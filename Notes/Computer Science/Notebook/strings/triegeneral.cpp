/*
Eventually perhaps I will come back here and compose a trie structure which supports deletion in a struct. Maybe to practise for interviews where the struct structure is relevant. One way to do so is to maintain prefix counts and delete from the back when that count is ==1 while deleting an entry. Another way to do it say we had a larger alphabet size like an alphabet of size 1000 uh could be like uh if we have at most say around 100000 words at a time but want to stream 10000000 operations of insertions and deletions then we could maintain a hash set of hashes with some underlying hash function so that the probability of collision is low e.g. with like long longs and then as we are walking back check each prefix is not already a word or has another offspring down tree works. But the earlier solution also works.
*/