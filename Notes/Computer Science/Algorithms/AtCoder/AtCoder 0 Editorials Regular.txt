A - +3 +5 +7 Editorial by evima Hints → https://atcoder.jp/contests/arc158/editorial/5987 [1] Change the problem In the problem, the values of x 1 ​ ,x 2 ​ ,x 3 ​ themselves do not quite matter; their differences do. Thus, the answer to the problem will not change if we may do the following at any time: add a constant number c to each of x 1 ​ ,x 2 ​ ,x 3 ​ . Particularly, the answer will remain the same if c is added to the numbers each time we do the (+3,+5,+7) operation. For instance, if we let c=−1, we may consider the problem with a (+2,+4,+6) operation instead of (+3,+5,+7); if we let c=−3, we have a (+0,+2,+4) operation. Here, we let c=−5 and consider the problem with a (−2,0,+2) operation. That is, we have the following operation: add −2 to one number and +2 to another. [2] The necessary condition The (−2,0,+2) operation does not change x 1 ​ +x 2 ​ +x 3 ​ . Thus, we can achieve x 1 ​ =x 2 ​ =x 3 ​ only if x 1 ​ +x 2 ​ +x 3 ​ is a multiple of 3. Assume that it holds and let a= 3 x 1 ​ +x 2 ​ +x 3 ​ ​ . Then, we need to make each x i ​ equal a by ±2 operations, so it is necessary that x i ​ and a have the same parity. Thus, we have the following necessary condition: a= 3 x 1 ​ +x 2 ​ +x 3 ​ ​ is an integer, and a,x 1 ​ ,x 2 ​ ,x 3 ​ have the same parity. [3] The sufficiency of the condition and the answer Assume that the above necessary condition holds and let d=∣x 1 ​ −a∣+∣x 2 ​ −a∣+∣x 3 ​ −a∣. We can verify the following. [A] One operation changes d by at most 4. [B] If d  =0, it is always possible to decrease d by 4. [A] can be seen from the fact that when x i ​ changes by ±2, ∣x i ​ −a∣ does not decrease by more than 2. [B] can be proved by considering the fact that when d  =0, there are i and j such that x i ​ <a and x j ​ >a, and adding +2 to x i ​ and −2 to x j ​ (note that ∣x i ​ −a∣≥2 if x i ​  =a, since x i ​ and a have the same parity). If the above necessary condition holds, [B] enables us to achieve the objective in 4 d ​ operations. Additionally, [A] shows that this is the minimum number of operations needed. Properly implementing the above solves the problem in O(1) time per test case. B - Sum-Product Ratio Editorial by evima Hints → https://atcoder.jp/contests/arc158/editorial/5987 The value in question is symmetric with respect to i,j,k, so let us forget the order 1≤i<j<k≤N and just choose distinct three numbers. Additionally, the sequence x may contain the same value multiple times, but let us order those occurrences of the same value in some way to distinguish all of them. [1] Narrow down the candidates Let us begin with a simple case: if x i ​ and x j ​ are already chosen, what are the optimal x k ​ ? If we let a=x i ​ +x j ​ and b=x i ​ x j ​ , the value is question can be written as: x i ​ x j ​ x k ​ x i ​ +x j ​ +x k ​ ​ = bx k ​ a+x k ​ ​ = b a ​ ⋅ x k ​ 1 ​ + b 1 ​ . It can be seen that this value is maximized (or minimized) when 1/x k ​ is maximum or minimum (depending on the signs of a and b, the maximum value of the objective function may correspond to either the maximum or minimum value of 1/x k ​ , but anyway, it is enough to check the maximum and minimum values of 1/x k ​ ). Even if we consider x i ​ and x j ​ , which are already chosen, we only need to consider six values for x k ​ : the ones with the three largest and three smallest values of 1/x k ​ . [2] Solution Let X be the multiset of elements x of the original sequence with the three largest and three smallest values of 1/x i ​ . We have seen that we only need to check x k ​ ∈X in search of an optimal solution. Similarly, it can be seen that we only need to check x i ​ ,x j ​ ∈X. Thus, we can solve the problem as follows. Sort the given sequence in ascending order of 1/x i ​ . Let X be the multiset of the first three and last three elements of the sorted sequence. Try all ways to choose three from X and print the minimum and maximum results. When sorting by 1/x i ​ , you can actually compute the values of 1/x i ​ or do the following: sort the negative numbers in descending order and the positive numbers in descending order, and then concatenate the results. This method has the time complexity of O(NlogN). Since it is not necessary to sort the whole sequence, and it is only necessary to select the top and bottom three, we can solve the problem in O(N) time, too. (Japanese version has some more information.) C - All Pair Digit Sums Editorial by evima Hints → https://atcoder.jp/contests/arc158/editorial/5987 [1] The sum of digits and carries When adding two integers a and b, if there are no carries, we have f(a+b)=f(a)+f(b). A carry trades 10 at some position for 1 at one higher position, so it decreases the sum of digits by 9. Thus, if there are k carries, f(a+b)=f(a)+f(b)−9k. Therefore, the answer can be computed as follows. [a] Compute ∑ i=1 N ​ ∑ j=1 N ​ (f(A i ​ )+f(A j ​ )). [b] Find the total number of carries when A i ​ +A j ​ is computed for every (i,j). [c] The answer is the sum in [a] minus the number in [b] multiplied by 9. The sum in [a] equals 2N∑ i=1 N ​ f(A i ​ ), which can be computed easily. Thus, we only have to compute the number in [b]. [2] Find the total number of carries Let us find the total number of carries when A i ​ +A j ​ is computed for every (i,j). This can be done by, for each k=0,1,…, finding the number of carries at the k-th lowest digit and summing them up. For a fixed k, the number of carries at the k-th lowest digit can be computed as follows. Let x i ​ be the remainder when A i ​ is divided by 10 k+1 . Find the number of (i,j) that satisfy x i ​ +x j ​ ≥10 k+1 . This number can be computed easily by sorting the sequence (x i ​ ) and then using binary search or two pointers. Therefore, the problem can be computed in a time complexity of O(KNlogN) where K is the maximum number of digits in A i ​ . One can also solve it in a time complexity of O(KN) by using the result of sorting A i ​ mod10 k in sorting A i ​ mod10 k+1 as in radix sort. D - Equation Editorial by evima Hints → https://atcoder.jp/contests/arc158/editorial/5987 Below, congruence modulo p is often denoted by an equal sign. We will ignore the condition x<y<z by sorting the solution after finding it. [1] A characteristic of the equality x i +y i +z i is a homogeneous polynomial of degree i, that is, all terms have a degree of i. Let F(x,y,z) and G(x,y,z) be the left-hand and right-hand sides of the given equation, and these are also homogeneous polynomials, which satisfy the following for any t,x,y,z: F(tx,ty,tz)=t 3n+1 F(x,y,z), G(tx,ty,tz)=t 3n G(x,y,z). [2] Solution Here is a strategy to find a solution to the equation. Choose some (a,b,c). Select t so that (x,y,z)=(ta,tb,tc) satisfies the equation. For a fixed (a,b,c), the equation F(ta,tb,tc)=G(ta,tb,tc) is equivalent to t 3n+1 F(a,b,c)=t 3n G(a,b,c). If F(a,b,c)  =0 and G(a,b,c)  =0, we can find a non-zero t satisfying this by t=G(a,b,c)/F(a,b,c). Thus, we can obtain a solution if we can choose (a,b,c) so that all of the following conditions are satisfied: a,b,c  =0, a  =b,a  =c,b  =c, a i +b i +c i  =0 for i∈{1,n,2n,3n}. Intuitively, if we randomly choose (a,b,c), it may seem that a i +b i +c i takes values between 0 and p−1 roughly randomly and we have a i +b i +c i =0 with probability about 1/p. This is wrong, and there are n and p such that we have a i +b i +c i =0 with probability considerably larger than 1/p, but we will prove later in [3] that even in such a case the randomized algorithm succeeds with large enough probability. Thus, the problem can be solved as follows. Keep randomly choosing a triple of integers (a,b,c) between 1 and p−1 until the above conditions are satisfied. Then, use it to find a solution (x,y,z)=(ta,tb,tc). The expected number of random choices is O(1) as shown in [3], and each choice involves raising numbers to the n-th power, so the expected time complexity is O(logn) per test case. [3] Evaluation of the probability of success Let us show the following lemma. 【Lemma】Let p be a prime number 5 or greater, and i be an integer. For integers a,b,c between 1 and p−1 randomly chosen, the probability that a i +b i +c i =0 is at most 1/4. Let S be the non-zero i-th powers, and m=∣S∣. m divides p−1, and for each s∈S, there are exactly m p−1 ​ numbers a such that a i =s. When m≥4, for a fixed (a,b) there are exactly 0 or m p−1 ​ numbers c such that a i +b i +c i =0, so our claim holds. When m=1, a i +b i +c i always equals 3, which is not 0 since p≥5. The case m=2 is similar since a i ,b i ,c i ∈{±1}. When m=3, if we let S={s 1 ​ ,s 2 ​ ,s 3 ​ }, then s i 3 ​ =1, and s 1 ​ +s 2 ​ +s 3 ​ =0. Since p≥5, if s 3 =1 then (−2s) 3  =1, so if i  =j then s i ​ +2s j ​  =0. Thus, we have a i +b i +c i =0 only if {a i ,b i ,c i }={s 1 ​ ,s 2 ​ ,s 3 ​ }, which happens with probability 27 6 ​ . Now the proof is complete. From【Lemma】and some simple observations, for a triple of integers (a,b,c) between 1 and p−1 randomly chosen, the following holds. The probability that a=b, a=c, or b=c is O(1/p). The probability that a+b+c is O(1/p). The probability that a n +b n +c n =0 is at most 1/4. The probability that a 2n +b 2n +c 2n =0 is at most 1/4. The probability that a 3n +b 3n +c 3n =0 is at most 1/4. Therefore, it has been proved that the randomized algorithm in [2] succeeds with probability at least 1/4−O(1/p). (Japanese version has some more information.) E - All Pair Shortest Paths Editorial by evima Hints → https://atcoder.jp/contests/arc158/editorial/5987 Let [L,R] denote the L-th, (L+1)-th, …, R-th columns, and X∈[L,R] denote the fact that X is a square in [L,R]. We use similar notations for half-open intervals [L,R)={i∣L≤i<R}. Let us write x i ​ =x 1,i ​ , y i ​ =x 2,i ​ for simplicity. For 1≤i≤N and X∈[1,i], let us define a i,X ​ , b i,X ​ as follows: a i,X ​ =f((1,i),X),b i,X ​ =f((2,i),X). Let S i ​ be the multiset of pairs of integers defined as S i ​ ={(a i,X ​ ,b i,X ​ )∣X∈[1,i]}. The answer ∑ X,Y ​ f(X,Y) can be found by computing ∑ (a,b)∈S i ​ ​ (a+b) for each i, which corresponds to finding the sum over the pairs (X,Y) such that the greater of their column numbers is i. Let us consider how to do this. By division into cases according to whether the two squares in the i-th column is in the path, we can see that the following hold for X∈[1,i−1]: a i,X ​ =min(a i−1,X ​ +x i ​ ,b i−1,X ​ +x i ​ +y i ​ ),b i,X ​ =min(a i−1,X ​ +x i ​ +y i ​ ,b i−1,X ​ +y i ​ ). Thus, if S i ​ is the multiset of pairs of integers defined as S i ​ ={(a i,X ​ ,b i,X ​ )∣X∈[1,i]}, we have: S i ​ ={min(a+x i ​ ,b+x i ​ +y i ​ ),min(a+x i ​ +y i ​ ,b+y i ​ )∣(a,b)∈S i−1 ​ }∪{(x i ​ ,x i ​ +y i ​ ),(x i ​ +y i ​ ,y i ​ )}. From case-by-case analysis, the pair (min(a+x i ​ ,b+x i ​ +y i ​ ),min(a+x i ​ +y i ​ ,b+y i ​ )) is equal to the following: ⎩ ⎪ ⎪ ⎨ ⎪ ⎪ ⎧ ​ (a+x i ​ ,a+x i ​ +y i ​ ) (a+x i ​ ,b+y i ​ ) (b+x i ​ +y i ​ ,b+y i ​ ) ​ (a−b<−x i ​ ) (−x i ​ ≤a−b≤y i ​ ) (y i ​ <a−b). ​ Note that the formula depends on a−b, and we are interested in a+b, and consider T i ​ ={(a−b,a+b)∣(a,b)∈S i ​ } instead of S i ​ , then the element of T i ​ for (a,b)∈T i−1 ​ is: ⎩ ⎪ ⎪ ⎨ ⎪ ⎪ ⎧ ​ (−y i ​ ,b+a+2x i ​ +y i ​ ) (a+x i ​ −y i ​ ,b+x i ​ +y i ​ ) (x i ​ ,b−a+x i ​ +2y i ​ ) ​ (a<−x i ​ ) (−x i ​ ≤a≤y i ​ ) (y i ​ <a). ​ For our objective, it is enough to find the difference between ∑ (a,b)∈T i−1 ​ ​ b and ∑ (a,b)∈T i ​ ​ b, which can be done by maintaining the number of elements of T i ​ for each a using a suitable data structure. We can, for example, use std::map in C++ to solve the problem in O(NlogN) time. It is also possible to use std::deque to solve it in O(N) time since we only have to retrieve the minimum and maximum values and insert elements. Sample submission: https://atcoder.jp/contests/arc158/submissions/39554314 (Japanese version has some more information.) F - Random Radix Sort Editorial by evima Hints → https://atcoder.jp/contests/arc158/editorial/5987 [1] Transform the condition Let us represent a way to execute the process as the sequence of chosen k: X=(k 1 ​ ,…,k M ​ ). When does X satisfy the condition? Stable sort does not reorder elements with the same values, so it can be uniquely determined which A i ​ each B i ​ derives from. B 1 ​ ,B 2 ​ ,…,B N ​ will be arranged in the desired order if and only if for every i, B i+1 ​ is to the right of B i ​ . Below, the “positional relationship” between B i ​ and B i+1 ​ means which of these two is to the left. Let us fix i and focus only on the positional relationship of B i ​ and B i+1 ​ . Each stable sort changes this positional relationship, where a and b are the k-th lowest digits of B i ​ and B i+1 ​ , respectively. If a<b, then B i+1 ​ will be to the right of B i ​ . If a=b, then the positional relationship of B i ​ and B i+1 ​ does not change. If a>b, then B i ​ will be to the right of B i+1 ​ . Thus, if S is the set of all k such that a<b, and T is the set of all k such that b<a, we will have the desired positional relationship of B i ​ and B i+1 ​ when the following conditions are satisfied. If there are elements of S and those of T in the sequence X, then the last of those occurrences is that of an element of T. Additionally, if B i ​ is to the right of B i+1 ​ in the initial state, then there is an element of T in X. Eventually, the problem can be transformed into the following one: Count sequences X=(k 1 ​ ,…,k M ​ ) that satisfy all O(N) conditions of the following two types. [Type 1] If there are elements of S and those of T in the sequence X, then the last of those occurrences is that of an element of T. [Type 2] There is an element of T in X. [2] Compute the answer For a sequence X=(k 1 ​ ,…,k M ​ ), let us define its subsequence Y that contains the last occurrence of each k. We can check whether X satisfies conditions of types 1 and 2 by checking whether Y satisfies the same conditions. Thus, we can first find the number of Y that satisfy the condition, and then find the number of corresponding X. [2 - 1] Count X corresponding to Y Let us count X corresponding to a length- n sequence Y=(y 1 ​ ,…,y n ​ ). X contains n kinds of values: y 1 ​ ,…,y n ​ . On the other hand, for the sequences X containing the n kinds of values y 1 ​ ,…,y n ​ , exactly 1/n! of them makes Y=(y 1 ​ ,…,y n ​ ). Thus, the number of X corresponding to a sequence Y is n! Surj(M,n) ​ , where Surj(M,n) is the number of surjections from an M-element set to an n-element set. [2 - 2] Count Y From [2 - 1], we can compute the answer if we can find the number of sequences Y for each ∣Y∣. Instead of sequences (y 1 ​ ,y 2 ​ ,…,y n−1 ​ ,y n ​ ), let us count increasing sequences of sets ∅⊊{y n ​ }⊊{y n−1 ​ ,y n ​ }⊊⋯. In other words, let us count the number of ways to construct the sequences from back to front. Then, a type- 1 condition can be written as: “no element of S should be added to any subset of T c .” Let us compute dp[s]: the number of increasing sequences leading to the set s without violating type- 1 conditions. We can compute this dp easily if, for each set s, the elements whose addition would violate type- 1 conditions are already enumerated. The elements that cannot be added to each set can be computed by first inserting the elements of S into T c and then propagating them toward their subsets in O(K2 K ) time (similarly to fast zeta transform and such). So far, we have not considered type- 2 conditions, but to do so, we only have to exclude some s from the computed dp[s]. The s to exclude can also be computed in O(K2 K ) time. From all of the above, the problem can be solved in a time complexity of O(KN+K2 K +KlogM). A - XXYYX Editorial by evima If we fix the first and last characters of S, the difference between the numbers of XY and YX will be uniquely determined, independent of the middle characters. For instance, if S begins with X and ends with Y, then XY must occur one more time than YX, and we have B−C=1. By considering the other cases similarly, we can see that ∣B−C∣≤1 must hold for the answer to be Yes. When ∣B−C∣=1, a desired string S always exists. For now, let us ignore the conditions on A and D and let: S ′ =XYXY…XY (the concatenation of B XYs) if B−C=1, and S ′ =YXYX…YX (the concatenation of C YXs) if B−C=−1. Then, add (A−1) Xs and (D−1) Ys at the beginning and end of S ′ accordingly to obtain a desired string S. When ∣B−C∣=0, the answer is again Yes if B>0. You can, for instance, let S ′ =XYXY…XYX (the concatenation of B XYs followed by one X) and then add (A−1) Xs and (D−1) Ys in S ′ accordingly to obtain a desired string S. Finally, when B=C=0, the only possible forms of the string are XXX…X and YYY…Y, so the answer is Yes if and only if at least one of A and D is 0. B - XYYYX Editorial by evima Let x be the number of Xs in S. If x=N, the answer is 0 if K≤1 and K−1 if K>1. Below, assume x<N. When K≤x, it is clearly disadvantageous to choose Ys and turn them into Xs, so we may assume you choose K Xs and turn them into Ys. Intuitively, you can choose X adjacent to Y and turn it into Y to get one YY, and you can choose all Xs in a segment YXX…XY (one or more Xs between Ys) to get one extra YY, so you should choose such segments YXX…XY greedily in ascending order of length. After pre-computations such as counting those segments for each length naively, the problem can be solved in a total of O(N) time. The validity of the greedy strategy When K>x, it is clearly disadvantageous not to choose some Xs, so we may assume you choose all Xs. Then, you have to choose (K−x) Ys to turn them into Xs. From a different perspective, out of the (N−x) Ys, (N−K) will not be chosen and remain to be Ys. Here, if we invert the Xs and Ys in the input string, the problem can be seen as choosing (N−K) from the (N−x) Xs and turn them into Ys, which can be reduced to the former case. C - YY Square Editorial by evima Assume that the contribution of the YYs in str(P) to the score are 1,3,5,… from left to right. Indeed, if YY occurs k times in str(P), the score is k 2 , and we have: 1+3+5+⋯+(2k−1)= i=1 ∑ k ​ (2i−1)=k 2 . If, for every pair of adjacent Ys in the grid, we can compute its total contribution over all possible paths, the answer is the sum of those values. Assume that both (i,j) and (i+1,j) have Y written on them, where 1≤i<H, 1≤j≤W. Then, the total contribution of this YY is a+2b, where: a is the number of paths containing the move (i,j)→(i+1,j), and b is the total number of times those paths move between adjacent Y squares before reaching (i,j). Here, we have: a=( i−1 i+j−2 ​ )×( H−i−1 H+W−i−j−1 ​ ). Let dp(i,j) be the total number of times the paths move between adjacent Y squares before reaching (i,j). After computing these by naive dynamic programming (DP), we can compute: b=dp(i,j)×( H−i−1 H+W−i−j−1 ​ ). Computing dp(i,j) We can similarly process a horizontal pair of (i,j) and (i,j+1), both of which have Y written on them, where 1≤i≤H, 1≤j<W. The DP in the pre-computation and the computation of the total contribution both take O(HW) time, which is the complexity of this solution. D - YY Garden Editorial by evima If the grid has an odd number of Ys, the answer is clearly 0. Below, assume that this number is even, and let y be half this value. If you set up fences to satisfy the condition, there must be exactly y blocks since each block has exactly two Y squares. Thus, if we let h and w be the number of fences between rows and between columns, respectively, we have (h+1)(w+1)=y. This means the value of h+1 can only be divisors of y. Let us try all of these values that satisfy the following: 0≤h<H, 0≤w= h+1 y ​ −1<W. For a fixed pair (h,w) satisfying the above, there is essentially a single way to set up fences. This is because: if just the h fences between rows are set up, each block must have exactly 2(w+1) Ys, and if just the w fences between columns are set up, each block must have exactly 2(h+1) Ys. However, if there is a row or column consisting of just X, you may set up a fence on either side of that row or column. The number of ways to set up fences is the product of these degrees of freedom, or 0. Let us pre-compute the two-dimensional cumulative sums of the number of Ys from the top-left corner, naively in O(HW) time. Then, we can find the positions to install fences (and the degree of freedom) to satisfy the necessary conditions for rows and columns in O(H+W) time. Additionally, if there are positions to install fences to satisfy both of those conditions, we can check whether the original condition (two Ys in each block) is satisfied in O(y) time. The total complexity is O(HW+k(H+W+y)), where k is the number of pairs (h,w) to try. Under the constraints, we have k≤80, ky≤6.1×10 7 (try all possible y’s to see this), and the constant factor is not large, so it runs in time. E - XXYX Binary Tree Editorial by evima Since there is no YY, the vertices with Ys written on them must form an independent set (a set of vertices, no two of which are adjacent) in the tree. Additionally, since every vertex has zero or two children, C must be even. When N=1, we have A=B=C=0, in which case writing either X or Y satisfies the condition, so the answer is Yes. Below, assume N≥3. First, since there are C YXs, so there must be exactly 2 C ​ Ys written on non-leaf vertices (a leaf is a vertex without children). Additionally, depending on the character written on the root, one of the following must hold. If X is written on the root, exactly B Ys should be written in total, and exactly B− 2 C ​ of them should be written on leaves. If Y is written on the root, exactly B+1 Ys should be written in total, and exactly B− 2 C ​ +1 of them should be written on leaves. On the other hand, if all of the necessary conditions above are satisfied, it can be seen that the original condition ( A XXs, B XYs, C YX, and zero YYs) is automatically satisfied. Thus, it is enough to know the maximum total number of Ys that can be written when exactly y Ys should be written on the leaves and the vertices with Ys written on them should form an independent set. You can compute this by dynamic programming (DP) from the leaves to the root where dp(v,y,z) (1≤v≤N, 0≤y≤ℓ v ​ , z∈{0,1}) is the answer to the above question for the subtree rooted at vertex v when writing X on the root if z=0 and Y if z=1. Here, ℓ v ​ denotes the total number of leaves in the subtree rooted at vertex v. There are at most ℓ 1 ​ = 2 N+1 ​ ≤5000 leaves, so the total complexity is v=1 ∑ N ​ (⌈ 2 ℓ v ​ ​ ⌉+1) 2 =O(N 2 ). (This is the so-called square tree DP. See ABC287-F Components for instance.) F - XY Ladder LCS Editorial by evima Here is the key observation: you can always make the length of the longest common subsequence (LCS) at least ⌊ 3 2N ​ ⌋. This can be seen by dividing the pair of input strings into intervals of length 3 (and the remainder) and observing the following in each interval. For an interval of length 1, the length of the LCS is 0 in the worst case where different characters are paired. For an interval of length 2, if the first characters of the two strings are the same, the length of the LCS is already at least 1; otherwise, you can always match one of them to the second character of the other string, so the length of the LCS is at least 1. For an interval of length 3, if the first or third characters of the two strings are the same, the case will be reduced into the case with length 2, and the length of the LCS is at least 2; if the first characters and third characters are both different in the two strings, you can always match both of them to the second characters, so the length of the LCS is at least 2. (For an interval of length 4, one of the worst cases is the pair of XXYY and YXYX, in which case the length of the LCS is 2 after any combination of swaps.) From this observation, an optimal solution never matches two characters with a distance greater than ⌈ 3 N ​ ⌉. Thus, the problem can be solved by letting dp(k,R) (0≤k≤N, ∣R∣≤⌈ 3 N ​ ⌉) be the tentative lexicographically smallest LCS made from the first k characters of the two strings while leaving the string R unmatched and available, and computing these values in ascending order of k by dynamic programming (DP). The total complexity will be O(N2 3 N ​ ) by properly encoding R and dp(k,R) into 64-bit integers and pre-computing the transitions that are independent of k. Encoding R and dp(k,R)The strings of length at most N consisting of X and Y can correspond one-to-one to the bit sequences representing positive integers less than 2 N+1 in binary. Specifically, X and Y should be replaced with 1 and 0, respectively, and the topmost bit that is 1 should just be seen as the representation of the length. For instance, XXY corresponds to (1110) 2 ​ =14, YY corresponds to (100) 2 ​ =4, and the empty string corresponds to (1) 2 ​ =1. Comparing integers in this representation is equivalent to comparing the original strings based on length and reversed lexicographical order (length is prioritized), so you can compute the transitions of the DP by comparing 64-bit integers normally. Pre-computing the transitions In the above encoding, R corresponds to a positive integer less than 2 18 in the largest case. When matching an unused character, it is not disadvantageous to greedily use the leftmost character available. Thus, for each positive integer less than 2 18 , you can naively pre-compute the first positions of 0 and 1, ignoring the topmost 1, in the binary representation of that integer to compute each transition in constant time. The complexity of the pre-computation is also O(N2 3 N ​ ). A - Non-Adjacent Flip Editorial by evima [1] Division into cases based on the number of 1 Let k be the number of 1 in S. In each operation, k increases by 0, +2, or −2, so the objective is unachievable if k is odd. Below, assume that k is even. The case k=0 Nothing to consider. The case k≥4 Let x 1 ​ ,x 2 ​ ,…,x k ​ be the coins showing heads from left to right. Then, one can achieve the objective in 2 k ​ operations by flipping coins 1 and x 2 k ​ +1 ​ , coins 2 and x 2 k ​ +2 ​ , and so on. The case k=2 If the coins showing heads are not adjacent, the answer is 1. Below, assume that they are adjacent, and let x be the coin to the left. If x≥3, one can achieve the objective in two operations by flipping coins 1 and x and then flipping coins 1 and y. If x+1≤N−2, one can again achieve the objective in two operations by flipping coins 1 and N and then flipping coins x and y. Neither of the above is satisfied if x<3 and x+1>N−2, which happens only if N=3 or 4. If N=3, then S is 011 or 110, in which case one can only flip coins 1 and 3, so the objective is unachievable. If N=4, x<3, and x+1>N−2, then S is 0110, in which case the objective is achievable in three operations (0110 →1111 →0101 →0000). One can show by brute force that it cannot be achieved in two operations. All these conditions can be checked in O(N) time. B - Mex on Blackboard Editorial by evima [1] Fixing the largest integer to write Let x be the largest integer you write. You can write x only if the blackboard has 0 through x−1. Here, if the initial blackboard does not have x−1, you need to write x−1. By repeating this recursive argument, we can see that you need to perform the following number of operations to write x for the first time: the number of integers not on the initial blackboard + 1 (in which you write x). [2] Counting Let us try all possible values of x. After writing x for the first time, you can write any integer between 0 and x. Additionally, from the above argument, there is a unique way to perform the minimum number of operations before writing x for the first time. From these facts, the problem can be reduced to the following one, where M is the minimum number of operations needed to write x for the first time. Let us write an integer between 0 and x exactly K−M. How many multisets can be obtained in this way? This is a famous problem of combination with repetition. There is a one-to-one correspondence between the set of such multisets and the ways to arrange K−M balls and x bars in a row, so there are ( x K−M+x ​ ) such multisets. This value can be computed in O(1) time after pre-computing the factorials. The possible values of x are 0 through N+K−1, so the problem is solved in O(N+K) time. C - Tree and LCS Editorial by evima [1] Constructing a solution You can always construct a permutation with the similarity of 1. We will first present an algorithm to construct it and then show that its similarity is 1. Algorithm Step 0. Prepare a sequence P of length N whose elements are undecided. Step 1. Insert all leaves of the tree into a queue. Step 2. Repeat the following as long as the queue has two or more vertices. Remove two vertices from the queue (let u and v be the removed vertices). Let P u ​ =v and P v ​ =u. Remove the vertices u and v from the tree T. If there are leaves after this removal, put all of them into the queue. Step 3. After Step 2, the queue contains one vertex x only if N is odd. Let P x ​ =x. Proof of the validness First, the above algorithm assigns each of 1,2,…,N to P exactly once, so P is indeed a permutation. Next, let us prove by induction that the similarity of P is 1. For N=1,2, the algorithm constructs a permutation with the similarity of 1. Consider the case N≥3. Let a and b be the first two vertices removed in Step 2. From the assignment of a and b to P, there is no path for which a longest common subsequence contains both a and b. If a common subsequence contains a, it follows from the assignment that such a subsequence has a length of 1. The same goes for b. From this, we get a problem whose size is reduced by 2. Repeat this to complete the proof. D - Xor Sum 5 Editorial by evima [1] Rephrasing the problem Below, consider coefficients of polynomials modulo 2. From x⊕x=0, our objective is to find the total XOR of S such that [x S ](x A 1 ​ +x A 2 ​ +⋯+x A N ​ ) K is 1. Here, we have: (x 1 ​ +x 2 ​ +…x n ​ ) 2 ≡x 1 2 ​ +x 2 2 ​ +…x n 2 ​ +2∑ i<j ​ x i ​ x j ​ ≡x 1 2 ​ +x 2 2 ​ +…x n 2 ​ . By using this repeatedly, we can show that: (x 1 ​ +x 2 ​ +…x n ​ ) 2 k ≡x 1 2 k ​ +x 2 2 k ​ +…x n 2 k ​ . Thus, if we write K in binary and have K=∑ i=1 M ​ 2 k i ​ (k i ​ <k i+1 ​ ), it holds that: [x S ](x A 1 ​ +x A 2 ​ +⋯+x A N ​ ) K ≡[x S ]∏ i=1 M ​ (x A 1 ​ ×2 k i ​ +x A 2 ​ ×2 k i ​ +⋯+x A N ​ ×2 k i ​ ). Therefore, the problem can be rephrased into finding the total XOR of ∑ i=1 M ​ A X i ​ ​ ×2 k i ​ . (For this part [1], you can also use Lucas’s theorem.) [2] Dynamic programming For the above problem, let us decide X 1 ​ , X 2 ​ ,…,X M ​ in this order to compute the result from the lowest bit. Deciding X m ​ after deciding X 1 ​ ,X 2 ​ ,…,X m−1 ​ will settle the k m ​ -th through (k m+1 ​ −1)-th bits of ∑ i=1 M ​ A X i ​ ​ ×2 k i ​ . Thus, for ∑ i=1 m ​ A X i ​ ​ ×2 k i ​ , in the later computations (including the computation of the final answer), we just have to consider the k m ​ -th and higher bits (that is, just ⌊ 2 k m ​ 1 ​ ∑ i=1 m ​ A X i ​ ​ ×2 k i ​ ⌋). This value is at most 2max(A), so we have to compute: dp[m][s]: the number, modulo 2, of combinations of X 1 ​ ,X 2 ​ ,…X m ​ such that ⌊ 2 k m ​ 1 ​ ∑ i=1 m ​ A X i ​ ​ ×2 k i ​ ⌋=s just for s≤2max(A), which can be done in O(NMmax(A)) time. The k m ​ -th through (k m+1 ​ −1)-th bits of the final answer can be computed from dp[m][s], but note that X m+1 ​ ,X m+2 ​ ,…,X M ​ are undecided, so the contribution depends on the parity of N M−m . E - Non-Adjacent Matching Editorial by evima [1] The necessary and sufficient conditions for a good sequence X is a good sequence if and only if both of the following hold: S:=∑ i=1 N ​ X i ​ is even. X i ​ +X i+1 ​ ≤ 2 S ​ for any i (1≤i≤N). Here, regard X N+1 ​ as X 1 ​ . Let us prove this. The necessity is simple. The sum of the degrees in a graph is always even, so S must be even. Additionally, if there is i such that X i ​ +X i+1 ​ > 2 S ​ , there must be at least X i ​ +X i+1 ​ edges, violating the condition for a good sequence. Let us show the sufficiency. We introduce auxiliary variables B i ​ = 2 S ​ −(X i ​ +X i+1 ​ ). Additionally, let us define the following operation: choose u and v that are not adjacent, and decrease X u ​ and X v ​ by 1. Then, our objective is to show that one can always perform the operation so that all B i ​ stay non-negative. Let us first consider how the operation affects B. When the operation is performed on u and v, each of B u−1 ​ ,B u ​ ,B v−1 ​ ,B v ​ increases by 1, and then every element of B decreases by 1. If minB is 1 or greater, the operation may be performed arbitrarily. Consider the case minB=0. Basically, one should choose i such that B i ​ =0 and perform the operation on i and i+2 or i−1 and i+1 where it is possible. If this is impossible, one can pair each of X i ​ and X i+1 ​ with any other element to perform the operation, so our claim holds. [2] Applying the principle of inclusion-exclusion The condition “ X i ​ +X i+1 ​ ≤ 2 S ​ for any i” is difficult to handle, so let us use the principle of inclusion-exclusion. Here, it is important to observe that this condition is violated by at most two indices i. Additionally, such i’s are adjacent, because if the condition were violated by two indices that are not adjacent, the sum would exceed S. In the counting below, we use formal power series. Let f(x)=1+x+…+x M = 1−x 1−x M+1 ​ . [2-1] The total number of sequences This number is the sum of [x i ]f N (x) over all even numbers from 0 to K. Let us try to find this. The sought value is equal to [x k ] 1−x 2 f N (x) ​ . Let g(x)= 1−x 2 (1−x M+1 ) N ​ and find g first. This can be done in O(N+K) time by expanding the numerator using binomial theorem and dividing it by (1−x 2 ) using the fact that the denominator is “sparse”. Next, let us find [x k ]g(x)(1−x) −N . The sequence of coefficients in (1−x) −N can be found in O(N+K) time using negative binomial theorem, so the total number of sequences can be found in O(N+K) time. [2-2] The case with one fixed position of violation Let us find the sum of the numbers of sequences when the condition must be violated at one fixed position. We will find the count for i=1 and then multiply it by N using the arbitrariness of i. Let us fix the sum S and t:=X 1 ​ +X 2 ​ . Note that we only have to consider the values of S less than 4M. For (X 1 ​ ,X 2 ​ ), the number of possible pairs of values can be found in O(1) time. For the remaining X 3 ​ ,…,X N ​ , there are [x S−t ]f N−2 possible combinations of values. To find the above value in O(1) time, find the first 4M+1 terms of f N−2 beforehand, which can be done in, say, O(MlogM) or O(M 2 ) time. Thus, the sum of the numbers of sequences when the condition must be violated at one fixed position can be found in O(M 2 ) time. [2-3] The case with two fixed positions of violation Next, let us find the sum of the numbers of sequences when the condition must be violated at two fixed positions. Again, we will find the count for i=1,2 and then multiply it by N. Let us fix the sum S and then try all values for u:=X 1 ​ +X 2 ​ +X 3 ​ . We want to count the triples (X 1 ​ ,X 2 ​ ,X 3 ​ ) such that X 1 ​ +X 2 ​ > 2 S ​ ,X 2 ​ +X 3 ​ > 2 S ​ ,X 1 ​ +X 2 ​ +X 3 ​ =u for every u under the fixed S. Let us try all X 2 ​ . Assume X 2 ​ =v and let l=max(S/2−1−v,0), then the number of sought triples (X 1 ​ ,v,X 3 ​ ) is 0 if l>m and x v (x l +x l+1 +…+x m ) 2 otherwise. If we naively add this every time, it will take O(M 2 ) time. However, if we transform the formula as x v (x l +x l+1 +…+x m ) 2 = (1−x) 2 x v (x l −x m+1 ) 2 ​ , the common denominator enables us to compute the numerator first, and then do the division in the end. With this improvement, the complexity is now O(M). The rest is the same as the earlier case. Again, the sum can be found in O(M 2 ). [2-1] through [2-3] solve the problem in O(M 2 +K+N) time. F - Make Same Set Editorial by evima Let M be the greatest value in all of A i ​ ,B i ​ ,C i ​ . [1] A new option Consider relaxing the first and second conditions into the following. It can be obtained as follows: start with an empty set, and for each i=1,2,…,N in this order, add A i ​ , B i ​ , or nothing to the set. It can be obtained as follows: start with an empty set, and for each i=1,2,…,N in this order, add A i ​ , C i ​ , or nothing to the set. In this case, the sought set can be constructed based on the maximum flow in the following network with 2+2N+2M vertices. The number of elements in a set constructed in this way gives an upperbound to the number of elements in a set satisfying the conditions in the original problem. Vertex S is the source, and vertex T is the sink. Vertex i (1≤i≤N) corresponds to choosing A i ​ or B i ​ , and vertex N+i (1≤i≤N) corresponds to choosing A i ​ or C i ​ . Vertices 2N+A i ​ and 2N+B i ​ correspond to A i ​ and B i ​ , respectively, and vertices 2N+M+A i ​ and 2N+M+C i ​ correspond to A i ​ and C i ​ , respectively. For 1≤i≤N, there are edges of capacity 1 from vertex 1 to vertices 2N+A i ​ and 2N+B i ​ . For 1≤i≤N, there are edges of capacity 1 from vertices 2N+M+A i ​ and 2N+M+C i ​ to vertex N+i. For 1≤x≤M, there is an edge of capacity 1 from vertex 2N+x to vertex 2N+M+x. Below is a network for A,B,C in Sample 1 (the labels of vertices are modified to be more descriptive). If we are to construct a set satisfying the conditions in the original problem, we are in trouble with i such that both 2N+A i ​ and 2N+B i ​ are without flow. Below, a vertex i for such an i is called no-selection vertex (the same goes for vertex N+i for i such that both 2N+M+A i ​ and 2N+M+C i ​ are without flow). In the figure below, no-selection vertices for a flow along the path B 3 ​ →3→3→A 3 ​ or C 3 ​ →T are shown as squares. [2] The relation between augmenting paths and no-selection vertices The maximum flow in a network can be constructed by repeatedly sending flow along an augmenting path from S to T in the residual network, with reverse edges for the edges with flow. When we send flow along an augmenting path, how will the set of no-selection vertices change? Actually, if we send flow along a shortest (with the fewest number of edges) S−T path, there will be no new no-selection vertices. To prove this, let us show this: (there is an augmenting path such that there will be a new no-selection vertex if we send flow along that path) ⟹ (there is a shorter augmenting path). Consider the example below. If we send flow along the red augmenting path, “A5orB5” will be a new no-selection vertex. However, this vertex should have no flow, so we can use the blue augmenting path instead. This path is shorter than the red one. Let us generalize this. Assume that if we send flow along some augmenting path, vertex i will be a new no-selection vertex. Then, the augmenting path has the form S→⋯→N+j→2N+M+x→2N+x→⋯→T (x∈{A i ​ ,B i ​ }). Here, from the definition of no-selection vertex, vertex i should have no flow, so we can take the augmenting path S→i→2N+x→⋯→T. There are at least four edges from vertex S to vertex N+j, so this augmenting path is shorter than the original one. Also, we can similarly take a shorter augmenting path even if the vertex to be the new no-selection vertex is vertex N+i. Thus, we have (there is an augmenting path such that there will be a new no-selection vertex if we send flow along that path) ⟹ (there is a shorter augmenting path), so if we take a shortest augmenting S−T path and send flow along it, there will be no new no-selection vertices. Dinic’s algorithm, which finds the maximum flow and is available in AtCoder Library, uses shortest augmenting paths, so it can send flow without creating new no-selection vertices. [3] Solution If we start with a residual network without no-selection vertices and use the observation in [2], the maximum flow considered in [1] can restore a set that achieves the upperbound and satisfies the first and second conditions. To start with such a residual network, we should take a set that satisfies the first and second conditions and send the corresponding flow beforehand. Clearly, {A 1 ​ ,A 2 ​ ,…,A N ​ } is one such set. Therefore, the problem can be solved in O(N N ​ ) time. A - ST and TS Palindrome Editorial by evima Let rev(S) denote the reversal of S. Additionally, let S+S ′ denote the concatenation of S and S ′ in this order. [1] The case K<2N If K<2N, the leftmost min(N, K) characters of S ′ must equal rev(S), and so must the rightmost min(N, K) characters, so there is at most one string S ′ that can potentially satisfy the conditions. You just have to check if it does. [2] Reduce the case 2N≤K to [1] If 2N≤K, similar observations can rephrase the problem as follows. There is S ′ (∣S ′ ∣=K) such that S+S ′ , S ′ +S are both palindromes ⟺ There is S ′ (∣S ′ ∣=K−2N) such that S+rev(S)+S ′ +rev(S), rev(S)+S ′ +rev(S)+S are both palindromes ⟺ There is S ′ (∣S ′ ∣=K−2N) such that rev(S)+S ′ , S ′ +rev(S) are both palindromes ⟺ There is S ′ (∣S ′ ∣=K−2N) such that rev(rev(S)+S ′ ), rev(S ′ +rev(S)) are both palindromes ⟺ There is S ′ (∣S ′ ∣=K−2N) such that rev(S ′ )+S, S+rev(S ′ ) are both palindromes ⟺ There is S ′ (∣S ′ ∣=K−2N) such that S ′ +S, S+S ′ are both palindromes Therefore, one may replace K with Kmod2N, reducing the problem to the case K<2N. Therefore, the problem can be solved in O(N) time per test case. B - Abs Abs Function Editorial by evima Observing the graph reveals ∣∣x−a∣−b∣=min(∣x−(a−b)∣, ∣x−(a+b)∣). Thus, if we define an integer set S ′ ={a−b, a+b∣(a, b)∈S}, we have f S ​ (x)=min y∈S ′ ​ ∣x−y∣. Then, for a type- 2 query, if S ′ has an element between a i ​ and b i ​ , the answer is 0. Otherwise, it is min(a i ​ −L, R−b i ​ ), where L is the largest element less than a i ​ and R is the smallest element greater than b i ​ . You can maintain S ′ with std::set or similar data structures to check the existence of an element between a i ​ and b i ​ and find L and R in O(logQ) time. Therefore, the problem can be solved in O(QlogQ) time. C - Even Sum Triplet Editorial by evima There are two kinds of operations: one on two odd terms and one even term, and one on three even terms. Performing an operation does not affect the availability of the former, so the answer is No if it can be done in A but not in B, or vice versa. [1] If odd terms cannot be moved in both A and B In this case, the odd terms in A must coincide with those in B for the answer to be Yes. If they do, we may split the sequences at the odd terms to reduce the problem into the case that all terms are even. If all terms are even, one can swap any two adjacent terms if the length of the sequence is at least 3. Thus, if the length is 2 or less, the answer is Yes if and only if A and B are equal as sequences; if the length is 3 or greater, the answer is Yes if and only if A and B are equal as multisets. [2] If odd terms can be moved in both A and B The operation is reversible, so we may consider whether A and B can be turned into the same sequence to solve the problem. First, let us try to move all odd numbers to the beginning of the sequence. If A i ​ ,A i+1 ​ , …,A i+k−1 ​ (2≤k) are odd and A i+k ​ is even, one can repeat the operation to rearrange them into A i+k ​ , A i ​ , A i+1 ​ , …, A i+k−1 ​ . Repeating this process can move all odd numbers to the beginning of the sequence. (If there are no two adjacent odd numbers initially, create them by an operation involving odd terms.) After separating the odd and even terms, can we sort the odd terms? For instance, if A 1 ​ , A 2 ​ , …, A k ​ are odd and A k+1 ​ , A k+2 ​ , …, A N ​ are even, can we swap A i ​ and Ai+1 (i<k)? The answer is yes: you can move the even A k+1 ​ one by one as A k−1 ​ , A k ​ , A k+1 ​ →A k−1 ​ , A k+1 ​ , A k ​ to make the arrangement A i ​ , A i+1 ​ , A k+1 ​ , perform the swap as A i ​ , A i+1 ​ , A k+1 ​ →A i+1 ​ , A i ​ , A k+1 ​ , and then put A k+1 ​ to the original position. Thus, any two adjacent odd terms can be swapped, so we can sort all odd terms. For even terms, if there are three or more of them, any two adjacent ones can be swapped, so we can sort all even terms. If there are two, we cannot perform an operation involving both, so they cannot be swapped. Therefore, if the number of even numbers in each of A and B is not 2, the answer is Yes if and only if A and B are equal as multisets; if the number of even numbers in each of A and B is 2, the answer is Yes if and only if A and B are equal as multisets and contain the two even numbers in the same order. One can check the availability of the operation involving odd numbers in O(N) time, and the equality of multisets in O(NlogN) time, which is fast enough. D - Avoid Coprime Game Editorial by evima Let M=max(A). In this kind of problem, the first solution that comes to mind could be a bit DP that maintains the integers remaining on the blackboard, but it is way too slow for the case N=2×10 5 . How can we avoid enumerating all possible sets of remaining integers on the blackboard? Here is an important fact: if 1<gcd(A i ​ , G)<G for some A i ​ , then A i ​ always remain on the blackboard. Thus, if we only consider such operations that make G smaller, we may ignore the set of the remaining integers. Then, a potential issue is a situation where it is optimal for both players to play so that G does not change. However, in such a situation, they will keep choosing a multiple of G until there is none, so one can foresee from the parity of the number of multiples of G which player will be stuck and have to make G smaller. The observation above suggests that the winner from a certain situation depends only on the current G and the current player to play. This can be proved by induction on G. Thus, we can define and compute the following DP table: dp[g][p]: the winning player if the current G is g and the current player is p. Here, we have to check if there is A i ​ such that gcd(A i ​ , g)=d for each divisor d (d  =g), and find the parity of the number of multiples of g among A i ​ . The latter can be precomputed in O(MlogM) time. For the former, let f g,d ​ be the number of A i ​ such that gcd(A i ​ , g)=d. If A i ​ is a multiple of d, then gcd(A i ​ , g) is a multiple of d and a divisor of g, so the sum of f g,d ′ ​ over all integers d ′ that are multiples of d and divisors of g equals the number of divisors of d among A i ​ . Thus, we can compute f g,d ​ in descending order of d. To evaluate the complexity of this method, let us evaluate the number of triples (a, b, c) (1≤a≤b≤c≤M) such that b is a multiple of a and c is a multiple of b, which are what we eventually seek. For a fixed A, there are O( A M ​ log A M ​ ) pairs of b and c, so there are O(Mlog 2 M) triples. Therefore, the problem can be solved in O(N+Mlog 2 M) time, which is fast enough. E - Split and Square Editorial by evima Below, we see the integers less than 2 M and bitwise XOR ⊕ as the elements and addition in the vector space F 2 M ​ , and use the terms in linear algebra. [1] The change in the number of bases Let e 1 ​ , e 2 ​ , …, e n ​ (e i ​ ∈S) be the bases of the subspace spanned by the elements of S. After an operation that divides the bases into {e 1 ​ , e 2 ​ , …, e m ​ }⊂T 1 ​ and {e m+1 ​ , e m+2 ​ , …, e n ​ }⊂T 2 ​ , it will hold that {e 1 ​ ⊕e 2 ​ , e 1 ​ ⊕e 3 ​ , …, e 1 ​ ⊕e m ​ , e m+1 ​ ⊕e m+2 ​ , e m+1 ​ ⊕e m+3 ​ , …, e m+1 ​ ⊕e n ​ }⊂S. These elements are linearly dependent, so S will have at least n−2 bases. How to reduce the number of bases? For instance, consider this case: let us represent every element of S as a linear combination of e i ​ , and put to T 1 ​ all elements whose representation uses e 1 ​ , and to T 2 ​ the rest. After this operation, every element of S will be representable as a linear combination of e i ​ without using e 1 ​ , so there are at most n−1 bases. [2] When can we decrease it by 2? We have seen how to decrease the number of bases by at least 1. What remains is to see when it can be decreased by 2. Assume that the operation is performed by dividing the bases into {e 1 ​ , e 2 ​ , …, e m ​ }⊂T 1 ​ and {e m+1 ​ , e m+2 ​ , …, e n ​ }⊂T 2 ​ . To get n−2 bases, every element of S after the operation must be representable by a linear combination of e 1 ​ ⊕e i ​ (2≤i≤m) and e m+1 ​ ⊕e j ​ (m+2≤j≤n). This is equivalent to being representable as a linear combination of e i ​ using: an even number of elements from e 1 ​ , e 2 ​ , …, e m ​ , and an even number of elements from e m+1 ​ , e m+2 ​ , …, e n ​ . Based on this, let us consider how we should allocate the elements of S to T 1 ​ and T 2 ​ . We have e 1 ​ ∈T 1 ​ , so an element to assign to T 1 ​ must be representable as a linear combination of e i ​ using: an odd number of elements from e 1 ​ , e 2 ​ , …, e m ​ , and an even number of elements from e m+1 ​ , e m+2 ​ , …, e n ​ , and vice versa for an element to assign to T 2 ​ . Thus, the number of bases can be reduced by 2 if and only if every element of S is representable as a linear combination of e i ​ using an odd number of them. Particularly, 0∈S always holds after one operation, so this can be done only in the first operation. [3] Summary Therefore, if there are n bases initially, the answer is n if n≤1 or the condition in [2] is not satisfied, and n−1 otherwise. One can find the bases and check if the condition holds in O(NM 2 ) time by the sweeping-out method, which is fast enough. F - Directable as Desired Editorial by evima [1] Double counting Considering it from the leaves, there is a unique way, if any, to direct a tree to satisfy the condition. Thus, instead of undirected trees, let us count labeled directed trees where each vertex has the outdegree D i ​ . One method frequently used in counting trees with labeled vertices is double counting, which is applicable to this problem. Let A be the answer to the problem, and B be the number of rooted trees where: the root may be any of the N vertices, and the D i ​ edges going out from each vertex i are labeled with integers from 1 to D i ​ . Then, B=A×N×∏ i=1 N ​ D i ​ !, so finding B will also find A. [2] Construction of the rooted trees The rooted trees can be constructed as follows. Additionally, for each of them, there is a unique way to construct it in this method. Decide a set S of vertices with an edge toward the root. For each i∈S, choose from the D i ​ edges the one toward the root, and decide its ending vertex. Decide the ending vertices of the other edges. Consider the number of ways to perform the third step after completing the first and second. Let us decide the ending vertex of the edges in ascending order of (the index of the starting vertex, the edge’s label). As the ending vertex, one can choose any vertex without a parent and outside the (weakly) connected component to which the edge belongs. Initially, there are N−∣S∣ vertices without a parent, and this number decreases by 1 each time, so there are (N−∣S∣−1)! ways to perform the third step. Particularly, this number is independent of the second step. Next, consider the number of ways to perform the second step. There are ∏ i∈S ​ D i ​ ways to choose the edges toward the root. For the number of ways to choose their ending vertices, observe that it equals the number of rooted forests with N labeled vertices and ∣S∣ edges such that the set of vertices with a parent is S. For now, we will ignore the condition that the set of vertices with a parent should be S. Let us start with N vertices and 0 edges and repeat the following ∣S∣ times to make a rooted forest: connect to a vertex u another vertex v without a parent and outside the connected component to which u belongs. There are ∏ i=1 ∣S∣ ​ N×(N−i)=N ∣S∣ × (N−∣S∣−1)! (N−1)! ​ ways to choose u and v, and after removing duplicates that only differ by the order the edges are added, there are N ∣S∣ × ∣S∣!(N−∣S∣−1)! (N−1)! ​ rooted forests that can be constructed. From symmetry, N ∣S∣ × ∣S∣!(N−∣S∣−1)! (N−1)! ​ × N ​ C ∣S∣ ​ 1 ​ =N ∣S∣−1 (N−∣S∣) of them satisfy the condition that the set of vertices with a parent should be S (also for the case ∣S∣=0). Thus, for S fixed in the first step, there are N ∣S∣−1 ×(N−∣S∣)!×∏ i∈S ​ D i ​ rooted trees that can be constructed. [3] Using convolution Therefore, if we let f(x)=∏ i=1 N ​ (1+D i ​ x), we have B=∑ k=0 N−1 ​ N k−1 (N−k)[x k ]f(x). One can find f(x) in O(Nlog 2 N) time by convoluting the factors in a manner resembling a complete binary tree. Alternatively, one can process the factors with the same D i ​ using binomial theorem and then convolute the results in descending order of D i ​ to find it in O(NlogN) time. A - Swap Digit Editorial by evima For convenience, we assume that for 0≤i≤N−1, the i-th ( 0-indexed) lowest digits of A and B are different. Let a i ​ and b i ​ be the i-th lowest digits of A and B, respectively. Then, we have: A×B ​ = i=0 ∑ N−1 ​ j=0 ∑ N−1 ​ a i ​ b j ​ 10 i+j = i=0 ∑ N−1 ​ a i ​ b i ​ 10 2i + i=0 ∑ N−1 ​ j=i+1 ∑ N−1 ​ (a i ​ b j ​ +a j ​ b i ​ )10 i+j . ​ The value ∑ i=0 N−1 ​ a i ​ b i ​ 10 2i does not change no matter what we do. Our objective is to minimize ∑ i=0 N−1 ​ ∑ j=i+1 N−1 ​ (a i ​ b j ​ +a j ​ b i ​ )10 i+j . Here, which of a i ​ b j ​ +a j ​ b i ​ and a i ​ b i ​ +a j ​ b j ​ is the smaller? If a i ​ −a j ​ and b i ​ −b j ​ have the same sign, the former; otherwise, the letter. Proof Therefore, we can minimize A×B by specifying the smaller of a i ​ and b i ​ as a i ​ and the larger as b i ​ . Now, we can find ∑ i=0 N−1 ​ a i ​ 10 i and ∑ i=0 N−1 ​ b i ​ 10 i modulo 998244353 and compute their product to solve the problem in O(N) time. B - New Place Editorial by evima First, the operation does not change the string that results from sorting S. Thus, if sorting S and T results in different strings, we clearly cannot make S and T equal. On the other hand, if sorting S and T results in the same string, we can always make S and T equal. (The proof is given later.) Below, assume that sorting S and T results in the same string. For integers k(0≤k≤N), let us consider the condition for us to be able to make S and T equal in k operations. Here, the process of performing the operation k times can be seen as the following. Let X be the string formed from the (k+1)-th through N-th characters of S. Insert each of the 1-st through k-th characters of S at any position of X. Thus, S and T can be made equal if and only if X is a subsequence of T. The proof that we can always make S and T equal comes from the fact that when k=N, X is an empty string. Thus, a binary search on k solves the problem in O(NlogN) time. Alternatively, one can reverse S and T and solve it greedily in O(N) time. C - Roller Editorial by evima Below, let us call the operation of replacing A k ​ with A k+1 ​ operation k. Consider the case A=(1,2,…,N). We can make (1,2,…,N) in zero operations. Below, assume that we perform at least one operation. After one operation, A has N−1 different integers, and this number will not increase. Thus, any sequence that can be yielded has N−1 or fewer different integers. Additionally, the operation keeps this property of the sequence: there is an integer i such that A i ​ ≤A i+1 ​ ≤...≤A N ​ ≤A 1 ​ ≤...≤A i−2 ​ ≤A i−1 ​ . Thus, this is also a necessary condition for a sequence to be yieldable. These conditions turn out to be necessary and sufficient. To show that, let us first solve the following property. When one or more operations have been performed, one can shift A to the left. Proof Thus, A can be seen as Y 1 ​ copies of X 1 ​ , Y 2 ​ copies of X 2 ​ , …, and Y k ​ copies of X k ​ , arranged in this order. (X 1 ​ <X 2 ​ <⋯<X k ​ ,∑ i=1 k ​ Y i ​ =N.) For instance, when A=(1,1,3,4), we have X=(1,3,4),Y=(2,1,1). When A=(1,3,3,6,1,1), we have X=(1,3,6),Y=(3,2,1). Here, by performing the operation at the border between X i ​ and X i+1 ​ , one can decrease Y i ​ by 1 and increase Y i+1 ​ by 1, so all Y of this form can be yielded. This, in addition to the above property, proves the necessity and sufficiency of the conditions. Now, let us solve the problem with the general A. First, if A=B, the answer is Yes. If not, and the length of B after compression is N, then No. If neither of the above holds, let us check whether the following holds for the N sequences C that are rotations of B. If it holds for one of them, the answer is Yes. There is a non-decreasing integer sequence x 1 ​ ≤x 2 ​ ≤⋯≤x N−1 ​ ≤x N ​ that satisfies C i ​ =A x i ​ ​ . This can be checked greedily in O(N) time, so one can naively check it for all C to solve the problem in O(N 2 ) time. D - A + B > C ? Editorial by evima First, let us identify the integer x such that P x ​ =1. It can be done in N−1 questions as follows. Let x=1. For i=2,3,…,N in this order, do the following. Ask whether P i ​ +P i ​ >P x ​ . If the answer is No, let x=i. The final x satisfies P x ​ =1. Here is an important property: if a and b are different integers, a+1>b if and only if a>b. Thus, asking whether P a ​ +P x ​ >P b ​ reveals the larger between any two elements. Therefore, by performing merge sort on P 1 ​ ,P 2 ​ ,…,P x−1 ​ ,P x+1 ​ ,…,P N ​ , you can sort P 1 ​ ,P 2 ​ ,…,P x−1 ​ ,P x+1 ​ ,…,P N ​ in at most N⌈log 2 ​ (N)⌉ questions, finding P i ​ for all i. For N=2000, you will ask at most N−1+N⌈log 2 ​ (N)⌉=23999 questions, which is within the limit. E - Reverse and Inversion Editorial by evima We will explain two solutions: O(NlogM) solution from the characteristics of the operation: Here O(NlogM) solution from optimization of DP: https://atcoder.jp/contests/arc154/editorial/5600 f(P) equals ∑ i=1 N ​ (the number of indices j such that j<i,P j ​ >P i ​ )×i−∑ i=1 N ​ (the number of indices j such that i<j,P i ​ >P j ​ )×i. Below, let g(i):=(the number of indices j such that j<i,P j ​ >P i ​ )−(the number of indices j such that i<j,P i ​ >P j ​ ). Additionally, let inv(i):=(the index j such that P j ​ =i). Then, we have g(i)=i−P i ​ . Proof Thus, we have f(P)=∑ i=1 N ​ i(i−P i ​ ). Therefore, for integers 1≤i≤N, we want to find the expected value of the index of the position of the element P i ​ after M operations. Here is an important property. For an element involved in one or more operations, the distribution of its final position is symmetrical. Proof It is easy to find the probability that an element is involved in one or more operations, in which case the expected value of the index of its position is 2 N+1 ​ , in O(logM) time. The expected value otherwise is equal to its original position. Thus, the problem can be solved in O(NlogM) time. F - Dice Game Editorial by evima Let A i ​ :=(the number of ways to get i rolls where all sides have shown up ). Additionally, let f(x)=∑ i=0 ∞ ​ i! A i ​ x i ​ and g(x)=∑ i=0 ∞ ​ A i ​ x i . We have f(x)=(e x −1) N . Let us find g(x) from f(x). Here, note that e ax in EGF corresponds to 1−ax 1 ​ in OGF. Thus, from f(x)=∑ i=0 N ​ ( i N ​ )e ix (−1) N−i , we have g(x)=∑ i=0 N ​ 1−ix ( i N ​ )(−1) N−i ​ . Therefore, g(x) can be represented as g(x)= q(x) p(x) ​ using degree- n polynomials p(x) and q(x), which can be computed in O(Nlog 2 N) using the above formula of g(x). Here, note that q(x) has a factor (1−Nx). Let q(x)=(1−Nx)r(x). Here, let us define B i ​ :=(the probability that the die is rolled exactly i times before all sides have shown up ), and let h(x)=∑ i=0 ∞ ​ B i ​ x i . Then, we have h(x)=g( N x ​ )(1−x), from which we get h(x)= r( N x ​ ) p( N x ​ ) ​ . Now, for the probability generating function F(x)=∑ i=0 ∞ ​ a i ​ x i , let us consider F(e x ). We have [x k ]F(e x )=∑ i=0 ∞ ​ [x k ]a i ​ e ix =∑ i=0 ∞ ​ k! a i ​ ×i k ​ , so the sought values are the coefficients of x 1 ,x 2 ,…,x M in h(e x ). From h(x)= r( N x ​ ) p( N x ​ ) ​ , the problem is reduced to finding the coefficients of degree up to M in C(e x ) for a degree- N polynomial C(x)=∑ i=0 N ​ c i ​ x i . This can be done by finding the coefficients of degree up to M in ∑ i=0 N ​ 1−ix c i ​ ​ , in O(Nlog 2 N+MlogM) time. Therefore, the problem can be solved in O(Nlog 2 N+MlogM) time, which is fast enough. A - AABCDDEFE Editorial by evima Hints → https://atcoder.jp/contests/arc153/editorial/5524 [1] Reduction to 6-tuple As implied by the problem name, a decimal notation of a beautiful integer can be written as AABCDDEFE using digits A, B, C, D, E, and F, where A is not 0. Furthermore, the integer AABCDDEFE corresponds to a 6-tuple (A,B,C,D,E,F) in lexicographical order, so the problem can be reduced to the following one: find the lexicographically N-th smallest 6-tuple (A,B,C,D,E,F) of digits where A is not 0. [2] Solution 1 There are only 9×10 5 such 6-tuples, all of which can be listed in time. You can then print the N-th tuple. Sample code (Python): https://atcoder.jp/contests/arc153/submissions/37943916 [3] Solution 2 One can also directly obtain the N-th tuple. You can simplify the implementation by associating a 6-tuple (A,B,C,D,E,F) with a 6-digit integer ABCDEF. Sample code (Python): https://atcoder.jp/contests/arc153/submissions/37943564 B - Grid Rotations Editorial by evima Hints → https://atcoder.jp/contests/arc153/editorial/5524 [1] Reduction to a single dimension The operation in the problem has the following characteristics: two characters in the same row will remain in the same row; two characters in the same column will remain in the same column. Thus, one can solve the problem by computing the following for each i and j. To which row will the characters that start in the i-th row go? To which column will the characters that start in the j-th column go? These two problems can be solved separately. Although the problem takes place in a two-dimensional grid, each of these two problems deals with a one-dimensional array, as follows. 1D problem We have a 1D array of length N: A=(1,2,…,N). We perform the following operation Q times: given a such that 1≤a≤N−1, reverse the first a terms of A and the last N−a terms of A. Find the array after the operations. Let us explain how to solve this problem. [2] The characteristics of the obtained sequence From (1,2,…,N), one can only obtain some particular sequences (not all permutations of 1,2,…,N) by repeatedly reversing the first a terms and the last N−a terms. This can be shown using the following property of the operation: For the 1D array of length N, let us consider that the leftmost and rightmost terms are also adjacent, in addition to the usual adjacency. Then, two terms that are adjacent before the operation will also be adjacent after the operation. The proof is easy and omitted. From this, there are only 2N arrays that can result from repeating the operation: the circular shifts of (1,2,…,N) and its reversal. For instance, if N=5, the following 10 arrays can be obtained: (1,2,3,4,5),(2,3,4,5,1),(3,4,5,1,2),(4,5,1,2,3),(5,1,2,3,4), (1,5,4,3,2),(2,1,5,4,3),(3,2,1,5,4),(4,3,2,1,5),(5,4,3,2,1). For these sequences, one can restore the positions of all elements from, for example, the positions of 1 and 2. Therefore, the 1D problem can be solved in O(N+Q) time by tracing the positions of 1 and 2 through the operations. The original problem can be solved in O(HW+Q) time. C - ± Increasing Sequence Editorial by evima Hints → https://atcoder.jp/contests/arc153/editorial/5524 [1] Translating the problem by a change of variables For an integer sequence x=(x 1 ​ ,…,x N ​ ), let an integer sequence y=(y 1 ​ ,…,y N ​ ) defined as follows: y i ​ ={ x 1 ​ x i ​ −x i−1 ​ ​ (i=1) (i≥2) ​ Here we have x i ​ =∑ k=1 i ​ y k ​ , so one can restore x from y. Thus, instead of finding x, let us find y. We have: i=1 ∑ N ​ (A i ​ k=1 ∑ i ​ y k ​ )= 1≤k≤i≤N ∑ ​ A i ​ y k ​ = k=1 ∑ N ​ ( i=k ∑ N ​ A i ​ )y k ​ . If we let B k ​ =∑ i=k N ​ A i ​ , we have the following conditions on y. [Condition 1] ∣ ∣ ∣ ​ ∑ k=1 i ​ y k ​ ∣ ∣ ∣ ​ ≤10 12 for 1≤i≤N. [Condition 2] y i ​ >0 for 2≤i≤N. [Condition 3] ∑ i=1 N ​ B i ​ y i ​ =0. Here, the condition that x must be strictly increasing has turned into independent conditions on individual terms, which is easier to handle. Note that there is no restriction on y 1 ​ in [Condition 2]. [2] The case B 1 ​  =0 Here, one can construct a solution as follows: y i ​ ={ ∣B 1 ​ ∣ − B 1 ​ ∑ i=2 N ​ B i ​ ∣B 1 ​ ∣ ​ ​ (i≥2) (i=1) ​ Let us verify that this y satisfies the conditions. [Condition 2] and [Condition 3] are clearly satisfied. For [Condition 1], from ∣B i ​ ∣≤N, ∣y i ​ ∣≤N for i≥2, and ∣y i ​ ∣≤(N−1)N for i=1, so we have ∑ i=1 N ​ ∣y i ​ ∣≤2N 2 ≤10 12 . [3] The case B 1 ​ =0 [3 - 1] If B i ​ ≥0 for every i From ∣B 2 ​ −B 1 ​ ∣=1 and so on, we have B 2 ​ >0. Thus, under [Condition 2], we have: i=1 ∑ N ​ B i ​ y i ​ = i=2 ∑ N ​ B i ​ y i ​ >0. Thus, there is no solution. [3 - 2] If B i ​ ≤0 for every i Similarly to [3 - 1], there is again no solution. [3 - 3] The remaining case From ∣B i ​ −B i+1 ​ ∣=1, there are p,q≥2 such that B p ​ =−1,B q ​ =1. Let X=∑ i=2 N ​ B i ​ . If X≥0, let: y i ​ ={ 1 1+X ​ (i  =p) (i=p) ​ and if X<0, let: y i ​ ={ 1 1−X ​ (i  =q) (i=q) ​ Then, one can verify that the conditions are satisfied. The satisfaction of [Condition 1] can be shown using ∣X∣≤N 2 −N from ∣B i ​ ∣≤N. D - Sum of Sum of Digits Editorial by evima Hints → https://atcoder.jp/contests/arc153/editorial/5524 For a sequence A of non-negative integers, let F(A) denote the minimum possible value of ∑ i=1 N ​ f(A i ​ +x). Additionally, let K be the maximum number of digits in A i ​ . [1] Computing F(A) recursively For 0≤r≤9, let F r ​ (A) denote the minimum of the above value for x such that x≡r(mod10). We have F(A)=min r ​ F r ​ (A). For instance, when r=1, if we let x=10x ′ +1, from f(123+x)=f(12+x ′ )+4, f(45+x)=f(4+x ′ )+6 and so on, we have: F 1 ​ ((123,45,678,90))=20+F((12,4,67,9)). Similarly, when r=5, we have: F 5 ​ ((123,45,678,90))=16+F((12,5,68,9)). In this way, when max(A)≥2, one can compute F(A) using F(A ′ ) for a sequence A ′ with smaller values. When max(A)=1, we clearly have F(A)=sum(A), so this method can compute F(A). [2] Evaluating the number of states For how many sequences A ′ do we have to compute F(A ′ ) when computing F(A ′ ) recursively by the above method? It can be seen that the recursive calls at depth k only take the sequences A ′ that can be written as A i ′ ​ =⌊ 10 k A i ​ +c ​ ⌋ for some 0≤c<10 k . Thus, if i 1 ​ ,i 2 ​ ,…,i N ​ are the result of sorting i=1,2,…,N in ascending order of A i ​ mod10 k , the recursive calls only take A ′ in the following form: A i ′ ​ = ⎩ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎧ ​ ⌊ 10 k A i ​ ​ ⌋ ⌊ 10 k A i ​ ​ ⌋+1 ​ (i=i 1 ​ ,…,i n ​ ) (i=i n+1 ​ ,…,i N ​ ) ​ Let A(k,n) denote the sequence A ′ determined in this way. One can see that there are at most K(N+1) such sequences. [3] Summary Therefore, the problem can be solved by dynamic programming where dp[k][n], defined by dp[k][n]=F(A(k,n)) ( 0≤k<K,0≤n≤N), are computed in descending order of k. The bottleneck is the sorting of A i ​ mod10 k for each k, and the total complexity is O(NKlogN). Or, in the manner of radix sort, one can use the result of sorting A i ​ mod10 k−1 in the sorting of A i ​ mod10 k to make the complexity O(NK). Note that the complexity would increase if you performed a computation taking Ω(N) time for all sequences A(k,n), such as examining all terms. To perform the recursive computation stated in [1], you only need the frequency distribution of the ones digits of A(k,n), so the computation can be done faster by looking at the differences of A(k,n+1) and A(k,n), or using some cumulative sums. E - Deque Minimization Editorial by evima Hints → https://atcoder.jp/contests/arc153/editorial/5524 Let N denote the number of digits in Y. [1] An Θ(N 2 )-time solution It is clear that the following greedy strategy obtains f(X) from X. Initialize S as an empty string. Let N be the number of digits in X. For i=1,…,N in this order, do the following: if the i-th character in the decimal notation of X is greater than the first character of S at that point, insert it at the end of S; otherwise, insert it at the beginning of S. Let Y be the positive integer represented by the string S. Thus, the problem can be solved in a time complexity of Θ(N 2 ) by dynamic programming where the following is computed in appropriate order. dp[L][R]: the number of integers X that yield the L-th through R-th characters of Y. When L<R, dp[L][R] can be computed using dp[L+1][R] and dp[L][R−1]. More specifically, if Y L ​ ≤Y L+1 ​ , add dp[L+1][R] to dp[L][R]; if Y L ​ <Y R ​ , add dp[L][R−1] to dp[L][R]. For instance, the transitions in this dynamic programming for the case Y=12234433442 (sample 3) are shown below. The answer is the number of paths from the cells on the diagonal to the top-right corner. [2] Deleting useless transitions In the above transitions, let us remove the computations that clearly do not affect the answer. When Y i ​ >Y i+1 ​ , one does not have to compute dp[L][R] for L such that i<L, because there are no transitions from dp[i+1][−] to dp[i][−]. When L<i and Y L ​ ≥Y i ​ , one does not have to compute dp[L][R] for R such that i≤L, because such dp[L][R] are always 0. [3] Speeding up the computation Let us consider computing dp[L][−] in the order L=N,N−1,…,1. After deleting the useless transitions above, it can be seen that one can obtain dp[L−1][−] from dp[L][−] by the following operations: add 1 to the beginning, and compute the cumulative sums for some range determined by the value of Y L ​ . For the same value of Y L ​ , the cumulative sums are repeatedly computed for the same range, so the computation for this part can be combined into convolution with some sequence of binomial coefficients. Therefore, the problem can be solved in a time complexity of O(NlogN) by computing the convolution of length- N sequences at most 9 times. F - Tri-Colored Paths Editorial by evima Hints → https://atcoder.jp/contests/arc153/editorial/5482 This editorial assumes basic knowledge of biconnected components and block-cut trees of a graph. Here are some websites on these topics: Wikipedia Problem for verification Let us call a coloring bad when it satisfies the following. Edges in every color exist. The condition in question is not satisfied. That is, any simple path contains edges in two or fewer colors. The problem can be easily reduced to the counting of bad colorings, which we will explain below. [1] On 3-color cycles Let us show the following. In a bad coloring, let C be a 3-color cycle. Then, the following holds. C has a length of 3. If N≥5, there is exactly one vertex in C that is adjacent to a vertex outside C. First, if the length of C were 4 or greater, a simple path formed from C except one edge would contain all colors, which is a contradiction. Assume that the length of C is 3. Let v 1 ​ , v 2 ​ , and v 3 ​ be the vertices in C, and assume that the colors of edges v 1 ​ v 2 ​ , v 2 ​ v 3 ​ , and v 3 ​ v 1 ​ are 3, 1, and 2, respectively. Let us assume for contradiction that N≥5 and both v 1 ​ and v 2 ​ are adjacent to vertices outside C. Let x be a vertex outside C adjacent to v 1 ​ , and y be a vertex outside C adjacent to v 2 ​ . From the simple paths (x,v 1 ​ ,v 2 ​ ,v 3 ​ ) and (x,v 1 ​ ,v 3 ​ ,v 2 ​ ), the color of the edge xv 1 ​ is 1. Similarly, the color of the edge yv 2 ​ is 2. Then, if we let S={v 1 ​ ,v 2 ​ ,v 3 ​ ,x}, for any s∈S and two colors a and b, there is a simple path in S starting from s that contains the colors a and b. When N≥5>∣S∣, there is an edge connecting some s∈S and t∈ / S, but combining such an edge and a simple path in S starting from s yields a simple path containing all colors, a contradiction. From the above observations, one can count bad colorings with 3-color cycles. When N≤4, the problem can be solved by checking all possible colorings and simple paths, so let us assume N≥5 below. Such a coloring satisfies the following for a cycle C=(v 1 ​ ,v 2 ​ ,v 3 ​ ) and different colors a, b, and c. C is one of the biconnected components of G, and v 1 ​ is the only cut vertex of G in C. The colors of v 1 ​ v 2 ​ , v 2 ​ v 3 ​ , and v 3 ​ v 1 ​ are c, a, and b, respectively. Here, for any edge e not in C, there is a simple path that contains the edges e,v 1 ​ v 2 ​ ,v 2 ​ v 3 ​ , so the color of e is not b. Similarly, that color is not c, so it must be a. On the other hand, one can easily verify that such a coloring is always bad and contains a single 3-color cycle. Thus, when N≥5, one can count bad colorings containing 3-color cycles, as follows. Let n be the number of length- 3 cycles C that is one of the biconnected components of G and contains a single cut vertex of G. Then, there are 6n bad colorings containing 3-color cycles. [2] On 2-color cycles Let us show the following. There is no bad coloring that contains a 2-color cycle but not a 3-color cycle. Consider a bad coloring, and let C be a cycle containing colors 1 and 2 but not 3. Then, for any x∈C, there is a simple path starting from x and composed of edges in C that contains both colors 1 and 2. Let us show that no edge e has color 3. Assume that e is an edge outside C. If the color of e were 3, one can take a simple path containing e and reaching C, and combine it with a simple path in C to yield a path containing all colors, a contradiction. Assume that e is a chord in C (an edge that is not part of C but connects two vertices in C). Also, assume that e has color 3. e divides the edges in C into two parts C 1 ​ and C 2 ​ . From the assumption that the coloring does not contain a 3-color cycle, the number of colors of edges in C 1 ​ is 1. Similarly, the number of colors of edges in C 2 ​ is also 1. Then, adding edges from C 1 ​ and C 2 ​ before and after e yields a 3-color simple path, which contradicts the fact that the coloring is bad. Therefore, it has been shown that no edge has color 3, which violates the definition of bad coloring. [3] On bad colorings with just 1-color cycles Let us study bad colorings all of whose cycles are 1-colored. In such a coloring, all edges in each biconnected component of G have the same color. Thus, the problem can be reduced to the following one on block-cut trees. Count the number of ways to color each block of the block-cut tree T of G in color 1, 2, or 3 so that the following are satisfied. There is a block in every color. There is no simple path in T that contains a block in every color. Let us call such a coloring of T bad. The following holds. In a bad coloring of T, there is a unique cut vertex v that is adjacent to a block in every color. Additionally, for each connected component of T∖{v}, all blocks have the same color. Let us show this fact. In a bad coloring, there is at least one vertex v that is adjacent to two or more colors. Let us take one such v and root T at v. We may assume that v is adjacent to blocks in colors 1 and 2. Then, a block in a subtree rooted at a block in color 1 adjacent to v will not have color 3. The same goes for a subtree rooted at a block in color 2. Thus, from the assumption that there is a block in every color, v is adjacent to a block in every color. Then, it can be stated that a block in a subtree rooted at a block in color 1 does not have color 2 or 3, so all blocks there must have color 1. The same goes for blocks in colors 2 and 3. One can also easily verify that v is the only cut vertex that is adjacent to a block in every color. Therefore, it can be seen that one can count bad colorings all of whose cycles are 1-colored, as follows. For each cut vertex v, let n v ​ be the number of blocks adjacent to v. Then, there are ∑ v ​ f(n v ​ ) bad colorings all of whose cycles are 1-colored, where f(n) is the number of surjections from an n-element set to {1,2,3}. A - Seat Occupation Editorial by evima Everyone can take a seat in every possible way to choose seats if and only if there is no way to specify seats to make someone leave. Additionally, only 2-person groups may leave, and groups that come later are more likely to leave, so let us try to make the last 2-person group leave. For this, it is optimal to ask the earlier groups to sit from left to right in order, one seat apart from each other. Then, let us see if two or more seats remain. More specifically, the answer is Yes if L−∑ i=1 k−1 ​ (a i ​ +1)≥2, where the k-th group is the last 2-person group. This condition can also be rearranged into 2k≤N+1 ( k is 1-indexed). B - Pass on Path Editorial by evima Let us name the two travelers A and B. Before they visit both ends of the road and return to the starting point, they must pass each other twice. In one of those moments, A should be facing east, and in the other, A should be facing west. At that moment, when A is facing west, let l be the distance from the rest area where they are to the west end of the road. Here, the “gap” from A to B is 2l. Similarly, at the moment they pass each other when A is facing east, if r is the distance from the rest area where they are to the east end of the road, the gap from A to B is 2r. If these two gaps are different, one of the travelers must wait (or adjust the speed, etc.) while the other covers the difference, which takes extra time. Thus, the shortest time needed for the round trip is: 2L+2∣l−r∣. Moreover, both travelers can actually finish the round trip in this time. Specifically, they can start in opposite directions at one of the rest areas where they pass each other, and wait only at the other rest area to adjust the timing (at all other times, they move at a speed of 1). Therefore, one should choose the rest areas where they pass each other to minimize the difference between r and l, which can be done fast enough using two pointers or sorting. C - Pivot Editorial by evima The given operation is equivalent to moving each term to the symmetrical position with respect to the chosen value s on the number line. Therefore, the difference between the minimum and maximum values is constant, so let us minimize the minimum value instead. Let d be the difference between the minimum and maximum. When the operation is performed by choosing the minimum or maximum value as s, the minimum value increases or decreases by d. Therefore, if the remainder when the minimum value is divided by d is r, one can use this action to make the final minimum value r. Next, let us try to make r as close to 0 as possible. r changes when one chooses some term that is not the minimum or maximum value as s. More specifically, it changes by 2(s−m), where m is the minimum value. This action cannot be done twice in a row since doing it once reverses the relative positions of the terms. However, after performing a reversal with respect to the maximum value, which does not change r, one can again change r by 2(s−m). Thus, this action can be done any number of times, so r can be changed by any t such that there is k (≥0) such that 2(s−m)k≡t (mod d). Additionally, such positive k exists for t that is a multiple of gcd(d,2(s−m)) ( gcd denotes the greatest common divisor of some numbers). Thus, r can be changed by any multiple of gcd(d,2(s−m)). One can use any term for this action, so r can be changed by any multiple of gcd(d,2(a 1 ​ −m),2(a 2 ​ −m),...,2(a N ​ −m))=g as a whole. Therefore, the answer is m mod g+d. D - Halftree Editorial by evima Since the operation doubles the number of edges, the objective is obviously unachievable when N is even. When N is odd, it turns out that there is always a desired set of edges. Here is one way to construct one. Let g be the greatest common divisor of N and K, and n=N/g,k=K/g. Let us classify 0 through N−1 according to the remainder when divided by g to arrange them in n rows from top to bottom and g columns from left to right, where each column consists of the numbers with the same remainder. The numbers in the column with the remainder 0 are 0,K mod N,2K mod N,…,(n−1)K mod N from top to bottom. Since n and k are coprime, each number from 0 through n−1 appear once in 0,k mod n,2k mod n,…,(n−1)k mod, so if they are multiplied by g, which results in the above sequence, each multiple of g appears once. In the columns with a remainder of 1 or greater, each number should be one greater than the number on the left, as shown in the figure below. Then, each number from 0 through N−1 appears once, and the numbers of rows and columns are odd. As shown in the figure (where N=25 and K=10), if we draw vertical edges in the odd-numbered ( 1-st, 3-rd, …) columns, n−1 horizontal edges from the upper part of each odd-numbered column, and 2 horizontal edges from the lower part of each even-numbered column, we have a tree. Here, if we add the black edges in the figure ourselves, each will spawn the red edge right below it, satisfying the requirement. (“並べ方と辺の貼り方の一例”: One way to arrange numbers and add edges) E - Xor Annihilation Editorial by evima Let us compute the sequence of L and R for the balls. Consider the sequence of cumulative XOR sums of the weights, including Z at both ends. The total XOR of the weights is 0, so L and R for a ball correspond to the terms that are just before and after that ball, respectively. Next, let us see what happens when two balls come to the same coordinate. This corresponds to the disappearance of the term between those two balls in the above sequence of cumulative XOR sums. Additionally, from the rules of the moves, one can see that each ball moves toward the larger of the two adjacent terms in the sequence of cumulative XOR sums. Thus, one can simulate the moves of the balls by deleting a term that is larger than the two adjacent terms (accurately, smaller than neither of them, and larger than at least one of them) in the sequence of cumulative XOR sums and concatenating the remaining parts. The balls come to rest if and only if all terms in that sequence at that point are equal. This will happen if and only if that sequence contains no term smaller than Z at both ends. Therefore, the problem is equivalent to the following: “We have the sequence p i ​ of cumulative XOR sums for Z=0. Find the number of integers Z at most 2 N −1 such that Z xor p i ​ is never smaller than Z.” We have Z>(Z xor p i ​ ) when the most significant bit of p i ​ is present in Z. Thus, if there are k bit positions where none of the p i ​ has its most significant bit, the answer is 2 k . F - Attraction on Tree Editorial by evima If the distance between vertices 1 and N and the number of vertices have different parities, there is clearly no good procedure. Otherwise, it turns out that a good procedure is always constructible. Additionally, if a good procedure is constructible, there is a set of vertices that are visited by the piece in every good procedure, and other than that, there are limited candidates of vertices that needs to be visited. Let us explain a specific way to construct one. Below, let path(u,v) denote the path connecting two vertices u and v, and d(u,v) be its length. First, all vertices along path(1,N) must always be visited by the piece. Let us cut the edges along path(1,N) for now to consider the set of subtrees rooted at the vertices along path(1,N), and let w i ​ be the size of the subtree rooted at vertex i (including this vertex). Here, assume that for a vertex s, the piece does not have to visit the descendant of s. Let us pay attention to the change in the distance between the piece and s. If the operation chooses a vertex in the subtree rooted at s, the piece always approaches s. Otherwise, the piece may go away from s. Therefore, the following must hold: d(1,s)+(N−w s ​ )≥d(N,s)+w s ​ . ーⒶ If some vertices violate this, those vertices form a path (Ⓑ: the proof is given later.) In this case, let t be the deepest vertex in the path. Let us choose some of the children of t, and let W be the total size of the subtrees rooted at them. We will consume those W vertices and the other w t ​ −W vertices by first using them to attract the piece to t, and then making pairs. From the assumption, some vertices remain in the subtree rooted at t when the piece reaches t, but if more vertices remain among the W than among the w t ​ −W, they can be consumed in pairs by moving the piece back and forth between t and the chosen children. This would be impossible if more than half of the remaining vertices are in one of the subtrees rooted at the chosen children, but this is always avoidable since any child of t satisfies Ⓐ. Thus, one should choose as few children of t as possible so that the total size W of the subtrees rooted at the chosen children satisfies: W≥(w t ​ −W)−(d(1,t)+(N−w t ​ )−d(N,t)) ⟺ 2W≥w t ​ −(d(1,t)+(N−w t ​ )−d(N,t)). On the other hand, if no vertex violates Ⓐ, one can always construct a procedure where the piece only visits the vertices along path(1,N). Let us explain how. Choose a vertex s along path(1,N). Let B s ​ be the sum of w i ​ over the vertices i along the path from 1 to s except s, and F s ​ be the sum of w i ​ over the vertices i along the path from s to N except s. If none of w s ​ , B s ​ +d(1,s), and F s ​ −d(N,s) exceeds half of the sum of them, the vertices in the three groups around the vertex s can be consumed in pairs to construct a good procedure where the piece only visits the vertices along the path from 1 to N. Furthermore, if no vertex violates Ⓐ, there is always a vertex along path(1,N) that satisfies the condition above (Ⓒ: the proof is given later.) ■ The proof of Ⓑ It is clear that the parent of a vertex that violates Ⓐ also violates Ⓐ. Let us assume for contradiction that Ⓐ is violated by two different vertices i and j such that none of them is an ancestor of the other. Here, the following holds for i: d(1,i)−d(N,i)+(N−w i ​ )<w i ​ ⟺ d(1,i)−d(N,i)+(N−w i ​ )+1≤w i ​ . By using d(1,i)−d(N,i)≥−d(1,N), we get: (N−w i ​ )−d(1,N)+1≤w i ​ (the equality holds only if i is in the subtree rooted at 1). Here, (N−w i ​ )−d(1,N) is at least the total number of vertices that are neither in the subtree rooted at w i ​ nor along path(1,N). Since j is not in the subtree rooted at i, the subtree rooted at j should not overlap with the subtree rooted at i, and we have: w j ​ ≤(N−w i ​ )−d(1,N)+1 (the equality holds only if j is along path(1,N)). From the above, we have w j ​ ≤w i ​ , and the equality holds only if i is in the subtree rooted at 1 and j is along path(1,N). Therefore, we have w j ​ ≤w i ​ and w i ​ ≤w j ​ . To satisfy both equalities, we must have i=j=1, which contradicts the assumption. ■ The proof of Ⓒ Let us gradually move s from 1 along path(1,N). From the assumption, w s ​ is never the majority. From the definition, we have B s ​ +d(1,s)=0 for s=1 and F s ​ −d(N,s)=0 for s=N. The case one of these s satisfies the condition may be ignored, so let us assume that F s ​ −d(N,s) is the majority for s=1 and B s ​ +d(1,s) is the majority for s=N. There is a pair of vertices s and t such that t is one vertex closer to N than s, and F s ​ −d(N,s) is the majority for s, but F t ​ −d(N,t) is not the majority for t. Then, from F t ​ −d(N,t)=(F s ​ −w t ​ )−(d(N,s)−1)=F s ​ −d(N,s)−w t ​ +1 and B t ​ +d(1,t)=(B s ​ +w s ​ )+(d(1,s)+1)=B s ​ +d(1,s)+w s ​ +1, we have: F s ​ −d(N,s)>B s ​ +d(1,s)+w s ​ ⟺ F s ​ −d(N,s)−w t ​ +1+w t ​ >B s ​ +d(1,s)+w s ​ +1 ⟺ F t ​ −d(N,t)+w t ​ >B t ​ +d(1,t). Therefore, B t ​ +d(1,t) is not the majority, and from the assumption, neither is F t ​ −d(N,t) or w t ​ , so t satisfies the condition. A - Equal Hamming Distances Editorial by evima Let X i ​ denote the i-th character of a 01-sequence X. Additionally, let d(X,Y) denote the Hamming distance between 01-sequences X and Y, and D:=d(S,U)−d(T,U). Then, the problem asks to find the lexicographically smallest U such that D=0. For i such that S i ​ =T i ​ , whether U i ​ is 0 or 1 does not affect D. For i such that S i ​  =T i ​ , letting U i ​ :=S i ​ contributes −1 to D, and U i ​ :=T i ​ contributes +1 to D. Thus, in order to have D=0, among the indices i such that S i ​  =T i ​ , the number of ones such that U i ​ =S i ​ must be equal to those such that U i ​ =T i ​ . This is impossible if the number of indices i such that S i ​  =T i ​ , d(S,T), is odd. If it is even, one should let U i ​ :=S i ​ for d(S,T)/2 of those indices, and U i ​ :=T i ​ for the remaining d(S,T)/2. Let us try to find the lexicographically smallest such U. As stated above, indices i such that S i ​ =T i ​ contribute nothing to D, so one should let U i ​ :=0 for them to get the lexicographically smallest. For indices i such that S i ​  =T i ​ , one can use the following greedy strategy. Scan those indices i in ascending order. Prioritize assigning 0 to U i ​ over 1 as long as it will not be impossible to end up with d(S,T)/2 indices i such that U i ​ =S i ​ and d(S,T)/2 such that U i ​ =T i ​ . B - A < AP Editorial by evima Below, a sequence of length N consisting of integers between 1 and M is simply called a sequence. Additionally, for a sequence A, let A ′ :=(A P 1 ​ ​ ,A P 2 ​ ​ ,…,A P N ​ ​ ). There are M N sequences A in total. If X is the number of sequences A such that A=A ′ , the number of A’s such that A ′ <A lexicographically and the number of those such that A ′ >A are equal from the symmetry, so the answer is (M N −X)/2. Since X is the number of sequences A such that A i ​ =A P i ​ ​ for every i=1,2,…,N, if we consider an undirected graph G with the vertex set {1,2,…,N} and the undirected edge {i,P i ​ } for each i=1,2,…,N, then X is equal to the number of ways to make each connected component in G correspond to an integer between 1 and M. Thus, if C is the number of connected components in G, we have X=M C . Therefore, the answer is (M N −M C )/2. C - 01 Game Editorial by evima Let us divide the squares into (maximal) contiguous intervals of empty squares, which we will call components. Since the whole game is the sum of games for respective components, if we find the Grundy number of the game for each component, we can also find the Grundy number of the whole game (and particularly the winner) as their XOR. It can be proved by induction that the Grundy number of the game for each component is as follows, where n is the length (that is, the number of empty squares) of that component. If the component is sandwiched between different digits, the Grundy number is 0. If the component is sandwiched between equal digits, the Grundy number is 1. If the component touches just one digit, the Grundy number is n. If the component does not touch digits, the Grundy number is nmod2. D - Binary Representations and Queries Editorial by evima If the i-th and (i+1)-th queries satisfy X i ​  =X i+1 ​ , swapping these two queries does not change the final answer. To verify this, we first assume X i ​ =0,X i+1 ​ =1 and Y i ​ =0,Y i+1 ​ =0 without loss of generality. Additionally, in these two queries, additions within the four elements A 4k ​ , A 4k+1 ​ , A 4k+2 ​ , and A 4k+3 ​ are performed for k=0,1,2,…,2 N−2 −1 “in parallel,” so it is enough to verify for just k=0 as a representative. Then, one can actually perform the operations for (A 0 ​ ,A 1 ​ ,A 2 ​ ,A 3 ​ ) to verify that the result does not depend on the order of the two queries. Therefore, we may rearrange the queries without changing the relative order of queries with equal X i ​ so that: first, only the queries with X i ​ =0 are executed; next, only the queries with X i ​ =1 are executed; next, only the queries with X i ​ =2 are executed; ⋯ finally, only the queries with X i ​ =N−1 are executed. Thus, it is enough to solve the case where all queries have the same X i ​ fast enough. We assume X 1 ​ =X 2 ​ =⋯=X Q ​ =0 without loss of generality. Additionally, let A (i) =(A 0 (i) ​ ,A 1 (i) ​ ,…,A 2 N −1 (i) ​ ) denote A just after executing up to the i-th query. If we let: M 0 ​ :=[ 1 1 ​ 0 1 ​ ],M 1 ​ :=[ 1 0 ​ 1 1 ​ ], then for any k=0,1,2,…,2 N−1 , [ A 2k (i) ​ A 2k+1 (i) ​ ​ ]=M Y i ​ ​ [ A 2k (i−1) ​ A 2k+1 (i−1) ​ ​ ], so for any k=0,1,2,…,2 N−1 , [ A 2k (Q) ​ A 2k+1 (Q) ​ ​ ]=M Y Q ​ ​ M Y Q−1 ​ ​ …M Y 1 ​ ​ [ A 2k (0) ​ A 2k+1 (0) ​ ​ ]. Therefore, by computing the product of the Q matrices M Y Q ​ ​ M Y Q−1 ​ ​ …M Y 1 ​ ​ once, one can use it to compute every element of A (Q) in O(1) time per element. E - Keep Being Substring Editorial by evima Let +L, -L, +R, and -R denote the four operations on X: addition to the beginning, deletion from the beginning, addition to the end, and deletion from the end, respectively. ・If X and Y have a common integer Let S be the longest sequence that is a contiguous subsequence of both X and Y. Then, the optimal sequence of operations looks as follows. First, -L and -R are repeated so that X matches S. Then, +L and +R are repeated so that X matches Y. It consists of ∣X∣+∣Y∣−2∣S∣ operations. S can be found in O(∣X∣+∣Y∣) time using a suffix array and the LCP array. ・If X and Y do not have a common integer Here, the following additional rule can be imposed without affecting the optimal solution. (The proof is at the end of this editorial.) When X and Y have no common integer and ∣X∣≥2, only -L and -R may be performed. With this rule, one can only match the given X to Y in the following manner. First, repeat -L and -R until X has a length of 1. Repeat (∗) below as long as X and Y have no common integer: Perform +L or +R and then perform -L or -R. ⋯(∗) Match X to Y by repeating +L and +R. Steps 1. and 3. always consist of ∣X∣−1 and ∣Y∣−1 operations, respectively, so let us minimize the number of operations in step 2. Each time (∗) is performed, X changes from a sequence of length 1 into another of length 1. For different integers u and v, it is possible to transition from the state X=(u) to the state X=(v) by performing (∗) once if and only if: A has the sequence (u,v) or (v,u) as a contiguous subsequence. This can be rephrased into the following. In the undirected graph G whose vertex set is {1,2,…,N} and whose edge set is {1,2,…,N}, u and v are adjacent to each other. Additionally, the only element of X at the beginning of 2. can be freely chosen from X:={X 1 ​ ,X 2 ​ ,…,X P ​ } according to what is left in 1., and the only element of X at the end of 2. can be any of Y:={Y 1 ​ ,Y 2 ​ ,…,Y Q ​ }. Therefore, the minimum number of operations in 2. can be found as 2D by solving the shortest path problem to find: D:=min{dist(s,t):s∈X,t∈Y}. The proof that the additional rule does not affect the optimal solution Let op 1 ​ ,op 2 ​ ,…,op n ​ be an optimal sequence of operations that match X to Y. As shown below, one can obtain an optimal sequence of operations respecting the additional rule by repeating the following action: as long as the sequence has operations violating the additional rule, swap the last of them and the subsequent operation. Assume that the last operation violating the additional rule is op i ​ = +R. Just before executing op i ​ , X and Y has no common integer, so op i ​ cannot be the last operation, and the subsequent operation op i+1 ​ exists. If the integer added by op i ​ is contained in Y, it follows from the optimality of the sequence of operations that op i+1 ​ = -L. If the integer added by op i ​ is not contained in Y, it follows from the following reasons that op i+1 ​ = -L again. If op i+1 ​ = -R, a shorter sequence of operations could be obtained by cancelling out op i ​ and op i+1 ​ , contradicting with the optimality. If op i+1 ​ = +L or op i+1 ​ = +R, then op i+1 ​ would also violate the additional rule, contradicting with the choice of i. Since ∣X∣≥2 just before executing op i ​ , the sequence of operations obtained by swapping op i ​ = +R and op i+1 ​ = -L is also feasible and optimal. For the case where op i ​ = +L, one can use a symmetric argument to the above. The sequence after the swap has one fewer pair of integers (i,j) such that 1≤i<j≤n, op i ​ = +L or +R, and op j ​ = -L or -R than the sequence before the swap. Thus, this repetition of swaps halts after a finite number of swaps, yielding an optimal sequence of operations respecting the additional rule. F - RGB Card Game Editorial by evima Let us call a color advantageous to a player when both players have at least one card in that color and the player has fewer cards in that color than the opponent. Additionally, let us call a color balanced when both players have at least one card in that color and the same number of cards in that color. Let A num ​ , B num ​ , and C num ​ be the number of colors advantageous to Takahashi, advantageous to Aoki, and balanced, respectively. Additionally, let A sum ​ , B sum ​ , and C sum ​ be the sum of min{the number of cards in Takahashi’s hand, the number of cards in Aoki’s hand } over colors advantageous to Takahashi, advantageous to Aoki, and balanced, respectively. It can be proved by induction that the winner can be determined by division into four cases based on C num ​ as follows. Here, in each case, items listed earlier have priority over those listed later. ・When C num ​ =0 If A sum ​ ≥B sum ​ , Takahashi wins; if A sum ​ <B sum ​ , Aoki wins. ・When C num ​ =1 If A num ​ =2, Takahashi wins; if B num ​ =2, Aoki wins. If A sum ​ −B sum ​ ≥C sum ​ , Takahashi wins; if A sum ​ −B sum ​ ≤−C sum ​ , Aoki wins. If A sum ​ +B sum ​ +C sum ​ is odd, Takahashi wins; if it is even, Aoki wins. ・When C num ​ =2 If A num ​ =1, Takahashi wins; if B num ​ =1, Aoki wins. If C sum ​ is odd, Takahashi wins; if it is even, Aoki wins. ・When C num ​ =3 If C sum ​ is even, Takahashi wins; if it is odd, Aoki wins. A - Continuous 1 Editorial by evima [1] Solve the decision problem Let M be the number of 1s in S. Consider for each i (1≤i≤N−K+1) whether we can make all of S i ​ , S i+1 ​ , …,S i+K−1 ​ 1s and the others 0s. This can be done if and only if: the number of 1s in S i ​ , S i+1 ​ , …, S i+K−1 ​ is M, and the number of 0s in S i ​ , S i+1 ​ , …, S i+K−1 ​ is 0. Let us check this for each i. If exactly one i satisfies these conditions, the answer is Yes; otherwise, it is No. [2] Count 1s in S i ​ , S i+1 ​ , …, S i+K−1 ​ fast If we naively count 1s in S i ​ , S i+1 ​ , …, S i+K−1 ​ , it will take Θ(NK) time, which will run out of time for some test cases. This can be improved by focusing on the change of the count in i→i+1. Specifically, the difference between the number of 1s in S i ​ , S i+1 ​ , …, S i+K−1 ​ and that in S i+1 ​ , S i+2 ​ , …, S i+K ​ only comes from S i ​ and S i+K ​ . Thus, if the former is known, the latter can be found in O(1) time. Therefore, the number of 1s in S i ​ , S i+1 ​ , …, S i+K−1 ​ for every i (1≤i≤N−K+1) can be found in O(N) time in total. The numbers of 0s can also be found similarly in O(N) time. Using these counts, one can solve the decision problem in O(1) time, so the problem can be solved in O(N) time. B - Make Divisible Editorial by evima [1] Fix A+X B+Y ​ Consider minimizing X+Y for a fixed value of k= A+X B+Y ​ (1≤k). Here, we have Y=kX+kA−B,X+Y=(k+1)X+kA−B, and we want X to be as small as possible. From the condition 0≤X, Y, the minimum value that X can take is X=max(0, ⌊ k B−1 ​ ⌋+1−A). Thus, the problem can be rephrased into one that asks to find k that minimizes (k+1)max(0, ⌊ k B−1 ​ ⌋+1−A)+kA−B. [2] Use the small number of different values of ⌊ k B−1 ​ ⌋ For values of k with the same value of ⌊ k B−1 ​ ⌋, the value of the above formula will be smaller when k is smaller. Thus, for every value Q that ⌊ k B−1 ​ ⌋ can take, let us find the smallest k such that ⌊ k B−1 ​ ⌋=Q and compute the value of the formula, and then find the minimum of those values. When 1≤Q, the smallest value of k for Q can be found as ⌊ Q+1 B−1 ​ ⌋+1, which can be computed in O(1) time, from the following: Q=⌊ k B−1 ​ ⌋⟺Q≤ k B−1 ​ <Q+1⟺⌊ Q+1 B−1 ​ ⌋+1≤k≤ Q B−1 ​ . For Q=0, the smallest value of k is B. Let us list the values that Q can take. First, we have ⌊ k B−1 ​ ⌋ for k=1, 2, …, ⌈ B−1 ​ ⌉. Next, we have ⌊ k B−1 ​ ⌋ for ⌈ B−1 ​ ⌉<k, where the values are clearly at most ⌈ B−1 ​ ⌉, which means there are only O( B ​ ) of them. From the above, the problem can be solved in O( B ​ ) time per test case. C - Path and Subsequence Editorial by evima The condition in the Problem Statement would be the same if it included non-simple paths. Below, we also consider non-simple paths. For a path from vertex 1 to vertex u, p=(v 1 ​ , v 2 ​ , …, v k ​ ) (v 1 ​ =1, v k ​ =u), let f(p) denote the largest i such that (B 1 ​ , B 2 ​ ,…, B i ​ ) is a subsequence of (A v 1 ​ ​ , A v 2 ​ ​ , …, A v k ​ ​ ) (or 0 if it does not exist). Additionally, let d u ​ be the smallest value of f(p) for a path p from vertex 1 to vertex u. One can check the condition in the Problem Statement by seeing if d N ​ =K, so our objective is to find d u ​ (1≤u≤N). [1] Observation on f(p+(u ′ )) Let p be a path from vertex 1 to vertex u, and u ′ be a vertex adjacent to u. For a path from vertex 1 to vertex u ′ , p ′ =(v 1 ​ , v 2 ​ , …, v k ​ , u ′ ), let us consider f(p ′ ). From the definition, we have f(p ′ )=f(p)+1 if A u ′ ​ =B f(p)+1 ​ and f(p ′ )=f(p) otherwise, since the only difference between p and p ′ is the addition of A u ′ ​ (remember the greedy strategy for subsequence testing). From this, for paths p and q from vertex 1 to vertex u such that f(p)<f(q), we have f(p+(u ′ ))≤f(q+(u ′ )). Therefore, to determine d u ′ ​ , concerning the paths via vertex u, we only have to consider the minimum value of f(p), that is, d u ​ , and the following holds: d u ′ ​ =min u ​ { d u ​ +1 d u ​ ​ (A u ′ ​ =B d u ​ +1 ​ ) (A u ′ ​  =B d u ​ +1 ​ ) ​ . [2] Use 01-BFS From the above observation, it can be seen that the following algorithm finds d u ​ . The correctness can be shown similarly to the proof for Dijkstra’s algorithm. Initialize d u ​ (u  =1) to K+1. For d 1 ​ , initialize it to 1 if A 1 ​ =B 1 ​ and 0 otherwise. Initialize the set S, which consists of vertices u such that d u ​ is unconfirmed, to S={1, 2, …, N}. Repeat the following as long as S is not empty. Remove from S the u with smallest d u ​ among u∈S, since d u ​ is now confirmed. Then, for each vertex u ′ adjacent to u, let d u ′ ​ ←min(d u ′ ​ , d u ​ +1)) if A u ′ ​ =B d u ​ +1 ​ , and d u ′ ​ ←min(d u ′ ​ , d u ​ )) otherwise. This can be implemented similarly to 01-BFS to run in O(N+M) time. D - Removing Gacha Editorial by evima [1] Use the linearity of expectation For k=0, 1, …, N−1, let X k ​ be a random variable representing the number of operations performed after there are k black vertices for the first time before there are k+1 black vertices for the first time. From the linearity of expectation, the answer is ∑ k=0 N−1 ​ E[X k ​ ]. While the number of black vertices does not change, neither does the number of good vertices. Thus, the (conditional) expected value of X k ​ when there are exactly m black vertices at the moment there are k black vertices for the first time is N−m N−k ​ 1 ​ = N−k N−m ​ . From this, if p k,m ​ is the probability that there are exactly m good vertices at the moment there are k black vertices for the first time, it can be seen that E[X k ​ ]= m=0 ∑ N ​ N−k p k,m ​ (N−m) ​ = N−k N ​ − N−k 1 ​ m=0 ∑ N ​ p k,m ​ m. Therefore, it is enough to find m=0 ∑ N ​ p k,m ​ m, that is, the expected number of good vertices at the moment there are k black vertices for the first time. If q k,i ​ is the probability that vertex i is good at the moment there are k black vertices for the first time, the expected number of good vertices is ∑ i=1 N ​ q k,i ​ from the linearity of expectation. [2] Focus on operations that choose white vertices Let d i ​ be the number of ancestors of vertex i (including itself). Let us find q k,i ​ . The white vertex that turns black is always chosen with equal probability. Thus, the sought probability is equal to the probability that when k of N balls are chosen uniformly at random, some specified d i ​ balls are all chosen, which is q k,i ​ = ( k N ​ ) ( k−d i ​ N−d i ​ ​ ) ​ = N!(k−d i ​ )! k!(N−d i ​ )! ​ when d i ​ ≤k and 0 otherwise. [3] Use NTT Therefore, it is enough to find N! k! ​ 1≤i≤N,d i ​ ≤k ∑ ​ (k−d i ​ )! (N−d i ​ )! ​ for each k. If c i ​ is the number of v such that d v ​ =i, we have: 1≤i≤N,d i ​ ≤k ∑ ​ (k−d i ​ )! (N−d i ​ )! ​ = i=1 ∑ k ​ c i ​ (k−i)! (N−i)! ​ . This is the convolution of f i ​ =c i ​ (N−i)! and g i ​ = i! 1 ​ , so one can find the values for all k in O(NlogN) time by using NTT. E - Weathercock Editorial by evima Below, we only consider the case there are more Rs than Ls. (The case there are more Ls than Rs can be reduced to this one by a horizontal flip. In the case there are equal numbers of Ls and Rs, it can be seen that the people only change direction at t=0.5 from an argument similar to [1] and [2] below.) Let us expand S to a length of NK, and change S according to the people changing direction. [1] The change at t=0.5 Let us consider the changes at t=0.5, 1.5, 2.5, … by using f i ​ = (The number of Rs in S 0 ​ , S 1 ​ , …, S i ​ ) − (The number of Ls in S 0 ​ , S 1 ​ , …, S i ​ ) (let f −1 ​ =0 for convenience). Then, the condition for person i to change direction can be described as follows. When S i ​ =L, person i changes direction if 0≤f i ​ . When S i ​ =L, person i changes direction if f NK−1 ​ <f i ​ . Particularly, if f NK−1 ​ ≤min(f i ​ , f i−1 ​ ), person i always changes direction regardless of S i ​ . The figure below shows a graph whose horizontal axis represents i and whose vertical axis represents f i ​ when N=15, K=1, S=RRRLRLLLLRRRLLR. A red segment corresponds to a person changing direction with f NK−1 ​ ≤min(f i ​ , f i−1 ​ ) and S i ​ =R, and a blue segment corresponds to a person changing direction with f NK−1 ​ ≤min(f i ​ , f i−1 ​ ) and S i ​ =L. As seen here, all parts of the graph at or above f NK−1 ​ fold down by the change at t=0.5 so that f NK−1 ​ = 0≤i≤NK−1 max ​ f i ​ always hold after the change. (Some people with S i ​ =L, shown as yellow segments, change direction even if f i ​ <f NK−1 ​ , but these changes contribute only positively to the fact that f NK−1 ​ is the maximum.) [2] The changes at 1<t Since f NK−1 ​ becomes the maximum of f i ​ at t=0.5, people with S i ​ =R do not change direction at t=1.5. Thus, f NK−1 ​ will still be the maximum after the change at t=1.5. It can also be inductively seen that f NK−1 ​ will continue to be the maximum and people with S i ​ =R do not change direction through the subsequent changes. Thus, regarding the changes at 1<t, it is enough to consider whether people with S i ​ =L eventually become S i ​ =R. [3] Observation on the final S Consider what S will look like eventually at 1<t. Let k be the smallest i such that 0<f i ​ . First, f i ​ for i with i<k always satisfies f i ​ ≤0, so S i ​ does not change from the initial state. Next, consider person i with k≤i. We begin by noting that S k ​ is always R. If, to the right of person k, there are n people (1≤n) facing left at some time, there will be at most n−1 people facing left after the next change. Proof Therefore, to the right of person k, the number of people facing left will be 0 at time t=O(NK). (A more accurate evaluation reveals that it will be 0 at t=O(logN).) [4] Summary The observations above lead to the following conclusion. Person i with k≤i satisfying f NK−1 ​ <f i ​ and S i ​ =R at t=0 will change direction twice: R → L → R. Person i with k≤i satisfying S i ​ =L at t=0 will change direction once: L → R. The other people never change direction. Now, it is enough to find k and count the numbers of people satisfying the first and second conditions. By using f i ​ =⌊ N i ​ ⌋f N−1 ​ +f imodN ​ , they can be found in O(N) time. F - Constant Sum Subsequence Editorial by evima [0] Notations For integers i and x (1≤i≤N 2 , 1≤x≤S), let behind(i,x) denote the largest j such that A j ​ =x and j<i (if no such j exists, let behind(i,x)=0). Additionally, let front(i,x) denote the smallest j such that A j ​ =x and i<j (if no such j exists, let front(i,x)=∞). These can be found in O(logN) time after preprocessing in O(N) time. For an integer sequence of length n, X=(X 1 ​ , X 2 ​ , …, X n ​ ), let f(X) denote the largest s satisfying the following. Every sequence Y of positive integers totaling s is a subsequence of X. [1] Dynamic programming Let dp i ​ =f((A 1 ​ , A 2 ​ , …, A i ​ )) and compute them in the order i=1, 2, …. For convenience, let dp −1 ​ =−1 and dp 0 ​ =0. An integer sequence (IS) totaling S whose last term is x can be considered as (an IS totaling S−x) +(x). Thus, the condition to have every IS totaling S ending with x as a subsequence is S−x≤dp behind(i,x)−1 ​ . From this, we have dp i ​ = 1≤x≤S min ​ (dp behind(i,x)−1 ​ +x). [2] Find just the necessary parts In the above dynamic programming, dp i ​ is computed for all −1≤i≤N 2 . However, since dp i ​ is monotonic with respect to i, it is enough to find the smallest i such that dp i ​ =s for each −1≤s≤S (it can be seen that such an i always exists by considering a sequence of positive integers ending with x=1). If dp i ​ is needed during computation, it can be found with binary search. Let us think of a way to find the smallest i ′ such that dp i ′ ​ =s+1 when dp i ​ =s (s<S) is known. By considering x such that dp behind(i,x)−1 ​ +x=s, we see that front(i,x)≤i ′ is necessary. On the other hand, if this is satisfied, we have dp behind(i ′ ,x)−1 ​ +x≥dp i ​ +x≥s+1. Thus, the smallest i ′ such that dp i ′ ​ =s+1 is the maximum value of front(i,x) for x such that dp behind(i,x)−1 ​ +x=s. Therefore, the following algorithm can find L. Initialize with L=0 and S x ​ =x−1. For s=0, 1, …, S−1 in this order, do the following. For x such that S x ​ =s, let L ′ =front(L,x). For i such that L<i≤L ′ , let S A i ​ ​ ←dp behind(L ′ ,A i ​ )−1 ​ +A i ​ and L←L ′ . A good point of this algorithm is that the processing in 2. is performed only O(∑ x=1 S ​ x S ​ )=O(SlogS) times since S x ​ increases by x when S x ​ =s. However, when updating L, one must also update S x ​ =dp behind(L,x)−1 ​ +x for each x, which is the bottleneck. [3] Delay the update So, when updating L, let us not update dp behind(L,x)−1 ​ +x for each x to the correct value. Instead, let us update it when S x ​ =s. That is, use the following algorithm to find L. Initialize with L=0, T x ​ =x−1 (1≤x≤S). For s=0, 1, …, S−1 in this order, do the following. For x such that T x ​ =s, let T x ​ ←dp behind(L,x)−1 ​ +x. Then, if T x ​ =s, let L←front(L,x) and T x ​ ←s+x. Now, the issue by updating T x ​ is resolved, but what about the number of times the processing in 2. is performed? Actually, after T x ​ =s is satisfied twice, T x ​ will have increased by at least x. Proof Thus, the processing in 2. is again performed O(∑ x=1 S ​ x S ​ )=O(SlogS) times. Therefore, the above algorithm finds the smallest L that satisfies the condition in O(N+SlogS(logS+logN)) time. A - Repdigit Number Editorial by evima Hints → https://atcoder.jp/contests/arc149/editorial/4961 [1] Basic policy For positive integers 1≤d≤9 and n, let x(n,d) denote the integer made by concatenating n copies of d: x(n,d)= n dd⋯dd ​ ​ . The problem asks us to find the maximum integer that can be written as x(n,d) ( 1≤n≤N, 1≤d≤9) and is a multiple of M. Since there are 9N numbers x(n,d) in total, even if we do a computation taking O(1) time for every x(n,d), it takes O(N) time in total. It leads us to think of the following solution. Compute x(n,d)modM for every (n,d). Find the maximum x(n,d) such that x(n,d)modM=0. The second part, finding the maximum, is simple: we just choose the one with the maximum d among the ones with the maximum n. Below, let us explain how to compute x(n,d)modM for every (n,d). [2] Computing x(n,d)modM Here are two ways to compute x(n,d)modM assuming that x(n−1,d)modM, etc. are already known, allowing us to find all the desired x(n,d)modM in O(N) time. [2 - 1] Computing x(n,d) (1) By noting that x(n−1,d) is a prefix of x(n,d), we see that: x(n,d)=10x(n−1,d)+d . One can compute each x(n,d)modM in O(1) time by using this formula to do the computation in ascending order of n. [2 - 2] Computing x(n,d) (2) By noting that x(n−1,d) is a suffix of x(n,d), we see that: x(n,d)=d×10 n−1 +x(n−1,d). If one uses this formula, one also needs the values 10 n−1 modM, which can also be computed in ascending order of n using 10 n =10×10 n−1 , allowing one to compute each x(n,d)modM in O(1) time again. [3] Advanced topics One can also find the (n,d) giving the maximum faster, as follows. Fix d. Find the smallest positive integer n such that x(n,d) is a multiple of M, which can be done similarly to Problem G in ABC 270 by noting x(n,d)=10x(n−1,d)+d. Let n 0 ​ be the smallest positive integer n such that x(n,d) is a multiple of M. Then, one can prove that x(n,d) is a multiple of M if and only if n is a multiple of n 0 ​ . Thus, one can find the largest n by finding the largest multiple of n 0 ​ at most N, which can be done in O(1) time. This method allows one to find the optimal (n,d) in an expected time complexity of O( N ​ ) etc. One can find it even faster by using fast prime factorization, x(n,d)=d⋅ 9 10 n −1 ​ , and Euler’s theorem, etc. In this problem, however, it takes Ω(N) time to print the answer, so these methods do not allow one to solve it in o(N) time. B - Two LIS Sum Editorial by evima Hints → https://atcoder.jp/contests/arc149/editorial/4961 [1] Rephrasing the problem Since one may swap adjacent (A i ​ ,B i ​ ) and (A i+1 ​ ,B i+1 ​ ) any number of times, one may arrange the N tuples (A i ​ ,B i ​ ) in any order. Thus, the problem can be rephrased into the following. We are to arrange N tuples (A i ​ ,B i ​ ) freely and then mark some of the 2N numbers (A 1 ​ ,…,A N ​ ), (B 1 ​ ,…,B N ​ ). Here, all marked A i ​ must be increasing, and the same goes for all marked B i ​ . Find the maximum number of numbers that can be marked. [2] Structure of an optimal solution One can prove the following: there is an optimal solution that marks all A i ​ . Let us do it. First, if there is i such that both A i ​ and B i ​ are unmarked, one can insert that (A i ​ ,B i ​ ) in an appropriate position and then mark A i ​ to have more marks. Thus, we can see that, in optimal solutions, A i ​ or B i ​ is marked for every i. Similarly, we can also prove that there is an optimal solution that marks all A i ​ . If there is an optimal solution that does not mark A i ​ , one can insert that tuple in an appropriate position and then unmark B i ​ and instead mark A i ​ to have more marks on A i ​ while keeping the total number of marks. Therefore, one can take an optimal solution and repeat this operation as long as possible to get an optimal solution that marks all A i ​ . [3] How to solve the problem In the end, one can compute the answer to the problem as follows. Sort the N tuples (A i ​ ,B i ​ ) in ascending order of A i ​ . The answer is then LIS(A)+LIS(B)=N+LIS(B). One can compute LIS(B) in O(NlogN) time, and so the problem in O(NlogN) time. Computing LIS Here we list two methods. Let dp[x] be the greatest length of an increasing subsequence ending with x when one considers up to some term in the sequence. Then, one can compute dp[x] fast using a segment tree. If the upper limit on x is large, one should compress the coordinates beforehand. Let dp[k] be the smallest possible final term of an increasing subsequence of length k when one considers up to some term in the sequence. Then, one can compute dp[k] fast by binary search. C - Avoid Prime Sum Editorial by evima Hints → https://atcoder.jp/contests/arc149/editorial/4961 [1] Using parity Let us use the fact that any even number 4 or greater is not prime. Specifically, let us fill the upper half of the grid with odd numbers and the lower half with even numbers. Two different positive odd numbers, or two different positive even numbers, sum to an even number 4 or greater, which is not prime. Thus, almost all sums of two adjacent numbers in this grid are guaranteed not to be prime. It remains to think of a way to do with the part where odd and even numbers are adjacent. [2] Using multiples of 3 Under the policy in [1], we just need to make around N pairs of odd and even numbers that do not sum to a prime number, and place them around the border of odd and even to achieve the objective. This is a rather loose condition, which can be met in many ways. Here, let us do it by making the sums multiples of 3 that are 6 or greater. When N≥6, there are not less than N odd numbers and N even numbers that are multiples of 3. Let us place them around the border. One simple way to implement it is to place the following from top to bottom in order. The odd numbers that are not multiples of 3 The odd numbers that are multiples of 3 The even numbers that are multiples of 3 The even numbers that are not multiples of 3 This method of filling the border with multiples of 3 cannot handle the case 3≤N≤5. There are only three instances, so it is reasonable to solve them by hand and hardcode the solutions, which look like the following. For N=4, one could use the Sample Output. D - Simultaneous Sugoroku Editorial by evima Hints → https://atcoder.jp/contests/arc149/editorial/4961 [1] Observations Let us compute the results for all initial positions 1,2,…,10 6 . We label the piece whose initial position is x with the ID x. Let us observe how these pieces move. Initially, the 10 6 pieces are arranged consecutively in the order of ID on the positive part of the number line. Here, the relationship between the IDs and coordinates of the pieces is simple, and we can easily handle the destinations of the move altogether. The first move will divide the sequence of pieces into three parts: negative, origin, and positive. There is nothing to compute for a piece that comes to the origin, so let us consider the negative and positive parts. If we only look at one of these parts, the second move is represented by the same formula, so we might be able to handle the destinations of the second move altogether. Troublingly, however, the formulae for the two parts are different. Let us think of a way to deal with this. [2] Solution For two pieces that are at coordinates x and −x at some time, their subsequent movements will be symmetric with respect to the origin. Thus, for these pieces, we just need to compute the movement of only one of them. Then, among the two sequences of pieces on the positive and negative parts of the line, we do not need to manage the shorter one, that is, compute the movements of the pieces that belong to it. Thus, one can solve the problem by implementing the following appropriately. Simulate the movement of the sequence of pieces whose coordinates have the same sign by maintaining the relationship between the IDs and coordinates of the pieces. When a piece arrives at the origin, fix the answer for that piece, and stop tracing that piece. When the sequence of pieces is divided into positive and negative parts, stop tracing the pieces belonging to the shorter part after recording the IDs of the pieces at the symmetric positions. For these pieces, find the answer after all moves using the recorded IDs. Here, the number of times one fixes the answer for a piece or records the ID of the piece at the symmetric position is at most the total number of pieces, so it takes O(M+maxX i ​ ) time. To elaborate, when the pieces are divided into positive and negative parts, consider spanning a (directed) edge from each piece belonging to the shorter part to the symmetric piece. Then, the pieces form a directed forest. After all moves, one can propagate the answer from the roots to find the answers for all pieces. See also the following image. E - Sliding Window Sort Editorial by evima Hints → https://atcoder.jp/contests/arc149/editorial/4961 [1] Rephrasing the problem (1) The problem gradually shifts the segment to sort, but one can convert the coordinate so that this segment always starts at the left end so that the problem repeats the following operation K times. Operation: Sort (A 0 ​ ,…,A M−1 ​ ) and then circular shift the sequence to the left by 1. Below, we handle this problem. For instance, the sequence A=(4,1,5,6,2,3) in Sample Input 1 will change as follows: (4,1,5,6,2,3)→(4,5,6,2,3,1)→(5,6,2,3,1,4)→(5,6,3,1,4,2)→(5,6,1,4,2,3)→(5,6,4,2,3,1). [2] Rephrasing the problem (2) The operation will look even simpler if we divide the sequence into the left M−1 terms and right N−M+1 terms. The left M−1 terms will always be arranged in ascending order after one or more operations, so let us handle this part simply as a set. Let us write L=M−1, R=N+M−1 for simplicity. Call the set of the left L terms of the sequence the left set, and the sequence of the right R terms of the sequence the right sequence. Then, the process can be rephrased into the following. We have a left set with L terms and a right sequence with R terms. In the operation, we move the term at the beginning of the right sequence to the left set, and then move the smallest element in the left set to the end of the right sequence. Initial state	 {1,4}	 (5,6,2,3) 1st operation	 {4,5}	 (6,2,3,1) 2nd operation	 {5,6}	 (2,3,1,4) 3rd operation	 {5,6}	 (3,1,4,2) 4th operation	 {5,6}	 (1,4,2,3) 5th operation	 {5,6}	 (4,2,3,1) [3] Reduction to the case K=R The problem can be reduced to the case K=R, where the operation is repeated until every term in the right sequence is inserted into the left set exactly once. If K<R, where some terms are never inserted into the left set, we can simply ignore those terms. Consider the case K>R. After the operation is performed R times, the left set has the largest L numbers: {R+1,…,N}. Afterward, a number inserted into the left set gets deleted immediately, so the (R+1)-th and subsequent operations are simply a circular shift of the right sequence. From this fact, one can restore the state after R operations from the state after K operations, so the case K>R can be reduced to the case K=R. [4] Counting Assume that the state after K operations has the left set {R+1,…,N} and the right sequence (x 1 ​ ,…,x R ​ ) (if the left set is not this one, the answer is 0). Let us count initial states {a 1 ​ ,…,a L ​ },(b 1 ​ ,…,b R ​ ) consistent with this. First, it is necessary that if x i−1 ​ >x i ​ , b i ​ =x i ​ . This is because all elements in the left set at the end of the (i−1)-th operation are greater than x i−1 ​ . By ignoring those b i ​ and x i ​ , the problem can be reduced to the case (x i ​ ) is increasing. Here, the conditions imposed on a i ​ and b j ​ can be expressed as follows. One of a 1 ​ ,…,a L ​ ,b 1 ​ is equal to x 1 ​ . One of a 1 ​ ,…,a L ​ ,b 1 ​ ,b 2 ​ is equal to x 2 ​ . One of a 1 ​ ,…,a L ​ ,b 1 ​ ,b 2 ​ ,b 3 ​ is equal to x 3 ​ . ⋮ Then, by considering which of the a i ​ and b j ​ is equal to x 1 ​ ,x 2 ​ ,… in this order, one can see that there are (L+1) R initial states. In the original problem, the left set is simply a sequence, so the answer gets multiplied by L!. F - Rational Number System Editorial by evima Hints → https://atcoder.jp/contests/arc149/editorial/4961 [1] The unique existence of base- r expansion Let us first prove the unique existence of base- r expansion, which was also mentioned in the Problem Statement. We begin with showing the following: if n has a base- r expansion (a 1 ​ ,…,a k ​ ), then a k ​ =nmodp. Actually, by multiplying both sides of n=∑ i=1 k ​ a i ​ r k−i by q k−1 , one sees that p∣q k−1 (n−a k ​ ), so one obtains n≡a k ​ (modp) from gcd(p,q)=1 (A simpler proof is possible by expanding the notion of “the remainder when divided by p” to rational numbers whose denominator is coprime with p). From this, one also sees the following: if n=px+y ( 0≤y≤p−1) has a base- r expansion (a 1 ​ ,…,a k ​ ), then a k ​ =y, and the prefix (a 1 ​ ,…,a k−1 ​ ) is an empty sequence or the base- r expansion of qx. This inductively shows the unique existence of base- r expansion. [2] The trie structure To study the order by base- r expansion, let us use a trie. As seen in the proof in [1], the base- r expansion of n=px+y is the base- r expansion of qx with y appended to the end, so let us span an edge from qx to px+y to construct a trie. The figure below shows the trie when r=3/2. One can also see that the integers corresponding to the nodes in the trie match the BFS order. Let us evaluate the depths of the nodes with integers at most N. The depth k is the length of the base- r expansion, so we have r k−1 ≤N, that is, k≤1+log r ​ N. Under the constraints of this problem, k≤1+log 1.01 ​ (10 18 )=4166.342⋯. Below, let D denote the depth of the trie. [3] Computing the answer The lexicographical order on base- r expansions matches the pre-order in DFS on the trie. Thus, one can perform DFS on the trie and report the L-th, …, R-th nodes to solve the problem in O(N) time. Let us optimize this DFS. If the L-th node is found, one can compute the (L+1)-th, …, R-th nodes by a simple DFS in a total of O(R−L+D) time, so let us concentrate on the L-th node. Since the depth of the trie is D, we need to do the following D times: from some node in the trie, find which of its children has the sought node in its subtree. If we use binary search to find this, we want to do the following fast enough: compute the sum of the sizes of the subtrees of the first n children of some node in the trie. Since the integers corresponding to the nodes in the trie match the BFS order, the set of integers corresponding to the nodes in a subtree at a fixed depth form an interval. Thus, by finding the lower and upper limits of that interval, one can compute the number of nodes at a fixed depth. By doing this for every depth, one can solve the problem above in O(D) time. By summarizing all of the above, the original problem can be solved in O(D 2 logp+R−L) time. A - mod M Editorial by evima First, consider the case you choose M=2. xmod2 is 1 if x is odd and 0 if x is even, so every element in A becomes 0 or 1. Thus, there will be at most two different elements in A. Therefore, the answer is at most 2. Now, let us try to find the answer as follows. In some way, check if there is an M that makes the number of different elements 1. If there is such an M, the answer is 1; otherwise, it is 2. To make this check easier, let us rephrase the condition “the number of different elements becomes 1” into the following: A 1 ​ and A 2 ​ become the same, A 2 ​ and A 3 ​ become the same, ⋮, and A N−1 ​ and A N ​ become the same after the operation. For what M will A i ​ and A i+1 ​ match? It is an M such that the remainder when A i ​ is divided by M equals the remainder when A i+1 ​ is divided by M, which is the same as an M such that A i ​ −A i+1 ​ is divisible by M. Thus, there is an M that makes the number of different elements 1 if and only if: there is an M that divides all of A 1 ​ −A 2 ​ ,A 2 ​ −A 3 ​ ,…,A N−1 ​ −A N ​ . We can check this fast using the notion of the greatest common divisor. Let g=gcd({∣A 1 ​ −A 2 ​ ∣,∣A 2 ​ −A 3 ​ ∣,…,∣A N−1 ​ −A N ​ ∣}). If g=0: In this case, the following holds for all i: ∣A i ​ −A i+1 ​ ∣=0⟺A i ​ =A i+1 ​ . Thus, the number of different elements is already 1 before the operation, so it will remain 1 no matter what M is chosen. If g=1: Assume for contradiction that there is a positive integer x such that choosing M=x makes the number of different elements 1. Then, every ∣A i ​ −A i+1 ​ ∣ should be divisible by x, so g should be a multiple of x, contradicting with g=1. Therefore, there is no M satisfying the condition. If g≥2: Choosing M=g makes all elements in A the same. Now that we can check if there is an M that makes the number of different elements 1, the problem is solved fast enough in O(Nlogmax(A)) time. B - dp Editorial by evima A naive solution is to try all (L,R) such that 1≤L≤R≤N, find all resulting S, and print the lexicographically smallest of these strings plus the original S. It will print the correct answer, but there are O(N 2 ) pairs (L,R), and each string is of length N, so it takes O(N 3 ) time, which is too much. Let us try to narrow down the pairs to check. First, if S solely consists of d, it is optimal to skip the operation and print S as it is. Below, consider the case S contains p. Let i be the leftmost index of p in S. Also, let g(l,r) be the S resulting from the choice (L,R)=(l,r). Here, the following holds: For any g(L,R),L  =i, there is an R ′ such that g(i,R ′ )<g(L,R). (∗) We will prove this by division into cases according to the magnitude relationship between i and L. 1. If i<L: Let us compare g(i,i) and g(L,R). The first (L−1) characters are the same, but the L-th characters of g(i,i) and g(L,R) are d and p, respectively, so g(i,i)<g(L,R). 2. If i>L: Let us compare g(i,R) and g(L,R). The 1-st through (L−1)-th characters and the (R+1)-th through N-th characters are the same, so we look at the rest. The L-th through (i−1)-th characters of S are all d from the assumption, so let U be a string of length i−L solely consisting of d, and the i-th through R-th characters of the two strings are as follows. the i-th through R-th characters of g(i,R): U+f(T) the i-th through R-th characters of g(L,R): f(U+T)=f(T)+f(U) Now, for each of U+f(T) and f(T)+f(U), consider the leftmost index of p. (They have the same length, so if the leftmost positions of p in these strings are different, we can know which string is smaller.) We use division into cases according to whether f(T) contains p. a. If f(T) contains no p: U+f(T) solely consists of d and contains no p. On the other hand, f(U) solely consists of p, so the (∣T∣+1)-th character of f(T)+f(U) is p. Therefore, U+f(T)<f(T)+f(U). b. If the leftmost index of p in f(T) is j: The leftmost index of p in U+f(T) is ∣U∣+j, while that of f(T)+f(U) is j. Therefore, U+f(T)<f(T)+f(U). Thus, we have U+f(T)<f(T)+f(U) in both cases. Therefore, g(i,R)<g(L,R) holds in case 2. From the above, (∗) holds in all cases. By using (∗), we can see that only the pairs (L,R) such that L=i need to be checked to find the answer, because for any g(L,R) (L  =i), there is a smaller string g(i,R ′ ). Now, the number of strings to be checked decreases from O(N 2 ) to O(N), for a total complexity of O(N 2 ), which is fast enough. C - Lights Out on Tree Editorial by evima First, the following properties about pressing buttons hold. Pressing the same button twice changes nothing. The order to press buttons does not matter. These can be shown by naive arguments, but they can also be smartly explained by linear algebra on mod 2. From these facts, we need to press the same button at most once, and we only need to check 2 N cases: for each button, we press it or not. Let B={1,2,…,N} be the set of all buttons. The query gives us a vertex set S and asks us to find the set of buttons T⊆B such that: Pressing each button in T once flips exactly the coins in S. (∗) Here, the following fact holds. For a fixed vertex set S given in a query, there is exactly one set of buttons that satisfies (∗). First, we will show that at least one T exists. Consider the case S is of size 1 and S={v}. In this case, we can see that pressing the buttons corresponding to v itself and its all children flips just v. (Let T v ​ be this set of buttons.) Consider a general case. Let S={v 1 ​ ,v 2 ​ ,…,v m ​ }. Then, the set of buttons that appear an odd number of times satisfies the requirement, which can be shown from the above property “pressing the same button twice changes nothing.” Thus, we have shown that at least one T corresponds to S. Next, we will verify that there is at most one such T. There are 2 N −1 possible non-empty vertex sets S. On the other hand, there are 2 N possible button sets, but T=∅ flips nothing and corresponds to no S, so there are 2 N −1 sets T that correspond to some S. Since the number of sets that can be S is equal to the number of sets that can be S, it is obvious that at most one T corresponds to each S. Therefore, it has been shown that there is always exactly one button set that satisfies the requirement. Now, we only need to find the size of T that corresponds to S to solve the problem. This size can be computed in the method seen in the proof of the existence of T. Naive computation takes O(N) time, but one can, say, sort the vertices in BFS order and use a data structure such as a segment tree. The above is enough to solve the problem, but after some more observation (which we omit), one can solve the problem, without any advanced data structure, by just implementing the following. Pre-compute the number of children of each vertex. The answer to the i-th query is j=1 ∑ M i ​ ​ (the number of children of v i,j ​ , plus one), but subtract 2 from this for each pair of (parent, child). (Maintain S i ​ with an associative array to do this fast.) The solution runs in about O(N+(∑ i ​ M i ​ )log(∑ i ​ M i ​ )) time. D - mod M Game Editorial by evima We begin with the answer. Consider a graph with 2N vertices where vertex i has A i ​ written on it. Span a red edge between vertices with the same number. Also, if M is even, span a blue edge between vertices whose difference of the written numbers modulo M is M/2. If there is a perfect matching using an even number of blue edges, Bob wins; otherwise, Alice wins. Let us verify this. Below, we will only evaluate game states where it is Alice’s turn. Let us fix notations to describe a game state. Assume that the blackboard now has B=(B 1 ​ ,B 2 ​ ,…,B 2k ​ ), and let S and T be the sum of numbers deleted by Alice and Bob, respectively. Call the graph constructed as explained above G. Also, let d be (S−T)modM. 1. The case with an odd M This is the easier case, so let us start with it. We can ignore the condition on blue edges since G has only red edges if M is odd. Let us do some division into cases. 1.1 A state where G has a perfect matching and d=0 Bob can win by imitating Alice, that is, deleting the same number as Alice. One can show the validity of this inductively from the fact that Bob wins if G is empty, and the case where ∣G∣>0 can be reduced to a case with two less vertices. 1.2 A state where G has a perfect matching and d  =0 If ∣G∣=0, obviously Alice wins. If ∣G∣>0, Alice can win by a modified imitating strategy as follows. Alice arbitrarily chooses an element x in B and deletes it. If Bob next deletes y such that y  =x, Alice also deletes y. Repeat this until Bob deletes x. When Bob deletes x after repeating 2. zero or more times, the graph G ′ has a perfect matching, and d remains 0, so Alice can return to 1. and repeat the same procedure. This strategy allows Alice to make ∣G∣=0 while keeping d  =0. 1.3 A state where G has no perfect matching (with any d) Assume that the blackboard now has B=(B 1 ​ ,B 2 ​ ,…,B 2k ​ ). We will first consider the case the size of the maximum matching in G is k−1. Let u and v be the numbers written on the vertices not used in this matching. Here, we have u  =v and Mmod2=1, so (u−v)modM and (v−u)modM are different ( ∵u−v≡v−u⟺2(u−v)≡0(modM)). Thus, at least one of (d+u−v)modM and (d−u+v)modM is non-zero. Without loss of generality, we assume (d+u−v)modM  =0. Here, it can be verified that Alice can win by deleting u and employing the imitating strategy in 1.2. (We will omit the details.) In the case the size of the maximum matching in G is k−2 or less, constantly deleting a number written on a vertex that does not form the matching leads to the case ∣(the size of the maximum matching)∣+1=∣G∣/2. 2. The case with a general M The proof in 1.3 does not hold for a general M, particularly an even M. For instance, when M=8 and (u,v)=(1,5), we have 1−5≡5−1≡4(mod8), so if d=4 and the blackboard is left with (1,5), Bob wins. Let us consider whether a perfect matching exists in the graph where, in addition to red edges, a blue edge is spun between vertices whose difference of the written numbers modulo M is M/2 if M is even. 2.1 A state where G has no perfect matching (with any d) Here, u−v  =v−u(modM) holds for any pair of numbers (u,v) written on vertices without an edge between them, so we see that Alice can win by an argument similar to the one in 1.3. 2.2 A state where G has a perfect matching (with any d) If there is a perfect matching, from 2.1, Bob must keep choosing a vertex connected by an edge to the vertex chosen by Alice, because otherwise there would be no perfect matching in the graph. (It is unnecessary to know the winner here, so we do not prove it.) 2.3 A state where G has a perfect matching at the beginning of the game Consider the case there is a perfect matching formed by G at the beginning of the game. From 2.2, if both players play optimally, the vertices deleted by Alice and subsequently deleted by Bob in all 2N operations must be connected by edges, so they form a perfect matching. Here, we can verify that the parity of the number of blue edges is constant across all possible perfect matchings in G. Choosing a red edge in a matching does not change d while choosing a blue edge shifts d by M/2, so if there is an odd number of blue edges in an arbitrarily chosen perfect matching, Alice wins; otherwise, Bob wins. All of the above show that the answer at the beginning is correct. One can use an associative array to compute it in about O(NlogN) time, which is fast enough. E - ≥ K Editorial by evima We will solve the case the elements of A are distinct. (If A contains equal numbers, the same solution can be used after ordering equal numbers according to their indices.) Below, a sequence where adjacent elements sum to at most K is said to be valid. Consider obtaining a valid sequence B that is a permutation of A, as follows. Start with an empty sequence B. Perform the following operation N times to move all elements of A to B. Let L and R be the smallest and largest values in A, respectively. Compare L+R and K. If L+R<K, remove L from A and put it in an arbitrary position in B. If L+R≥K, remove R from A and put it in an arbitrary position in B. In either case, B must be valid after the insertion. Consider the number of sequences B that can be generated in this way. Let us begin with verifying the following fact: When inserting L,R in B, we have L<K/2,R≥K/2. This immediately holds from the condition in the branch. (For respective cases, we have 2L≤L+R<K, 2R≥L+R≥K.) Now, after performing the operation i times (0≤i<N), the length of B is i. Here, let us call a gap between B j ​ and B j+1 ​ (1≤j≤i+1) that satisfies the following condition a space. (Let B 0 ​ =B i+1 ​ =∞ for convenience.) (current minA) +min(B i−1 ​ ,B i ​ )≥K Then, let S i ​ be the number of spaces in B after performing the i-th operation. (Particularly, if i=0, B is empty and S 0 ​ =1.) Here, it can be proved that one always inserts an element of A into a space. (Proof outline) When L is inserted, the proposition obviously holds from the definition of space. Consider the case R is inserted. Assume that the R inserted by the i-th operation can be represented as K/2+d (d≥0). Since L+R≥K, we have L≥K/2−d, so if j does not correspond to a space, min(B j ​ ,B j+1 ​ ) is smaller than K/2+d. Also, every element in B at this point is either less than K/2−d or at least K/2+d. Therefore, min(B j ​ ,B j+1 ​ )<K/2−d holds for non-space positions, into which R cannot be inserted. Additionally, the following facts can be shown. When the i-th operation inserts L, the number of spaces decreases by 1. When the i-th operation inserts R, the number of spaces increases by 1. (Proof outline) The former is obvious from L<K/2. The latter follows from the fact that when the R inserted by the i-th operation can be represented as K/2+d (d≥0), all elements in A less than K/2 are at least K/2−d. Moreover, the value inserted by the i-th operation is constant, no matter where it is inserted. Thus, it can be said that the sequence S 0 ​ ,S 1 ​ ,S 2 ​ ,…,S N ​ is constant, no matter how one performs the operations. From the arguments above, the number of sequences that can be generated by the above procedure is ∏ i=0 N−1 ​ S i ​ . Let C i ​ be the B at the end of the i-th operation. The whole process of N operations can be represented as a sequence of length N+1: (C 0 ​ ,C 1 ​ ,…,C N ​ ). Below, we call such a sequence an operation array. So far, we have explained how one obtains a sequence from an operation array. Actually, it can be proved that the set of all sequences generated by operation arrays covers all valid sequences that are permutations of A. To prove this, we will explain how one conversely obtains an operation array from a sequence. For a permutation B of A where adjacent elements sum to at most K, consider performing the following operation N times to empty B. Choose an element x in B that minimizes ∣K/2−x∣ and remove it. (If there are multiple such elements, choose the one that itself is the smallest.) Here, it can be shown that B is always valid during the process. (Proof outline) Let d≥0. When removing x=K/2−d, both elements adjacent to x are at least K/2+d, so B is still valid after removing x. When removing x=K/2+d, every elements remaining in B are either less than K/2−d or at least K/2+d. If x is adjacent to a number less than K/2−d, one can inductively derive a contradiction, so x must be adjacent to numbers at least K/2+d, in which case B is still valid after removing x. Moreover, it can also be verified that the i-th element removed by the removing operation equals the (N+1−i)-th element inserted by the inserting operation. (Proof is omitted.) Let C N−i ​ be the B after i removing operations. The whole process of N removing operations can be represented as a sequence of length N+1: (C N ​ ,C N−1 ​ ,…,C 1 ​ ,C 0 ​ ). From the above arguments, the reversal of this sequence (C 0 ​ ,C 1 ​ ,…,C N ​ ) is a valid operation array. Therefore, we have constructed a bijection between the set of operation arrays and the set of sequences, so the answer to the problem is ∏ i=0 N−1 ​ S i ​ . One can use sorting and std::map to compute it in about O(NlogN) time, which is fast enough. F - 998244353 → 1000000007 Editorial by evima The problem can basically be solved by using Montgomery multiplication (Wikipedia). See this article for a detailed explanation of what this is. (Below, the usage of variables follows this article.) Simply speaking, Montgomery multiplication is an algorithm to compute A×BmodN using only multiplication, addition, and a modulo operation mod R (without using the modulo operation mod N). The following code assigns A×BmodN to C. (Below, N ′ is the smallest positive integer such that N ′ N≡−1(modR), and R 2 ​ =R 2 modN.) Copy uint64_t reduce(uint64_t T) { uint64_t t = (T + (T % R * Nprime % R) * N) / R; if (t >= N) t -= N; return t; } uint64_t A = a, B = b, C; void f() { A = reduce(A * R_2); B = reduce(B * R_2); C = A * B; C = reduce(C); C = reduce(C); } uint64_t reduce(uint64_t T) { uint64_t t = (T + (T % R * Nprime % R) * N) / R; if (t >= N) t -= N; return t; } uint64_t A = a, B = b, C; void f() { A = reduce(A * R_2); B = reduce(B * R_2); C = A * B; C = reduce(C); C = reduce(C); } Let us consider performing Montgomery multiplication with N=10 9 +7,R=998244353. The part reduce(T) in the code above is called Montgomery reduction, which is the key to the problem. By reading the code, we can see that everything can be implemented using the given instructions except the following two parts. / R in the first line The if statement in the second line The division with R can be relatively easily handled by using the fact that the multiplication takes mod 2 64 . Let S be an integer such that SR≡1(mod2 64 ). For any 64-bit integer X that is a multiple of R, it holds that X/R and XS are congruent modulo 2 64 , and this value is uniquely determined between 0 and 2 64 −1. Therefore, the division by R may be replaced with multiplication by S without changing the result. Now, proceed to the if statement. There are several approaches. Method 1 Here is a straightforward approach. To simplify the problem, consider the following function F(t): F(t)=(1 if t ≥N else 0). If F(t) can be computed using only the given instructions, the if statement can be replaced by t+F(t)×(2 64 −1). Let us try to implement F(t). We need to do a calculation that produces different results when 0≤t<N and when N≤t<2N. One way to do so is as follows. Consider storing the following p and q in variables. p=t+2 64 −N,q=t+2 64 +2R−N If t<N, only q is greater than or equal to 2 64 , so the value to be stored in q is the true value minus 2 64 . Thus, (q−p)modR is 2 64 modR. On the other hand, if N≤t<2N, both p and q are greater than or equal to 2 64 and get subtracted by 2 64 . Thus, (q−p)modR is 0. Therefore, we see that F(t) can be computed by performing appropriate multiplication and addition by constant numbers on (q−p)modR. (Since 2 64 modR does not have a multiplicative inverse modulo 2 64 , the required implementation is more complex than it seems, which we will omit.) With this, one can completely implement the function reduce, which one can use to perform Montgomery multiplication to achieve the objective. Method 2 Another approach (former model solution) is a “feat of strength.” Montgomery multiplication maintains TR −1 as a value between 0 and N−1. The if statement in Montgomery reduction is used to normalize the t in the previous statement, which takes a value between 0 and 2N−1, into the range [0,N). To put it the other way around, one can do without the if statement and still obtain a value congruent to the true value modulo N if there is no overflow, etc. So, let us do the multiplication without normalization in reduce, that is, consider the operation represented as the following function incomplete_reduce: Copy uint64_t incomplete_reduce(uint64_t T) { return (T + (T % R * Nprime % R) * N) / R; } uint64_t incomplete_reduce(uint64_t T) { return (T + (T % R * Nprime % R) * N) / R; } Consider a code where the function reduce is replaced with incomplete_reduce (shown below). If the C in the fifth line of f is always less than N, this would be correct (it is not). Copy uint64_t A = a, B = b, C; void f() { A = incomplete_reduce(A * R_2); B = incomplete_reduce(B * R_2); C = A * B; C = incomplete_reduce(C); C = incomplete_reduce(C); } uint64_t A = a, B = b, C; void f() { A = incomplete_reduce(A * R_2); B = incomplete_reduce(B * R_2); C = A * B; C = incomplete_reduce(C); C = incomplete_reduce(C); } By evaluating the value assigned to the left side in each line, it can be verified that the C in the fifth line is at most N+6. (Details are omitted, but one can use the fact that the return value of incomplete_reduce is bound by (T+(R−1)N)/R. Stricter evaluation is also possible.) By the way, the return value of incomplete_reduce depends on T, and one can see that a smaller T allows a stricter evaluation of the output. So, let us perform the reduction once again, that is, add the following to the code as the sixth and seventh lines. Copy C = incomplete_reduce(C * R_2); C = incomplete_reduce(C); C = incomplete_reduce(C * R_2); C = incomplete_reduce(C); Then, it can be verified that C<N+1. (Details are again omitted, but the writer thinks it is necessary to use R 2 ​ <N/3.) Additionally, it never happens that C=N. (In such a case, at least one of a and b should be 0, which would make C=0 since incomplete_reduce(0) = 0.) Thus, C is always less than N. Therefore, it has been proved that performing the incomplete reduction one extra time ensures that C becomes less than N, allowing one to compute a×bmodN. From the above, one can compute a×b(modN) by implementing Method 1 or 2 in the program. There should be enough lines to implement either method. (Our solutions had 27, 37, 40, and 40 lines.) By the way, you can reduce instructions by first computing A×B and then performing a reduction on that value. The explanation of Method 1 was written referring to maspy’s program, and the note on reducing instructions was written referring to maroon’s program. The writer thanks the admin and testers. A - Max Mod Min Editorial by evima [1] Naive simulation One can solve this problem by simulating the process as follows. Search for an integer i such that A i ​ =min({A 1 ​ ,A 2 ​ ,…,A k ​ }) in O(N) time. Search for an integer j such that A j ​ =max({A 1 ​ ,A 2 ​ ,…,A k ​ }),i  =j in O(N) time. Set A j ​ to (A j ​ modA i ​ ). If A j ​ becomes 0, delete it. Instead of actually deleting an element, one can replace it with a special value such as −1, which takes O(1) time. This solution takes O(NX) time, where X is the answer. Since each operation decreases the length of A by at most 1, we have X≥N, so it will run out of time. [2] Analyzing X To analyze the value X, consider the number of times a certain element gets chosen as A j ​ in the simulation above. When A j ​ is chosen, A j ​ becomes less than half since 2 A j ​ ​ ≥(A j ​ modA i ​ ). Proof Therefore, each element in A gets chosen as A j ​ at most O(logmaxA) times, so X is O(NlogmaxA). [3] Optimizing the simulation First, let us sort A so that A 1 ​ ≤A 2 ​ ≤⋯≤A N ​ . Then, let us repeat the following. Take out A k ​ from A, where k is the current length of A. If (A k ​ modA 1 ​ )>0, insert (A k ​ modA i ​ ) at the beginning of A. Otherwise, do nothing. One can see that A 1 ​ ≤A 2 ​ ≤⋯≤A k ​ always holds during the process of this simulation. One can perform all operations above in O(1) time by using a double-ended queue. Therefore, the problem can be solved in O(X+NlogN) time. B - Swap to Sort Editorial by evima [1] Preface This problem is a combination of optimization and construction. One can solve it through step-by-step observations organizing the conditions. [2] Minimizing the number of Operations A Let us look at the parity of P i ​ . Call i a good index when P i ​ and i have the same parity, and a bad index otherwise. Then, call the number of bad indices the disparity of P, and consider how it changes in the process. In Operation A, the disparity of P increases by 2, 0, or −2, which can be seen from the following case-by-case analysis. Before the operation, if both i and i+1 are good indices: the disparity of P increases by 2. if both i and i+1 are bad indices: the disparity of P decreases by 2. if one of i and i+1 is good and the other is bad: the disparity of P does not change. Additionally, in Operation B, the disparity of P does not change. From these properties and the fact that the desired state of P (sorted in ascending order) has a disparity of 0, one can see that: Operation A must be performed at least 2 1 ​ ×( the initial disparity of P ) times. Note: It can be proved that the disparity of P is always even, as long as P is a permutation of (1,2,…,N). [3] Making the disparity of P 0 Consider how to make the disparity of P 0 by performing Operation A exactly 2 1 ​ ×( the initial disparity of P ) times. From the case-by-case analysis above, to do with that number of Operations A, one must perform Operation A only for i such that both i and i+1 are bad indices. This can be easily done when the good and bad indices are in the following arrangement (O and X stand for good and bad indices, respectively): OOXXOXXO However, it is a little hard in this case: So, let us take advantage of the fact that Operation B may be performed any number of times to make the bad indices gather at an end. XXXXOOOO Now, one can perform Operation A exactly 2 1 ​ ×( the initial disparity of P ) times to make the disparity of P 0. Note: One can perform just Operation B to make the bad indices gather at an end because P is a permutation of (1,2,…,N) and thus has the same number of even bad indices and odd bad indices. [4] Sorting P in ascending order Now that P has a disparity of 0, i and P i ​ have the same parity for every i. So, by finding i such that P i ​ >P i+2 ​ and performing Operation B for that i, one can sort P in ascending order. [5] Analyzing the total number of operations Finally, let us check whether the total number of operations is at most 10 5 . To make the bad indices gather at an end, one has to perform Operation B at most 4 N ​ × 2 N ​ times. One has to perform Operation A at most 2 N ​ times. To sort P in ascending order in the end, one has to perform Operation B at most ( 2 N ​ ) 2 times. For N=400, these sum up to 60200 operations, well within the limit of 10 5 . Sample implementation (C++) Copy #include <bits/stdc++.h> using namespace std; int p[405]; vector<pair<char,int>> ans; void f(char c,int i){ ans.emplace_back(c,i+1); swap(p[i],p[i+1+c-'A']); } int main(){ int N; cin >> N; for(int i=0;i<N;i++) cin >> p[i]; for(int i=0;i<N;i++) for(int j=0;j<N-2;j++) if(p[j]%2!=p[j+2]%2 && p[j]%2!=j%2) f('B',j); for(int i=0;i<N-1;i++)if(p[i]%2!=p[i+1] && p[i]%2==i%2) f('A',i); for(int i=0;i<N;i++) for(int j=0;j<N-2;j++) if(p[j]>p[j+2]) f('B',j); cout << ans.size() << endl; for(auto x:ans) cout << x.first << ' ' << x.second << endl; } C - Min Diff Sum Editorial by evima [1] Preface The problem does not require advanced knowledge and heavy implementation at all, but starting in the right direction may not be easy. [2] Solution Let us look at the maximum among L i ​ and minimum among R i ​ and let L l ​ =M,R r ​ =m. Now, do the following case-by-case analysis. 1. If M≤m Let X be an integer such that M≤X≤m. Since M is the maximum among L i ​ , we have L i ​ ≤X for all i. Similarly, we have X≤R i ​ for all i. Thus, everyone can stand at coordinate X, for a dissatisfaction level of 0. 2. If M>m M>m means L l ​ >R r ​ , so we have l  =r. Now, consider the dissatisfaction level where x l ​ =A and x r ​ =B. First, one can show that B≤x i ​ ≤A for all i in an optimal solution. Proof: Assume that there is i such that x i ​ <B or x i ​ >A in an optimal solution. Since B≤m<M≤A, we have B≤R i ​ and L i ​ ≤A for all i. Thus, one can reassign x i ​ =B for all i such that x i ​ <B and x i ​ =A for all i such that x i ​ >A to decrease the dissatisfaction level, which is a contradiction. Let C be the sum of the contributions to the dissatisfaction level by pairs of people, none of whom is l or r. Then, the dissatisfaction level can be represented as: i=1 ∑ N−1 ​ j=i+1 ∑ N ​ ∣x j ​ −x i ​ ∣=C+∣A−B∣+ i  =l,r ∑ ​ ∣x i ​ −B∣+ i  =l,r ∑ ​ ∣A−x i ​ ∣. By using B≤x i ​ ≤A, this can be transformed into: C+(A−B)×(N−1). To minimize this, one should let A=M,B=m. By recursively computing C from the above, the final answer can be found as: i=0 ∑ N−1 ​ max(0,L i ​ −R i ​ )×(N−2×i−1) where L and R are sorted in descending and ascending order, respectively. Sample implementation (C++) Copy #include <bits/stdc++.h> using namespace std; int main(){ int N; cin >> N; vector<long long> L(N),R(N); for(int i=0;i<N;i++)cin >> L[i] >> R[i]; sort(L.begin(),L.end(),greater<>()); sort(R.begin(),R.end()); long long ans=0; for(int i=0;i<N;i++) ans += max(0ll,L[i]-R[i])*(N-2*i-1); cout << ans << endl; } D - Sets Scores Editorial by evima [1] Fixing the common elements It is difficult to handle the condition that the number of elements contained in exactly one of S i ​ and S i+1 ​ is 1, so let X i ​ be that element contained in exactly one of S i ​ and S i+1 ​ . Below, we consider the problem for fixed X 1 ​ ,X 2 ​ ,…,X N−1 ​ . [2] Solving the fixed case Determining S 1 ​ will also determine S 2 ​ and all subsequent sets, so there are 2 M possible brilliant sequences of sets. Let A x ​ be the number of sets containing x when S 1 ​ contains x, and B x ​ be the number of sets containing x when S 1 ​ does not contain x. Then, the sum of the scores for all possible choices of S 1 ​ is (A 1 ​ +B 1 ​ )(A 2 ​ +B 2 ​ )…(A M ​ +B M ​ ), which equals N M since A i ​ +B i ​ =N. [3] Finding the whole sum There are M N−1 choices of X, each of which yields the total score of N M , so the answer is N M ×M N−1 . Therefore, the problem is solved in O(logN+logM). E - Examination Editorial by evima [1] Checking if the answer is −1 Let us first consider how to check if the objective is achievable at all by performing any number of swaps. Since it is optimal to assign a higher score to a person with a greater B i ​ (stricter requirement), the objective is achievable if and only if: B i ​ ≤A i ​ for every i when A and B are sorted in ascending order. This is probably the common first try, but we need to rephrase this condition a little. For 1≤t≤10 9 , let cnt t ​ =( the number of i such that B i ​ ≤t )−( the number of i such that A i ​ ≤t ). Then, cnt t ​ ≥0 holds for every t. These two conditions are equivalent. [2] Finding the maximum number of unswapped people If B i ​ ≤A i ​ holds for every i already in the beginning, the answer is N. Otherwise, we have to find a set S of people whose scores are swapped that minimizes ∣S∣. S must contain all people with A i ​ <B i ​ in the beginning. So, let us initialize S as the set of people with A i ​ <B i ​ in the beginning, and add other people to S one at a time until cnt t ​ ≥0 holds for every t. In what order should we add people? Consider the minimum t such that cnt t ​ <0 at the moment. Then, we must add Person i such that B i ​ ≤t and t<A i ​ . If there is no such person, the objective is unachievable. If there are multiple such people, the person i with the maximum A i ​ should be chosen, because B i ​ does not matter since we have chosen the minimum t such that cnt t ​ <0. This solution works in O(NlogN) time by using, say, a priority queue. Sample implementation (C++) Copy #include <bits/stdc++.h> using namespace std; int main(){ int N; cin >> N; priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq1; priority_queue<int> pq2; map<int,int> mp; int ans=N; for(int i=0;i<N;i++){ int A,B; cin >> A >> B; if(A<B){ mp[A]--; mp[B]++; ans--; } else pq1.emplace(B,A); } int cnt=0; for(auto x:mp){ while(!pq1.empty()&&pq1.top().first<=x.first){ pq2.push(pq1.top().second); pq1.pop(); } cnt+=x.second; while(cnt<0){ if(pq2.empty()||pq2.top()<=x.first){ cout << -1 << endl; return 0; } cnt++; ans--; mp[pq2.top()]--; pq2.pop(); } } cout << ans << endl; } F - Again ABC String Editorial by evima [1] Rephrasing the problem The problem is equivalent to the following one: There are X+Y+Z+3 points on a circumference, consecutively numbered 0 to X+Y+Z+2. There are three people standing at Points 0, X+1, and X+Y+2. Now, let us perform the following operation M times. Choose a person. Let i be the index of the point he stands at, and send him to Point (i+1)mod(X+Y+Z+3). Here, no two people may come to the same point. Find the number of ways to perform M operations, modulo 2. Below, let us solve this problem. We let M=X+Y+Z+3, and call the people starting at Points 0, X+1, and X+Y+2 Person 1, 2, and 3, respectively. [2] Looking it backward Let us look at the process backward. That is, we try to find the number of ways where Persons 1, 2, and 3 end up at Points 0, X+1, and X+Y+2, respectively, but their initial positions do not matter as long as Persons 1, 2, and 3 stand in this order. This does not change the answer. [3] Using dynamic programming The problem above can be solved by dynamic programming where: dp[i][j][k]:= the number of ways to perform i operations after which (coordinate of Person 2) − (coordinate of Person 1) =jmod M and (coordinate of Person 3) − (coordinate of Person 2) =kmod M without no collisions so far, modulo 2, with the following transition: { dp[i][j][k]=dp[i−1][j−1][k]+dp[i−1][j+1][k−1]+dp[i][j][k+1](1≤i≤N,1≤j,k≤M−2,j+k≤M−1). ​ This should be initialized by dp[0][j][k]=1, and the answer is dp[N][X+1][Y+1]. Assume that all values at invalid indices are 0. It takes O(NM 2 ) time as it is, far beyond the limit. [4] "Method of mirror images" Below is a slice of dp[i]: ( M=5) dp[i][1][1] dp[i][1][2] dp[i][1][3] dp[i][2][1] dp[i][2][2] dp[i][3][1] Let us expand this dp[i]. Specifically, let us expand the range of j,k from 1≤j,k≤M−2,j+k≤M−1 to 0≤j,k≤M−1. The entry where 1≤j,k≤M−2,j+k≤M−1 does not hold is defined as follows: { dp[i][j][k]=0(j=0 or k=0 or j+k=0mod M) dp[i][j][k]=dp[i][M−k][M−j](else). ​ Then, the transition can be done as follows: { dp[i][j][k]=dp[i−1][j−1modM][k]+dp[i−1][j+1modM][k−1modM]+dp[i][j][k+1modM](1≤i≤N,0≤j,k≤M−1), ​ which can be proved by noting that dp[i][j][k]=dp[i][k][j] and dp[i][j][k]=dp[M−(j+k)][j]. That is, if we let f i ​ (x,y)=∑ j=0 M−1 ​ ∑ k=0 M−1 ​ dp[i][j][k]x j y k , it holds that f i+1 ​ (x,y)=f i ​ (x,y)×(x+ x y ​ + y 1 ​ )mod(x M −1)(y M −1). Here, note that we may have f 0 ​ (x,y)=(∑ j=0 M−1 ​ ∑ k=0 M−1 ​ x j y k )+(∑ j=0 M−1 ​ x j )+(∑ k=0 M−1 ​ y k )+(∑ j=0 M−1 ​ x j y M−j ) since we work modulo 2. The answer is the coefficient of x X+1 y Y+1 in f N ​ (x,y). Let us consider each term in f 0 ​ (x,y). Below, we reduce everything modulo (x M −1)(y M −1). (∑ j=0 M−1 ​ ∑ k=0 M−1 ​ x j y k ) gets multiplied by all terms in (x+ x y ​ + y 1 ​ ) N , so the coefficient of x X+1 y Y+1 in (∑ j=0 M−1 ​ ∑ k=0 M−1 ​ x j y k )×(x+ x y ​ + y 1 ​ ) N is 1. For (∑ j=0 M−1 ​ x j ), we may ignore x, so the coefficient of x X+1 y Y+1 in (∑ j=0 M−1 ​ x j )×(x+ x y ​ + y 1 ​ ) N equals the coefficient of y Y+1 in (1+y+ y 1 ​ ) N . Similarly, the coefficient of x X+1 y Y+1 in (∑ k=0 M−1 ​ y k )×(x+ x y ​ + y 1 ​ ) N equals the coefficient of x X+1 in (x+ x 1 ​ +1) N . Similarly, the coefficient of x X+1 y Y+1 in (∑ j=0 M−1 ​ x j y M−j )×(x+ x y ​ + y 1 ​ ) N equals the coefficient of x X+Y+2 in (x+1+ x 1 ​ ) N , since x and y do not have to be distinguished. Therefore, solving the following problem three times will solve our problem. Find the coefficient of x K in (x+1+ x 1 ​ ) N mod(x M −1), modulo 2. Here, since (x+y) 2 a =x 2 a +y 2 a mod2, we have (x+1+ x 1 ​ ) N =∏ i=1 k ​ (x 2 A i ​ +1+x −2 A i ​ ) where N=2 A 1 ​ +2 A 2 ​ +2 A 3 ​ +⋯+2 A k ​ . Note that k=O(logN). [5] An O(MlogN) solution The above problem can be solved by dynamic programming where dp[i][j]=[x j ]∏ p=1 i ​ (x 2 A p ​ +1+x −2 A p ​ ), in O(MlogN) time. [6] An O( M NlogN ​ ) solution Let us multiply everything by x N and consider ∏ i=1 k ​ (1+x 2 A i ​ +x 2 A i ​ +1 ). Here, instead of taking modulo (x M −1), let us take the sum of the coefficients of x K+iM over all integers i such that x K+iM and 0≤K+iM≤2N. Then, the problem can be solved by solving the following one: You are given positive integers N and X. Find the number, modulo 2, of triples of non-negative integers A, B, and C such that A+B+C=N, (A or B or C)=N, and B+2C=X. This can be solved by a digit DP that scans the bits of N in ascending order and maintains the carry, in O(logN) time. We solve this subproblem O( M N ​ ) times, so this solution works in O( M NlogN ​ ) time. [7] Summary Therefore, one can solve the problem: Find the coefficient of x K in (x+1+ x 1 ​ ) N mod(x M −1), modulo 2. in O( N ​ logN) time by choosing one of the two solutions above that works faster, the original problem can also be solved in O( N ​ logN) time. A - Three Cards Editorial by evima [1] Which cards should be used? One should always use the cards with the three greatest integers. We can show this as follows: if A i ​ >A j ​ and Card i is not chosen while Card j is chosen, one can replace Card j with Card i in the concatenated integer to make it greater. [2] Computing the answer Now that we know which three cards to use, we should try all six ways to arrange the cards and print the greatest result. Note that arranging them in descending order may not be optimal. For example, arranging 9,9,10 in descending order makes 1099, but we can make 9910 here. The problem is now solved in O(N) time. B - Plus and AND Editorial by evima [1] Notation For a non-negative integer X, let the superior set of X be the set of non-negative integers Y such that X AND Y=X. [2] Using binary search To find the answer, one should maintain a variable ANS that is initialized to 0 and do the following for each i=31,30,…,1,0 in this order. If one of the elements of the superior set of ANS+2 i can be obtained as the bitwise AND of the chosen K elements in at most M operations, set ANS to ANS+2 i . This greedy method is valid because 2 i >2 0 +2 1 +⋯+2 i−1 and thus one should get 1 in as high bits as possible. [3] Solving the decision problem Let us find the number of operations required to obtain one of the elements of the superior set of a non-negative integer X. We will find for each i ( 1≤i≤N) the smallest integer B i ​ that is at least A i ​ and contained in the superior set of X, and choose the K elements with the smallest B i ​ −A i ​ . To find the smallest integer B i ​ that is at least A i ​ and contained in the superior set of X, do the following for each j=31,30,…,1,0 in this order. If the j-th bit of X is 1, do nothing. If the j-th bit of X is 0, make it 1 if the result of setting the 0-th through (j−1)-th bits of X to 1 is less than A i ​ , and do nothing otherwise. Now, we have found the number of operations required to make one of the elements of the superior set of a non-negative integer X in O(N(logN+logA)) time. [4] Summary The problem can therefore be solved in O(NlogA(logN+logA)) time. Note that A i ​ can become as large as 2 31 −2. C - Even XOR Editorial by evima [1] Rephrasing the conditions The condition is satisfied if and only if there is no non-empty subset of S whose size is even and the XOR of whose elements is 0. [2] Adding elements To S satisfying the condition, what non-negative integer can we add so that the condition is still satisfied? Let T be a subset of S whose size is odd, and X be the XOR of the elements in T. If X is added to S, the set resulting from adding X to T has an even size, and the XOR of the elements in this set is 0, so the condition will be violated. On the other hand, a non-negative integer Y that is never equal to the XOR of the elements in an odd-sized subset of S can be added to S without violating the condition. Additionally, let T and U be two odd-sized subsets of S. If T and U differ, we can prove that their XORs of the elements also differ. Indeed, if they were equal, the set V consisting of the elements that are contained in exactly one of T and U has an even size, and the XOR of the elements in V is 0, contradicting the fact that S satisfies the condition. Therefore, for every set S satisfying the condition, the number of non-negative integers that can be added to S without violating the condition is 2 N −(the number of odd-sized subsets of S). [3] Using dynamic programming Let us consider a dynamic programming solution where dp[i]:=(the number of sets of size i satisfying the condition ). We have dp[0]=1. From the above argument, the transitions are: { dp[i]=dp[i−1]×2 N (i=1) dp[i]= i dp[i−1]×(2 N −2 i−2 ) ​ (i≥2) ​ Here, the division by i comes from the need to consider the order in which the elements are added. From the above formula, it can be seen that there is no set of size N+2 or greater that satisfies the condition. Therefore, the problem is solved in O(N) time. D - >=< Editorial by evima [1] Rephrasing the condition Let us denote the K parts of the condition by Condition 1 to Condition K. Then, Condition i is equivalent to (A P i ​ ​ ≤X−1⟺A Q i ​ ​ ≤Y−1) and (A P i ​ ​ ≤X⟺A Q i ​ ​ ≤Y). Below, assume that we have multiple conditions in the form A P i ​ ​ ≤X i ​ ⟺A Q i ​ ​ ≤Y i ​ . [2] Constructing the optimal solution Let us begin with A=(1,1,…,1). Then, we repeat updating A Q i ​ ​ to max(A Q i ​ ​ ,Y i ​ +1) if A P i ​ ​ >X i ​ . The case A Q i ​ ​ >Y i ​ is treated similarly. When we have done this until there is nothing to update, if all elements of A are at most M, A has the smallest possible sum. Otherwise, no sequence satisfies all conditions. One can prove this from the fact that if A P i ​ ​ >X i ​ , the only way to satisfy A P i ​ ​ ≤X i ​ ⟺A Q i ​ ​ ≤Y is to let A Q i ​ ​ >Y i ​ . [3] Summary The simulation of the above process can be done in O(N+K) time if implemented appropriately. Thus, the problem can be solved in O(N+K) time. E - Simple Speed Editorial by evima [1] Using dynamic programming Let us call an integer sequence where the absolute difference between adjacent elements is always 1 (including a length- 1 sequence) a fantastic IS. Consider the following dynamic programming: dp[i][j][k]:=(the number of ways to make a sequence of fantastic ISs C 1 ​ ,C 2 ​ ,…,C j ​ by only using values at most i while satisfying all of the following conditions ) For each l such that 2≤l≤j, C l ​ begins with i. For each l such that 1≤l≤j−1, C l ​ ends with i. Exactly k of the beginning of C 1 ​ and the end of C j ​ is less than or equal to i−1. This counts the number of sequences of arrays that can result when only extracting values at most i from B. For example, the fantastic IS (2,3,2,1,2,3,4,3,4,3,2,3) goes through the following four entries of the table dp. (1) (dp[1][1][0]) (2),(2,1,2),(2) (dp[2][3][0]) (2,3,2,1,2,3),(3),(3,2,3) (dp[3][3][1]) (2,3,2,1,2,3,4,3,4,3,2,3) (dp[4][1][1]) One can consider this process as insertions to perform the transitions in this dynamic programming. Summing up dp[i][j][0],dp[i][j][1],dp[i][j][2] yields dp[i+1]. ⎩ ⎪ ⎪ ⎨ ⎪ ⎪ ⎧ ​ dp[i+1][A i+1 ​ −j][0]=dp[i][j][0]×( j A i+1 ​ −1 ​ ) dp[i+1][A i+1 ​ −j+1][1]=dp[i][j][0]×2×( j−1 A i+1 ​ −1 ​ ) dp[i+1][A i+1 ​ −j+2][0]=dp[i][j][0]×( j−2 A i+1 ​ −1 ​ ) ​ { dp[i+1][A i+1 ​ −j+1][1]=dp[i][j][1]×( j−1 A i+1 ​ −1 ​ ) dp[i+1][A i+1 ​ −j+2][2]=dp[i][j][1]×( j−2 A i+1 ​ −1 ​ ) ​ { dp[i+1][A i+1 ​ −j+2][2]=dp[i][j][2]×( j−2 A i+1 ​ −1 ​ ) ​ [2] Complexity analysis In the above dynamic programming, if we maintain all triples of (i,j,k), the complexity will be O(N×maxA). We will try to reduce the complexity by only maintaining (i,j,k) where dp[i][j][k]  =0. For a fixed (i,k), let us examine the values of j such that dp[i][j][k]  =0. For simplicity, let X i ​ =A i ​ −A i−1 ​ +A i−2 ​ −A i−3 ​ +…. 1 2 3 4 ​ 0 X 1 ​ X 2 ​ X 3 ​ X 4 ​ ​ 1 X 2 ​ +1 X 3 ​ ,X 3 ​ +1 X 4 ​ ,X 4 ​ +1 ​ 2 X 2 ​ +2 X 3 ​ ,X 3 ​ +1,X 3 ​ +2 X 4 ​ ,X 4 ​ +1,X 4 ​ +2 ​ ​ From this, one can see that the number of (i,j,k) such that dp[i][j][k]  =0 is O(N). [3] Summary The problem can therefore be solved in O(N+maxA). One can simplify the implementation by using associative arrays, for example. F - Simple Solitaire Editorial by evima [1] Rephrasing the problem Assume that the process continues even if the number of PCT’s cards becomes M or greater. Consider the sequence A P ​ defined as A P,i ​ :=(the number of PCT’s cards after i operations ) for 0≤i≤N when the process uses the permutation P. For a permutation P such that A P ​ =X to exist with a score of at least 1, all of the following conditions must be satisfied. X i ​ +1≥X i+1 ​ for 0≤i≤N−1. X 0 ​ =X N ​ =0. 1≤X i ​ ≤M−1 for 1≤i≤N−1. If X satisfies this, the score of the permutation P such that A P ​ =X is ∏ i=1 N−1 ​ X i ​ . Here, consider the following sequences Y and Z. Let p 1 ​ ,p 2 ​ ,…,p k ​ be the indices i, in ascending order, such that 0≤i≤N−1 and X i ​ +1>X i+1 ​ . Then, Y=(X p 1 ​ ​ ,X p 1 ​ +1 ​ ,X p 2 ​ ​ ,X p 2 ​ +1 ​ ,…,X p k ​ ​ ,X p k ​ +1 ​ ) and Z=(X p 1 ​ ​ ,X p 1 ​ +1 ​ ,X p 2 ​ ​ ,X p 2 ​ +1 ​ ,…,X p k ​ ​ ) ( 1-indexed). For example, when X=(0,1,2,3,2,3,4,1,1,0), we have Y=(3,2,4,1,1,1,1,0) and Z=(3,2,4,1,1,1,1). Less formally, Y is the sequence of numbers of PCT’s cards before and after procedures where he eats one or more cards, and Z is obtained by removing the 0 at the end of Y. Here, we have ∏ i=1 N−1 ​ X i ​ = ∏ i ​ (Z 2i ​ −1)! ∏ i ​ Z 2i−1 ​ ! ​ . Additionally, there are ∏ i ​ Z 2i ​ ! ∏ i ​ Z 2i−1 ​ ! ​ permutations P such that A P ​ =X. This can be derived by considering when PCT drew the cards that are being eaten in each procedure where he eats cards. Therefore, one can see that the answer to the problem equals the answer to the following problem. Find the sum of ∏ i ​ (Z 2i ​ −1)!×Z 2i ​ ! ∏ i ​ Z 2i−1 ​ ! 2 ​ over all sequences of non-negative integers Z 1 ​ ,Z 2 ​ ,…,Z 2K+1 ​ that satisfy all of the conditions below. ∑ i=1 K ​ (Z 2i−1 ​ −Z 2i ​ +1)+Z 2K+1 ​ +1=N Z 2i−1 ​ ≥Z 2i ​ (1≤i≤K) Z 2i ​ ≤Z 2i+1 ​ (1≤i≤K) 1≤Z i ​ ≤M−1(1≤i≤2K+1) [2] Using the inclusion-exclusion principle Among the above conditions, let us apply the inclusion-exclusion principle to Z 2i ​ ≤Z 2i+1 ​ (1≤i≤K). Then, one can see that the answer can be found by solving the following problem for each 1≤N ′ ≤N. Find the sum of ∏ i ​ (Z 2i ​ −1)!×Z 2i ​ ! ∏ i ​ Z 2i−1 ​ ! 2 ​ ×(−1) K over all sequences of non-negative integers Z 1 ​ ,Z 2 ​ ,…,Z 2K ​ that satisfy all of the conditions below. ∑ i=1 K ​ (Z 2i−1 ​ +1)−∑ i=1 K ​ (Z 2i ​ )=N ′ Z 2i−1 ​ ≥Z 2i ​ (1≤i≤K) Z 2i ​ >Z 2i+1 ​ (1≤i≤K−1) 1≤Z i ​ ≤M−1(1≤i≤2K) ( Z 2K+1 ​ at the end of the sequence should be handled separately.) Below, let us consider this problem. To solve this, one can use dynamic programming by letting dp[i][j][k] as follows. Consider the situation in which the part of Z consisting of i and greater values is already determined, and lmod2=j where Z l ​ is the end of that part. Then, dp[i][j][k] is the sum of ∏ i ​ (Z 2i ​ −1)!×Z 2i ​ ! ∏ i ​ Z 2i−1 ​ ! 2 ​ over all Z such that (∑ i=1 ⌊ 2 l+1 ​ ⌋ ​ Z 2i−1 ​ +1)−(∑ i=1 ⌊ 2 l ​ ⌋ ​ Z 2i ​ )=k. [3] Optimizing the computation If we compute this whole table, the complexity will be O(NM), but the transitions in dp can be represented by a product of matrices whose entries are polynomials. That is, if we let dp[i][j]=∑ i=0 ∞ ​ dp[i][j][k]x k , the transitions are as follows. From dp[i][0] to dp[i−1][0], there are two transitions: Do nothing. The coefficient is 1. Add two is at the end of Z. The coefficient is −ix. From dp[i][0] to dp[i−1][1], there is one transition: Add one i at the end of Z. The coefficient is −(i!) 2 x. From dp[i][1] to dp[i−1][0], there is one transition: Add one i at the end of Z. The coefficient is i!(i−1)! x ​ . From dp[i][1] to dp[i−1][1], there is one transition: Do nothing. The coefficient is x. Thus, if we let V i ​ =( 1−ix i!(i−1)! x ​ ​ −(i!) 2 x x ​ ), dp[1][i] is the (1,i)-entry of V M−1 ​ V M−2 ​ …V 2 ​ V 1 ​ . One can compute this in O(Mlog 2 M) time if one merges the matrices in a way resembling a perfect binary tree. [4] Summary Since the subproblem in the inclusion-exclusion principle is solved, the answer to the original problem can be found by finding the inverse of a polynomial in O(NlogN) time. Therefore, the problem is solved in O(NlogN+Mlog 2 M) time. A - AB Palindrome Editorial by evima [1] Looking at the first and last characters If the first character in S is A, it cannot be changed to B. Similarly, if the last character in S is B, it cannot be changed to A. Therefore, if the first and last characters in S are A and B, respectively, S cannot be turned into a palindrome. Now, let us consider the case the first character is B or the last character is A. If the first character in S is B, and N is at least 3: By performing the operation for 2-nd and 3-rd characters, then for the 3-rd and 4-th characters, and so on, we can turn S into BAAA…AAAB, a palindrome. If the last character in S is A, and N is at least 3: By performing the operation for (N−2)-nd and (N−1)-st characters, then for the (N−3)-rd and (N−2)-nd characters, and so on, we can turn S into ABBB…BBBA, a palindrome. Notice that the argument above depends on the assumption that N is at least 3. Beware the case N=2: S cannot be turned into a palindrome (only) if S is BA. (AA and BB are already palindromes.) [2] The solution Eventually, the answer is No only if one of the following holds, and Yes otherwise: the first and last characters in S are A and B, respectively; S is BA. [3] Sample implementation Python: Copy n = int(input()) s = input() print("Yes" if (s[0] == "B" or s[-1] == "A") and s != "BA" else "No") B - AB Game Editorial by evima [1] When does Alice win? Let n be the initial number of stones and analyze the relation between n, A, and B when Alice wins. If n<A, Alice loses. Below, assume n≥A. Here is an important fact that we need to notice: it is optimal for Alice to take as many stones as possible. Proof Therefore, the necessary and sufficient condition for Alice’s win is: n≥A and nmodA<B. [2] Computing the count Let us count the integers n that satisfy the condition above. Let f(X) be the number of n’s such that nmodA<B and 1≤n≤X. The answer is the number of n’s between A and N satisfying nmodA<B, so it can be represented as f(N)−f(A−1). Using the fact that XmodA is in a cyclic pattern 1,2,…,A−1,0,1,2,…, we can compute f(X) by the following formula: f(X)=⌊ A N ​ ⌋min(A,B)+min(NmodA,B−1). This can be done in O(1) time, so the problem is solved in O(1) time. [3] Sample Implementation Python: Copy n, a, b = map(int, input().split()) def f(x): return x // a * min(a, b) + min(x % a, b - 1) print(max(f(n) - f(a - 1), 0)) C - Split and Maximize Editorial by evima For a division into A and B that maximizes the score, let us say A i ​ and B i ​ to be paired. [1] When is the score maximized? For any positive integers A, B, C, and D such that A<B<C<D, the following holds: AD+BC<AC+BD<AB+CD. Therefore, in a division that maximizes the score, we have the following pairs: 2N and 2N−1, 2N−2 and 2N−3, …, 2 and 1. (Otherwise, the score could be increased by rearranging the pairs accordingly.) [2] Correspondence to parenthesis sequences For each pair (a,b), let us call a the left element when a is to the left of b in P. There are 2 N ways to “direct” the pairs in P, that is, to decide which of each pair is the left element. Additionally, there are N! possible relative orders of the left elements in P. Here, if the elements in P are scanned from left to right, there must always be more left elements than right elements. The number of such arrangements corresponds to that of parenthesis sequences. Eventually, there are N! ways to order the pairs, 2 N ways to direct them, and N+1 1 ​ ( N 2N ​ ) parenthesis sequences (the Catalan number), for a total of 2 N (N+1)! (2N)! ​ sequences that can be made. [3] Sample Implementation Python: Copy mod = 998244353 n = int(input()) res = pow(2, n, mod) for i in range(n + 2, 2 * n + 1): res *= i res %= mod print(res) D - Non Arithmetic Progression Set Editorial by evima Below, a set is called good when y−x  =z−y holds for all triples of distinct elements x,y,z. [1] The condition rearranged It is important that we can rearrange the formula as follows: y−x  =z−y for all distinct three elements x,y,z ⟺ 2y  =x+z for all distinct three elements x,y,z. This rearranging was also used in several past problems ranging from easy to difficult, such as ARC123-A. [2] Without the sum restriction… Let us call an integer n good when the following holds: when n is written in base 3, all digits are 0 or 1. For instance, 10=101 (3) ​ is good, while 7=21 (3) ​ is not. Then, the following property holds: any set consisting of good integers is good. This is not trivial but is easy to prove after the rearranging in [1]. Let us use the base- 3 notation. If y is good, all digits in 2y is 0 or 2. Also, if x and z are good, there is no carry when calculating x+z. Therefore, x+z=2y holds only if x=z=y, completing the proof. [3] Taking care of the sum restriction A good set is still good after adding the same integer to every element. By using this, the sought set can be constructed if the difference between M and the sum of a good set is a multiple of N. Such a good set can be obtained by taking the smallest N positive good integers whose bottom digit is 0 and then adjusting the bottom digits accordingly. Additionally, in a set S obtained this way, it follows from the constraint on ∣M∣ that every element is between −10 7 and 10 7 , so the problem is solved. [4] Sample Implementation Python: Copy n, m = map(int, input().split()) S = [] for i in range(2, 2 * n + 1, 2): s, tmp = 0, 1 for j in range(15): if i >> j & 1: s += tmp tmp *= 3 S.append(s) x = (m - sum(S)) % n for i in range(x): S[i] += 1 diff = (sum(S) - m) // n print(*[s - diff for s in S]) E - Adjacent XOR Editorial by evima Let M be the maximum value in A,B. From the Constraints, M<2 60 . [1] Looking it backward By reversing the process of the operation, one can assume that the following operation is available instead of the given one: Choose an integer K (1≤K≤N). For every i (1≤i≤K), simultaneously replace the value of B i ​ with B 1 ​ ⊕B 2 ​ ⊕…⊕B i ​ . — Below, we consider this version of the problem. [2] Describing the possible states Let us characterize the sequence B after some operations. Let B ′ be the sequence B after zero or more operations. It can be seen that the following holds for each i: B i ′ ​ =B i ​ ⊕(the XOR of some subset of {B 1 ​ ,B 2 ​ ,…,B i−1 ​ }). This can be proved by mathematical induction. Therefore, the objective is achievable if and only if, for each i, A i ​ can be represented as B i ​ ⊕(the XOR of some subset of {B 1 ​ ,B 2 ​ ,…,B i−1 ​ }). This condition can be checked in O(NlogM) time by Gaussian elimination. In fact, if this condition is satisfied, one can always match B to A in at most 70000 operations, as explained below. [3] The specific procedure Below, assume that the necessary and sufficient condition explained above is satisfied. If one chooses K in the operation, B K+1 ​ and subsequent elements will not be affected, so it seems reasonable to try matching B to A from the end to the beginning. If we can match the last elements in O(logM) operations, repeating it N times will match the whole sequences in O(NlogM) operations, which will be at most 70000. Now, let us find a way to match A i ​ and B i ​ in O(logM) operations. Since we are matching the sequences from the end to the beginning, we cannot choose K greater than i. Ignoring the trivial case A i ​ =B i ​ , we have to choose K=i at the end of the process of making A i ​ =B i ​ . An operation with K=i makes B i ​ =B 1 ​ ⊕B 2 ​ ⊕ …⊕B i−1 ​ ⊕B i ​ , so we want to match B 1 ​ ⊕B 2 ​ ⊕ …⊕B i−1 ​ ⊕B i ​ to A i ​ (or make B 1 ​ ⊕B 2 ​ ⊕ …⊕B i−1 ​ ⊕B i ​ ⊕A i ​ =0). Here, let us look at a basis of the sequence. If the basis is found by applying Gaussian elimination in the order i=1,2,…, no operation will change whether each element is contained in that basis. This property follows from the character of B in [2]. Additionally, if there is a basis vector in position j, an operation with K=j+1 can cause a change by B j ​ to B 1 ​ ⊕B 2 ​ ⊕ …⊕B i−1 ​ ⊕B i ​ without causing changes by the basis vectors to the right of j. It follows that one can make A i ​ =B i ​ in O(logM) operations by taking the basis vectors from right to left, checking whether the operation for the current basis vector is required, and carrying it out if it is required. Therefore, if the necessary and sufficient condition in [2] is satisfied, one can always match B to A in O(NlogM) operations. F - Modulo Sum of Increasing Sequences Editorial by evima For convenience, we denote MOD by P. [1] Rephrasing the problem Consider the sequence B defined by B i ​ :=A i ​ +i, and one can see that it corresponds one-to-one with A, so let us count B instead of A. Here, B is strictly increasing, and its elements take values between 0 and M+N−1, so B corresponds one-to-one with a size- N subset of {0,1,…,M+N−1}. From these arguments, if we redefine M to be M+N, the problem can be rephrased into the following: How many ways are there to choose exactly N from 0,1,…,M−1 so that (the sum)modP=K, for each K=0,1,2,…,P−1? Below, we consider this version of the problem. [2] Focusing on a special case It is difficult to solve the problem above for all cases directly, so let us first consider the case MmodP=0. Let V s ​ be the number of choices with the sum of s in the problem above, and consider the polynomial f(x)=∑ s ​ V s ​ x s =[y N ]∏ i=0 M−1 ​ (1+x i y). Finding g(x)=f(x)mod(x P −1) will solve the problem. [3] Using the principles of Fourier transform Let ω be the primitive P-th root of 1 in C (the complex field). If g(ω 0 ),g(ω 1 ),…,g(ω P−1 ) are found, g can be restored in a way similar to inverse Fourier transform. (We have complex numbers here, but eventually, we will only have to work with rational numbers.) Here, we have g(ω k )=f(ω k ), so let us find f(ω k ) instead. A substitution yields f(ω k )=[y N ]∏ i=0 M ′ −1 ​ (1+(w k ) i y). Now, let us use the assumption that MmodP=0. Define H(y)=∏ i=0 P−1 ​ (1+(w k ) i y), and we have f(ω k )=[y N ]H(y) M/P . Here, let us rewrite H. Let g:=gcd(k,P). Using the factor theorem, one computes that H(y)=(1−(−y) g P ​ ) g . Therefore, f(ω k )=[y N ](1−(−y) g P ​ ) P gM ​ , which can be computed using the binomial theorem. Now that g(ω 0 ),g(ω 1 ),…,g(ω P−1 ) are found, let us restore g(x). It holds that [x j ]g(x)= P 1 ​ ∑ i=0 P−1 ​ ω ij g(ω i ) ​ . Directly applying inverse Fourier transform to the above formula requires division by the complex number ω. To avoid this, let us use the fact that g(ω a )=g(ω b ) if gcd(a,P)=gcd(b,P) to put together the computations where the values of g are equal. One can compute ∑ 0≤i<P,gcd(i,P)=k ​ ω ij 1 ​ using the inclusion-exclusion principle, for example, which also shows that this value is an integer. Additionally, g(ω 0 ),g(ω 1 ),…,g(ω P−1 ) are all rational numbers, so all computations can be done with rational numbers without complex numbers. Therefore, the special case can be solved in O(P 2 ) time after pre-computing factorials in O(N+M) time. [4] Solving the general case Consider the case MmodP  =0. Let M ′ be the greatest multiple of P not exceeding M, and fix the number of chosen values between M ′ and M−1. The choices of values between 0 and M ′ −1 can be counted in O(P 2 ) time using the method in [3]. For the choices of values between M ′ and M−1, the problem is to find the number of ways to choose exactly i values between M ′ and M−1 so that (the sum)modP=j, which can be solved with simple dynamic programming. Then, one can straightforwardly merge these two parts. The dynamic programming part needs to be pre-computed just once, which, combined with the fact M−M ′ <P, enables one to try all possible numbers of chosen values between M ′ and M−1 in O(P 3 ) time. Therefore, the problem is solved in O(N+M+P 3 ) time. A - Digit Sum of 2x Editorial by evima [1] Carries in addition and the digit sum Generally, the sum of digits in a+b, f(a+b), satisfies the following: f(a+b)=f(a)+f(b)−9k, where k is the number of carries when calculating a+b using the column method. This is because a carry subtracts 10 from a digit and adds 1 to the next digit. [2] Finding M Assume that a positive integer x satisfies f(x)=N. From [1], we have f(2x)=f(x)+f(x)−9k=2N−9k, where k is the number of carries when calculating x+x using the column method. Thus, the following can be deduced: f(2x)≤2N always holds; f(2x)=2N holds if and only if all digits in x are at most 4. There does exist an x such that f(x)=N and all digits in x are at most 4 (for instance, x= N 111⋯111 ​ ​ ), so we find that M=2N. [3] Finding x Now let us find the smallest positive integer x such that f(x)=N and f(2x)=2N. Such x satisfies the following: All digits are at most 4; All but the most significant digit are 4. The first condition is already discussed in [2]. Let us verify the second condition. Assume that x has a non-most-significant digit that is at most 3. Look at the most significant such digit. By increasing that digit by 1 and decreasing the next significant digit by 1, we can decrease x while still satisfying f(x)=N and f(2x)=2N, which contradicts the minimality of x. There is only one x such that f(x)=N and those two conditions are satisfied, which is: x= k 44⋯44 ​ ​ if N=4k; x=1 k 44⋯44 ​ ​ if N=4k+1; x=2 k 44⋯44 ​ ​ if N=4k+2; x=3 k 44⋯44 ​ ​ if N=4k+3. These M and x should be printed. Output takes Θ(N) time, for a time complexity of Θ(N). B - Gift Tax Editorial by evima [1] Existence of the answer Let us begin by verifying that what the problem asks, “the maximum possible value of min(A 1 ​ ,A 2 ​ ,…,A N ​ ) after your operations,” exists. Since a≤b, the sum of the sequence A does not increase by the operation. Thus, in the final situation, we have min(A 1 ​ ,…,A N ​ )≤S/N, where S is the initial sum of A. This and the fact that A is always an integer sequence guarantee that the maximum possible value of min(A 1 ​ ,…,A N ​ ) exists. [2] Using binary search Consider finding the answer by binary search. For that, we are to solve the following decision problem for a constant C: determine whether one can achieve min(A 1 ​ ,…,A N ​ )≥C by the operation. We can rewrite the condition min(A 1 ​ ,…,A N ​ )≥C into separate conditions for respective terms, which is easier to handle, as follows: determine whether one can satisfy A i ​ ≥C for all i. [3] Solving the decision problem For a sequence of operations to achieve our objective “ A i ​ ≥C for all i,” we can presume the following: One never applies both +a and −b to the same i. Indeed, assume that a sequence of operations achieving the objective contains both of the following: an operation applying +a to A i ​ and −b to A j ​ ; an operation applying −b to A i ​ and +a to A k ​ . We can reduce the number of operations in such a sequence while still satisfying the objective, by canceling these operations if j=k, and replacing these operations with “an operation applying −b to A j ​ and +a to A k ​ ” if j  =k. Therefore, one never applies both +a and −b to the same i, when, for example, achieving the objective with the minimum number of operations. Now, for each i, we can compute the following x i ​ or y i ​ : for i such that A i ​ <C initially: +a must be applied at least x i ​ times, but −b should not be applied; for i such that A i ​ ≥C initially: +a should not be applied, but −b may be applied at most y i ​ times. There is a way to achieve these if and only if ∑x i ​ ≤∑y i ​ . This allows us to solve the decision problem. [4] Summary The decision problem can be solved in O(N) time. As a lower bound for the binary search, the initial value of minA i ​ can be used. As an upper bound, one can use the initial value of ∑A i ​ /N or maxA i ​ from the argument in [1]. Therefore, the whole problem can be solved in O(Nlog(maxA i ​ −minA i ​ )) time. C - K Derangement Editorial by evima [1] A necessary condition For a solution to exist, N≥2K is necessary. Indeed, one can choose A K ​ so that 1≤A K ​ ≤N and ∣A K ​ −K∣≥K only if N≥2K. Below, let us check whether a solution exists under this necessary condition. [2] An unsuccessful greedy algorithm Since the problem asks for the lexicographically minimum, one can come up with the following greedy algorithm: For each i=1,2,3,… in this order, do the following: let A i ​ be the smallest integer x such that ∣x−i∣≥K among the numbers not in A 1 ​ ,…,A i−1 ​ . However, it fails. Indeed, in Sample Input 2, the optimal solution chooses A 4 ​ =7, although x=1 satisfies ∣x−4∣≥3. Why? When constructing the permutation, one must certainly set A i ​ for all i, but one must also set i such that A i ​ =x for all x. For instance, in Sample Input 2, the i such that A i ​ =7 must satisfy i≤4. This will explain why one must choose A 4 ​ =7 in the optimal solution. [3] A successful greedy algorithm Based on the lesson from [2], let us try another greedy algorithm: For each i=1,2,3,… in this order, do the following: If j=i+K is not in A 1 ​ ,…,A i−1 ​ , and j>N−K, let A i ​ =j. Otherwise, let A i ​ be the smallest integer x such that ∣x−i∣≥K among the numbers not in A 1 ​ ,…,A i−1 ​ . It is not clear that this algorithm successfully determines a permutation (that is, it never happens that no x is available), but if it does, the output is optimal because of the argument in [2]. [4] The output of the greedy algorithm Let us confirm that the algorithm in [3] works. First, when 2K≤N≤4K, one can verify that the algorithm returns the following permutation A: When 2K≤N≤3K A i ​ ={ i+K i−N+K ​ (1≤i≤N−K) (N−K<i≤N) ​ When 3K<N≤4K A i ​ = ⎩ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎧ ​ i+K i−K i+K i−2K i−K ​ (1≤i≤K) (K<i≤N−2K) (N−2K<i≤N−K) (N−K<i≤3K) (3K<i≤N) ​ When N≥4K, the algorithm begins by printing (K+1,…,2K,1,…,K) as the first 2K terms and then run in the same way as in the case of N−2K, so it can be inductively deduced that the algorithm does print a solution. Therefore, the problem can be solved in O(N) time by properly implementing the algorithm in [3] or using the formulae above. [5] FYI: the solutions for K=4 Here are samples of the solutions for K=4: N=8: (5,6,7,8,1,2,3,4) N=9: (5,6,7,8,9,1,2,3,4) N=10: (5,6,7,8,9,10,1,2,3,4) N=11: (5,6,7,8,9,10,11,1,2,3,4) N=12: (5,6,7,8,9,10,11,12,1,2,3,4) N=13: (5,6,7,8,1,10,11,12,13,2,3,4,9) N=14: (5,6,7,8,1,2,11,12,13,14,3,4,9,10) N=15: (5,6,7,8,1,2,3,12,13,14,15,4,9,10,11) N=16: (5,6,7,8,1,2,3,4,13,14,15,16,9,10,11,12) N=17: (5,6,7,8,1,2,3,4,13,14,15,16,17,9,10,11,12) ⋮ D - AND OR Equation Editorial by evima [1] Remodeling the problem with sets Let the integers from 0 to 2 N −1 correspond to the subsets of S={0,1,…,N−1} by seeing them as binary sequences. The problem will be rephrased into the following, where 2 S denotes the set of the subsets of S: Count maps f:2 S ⟶{0,1,…,K} such that: f(A)+f(B)=f(A∩B)+f(A∪B) for all A,B∈2 S . [2] Characterization We can prove the following: Assume that f:2 S ⟶Z satisfies f(A)+f(B)=f(A∩B)+f(A∪B) for all A,B∈2 S . Then, f(A)=c+∑ i∈A ​ x i ​ holds for all A∈2 S , where c=f(∅) and x i ​ =f({i})−c ( 0≤i<N). Let us prove this. If we define g:2 S ⟶Z by g(A)=f(A)−c, the following holds: g(∅)=0. g(A)+g(B)=g(A∩B)+g(A∪B) for all A,B∈2 S . g({i})=x i ​ . Additionally, it follows from 1. and 2. that g(A)+g(B)=g(A∪B) if A∩B=∅. By this property, it holds that: g(A)=g( i∈A ⋃ ​ {i})= i∈A ∑ ​ g({i})= i∈A ∑ ​ x i ​ , which shows f(A)=c+∑ i∈A ​ x i ​ . On the other hand, the following also holds: If f:2 S ⟶Z is defined by f(A)=c+∑ i∈A ​ x i ​ for c,x 0 ​ ,…,x N−1 ​ ∈Z, then f(A)+f(B)=f(A∩B)+f(A∪B) holds for all A,B∈2 S . One can easily prove this by separately considering the contribution of c and each x i ​ on both sides. [3] Remodeling the problem again By [2], the counting problem can again be rephrased into the following: Count tuples of integers (c,x 0 ​ ,x 1 ​ ,…,x N−1 ​ ) such that: 0≤c+∑ i∈A ​ x i ​ ≤K for all A∈2 S . If we denote by s − the sum of x i ​ over all i such that x i ​ <0, and by s + the sum of x i ​ over all i such that x i ​ >0, the above inequality can be transformed into 0≤c+s − and c+s + ≤K, that is, −s − ≤c≤K−s + . There are max{0,K+1−s + +s − } such values for c. Since s + −s − =∑ i ​ ∣x i ​ ∣, our problem is now: Find the sum of (1+K−∑ i ​ ∣x i ​ ∣) over all tuples of integers (x 0 ​ ,…,x N−1 ​ ) such that ∑ i ​ ∣x i ​ ∣≤K. [4] Computing the answer. We will explain two methods. Method 1 Let us first fix the number n of indices i such that x i ​  =0 and then do the count. There are ( n N ​ ) ways to choose i’s, and 2 n ways to choose their signs. We should multiply these by: the sum of (1+K−∑ i ​ x i ​ ) over all tuples of positive integers (x 1 ​ ,…,x n ​ ) such that ∑ i ​ x i ​ ≤K. This is equal to the following counts: The number of tuples of positive integers (a,x 1 ​ ,…,x n ​ ) such that a+∑x i ​ ≤K+1. The number of tuples of positive integers (a,b,x 1 ​ ,…,x n ​ ) such that a+b+∑x i ​ =K+2. These counts equal ( n+1 K+1 ​ ), so the answer is: n=0 ∑ N ​ 2 n ( n N ​ )( n+1 K+1 ​ ). Method 2 Let a n ​ be the number of tuples of integers (x 1 ​ ,…,x N ​ ) such that (x 1 ​ ,…,x N ​ ). Consider the generating function f(x)=∑ n=0 ∞ ​ a n ​ x n of a n ​ , which is: f(x)=(1+2x+2x 2 +2x 3 +⋯) N =( 1−x 1+x ​ ) N = (1−x) N (1+x) N ​ . The answer is (K+1)a 0 ​ +Ka 1 ​ +⋯+1⋅a K ​ , which can be represented as [x K ]f(x)g(x) using g(x)=1+2x+3x 2 +⋯=(1−x) −2 . Thus, the answer is [x K ] (1−x) N+2 (1+x) N ​ . If we represent the numerator as ((1−x)+2x) N , the binomial expansion leads to the formula we obtained in Method 1. Alternatively, a direct binomial expansion of the numerator shows that the answer is: n=0 ∑ N ​ ( n N ​ )( N+1 K−n+N+1 ​ ), which can also be computed. In either case, the answer can be found in O(N) time by efficiently computing the required binomial coefficients (for example, one can compute the ratio between their values for respective n’s, or use a data structure that can handle range products). E - GCD of Path Weights Editorial by evima [1] Conversion to edge weight The problem considers the total vertex weight of a path. It is occasionally easier to handle total edge weight than total vertex weight (because, for example, it acts additively with respect to the concatenation of paths), so let us first convert our subject of study to total vertex weight by building a graph G ′ as follows: For each vertex v in G, make two vertices v in ​ ,v out ​ , for a total of 2N, which will be the vertices in G ′ . For each directed edge vw in G, span a directed edge v out ​ w in ​ with a weight of 0 in G ′ . If a vertex v in G has a weight of W v ​ , span a directed edge v in ​ v out ​ with a weight of W v ​ in G ′ . The problem is now reduced to the following: You are given a DAG with weighted edges, a source s, and a sink t. Some edges have weights of -1, which means “undecided”. Maximize the gcd of total edge weights of all st-paths by appropriately setting the undecided edge weights. Below, the total edge weight of a path is simply called the weight of the path. [2] Rephrasing the decision problem First, for a fixed x, consider the decision problem to determine whether one can make the weights of all st-paths divisible by x. Obviously, one does not need to consider the following vertices: the vertices unreachable from s; the vertices from which t is unreachable. By deleting those vertices beforehand, we can assume that for all v, both sv- and vt-paths exist. Under this assumption, one can make the weights of all st-paths divisible by x if and only if: one can assign to each vertex v an integer value P v ​ called potential to satisfy the following: P s ​ ≡P t ​ (modx); P w ​ ≡P v ​ +c(modx), if a directed edge vw has a fixed weight of c. We will prove the necessity first. Assume that one was able to make the weights of all st-paths divisible by x. Let P v ​ be the weight of some sv-path (remember the assumption that a sv-path exists). We have P s ​ =0, and from the fact that all st-paths have weights divisible by x, we also have P t ​ ≡0(modx), so P s ​ ≡P t ​ (modx) holds. Let us show that P w ​ ≡P v ​ +c(modx) when a directed edge vw has a weight of c. Combining this edge and an sv-path with a weight of P v ​ , there is an sw-path with a weight of P v ​ +c. There is also an sw-path with a weight of P w ​ . Additionally, take an wt-path whose existence is guaranteed by the assumption, and let d be its weight. Then, we obtain an st-path with a weight of P v ​ +c+d and an st-path with a weight of P w ​ +d. It follows from both P v ​ +c+d and P w ​ +d being divisible by x that P w ​ ≡P v ​ +c(modx). Next, we will prove the sufficiency. Assume that one was able to assign the potentials P v ​ to satisfy the conditions. For each directed edge vw with an undecided weight, we set its weight c in some way such that P v ​ +c≡P w ​ (modx). Then, it can be verified that the weight of every uv-path is congruent to P v ​ −P u ​ (modx) by induction on the length of a path. Particularly, the weight of every st-path is congruent to P t ​ −P s ​ (modx), which, combined with P s ​ ≡P t ​ (modx), shows that the weight of every st-path is divisible by x. [3] The solution to the original problem The decision problem to determine whether one can make the weights of all st-paths divisible by x, has been reduced to the following problem: You are given some pieces of information in the form P v ​ ≡P w ​ +c(modx). Determine whether one can set a sequence of potentials (P v ​ ) v ​ without contradicting them. This can be solved by managing the information network by maintaining the connected component that each vertex belongs to, the potentials of the representatives, and the differences in potential between vertices. For more information, try searching the web for weighted union-find. Alternatively, since there is no need to add information dynamically, one can also perform DFS on each connected component to set the potential for each vertex. The original problem asks the maximum x such that the answer for the decision problem is yes, but the solution for this case is almost the same. Solving the decision problem involves determining whether a certain value is divisible by x some finite number of times. This time, we should find the maximum x that passes all those checks, which can be computed as the greatest common divisor of some values. Therefore, the problem can be solved in O(N+M+log∑A i ​ ) time or similar. F - Arithmetic Sequence Nim Editorial by evima By dividing values such as a, m, and A i ​ by gcd(a,m), the problem can be reduced to the case gcd(a,m)=1. Below, we assume gcd(a,m)=1. [1] Remodeling with Grundy numbers Let us define a function G:{0,1,2,…}⟶{0,1,2,…} recursively by: G(n)=mex{G(n−x)∣x∈X,x≤n}. This is the Grundy number of the game where the sequence has only one term n. The problem can then be rephrased into the following: Find the number of pairs (i,x) of an index i and x∈X such that G(A 1 ​ )⊕⋯⊕G(A n ​ )=G(A i ​ )⊕G(A i ​ −x). Thus, the problem will be solved if one can: compute G(n) for a given n; count x∈X such that G(n−x)=g for a given n and g. [2] The case a=0 It follows from gcd(a,m)=1 that m=1, so we have X={1,2,3,4,…}. This is exactly the game called Nim, so it is easy to find that G(n)=n. [3] Representing states with a grid Below, we assume a>0. Consider a grid with infinite numbers of rows and columns labeled with integers, and let the square at Row x and Column y correspond to the number mx+ay. For instance, when m=10 and a=3, the squares corresponding to non-negative integers are arranged as shown in the following figure: Since gcd(a,m)=1, all non-negative integers appear in this grid. Instead of a number, let us use one of the corresponding squares. Then, we are to study the Grundy numbers of the squares in the game where the players make the following move in each turn: move one square left and zero or more squares up. [4 - 1] The case 0<a≤m/2 The Grundy numbers of the squares can be determined as follows: Step 1 The Grundy number of a square whose left neighbor is a negative integer is 0. Step 2 Look at a column on the (immediate) right of a column containing a square confirmed as 0 in Step 1. Let us call such a column special. The Grundy numbers of the squares in a special column are still difficult to find, but they are confirmed to be at least 1. Step 3 The Grundy numbers of the squares in the column on the right of a special column must be 0. In the column on the right of that column, the Grundy numbers of all squares must be 1. In the next column on the right, the Grundy numbers of all squares must be 0. In this manner, one can determine the Grundy numbers in the columns until reaching another special column. Step 4 At this point, the Grundy numbers of all squares except the special columns are already confirmed. Since a≤m/2, there are no two consecutive special columns. Therefore, in the column on the left of a special column, all Grundy numbers are confirmed, so we can also determine the Grundy numbers in the special column. [4 - 2] The case m/2<a<m Let us call a square immediately below a negative integer a top square. Since m/2<a, there can be at most two horizontally consecutive top squares. Additionally, since a<m, there do exist two horizontally consecutive top squares. Now, the Grundy numbers of the squares can be determined as follows: Step 1 The Grundy number of a square whose left neighbor is a negative integer is 0. Step 2 For each pair of horizontally consecutive top squares, let us call the column containing the right top square special. The Grundy numbers of the squares in a special column are still difficult to find, but they are confirmed to be at least 1. Step 3 The Grundy numbers of the squares in the column on the right of a special column must be 0. If we proceed to the right, the top square keeps moving up one square until we reach another special column. Thus, the sequence of the Grundy numbers in a column transitions as follows: (0,0,0,0,0,0,…)→(0,1,1,1,1,1,…)→(0,1,2,2,2,2…)→(0,1,2,3,3,3,…). Step 4 At this point, the Grundy numbers of all squares except the special columns are already confirmed. In the column on the left of a special column, the sequence of Grundy numbers looks like (0,1,2,3,3,3…), so one can see that it also looks like (1,2,3,4,4,4,…) in the special column. [5] Summary [2], [4-1], and [4-2] have revealed the patterns of the Grundy numbers in all possible cases. It is not difficult to use these to: compute G(n) for a given n; count x∈X such that G(n−x)=g for a given n and g. One can also compute the relative position of the top and “leftmost” squares and such from a certain square using the remainder of division by m and a. Each of these computations can be done in O(1) time, so the problem can be solved in O(N) time. A - Three Integers Editorial by evima The operation “subtract 1 from two of the integers” can be rephrased into an operation “add 1 to one of the integers and then subtract 1 from all of the integers.” Thus, the problem can be rephrased as follows. Find the smallest positive integer K for which the following holds. It is possible to “add 1 to one of the integers” at most K times so that all the integers have the value of K. Here, the conditions that K must satisfy are the following. K≥max{A,B,C}, and K≥(K−A)+(K−B)+(K−C). Let A≤B≤C for simplicity. Then, if the second condition is satisfied for K=C, the answer is C; otherwise, it is −1. B - Counting Grids Editorial by evima For any way to fill the grid, there is at most one square that violates both of the conditions, because such a square satisfies the following. All numbers written in the column containing that square are less than the number written in that square. All numbers written in the row containing that square are greater than the number written in that square. Let us count the ways to fill the grid so that there is a square satisfying these two conditions. There are N 2 positions for that square, and ( 2N−1 N 2 ​ ) sets of numbers to be written in the squares sharing a row or column with that square. For each pair of these, we have (N−1)!×(N−1)!×(N−1) 2 ! ways to fill the grid. Multiplying these counts yields the answer. C - Piles of Pebbles Editorial by evima Let B i ​ be the remainder when A i ​ is divided by X+Y. Below, we call Takahashi and Aoki the first and second players, respectively. First, if all B i ​ are less than X, the second player wins. This is because for each pile chosen by the first player, the value of B i ​ becomes at least Y, so the second player can choose the same piles to restore the previous values of B i ​ . Next, assume X≤Y. If there is some B i ​ greater than or equal to X, the first player wins. This is because he can choose the piles whose B i ​ are greater than or equal to X in his operation so that all B i ​ are less than Y. Finally, consider the case X>Y. Here, none of the piles whose B i ​ are less than X can be chosen, while all of the piles whose B i ​ are greater than or equal to X must be chosen. This uniquely specifies the set of piles to choose, and the outcome of the game can be determined from the arguments in the previous cases. D - Bridges Editorial by evima Consider an undirected graph with N vertices and M edges where the i-th edge connects Vertex A i ​ and Vertex B i ​ . If the i-th edge in this graph is a bridge, the i-th edge in the undirected graph corresponding to any binary sequence of length M will always be a bridge. Actually, it is possible to make all other edges (except trivial edges) non-bridges by appropriately choosing the binary sequence. Each connected component after removing the bridges can be independently treated, so we may assume that the graph is connected and has no bridges. Then, it is possible to turn the graph into a strongly connected direct graph by appropriately directing each edge. One way to do so is to take a DFS tree, and direct the edge from the child to the parent for each edge used in the tree and from the deeper vertex to the shallower vertex for each back-edge. From these directions, we construct a binary sequence as follows: if the i-th edge is directed from Vertex A i ​ to Vertex B i ​ , the i-th character is 0; if the i-th edge is directed from Vertex B i ​ to Vertex A i ​ , the i-th character is 1. Let us verify that this binary sequence satisfies our requirement. Assume that there are two or more vertices. (For the case of one vertex, there would be one bridge.) Then, from the fact that the original graph has no edges, the only edges that could be a bridge are those connecting Vertex j and Vertex (j+N). Here, there is a cycle containing Vertex j since the previous directed graph is strongly connected. By seeing the edges used in this cycle, we can see that Vertex j and Vertex (j+N) would be connected even after removing the edge between them. Therefore, the undirected graph corresponding to this binary sequence has no edges. E - Reversi Editorial by evima Look at a leaf in the graph. If the piece on that vertex shows white, that vertex must be chosen before the adjacent vertex. On the other hand, if that piece shows black, that vertex must be chosen after the adjacent vertex. Using this observation, we can solve the decision problem. Since the case with one vertex is trivial, we assume there are two or more vertices. Choose any leaf. If it must be chosen after the adjacent vertex, the problem can be solved by solving the decision problem for the tree obtained by removing that vertex. On the other hand, if it must be chosen before the adjacent vertex, the problem can be solved by flipping the piece on the adjacent vertex and then solving the decision problem for the tree obtained by removing that vertex. In short, the decision problem can be solved recursively on the number of edges. Actually, the answer is yes if and only if the number of pieces showing white is odd. Next, let us consider how to find the lexicographically smallest sequence of operations. Again, for each edge, we can recursively determine which of the endpoints should be chosen first. Additionally, it can also be seen that any sequence of operations following these orders is feasible. Thus, the problem can be rephrased into finding the lexicographically smallest topological sort of a DAG. This can be solved by successively removing the vertex with the smallest index whose in-degree is 0. F - Counting Subsets Editorial by evima Let us fix the smallest number a in S that is not a power of two and find the count for each a. Consider the sequence denoting the number of ways to represent each integer as the sum of some elements of S. In the end, its values at the indices 0,1,...,N must be 1 or 2. Now, let us add elements to S one by one in ascending order and consider what this sequence is at each step. When the elements up to a have been added, it looks like this: a occurrences of 1, followed by (2 k −a) occurrences of 2, followed by a occurrences of 1. ( 2 k is the smallest power of two that is at least a.) If we add another element, it will change as follows. Copy the current sequence. Then, “overlay” the leftmost a occurrences of 1 in the copy on the rightmost a occurrences of 1 in the original sequence to obtain the new sequence. To “overlay” parts of two sequences is to concatenate the two sequences while replacing these parts with b occurrences of 1, followed by (a−b) occurrences of 2, followed by b occurrences of 1. ( b is an arbitrary non-negative integer at most a.) Noting that integers greater than N may have three or more representations, what we should find is as follows. Repeat the above procedure until the length of the sequence is (N+1) or more. We should find the sum, over all sequences that can be obtained this way, of distances from the index N to the nearest index to the left that contains 2. We can consider a full binary tree corresponding to the process of constructing the sequence. Each vertex corresponds to a (contiguous) subsequence of the sequence, as follows. Each leaf of the full binary tree corresponds to a subsequence that is a copy of the “ (2 k −a) occurrences of 2” in the initial sequence. Each vertex at height k of the full binary tree corresponds to a subsequence that is a copy of the “overlayed” part in the k-th procedure. Now, let us fix the number of vertices that correspond to subsequences positioned within the range between 0 and N. Since a subsequence corresponding to a vertex at height 1 or above is at least a, so there are only at most 2N/a+1 such vertices. Here, the length of the subsequences corresponding to the vertices at each height can be specified to be any value between a and 2a. Thus, with simple dynamic programming, we can count the number of ways to specify the lengths so that the total length of the subsequences is at most (N+1) and would exceed (N+1) if the next subsequence to the right were included. In reality, we have to find the sum, over such sequences, of distances from the index N to the nearest index to the left that contains 2, but it can also be done similarly with dynamic programming. Since the heights are O(logN), so the time complexity of this solution for each fixed setting is O(NlogN). There are O(∑N/a)=O(NlogN) settings, so it runs in O(N 2 log 2 N) time in total. It is also possible to find the answer in O(N 2 logN) time by incrementing the number of vertices contained in the subsequences positioned within the range 0,...,N one by one and reusing the results from the dynamic programming at each step. However, the solution earlier mentioned is already fast enough since the constant factor is low. A - Reverse and Minimize Editorial by evima If f(K)  =K, the answer is 0. Otherwise, it is the number of values at most N among the following: K multiplied by 1,10,100,… the integer obtained by reversing K, multiplied by 1,10,100,… We can start with K or its reversal, repeat multiplying it by 10, and quit when it exceeds N to check all those candidates in O(logN) time, which is fast enough. Take care to remove duplication when the reversal of K coincides with K. B - Unbalanced Squares Editorial by evima The number of squares horizontally, vertically, or diagonally adjacent to a square is at most 8. However, if this number is less than 8, it must be odd, so we can ignore that square. The sketch of the solution is to divide the integers into smaller ones and larger ones, and ensure that every square is adjacent to many integers on the opposite side, which makes achieving a  =b relatively easy. Here are two specific ways to do so. (Where the order is not specified, fill the squares (i,j) in lexicographically ascending order of (i,j).) First, fill all odd-indexed rows, using the integers in ascending order. Next, fill all even-indexed rows, using the remaining integers in ascending order. First, fill all squares (i,j) such that i+j is odd, using the integers in ascending order. Next, fill all squares (i,j) such that i+j is even, using the remaining integers in ascending order. C - Tree Queries Editorial by evima Let D i ​ =d 1,i ​ +d 2,i ​ . We can find this value for i=3,…,N in 2(N−2)=2N−4 questions. In many cases, the minimum value among D i ​ equals d 1,2 ​ . The only exception is when d 1,2 ​ =1 (no vertices between Vertices 1,2), where the minimum among D i ​ is 3. At this point, we can know d 1,2 ​ unless the minimum D i ​ is 3. Let us try to determine whether d 1,2 ​ is 1 or 3 when the minimum D i ​ is 3. If we assume d 1,2 ​ =3, there would be exactly two indices i such that D i ​ =3, so we should have d 1,2 ​ =1 otherwise. When there are indeed exactly two indices i such that D i ​ =3, let us call them x and y. If d 1,2 ​ =1, each of x and y would be adjacent to Vertex 1 or Vertex 2; if d 1,2 ​ =3, x and y would be adjacent. Therefore, if d x,y ​ is 2 or 3, we should have d 1,2 ​ =1; if it is 1, we should have d 1,2 ​ =3. From the above, we can know d 1,2 ​ in at most 2N−3 questions. D - Deterministic Placing Editorial by evima Notations For a tree with some pieces on it, a sliding path is a simple path with two or more vertices where all vertices, except exactly one of the endpoints, are occupied with a piece. A sliding path decomposition is a decomposition of the tree into one or more sliding paths. Two sliding path decompositions are distinguished when they are different as path decompositions, or the positions of the pieces are different. Observing the valid placements Consider a placement of pieces that satisfy the condition. Given S 0 ​ and S 1 ​ , the following algorithm finds the moves of the pieces by the first good operation. Mark all vertices as unprocessed. Repeat the following until there are no unprocessed vertices. Choose an unprocessed vertex without a piece, v. If S 1 ​ contains v, mark v as processed. Otherwise, among the one or more connected components obtained by deleting v from the tree, there is exactly one connected component that currently has more pieces than the intersection of that component and S 1 ​ . From the vertex adjacent to v in such a connected component, move the piece to v. Then, mark v as processed. Considering that no vertex is absent in both S 0 ​ and S 1 ​ (otherwise, one would be able to move a piece to that vertex, so the condition would not be satisfied), this algorithm gives the correspondence from a valid placement to a sliding path decomposition. Additionally, considering that different placements correspond to different sliding path decompositions (if they correspond to some decompositions), the set of the valid placements corresponds one-to-one to some subset X ′ of the set X of the sliding path decompositions. When is a sliding path decomposition contained in X ′ ? One way to move the pieces in a sliding path decomposition is to slide the pieces back and forth within each sliding path. If there is more than one way to move the pieces, that sliding path decomposition is not in X ′ , which can be shown to happen if and only if there are some adjacent sliding paths x and y such that one can move a piece from x to y without moving a piece from y to other sliding paths. Proof If it were impossible to move a piece from a sliding path to another, there would be a unique way to move the pieces, so it must be possible to move a piece from some sliding path to another. Considering that the graph is a tree and each edge is traversed by at most one piece, the give-and-take relation between the sliding paths has no cycle, so there is a sliding path that is the endpoint of a chain. That endpoint is y, and the sliding path that gives a piece to y is x. From the above, it can be shown (by case-by-case analysis) that a sliding path decomposition is contained in X ′ when the following holds for every pair of adjacent sliding paths x and y. The occupied endpoint of one of x and y is connected by an edge to the unoccupied endpoint of the other. Non-endpoint vertices of x and y are connected by an edge. Finding ∣X ′ ∣ with tree DP Let us root the tree at an arbitrary vertex. Now, we can count the valid sliding path decompositions by DP, classifying the vertices into the following five categories: A vertex, not the occupied endpoint, in a sliding path whose unoccupied endpoint is a descendant of that vertex (or itself) A vertex, not the unoccupied endpoint, in a sliding path whose occupied endpoint is a descendant of that vertex (or itself) The occupied endpoint of a sliding path whose unoccupied endpoint is a descendant of that vertex The unoccupied endpoint of a sliding path whose occupied endpoint is a descendant of that vertex A vertex in a sliding path whose endpoints are both descendants of that vertex Here is one of the transitions in this DP. The current vertex falls into Category 1 when one of the following is satisfied, considering the condition for being in X ′ . All of the children fall into Category 3. One of the children falls into Category 1, and the others fall into Category 5. Thus, the count for the current vertex can be found using the counts for the children. Also, by symmetry, we can consider Patterns 1 and 2 the same, as well as Patterns 3 and 4. In this case, we have two ways to put pieces independently for each part of a sliding path decomposition separated by edges connecting non-endpoint vertices, so we should multiply the counts by 2 in a transition between non-endpoint vertices. E - Pairing Wizards Editorial by evima For each given pair (x,y), the strengths of Wizards x,y must be at least min(b x ​ ,b y ​ ). Below, we assume that this requirement is already met by applying the operation appropriately. Let X be the set of wizards planning to defeat monsters whose strengths are greater than that of the wizard, and Y be the set of the other wizards. The requirement for a pair (x,y) that is not yet good can be written as follows (by swapping x and y if necessary): at least one of Wizards x,y must have a strength of at least b x ​ , where x belongs to X, and y belongs to Y. From the above, the minimum number of operations needed to make all the given pairs good equals the size of a minimum S−T cut of the following directed graph. The vertice set consists of the following vertices: The vertices S,T A vertex corresponding to x, for each x∈X A vertex corresponding to a pair (y,i), for each y∈Y and each integer i(1≤i≤100) The edge set consists of the following edges: An edge of weight b x ​ −a x ​ from S to the vertex corresponding to x An edge of weight 1 from the vertex corresponding to (y,i) to T An edge of weight ∞ from the vertex corresponding to (y,i) to the vertex corresponding to (y,i−1), for each i≥2 An edge of weight ∞ from the vertex corresponding to x to the vertex corresponding to (y,b x ​ −a y ​ ), for each pair (x,y) that is yet to be good Indeed, for each pair (x,y), making the strength of x at least b x ​ corresponds to the edge from S to the vertex corresponding to x, and making the strength of y at least b x ​ corresponds to the edges from the vertices corresponding to (y,i) for each i=1,…,b x ​ −a y ​ to T. Let us analyze the complexity of this method. An S−T flow on this graph has a value of O(NA), and there are O(N 2 +NA) edges, where A is the upper limit for a i ​ and b i ​ , so the complexity is O(N 3 A+N 2 A 2 ). F - Paired Wizards Editorial by evima Assume that X casts Spell 2 C X ​ times, as the x 1 ​ -th, x 2 ​ -th, …, x C X ​ ​ -th spells from the earliest. Then, the x i ​ -th spell deals x i ​ −i damage to the monster. Therefore, the total damage dealt by X is S X ​ − 2 C X ​ (C X ​ +1) ​ , where S X ​ =∑x i ​ . If we similarly define C Y ​ and S Y ​ for Y, the problem asks us to maximize S X ​ +S Y ​ − 2 C X ​ (C X ​ +1) ​ − 2 C Y ​ (C Y ​ +1) ​ . Let us classify the tuples (a i ​ ,b i ​ ,c i ​ ,d i ​ ) into the five patterns below, based mainly on whether the spell for each wizard is fixed. Neither X’s nor Y’s spell is fixed, and they are different Neither X’s nor Y’s spell is fixed, and they are the same X’s spell is fixed, while Y’s spell is not fixed X’s spell is not fixed, while Y’s spell is fixed Both X’s and Y’s spells are fixed When the spell for a wizard is fixed, the contribution of that part to C X ​ ,C Y ​ ,S X ​ ,S Y ​ is constant (so Pattern 5 is excluded from the consideration below, as there is no choice to make). Let us try brute force for the choices in unfixed parts. In Pattern 1, exactly one of X and Y casts Spell 2. Here, the contribution to S X ​ +S Y ​ is the same regardless of which wizard casts it, and it only matters how many times each of X and Y casts Spell 2 in total, considering the contribution to C X ​ and C Y ​ . After deciding the number of casts of Spell 2 for X, the remaining casts of Spell 2 are for Y, so there are O(N) choices to try. In Pattern 2, let k be the number of times X and Y cast Spell 2 here. Then, it is optimal to do so in the last k occurrences of this pattern, because the timing only affects S X ​ and S Y ​ ー not C X ​ or C Y ​ ー and maximizing S X ​ and S Y ​ maximizes the total damage. Again, there are O(N) choices for the number k to try. For similar reasons, there are also O(N) choices to try in each of Patterns 3 and 4, so we already have an O(N 4 ) brute force solution. After fixing the choices in Patterns 1 and 2, the optimal choices in Patterns 3 and 4 can be separately determined, and they only depend on the values of C X ​ and C Y ​ . Therefore, by pre-computing the optimal uses of spells in Patters 3 and 4 for each C X ​ =0,1,2,… and each C Y ​ =0,1,2,…, we get an improved O(N 2 ) brute force solution, which is fast enough. A - Periodic Number Editorial by evima If N is a 2-digit number, the problem is easy. Below, we assume that N is a k-digit (3≤k) number. 10 k−1 −1=999...999 is a (k−1)-digit number, which is periodic. Thus, other than this, we only need to check k-digit numbers to find the greatest periodic number at most N. Consider a k-digit periodic number n that is the concatenation of a k ​ copies of an a-digit positive number m. Let N ′ be the topmost a digits of N interpreted as an integer. Then, we only need to consider m=N ′ −1 and N ′ , because we always have n≤N for a=N ′ −1 and N<n for a=N ′ +1. Now we only have to consider O(logN) periodic numbers, enabling us to solve the problem in O(log 2 N) time per test case. Beware the case N ′ is a power of 10, or there is no k-digit periodic number at most N. B - Increasing Prefix XOR Editorial by evima Consider the problem in binary. If positive integers a and b have the same number of digits, the only case when both a<c and b<b⊕c hold is when c has more digits than each of a and b, in which case c and b⊕c have the same number of digits. From this, it can be inductively shown that when A satisfies the conditions, A i+1 ​ has more digits than A i ​ . On the other hand, if A i+1 ​ has more digits than A i ​ for every i, the conditions are obviously satisfied. Therefore, when M<2 60 , the answer is 0 if 60<N. Otherwise, let us precompute the number of k-digit integers between 1 and M to solve the problem in O(Nlog 2 M) time by dynamic programming, where we set dp[n][k]: the number of sequences (A 1 ​ , A 2 ​ , …, A n ​ ) of positive integers with increasing numbers of digits whose A n ​ has k digits. (Alternatively, consider taking at most one k-digit integer for each k to choose N in total, to solve it in O(NlogM) time.) Therefore, the problem can be solved in O(log 3 M) (or O(log 2 M)) time. C - Bracket and Permutation Editorial by evima If P 2i−1 ​ >P 2i ​ , we can see that S P 2i−1 ​ ​ = ( and S P 2i ​ ​ = ) must hold (otherwise, we could swap P 2i−1 ​ and P 2i ​ ). Similarly, if Q 2i−1 ​ <Q 2i ​ , it must hold that S Q 2i−1 ​ ​ = ( and S Q 2i ​ ​ = ). It turns out that, after this observation, if we still have more than one candidate for S, there is no S that satisfies the condition. Proof For simplicity, we consider the case S is a correct parenthesis sequence or its reversal. The general case can be proved in the same way, using the fact that a general S can be represented as the concatenation of correct parenthesis sequences and their reversals. Assume that S is a correct parenthesis sequence. Let L 1 ​ <L 2 ​ <⋯<L N ​ be the indices i such that S i ​ = ( and R 1 ​ <R 2 ​ <⋯<R N ​ be the ones such that S i ​ = ). Since S is a correct parenthesis sequence, we have L i ​ <R i ​ . Therefore, the lexicographically largest p such that S p 1 ​ ​ S p 2 ​ ​ …S p 2N ​ ​ is a correct parenthesis sequence is p=(L N ​ , R N ​ , L N−1 ​ , R N−1 ​ , …, L 1 ​ , R 1 ​ ), in which case we can restore S from Q by the above observation only. If S is a reversed correct parenthesis sequence, we can restore it similarly from P. If we now have one candidate for S after the observation above, we can try greedily constructing what should be P and Q to see if they match. D - Non-divisible Set Editorial by evima When constructing a good set with integers between 1 and 2M, for each of the M odd numbers n=1, 3, …, 2M−1, we can choose at most one from the numbers 2 k n. Thus, choosing a good set with M elements is equivalent to choose k 1 ​ , k 3 ​ , …, k 2M−1 ​ for each n=1, 3, …, 2M−1 so that the following conditions are satisfied. 2 k n ​ n∈S. 2 k n ​ n is not a multiple of 2 k m ​ m, if n  =m. Moreover, considering that the second condition is always satisfied if n is not a multiple of m, it is equivalent to “ k n ​ <k m ​ if n is a multiple of m (n  =m).” Choosing such k n ​ ’s is a typical problem: we get the upper limit R n ​ for each k n ​ by choosing as large k n ​ as possible in the order n=1, 3, …, 2M−1, and the lower limit L n ​ for each k n ​ by choosing as small k n ​ as possible in the order n=2M−1, 2M−3, …, 1. Now, for each n=1, 3, …, 2M−1, when can we have k n ​ =K? It turns out to be always possible when L n ​ ≤K≤R n ​ and 2 K n∈S, because (k 1 ​ , k 3 ​ , …, k n−2 ​ , k n ​ , k n+2 ​ , …, k 2M−3 ​ , k 2M−1 ​ )=(R 1 ​ , R 3 ​ , …, R n−2 ​ , K, L n+2 ​ , …, L 2M−3 ​ , L 2M−1 ​ ) is a feasible option. Therefore, the problem is solved by finding L n ​ and R n ​ , which can be done in O(N+MlogM) or O(N+MloglogM) time. E - Sliding Edge on Torus Editorial by evima After a coordinate transformation (i, j)→(i−j, j), each query spans edges between (u i ​ , k) and (v i ​ , k+p i ​ ) for integers u i ​ , v i ​ , p i ​ . We can then apply another coordinate transformation (i, j)→(i, j+h i ​ ) for an integer sequence h=(h 1 ​ , h 2 ​ , …, h N ​ ) without affecting the contents of queries (in other words, we may shift each row horizontally). Let us take h so that the following is satisfied. p i ​ =0 if (u i ​ , j) and (v i ​ , j ′ ) are disconnected for every 0≤j, j ′ <N just before the i-th query (u i ​ , v i ​ , p i ​ ) adds edges. This condition can be written as h u i ​ ​ −h v i ​ ​ =p i ′ ​ for (u i ​ , v i ​ ) in those queries. The graph with N vertices and those edges (u i ​ , v i ​ ) will be a forest, so such h always exists. For a query (u i ​ , v i ​ , p i ​ ) that is not among the above ones, (u i ​ , k) and (v i ​ , k) will be already connected when adding edges, so we may assume that it adds edges between (u i ​ , k) and (u i ​ , k+p i ​ ) instead. As a result, after taking an appropriate h, we have two kinds of queries: those that add edges between (u i ​ , k) and (v i ​ , k), those that add edges between (u i ​ , k) and (u i ​ , k+p i ​ ). After processing just the queries of the first kind, each column will have the graph G row ​ : the part of G in the first column. If we then process queries of the second kind, the N columns for each connected component in G row ​ will merge into g connected components, where g is the greatest common divisor of N and the p i ​ ’s in relevant queries. Thus, after determining h, we can process the queries by maintaining the following: the graph G row ​ , the part of G in the first column, a sequence g, containing the number of connected components corresponding to each connected component in G row ​ , in O((N+Q)logN) time, using tools such as dsu. F - Well-defined Abbreviation Editorial by evima Let f(T) denote the set of strings that can result from the operation on T. Additionally, when the size of f(T) is 1, let g(T) denote the resulting string. The necessary and sufficient condition Let us first consider S i ​ that contains one of the S j ​ ’s (i  =j). If greedily removing S j ​ ’s (j  =i) from the beginning of S i ​ makes it empty, f(T) is not affected by the existence or absence of S i ​ . Therefore, we may remove such S i ​ without changing the answer. If S i ​ does not become empty, S i ​ itself is a bad string. If this process does not find a bad string, S j ​ is not a substring of S i ​ for any S i ​ and S j ​ (i  =j). Now, the necessary and sufficient condition for there to be no bad string is: there is no strings A, B, C (A  =C) and integers 1≤i, j≤n such that S i ​ =A+B and S j ​ =B+C. Proof Necessity Assume that A, B, C and i, j with the above properties exist. First, if A or C contained one of the S k ​ ’s, S i ​ and S j ​ would also contain that string as a substring. Thus, both A and C contain none of the S k ​ s, so we have f(A)={A}, f(C)={C}. Therefore, we have {A, C}⊂f(A+B+C), so T=A+B+C is a bad string since A  =C. Sufficiency We will show that the size of f(T) is 1 for any T by induction on ∣T∣. The starting case where T is an empty string is clear. Now, assume that the size of f(T ′ ) is 1 for strings T ′ shorter than T. Let T 1 ′ ​ and T 2 ′ ​ be the strings obtained by removing S i ​ and S j ​ somewhere from T, respectively. We need to show that g(T 1 ′ ​ )=g(T 2 ′ ​ ). If the positions of the removed strings overlap, it follows from the conditions above that T 1 ′ ​ =T 2 ′ ​ , so g(T 1 ′ ​ )=g(T 2 ′ ​ ). If the positions do not overlap, we can take a string T 3 ′ ​ obtained by removing both S i ​ and S j ​ from T, for which g(T 1 ′ ​ )=g(T 2 ′ ​ )=g(T 3 ′ ​ ). Therefore, the problem can be solved by: Step 1: removing S i ​ ’s that can be made empty by removing shorter S j ​ ’s, and Step 2: determining whether the necessary and sufficient condition above is satisfied. Step 1 Let us add the characters of S i ​ one by one to an empty string, and whenever the current string ends with one of the S j ​ ’s, remove that ending. This can be done in O(∣S i ​ ∣) time with the Aho-Corasick algorithm. However, if we use failure links to move between nodes, we may perform many moves taking Θ(∣S i ​ ∣) time (when, for example, S={ AAA…AAA, C, BD, AAA…ABDCCC…CA }). We should precompute the next node for every character at every node. This can be done in O(σ∑ i=1 N ​ ∣S i ​ ∣) time in a way similar to finding the failure links. Step 2 Let us record the j such that the length- n suffix of S i ​ and the prefix of S j ​ match, for each (i, n). Those j’s can be listed in O(∣S i ​ ∣) time by traversing down the trie to the end and then tracing failure links. We only need to record one j because if two or more prefixes of S j ​ ’s match the same suffix, they will not be the (S i ​ ,S j ​ ) we look for. When j is recorded for (i, n), we need to check whether ∣S i ​ ∣=∣S j ​ ∣ and i is recorded for (j, n−∣S i ​ ∣) to see if we have found the pair. Summarizing the above, the problem can be solved in O(σ∑ i=1 N ​ ∣S i ​ ∣) time. A - Right String Editorial by evima Take the smallest integer M that is a divisor of N and satisfies S i ​ =S i+M ​ =⋯=S N−M+i ​ for each 1≤i≤M. Since the proposition is true for M=N, such an M always exists. Then, we have f(S)=M. Below, we will try to minimize M. For each divisor M of N, let us determine whether we can make f(S)=M. This can be done in O(∣S∣) time, since for each 1≤i≤M, it is optimal to make S i ​ ,S i+M ​ ,…,S N−M+i ​ fit the majority. Since N has at most N divisors, the problem has been solved in O(N 2 ) time. Actually, N has at most N ​ divisors less than or equal to N, so the same method works when N≤2×10 5 . B - Shorten ARC Editorial by evima In a contiguous substring of S, we call a maximal string of the form A…ARC…C a block. Also, we call the blocks in S Block 1,2,…,M from left to right. When no more operation is possible in a block, it has one of the forms A…AC…C, R, A…AR, RC…C. From this, we can see that an operation never combines multiple blocks into one. The above observation allows us to rephrase the problem into the following, where X i ​ is min(number of A’s, number of C’s). You are given a sequence of positive integers X=(X 1 ​ ,X 2 ​ ,…,X M ​ ). At most how many times can the operation below be performed? In an odd-numbered operation, choose a positive element from X and decrease it by 1. In an even-numbered operation, choose a positive element from X and delete it. We will consider this problem. It is easy to show the following: in an odd-numbered operation, it is optimal to choose the smallest element at least 2 if it exists; in an even-numbered operation, it is optimal to delete the smallest element. This greedy strategy solves the problem in O(NlogN) time. We can also solve it in linear time. Let us consider an upper bound for the number of operations. Since each even-numbered operation removes a positive element from X, there can be at most 2M operations. Also, since each operation decreases the sum of X at least 1, there can be at most ∑ i ​ X i ​ operations. Therefore, min(2M,∑ i ​ X i ​ ) is an upper bound for the number of operations, which turns out to be always achievable. Thus, the problem is solved in O(N). C - ABS Permutation (LIS ver.) Editorial by evima For simplicity, we will consider the case N is odd. (When N is even, there are small differences, but the same main idea works.) Below, let M=⌊ 2 N ​ ⌋. An obvious upper bound for the answer is N−1, only achieved by A=(1,2,…,N−1). Considering the elements of this A from back to front, we can see that it has only two corresponding P’s: P=(M+1,M,M+2,M−1,…,1,N),(M+1,M+2,M,M+3,…,N,1). If X=M+1, we can print one of the above. If X  =M+1, we have an upper bound of N−2. Let us divide the elements other than X into two arrays L and R, each of length M, so that L 1 ​ <L 2 ​ <…<L M ​ <R 1 ​ <R 2 ​ <…<R M ​ . Now the upper bound is achieved by P=(X,L M ​ ,R 1 ​ ,L M−1 ​ ,R 2 ​ ,…,L 1 ​ ,R M ​ ). D - One to One Editorial by evima Consider a connected component G ′ in G. If this graph has N ′ vertices, it also has N edges, so G ′ has exactly one cycle. Therefore, we will count cycles instead of connected components. First, we count the cycles that exist when we span the edges for such i’s that A i ​  =−1. Now, each connected component without a cycle is a tree. We number them 1,2,…,K and let B i ​ be the size of the connected component numbered i. For 1≤x 1 ​ <x 2 ​ <⋯<x k ​ ≤K, we find the number of cycles that contain vertices in the connected components numbered x 1 ​ ,x 2 ​ ,…,x k ​ , which is (k−1)!×∏ i=1 k ​ B x i ​ ​ . Therefore, we can find for each k the sum of ∏ i=1 k ​ B x i ​ ​ with dynamic programming to solve the problem in O(N 2 ) time. We can also compute ∏ i=1 K ​ (1+B i ​ x) with divide-and-conquer to solve it in O(Nlog 2 N) time. E - Not Equal Rectangle Editorial by evima Below, the matrix is 0-indexed. Also, we use integers between 0 and 24 (and add 1 to everything in the end). In short Let P=23. Write (⌊ P i ​ ⌋⌊ P j ​ ⌋+i+j)modP at the i-th row and j-th column, and the given condition will be entirely satisfied. Sample Implementation (Python): Copy n, m = map(int, input().split()) p = 23 for i in range(n): print(*[((i // p) * (j // p) + i + j) % p + 1 for j in range(m)]) n, m = map(int, input().split()) p = 23 for i in range(n): print(*[((i // p) * (j // p) + i + j) % p + 1 for j in range(m)]) Analysis Consider a more general problem: for any prime number P, paint a P 2 ×P 2 grid with integers between 0 and P−1 to satisfy the condition. If we solve this, we can let P=23, construct a grid for P 2 =529×529, and then print the top-left part with N rows and M columns. We call a P×P grid a small block. We will make P kinds of small blocks B 0 ​ ,B 1 ​ ,…,B P−1 ​ and arrange P×P small blocks accordingly to construct a P 2 ×P 2 grid. For the small grid B k ​ , let the (i,j) entry be (i+j+k)modP. For example, for P=3, B will be: B 0 ​ = ⎝ ⎛ ​ 0 1 2 ​ 1 2 0 ​ 2 0 1 ​ ⎠ ⎞ ​ ,B 1 ​ = ⎝ ⎛ ​ 1 2 0 ​ 2 0 1 ​ 0 1 2 ​ ⎠ ⎞ ​ ,B 2 ​ = ⎝ ⎛ ​ 2 0 1 ​ 0 1 2 ​ 1 2 0 ​ ⎠ ⎞ ​ . Now let us place P×P of these small blocks. We put B ijmodP ​ at the position (i,j). For example, for P=3, we get: ⎝ ⎛ ​ B 0 ​ B 0 ​ B 0 ​ ​ B 0 ​ B 1 ​ B 2 ​ ​ B 0 ​ B 2 ​ B 1 ​ ​ ⎠ ⎞ ​ = ⎝ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎛ ​ 0 1 2 0 1 2 0 1 2 ​ 1 2 0 1 2 0 1 2 0 ​ 2 0 1 2 0 1 2 0 1 ​ 0 1 2 1 2 0 2 0 1 ​ 1 2 0 2 0 1 0 1 2 ​ 2 0 1 0 1 2 1 2 0 ​ 0 1 2 2 0 1 1 2 0 ​ 1 2 0 0 1 2 2 0 1 ​ 2 0 1 1 2 0 0 1 2 ​ ⎠ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎞ ​ . Let us prove that this construction satisfies the condition. Since the numbers in each row and each column of a small block are distinct, the condition is satisfied when (x 1 ​ ,x 2 ​ ,y 1 ​ ,y 2 ​ ) lies within a small block or straddles two small blocks. Now, all we have to check is that the condition is satisfied when (x 1 ​ ,x 2 ​ ,y 1 ​ ,y 2 ​ ) straddles four small blocks. Let a,b,c,d be the indices of the four small blocks straddled by (x 1 ​ ,x 2 ​ ,y 1 ​ ,y 2 ​ ), in clockwise order starting at the top left. If all four entries were equal, we would have a−d=b−c from the way B are constructed, which should not happen because we put B ijmodP ​ at the position (i,j). This completes the proof. F - ABS Permutation (Count ver.) Editorial by evima Let us solve the case M=1. Consider dividing (1,2,…,N) into some contiguous subsequences, reverse some of them with length 2 or more, and then permute them. For example, we divide (1,2,3,4,5,6) into (1,2,3),(4),(5,6), reverse (1,2,3) into (3,2,1), and permute them into (4,5,6,3,2,1). When dividing the sequence, let us call the gap between i and i+1 partition i. Consider choosing some of the partitions 1,2,…,N−1. We note that each time two consecutive partitions are chosen, the number of ways to perform reversion gets multiplied by 2 1 ​ . Now, we can find for every i the number of ways to get i subsequences and reverse them in O(NlogN) time with binary lifting, maintaining whether each of the partitions 1 and N are chosen when choosing K from consecutive N partitions. Now, consider the case with general M. Take a permutation Q such that Q P i ​ ​ =i. Then, we have ∣P i ​ −P i+1 ​ ∣=M⇔∣Q i ​ −Q i+M ​ ∣=1, so we can reduce it to the case M=1 by classifying the indices in Q modulo K. We merge these results in O(Nlog 2 N) time. Let A K ​ be the answer for a fixed K. What we have found is ∑ j=0 N−1 ​ ( i j ​ )A j ​ for 0≤i≤N−1, which we will denote by B i ​ . After appropriate replacements in B i ​ =∑ j=0 N−1 ​ ( i j ​ )A j ​ , we get B i ​ =∑ j=0 N−1 ​ (j−i)! A j ​ ​ , from which we can determine A j ​ from top to bottom with divide-and-conquer FFT. Now the problem has been solved in O(Nlog 2 N) time. A - Trailing Zeros Editorial by evima Let us try to decide the values in the order A 1 ​ ,A 2 ​ ,…,A N ​ . Then, it is optimal to let A i ​ the minimum x such that A i−1 ​ <x and ctz(x)=T i ​ , where we assume A 0 ​ =0 for convenience. Here, if we rephrase the condition “ ctz(x)=T i ​ ” using division, it becomes: “ x is an integer divisible by 2 T i ​ but not by 2 T i ​ +1 .” Let y 1 ​ and y 2 ​ be the smallest and second smallest integer greater than A i−1 ​ and divisible by 2 T i ​ . We can represent y i ​ as follows, using the floor function: y 1 ​ =(⌊ 2 T i ​ A i−1 ​ ​ ⌋+1)×2 T i ​ Also, we have y 2 ​ =y 1 ​ +2 T i ​ . Here, exactly one of y 1 ​ and y 2 ​ is not divisible by 2 T i ​ +1 , so we can choose it for A i ​ . Additionally, since A i ​ −A i−1 ​ ≤y 2 ​ −A i−1 ​ ≤2 T i ​ +1 , we can give an upper bound for A N ​ as follows, using the constraints: A N ​ = 1≤i≤N ∑ ​ (A i ​ −A i−1 ​ )≤ 1≤i≤N ∑ ​ 2 T i ​ +1 ≤2 41 ×10 5 <2.2×10 17 Thus, A N ​ is confirmed to be representable by a 64-bit integer, so we can solve the problem by naive computations using types such as long long in C++, in O(N) time. B - Make N Editorial by evima We explain the case in which AX≥Y and BX≥Z. (Otherwise, it is optimal to greedily use the operations in descending order of (increment)/(cost), so the problem can be solved in O(1) time.) Assume A Y ​ ≤ B Z ​ without loss of generality. (Otherwise, swap Y,Z and swap A,B.) The operation of increasing P by A will be used at most ⌊ A N ​ ⌋ times, because using it more than ⌊ A N ​ ⌋ times would make P>N, making the objective unachievable. The operation of increasing P by B can be assumed to be used at most A−1 times, because if it was used A or more times, we could replace A uses of the operation “increase P by B” with B uses of the operation “increase P by A” without increasing the total cost. Thus, we can solve the problem by trying all possible numbers of uses of the operation “increase P by A” if ⌊ A N ​ ⌋<A−1, and those of the operation “increase P by B” otherwise, in O(T N ​ ) time. C - One Three Nine Editorial by evima Let us consider having a pair (X,Y) as placing a piece at a square (X,Y) to rephrase the problem to one about placing pieces on a two-dimensional grid. Assume N≤M without loss of generality. Since the minimum and maximum values for 3X i ​ +Y i ​ are 4 and 3N+M, respectively, we see that 3N+M−3 is an upperbound for K. We claim that this upperbound is achievable except when N=M and N is even. For now, we exclude the case N=M and N is even. Here is an optimal placement: oooxxxxxxxxxxxx oooxxxxxxxxxxxx oooooxxxxxxxxxx xxoooxxxxxxxxxx xxoooooxxxxxxxx xxxxoooxxxxxxxx xxxxooooooooooo 3X+Y increases by 1 each time we move as follows: go from (i,j) to (i,j+1); go from (i,j) to (i+1,j−2). Using these two moves, it is possible to reach (N,M) from (1,1) passing all o’s and no other squares, which proves that all o’s have different values of 3X+Y and that there are 3N+M−3 o’s. For X+3Y, again, we can similarly prove that all o’s have different values of X+3Y, though we go out of the grid during the process. For the case N=M and N is even, an optimal placement can be constructed similarly, too: oooxxx oooxxx ooooox xxooox xxoooo xxxxoo However, as shown above, the square (N−1,N+1) does not exist, so we can have one less o while going (N−1,N)→(N−1,N+1)→(N,N−1). Below, we prove that the optimal solution is 3N+M−4. When N=2, we can place pieces on all squares to have the optimal solution 3N+M−4=NM. Consider the case N≥4. Let S be the set of squares in the grid reachable from (3,1) by the following two moves. Here, it is allowed to go out of the grid temporarily. Go from (i,j) to (i+1,j−3). Go from (i,j) to (i+3,j−1). The elements of S have 2 N ​ different values of 3X+Y, and 2 N ​ −1 different values of 3X+Y, so we have 3N+M−4 as another upperbound for K, improved by 1 from 3N+M−3. Thus, we have solved the problem in O(N+M) time. Special thanks to maspy for the unusual amount of help during the preparation of this problem. D - Priority Queue 2 Editorial by evima The problem is solved if, for each 1≤i≤M, we find the expected value of the number of values in A not greater than i after the operations. That is, the problem can be rephrased into the following. You are given an integer x between 0 and N. Find the expected value of x after repeating the following operation K times. ・Increase x by 1 with probability p. Then, if x≥X, decrease x by 1. Notice that ∣x−(X−1)∣ will decrease monotonically. Hence, if we fix the final value of x, the probability of getting it can be represented using binomial coefficients and powers. Thus, for a fixed i, the sought value can be found in O(NlogK) time. Therefore, we have solved the whole problem in O(MNlogK+K) time, including pre-computations of binomial coefficients and such. E - Wazir Editorial by evima We will use the fact that, from the condition in the statement, we can place at most ⌊ 2 W ​ ⌋ pieces in a row. If both H and W are even, an upperbound for L is 2 W ​ ×H= 2 HW ​ , which can be achieved by placing the pieces in a checkered pattern. There are two ways for the top row: #.#.#. … and .#.#.# …, which uniquely determine the placement in the remaining rows, so the answer is 2. If at least one of H and W is odd, we can reduce that case to one of the following by swapping H and W if necessary: H is even, and W is odd; both H and W are odd, and H≥W. Here, an upperbound for L is H× 2 W−1 ​ . We will verify that it is achievable. If there is a placement that achieves it, each row contains exactly one pair of adjacent .’s, which looks like #.#..#.#.#.. Additionally, the positions of ..’s in any two adjacent rows differ by one square, as shown in the figure below. Using these facts, we can immediately confirm that there is a placement that achieves the upperbound. Copy #.#..#.#.#. .#.#..#.#.# #.#..#.#.#. .#.#..#.#.# Now, let us count the placements that achieve the upperbound. Below, we consider the indices for rows mod H, and for columns mod W. By making one-to-one correspondence between a valid placement and an integer sequence A of length H where A i ​ is j such that (i,j)= . and (i,j+1)= ., we can solve the problem by counting sequences A that satisfy the following conditions: 1≤A i ​ ≤W; A i+1 ​ −A i ​ ≡1,−1(modW), for each 1≤i≤H. We can count them efficiently by dividing the case according to the magnitude relationship between H and W. If H≤10 5 , represent the answer as a sum of O(H) binomial coefficients and compute it. If W≤10 5 , compute the constant term of (x+x −1 ) H mod(x W −1) with convolution + binary lifting. Now the problem is solved in O(min(H,W)logHlogW) time. F - Many Xor Optimization Problems Editorial by evima Let us call a basis (S 1 ​ ,S 2 ​ ,…,S K ​ ) of a sequence consisting of integers between 0 and 2 M −1 normal when it satisfies the following: 0<S 1 ​ <S 2 ​ <⋯<S K ​ <2 M holds; the highest bit in S i ​ is 0 in S j ​ , for each (i,j) such that 1≤i<j≤K. The problem is solved if we find the sum, for all sequences of non-negative integers 0≤X 1 ​ <X 2 ​ <⋯<X K ​ <M, of the products of the values below. The number of sequences A such that a normal basis of A consists of K vectors and the top bit of the i-th smallest vector is 2 X i ​ . The expected value of the answer to Xor Optimization Problem for a sequence with such a basis as above. The number of sequences of non-negative integers 1≤Y 1 ​ <Y 2 ​ <⋯<Y K ​ <2 M such that the highest bit in Y i ​ is 0 in Y j ​ for each pair 1≤i<j≤K and the highest bit in Y i ​ is 2 X i ​ for each 1≤i≤K. Let us find the number of sequences A such that a normal basis of A consists of K vectors and the top bit of the i-th smallest vector is 2 X i ​ . We are done if we find the number of sequences with the basis 2 0 ,2 1 ,2 2 ,…,2 K−1 . Let us start with S={} and do the operations below N times in total. Choose one of the 2 ∣S∣ non-negative integers obtained as the XOR of some subset of the elements in S, and append it to the end of A. Choose an integer i such that 0≤i<2 K and cannot be obtained as the XOR of any subset of the elements in S, and append it to the ends of A and S; there are 2 K −2 ∣S∣ such indices i. Here, the second operation must be done exactly K times out of N. There are [x N−K ]∏ i=0 K ​ 1−2 i x 1 ​ ×∏ i=0 K−1 ​ (2 K −2 i ) sequences A that can be made this way. Now, let f K ​ (x)=∏ i=0 K ​ 1−2 i x 1 ​ . We have (1−x)f K ​ (x)=(1−2 K+1 x)f K ​ (2x). By observing the coefficients of x i+1 on both sides, we get [x i+1 ](1−2 i+1 )f K ​ (x)=[x i ](1−2 K+i+1 )f K ​ (x), from [x i+1 ]f K ​ (x)−[x i ]f K ​ (x)=[x i+1 ]2 i+1 f K ​ (x)−[x i ]2 K+i+1 f K ​ (x). Thus, [x i ]f K ​ (x)= j=1 ∏ K ​ 1−2 j 1−2 i+j ​ . Therefore, we can enumerate [x N−K ]f K ​ (x) for 1≤K≤M in O(NlogN) time. Below, let B K ​ be this count. Next, let us find the expected value of the answer to Xor Optimization Problem for a sequence with such a basis as above. By noticing that the X i ​ -th bit is always 1, we find that this value is 2 (2 X M ​ +1 −1)+(∑ i=1 K ​ 2 X i ​ ) ​ . Finally, let us find the number of sequences of non-negative integers 1≤Y 1 ​ <Y 2 ​ <⋯<Y K ​ <2 M such that the highest bit in Y i ​ is 0 in Y j ​ for each pair 1≤i<j≤K and the highest bit in Y i ​ is 2 X i ​ for each 1≤i≤K. We have the following requirements for Y i ​ : the highest bit of Y i ​ must be the X i ​ -th bit, and the X j ​ -th bits must be 0 for each 1≤j<i. Thus, there are i=1 ∏ K ​ 2 X i ​ −(i−1) such sequences. Therefore, the problem asks us to find the sum, for all sequences of non-negative integers 0≤X 1 ​ <X 2 ​ <⋯<X K ​ <M, of the values of the following: ・ B K ​ × 2 (2 X K ​ +1 −1)+(∑ i=1 K ​ 2 X i ​ ) ​ × i=1 ∏ K ​ 2 X i ​ −(i−1) . First, let us handle the ∑ i=1 K ​ 2 X i ​ part. After rearranging the product, we have B K ​ ×∑ i=1 K ​ 2 X i ​ ×2 2 K(K−1) ​ ×∏ i=1 K ​ 2 X i ​ . Let us try to find the sum of ∑ i=1 K ​ 2 X i ​ ×∏ i=1 K ​ 2 X i ​ for each K. Let C K ​ be the sum, for all size- K subsets of {2 0 ,2 1 ,…,2 M−1 }, of the products of the elements. Then, ∑ i=1 K ​ 2 X i ​ ×∏ i=1 K ​ 2 X i ​ for a fixed K is (2 M −1)C K ​ −(K+1)C K+1 ​ , which can be derived by seeing ∑ i=1 K ​ 2 X i ​ as “ 2 M −1−(surplus).” Next, let us handle the 2 X K ​ +1 −1 part. After rearranging the product, we have B K ​ ×(2 X K ​ +1 −1)×2 2 K(K−1) ​ ×∏ i=1 K ​ 2 X i ​ . The 1 part in 2 X K ​ +1 −1 can be easily represented using C K ​ , so let us consider the 2 X K ​ part below. We want to find 2 X K ​ ×∏ i=1 K ​ 2 X i ​ for a fixed K, which can be done with divide-and-conquer in O(Mlog 2 M) time. Therefore, we have solved the problem in O(NlogN+Mlog 2 M) time. A - Larger Score Editorial by evima Consider an arbitrary optimal solution. Let 1≤p 1 ​ <p 2 ​ <⋯<p w ​ ≤K be the indices of the terms that are among the first K terms in the initial state but not in the final state. Similarly, let K+1≤q 1 ​ <q 2 ​ <⋯<q w ​ ≤N be the indices of the terms that are among the first K terms in the final state not in the initial state. This optimal solution obviously performs at least q w ​ −p 1 ​ operations. Additionally, there always exist 1≤i,j≤w such that p i ​ <q j ​ (or the score would never increase). Now, consider a solution that only exchanges those p i ​ and q j ​ . It is optimally performed by moving the value at the position p i ​ to the position K and the value at the position p j ​ to the position K+1, and then swapping the values at the positions K and K+1, with q j ​ −p i ​ operations. This is not more than the minimum number of operations that must be performed by an optimal solution we considered above. Therefore, we only need to consider the case w=1 to find the optimal solution. That is, we want to find the pair (i,j) that minimizes (j−i) among the ones satisfying 1≤i≤K, K+1≤j≤N, A i ​ <A j ​ . Let us sort the indices i in ascending order of the pair (A i ​ ,−i) and examine them in order. If the current i satisfies K+1≤i, swapping A j ​ <A i ​ is a potential optimal solution, where j is the largest index i we have examined so far that satisfies i≤K. Among those candidates, the one with the minimum number of operations is the final answer. Sorting is the bottleneck of this method, resulting in a total complexity of O(NlogN). B - 01 Generation Editorial by evima Consider the sequence y obtained by flipping the 2-nd, 4-th, 6-th, ⋯ terms from the beginning of x. Let us also flip the 2-nd, 4-th, 6-th, ⋯ terms of A and aim to make y equal to this A. By rephrasing the operations on x to those on y, we get the following: Operation A: Add 0 to the beginning of y. Operation B: Add a value to the end of y. The value to add depends on the parity of the length of y before the addition: we add 0 if the length is even and 1 if it is odd. First of all, we need A 1 ​ =0 to hold. If all elements of A are 0, the answer is yes. Otherwise, let A z ​ be the position of the 1 nearest to the beginning of A. Let us take out A z ​ and the following elements from A and call this part of the sequence S. Consider making S by doing only Operation B. Then, we need S to be a subsequence of (0,1,0,1,...) (length N). On the other hand, if this holds, we can make y equal to A by doing Operation B for a position in (0,1,0,1,...) corresponding to S and Operation A for the other positions. These procedures can be implemented in O(N). C - Rotate and Play Game Editorial by evima If Snuke can take the largest N/2 in A, it is guaranteed to be the largest score possible. We claim that it is achievable. Let us correspond the largest N/2 values in A to −1 and the other values to +1 to make a sequence B of length N consisting of −1 and +1. (Ties can be broken arbitrarily.) If B satisfies the following condition, Snuke can take all values corresponding to −1. Any prefix sum of B is zero or greater. It can be proved as follows. First, Snuke will take the nearest −1 to the beginning. From the prefix sum condition, B always begins with +1, which will be taken by Mr. Min next. Here, we see that the prefix sum condition on B is still satisfied. (The only thing that happened in those two turns is a sequence +1,−1 getting removed, which does not affect the prefix sums anywhere else.) Therefore, the problem is solved if we can cyclically shift B to satisfy the condition above. Now, let us define C 0 ​ =0,C i ​ =C i−1 ​ +B i ​ ( 1≤i≤N). We can see that the condition is satisfied by cyclically shifting B by x to the left, where C x ​ is the minimum value in C. The complexity of this method is O(NlogN) in total, the bottleneck being the sorting to find the largest N/2 in A. (We can make it O(N) by using std::nth_element etc.) D - Differ by K bits Editorial by evima The problem for K=1 is a famous one known as Gray code. Below, we consider K≥2. First, the answer is always impossible for an even K, because all numbers will have the same parity of the popcount. The case K=N is also obviously impossible. The other cases are possible. We will show it by actually constructing the solution. It is possible to take a basis in N-bit XOR consisting of values whose popcounts are K. Let z 1 ​ ,z 2 ​ ,⋯,z N ​ be one such basis. Additionally, we find an N-bit Gray code (a permutation of the numbers where adjacent terms differ by exactly one bit) and name it a 0 ​ ,a 1 ​ ,⋯,a 2 N −1 ​ . Here, let us define b i ​ as follows. b i ​ =z j 1 ​ ​ ⊕z j 2 ​ ​ ⊕⋯, where j 1 ​ ,j 2 ​ ,⋯ are the bit positions of 1’s in a i ​ . Then, b will be the answer to the problem. Because the XOR of adjacent terms will be one of the elements of z, it satisfies the condition of adjacent terms differing by exactly K bits. Additionally, since z is a basis, b will be a permutation of the numbers. The time complexity of this method is O(N2 N ). E - Decreasing Subsequence Editorial by evima Let us decrease each value in A by 1. Consider a graph with N+1 vertices 0,1,⋯,N and an edge i→A i ​ for each i such that A i ​ ≥0. Then, a good sequence corresponds to a decomposition of the N+1 vertices to some number of paths. We can see a length- K decreasing subsequence of A as a set of K nested edges, or a combination of vertices L 1 ​ <L 2 ​ <⋯<L K ​ <R K ​ <⋯<R 1 ​ with edges R i ​ →L i ​ . We will count the ways to embed such K edges in a path-decomposition of (0,1,⋯,N). Let us consider the two parts of the graph separately: the K paths containing the K edges, and the remaining vertices. Then, we further divide the vertices in the K paths into two sets: the set A of vertices to the left of L K ​ (including L K ​ ) and the set B of vertices to the right of L K ​ . Each of A and B in itself should be decomposed into K paths. On the other hand, for a fixed path-decomposition of A and B, the K edges connecting them are uniquely determined. (The starting point of the i-th path from the right in A corresponds to the ending point of the i-th path from the left in B.) Eventually, after fixing the sizes of A and B, we can count the corresponding number of ways to have the K edges by multiplying the following values. The number of ways to choose the vertices for A and B from the N+1 vertices. The number of ways to decompose A into K paths. The number of ways to decompose B into K paths. The number of path-decompositions of the vertices not in A or B. For the numbers of path-decompositions, we can define dp[i][j]= (the number of ways to decompose the graph with i vertices into j paths) to compute all necessary values in O(N 2 ). The total complexity of this method is O(N 2 ). F - KD Tree Editorial by evima Let f(A) be the number of sequences obtained by arranging a set A of points. Here, the X- or Y-coordinates of the points may not be a permutation of the smallest positive integers. In the actual computation of f, however, we compress the values and make it a permutation of those numbers. Basically, we try all possibilities for the position and direction of the division of A to recursively call f. However, this can count the same sequence multiple times. This is because there is a degree of freedom in dividing A even after fixing the sequence to get. To handle it, let us adopt the following rule so that there is a unique way to divide A. Let X x ​ denote the division according to whether the X-coordinate is less than x or not. Similarly, let Y y ​ denote the division according to whether the Y-coordinate is less than y or not. Among the divisions leading to the desired sequence, we use the leftmost one in X 2 ​ ,Y 2 ​ ,X 3 ​ ,Y 3 ​ ,⋯,X K ​ ,Y K ​ . For each division in the order of preference, let us count the number of desired sequences that cause the division to be chosen. Assume that we are considering X x ​ . Note that whether X x ​ is chosen in the above procedure depends on the first x−1 elements in the desired sequence. Thus, we will count the number of such ways to arrange the first x−1 elements. Let us first count the number of sequences obtained by arranging the points whose X-coordinates are less than x. From this, let us subtract the number of sequences that cause us to choose X 2 ​ , Y 2 ​ , X 3 ​ , Y 3 ​ , ⋯, X x−1 ​ , or Y x−1 ​ in the above procedure. For instance, the number of sequences that causes us to choose X z ​ (z<x) looks as follows: (the first z−1 elements that cause X z ​ to be chosen in the procedure )+(the sequence obtained by arranging the set of points whose X-coordinates are between z and x−1). We can count such sequences because we should have already counted the number of ways to arrange (the first z−1 elements that cause X z ​ to be chosen in the procedure ). Divisions in the Y-direction can be handled similarly. Let us estimate the complexity. The set of points passed as an argument to f can only result from extracting a rectangular region from the set of N points given in input. Therefore, there are only O(N 4 ) states after memoization. We need O(N 2 ) time for each state, for a total complexity of O(N 6 ). A - Coprime Pair Editorial by evima Since gcd(L,L+1)=1, there is always a solution. We can just try all pairs (x,y) such that L≤x<y≤R in decreasing order of (y−x) and print (y−x) when we have gcd(x,y)=1. The correctness of this method is obvious, so let us estimate the complexity. We are going to try O(K 2 ) pairs, where K is the difference between R−L and the answer. Taking account of the time to compute gcd, the total complexity is O(K 2 logR), so we are done if we can show that K is small. One way to prove it is to use prime gap. Under the Constraints of this problem, 1500 consecutive integers always contain at least one prime. Thus, among (x,y)=(L,R),(L,R−1),⋯,(L,R−1500), at least one satisfies gcd(x,y)=1. This shows K≤1500. Sample Submission (C++) In fact, K will be much smaller than this limit. Among R−5,⋯,R, there is always a number coprime with 30, which, under the Constraints, is always coprime with some of L,⋯,L+16. This shows K≤21. (Proof by maspy) It is possible to generate a case with K=7 using CRT. (The idea of shuffling primes was proposed by Nyaan) B - Count 1's Editorial by evima It is easy to find the minimum/maximum possible number of 1’s (by finding the contiguous subsequence where the number of 1’s minus the number of 0’s is minimum/maximum). It turns out that everything between the minimum and maximum is achievable. For example, let X be the original number of 1’s, Y be the maximum number of 1’s achievable, which is achieved by flipping [L,R]. Now, consider the number of 1’s after flipping (empty) ,[L,L],[L,L+1],⋯,[L,R]. It changes from X and Y, and adjacent numbers differ by 1, so all numbers between X and Y must be present. The same argument applies to the minimum. The complexity of the solution is O(N). C - Distinct Numbers Editorial by evima First, assume that A N−1 ​ +2≤A N ​ . It turns out that the first player always wins in this case, from the following argument. If the first player can make A N ​ less than A N−1 ​ and foist a losing board on the second player, the first player wins. Assume that all boards that can be obtained by making A N ​ less than A N−1 ​ are winning. Then, if we change A N ​ to A N−1 ​ +1, all boards that can be transitioned from that board are winning. Thus, the board obtained by changing A N ​ to A N−1 ​ +1 is losing. Therefore, the initial board is winning. Next, consider when a board with A N ​ =A N−1 ​ +1 is given. It can be seen from the above argument that a player should never give a board where the two largest elements have the difference of 2 or greater. Thus, throughout the game, we can assume that the two largest elements of A have the difference of 1. Then, we can see that each operation decreases max(A) by 1, regardless of how it is done. A board with max(A)=N−1 is unplayable, so the winner can be determined from the difference between the parities of A N ​ and N−1 in input. The complexity of the solution is O(N). D - Prefix XORs Editorial by evima For a fixed k, let us consider the contribution of A i ​ to the answer. Repeated applications of one-dimensional prefix sum correspond to vertical and horizontal moves in a two-dimensional grid. It follows that if ( k−1 (N−i)+(k−1) ​ ) is odd, the answer gets XORed by A i ​ , and if it is even, the answer is unaffected. ( k−1 (N−i)+(k−1) ​ ) is odd iff the positions of all 1’s in the binary representations of (N−i) and k−1 are different.（Lucas’s theorem） Now, let S be the smallest power of 2 such that max(N,M)≤S. Then, the condition of ( k−1 (N−i)+(k−1) ​ ) being odd can be rephrased into the set of bit positions of 1’s in S−1−(N−i) containing the set of bit positions of 1’s in k−1. At this point, we can solve the problem in a way similar to the fast zeta transform. The complexity is O(max(N,M)logmax(N,M)). E - Bakery Editorial by evima Let us formulate the problem as a minimum-cost flow problem. Let us make a graph with N+1 vertices numbered 0 to N and the following edges. Vertex j→(j−1): capacity A j ​ , cost −D ( 1≤j≤N) Vertex j→(j−1): capacity M−A j ​ , cost 0 ( 1≤j≤N) Vertex (L i ​ −1)→R i ​ : capacity 1, cost C i ​ ( 1≤i≤M) The cost of the minimum-cost circulation is the answer to the original problem multiplied by −1, which can be seen from decomposing into cycles passing (L i ​ −1)→R i ​ . You can feed this graph to a strong library and solve the problem, but a minor modification can make it easier. By preliminarily sending the maximum amount of flow up to the capacity along each edge j→(j−1) (of both kinds), the minimum-cost circulation above can be reduced to the minimum-cost flow of capacity M from 0 to N in the following graph. Vertex (j−1)→j: capacity A j ​ , cost D ( 1≤j≤N) Vertex (j−1)→j: capacity M−A j ​ , cost 0 ( 1≤j≤N) Vertex (L i ​ −1)→R i ​ : capacity 1, cost C i ​ ( 1≤i≤M) We can solve this problem with the successive shortest path (primal-dual) algorithm. The complexity is O(N(N+M)log(N+M)). F - Overlaps Editorial by evima Let us correspond the 2N real numbers generated throughout the process to a permutation of (1,2,⋯,2N) while maintaining the magnitude relation. Then, all permutations occur with equal probability. Now we have a problem with a discrete setting. For each i=1,2,⋯,2N, let us decide one by one whether i is used as the right end or the left end of an interval. If we decide to use i as the right end of an interval, there is a degree of freedom for the corresponding left end. There will be exactly N right ends. Let x 1 ​ ,x 2 ​ ,⋯,x N ​ be the number of candidates for the corresponding left ends. Deciding whether each i is used as a right end or a left end will determine x. Here, the requirement of no overlap of K+1 or more stickers means every element of x must be at most K. Additionally, from the way the number of candidates for the left end changes, x i+1 ​ ≥x i ​ −1 must hold. Furthermore, x N ​ =1 must hold. On the other hand, for an x that satisfies all of these necessary conditions, there is a unique way to decide whether each i is a right end or a left end that corresponds to x. Thus, we are to solve the following problem. Find the sum of ∏ 1≤i≤N ​ x i ​ over all integer sequences x 1 ​ ,x 2 ​ ,⋯,x N ​ that satisfy the conditions below. 1≤x i ​ ≤K x i+1 ​ ≥x i ​ −1 x N ​ =1 Notice the second condition and use the inclusion-exclusion principle to do the count. Assume that we have fixed i’s that do not satisfy this condition. By paying attention to repetitions of such i’s, we can decompose the sequence into several blocks. The number of ways to decide the values in each block is found as the following. The sum of ∏ 1≤i≤m ​ y i ​ over all sequences of length m ( 1≤m≤N), K≥y 1 ​ >y 2 ​ >⋯>y m ​ ≥1, that satisfy y j ​ −2≥y j+1 ​ ( 1≤j≤m−1). We can find it with divide-and-conquer & FFT. Specifically, we should write a function that finds the answer when the range of y is between l and r and call it recursively. Here, the function needs to return 2×2 values, classified by whether l and r are used. Now that we know about deciding values within each block, we just need to do DP using it. This DP can be made fast by divide-and-conquer & FFT or finding inv of polynomials. Take care of the special restriction on the final block that it must use 1. The complexity will be O(Nlog 2 N+Klog 2 K) or O(NlogN+Klog 2 K). Sample Submission (C++) P.S. It is possible to solve this problem in O(NlogN) time. For a fixed K, the answers for N=0,1,2,⋯,⌈K/2⌉ are 1,1,3,15,105⋯. If we consider the denominator of generating function of this sequence, it coincides with this OEIS sequence. We can prove it by induction. So we can reconstruct the sequence of answers for larger Ns. （tourist’s submission inspired me. Thanks!） Sample Submission(c++) A - A ↔ BB Editorial by evima Cs do not change, so let us focus on a maximal segment consisting of As and Bs. If we assign a weight of 2 to A and a weight of 1 to B, the operations do not change the total weight. Now, let W be the total weight of a maximal segment consisting of As and Bs. Then, the optimal move is as follows. If W is even: change it to W/2 repetitions of A. If W is odd: change it to (W+1)/2 repetitions of A followed by one B. It can be easily seen that this is the lexicographically smallest possible under the fixed total weight. Additionally, this is actually achievable (by temporarily changing all As to Bs and then changing them to As from left to right). This solution works in O(N) time. B - Triple Shift Editorial by evima If A and B do not coincide as multisets, the objective is obviously unachievable. Below, we assume these multisets are the same. First, let us solve the case in which the values of A are distinct. Consider the parity of the inversion number of the sequence A. This is unaffected by the operation. On the other hand, if the parity of the inversion number of A and that of B are the same, it turns out that A can be changed to B. We can show this as follows. First, if N≥3, we can bring any value to the front by some sequence of operations. By repeating this for the 1-st, 2-nd, ⋯, (N−2)-th terms from the left in B, we can match the first N−2 terms of A and B. What remains is the order of the remaining 2 terms, but this is determined by the parity of the inversion number, so A and B are guaranteed to coinside. Finally, let us consider the case in which there are duplicates among the values of A. In this case, it turns out that A can always be changed to B. Specifically, we first make all values distinct by labeling duplicated values (for example, label the occurrences of v as v 1 ​ ,v 2 ​ ,⋯). If A and B now have the same parity of the inversion number, we are done. If they do not, we swap the labels of v 1 ​ and v 2 ​ in A. This changes the parity of the inversion number, allowing us to apply the procedure in the “distinct” case. We can now solve the problem by directly implementing this criterion. It can be solved in O(NlogN) time, but the constraints allow O(N 2 ) solutions. C - Circular Addition Editorial by evima In one operation, the maximum value among the elements of x increases by at most 1. Additionally, the sum of absolute differences of adjacent elements of x ( =∑ 1≤i≤N−1 ​ ∣x i ​ −x i+1 ​ ∣+∣x N ​ −x 1 ​ ∣) increases by at most 2. Thus, if we let M=maxA i ​ and D=(∑ 1≤i≤N−1 ​ ∣A i ​ −A i+1 ​ ∣+∣A N ​ −A 1 ​ ∣)/2, we need at least max(M,D) operations. It turns out this lower bound is achievable, which we will show below. Let us look at the sequence of operations backward and show that it is possible to do the operation on A once to decrease the value max(M,D) by 1. First, consider the case in which M>D. Here, it can be verified that there is no i such that A i ​ =0 (by making a circuit of 0,⋯,M,⋯,0, we can see that M≤D, which is a contradiction). Thus, the objective can be achieved by decreasing the whole sequence A by 1. Next, the case in which M<D can be handled by choosing a maximal segment consisting of M in A and decreasing that segment by 1. What remains is the case in which M=D. As we did in the M<D case, consider a maximal segment consisting of M in A. If such a segment uniquely exists, decreasing that segment by 1 will decrease both M and D by 1. Let us consider the case with multiple such segments. It can be verified here that there is no i such that A i ​ =0 (by making a circuit of 0,⋯,M,⋯,( less than M ),⋯,M,⋯,0, we can see that M<D). Thus, it can be seen that an operation choosing a minimal segment containing all Ms will decrease both M and D by 1. This completes the proof. A straightforward implementation will run in O(N) time. D - Without Carry Editorial by evima Let L=6. For integers x,y between 0 and 10 L −1, let us say x dominates y when the following condition is satisfied. For each i ( 0≤i≤5), (the digit in the 10 i ’s place of x) ≥ (the digit in the 10 i ’s place of y) Calculation of x+y involves no carrying when (10 L −1−x) dominates y. Thus, the problem can be solved if, for each 0≤s<10 L , the number of A i ​ dominated by s is known. Here, if the problem is in base 2 instead of base 10, we can see that this is the fast zeta transform itself. Additionally, the same algorithm is feasible in base 10. Specifically, we should do DP with a transition from x to x+10 i if the digit in the 10 i ’s place of x is less than 9, for each i ( 0≤i≤5). Our solution runs in O(N+L×10 L ) time. E - Non-coprime DAG Editorial by evima Let us always use Vertex 1 and ignore it below. For integers x,y ( x<y), let us consider the condition for Vertex y to be reachable from x. Below, let f(n) be the smallest prime factor of n. After a case-by-case analysis based on the parities of x,y, the condition can be summarized as follows. If x≡0 and y≡0: always reachable. If x≡1 and y≡0: equivalent to x+f(x)≤y. If x≡0 and y≡1: equivalent to x≤y−f(y). If x≡1 and y≡1: equivalent to x+f(x)≤y−f(y). The case in which x≡0 and y≡0 is obvious. We will explain the remaining cases. First, the smallest integer reachable from x is x+f(x). Here, x+f(x) is always even, from which the above condition for the case in which x≡1 and y≡0 is derived. Similarly, the largest integer from which y is reachable is y−f(y), which is always even, so the case in which x≡0 and y≡1 is also resolved. Let us consider the last case. Since it is obvious that the condition above is necessary, we will prove the sufficiency. Assume that y is reachable from x while the condition is not satisfied. If y was reachable from x via two or more transitions, the condition would hold, so we only have to consider the direct transition x→y. Let p be a common prime factor of x,y. If we write x=ap,y=bp, a and b are both odd. Thus, we have x=ap<(a+1)p<bp=y, which means y is reachable from x via two transitions. Thus, x+f(x)≤y−f(y) must eventually hold, which completes the proof. For an integer n, let us define l(n),r(n) as follows. l(n)=n,r(n)=n+1 ( x≡0mod2) l(n)=x−f(n)+1,r(n)=x+f(n) ( x≡1mod2) Then, for integers x,y ( x  =y), x and y are unreachable from each other if and only if the intervals [l(x),r(x)) and [l(y),r(y)) intersect. Let us return to the original problem. If the chosen set of vertices satisfies the condition in the problem statement, there must be a point contained in all intervals corresponding to the vertices. Thus, the problem can eventually be solved by adding A i ​ to the interval [l(i),r(i)) for each 2≤i≤N and finding the max among all values. Our solution runs in O(N) time. F - Flip Cells Editorial by evima Let us call a state of the grid good when each row contains exactly A i ​ 1s. Here, we assume that the process continues even after a good state. Let us define f n ​ =( the probability of having a good state after n operations when starting from the given state in input ). Additionally, let F(x)=∑ 0≤n ​ f n ​ x n be the generating function of f n ​ . Similarly, let us define g n ​ =( the probability of having a good state after n operations when starting from a good state ). (Note that g can be defined without depending on the initial good state.) Additionally, let G(x)=∑ 0≤n ​ g n ​ x n be the generating function of g n ​ . Finally, let us define e n ​ =( the probability of having the first good state after n operations when starting from the given state in input ). (Note that g can be defined without depending on the initial good state.) Additionally, let E(x)=∑ 0≤n ​ e n ​ x n be the generating function of e n ​ . Here, the relation E(x)G(x)=F(x) holds. Additionally, our final objective in this problem, ∑ 0≤n ​ n×e n ​ , can be obtained by substituting x=1 in E ′ (x). (※) Eventually, it is enough to find F and G. Below, we describe how to find F. ( G can be found similarly.) We will first find the exponential generating function F exp ​ (x)=∑ 0≤n ​ f n ​ /n! x n . Let us fix a good state and consider the probability of coinciding with it. Then, there will be a requirement for each square to be flipped an even/odd number of times. Using the generating function w even ​ (x)=(exp(x/HW)+exp(−x/HW))/2 corresponding to a square flipped an even number times and the generating function w odd ​ (x)=(exp(x/HW)−exp(−x/HW))/2 corresponding to a square flipped an odd number times, the sought generating function is their multiplication. We have solved the case with a fixed good state. To deal with all possible good states, DP can be used. (The key in DP should be the degree of w even ​ , and the value should be the number of good states corresponding to that generating function.) Here, we find the exponential generating function as a multiplication of w even ​ ,w odd ​ , but it can also be written as a linear combination of exp(ax), where a can take the values −HW/HW,−(HW−2)/HW,⋯,(HW−2)/HW,HW/HW. Now we have found F exp ​ (x). Additionally, F(x) can also be found by making the terms corresponding to exp(ax) 1/(1−ax). We will find G similarly. There is a term 1/(1−x) in F(x),G(x), which is a problem when substituting x=1, so we choose to compute E(x)=((1−x)F(x))/((1−x)G(x)). What remains is to find (1−x)F(x), (1−x)G(x), and substituting x=1 in the derivatives of these. Since (1−x)/(1−ax) and the result of substituting x=1 in the derivative can be computed by a simple formula, all sought values can be found as their linear combinations. By the way, we can see that the results of substituting x=1 in (1−x)F(x) and (1−x)G(x) are the same, which helps simplify the implementation a bit. Our solution runs in, for example, O(H 2 W 2 ) time. Sample submission (c++) (※) Here is a supplementary explanation for the validity of this substitution. First, the convergence of ∑ 1≤n ​ n×e n ​ can be seen as a property of Absorbing Markov Chain. Thus, the radius of convergence of the power series ∑ 1≤n ​ n×e n ​ x n−1 is at least 1. Therefore, in the range ∣x∣<1, this series coincides with the regular analytic function E ′ (x), and it follows from Abel’s theorem that the substitution x=1 is also allowed (in the rational expression, not the series). A - Floor, Ceil - Decomposition Editorial by evima We use the following notations in this editorial. For a positive integer X, let f(x) be the maximum possible final product when starting with one X written on the blackboard. - Let X − ​ =⌊X/2⌋ and X + ​ =⌈X/2⌉. [1] Recurrence relation for f(X) We have the following: f(1)=1 f(X)=max{X,f(X − ​ )f(X + ​ )} (for X≥2) Actually, the sought value is the greater of the following two. When doing zero operations: the final product is X. When doing one or more operations: the first operation changes the state of the blackboard to (X − ​ ,X + ​ ). Then, it is optimal to individually handle X − ​ and X + ​ for the maximum product, after which the final product is f(X − ​ )f(X + ​ ). Additionally, by considering which is larger in f(X)=max{X,f(X − ​ )f(X + ​ )}, we can see that the following holds: f(X)=X (for X≤4) f(X)=f(X − ​ )f(X + ​ ) (for 5≤X) For X≤4, this can be seen by actually calculating the values of f(X) using the reccurrence relation f(X)=max{X,f(X − ​ )f(X + ​ )}. For 5≤X, it follows from f(X − ​ )f(X + ​ )≥X − ​ X + ​ ≥ 2 X−1 ​ ⋅ 2 X ​ = 4 X−1 ​ ⋅X≥X that f(X − ​ )f(X + ​ )≥X. [2] Algorithm and complexity analysis We use the recurrence relation in [1] to compute the values f(X) recursively. This can be done efficiently by memoized recursion, reusing the values of f(X) computed once. Sample Code (Python)：https://atcoder.jp/contests/arc135/submissions/29019824 Sample Code (C++)：https://atcoder.jp/contests/arc135/submissions/29019934 During the computation of f(X), we have to compute f(x) for several smaller values of x. Here, only the values that can be represented as ⌊X/2 k ⌋ or ⌈X/2 k ⌉ for some k appear as x. (We can prove in the order k=0,1,2,… that this is true for the k-th recursion.) Thus, if we choose K so that 2 K−1 ≤X<2 K , there are at most 2K values of f(x) to compute, allowing us to solve the problem in Θ(logX) time (or Θ(logXloglogX) time, depending on the method of memoization). B - Sum of Three Terms Editorial by evima [1] Structure of the solutions of the simultaneous linear equations First, let us consider what kind of sequences A satisfy S i ​ =A i ​ +A i+1 ​ +A i+2 ​ , including ones with A i ​ <0. This equation can be rephrased into A i+2 ​ =S i ​ −A i ​ −A i+1 ​ . Thus, deciding A 1 ​ and A 2 ​ produces exactly one sequence satisfying the condition by the recurrence relation A i+2 ​ =S i ​ −A i ​ −A i+1 ​ . By letting A 1 ​ =a, A 2 ​ =b and calculating the values of A i ​ , we can see that the solutions of the equations can be represented as follows, using some sequence of constants (x 1 ​ ,…,x N+2 ​ ) and parameters a,b. ⎩ ⎪ ⎪ ⎨ ⎪ ⎪ ⎧ ​ A i ​ =x i ​ +a A i ​ =x i ​ +b A i ​ =x i ​ −a−b ​ (i=1,4,7,…) (i=2,5,8,…) (i=3,6,9,…) ​ [2] The solution to the problem The problem asks us to determine the existence of a solution in the form above and to construct one if it exists. By rephrasing this to conditions regarding the parameters a,b, we have the following problem. You are given constants c 1 ​ ,c 2 ​ ,c 3 ​ . Determine the existence of a pair (a,b) that satisfies all of the inequalities, and construct one if it exists. c 1 ​ ≤a c 2 ​ ≤b a+b≤c 3 ​ This problem can be solved as follows: If c 1 ​ +c 2 ​ >c 3 ​ , no solution exists. If c 1 ​ +c 2 ​ ≤c 3 ​ , (a,b)=(c 1 ​ ,c 2 ​ ) is one of the valid solutions. Summing up the above, the original problem can be solved in Θ(N) time. Sample Code (Python)：https://atcoder.jp/contests/arc135/submissions/29021066 C - XOR to All Editorial by evima In this editorial, let A and B denote the sequence before and after the operations, respectively. [1] Characterization of the sequence after the operations For B, the sequence after the operations, the following holds: A i ​ ⊕A j ​ =B i ​ ⊕B j ​ for every i,j. If at least one operation is done, B i ​ =0 for some i. The former property can be seen from the fact that a⊕b=(a⊕x)⊕(b⊕x) for any non-negative integers a,b,x. The former property can be seen from the fact that, if at least one operation is done, the term that was equal to the last chosen x becomes 0. From these properties, the sequence after the operations, B, must be one of the following. The same sequence as the sequence A before the operation (when doing zero operations). A sequence determined by B i ​ =A i ​ ⊕A k ​ ( 1≤i≤N) for some k. On the other hand, these sequences can be obtained as the sequence B after the operations (by doing zero or one operation). [2] Computing the answer Now we have determined all possible variants of the sequence B after the operations. If we can compute ∑ i=1 N ​ B i ​ for all of them, we can find the answer. Thus, for each x∈{0,A 1 ​ ,…,A N ​ }, we want to compute ∑ i=1 N ​ (A i ​ ⊕x). Let us choose K so that max i ​ A i ​ <2 K and do the computations as follows. For each k(0≤k<K), compute the sum of the digits of (A i ​ ⊕x) in 2 k ’s place. Sum up the results. This can be done as follows, in the following complexity. For each k, precompute the numbers of 0s and 1s among the digits of A i ​ in 2 k ’s place (in Θ(NK) time). Use these counts to compute ∑ i ​ (A i ​ ⊕x) for each x (in Θ(K) time for each x, for a total of Θ(NK) time). Summing up the above, the problem can be solved in Θ(NK) time. Sample Code (Python)：https://atcoder.jp/contests/arc135/submissions/29030561 D - Add to Square Editorial by evima [1] Characterization of the grid after the operations Let A and B denote the grid before and after the operations, respectively. For each row and each column, the alternating sum of the written numbers is an invariant. That is, the following holds: For every i, ∑ j=1 W ​ A ij ​ (−1) i+j =∑ j=1 W ​ B ij ​ (−1) i+j For every j, ∑ i=1 H ​ A ij ​ (−1) i+j =∑ i=1 H ​ B ij ​ (−1) i+j Thus, for these H+W formulae to hold is a necessary condition for B to be obtained by the operations. Let us verify that this necessary condition is also a sufficient condition for B to be obtained by the operations. By matching A i,j ​ to B i,j ​ with the operation on A i,j ​ ,A i,j+1 ​ ,A i+1,j ​ ,A i+1,j+1 ​ in ascending order of i,j, we can match A i,j ​ to B i,j ​ for every 1≤i<H and 1≤j<W. If two grids have the same alternating sum in each row and each column, and the same number in the square (i,j) for each 1≤i<H, 1≤j<W, they have the same numbers in all squares. Thus, when the necessary condition above holds, the procedure above can match A to B. [2] Rephrasing the problem For convenience in dealing with alternating sums, let us multiply the value in the square (i,j) by (−1) i+j to rephrase the problem into the following. You are given a state of the grid A. Among the states of the grid B with the same sum in each row and each column, find one that minimizes ∑∣B ij ​ ∣. By letting x i ​ and y j ​ denote the sums of each row and each column in A, it can be further rephrased into the following. You are given sequences (x 1 ​ ,…,x H ​ ) and (y 1 ​ ,…,y W ​ ) such that ∑x i ​ =∑y j ​ . Among the states of the grid B with the sum of each row equal to x i ​ and the sum of each column equal to y i ​ , find one that minimizes ∑∣B ij ​ ∣. Furthermore, let us consider starting with B i,j ​ =0 and changing it to B i,j ​ =b, which changes the differences between a row’s sum and x i ​ and between a column’s sum and y i ​ . The problem is again rephrased into the following: You are given sequences (x 1 ​ ,…,x H ​ ) and (y 1 ​ ,…,y W ​ ) such that ∑x i ​ =∑y j ​ . Make all x i ​ and y j ​ 0 with the minimum cost, using the following operation. Operation (i,j,b): Add −b to each of x i ​ and y j ​ , for a cost of ∣b∣. [3] Constructing the optimal solution Let X=∑∣x i ​ ∣ and Y=∑∣y j ​ ∣. Operation (i,j,b) changes X and Y by at most ∣b∣, so the following holds: The minimum cost ≥max{X,Y} Let us show that the equality in this inequality holds. Actually, the sequence of operations below achieves the minimum possible cost. If there is (i,j) such that x i ​ <0 and y j ​ <0, do Operation (i,j,−1). Repeat this as long as possible. If there is (i,j) such that x i ​ >0 and y j ​ >0, do Operation (i,j,− ) ​ . Repeat this as long as possible. If there is (i 1 ​ ,i 2 ​ ) such that x i 1 ​ ​ >0 and x i 2 ​ ​ <0, do Operation (i 1 ​ ,1,1) and Operation (i 2 ​ ,1,−1). Repeat this as long as possible. If there is (j 1 ​ ,j 2 ​ ) such that y j 1 ​ ​ >0 and y j 2 ​ ​ <0 , do Operation (1,j 1 ​ ,1) and Operation (1,j 2 ​ ,−1). Repeat this as long as possible. We need to verify that: An operation always decreases max{∑∣x i ​ ∣,∑∣y j ​ ∣} by the amount equal to the cost ∑∣x i ​ ∣=∑∣y j ​ ∣=0 is eventually reached This can be proved using properties such as the following: During the process, ∑x i ​ =∑y j ​ always hold. Therefore, after repeating step 1. and 2. as much as possible, ∑∣x i ​ ∣=0 or ∑∣y j ​ ∣=0 holds. This proof also gives a construction of an optimal solution, so the problem can be solved in Θ(HW) time by summing up the arguments so far. Sample Code (Python)：https://atcoder.jp/contests/arc135/submissions/29110785 [4] Reference: Invariants and polynomials The conclusion in [1] can also be derived from an argument using polynomials. Let us associate a state of the grid A with a bivariate polynomial ∑ i,j ​ A i,j ​ x i y j . Then, the operation in the problem can be interpreted as adding a polynomial P such that (1+x)(1+y)∣P. The polynomial ring Z[x,y] is a unique factorization domain, and fg∣P⟺f∣Pandg∣P holds for irreducible polynomials f,g ( f  =±g) and a polynomial P, so we have: (1+x)(1+y)∣P(x,y)⟺1+x∣P(x,y)and1+y∣P(x,y)⟺P(−1,y)=P(x,−1)=0 This leads to the characterization based on the alternating sums of the rows and columns. E - Sequence of Multiples Editorial by evima Below, we assume that A is an optimal sequence, where A i ​ is the smallest multiple of i greater than A i−1 ​ for i≥2. [1] A solution in O(X 1/2 ) time We first explain an O(X 1/2 ) solution (which is expected to get TLE). Let a sequence B defined by B i ​ =A i ​ /i. We have B i+1 ​ =⌊ i+1 iB i ​ ​ ⌋+1=B i ​ +1−⌈ i+1 B i ​ ​ ⌉. It is easy to see the following: B i ​ is non-increasing B i+1 ​ =B i ​ if B i ​ <i Since B i ​ is non-increasing, there is n such that B n ​ <n. Afterward, it is a constant sequence, where the sum can be computed altogether. Thus, the problem can be solved by computing the sequence B until B n ​ <n holds. Let us evaluate the complexity of this solution, that is, the size of n such that B n ​ <n. If we roughly consider that B i+1 ​ and i+1 iB i ​ ​ are close enough, that is, iB i ​ is almost a constant, it seems probable that B n ​ <n. A more detailed argument can, for example, prove the following: B i ​ < i X ​ +i for every i. Specifically, if we let m=⌈ X ​ ⌉, we have B m ​ < m X ​ +m≤2m, and it follows from B 2m ​ ≤B m ​ <2m that B n ​ <n for n=2m=2⌈ X ​ ⌉. Especially, the time complexity of the solution above is O(X 1/2 ). [2] A solution in O(X 1/3 ) time Let us try to put together some computations in [1]. Since B i ​ −B i+1 ​ =⌈ i+1 B i ​ ​ ⌉−1 and B is non-increasing, it can be seen that the following holds: B 1 ​ −B 2 ​ ≥B 2 ​ −B 3 ​ ≥⋯ Let us deal with B n ​ ,…,B m−1 ​ where B n ​ −B n+1 ​ =⋯=B m−1 ​ −B m ​ holds altogether. For a given n, the range of i where B n ​ −B n+1 ​ =B i ​ −B i+1 ​ holds can be found in O(1) time. Additionally, ∑ i=n m−1 ​ iB i ​ can be found in O(1) time, too (by using formulae such as ∑ k=0 n−1 ​ k 2 = 6 1 ​ (n−1)n(2n−1), or polynomial interpolation, etc). In the end, if B i ​ −B i+1 ​ takes n different values, the problem can be solved in O(n) time. Below is a proof that B i ​ −B i+1 ​ takes O(X 1/3 ) different values. Let n=⌈X 1/3 ⌉. Then, from the evaluations in [1], we have B n ​ <X 2/3 +n. Thus, we have B n ​ −B n+1 ​ =⌈ n+1 B n ​ ​ −1⌉≤⌈ n+1 X 2/3 ​ ⌉≤n. There are at most n−1 different values among B 1 ​ −B 2 ​ ,…,B n−1 ​ −B n ​ , and at most n+1 different values after B n ​ −B n+1 ​ (because they are among 0,1,…,n). Therefore, B i ​ −B i+1 ​ takes at most 2n=2⌈X 1/3 ⌉ different values. F - Delete 1, 4, 7, ... Editorial by evima [1] Computation in O(NK⋅(2/3) K ) time Let N k ​ be the number of elements after k operations. N k ​ can be computed from N k+1 ​ =⌊ 3 2N k ​ ​ ⌋. Particularly, N K ​ , the number of elements in the sequence in question, can be computed in O(K) time. Let M denote this number. Let B=(b 0 ​ ,b 1 ​ ,…) be the result of applying the operation on the sequence A=(a 0 ​ ,a 1 ​ ,…). b i ​ can be computed from the following rule: b i ​ =a j ​ , where j=⌊ 2 3i+2 ​ ⌋. Thus, by letting f(i)=⌊ 2 3i+2 ​ ⌋, the problem can be rephrased as follows: Find ∑ n=0 M−1 ​ (f K (n)+1). Here, f K is the K-times self composition of f. An approach that directly computes this has the complexity of O(MK). Since M≤N⋅(2/3) K , it takes O(NK⋅(2/3) K ) time. [2] Computation in O(K⋅2 K ) time It can be recursively verified that f K , the self composition of f, has the following periodicy: f K (n+2 K )=f K (n)+3 K . By computing the contributions of n such that n≡i(mod2 K ) altogether after precomputing f K (i) for 0≤i<2 K , the computation can be done in O(K⋅2 K ) time. [3] Computation in O((K+logN)⋅2 K/2 ) time Let X and Y be integers such that K=X+Y, and decompose the function as f K (n)=f Y (f X (n)). Additionally, for f X and f Y , we do the precomputation similar to the one in [2]. To compute the contributions of n such that n≡i(mod2 X ) for each i, we need the following computation: Find ∑ j ​ f Y (a+3 X j). This can be done fast by precomputing all sums in the form f Y (a)+⋯+f Y (a+(2 k −1)3 X ). By choosing X=⌈N/2⌉ and Y=⌊N/2⌋, this solves the problem in, for example, O((K+logN)⋅2 K/2 ) time. [4] Conclusion By choosing between the methods [1] and [3], the problem can be solved in the following time complexity: O(min(NK⋅(2/3) K ,(K+logN)⋅2 K/2 )). It is possible to get accepted by, for example, using the method [1] if K>40 and the method [3] if K≤40. Below are some possible optimizations of the solution, none of which should be required to fit within the time limit. Optimize the computation of f K (n) in an approach similar to the one in [3]. Perform the precomputation of f X (i) in O(2 X ) time. For the computation of ∑ j ​ f Y (a+3 X j) in [3], precompute the prefix sums at every 3 X terms in O(2 Y ) time to process each query in O(1) time, for a total of O(2 K/2 ) time. A - Bridge and Sheets Editorial by evima The uncovered part is divided into several segments. From the fact that the tarps have the same lengths, it can be shown that we can individually solve the problem for each segment. Thus, the problem can be rephrased into the following. There are n bridges without existing tarps. The length of the i-th bridge is l i ​ . For each bridge, find the minimum number of tarps needed to cover it entirely. Then, find the sum of these numbers. We need ⌈ W l ​ ⌉ tarps to cover a bridge of length l. Therefore, the answer is ∑ i=1 n ​ ⌈ W l i ​ ​ ⌉, which can be found in O(N) time. B - Reserve or Reverse Editorial by evima To lexicographically minimize the s after the procedure, the following greedy algorithm should be applied. Make s 1 ​ as small as possible. Satisfying the above, make s 2 ​ as small as possible. Satisfying the above, make s 3 ​ as small as possible. ⋮ Satisfying the above, make s N ​ as small as possible. The procedure by Snuke can be rephrased into the following. Let l=0,r=N+1. Snuke chooses integers p,q such that l<p<q<r (or terminate the procedure). Swap s p ​ and s q ​ . Set l=p,r=q and go to 2. Here, we should apply the greedy algorithm above, as follows. A proper implementation runs in O(N) time, which is fast enough. If a swap with p=1 makes s 1 ​ smaller, do it. Here, choose the largest q that makes s 1 ​ the smallest. If a swap with p=2 makes s 2 ​ smaller, do it. Here, choose the largest q that makes s 2 ​ the smallest. ⋮ C - The Majority Editorial by evima The balls with 1 have the majority in every box if and only if the following holds: after repeatedly removing a pair of a ball with 1 and a ball with a different number, every box will have just balls with 1, and no box is empty. We should exclude the balls with 1 to be paired with balls with other numbers beforehand, put the remaining balls with 1 in the boxes, and then find the product of numbers of ways to allocate the other balls to the boxes. The answer is ( K+1 a 1 ​ −∑ i=2 N ​ a i ​ ​ )∏ i=2 N ​ ( K+1 a i ​ +K+1 ​ ), which can be found fast enough in O(NK) time. D - Concatenate Subsequences Editorial by evima Let A=(a 1 ​ ,a 2 ​ ,…,a N ​ ),B=(a N+1 ​ ,…,a 2N ​ ). Also, let X be min(A). If there is i such that A i ​ =X,A i ​ ≥B i ​ , choosing such i with the smallest B i ​ yields the lexicographically smallest possible sequence. Below, we assume A i ​ ≤B i ​ when A i ​ =X. Then, it can be proved that all i such that A i ​ =X are chosen in the optimal solution (otherwise, the resulting sequence will be obviously lexicographically larger). Let y=(y 1 ​ ,y 2 ​ ,…,y K ​ ) be the list of i such that A i ​ =X sorted in ascending order. Let us consider the optimal choice of j such that y K ​ <j≤N,A j ​ ≤B c 1 ​ ​ . Let us deal with these j after sorting them by (A j ​ ,j) in ascending order. Then, for elements such that A j ​ <B y 1 ​ ​ , it can be shown that the optimal strategy is to add j if it is greater than the current last element of y (otherwise, the result will be lexicographically larger). The last thing to consider is whether to choose j such that A j ​ =B y 1 ​ ​ . The following can be shown: if adding one such j makes the result lexicographically smaller, they should be chosen as many as possible. Otherwise, none of them should be chosen. It is possible to implement the above to find the answer in O(N) time, but an O(NlogN) algorithm also runs fast enough. E - Modulo Nim Editorial by evima First, let us consider the problem to determine the winner for a given a. Since 0 or multiple occurrences of the same number do not affect the answer, the board can be represented as a set of natural numbers. Let S be the current board. If S={1} or S={2}, it is obvious that the current player loses. Let us consider the other cases. Below, we assume max(S)≥3. If the board has an odd number, a move with m=2 wins the game, so all elements of S need to be even for the board to be losing. Similarly, if the board has a number that leaves a remainder of 2 when divided by 4, a move with m=4 wins the game, so all elements of S need to be multiples of 4 for the board to be losing. Additionally, by considering the move with m=3, it can be seen that the board needs to satisfy one of the following to be losing. S contains both a number that leaves a remainder of 1 and a number that leaves a remainder of 2 when divided by 3. All elements of S are multiples of 3. For the former case, the only losing board is {4,8}. Otherwise, a move with m=12 wins the game. For the latter case, all elements of S need to be multiples of 12. Since a i ​ ≤200, there are at most 2 ⌊ 12 200 ​ ⌋ boards that have to be considered. Because of this small number of relevant boards, we can list all losing S by determining the outcomes for these boards by methods such as memoized recursion. Now, let us return to the original problem. The observations so far have revealed that Taro The First only loses in quite limited cases, which can be counted by methods such as bitmask DP. F - Flipping Coins Editorial by evima First, let us correlate the permutation p and the final number of coins k that face up. Consider a sequence of the form i→p i ​ →p p i ​ ​ →⋯ Let chain be a maximal such sequence such that i<p i ​ <p p i ​ ​ <⋯ (that is, increasing). Assume that the cycles in the permutation p are decomposed into sets of chains. Then, considering how the operations are done, it can be seen that the number of odd length chains equals k. It is difficult to directly count the permutations p with k odd length chains, so we will consider a different problem with the same answer and solve it. Consider a mapping f(p)=q that assign to a permutation p another permutation q. First, consider the decomposition of p into cycles. Let x i,1 ​ →x i,2 ​ →⋯→x i,1 ​ be the i-th cycle. Here, make x i,1 ​ the smallest index that appears in this cycle. Additionally, order the cycles so that x 1,1 ​ >x 2,1 ​ >⋯ Arranging x 1 ​ ,x 2 ​ ,⋯ in this order yields a permutation of {1,2,⋯,N}, which we define to be f(p). Here, it can be first seen that f has an inverse mapping. That is, for a given permutation p, there uniquely exists p such that f(p)=q. This can be obtained by scanning the elements of q from the front and making a new cycle when the prefix minimum is updated. Let run be a maximal increasing contiguous subsequence of q. Then, it can be seen that a chain in p corresponds to a run in q. Therefore, we have the following problem. Consider a permutation q. When q has exactly k odd length runs, we get a score of W k . What is the sum of the scores for all possible q? For each run, let us group the elements into pairs from the front. Label the elements in each pair A, B in this order, and the leftover element C. The number of odd length runs is equal to the number of C. Here, the final sequence of ABC has the following form: zero or more (zero or more C + AB) + (zero or more C) Now, let us fix one such ABC sequence and try to count permutations corresponding to that sequence. First, for each block of (zero or more C + AB), the relative order of the elements inside must be considered. On the other hand, it is the only requirement when making the corresponding permutations. That is, there is no need to consider constraints that straddle multiple blocks. (The same goes for the block of (zero or more C).) We can use DP to count these for all possible ABC sequences. Let dp[i]= the sum of weights of all permutations of length i. In the transition dp[i]→dp[j], the block of ( (j−i−2) Cs + AB) should be added. If implemented naively, this DP takes O(N 2 ) time, but we can optimize it by divide-and-conquer FFT to yield an O(Nlog 2 N) algorithm. The problem can also be solved in O(NlogN) time by considering the inverse of a formal power series. A - Erase by Value Editorial by evima If there is i such that A i ​ >A i+1 ​ , let k be the leftmost such index. Let j be the smallest i among the i’s such that A k ​ =A i ​ . Then, A begins with A 1 ​ ≤A 2 ​ ≤⋯≤A j−1 ​ <A j ​ =A j+1 ​ =⋯=A k ​ >A k+1 ​ . If we choose x=A k ​ here, a will begin with A 1 ​ ,A 2 ​ ,⋯,A j−1 ​ ,A k+1 ​ , which can be verified to be lexicographically smaller than A. (They share the first j−1 elements, and the j-th element of a is smaller than that of A.) If we choose a different value for x, an argument similar to above shows that the result will not be better than when x=A k ​ . Thus, x=A k ​ is an optimal choice. If there is no i such that A i ​ >A i+1 ​ , the optimal choice is x=A N ​ since A is non-decreasing. Implementation of the above will run in O(N) time. B - Dividing Subsequence Editorial by evima First, let us list all pairs (i,j) such that Q j ​ is a multiple of P i ​ . There are approximately ∑ 1≤i≤N ​ N/i such pairs, which is known to be O(NlogN). The problem considers a sequence of such pairs (i 1 ​ ,j 1 ​ ),(i 2 ​ ,j 2 ​ ),⋯,(i k ​ ,j k ​ ) such that i 1 ​ <i 2 ​ <⋯<i k ​ , j 1 ​ <j 2 ​ <⋯<j k ​ and asks us to maximize its length. Let us sort the pairs using (i,−j) as the key (note that the sign of j is inverted). In the resulting sequence, if we look only at j’s and find the longest (strictly) increasing subsequence, it turns out to be the answer to the original problem. (Since j’s corresponding to the same i are in descending order, the i’s in the subsequence are guaranteed to be strictly increasing.) Implementation of finding the longest increasing subsequence can be easily done using the lower_bound on arrays. The total complexity will be O(Nlog 2 N). C - Row Column Sums Editorial by evima If the sum of A and that of B are different modulo K, the objective is obviously unachievable. Below, we consider the other case. Let us start by hypothetically writing K−1 in every square, and try to fit the conditions by decreasing the numbers. For each row and each column, we can find the amount by which we need to reduce the sum modulo K. Let C i ​ and D i ​ be those amounts. Let Z=max(∑ 1≤i≤H ​ C i ​ ,∑ 1≤i≤W ​ D i ​ ). We have to decrease the numbers by at least Z in total. On the other hand, we can show the existence of a solution where we decrease the numbers by exactly Z in total. Therefore, the answer is HW(K−1)−Z. Below, we will show the existence of such a solution. Because ∑ 1≤i≤H ​ C i ​ ≡∑ 1≤i≤W ​ D i ​ modK, it is possible to add some multiple of K to C 1 ​ or D 1 ​ so that ∑ 1≤i≤H ​ C i ​ =∑ 1≤i≤W ​ D i ​ =Z. Now, repeat the following Z times. Find i,j such that C i ​ ≥1,D j ​ ≥1. Decrease by 1 the value at the i-th row and j-th column, and also C i ​ and D j ​ . Here, the value at the i-th row and j-th column will be decremented at most min(C i ​ ,D j ​ )≤K−1 times, so there will never be a negative value. This completes the proof. D - Range XOR Editorial by evima For 0≤k, let us define w k ​ =0⊕1⊕⋯⊕(k−1). We want to count (i,j) such that L≤i<j≤R+1 and w i ​ ⊕w j ​ =V. After a small transformation, it comes down to a subroutine of counting (i,j) such that 0≤i<A,0≤j<B,w i ​ ⊕w j ​ =V. The values of w k ​ are simple when classified modulo 4. Specifically, we have: w 4x ​ =0 w 4x+1 ​ =4x w 4x+2 ​ =1 w 4x+3 ​ =4x+3 Thus, we just need to fix the remainders of i and j divided by 4 and solve all 16 cases. In reality, the cases (4x,4x+2) can be bundled together, as well as (4x+1,4x+3), so we have about 4 cases. The most complex of them is the case where i and j are both (4x+1,4x+3). In this case, we additionally have to solve the following subproblem. Given integers C, D, and W, count pairs (c,d) such that 0≤c<C,0≤d<D,c⊕d=W. This can be solved fast by bit DP or memoized recursion. Implementation of the above solves the problem in O(poly(logmax(R,V))) time. E - Cyclic Medians Editorial by evima Here, we assume that the values range from 0 to V−1. For each 1≤k≤V−1, we count the ways ending up with k≤a. The answer is the sum of those numbers. Now, consider a fixed k. If we correspond values less than k to 0 and values not less than k to 1, we now have a problem with a 01-sequence. By the way, the median of (a,0,0) is 0, and that of (a,1,1) is 1. Thus, if there is a time when the two values other than a are the same, the final value of a does not depend on the initial value ( =A). Let us call these cases inactive, and the other cases active. Here, from the symmetry of 0,1, the number of inactive cases with k=p resulting in 0 is equal to that of inactive cases with k=V−p resulting in 1. Eventually, considering only inactive cases for all 1≤k≤V−1, exactly half of them print 1. Thus, we can easily handle the inactive cases. Now, consider the active cases. Let G:=gcd(N,M). The active cases can be characterized as follows. (Here, the elements of x and y are converted to 0,1.) For each 1≤r≤G, x r ​ =x r+G ​ =⋯ and y r ​ =y r+G ​ =⋯ and x r ​  =y r ​ . This follows from the fact that there is a time when x i ​ and y j ​ are used together ⟺i≡jmodG. Eventually, the number of active cases can be found as (k N/G (V−k) M/G +k M/G (V−k) N/G ) G . In these cases, the procedure does not change the value in input, so we just need to sum the aforementioned number for k≤A. Implementation of the above solves the problem in O(V(logN+logM)) time, which is fast enough. F - Random Transition Editorial by evima First, we rephrase the operation as follows. We have a 01-sequence of length N, where x characters are 1. Choose a random character and flip it ( 0 becomes 1 and vice versa). Let us count the number of ways that begin with a 1’s and end with b 1’s after K operations. Here, let us define polynomials of two variables x,y: f even ​ =y(∑ i≡0mod2 ​ x i /i!)+(∑ i≡1mod2 ​ x i /i!) and f odd ​ =(∑ i≡0mod2 ​ x i /i!)+y(∑ i≡1mod2 ​ x i /i!). Here, the degree of x corresponds to the number of operations, and the degree of y corresponds to the final number of 1’s. The value we seek is the coefficient of x K y b in f even a ​ f odd N−a ​ (multiplied by K!/N K , to be precise, but we ignore it now). If we define P=(y+1)exp(x),Q=(y−1)exp(−x), what we want to compute is ∑ 0≤a≤N ​ A a ​ (P+Q) a (P−Q) N−a (multiplied by some constant, but again we ignore it here). The result of computing ∑ 0≤a≤N ​ A a ​ (P+Q) a (P−Q) N−a can be written as ∑ 0≤i≤N ​ w i ​ P i Q N−i using some w 0 ​ ,w 1 ​ ,⋯,w N ​ . Here, the x-component of P i Q N−i turns out to be exp((2i−N)x), so the coefficient of x K can be found as (2i−N) K /K!. (Combining it with the term K! which we first ignored, we have (2i−N) K , which can be easily computed.) Eventually, what we want to compute is ∑ 0≤i≤N ​ w i ​ (2i−N) K (y+1) i (y−1) N−i . To compute ∑ 0≤a≤N ​ A a ​ (P+Q) a (P−Q) N−a and ∑ 0≤i≤N ​ w i ​ (2i−N) K (y+1) i (y−1) N−i , the following problem should be solved. Given an integer sequence C 0 ​ ,C 1 ​ ,⋯,C N ​ as the input, find ∑ 0≤i≤N ​ C i ​ (z+1) i (z−1) N−i as a polynomial of z. This can be solved by divide and conquer. Specifically, we should solve the problem on the former and latter halves of C recursively, multiply them by powers of (z−1) and (z+1), respectively, and then add them. By using FFT in multiplications of polynomials, the total complexity will be O(Nlog 2 N). Sample Solution (c++) Note: It is possible to solve the problem in O(NlogN) time by calculating ∑ 0≤i≤N ​ C i ​ z i (z−2) N−i . Shout-out to EntropyIncreaser! Sample Solution(c++) A - Permutation Grid Editorial by evima Consider the case n=5 and the permutations R,C are both 1,2,3,4,5. Let ? denote the square whose color is not yet determined. Copy ????? ????? ????? ????? ????? ????? ????? ????? ????? ????? Since the 5-th row should have five black squares, it must be entirely black. The same goes for the 5-th column. Copy ????# ????# ????# ????# ##### ????# ????# ????# ????# ##### Since the 1-st row should have one black square, all remaining squares must be white. The same goes for the 1-st column. Copy ....# .???# .???# .???# ##### ....# .???# .???# .???# ##### Since the 4-th row should have four black squares, all remaining squares must be black. The same goes for the 4-th column. Copy ....# .??## .??## .#### ##### ....# .??## .??## .#### ##### Since the 2-nd row should have two black squares, all remaining squares must be white. The same goes for the 2-nd column. Copy ....# ...## ..?## .#### ##### ....# ...## ..?## .#### ##### Since the 3-rd row should have three black squares, all remaining squares must be black. The same goes for the 3-rd column. Copy ....# ...## ..### .#### ##### ....# ...## ..### .#### ##### Therefore, the square at the r-th row from the top and c-th column from the left will be black if r+c≥6 and white otherwise. We can also prove that for a general n, when the permutations R,C are both 1,2,…,n, the square at the r-th row from the top and c-th column from the left will be black if r+c≥n+1 and white otherwise. (We can prove it, for example, by induction by determining the outermost squares as we did above and reducing the case to the n−2 case.) Additionally, when we have the solution M for some R 1 ​ ,…,R n ​ ,C 1 ​ ,…,C n ​ , the solution for that case after swapping the a-th and b-th terms of R 1 ​ ,…,R n ​ will be M after swapping the a-th and b-th rows. The same goes for columns. Therefore, the square at the r-th row from the top and j-th column from the left will be black if R r ​ +C c ​ ≥n+1 and white otherwise. B - Shift and Reverse Editorial by evima Let Operation 1 and 2 be the following operations. Reverse the entire permutation: p 1 ​ ,p 2 ​ ,…,p n ​ becomes p n ​ ,p n−1 ​ ,…,p 1 ​ . Move the term at the beginning to the end: p 1 ​ ,p 2 ​ ,…,p n ​ becomes p 2 ​ ,…,p n ​ ,p 1 ​ . Solution A There are only 2n permutations that the operations above can sort into 1,2,…,n, as follows (when n=2, there are just two of them because of duplication). The ones that can be sorted in ascending order by Operation 1 1,2,3,…,n 2,3,…,n,1 3,…,n,1,2 ⋮ n,1,2,3,…,n−1 The ones that can be sorted in descending order by Operation 2 n,n−1,n−2,…,1 n−1,n−2,…,1,n n−2,…,1,n,n−1 ⋮ 1,n,n−1,n−2,…,2 Thus, there are only O(n) possible states on the way, so we can solve it basically by brute force. However, each operation would take O(n) time in naive implementation using the given array of length n as is, so we need to improve the way to maintain the states. One better way to represent a state is to represent it as the pair of the following information. The position of 1 Whether it can be sorted in ascending order by Operation 2 only Sample Implementation in C++ Solution B Doing Operation 2 → Operation 1 → Operation 2 leads to the same result as doing Operation 1 only. Thus, we do not need to consider doing Operation 2 → Operation 1 → Operation 2. Similarly, doing Operation 1 → Operation 1 leads to the same result as doing nothing, so we do not need to consider it. From above, we can see that Operation 1 only needs to be done at the beginning or end. Therefore, we can try four cases: whether we do Operation 1 at the beginning and whether we do it at the end, and adopt the one with the fewest operations among the ones that worked. C - Almost Sorted Editorial by evima We will do Dynamic Programming with the following two keys, choosing the terms from front to back. The number of terms already chosen The set of elements already used However, there are 2 n possible sets of used elements, so we need to do better than maintaining them naively. When the first i terms are chosen, there is no way to choose the rest to satisfy the conditions if the following is not satisfied. All elements less than or equal to i−d are used. No elements greater than or equal to i+d+2 are used. Thus, it is enough to remember, for each i, whether each number between i−d+1 and i+d+1 is used. There are only 2 2d+1 sets to remember, making the size of the table of the dynamic programming O(4 d n). There are d transitions for each state, so the complexity is O(4 d dn). D - Between Two Binary Strings Editorial by evima Solution When the first character is fixed, the optimal string x can be constructed greedily, using the same character as the previous as long as the following condition is satisfied. The number of 0s among the first i characters of x is between that of s and that of t. Therefore, for each of the two cases where the first character is 0 and where it is 1, we can greedily construct the string and find its beauty, and then we print the greater. Sample Implementation in C++ Proof Below we prove the validity of the greedy strategy. Associate a string with a path in a two-dimensional grid Let us associate a string s∈S n,m ​ with a path from the coordinates (0,0) to (n,m) in n+m steps as follows. When we are at (x,y) before the i-th step, go to (x+1,y) if the i-th character of s is 0, and go to (x,y+1) if that character is 1. In this path, swapping two adjacent characters in the string corresponds to “folding back” a corner in the path. Thus, if S and T are the path corresponding to s and t, the path corresponding to a string between s and t lies between S and T (in the region surrounded by S and T). Additionally, the beauty is maximized by minimizing the number of turns. If going straight would take us out of the region between S and T, we need to make a turn. Let us call turns made in other cases bad. It is sufficient to show that we do not need to consider making bad turns when minimizing the number of turns. We can show this as follows. Let P be an arbitrary path from (0,0) to (n,m) that lies between S and T, and assume that P makes a bad turn. By fixing P as described below, we can construct a path Q that satisfies the following conditions. The number of turns is not more than that in P. The first bad turn is made later than in P (that is, there are more steps before the first bad turn), or there is no bad turn. Let A be the point where the first bad turn among the n+1 steps is made. Let P ′ be the path where we do not make a turn at A and instead make a turn when hitting S or T. Let B be the first point after A where P and P ′ cross (share the same point). From A to B (including both ends), P ′ always makes exactly one turn, while P makes two or more turns. If B=(n,m), P ′ makes no bad turns, so we can let this P ′ be Q. Otherwise, consider a new path P ′′ that traces P ′ until B and traces P after that. From A to B (including both ends), P ′′ always makes exactly two turns. Additionally, the first bad turn of P ′′ is at B. Thus, we can let this P ′′ be Q. By repeatedly constructing Q from P, we can eventually have a path without bad turns (because as long as the path has a bad turn, it makes the first bad turn later and later, but the path from (0,0) to (n,m) has a finite number of steps which is n+m). This completes the proof. E - Paw Editorial by evima The final state looks like <<..<==..=>>..>, where = denotes a square that does not change from the initial state, < denotes a square replaced with a left-pointing footprint, and > denotes a square replaced with a right-pointing footprint. That is, the squares to the left of a square replaced with < will also be replaced with <, and the squares to the right of a square replaced with > will also be replaced with >. Additionally, only a maximal segment not containing . in the initial state can become the segment of =s. Therefore, there are only k+1 possible final states, where k is the number of squares with a hole. The problem can be solved by finding the probability that each final state is realized. Consider the number of sequences of operations that replace the leftmost d .s in the initial state with <s, and the remaining k−d . with >s. The operations on the d .s to the left and those on the t−d .s to the right do not affect each other. Thus, if we find the number L d ​ of desirable sequences of operations on the left side, and the number R t−d ​ of desirable sequences of operations on the right side, the sought number is L d ​ R t−d ​ ( d k ​ ). To find L 0 ​ ,…,L k ​ , let us ignore the squares that are not eventually replaced with <s for now. We focus on the direction Snuke faces after filling the i-th square. If there are holey squares to the right of the i-th square when filling the i-th square, Snuke’s direction here does not affect the final state. The same goes for the square with a footprint in the initial state. This is because the i-th square will also become < when the holey square immediately to the right becomes <. On the other hand, if there is no holey square to the right of the i-th square, Snuke must face to the left. Let us use this observation to create a recurrence formula on L 0 ​ ,…,L k ​ . Assume that d+1 .s will get replaced with <s, and classify the cases according to when the leftmost holey square gets filled. If the leftmost one is the (d+1)-th square to be filled, Snuke must face to the left; otherwise, he may face either direction. There are L d ​ ways to decide the relative order of the d remaining empty squares and Snuke’s directions on them, so we have L d+1 ​ =(2d−1)L d ​ . Additionally, by swapping left and right in the operation, we can see that L d ​ =R d ​ . Sample Implementation in C++ F - Takahashi The Strongest Editorial by evima Focusing only on Aoki’s and Snuke’s strategies, there are four possible scenarios for the i-th round, as follows. Takahashi can become the only winner by playing paper. (The other two both play rock.) Takahashi can become the only winner by playing rock. (The other two both play scissors.) Takahashi can become the only winner by playing scissors. (The other two both play paper.) Takahashi cannot become the only winner by playing any hand. (The other two play different hands.) Let the opponents’ strategy be the sequence (v 1 ​ ,…,v t ​ ), representing each of the k rounds as one of the four above. Find the probability distribution for the opponents’ strategy in O(k4 k ). Let us find a way to find the probability distribution representing what the opponents’ strategy becomes among the 4 k possible ones. An obvious policy is to try all nm choices, but it takes O(k9 k ) time, so let us do convolution using DP similar to the fast zeta transform. Policy Let A v 1 ​ ,…,v k ​ ​ be the probability that Aoki satisfies the following conditions, where v i ​ =1,2,3. If v i ​ =1, he plays rock in the i-th round. If v i ​ =2, he plays scissors in the i-th round. If v i ​ =3, he plays paper in the i-th round. Let A v 1 ​ ,…,v k ​ ′ ​ be the probability that Aoki satisfies the following conditions, where v i ​ =1,2,3,4. If v i ​ =1, he plays rock in the i-th round. If v i ​ =2, he plays scissors in the i-th round. If v i ​ =3, he plays paper in the i-th round. If v i ​ =4, he may play anything. Let f be the process that finds {A v 1 ​ ,…,v k ​ ′ ​ } v 1 ​ ,…,v n ​ =1,2,3,4 ​ from {A v 1 ​ ,…,v k ​ ​ } v 1 ​ ,…,v n ​ =1,2,3,4 ​ . For Snuke, we similarly define B v 1 ​ ,…,v k ​ ​ and B v 1 ​ ,…,v k ​ ′ ​ . Then, C v 1 ​ ,…,v k ​ ′ ​ :=A v 1 ​ ,…,v k ​ ′ ​ B v 1 ​ ,…,v k ​ ′ ​ will be the probability that the following is satisfied. If v i ​ =1, both play rock in the i-th round. If v i ​ =2, both play scissors in the i-th round. If v i ​ =3, both play paper in the i-th round. If v i ​ =4, they may play anything. Therefore, if C v 1 ​ ,…,v k ​ ​ is the sequence that satisfies {C v 1 ​ ,…,v k ​ ′ ​ } v i ​ =1,2,3,4 ​ =f({C v 1 ​ ,…,v k ​ ​ } v i ​ =1,2,3,4 ​ ), C v 1 ​ ,…,v k ​ ​ is the probability distribution that we seek. Implementation {A v 1 ​ ,…,v k ​ ​ } v 1 ​ ,…,v n ​ =1,2,3,4 ​ can be directly found from input. f can be computed by adding each term A v 1 ​ ,…,v k ​ ​ such that v i ​  =4 to A v 1 ​ ,…,v i−1 ​ ,4,v i+1 ​ …v k ​ ​ , similarly to the fast zeta transform. That is, we let A v 1 ​ ,…,v k ​ 0 ​ :=A v 1 ​ ,…,v k ​ ​ , compute A v 1 ​ ,…,v k ​ i+1 ​ for each i as follows, and then let A v 1 ​ ,…,v k ​ ′ ​ :=A v 1 ​ ,…,v k ​ k ​ . (Here, superscripts are indices, not powers.) A v 1 ​ ,…,v i−1 ​ ,1,v i+1 ​ …v k ​ i+1 ​ :=A v 1 ​ ,…,v i−1 ​ ,1,v i+1 ​ …v k ​ i ​ A v 1 ​ ,…,v i−1 ​ ,2,v i+1 ​ …v k ​ i+1 ​ :=A v 1 ​ ,…,v i−1 ​ ,2,v i+1 ​ …v k ​ i ​ A v 1 ​ ,…,v i−1 ​ ,3,v i+1 ​ …v k ​ i+1 ​ :=A v 1 ​ ,…,v i−1 ​ ,3,v i+1 ​ …v k ​ i ​ A v 1 ​ ,…,v i−1 ​ ,4,v i+1 ​ …v k ​ i+1 ​ :=A v 1 ​ ,…,v i−1 ​ ,1,v i+1 ​ …v k ​ i ​ +A v 1 ​ ,…,v i−1 ​ ,2,v i+1 ​ …v k ​ i ​ +A v 1 ​ ,…,v i−1 ​ ,3,v i+1 ​ …v k ​ i ​ +A v 1 ​ ,…,v i−1 ​ ,4,v i+1 ​ …v k ​ i ​ Here, A v 1 ​ ,…,v k ​ j ​ is the probability that the following is satisfied. For each i such that i<j: If v i ​ =1, play rock in the i-th round. If v i ​ =2, play scissors in the i-th round. If v i ​ =3, play paper in the i-th round. If v i ​ =4, play anything. For each i such that i≥j: If v i ​ =1, play rock in the i-th round. If v i ​ =2, play scissors in the i-th round; If v i ​ =3, play paper in the i-th round. (If v i ​ =4, playing anything is unacceptable.) We do the same for the inverse function. That is, for each i, we subtract each term A v 1 ​ ,…,v k ​ ′ ​ such that v i ​  =4 from A v 1 ​ ,…,v i−1 ​ ,4,v i+1 ​ …v k ​ ′ ​ . Find the answer from the probability distribution of the opponents’ strategy in O(k4 k ) From the probability distribution we have just found, let us next find the probability that Takahashi gets unhappy for each strategy for Takahashi. Here, we can use a term-by-term conversion similar to the above. Let D v 1 ​ ,…,v k ​ ​ be the probability that the following conditions are satisfied, where v i ​ =1,2,3,4. If v i ​ =1, anything other than both players playing rock is allowed in the i-th round. If v i ​ =2, anything other than both players playing scissors is allowed in the i-th round. If v i ​ =3, anything other than both players playing paper is allowed in the i-th round. If v i ​ =4, playing anything is allowed. To find D v 1 ​ ,…,v k ​ ​ from C v 1 ​ ,…,v k ​ ​ , we let C v 1 ​ ,…,v k ​ 0 ​ :=C v 1 ​ ,…,v k ​ ​ , compute C v 1 ​ ,…,v k ​ i+1 ​ for each i as follows, and then let D v 1 ​ ,…,v k ​ ​ :=C v 1 ​ ,…,v k ​ k ​ . C v 1 ​ ,…,v i−1 ​ ,1,v i+1 ​ …v k ​ i+1 ​ :=C v 1 ​ ,…,v i−1 ​ ,2,v i+1 ​ …v k ​ i ​ +C v 1 ​ ,…,v i−1 ​ ,3,v i+1 ​ …v k ​ i ​ +C v 1 ​ ,…,v i−1 ​ ,4,v i+1 ​ …v k ​ i ​ C v 1 ​ ,…,v i−1 ​ ,2,v i+1 ​ …v k ​ i+1 ​ :=C v 1 ​ ,…,v i−1 ​ ,1,v i+1 ​ …v k ​ i ​ +C v 1 ​ ,…,v i−1 ​ ,3,v i+1 ​ …v k ​ i ​ +C v 1 ​ ,…,v i−1 ​ ,4,v i+1 ​ …v k ​ i ​ C v 1 ​ ,…,v i−1 ​ ,3,v i+1 ​ …v k ​ i+1 ​ :=C v 1 ​ ,…,v i−1 ​ ,1,v i+1 ​ …v k ​ i ​ +C v 1 ​ ,…,v i−1 ​ ,2,v i+1 ​ …v k ​ i ​ +C v 1 ​ ,…,v i−1 ​ ,4,v i+1 ​ …v k ​ i ​ C v 1 ​ ,…,v i−1 ​ ,4,v i+1 ​ …v k ​ i+1 ​ :=C v 1 ​ ,…,v i−1 ​ ,1,v i+1 ​ …v k ​ i ​ +C v 1 ​ ,…,v i−1 ​ ,2,v i+1 ​ …v k ​ i ​ +C v 1 ​ ,…,v i−1 ​ ,3,v i+1 ​ …v k ​ i ​ +C v 1 ​ ,…,v i−1 ​ ,4,v i+1 ​ …v k ​ i ​ Now that we have found the probability D v 1 ​ ,…,v k ​ ​ that Takahashi gets unhappy, the answer is 1−D v 1 ​ ,…,v k ​ ​ . Sample Implementation in C++ A - Two Lucky Numbers Editorial by evima Table of contents If you are new to programming and at a loss, go to practice contest and try Problem A, with sample solutions in each language. 1. Naive algorithm 2. Intended solution 3. Proof 4. Hints for coming up with the solution 5. Source codes To see just the solution, go to 2. Intended solution. 1. Naive algorithm Here is a simple algorithm to solve this problem: Determine if x=1 is super-lucky. (If yes, print 1 and terminate.) Determine if x=2 is super-lucky. (If yes, print 2 and terminate.) Determine if x=3 is super-lucky. (If yes, print 3 and terminate.) And so on, until encountering a super-lucky number for the first time. However, this can take long. For example, if A=99999999,B=40000000, the smallest super-lucky number is 9999999920000000, with 16 digits. Computers are not infinitely fast, and a solution that performs more than 10 8 ∼10 9 calculations (the number depends on programming language) will get a Time Limit Exceeded verdict. (Source Code in C++) Let us try a different approach. 2. Intended solution It turns out that, under the Constraints, 500,000,000×B+A is always super-lucky. Thus, the following program (C++) that prints this value will get accepted. See 5. Source codes for codes in Python, Java, C. Copy #include <iostream> #include <string> using namespace std; int main() { 	long long A, B; // declare variables A, B of type long long 	cin >> A >> B; // receive integers A, B 	cout << 500000000LL * B + A << endl; // LL stands for long long 	return 0; } #include <iostream> #include <string> using namespace std; int main() { 	long long A, B; // declare variables A, B of type long long 	cin >> A >> B; // receive integers A, B 	cout << 500000000LL * B + A << endl; // LL stands for long long 	return 0; } 3. Proof Here is the proof of the solution. Let X=500,000,000×B+A. Then, we have 2X=10 9 ×B+2A, and the following holds. The lowest 8 digits of X form A, satisfying the first condition ( X contains A). Since A≤99999999, the lowest 9 digits of 2X form 2A, and the digits above them form B, satisfying the second condition ( 2X contains B). For reference, here are the values of X and 2X in some cases. 4. Hints for coming up with the solution In a problem that asks you to “construct” one solution, it is typically helpful to consider just part of the given conditions and then modify the provisional solution a bit. In this problem, it allows us to reach the intended solution as follows. Step 1: Consider just the first condition What integer x satisfies the first condition ( x contains A)? Obviously, x=A does. Step 2: Possible modification Now, consider modifying x a bit so that it still satisfies the condition. We can see that modifying the part above the lowest 9 digits does not break it. (For example, when A=1234567, changing it to x=1001234567 or x=869001234567 is fine.) Step 3. Add the second condition Now, consider making the upper digits of 2x contain B. It should be possible to derive x=500,000,000×B+A. This pattern of thought can also be used in other problems such as ARC 117 A - God Sequence. B - Grid Repainting 4 Editorial by evima Table of contents Intended solution Implementation Sample Codes 1. Intended solution The method below constructs a coloring that satisfies the requirements. Here, we paint the squares in the order starting at the top-left square, but it is not mandatory. If (1,1) is not painted yet, paint it in a color different from those of all adjacent squares. [1] If (1,2) is not painted yet, paint it in a color different from those of all adjacent squares. If (1,3) is not painted yet, paint it in a color different from those of all adjacent squares. : If (H,W) is not painted yet, paint it in a color different from those of all adjacent squares. The figure below shows this method applied to a specific grid. [1] Here, the existence of such a color is guaranteed, because there are at most four adjacent squares, while there are five colors available. 2. Implementation As in the (C++) code below, the solution can be implemented using nested loops. The two-dimensional array d[i][j] represents the color of (i,j), where d[i][j]=0 means it is unpainted yet, and the other values mean it is painted in Color d[i][j]. As a side note, in problems involving grids, it can be helpful to have arrays that store information indicating the positions of adjacent squares, such as: int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, 1, 0, -1}; For codes in Python, JAVA, C, see 3. Sample Codes. Copy #include <iostream> using namespace std; // Positions of adjancent squares int dx[4] = { 1, 0, -1, 0 }; int dy[4] = { 0, 1, 0, -1 }; // Input/Output, the grid int H, W; int d[709][709]; int main() { 	// Step #1. Input 	cin >> H >> W; 	for (int i = 1; i <= H; i++) { 		for (int j = 1; j <= W; j++) { 			char c; cin >> c; 			if (c == '.') { d[i][j] = 0; } // Not painted 			if (c == '1') { d[i][j] = 1; } // Color 1 			if (c == '2') { d[i][j] = 2; } // Color 2 			if (c == '3') { d[i][j] = 3; } // Color 3 			if (c == '4') { d[i][j] = 4; } // Color 4 			if (c == '5') { d[i][j] = 5; } // Color 5 		} 	} 	// Step #2. Simulation 	for (int i = 1; i <= H; i++) { 		for (int j = 1; j <= W; j++) { 			if (d[i][j] != 0) { 				// already painted, no need to paint it 				continue; 			} 			// used[k] = true when there is an adjacent square in Color k 			bool used[6] = { false, false, false, false, false, false }; 			for (int k = 0; k < 4; k++) { 				int sx = i + dx[k]; 				int sy = j + dy[k]; 				used[d[sx][sy]] = true; 			} 			// Look for the color to use 			// In this program, choose the usable color with the smallest ID 			for (int k = 1; k <= 5; k++) { 				if (used[k] == true) continue; 				d[i][j] = k; 				break; 			} 		} 	} 	// Step #3. Output 	for (int i = 1; i <= H; i++) { 		for (int j = 1; j <= W; j++) { 			cout << d[i][j]; 		} 		cout << endl; 	} 	return 0; } C - Zero XOR Editorial by evima Table of contents Intended solution Proof Hints for coming up with the solution Sample Codes 1. Intended solution The answer can be found by a case-by-case analysis as follows. (See 2. Proof for the proof.) If N is odd: The first player always wins. If N is even: First player wins if (s)he can make the XOR of the cookies remaining on the desk 0. Otherwise, the second player wins (☆). In other words, let v=A 1 ​ XOR A 2 ​ XOR ⋯ XOR A N ​ . If one of A 1 ​ ,A 2 ​ ,⋯,A N ​ is equal to v, the first player wins. Otherwise, the second player wins (★). See the section 1.2 for the validity of this rephrasing. Therefore, the following program solves the problem. Note that, when N is even, a naive check using ☆ takes O(N 2 ) time and is too slow, so we need to use ★. Copy #include <iostream> using namespace std; int N, A[400009]; int v = 0; int main() { 	// Step #1. Input 	cin >> N; 	for (int i = 1; i <= N; i++) cin >> A[i]; 	 	// Step #2. Compute A[1] xor A[2] xor ... xor A[N] 	for (int i = 1; i <= N; i++) v ^= A[i]; 	// Step #3. Branching and output 	if (N % 2 == 1) { 		cout << "Win" << endl; 	} 	else { 		bool winning = false; 		for (int i = 1; i <= N; i++) { 			if (A[i] == v) winning = true; 		} 		if (winning == true) cout << "Win" << endl; 		else cout << "Lose" << endl; 	} 	return 0; } #include <iostream> using namespace std; int N, A[400009]; int v = 0; int main() { 	// Step #1. Input 	cin >> N; 	for (int i = 1; i <= N; i++) cin >> A[i]; 	 	// Step #2. Compute A[1] xor A[2] xor ... xor A[N] 	for (int i = 1; i <= N; i++) v ^= A[i]; 	// Step #3. Branching and output 	if (N % 2 == 1) { 		cout << "Win" << endl; 	} 	else { 		bool winning = false; 		for (int i = 1; i <= N; i++) { 			if (A[i] == v) winning = true; 		} 		if (winning == true) cout << "Win" << endl; 		else cout << "Lose" << endl; 	} 	return 0; } 1.2. Why ☆ and ★ are equivalent It follows from a XOR x XOR x=a, where a is the XOR of the cookies other than the i-th one, and x is the i-th cookie. The figure below illustrates this relationship. ※ The properties of XOR make a XOR x XOR x=a hold for general non-negative integers a and x, too. 2. Proof The validity of the intended solution can be proved as follows. Step 1: Does the game end in two moves? We can prove that the game never ends in exactly two moves when N is odd, from the reason below. Here, the game is said to end in two moves when, following the first move by the first player, the second player plays a move that makes the XOR 0 and wins. For the game to end in two moves, it is necessary that the following condition holds. For every i (1≤i≤N), there is a way for the second player to make the XOR 0 after the first player takes the i-th cookie. (◆) Assume that ◆ holds, and the XOR of the remaining cookies becomes 0 when the first player takes the i-th cookie and then the second player takes the P i ​ -th cookie (i  =P i ​ ). Then, from the properties of XOR, the XOR of the remaining cookies will also become 0 when the first player takes the P i ​ -th cookie and the second takes the i-th. This holds for all i (1≤i≤N), so there should be N/2 pairs of form (i,P i ​ ). However, since N is odd, at least one cookie must be left over (see the figure below). Therefore, ◆ does not hold, and the game never ends in two moves. Step 2: When N is odd To begin with, consider the case N=7. From the property seen in Step 1, we can prove that the first player always wins. When there are 7 cookies, the first player can win with the next move, or (s)he will get another turn with 5 cookies remaining. When there are 5 cookies, the first player can win with the next move, or (s)he will get another turn with 3 cookies remaining. When there are 3 cookies, the first player can win with the next move, or (s)he will get another turn with 1 cookie remaining. When there is 1 cookie, the first player can win with the next move. Therefore, the first player always wins. The case with a general odd N can be proved similarly: after repeatedly applying the property, there will be eventually one cookie, where the first player wins. Step 3: When N is even In this case, if the first player cannot end the game with the first move, the second player will be in the same situation as the one in Step 2. Thus, unless the first player can win in the first turn, the second player wins. 3. Hints for coming up with the solution It is pretty hard to derive the solution above and prove it. However, in these contests, you can get the score by getting AC, even without proving it. It may be helpful to do some experiments in some test cases to find some clues. Experiments in large cases with N=4 or larger take long if done by hand, so it is advisable to write codes that solve the problem naively or generate test cases. Below is a C++ program that solves the problem with brute-force. Copy #include <iostream> #include <vector> using namespace std; // returns true if the first player wins with the cookies vec[0], vec[1], ..., vec[vec.size()-1] bool solve(vector<int> vec) { 	// if XOR is 0, the second player wins 	int All_XOR = 0; 	for (int i = 0; i < vec.size(); i++) { 		All_XOR ^= vec[i]; 	} 	if (All_XOR == 0) { 		return false; 	} 	// otherwise... 	for (int i = 0; i < vec.size(); i++) { 		// take the i-th cookie 		vector<int> nex; 		for (int j = 0; j < vec.size(); j++) { 			if (j != i) nex.push_back(vec[j]); 		} 		bool ret = solve(nex); 		if (ret == false) return true; // first player wins 	} 	return false; // second player wins } int main() { 	// input 	int N; cin >> N; 	vector<int> A(N, 0); 	for (int i = 0; i < N; i++) cin >> A[i]; 	// output 	bool Answer = solve(A); 	if (Answer == true) cout << "Win" << endl; 	else cout << "Lose" << endl; 	return 0; } D - AtArcher Editorial by evima The closer to the center, the higher the score is. This property of the target is the key to the problem. Table of contents The solution to this problem has four steps. Step 1: The pattern of the optimal solution Step 2: Reduce it to a brute-force problem Step 3: Make it faster (1) Step 4: Make it faster (2) Then, we summarize the solution in Section 5 and show sample implementations (C++ and Python) in Section 6. If you are in a hurry, go to Section 5. Step 1: The pattern of the optimal solution The target gives higher scores to arrows that are closer to the center. Let us consider the way arrows are shot in the optimal solution. The first thing to note is that the arrows should be “centered” for a higher score. In the figure above (with D=3), the score is improved by centering the arrows. Since the score for each arrow never decreases by this, the total score never decreases, either. After centering the arrows as much as possible, the arrows will be evenly spaced, with coordinates x,x+D,x+2D,…,x+(N−1)D. In the above figure, x=−5. Now, let us try to brute-force this pattern of the optimal solution, in the following sections. Step 2. Reduce it to a brute-force problem First, by centering the arrows, it is always possible to make −(N−1)D≤x≤0 hold, because: if x<−(N−1)D, the arrows can be further centered by moving them to the right; if x>0, the arrows can be further centered by moving them to the left. Also, we can limit x to be an integer, because if x is not an integer, changing it to the closest integer does not change the score. Thus, if we try the (N−1)D+1 ways to shoot the arrows, x=−(N−1)D,−(N−1)D+1,−(N−1)D+2,…,−1,0, the highest score obtained is the answer. Finding the total score for one x would take O(NM) time if implemented naively, so let us try to find the number of arrows in each segment using divisions. It can be calculated that the number of arrows in the segment [L,R) is: max(min(⌈ D R−x ​ ⌉,N),0)−max(min(⌈ D L−x ​ ⌉,N),0) because: the number of arrows with coordinates less than L is max(min(⌈ D L−x ​ ⌉,N),0), the number of arrows with coordinates less than R is max(min(⌈ D R−x ​ ⌉,N),0). We have to do this for 2M−1 segments, so the computation for each x now takes O(M) time. Thus, we can solve the problem in a total of O(NMD) time, but under the constraints N≤10 5 ,M≤10 5 ,D≤10 6 , it is too slow. Step 3: Make it faster (1) Above, we brute-forced the cases x=−(N−1)D,−(N−1)D+1,−(N−1)D+2,…,−1,0, but we can narrow the range. Look at the figure below. Although the arrows are centered, it intuitively looks suboptimal. Why is it? Because we can move the leftmost arrow at coordinate −11 to the right end to increase the score. Here, the distance of that arrow from the center decreases from 11 to 4, and the other arrows do not move. When can we move the leftmost arrow to the right end or move the rightmost arrow to the left end to make it closer to the center? Moving the leftmost arrow to the right end Consider moving an arrow at coordinate x to x+ND. It will get closer to the center when −x>x+ND, that is, x<− 2 ND ​ . Moving the rightmost arrow to the left end Consider moving an arrow at coordinate x+(N−1)D to x−D. It will get closer to the center when x+(N−1)D>−(x−D), that is, x> 2 ND ​ +D. Thus, the arrows cannot be further centered when − 2 ND ​ ≤x≤− 2 ND ​ +D. We can state that this range always contains the optimal solution. That is, if we brute-force the D ways to shoot the arrows x=A,A+1,A+2,…,A+(D−1), where A=−⌊ 2 ND ​ ⌋, the highest score obtained is the answer. ( x=A+D is also in the range, but that case is symmetric to the case x=A, with the same score.) In the figure below, we now have to compute the score for just D=3 values of x, compared to (N−1)D+1=13 above. The total complexity has been reduced to O(MD), but still too slow under the constraints M≤10 5 ,D≤10 6 . Step 4: Make it faster (2) How to do it faster? Unfortunately, we cannot further narrow the range of search. It is desired to compute the total scores for x=A,A+1,A+2,…,A+(D−1) “at once”. Previously, the computation was done as follows. Compute the total score for x=A, that is, the sum of {min(⌈ D R i ​ −x ​ ⌉,N)−max(⌈ D L i ​ −x ​ ⌉,0)}×S i ′ ​ for x=A. Compute the total score for x=A+1, that is, the sum of {min(⌈ D R i ​ −x ​ ⌉,N)−max(⌈ D L i ​ −x ​ ⌉,0)}×S i ′ ​ for x=A+1. ⋮ Compute the total score for x=A+(D−1), that is, the sum of {min(⌈ D R i ​ −x ​ ⌉,N)−max(⌈ D L i ​ −x ​ ⌉,0)}×S i ′ ​ for x=A+(D−1). Here, L i ​ ,R i ​ ,S i ′ ​ represent the i-th segment from the left with the range [L i ​ ,R i ​ ) and the score S i ′ ​ (see the latter half of Step 2). Specifically, the positive score area of the target can be divided into 2M−1 segments, as follows. L=(−x M ​ ,−x M−1 ​ ,…,−x 2 ​ ,−x 1 ​ ,x 1 ​ +1,…,x M−2 ​ +1,x M−1 ​ +1) R=(−x M−1 ​ ,−x M−2 ​ ,…,−x 1 ​ ,x 1 ​ +1,x 2 ​ +1,…,x M−1 ​ +1,x M ​ +1) S ′ =(s M−1 ​ ,s M−2 ​ ,…,s 1 ​ ,s 0 ​ ,s 1 ​ ,…,s M−2 ​ ,s M−1 ​ ) Let us try to do this computation from another direction, as follows. First, initialize the total scores v 0 ​ ,v 1 ​ ,…,v D−1 ​ for x=A,A+1,…,A D−1 ​ to 0s. Add the contributions of Segment 1 to the total scores. That is, for k=0,1,2,…,D−1, add {max(min(⌈ D R 1 ​ −(A+k) ​ ⌉,N),0)−max(min(⌈ D L 1 ​ −(A+k) ​ ⌉,N),0)}×S 1 ′ ​ to v k ​ . Add the contributions of Segment 2 to the total scores. That is, for k=0,1,2,…,D−1, add {max(min(⌈ D R 2 ​ −(A+k) ​ ⌉,N),0)−max(min(⌈ D L 2 ​ −(A+k) ​ ⌉,N),0)}×S 2 ′ ​ to v k ​ . ⋮ Add the contributions of Segment 2M−1 to the total scores. That is, for k=0,1,2,…,D−1, add {max(min(⌈ D R 2M−1 ​ −(A+k) ​ ⌉,N),0)−max(min(⌈ D L 2M−1 ​ −(A+k) ​ ⌉,N),0)}×S 2M−1 ′ ​ to v k ​ . The values to add, which may look complicated, represent the number of arrows in Segment i (see the latter half of Step 2). This number changes at most twice: when the value ⌊ D L i ​ −(A+k) ​ ⌋ changes, or the value ⌊ D R i ​ −(A+k) ​ ⌋ changes. Thus, the values to be added in each step, v 0 ​ ,v 1 ​ ,v 2 ​ ,…,v D−1 ​ , look as a,a,…,a,b,b,…,b,c,c…,c: we just add the same value to at most three segments. Adding the same value to a segment can be done fast by utilizing prefix sums, which allows us to find the final values of v 0 ​ ,v 1 ​ ,…,v D−1 ​ in O(M+D). The answer is the largest among them. 5. Summary The problem can be solved in the following steps. Restrict the arrows to be at x,x+D,x+2D,…,x+(N−1)D for some x, after which the optimal solution can still be obtained. Further limit the options to the D cases x=A,A+1,A+2,…,A+(D−1) where A=−⌊ 2 ND ​ ⌋, after which the optimal solution can still be obtained. The positive score area of the target can be divided into 2M−1 segments. For each of them, add its contributions to the total scores for the cases x=A,A+1,A+2,…,A+(D−1) all at once, utilizing prefix sums, to compute the scores for all cases in O(M+D) time. The answer is the largest value computed in 3. E - Christmas Wreath Editorial by evima There was just one sample input with N=4, for which the answer is No, so you might have doubted the existence of a valid decoration. However, there is one if N is 6 or greater and Nmod3 is 0 or 1. Table of contents The solution to the problem has two steps. In Step 1, we find a pattern of the decoration that is guaranteed to satisfy Condition 2 (there is no triangle with three differently colored ropes). In Step 2, from the decorations in the pattern above, we find one that also satisfies Condition 1 (there are equal numbers of red, blue, and white ropes). These steps are explained in Sections 1 and 2. Especially, we have three solutions for Step 2. The subsequent sections are: Section 3: Summary Section 4: Sample Implementations (C++ and Python) Section 5: Bonus If you are in a hurry, go to Section 3. Step 1. Fixing the pattern We need to make a decoration that satisfies the two conditions: Condition 1: there are equal numbers of red, blue, and white ropes, Condition 2: there is no triangle with three differently colored ropes. Condition 2 particularly looks complicated, but undergoing the following procedure guarantees that this condition is satisfied. Let ⟨a,b⟩ denote the rope connecting Balls a and b. Phase 1: Choose some color and light up ⟨1,2⟩ in that color. Phase 2: Choose some color and light up all of ⟨1,3⟩,⟨2,3⟩ in that color. Phase 3: Choose some color and light up all of ⟨1,4⟩,⟨2,4⟩,⟨3,4⟩ in that color. ⋮ Phase N−1: Choose some color and light up all of ⟨1,N⟩,⟨2,N⟩,⟨3,N⟩,…,⟨N−1,N⟩ in that color. For example, when N=5, choosing red, red, white, blue in this order makes the decoration below. As you can see, there is no triangle with three different ropes. Why does this procedure guarantee that Condition 2 is satisfied? Because: Let a,b,c (1≤a<b<c≤N) be the balls that are the vertices of a triangle. Because ⟨a,c⟩ and ⟨b,c⟩ are lighted in the same phase c−1, they have the same color. Therefore, the colors of the three ropes are never all different. Of course, there can be other ways to make a decoration that satisfies both conditions. However, even if we limit ourselves to using this pattern, we can make a valid decoration for all N where the answer is Yes (more specifically, all N at least 6 such that Nmod3 is 0 or 1; see Section 2-3 for proof). Step 2. Find one with equal numbers of red, blue, white ropes The procedure described in Step 1 guarantees that the decoration satisfies Condition 2. The other condition is: Condition 1: There are equal numbers of red, blue, and white ropes. Can we decide the color in Phase 1,2,…,N−1 to satisfy this? For example, in the previous example with N=5, after choosing red, red, white, blue in this order, we have: 1+2=3 red ropes (because red is chosen in Phases 1,2), 4 blue ropes (because blue is chosen in Phases 4), 3 white ropes (because white is chosen in Phases 3). As seen here, the number of ropes in each color is equal to the sum of the “phase numbers” where that color is chosen. Thus, Condition 1 is satisfied when 1,2,3,…,N−1 are divided into three groups so that the sums are equal. Here are some examples. When N=6: we can divide 1,2,3,4,5 into the groups {1,4},{2,3},{5}, where all sums are 5. When N=9: we can divide 1,2,3,4,5,6,7,8 into the groups {1,2,3,6},{4,8},{5,7}, where all sums are 12. For instance, in the case N=6, we can choose red in Phases 1,4, blue in Phases 2,3, white in Phase 5 to satisfy both conditions. Now, how do we divide 1,2,3,…,N−1 into three groups with equal sums? We will describe three methods: Randomized algorithm Dynamic Programming (DP) Mathematical construction 2-1. Randomized algorithm There may not be many participants who did it this way, but the following algorithm can easily find a solution. 1. Using RNG, randomly assign each of 1,2,3,…,N−1 to one of the three groups. 2. If the sums of the numbers in the three groups are all equal, we have found a solution. Otherwise, start over. 3. If no solution is found for some duration of time, assume that the answer is No. Some may suspect that such a miracle of having three equal sums in Phase 2 is rare, but it is fast enough for the values of N not greater than 50 where the answer is Yes. 2-2. Dynamic Programming (DP) We can use DP to determine if there is a division with three equal sums. To satisfy the conditions: The sum of the numbers in Group 1 must be 6 N(N−1) ​ . The sum of the numbers in Group 2 must be 6 N(N−1) ​ . (Then, the sum of the numbers in Group 3 will automatically be 6 N(N−1) ​ .) Now, let us compute the following values with DP, in ascending order of (i,sum1,sum2). dp[i][sum1][sum2]: whether it is possible to make the sum of the numbers in Group 1 sum1 and that in Group 2 sum2 (true or false) Eventually, if dp[N−1][ 6 N(N−1) ​ ][ 6 N(N−1) ​ ] is true, there is a desirable division; if it is false, there is no such division. Since there are O(N 5 ) states (i,sum1,sum2), the complexity is O(N 5 ). For your reference, this is the subset sum problem expanded to two dimensions. Copy bool dp[51][393][393]; // assume that p[i][j][k] are all initialized to 0 int A = N * (N - 1) / 6; // not divisible when N = 3k+2, in which case the answer is No dp[0][0][0] = true for (int i = 1; i <= N - 1; ++i) { 	for (int sum1 = 0; sum1 <= A; ++sum1) { 		for (int sum2 = 0; sum2 <= A; ++sum2) { 			if (sum1 >= i && dp[i - 1][sum1 - i][sum2] == true) { 				dp[i][sum1][sum2] = true; // put i in Group 1 			} 			if (sum2 >= i && dp[i - 1][sum1][sum2 - i] == true) { 				dp[i][sum1][sum2] = true; // put i in Group 2 			} 			if (dp[i - 1][sum1][sum2] == true) { 				dp[i][sum1][sum2] = true; // put i in Group 3 			} 		} 	} } bool dp[51][393][393]; // assume that p[i][j][k] are all initialized to 0 int A = N * (N - 1) / 6; // not divisible when N = 3k+2, in which case the answer is No dp[0][0][0] = true for (int i = 1; i <= N - 1; ++i) { 	for (int sum1 = 0; sum1 <= A; ++sum1) { 		for (int sum2 = 0; sum2 <= A; ++sum2) { 			if (sum1 >= i && dp[i - 1][sum1 - i][sum2] == true) { 				dp[i][sum1][sum2] = true; // put i in Group 1 			} 			if (sum2 >= i && dp[i - 1][sum1][sum2 - i] == true) { 				dp[i][sum1][sum2] = true; // put i in Group 2 			} 			if (dp[i - 1][sum1][sum2] == true) { 				dp[i][sum1][sum2] = true; // put i in Group 3 			} 		} 	} } After computing the values in the DP table, we can trace (i,sum1,sum2) backward to find the actual grouping. 2-3. Mathematical construction Without using a randomized algorithm or dynamic programming, we can mathematically form a grouping based on induction. When N=3k+2 ( k is an integer), the sum of 1,2,…,N−1 is not a multiple of 3, so there is no grouping with equal sums. When N=3,4, there is no such grouping, either. Now, we will consider the remaining case. First, let us make one grouping with equal sums for each of N=6,7,9,10. When N=6: Divide 1,2,3,4,5 into {1,4},{2,3},{5}. When N=7: Divide 1,2,3,4,5,6 into {1,6},{2,5},{3,4}. When N=9: Divide 1,2,3,4,5,6,7,8 into {1,2,3,6},{4,8},{5,7}. (Other solutions exist.) When N=10: Divide 1,2,3,4,5,6,7,8,9 into {1,2,3,4,5},{6,9},{7,8}. (Other solutions exist.) Based on them, we can form groupings for N=12,13,15,16,18,19,…, as follows. Let n=N initially, and repeat the following until n<12. Add {n−6,n−1} to Group 1, {n−5,n−2} to Group 2, {n−4,n−3} to Group 3. Then, decrease n by 6. Eventually, n becomes 6, 7, 9, or 10. To each group, add the corresponding numbers in the grouping for N=n (see above). For example, when N=21, we get the grouping {1,2,3,6,9,14,15,20},{4,8,10,13,16,19},{5,7,11,12,17,18}, where the sums are all equal. 3. Summary The problem can be solved as follows. For each i (2≤i≤N), we light up ⟨1,i⟩,⟨2,i⟩,…,⟨i−1,i⟩ in the same color. Then, Condition 2 (there is no triangle with three differently colored ropes) is always satisfied. Now, finding a way to satisfy Condition 1 (there are equal numbers of red, blue, and white ropes) is equivalent to finding a division of 1,2,…,N−1 into three groups with equal sums. To find this grouping, we can use the following three methods. Randomized algorithm Dynamic programming Mathematical construction Here, ⟨a,b⟩ denote the rope connecting Balls a,b. Particularly, in Mathematical construction, * the groupings for N=6,7,9,10 can be found by hand; * the groupings for N≥12 can be found inductively by adding {N−6,N−1},{N−5,N−2},{N−4,N−3} to the grouping when N is 6 smaller. As a result, a desirable decoration exists when N=6,7,9,10,12,13,15,16,18,19,… 4. Sample Implementations (C++ and Python) Below are C++ implementations of the three approaches. Randomized algorithm: https://atcoder.jp/contests/arc131/submissions/27697585 Dynamic progamming: https://atcoder.jp/contests/arc131/submissions/27697706 Mathematical construction https://atcoder.jp/contests/arc131/submissions/27697752 Below are Python implementations of the three approaches. Randomized algorithm: https://atcoder.jp/contests/arc131/submissions/27697896 Dynamic progamming: https://atcoder.jp/contests/arc131/submissions/27698083 Mathematical construction https://atcoder.jp/contests/arc131/submissions/27698092 5. Bonus Actually, we can use hill climbing to solve this problem. Here is a sketch of this technique: Generate a random solution X. Repeat the following: Slightly modify some parts of X randomly. Let X ′ be the result. (For example, choose two values randomly and swap them.) If X ′ is “better” than X, update X to X ′ . After enough iterations, the solution should be improved to some extent. We can apply hill climbing to this problem, too. Hill climbing in this problem We need to make a decoration where the ropes of each triangle have different colors. To handle this, let us define the score of a decoration as the number of triples (a,b,c) such that the colors of ⟨a,b⟩,⟨b,c⟩,⟨c,a⟩ are all different. When the numbers of red, blue, white ropes are equal, and the score is 0, we have a desirable decoration. Now, consider the following algorithm with hill climbing. First, make a random decoration with N(N−1)/6 red, N(N−1)/6 blue, N(N−1)/6 white ropes. Repeat the following enough times. From the N(N−1)/2 ropes, choose two randomly and swap their colors. Compute the score of this new decoration. If it is higher (worse) than it was, redo the swap. When the score is 0, we have found an answer. This simple algorithm can solve the problem without creative observations, such as finding the pattern in Step 1. Sample Implementation (C++): https://atcoder.jp/contests/arc131/submissions/27709349 However, since there are O(N 3 ) triangles, naive computation of the score takes O(N 3 ) time, which might be too slow to perform enough iterations with bad luck. Can we make it faster? Actually, swapping two ropes affects the colors of at most 2N−4 triangles, because swapping ⟨a,b⟩ and ⟨c,d⟩ only affects the triangles whose vertices are (a,b,x) or (c,d,x). Therefore, we can compute the change of the score by checking just these 2N−4 triangles to accelerate each iteration of hill climbing, making the program very fast under the constraint N≤50. Hill Climbing and AtCoder Heuristics Contest (AHC) Starting on March 2021, AtCoder holds AHC. In these contests, unlike the usual ones such as ARC, participants are asked to find as good solutions as possible in a problem where finding the optimal solution is unrealistic. Hill climbing, which can often produce decent solutions despite being simple, is used in many AHCs. Simulated annealing, a probabilistic variant of hill climbing, is often used, too. Hill climbing never updates a solution to a worse one, but simulated annealing also adopts a worse solution probabilistically, according to the degree to which the solution is worsened. In addition to heuristics contests such as AHC, hill climbing and simulated annealing can occasionally be used in algorithm contests such as ARC. F - ARC Stamp Editorial by evima Table of contents Section 1 explains the fundamental viewpoint to deal with the problem: to see it backward. Section 2 derives the key idea to the problem: decomposition of the string T. Section 3 presents the solution to the problem with dynamic programming. Section 4 summarizes the solution, and Section 5 provides a sample implementation (C++). If you are in a hurry, go to Section 4. 1. Introduction: see it backward Consider the following problem. We have a string of S of length N, which is initially S = ***...**. Determine whether it is possible to repeat the operation below to make S equal to a string T (consisting of A, R, C). Operation: Choose three consecutive characters in S and replace them with ARC. (Modification of CPSCO2019 Session3 Problem D - Decode RGB Sequence) Consider the reverse version of the operation: replace ARC with arbitrary three characters. By representing this arbitrary character by ?, the problem becomes the following. We have a string of S of length T. Determine whether it is possible to repeat the operation below to make T the string ???...??. Operation: Choose three consecutive characters in T that are one of the following: ARC, AR?, A?C, ?RC, A??, ?R?, ??C, ???. Then, replace them with ???. Here, doing an operation does not “make a possible operation impossible”. Instead, it just “unlocks” new operations. Thus, if we repeat the operation as many times as possible and get ???...??, the answer is Yes; if A, R, or C remains somewhere, the answer is No. We can use this backward approach also to the original problem, where the setting is quite similar. 2-1. From what kind of string S can we make T? First, let us consider a specific case: from what kind of string S can we make T = ARARCCC in one, two, or three operations? As we did in Section 1, we see the process backward. In one operation The operation just before getting ARARCCC could only be to change the 3-rd, 4-th, 5-th characters to ARC. This could be done if the string was AR???CC (? stands for an arbitrary character which is A, R, or C). In two operations The operation just before getting AR???CC could be one of the three options below. Change the 1-st, 2-nd, 3-rd characters to ARC, which could be done if the string was ?????CC. Change the 3-rd, 4-th, 5-th characters to ARC, which could be done if the string was AR???CC. Change the 4-th, 5-th, 6-th characters to ARC, which could be done if the string was AR????C. Thus, we can make the string T in two operations when S is ?????CC or AR????C. In three operations Similarly to the above, we can make the string T in three operations when S is ??????C or AR?????. The figure below describes this process, where blue segments represent the positions changed to ARC. Intuitively speaking, we make the string S by “dominating” the string T with ?, starting at positions with ARC. Here are some examples. We need three operations to make ARARCCC from AR?????, because it takes three steps to dominate: ARARCCC → AR???CC → AR????C → AR?????. We need four operations to make AARCRARC from ????????, because it takes four steps to dominate: AARCRARC → A???RARC → A???R??? → ????R??? → ????????. 2-2. How to dominate it with “?”? Here is what we write above: ‘Intuitively speaking, we make the string S by “dominating” the string T with ?, starting at positions with ARC.’ Let us sort out this mechanism of domination. There is only one way to create domination from nothing: ARC → ???. There are two ways to expand a dominated part to the left: A??...?? → ???...?? (dominate the A to the left) AR??...?? → ????...??(dominate the AR to the left) There are two ways to expand a dominated part to the right: A??...?? → ???...?? (dominate the C to the right) AR??...?? → ????...??(dominate the RC to the right) It is also possible to connect two dominated parts: ??...??R??...?? → ??...?????...?? (dominate the C in the middle) The reason why we have six ways to expand domination is that while there are eight patterns ARC, AR?, A?C, ?RC, A??, ?R?, ??C, ??? that can be changed to ???, ??? → ??? is a meaningless change, and A?C never appears in the string. 2-3. Decomposition of T Let us revisit the case T = ARARCCC again. There are many orders we can dominate T with ?, such as: ARARCCC → AR???CC → ?????CC → ??????C → ??????? ARARCCC → AR???CC → AR????C → AR????? → ??????? However, in one step, only the fixed segments on T ― between [ and ] in [AR][ARC][C][C] ― can be dominated. The cases above can be seen as: [AR][ARC][C][C] → [AR][???][C][C] → [??][???][C][C] → [??][???][?][C] → [??][???][?][?] [AR][ARC][C][C] → [AR][???][C][C] → [AR][???][?][C] → [AR][???][?][?] → [??][???][?][?] Let us see some other examples. T = ARCRCCRARC: can be decomposed into [ARC][RC][C][R][ARC]. T = RARCCRRARC: can be decomposed into [R][ARC][C][RR][ARC]. (Since the leftmost R and the middle RR cannot be dominated, let us represent it as [X][ARC][C][X][ARC].) T = AARARCRARRAC: can be decomposed into [A][AR][ARC][RARRAC] = [A][AR][ARC][X]. T = ARCARCARC: can be decomposed into [ARC][ARC][ARC]. (However, since the dominations of [ARC]s do not interfere with each other, let us put [X]s in between to represent it as [ARC][X][ARC][X][ARC] for easier implementation.) T = CARCCAARCA: can be decomposed into [C][ARC][C][A][ARC][A] = [X][ARC][C][X][A][ARC][X]. Actually, for a general string T, there is a unique decomposition representing segments that can be dominated in one step. This decomposition can be found in O(∣T∣) time as the process of dominating the T as much as possible. Then, we can simplify the domination in a step to the following. Dominate [ARC]. Dominate [A] or [AR] to the left of a dominated part. Dominate [C] or [RC] to the right of a dominated part. Dominate [R] between dominated parts. [X] cannot be dominated. Therefore, the following important property holds, where a clause is [ARC], [A], [AR], [C], [RC] or [X] in the decomposition. Property: the number of minimum operations needed to perform the domination equals the number of clauses to dominate. Thus, counting the strings S that can be made in K or fewer operations can be done by counting the strings that can be made by dominating K or fewer clauses. This idea leads to the solution with dynamic programming stated in Section 3. 3. Solution with dynamic programming (DP) Based on the idea of decomposing the string T we obtained in Step 2, let us design a solution to the problem with DP. Let v 1 ​ ,v 2 ​ ,…,v M ​ be the decomposition of T from left to right, where M is the number of clauses. Here, each v i ​ is [ARC], [A], [AR], [C], [RC], or [X]. Now, consider deciding, for each clause, whether to dominate it with ? and what the original string (in S) will be if we dominate it, one by one from left to right. Then, we need the following three values (pos,conq,flag) as the state of the DP. pos: the clause up to which we have processed (representing that v 1 ​ ,v 2 ​ ,…,v pos ​ are already processed) conq: the number of clauses already dominated flag: a boolean value representing whether both Clauses pos and pos+1 are to be dominated ( 1 if dominating both, 0 if not dominating either) The setting of the third variable flag depends on implementation. In this editorial, we record whether we dominate both v pos ​ and v pos+1 ​ to simply the implementation. Then, when choosing the “original string” in the clause v pos+1 ​ from the state (pos,conq,flag), the transition happens as follows. (A bit complicated, but you will see it if you sort it out.) When v pos+1 ​ = [ARC] (pos,conq,0) → (pos+1,conq,0): 1 way (do not dominate) (pos,conq,0) → (pos+1,conq+1,1): 27 ways (dominate from v pos+1 ​ ; the original three characters can be freely chosen) (pos,conq,1) → (pos+1,conq+1,0): 27 ways (dominate up to v pos+1 ​ ; the original three characters can be freely chosen) (pos,conq,1) → (pos+1,conq+1,1): 27 ways (dominate v pos+1 ​ ; the original three characters can be freely chosen) (pos,conq,0) → (pos+1,conq+1,0): 26 ways (dominate just v pos+1 ​ , do not dominate the clauses around it; the original three characters can be anything other than ARC) When v pos+1 ​ = [A] (pos,conq,0) → (pos+1,conq,0): 1 way (do not dominate) (pos,conq,0) → (pos+1,conq+1,1): 2 ways (dominate from this clause; this operation will not be in vain if A is changed to R or C) (pos,conq,1) → (pos+1,conq+1,1): 3 ways (dominate this clause; the original character can be freely chosen) When v pos+1 ​ = [AR] (pos,conq,0) → (pos+1,conq,0): 1 way (do not dominate) (pos,conq,0) → (pos+1,conq+1,1): 8 ways (dominate from this clause; this operation will not be in vain if AR is changed to something else) (pos,conq,1) → (pos+1,conq+1,1): 9 ways (dominate this clause; the original two characters can be freely chosen) When v pos+1 ​ = [C] (pos,conq,0) → (pos+1,conq,0): 1 way (do not dominate) (pos,conq,1) → (pos+1,conq+1,0): 2 ways (dominate up to this clause; this operation will not be in vain if C is changed to A or R) (pos,conq,1) → (pos+1,conq+1,1): 3 ways (dominate this clause; the original character can be freely chosen) When v pos+1 ​ = [RC] (pos,conq,0) → (pos+1,conq,0): 1 way (do not dominate) (pos,conq,1) → (pos+1,conq+1,0): 8 ways (dominate from this clause; this operation will not be in vain if RC is changed to something else) (pos,conq,1) → (pos+1,conq+1,1): 9 ways (dominate this clause; the original two characters can be freely chosen) When v pos+1 ​ = [R] (pos,conq,0) → (pos+1,conq,0): 1 way (do not dominate) (pos,conq,1) → (pos+1,conq+1,1): 2 ways (dominate this clause; this operation will not be in vain if R is changed to A or C) When v pos+1 ​ = [X] (pos,conq,0) → (pos+1,conq,0): 1 way (do not dominate; there is no other choice) We store in dp[pos][conq][flag] the number of strings S (prefixes of length ∣v 1 ​ ∣+∣v 2 ​ ∣+⋯+∣v pos ​ ∣, to be exact) that lead to the state (pos,conq,flag). As the initial state, we set dp[0][0][0]=1, and follow the transitions above to sequencially find dp[pos][conq][flag]. In the end, dp[M][conq][0] represents the number of strings S such that the minimum number of operations needed is conq. (The transitions do not allow futile operations, and each possible string is counted exactly once.) Thus, the answer is dp[M][0][0]+dp[M][1][0]+⋯+dp[M][K][0]. Since the number of states is O(MK), the total complexity of the solution is O(MK). 4. Summary In short, we can solve the problem as follows. See the operations backward and rephrase the problem into counting the strings S that can be obtained from the string T in K or fewer operations. For example, when T = ARARCCC, there are 27 strings that can be obtained in one operation (AR???CC), and 297 strings that can be obtained in two operations (AR????C or AR????C). As seen here, we see each operation as expanding the region “dominated” by ?. Let us call a string of the form [A or AR]...[A or AR][ARC][C or RC]...[C or RC] a subsection. Then, T can be uniquely decomposed in the form [unchangable part][subsection][R or unchangable part][subsection][R or unchangable part]...[subsection][unchangable part]. Let us call a part between [ and ] a clause. For example, T = ARARCCC can be decomposed into the clauses [AR][ARC][C][C]. Then, one operation corresponds to dominating one clause. That is, the minimum number of operations equals the number of clauses that must be dominated. After decomposing T into clauses, we sequentially find dp[pos][conq][flag]: the number of possible strings S when the first pos clauses have been processed, conq clauses are dominated so far, and the boolean value representing whether both Clauses pos and pos+1 are to be dominated is flag. This DP takes O(∣T∣⋅K) time. Therefore, the problem can be solved in the total complexity O(∣T∣⋅K), or O(∣T∣⋅min(∣T∣,K)) because when K≥∣T∣, we can regard it as K=∣T∣ without changing the result. A - Remove One Character Editorial by evima In this editorial, let S(k) denote the k-th character of S. ◆ Rephrasing the condition S i ​ =S j ​ First, let us figure out when S i ​ =S j ​ holds for 1≤i<j≤N. The equation S i ​ =S j ​ holds if and only if S i ​ (k)=S j ​ (k) holds for every k. Let us examine where the k-th characters of S i ​ ,S j ​ are located in S. If 1≤k<i: we have S i ​ (k)=S(k), S j ​ (k)=S(k). If i≤k<j: we have S i ​ (k)=S(k+1), S j ​ (k)=S(k). If j≤k<N: we have S i ​ (k)=S(k+1), S j ​ (k)=S(k+1). Thus, it can be seen that S i ​ =S j ​ ⟺S(i)=S(i+1)=⋯=S(j). ◆ Counting Let us count the pairs (i,j) for each j separately. We want to compute the following for each j: find the number n j ​ of indices i<j such that S(i)=⋯=S(j). First, if S(j−1)  =S(j), we have n j ​ =0. If S(j−1)=S(j), the condition can be rephrased into “ i=j−1, or i<j−1 and S(i)=⋯=S(j−1)”, so we have n j ​ =n j−1 ​ +1. Thus, by computing n j ​ in the order j=1,2,…, each n j ​ can be computed in O(1) time. Therefore, the problem can be solved in O(N) time. B - Colorful Lines Editorial by evima ◆ The contribution of each operation to the answer By decomposing the answer into the contributions of the operations, we can see that computing the following for each i is the way to go: how many of the squares painted in the i-th query are not repainted until the end? A square is not repainted if and only if neither the row nor column that contain the square becomes the target of an operation. Thus, if we can find the sets of rows and columns that appear in operations after the i-th one, we can easily see which squares are not repainted, enabling us to answer the question above. ◆ Solution After all, the following information for each i enables us to find the answer. The set of rows that appear in operations after the i-th one The set of columns that appear in operations after the i-th one Since the information of operations are accumulated backward, computing in the order i=Q,Q−1,…,2,1 enables us to perform the computation for all i efficiently. Almost the same as above, but another understanding is that the final colors of the squares can be obtained as follows: For each i=Q,Q−1,…,2,1 in this order: paint the unpainted squares in the specified row or column. ..... 22222 22222 22222 22222 22222 ..... ..... ...2. .4.2. .4.2. .4.2. ..... ..... ...2. .4.2. 34323 34323 ..... ..... ...2. .4.2. .4.2. .4.2. C - Digit Sum Minimization Editorial by evima Let S(n) denote the sum of the digits of a positive integer n. ◆ The sum of the digits and carries When adding two integers a,b, we have S(a+b)=S(a)+S(b) if there is no carry. Since a carry trades 10 in a position for 1 in the position to the left, this operation reduces the sum of the digits by 9. Thus, if there are k carries, we have S(a+b)=S(a)+S(b)−9k. The objective of this problem can be rephrased into maximizing the number of carries. ◆ The structure of optimal solutions We can see the following for optimal solutions: if there is an optimal solution with at least one carry, there is such a solution that has a carry in the ones digit. Actually, if there is an optimal solution without this property, we can see that it would still be optimal after cycling it so that the first carry happens in the ones digit. Similarly, we can show the following: if there is an optimal solution with at least k carries, there is such a solution that has carries in the 1’s, 10 1 ’s, …, 10 k−1 ’s digit. This can be proved similarly to the above by cycling the part that violates the property. Eventually, solving the following will solve the problem. Find a permutation (a 0 ​ ,a 1 ​ ,…) of the digits of a and a permutation (b 0 ​ ,b 1 ​ ,…) of the digits of b that makes the following hold for as large K as possible. a 0 ​ +b 0 ​ ≥10 a i ​ +b i ​ ≥9 （ 1≤i<K） Here, we assume that a i ​ =0 or b i ​ =0 if i is greater than or equal to the number of digits in a or b. ◆ Solution Since there are just at most 9 possible values for a 0 ​ , it is enough to solve it when a 0 ​ is fixed. After fixing a 0 ​ , the following greedy algorithm can construct an optimal solution. Choose b 0 ​ such that a 0 ​ +b 0 ​ ≥10 as the minimum possible value. Choose the pairs (a 1 ​ ,b 1 ​ ),(a 2 ​ ,b 2 ​ ),… in order. When choosing b i ​ , choose the minimum among the candidates that have a i ​ +b i ​ ≥9. D - Zigzag Tree Editorial by evima Let us choose the root arbitrarily so that the graph is rooted. Assigning a permutation to the vertices can be rephrased into setting a total order on the vertices. The condition in question holds if and only if one of the following holds for any vertex v (the inequality is regarding the total order): v>w for any w adjacent to v, v<w for any w adjacent to v. Let us say a v with the former property big, and a v with the latter property small. ◆ Tree DP For a rooted subtree with n vertices rooted at v, let us call the following value dp v ​ [i]. The number of ways to set a total order on the vertices in the rooted tree v such that the root v is small and the value assigned to the root is the i-th smallest value. We can solve the problem by a tree DP that computes this from bottom to top. In this DP, we first need to merge the information from subtrees to compute the information for subforests in order. For a forest with n vertices, we compute the following for each i. The number of ways to set a total order on the vertices in the forest such that all roots are small and the maximum value assigned to the root is the i-th smallest value. ◆ Merging the DP table We can see that computing the following is the key to the problem. We have a set A with n elements and a set B with m elements. dp A ​ [i] is given, which is the number of total orders on A where the root is the i-th smallest and a certain requirement is satisfied. dp B ​ [i] is given similarly. Compute dp[i], the number of total orders on A⨿B where the restrictions on A and B satisfy the requirement and the larger of the roots of A and B is the i-th smallest. We will divide the computation into two, based on which of the roots is larger. Let us fix the order a 1 ​ <a 2 ​ <⋯<a n ​ on A and the order b 1 ​ <b 2 ​ <⋯<b m ​ on B. When the root of A is A i ​ , the number of ways to extend the orders so that a i ​ is the (A⨿B)-th smallest in A⨿B can be computed as the product of the following: setting the order between a 1 ​ ,…,a i−1 ​ , b 1 ​ ,…,b j ​ : ( i−1 i−1+j ​ ) ways setting the order between a i+1 ​ ,…,a n ​ , b j+1 ​ ,…,b m ​ : ( n−i n−i+m−j ​ ) ways Additionally, a i ​ is larger than the root of B when the root of B is one of b 1 ​ ,…,b j ​ . Thus, to dp[i+j], we will add ( i−1 i−1+j ​ )( n−i n−i+m−j ​ )dp A ​ [i](dp B ​ [1]+⋯+dp B ​ [j]). After pre-calculation of prefix sums, this can be done in O(nm) time in total. ◆ Complexity Analysis In a tree DP, if merging the information of subforests of sizes n and m takes O(nm) time, the information of the whole rooted tree with N vertices can be computed in O(N 2 ) time. The analysis of this complexity can be found, for example, on: ABC207 - F Editorial (https://atcoder.jp/contests/abc207/editorial/2155). This analysis or tree DPs that involve it is often called “squared tree DP” in the Japanese kyo-pro community. E - Increasing Minimum Editorial by evima For each 1≤i≤N, let t(i) denote the largest t such that i t ​ =i. If there is no such t, let t(i)=−1. By reindexing the sequence, we assume t(1)≤t(2)≤⋯≤t(N) below. Particularly, the last operation adds 1 to A N ​ . ◆ Narrowing down the candidates (1) For an optimal solution, the following holds. minA=1 before the operations. A N ​ −1≤A 1 ​ ≤A 2 ​ ≤⋯≤A N ​ after the operations. The first property can be seen from the following fact: when I can be obtained from a sequence A such that minA≥2, it can also be obtained after adding −1 to all A i ​ . Let us verify the second property. First, for A i ​ that becomes the target of an operation at least once, it can be inductively seen that t(i)<t(j)⟹A j ​ −1≤A i ​ ≤A j ​ at the end of the process. For A i ​ that never becomes the target of an operation, we can assume that A i ​ =A N ​ −1 at the end of the process. Actually, since the last operation is done on A N ​ , it is necessary that A_i\geq A_N-1 .Ontheotherhand,ifweletA_i = A_N-1 ,thesameI canbeobtainedwithoutA_i beingtargettedbyanoperation.Thus,fori suchthatt(i) = -1 ,wecanassumeA_i = A_N-1$. In the sequence of inequalities A N ​ −1≤A 1 ​ ≤A 2 ​ ≤⋯≤A N ​ , the difference between the leftmost and rightmost sides is 1. Thus, among those ≤’s, exactly one is < and the other N−1 are =. This, in addition to the first property, narrows down the candidates for the optimal solution to N. ◆ Narrowing down the solutions (2) Let us examine which of the above N candidates are consistent with the sequence I. From the inequality A N ​ −1≤A 1 ​ ≤A 2 ​ ≤⋯≤A N ​ that holds at the end of the process, we can determine one of the A j ​ ’s that takes the minimum value at each stage of the process. Actually, that is the smallest j with the greatest difference between the current and last values of A j ​ . If the k-th operation targets A i k ​ ​ , and one of the smallest values just before the k-th operation is A j k ​ ​ , the condition for this operation to be consistent with the specifications in the statement is A i k ​ ​ =A j k ​ ​ . It is easy to state which of the N candidates are consistent with this condition (using some intervals). After determining which of the N candidates are consistent with the sequence of operations, we just need to print the lexicographically smallest among them, which is easy. From all of the above, the problem can be solved in O(N+K) time. F - Replace by Average Editorial by evima During the process, A i ​ ≤0 never holds. Thus, there exists a minimum possible value of ∑A i ​ after the process. Let us take one sequence with this minimum sum and call it B. Also, in this editorial, let A(x),B(x) denote their x-th terms A x ​ ,B x ​ . For convenience, let A(x)=B(x)=∞ for x<1 or N<x. ◆ The convexity of B From the fact that an operation with (i,j,k)=(x−1,x,x+1) does not reduce ∑ x=1 N ​ B(x), we have 2B(x)≤B(x−1)+B(x+1) for any x. A function B:Z⟶R with this property is called a discrete convex function. ◆ The minimum of B In the process of obtaining B from A, we can assume that no operation is done to increase a term. That is, we have min x∈Z ​ B(x)=min x∈Z ​ A(x). By generalizing this observation, we can show the following: for any p∈Z, min x∈Z ​ (B(x)−px)=min x∈Z ​ (A(x)−px). ◆ Determining B Let a p ​ :=min x∈Z ​ (A(x)−px). From the aformentioned properties: B is convex, that is, 2B(x)≤B(x−1)+B(x+1) min x∈Z ​ (B(x)−px)=a p ​ we can uniquely determine B. Actually, we can prove that: B(x)=max p∈Z ​ (px+a p ​ ). Proof that B(x)≥max p∈Z ​ (px+a p ​ ) It is enough to fix x and show that B(x)≥px+a p ​ for any p∈Z, which is obvious from the property 2. Proof that B(x)≤max p∈Z ​ (px+a p ​ ) It is enough to fix x and give one p such that B(x)≤px+a p ​ . From the convexity of B, there is p∈Z such that B(x)−B(x−1)≤p≤B(x+1)−B(x), for which B(x)−px=min y∈Z ​ (B(y)−py). Since the right side was equal to a p ​ , we have B(x)−px=a p ​ , which verifies the existence of p such that B(x)≤px+a p ​ . Eventually, it has turned out that the optimal solution B is determined as follows. Let a p ​ =min x∈Z ​ (A(x)−px). We have B(x)=max p∈Z ​ (px+a p ​ ). For each p, the x such that a p ​ =A(x)−px lies somewhere along the lower convex envelope of A. By enumerating the points on the lower convex envelope, for each p we can find one x such that a p ​ =A(x)−px. Let us write this x as x p ​ . For x p ​ ≤x≤x p+1 ​ , we have B(x)=max(px+a p ​ ,(p+1)x+a p+1 ​ ). This is because: if q≤p, we have qx p ​ +a q ​ ≤px p ​ +a p ​ , from which qx p ​ +a q ​ ≤px p ​ +a p ​ holds; if q≥p+1, we have qx p+1 ​ +a q ​ ≤qx p+1 ​ +a p+1 ​ , from which qx+a q ​ ≤(p+1)x p+1 ​ +a p+1 ​ holds. This formula allows us to compute B(x) such that x p ​ ≤x≤x p+1 ​ , enabling us to find all B(x). Proper implementation of the above solves the problem in O(N) time. A - Smaller XOR Editorial by evima Let us write x in binary and assume that the most significant bit is at position k ( 2 k ). Let us also write N in binary. If the bit at position k is 0, we have N⊕x>N. On the contrary, if the bit at position k is 1, we have N⊕x<N. Thus, we are done if, for every k such that the bit of N at position k is 1, we find the number of integers x such that L≤x≤R and the most significant bit of x is at position k. Here, we can rephrase the latter condition into 2 k ≤x<2 k+1 , so we just have to count integers x such that max(L,2 k )≤x≤min(R,2 k+1 −1), which is easy. Since there are O(logN) conditions for k, the total complexity is O(logN). B - Range Point Distance Editorial by evima dist(l,r,x) can be rephrased into dist(l,r,x)=max(0,l−x,x−r). Thus, the function to minimize is max(0,L 1 ​ −x,x−R 1 ​ ,L 2 ​ −x,x−R 2 ​ ,⋯,L k ​ −x,x−R k ​ ). Here, if we let A k ​ =max(L 1 ​ ,L 2 ​ ,⋯,L k ​ ) and B k ​ =min(R 1 ​ ,R 2 ​ ,⋯,R k ​ ), the objective function can be rephrased into max(0,A k ​ −x,x−B k ​ ). If A k ​ ≤B k ​ , we can let x=A k ​ to make the answer 0. If B k ​ <A k ​ , the optimal choice is x=floor((A k ​ +B k ​ )/2), which achieves the minimum value ceil((A k ​ −B k ​ )/2). In the end, we need to find A k ​ and B k ​ for every k in order, which can be done in O(N) time in total. C - Multiple of 7 Editorial by evima Let a i ​ be the value of the i-th through ∣s∣-th characters seen as a number. For convenience, let a ∣s∣+1 ​ =0. A pair of integers (l,r) satisfies the condition if and only if (a l ​ −a r+1 ​ )/10 ∣s∣−r is divisible by 7. Here, 10 ∣s∣−r is coprime with 7, so the above is equivalent to a l ​ −a r+1 ​ being divisible by 7. Let b i ​ be the remainder when a i ​ is divided by 7. Additionally, for each 0≤v<7, let c v ​ the number of i’s such that b i ​ =v. There are N pairs of integers (l,r) satisfying the condition if and only if there are N pairs (l,r) such that b l ​ =b r+1 ​ , which can be further rephrased into ∑ 0≤v<7 ​ c v ​ (c v ​ −1)/2=N. Let us first try to find c v ​ ’s that satisfy the above. We can do this greedily. Specifically, we should decide c 0 ​ ,c 1 ​ ,⋯,c 6 ​ in this order, and when choosing c k ​ , we should choose the maximum c k ​ that satisfies ∑ 0≤v≤k ​ c v ​ (c v ​ −1)/2≤N. This greedy strategy finds desirable c v ​ ’s for all N under the Constraints of this problem. (It does not work for a general N, but we can make it work using the Fermat polygonal number theorem.) After finding c v ​ ’s, let us decide b i ​ based on them. When b i+1 ​ is already decided, we can freely choose the value of b i ​ by properly setting the i-th character of s to 1, 2, ⋯, or 7, so the whole construction can be done backward. D - -1+2-1 Editorial by evima Throughout this editorial, assume that 0 and N+1 as indices stand for N and 1, respectively. First, it is clearly necessary that ∑ 1≤i≤N ​ A i ​ =0. Below, we assume this to hold. Let a i ​ be the number of times i is chosen in the operations. The conditions for a i ​ are: a i ​ ≥0 2a i ​ −a i−1 ​ −a i+1 ​ =−A i ​ By letting b i ​ =a i+1 ​ −a i ​ , the second condition can be converted into b i ​ −b i−1 ​ =A i ​ . From this, we can determine the value b i ​ −b 1 ​ for every i. Also, it follows from the definition that ∑ 1≤i≤N ​ b i ​ =0, which we can use to determine the value b 1 ​ . If this value b 1 ​ is not an integer, there is no solution. After finding out the values b i ​ , we can determine the value a i ​ −a 1 ​ for every i. Here, there is a degree of freedom in choosing a 1 ​ , and we should choose the minimum value possible under the condition that a i ​ ≥0 holds for every i. The complexity is O(N) in total. E - Yet Another Minimization Editorial by evima Let us formalize the problem as the minimum cut problem. First, we have a source S and a sink T. For each 1≤i≤N, we have a path of length M: S=V i,0 ​ →V i,1 ​ →⋯→V i,M ​ =T. By spanning an edge V i,k ​ →V i,k−1 ​ with capacity ∞ for each 1≤k≤M, first some of V i,k ​ will side with S in the minimum cut, and the rest will side with T. Let us make it so that cutting between V i,k ​ and V i,k−1 ​ corresponds to choosing A i,k ​ . We can do this by spanning an edge V i,k−1 ​ →V i,k ​ with capacity C i,k ​ to express the cost of choosing A i,k ​ . Next, let us add edges that correspond to the cost ∣x i ​ −x j ​ ∣×W i,j ​ . We can rephrase this cost as follows. For each integer a, the following cost is incurred. W i,j ​ , if x i ​ ≤a and a+1≤x j ​ . W i,j ​ , if x j ​ ≤a and a+1≤x i ​ . The condition “ x i ​ ≤a and a+1≤x j ​ ” can be rephased as “ V i,p ​ sides with T and V j,q ​ sides with S in the cut” using appropriate 0≤p,q≤M. Thus, we can span an edge V j,q ​ →V i,p ​ with capacity W i,j ​ to express the cost corresponds to this condition. By putting together a’s that use the same p,q, there will be O(M) edges to add for each pair (i,j). Now that our graph is ready, we just need to find its minimum cut = the maximum flow. Since the graph has O(NM) vertices and O(N 2 M) edges, Dinic’s algorithm solves the problem in O(N 4 M 3 ) time. F - Let's Play Tag Editorial by evima Let us solve the case s 1 ​ =L, s N+M ​ =R. The other cases can be solved similarly. We will focus only on time when Snuke makes a turn (changes direction). For convenience, let us consider catching the last child as making a turn, too. Let k be the number of turns he makes at negative coordinates. If we first choose the set of children caught when making turns, there is exactly one s that realizes it, so let us consider the game’s duration for all sets of children caught when making turns. Writing the game’s duration as a formula would involve an addition of some value for each turn. More specifically, if the child who starts at coordinate −L i ​ is caught at Snuke’s j-th turn at a negative coordinate, it contributes 4L i ​ ×9 k−j to the duration. Turns at positive coordinates can be represented similarly, so we focus on computing the contribution of negative turns. The leftmost and rightmost children are always used in turns, so we pay attention to the others. Eventually, we have the following problem. For each 1≤k, find the sum below. Choose k−1 from the sequence (L 1 ​ ,L 2 ​ ,⋯,L N−1 ​ ), and again k−1 from (R 1 ​ ,R 2 ​ ,⋯,R M−1 ​ ). For each of the ways to do so, if L i ​ is chosen in the j-th choice, add 4L i ​ ×9 k−j to the answer. First, let us reverse L i ​ so that 4L i ​ ×9 j is added to the answer for the j-th value chosen. Next, rather than choosing k−1 from (R 1 ​ ,R 2 ​ ,⋯,R M−1 ​ ), let us choose M−k from (R 1 ​ ,R 2 ​ ,⋯,R M−1 ​ ) that are not used in turns. If we let k move and take the sum, we are to try all ways to choose M−1 in total from L and R. Eventually, we have the following problem. Choose M−1 from a sequence of length N−1+M−1. For each 1≤i≤N−1, if i is chosen in the j-th choice, a weight of 9 j is added. For each i, find the total weight over all possible choices. Writing this as a formula, we have ∑ j ​ ( j−1 i−1 ​ )×( M−1−j N+M−2−i ​ )×9 j for each i. This formula can be written as the product of a term depending on i, a term depending on j, and a term depending on i−j, so we can use FFT to compute it for all i in O(NlogN) time. The omitted contribution of the leftmost and rightmost children can be computed separately. Therefore, the problem can be solved in O(NlogN) time. A - Gold and Silver Editorial by evima Using some sequence 1≤x 1 ​ <y 1 ​ <x 2 ​ <y 2 ​ <⋯<x k ​ <y k ​ ≤N, the solution can be represented as follows. Exchange gold for silver on Day x 1 ​ and exchange silver for gold on Day y 1 ​ , multiplying the amount of gold by A x 1 ​ ​ /A y 1 ​ ​ . Exchange gold for silver on Day x 2 ​ and exchange silver for gold on Day y 2 ​ , multiplying the amount of gold by A x 2 ​ ​ /A y 2 ​ ​ . ⋮ Exchange gold for silver on Day x k ​ and exchange silver for gold on Day y k ​ , multiplying the amount of gold by A x k ​ ​ /A y k ​ ​ . Incidentally, allowing multiple trades on a single day does not change the final amount of gold. (Making two trades on a day is the same as making no trades.) Thus, “exchanging gold for silver on Day x i ​ and exchanging silver for gold on Day y i ​ , multiplying the amount of gold by A x i ​ ​ /A y i ​ ​ ” is equivalent to: exchanging gold for silver on Day x i ​ and exchanging silver for gold on Day x i ​ +1, multiplying the amount of gold by A x i ​ ​ /A x i ​ +1 ​ , exchanging gold for silver on Day x i ​ +1 and exchanging silver for gold on Day x i ​ +2, multiplying the amount of gold by A x i ​ +1 ​ /A x i ​ +2 ​ , ⋮ exchanging gold for silver on Day y i ​ −1 and exchanging silver for gold on Day y i ​ , multiplying the amount of gold by A y i ​ −1 ​ /A y i ​ ​ . To sum up, deciding when to trade is equivalent to deciding whether to “exchange gold for silver on Day i and exchange silver for gold on Day i+1, multiplying the amount of gold by A i ​ /A i+1 ​ ” for each 1≤i≤N−1. Obviously, it is optimal to do this operation only for those i such that A i ​ >A i+1 ​ . This allows us to write the following code: Copy n=int(input()) a=list(map(int,input().split())) ans=[0]*n for i in range(n-1): 	if a[i]>a[i+1]: 		ans[i]^=1 		ans[i+1]^=1 print(*ans) n=int(input()) a=list(map(int,input().split())) ans=[0]*n for i in range(n-1): 	if a[i]>a[i+1]: 		ans[i]^=1 		ans[i+1]^=1 print(*ans) The complexity is O(N). B - Balls of Three Colors Editorial by evima Let us find the minimum number of operations needed to end up with only red balls. Assume G≥B without loss of generality. Let us focus on the difference between the numbers of green balls and blue balls. No operation changes this value modulo 3. From the fact that this value eventually becomes 0, it is necessary that G≡Bmod3. When G≡Bmod3, we can turn all balls into red balls by the following sequence of operations. Convert a green ball and blue ball into red balls B times. Do the following (G−B)/3 times. Convert a red ball and green ball into blue balls. Convert a green ball and blue ball into red balls. Convert a green ball and blue ball into red balls. Here, there are G operations in total. We can easily see that this is the minimum number needed. We have found the number of operations needed to end up with only red balls, so let us do the same for blue and green balls and print the minimum of the numbers found. The time complexity is O(1) per case. C - Max Dot Editorial by evima Without the restriction by M, the problem can be solved as follows. For each 1≤i≤N, let sum(i) be the sum of the last i terms of A. Also, let m be the i that maximizes sum(i)/i. Then, let the first N−m terms of x be 0, and the last m terms S/m. We can prove the validity of this as follows. Assume that there is an optimal solution x such that x i ​ <x i+1 ​ ( 0≤i≤N−1) for some i other than i=N−m. Here, we assume x 0 ​ =0 for convenience and take i=0 into account. Now, let d=x i+1 ​ −x i ​ . By subtracting d from the last N−i terms of x and then adding d×(N−i)/m to the last m terms of x, we can have less indices i such that x i ​ <x i+1 ​ while maintaining the sum of x and without decreasing the score. Repeating this operation results in the aforementioned form of x where the last m terms are S/m. Let us consider the restriction by M. By an argument similar to the above, we can see the following: if S/m≤M, the optimal solution is to make the last m terms S/m; if S/m>M, it is fine to assume that the last m terms of the optimal sequence are M. For the former case, the score can be easily found. For the latter case, the optimal solution can be found by simply solving the same problem for a smaller sequence with N−m terms. A naive implementation of this procedure leads to an O(N 2 )-time algorithm, which is fast enough. Bonus: the problem can be solved in O(N) by carefully observing the algorithm above. (Hint: convex hull) D - Neq Neq Editorial by evima If A i ​ =A i+1 ​ , Balls i and i+1 will never disappear, so let us split the sequence here and consider the pieces independently. Now, assume A i ​  =A i+1 ​ ( 1≤i≤N−1). Let us determine whether it is possible to keep only Balls 1 and N. First of all, it is always possible when N=2,3. Now, assume N≥4. The objective is obviously unachievable when there are just two different values. On the other hand, we will show that it is always achievable when there are three or more different values. Let us prove it by induction on N. The case N=4 can be validated by hand. Now, let us assume that the statement holds true for N=K and show that it is also true for N=K+1. Since there are three or more different values, there exists 2≤i≤N−1 such that A i−1 ​ ,A i ​ ,A i+1 ​ are all different. If, after removing A i ​ , there are still three or more different values, we are done. Otherwise, A has the form A=(⋯,y,x,y,x,A i ​ ,y,x,y,x⋯), in which case we can remove A i−1 ​ or A i+1 ​ to still have three or more different values. This completes the proof. Let us do DP using these characteristics. When (A i ​ ,A i+1 ​ ⋯,A j ​ ) satisfies the condition above, there should be a transition dp[i]→dp[j]. There are O(N 2 ) transitions, but the distribution of indices i and j satisfying the requirement of three or more different values forms intervals, so we can accelerate the DP with prefix sums. The complexity is O(N). Some implementation may take O(NlogN) time, which is also fine. E - K Different Values Editorial by evima Let S=∑ 1≤i≤N ​ A i ​ . For now, we will focus on whether there is a sequence satisfying the conditions. Let us split the final sequence into blocks of lengths Q,K,K⋯,K. Here, let 1≤Q≤K so that the division is unique. Let P be the number of blocks. First, for every block, all values in it must be different. Thus, it is necessary that A i ​ ≤P for every 1≤i≤N. It is also necessary that there is at most Q indices i such that A i ​ =P. On the other hand, if these conditions are satisfied, there is a sequence satisfying the conditions. Below, we will show this fact by actually constructing the lexicographically smallest such sequence. For each 0≤i≤N−1, we will decompose the last N−i terms into blocks of length K each, and let Q i ​ and P i ​ be the length of the part that will be left, and the number of blocks, respectively. Particularly, Q 0 ​ =Q,P 0 ​ =P. The lexicographically smallest sequence that satisfies the condition can be obtained by the following procedure. Let ans=(), to which we will append values. For each i=0,1,⋯,N−1, do the following. (a): If there are Q i ​ values v such that A v ​ =P i ​ , let m be the smallest such value that does not appear in the last K−1 terms of ans. (b): Otherwise, let m be the smallest value satisfying A v ​ ≥1 that does not appear in the last K−1 terms of ans. Append m to the end of ans and decrease A m ​ by 1. In order for this procedure to terminate normally, the following must hold. (1): For each i, maxA v ​ ≤P i ​ before doing the operation. Also, there are at most Q i ​ values v such that A v ​ =P i ​ . (2): For each i, there is at least one value that satisfies the condition, allowing m to be defined. On the other hand, if the procedure exits normally, it obviously leads to the lexicographically smallest result. Thus, now we just need to show (1) and (2). For (1), we can easily see that if it holds for i=x, it also holds for i=x+1. It does hold for i=0, which completes the proof by induction. Let us show (2). Assume that, at the point i=x, there happens to be no candidate for m. If it happens on (a): It means that the last K−1 terms of ans contains all v such that A v ​ =P i ​ . However, in such a case, (1) should have been violated already at the point i=x−(K−1), which is a contradiction. If it happens on (b): There are at most K−1 values v such that A v ​ ≥1. Here, it follows from (1) that N−i≤K−1, and we can also see that P i ​ =1. Eventually, it can be seen that this case falls into the above category (a). Strictly speaking, we also need to consider the case the length of ans is less than K−1, but we can apply the same argument to that case. This completes the proof of the validity of the procedure above. A naive implementation of the procedure takes O(SN) time, which is fast enough. F - Game against Robot Editorial by evima Without loss of generality, assume A 1 ​ ≥A 2 ​ ≥⋯≥A N ​ . Let us consider the problem where p is fixed. The solution to this version is as follows. Let x 1 ​ ,x 2 ​ ,⋯,x N ​ be the sorted list of cards in ascending order of p i ​ . Then, do the operation below for each i=1,3,⋯,N−1. Here, s is a priority queue, and ans is a variable that stores the answer. Add A x i ​ ​ and A x i+1 ​ ​ to s. Take out the largest element from s and add it to ans. Now, let us unfix p and solve the counting problem. For each 1≤k≤N, we want to know the number of times A k ​ is added to ans. Almost similarly, let us find the number of times a value greater than or equal to A k ​ is added to ans. Let us classify the elements of the sequence x by whether x i ​ ≤k or not to make a 01 sequence y, where an element such that x i ​ ≤k corresponds to 1. Enumerating all N! permutations p is equivalent to enumerating all 01 sequences y containing N−k zeros and k ones. Here, the same 01 sequence appears (N−k)!k! times. For a fixed y, we can find the number of times a value greater than or equal to A k ​ is added to ans, as follows. Let cnt(i) denote the number of 1s in the last i elements of y. Then, the number of times a value greater than or equal to A k ​ is added to ans is k−max i=0,2,4,⋯,N ​ (cnt(i)−i/2). This follows from the number of values greater than or equal to A k ​ in the priority queue. The essentially difficult part is max i=0,2,4,⋯,N ​ (cnt(i)−i/2). First, let us make a −1,1 sequence y ′ by replacing 0 with −1. Then, if we let suf(i) denote the sum of the last i elements of y ′ , we have max i=0,2,4,⋯,N ​ (cnt(i)−i/2)=⌊max 0≤i≤N ​ suf(i)/2⌋. Note that the range of i at max on the right side is not limited to even numbers. Let us fix the value max 0≤i≤N ​ suf(i) to h and count y ′ that realize it. First, let m be the largest i that maximizes suf(i). Here, let us reverse the last m elements of y ′ and flip the signs of those elements. Let z be the resulting sequence. Then, z will satisfy the following conditions: the sum of z is 2k−N−2h; all prefix sums of z are at least 2k−N−2h. On the other hand, if we have a sequence z that satisfies the two conditions above, there is a unique y ′ that corresponds to it. Thus, instead of counting y ′ , let us count z. The number of z can be written as a simple formula with binomial coefficients, similar to the formula that gives Catalan numbers, which subtracts the number of paths symmetric to invalid paths. Now, we just have to unfix h and compute the sum of this formula. Using prefix sums, the computation for each k can be done in O(1) time, after a pre-computation that takes O(N) time. The total complexity is O(N). A - Leading 1s Editorial by evima The answer is the sum of the following: the number of integers between 1 and N that begin with 1 the number of integers between 1 and N that begin with 11 the number of integers between 1 and N that begin with 111 ⋮ This is because an integer x with k leading ones is contained in the first k of the lists above. Now, what kinds of integers begin with 111, for instance? We can see that those numbers are in the following ranges: [111,112) [1110,1120) [11100,11200) ⋮ Generally, we are interested in the ranges of the form [1⋯10⋯0,1⋯20⋯0). Now, we just need to count the numbers at most N in those ranges. We only need to consider O(log 2 N) ranges of the form [1⋯10⋯0,1⋯20⋯0), so the time complexity will also be O(log 2 N). B - Ternary Strings Editorial by evima Instead of strings, let us construct ternary numbers. Here, numbers are already padded with zeros, so being the lexicographically largest is equivalent to being the largest number. We need N numbers that begin with 2. Thus, it is necessary that 2×3 (L−1) +N−1≤t. Actually, we can achieve 2×3 (L−1) +N−1=t. We begin with 2×3 (L−1) ,2×3 (L−1) +1,⋯,2×3 (L−1) +N−1. Let us convert each of these numbers as follows: in ternary, replace 0 with 1, 1 with 2, 2 with 0. This results in numbers that all begin with 0 and are pairwise distinct. Similarly, perform the following conversion, too: in ternary, replace 0 with 2, 1 with 0, 2 with 1. Now we can print these 3N numbers that satisfy the conditions. C - Binary Strings Editorial by evima Let us subtract 1 from X to consider it as 0-based. Additionally, since every string on the blackboard begins with 1, let us assume that it does not exist. (For instance, we see 1 as an empty string.) Let us gradually determine the string in question from the top. There are 2 (N−1) strings that begin with 0 or are empty. Thus, if 2 (N−1) ≤X, the answer begins with 1. On the other hand, if 1≤X<2 (N−1) , the answer begins with 0. If X=0, the answer is an empty string. If 1≤X<2 (N−1) , the rest of the answer can be found by solving the same problem after letting N:=N−1 and X:=X−1. Similarly, if 2 (N−1) ≤X, the rest of the answer can be found by solving the same problem after letting N:=N−1 and X:=X−2 (N−1) . A naive implementation of this would involve O(N) operations on integers with O(N) digits, for a total of O(N 2 ) time. However, by maintaining X in binary, we can execute the operations in a total of O(N) time. First, when checking whether 2 k ≤X, it is enough to see whether the k-th bit is 1, since x<2 k+1 always holds. Next, when letting X:=X−1, we can just calculate it as if doing it on paper until there is no more borrowing, when we break the loop. Doing this N times makes ceil(N/2 k ) loops reach the k-th digit ( ceil(x) is the smallest integer not less than x). This is because once borrowing happens up to the k-th bit, every digit below it becomes 1, so the next borrowing up to the k-th bit will happen 2 k operations later. Since ∑ 0≤k≤N−1 ​ ceil(N/2 k ) is O(N), it shows that the total complexity is O(N). D - Sum of Min of Xor Editorial by evima Let L=18 and consider every number to have L digits (in binary). Below, when we say the k-th bit of a number, it refers to the k-th bit ( 0-indexed) from the bottom. Consider the first bit (from the top) where A i ​ ⊕A j ​ and B i ​ ⊕B j ​ differ. This is the topmost bit of A i ​ ⊕A j ​ ⊕B i ​ ⊕B j ​ . Let C i ​ =A i ​ ⊕B i ​ . Let S be the set of i such that the W( =L−1)-th bit of C i ​ is 0, and T be the set of i such that the W-th bit of C i ​ is 1. For the pairs (i,j) such that i,j∈S or i,j∈T, we will compute their contribution recursively in each of S and T after letting W:=W−1. Let us consider the contribution of pairs (i,j) such that i∈S,j∈T. For i inS, we will further divide these indices into sets S 0 ​ and S 1 ​ , which consist of i such that the W-th digit of A i ​ is 0 and 1, respectively. T 0 ​ and T 1 ​ are similarly defined. Then, for each pair 0≤x,y≤1, for any i∈S x ​ and any j∈T y ​ , the smaller of A i ​ ⊕A j ​ and B i ​ ⊕B j ​ is uniquely determined. Therefore, we can find the answer by computing the following for each V=S 0 ​ ,S 1 ​ ,T 0 ​ ,T 1 ​ : the distribution of the j-th bits of A i ​ and B j ​ for each 0≤j<L. The total complexity will be O((N+2 L )L 2 ). (We omitted the contribution of pairs (i,j) such that C i ​ =C j ​ , because it is simple.) E - Priority Queue Editorial by evima For each 1≤v≤N, let us consider maximizing the number of values not less than v that are contained in s in the end. For this objective, we can see that it is optimal to insert i in the i-th push. This strategy does not depend on v. Let Z={Z 1 ​ <Z 2 ​ <⋯<Z K ​ } ( K=A−B) be the set s that results from this strategy. Let us consider whether it is possible to have x={x 1 ​ <x 2 ​ <⋯<x K ​ } as s in the end. First, it is necessary that x i ​ ≤Z i ​ (1≤i≤K). This is because otherwise there would be v such that there are more values not less than v in x than in Z. Actually, this necessary condition is also sufficient. After figuring it out, we can count sets x satisfying this condition with simple O(A 2 )-time DP. Finally, we will show the sufficiency of the condition. The following way to push numbers will leave the desired set in the end. Let W={W 1 ​ <W 2 ​ <⋯<W B ​ } be the set of i such that 1≤i≤N and not contained in Z. Let y={y 1 ​ <y 2 ​ <⋯<y B ​ } be the set of i such that 1≤i≤N and not contained in x. In the Z i ​ -th push, insert x i ​ . In the W i ​ -th push, insert y i ​ . We can see that this strategy works by noting that W i ​ ≤y i ​ holds. F - ±AB Editorial by evima If A+B−1≤M, the answer is M+1. Let us consider the other case. For x such that 0≤x≤V, we can transition from x to x−A,x−B,x+A,x+B, but since M≤A+B−2, just two of them are within [0,M]. Thus, we can see that the transition of x looks like one of the following two: +A if possible, −B if possible, +A if possible, −B if possible, ⋯ +B if possible, −A if possible, +B if possible, −A if possible, ⋯ Additionally, neither of them goes into a loop. If we assume otherwise, since gcd(A,B)=1, the length of the loop would be at least A+B, which implies that V has taken A+B or more different values, which contradicts with M+1<A+B. From the fact that they do not go into a loop, we can also see that each of the two strategies above does not revisit the same value. Let us count the number of values x can take in the strategy with +A,−B. We can redefine this strategy as follows: let x:=x+A and then replace x with the remainder when x is divided by B. We will become unable to do the operation at the moment (xmodB)>M−A holds. Thus, what we want to solve is the following problem: find the smallest integer k such that (V+kAmodB)≥M−A+1. If (VmodB)≥M−A+1, the answer is obviously k=0, so let us consider the other case. Let us rephrase the problem and find the smallest k such that M−A+1−(VmodB)≤(kAmodB)≤B−1−(VmodB). More generally, we want to solve the following problem. Given are integers H,W,L,R. A ray of light is emitted from the bottom left corner of an H×W rectangle diagonally at a 45-degree angle to upper right. Treat this rectangle as a torus. In other words, when the ray hits an edge of the rectangle, it reappears from the opposite edge. Where does the ray hit the interval [L,R] of the bottom edge, measured from the bottom left corner? It is obvious that this problem is equivalent to the original one with an inequality with modulo. We can solve this problem in a way similar to Euclidean division. It would be tedious to describe it with words, so refer to the following figure (and writer’s submissions). algorithm This algorithm works in O(log(max(A,B))) time, which is fast enough. There are also O(log 2 (max(A,B))) solutions for this problem, and we have set a relatively loose time limit to allow them to pass. A - Make 10 Editorial by evima ◆ Exploiting parity When making a stick of length 10, we will always use an even number of sticks of length 3. Thus, instead of having N 3 ​ sticks of length 3, let us assume that we have ⌊ 2 N 3 ​ ​ ⌋ sticks of length 6 from the beginning. Thus, we can reduce the problem to making sticks of length 10 from sticks of lengths 2, 4, and 6. Furthermore, by dividing the length of every stick by 2, we end up with the following problem. We have N 1 ​ sticks of length 1, N 2 ​ sticks of length 2, and N 3 ​ sticks of length 3. Find the maximum number of sticks of length 5 that can be made. Below, we deal with this problem instead of the original. We will call a way to make the maximum possible number of sticks of length 5 an optimal solution. ◆ The structure of an optimal solution (1) Intuitively, having two sticks of length 1, for example, is better than having one stick of length 2 because they are more versatile. Based on these observations, let us analyze the structure that we can assume an optimal solution has. We can prove the following: when we have at least one stick of length 2 and at least one stick of length 3, there is an optimal solution that bonds those sticks to form a stick of length 5. Let us prove this. We will assume that no optimal solution bonds a stick of length 2 and a stick of length 3 and derive a contradiction. Let us take an optimal solution and name it X. Also, let us take a stick of length 2 and another of length 3 and name them A and B, respectively. If X uses neither A nor B: we can bond A and B to form a new stick of length 5, which contradicts the optimality of X. If X uses A but not B: we can break the stick of length 5 containing A and then bond A to B to obtain an optimal solution that bonds a stick of length 2 and a stick of length 3, which is a contradiction. If X uses B but not A: contradictory, similarly to the case above. If X uses both A and B: we can break the stick of length 5 containing A and the stick of length 5 containing B, and then bond A to B and bond together the remaining sticks, to obtain an optimal solution that bonds sticks of length 2 and 3, which is a contradiction. This completes the proof. ◆ The structure of an optimal solution (2) With the fact shown above, we have found what to bond when we have both sticks of length 2 and sticks of length 3. What remains is the case we have no sticks of length 2 or no sticks of length 3. Similarly to the proof above, we can prove the following. We will omit the proofs. If we have no sticks of length 2, at least one stick of length 3, and at least two sticks of length 1, there is an optimal solution that bonds those sticks of length 3,1,1 to form a stick of length 5. If we have no sticks of length 3, at least two sticks of length 2, and at least one stick of length 1, there is an optimal solution that bonds those sticks of length 2,2,1 to form a stick of length 5. If we have no sticks of length 3, just one stick of length 2, and at least three sticks of length 1, there is an optimal solution that bonds those sticks of length 2,1,1,1 to form a stick of length 5. ◆ Greedy algorithm Eventually, we can see that the following greedy algorithm finds an optimal solution. (Step 1) If we have at least one stick of length 2 and at least one stick of length 3, bond those sticks to form a stick of length 5. Repeat as many times as possible. (Step 2) If we have at least one stick of length 3 and at least two sticks of length 1, bond those sticks to form a stick of length 5. Repeat as many times as possible. (Step 3) If we have at least two sticks of length 2 and at least one stick of length 1, bond those sticks to form a stick of length 5. Repeat as many times as possible. (Step 4) If we have at least one stick of length 2 and at least three sticks of length 1, bond those sticks to form a stick of length 5. Repeat as many times as possible. (Step 5) If we have at least five sticks of length 1, bond those sticks to form a stick of length 5. Repeat as many times as possible. B - Cross-free Matching Editorial by evima Let us sort the segments so that a 1 ​ ≤a 2 ​ ≤⋯ holds. ◆ If a i ​ are all distinct For simplicity, let us first consider the case a i ​ are all distinct. In this case, we can choose Segments i and j simultaneously if and only if b i ​ <b j ​ . Thus, the problem is equivalent to finding the length of Longest Increasing Subsequence (LIS). Problem: Longest Increasing Subsequence (LIS) For a sequence A=(A 1 ​ ,A 2 ​ ,…,A N ​ ), find the longest subsequence that is (weakly / strictly) increasing. It is possible to find the length of LIS in O(NlogN) time (described below). ◆ Solution to the original problem We can reduce the original problem to finding the length of LIS by carefully dealing with coincident endpoints. Specifically, when sorting the segments, we will set a new rule for the case a i ​ =a j ​ , as follows. When a i ​ <a j ​ , we consider Segment i is smaller than Segment j. When a i ​ =a j ​ , we consider Segment i is smaller than Segment j if b i ​ >b j ​ additionally holds. Since sorting and finding the length of LIS can both be done in O(MlogM) time, the problem can be solved in O(MlogM) time. ◆ Finding the length of LIS We will explain two ways for this. Scan the sequence from left to right and let dp[x] be the greatest length of an increasing subsequence ending with x at that point. We can use Segment Tree to compute dp[x] fast. If x can be large, compress the values beforehand. Scan the sequence from left to right and let dp[k] be the smallest value that can be the last element of an increasing subsequence of length k at that point. We can use Binary Search to compute dp[k] fast. C - Maximize GCD Editorial by evima Let A max ​ denote max{A 1 ​ ,…,A N ​ }. ◆ Rephrasing the problem Generally speaking, rather than to deal with the condition x∣gcd(A 1 ​ ,…,A N ​ ), it is easier to deal with the condition x=gcd(A 1 ​ ,…,A N ​ ). This is because the latter can be decomposed into conditions on respective elements: ∀i,x∣A i ​ . Therefore, we will solve the following problem instead of the original. Find the maximum value of x such that it is possible to end up with x∣gcd(A 1 ​ ,…,A N ​ ) being satisfied after operations. We can easily see that rephrasing the problem in this way does not change the answer. Let cost(x) denote the minimum number of operations needed to satisfy x∣gcd(A 1 ​ ,…,A N ​ ), that is, make every A i ​ divisible by x. ◆ Computing cost(x) cost(x) is the sum of numbers of operations needed to make respective A i ​ divisible of x. Let k be an integer and compute the number of operations for all A i ​ such that (k−1)x<A i ​ ≦kx at once. For A i ​ in this range, we need kx−A i ​ operations, for a total of ∑ i ​ (kx−A i ​ )=∑ i ​ kx−∑ i ​ A i ​ . That is, we can see that the total number of operations for A i ​ in this range is kxc−s, where: c is the number of indices i such that (k−1)x<A i ​ ≤kx, and s is the sum of A i ​ over all i such that (k−1)x<A i ​ ≤kx. This number can be computed in O(1) time by computing prefix sums beforehand. By shifting k and add up these sums, we can compute cost(x) in O(⌈A max ​ /x⌉) time. ◆ The whole solution First, we perform the computation of cost(x) stated above for 1≦x≦A max ​ . It takes O(N+A max ​ ) time to pre-compute prefix sums, and O(∑ 1≤x≤A max ​ ​ ⌈A max ​ /x⌉) time in total to compute cost(x). Since ∑ 1≤x≤A max ​ ​ ⌈A max ​ /x⌉=O(A max ​ logA max ​ ), the computations so far takes a total of O(N+A max ​ logA max ​ ) time. So far, we have determined for all x in the range x≦A max ​ whether it is possible to make every A i ​ divisible of x. What remains is the case x>A max ​ . Since cost(x)=Nx−∑ i ​ A i ​ holds in this case, it is easy to determine whether there exists x such that cost(x)≦K and find the maximum value of x if it exists. Therefore, the problem can be solved in a total of O(N+A max ​ logA max ​ ) time. D - Pure Straight Editorial by evima ◆ With fixed terms to use and fixed position of the subsequence Let us first consider the minimum number of operations when the terms to use are fixed to A i 1 ​ ​ ,…,A i K ​ ​ ( i 1 ​ <⋯<i K ​ ), and the position for the contiguous subsequence (1,2,…,K) is fixed to j 1 ​ ,…,j K ​ =n,n+1,…,n+K−1. For increasing sequence of indices I=(i 1 ​ ,…,I K ​ ) and J=(j 1 ​ ,…,j K ​ ), let us define their distance as ∑ k=1 K ​ ∣i k ​ −j k ​ ∣. Also, let us define the inversion number of a sequence (x 1 ​ ,…,x K ​ ), inv(x 1 ​ ,…,x K ​ ), as the number of pairs (i,j) such that i<j and x i ​ >x j ​ . We can show that minimum number of operations needed to sort A i 1 ​ ​ ,…,A i K ​ ​ in asending order at the positions j 1 ​ ,…,j K ​ =n,n+1,…,n+K−1 is dist(I,J)+inv(A i 1 ​ ​ ,…,A i K ​ ​ ). Indeed, we need at least dist(I,J)+inv(A i 1 ​ ​ ,…,A i K ​ ​ ) operations because of the following holds. When swapping two of the K terms to use: the inversion number decreases by at most 1, but the distance of I and J does not change. When swapping two elements otherwise: the distance of I and J decreases by at most 1, but the inversion number does not change. On the other hand, we can achieve the objective in dist(I,J)+inv(A i 1 ​ ​ ,…,A i K ​ ​ ) operations, by moving each A i k ​ ​ to the position j k ​ and then repeatedly swapping two of these K terms. ◆ Only fixing the terms to use Next, let us consider how to compute the minimum number of operations when the terms to use are fixed but not the position. We will need to choose the position for the contiguous subsequence (1,2,…,K), j 1 ​ ,…,j K ​ =n,n+1,…,n+K−1, to minimize ∑∣i k ​ −j k ​ ∣. For m=⌈K/2⌉, we can see the following. If i m ​ <j m ​ , decreasing every j 1 ​ ,…,j K ​ by 1 decreases ∣i k ​ −j k ​ ∣ by 1 for 1≤k≤m and increases ∣i k ​ −j k ​ ∣ by at most 1 for m<k≤K. If i m ​ >j m ​ , decreasing every j 1 ​ ,…,j K ​ by 1 increases ∣i k ​ −j k ​ ∣ by at most 1 for 1≤k<m and decreases ∣i k ​ −j k ​ ∣ by 1 for m≤k≤K. From these, we can see that there is an optimal solution such that i m ​ =j m ​ , where: ∣i k ​ −j k ​ ∣=j k ​ −i k ​ =(j m ​ +k−m)−i k ​ if 1<k<m, and ∣i k ​ −j k ​ ∣=i k ​ −j k ​ =i k ​ −(j m ​ +k−m) if m<k≤K. Thus, we can represent dist(I,J) as a formula with i 1 ​ ,…,i K ​ : ∑a k ​ i k ​ +b ( a k ​ ∈{−1,0,1}). Adding the inversion number of (A i 1 ​ ​ ,…,A i K ​ ​ ) yields the minimum number of operations when using (A i 1 ​ ​ ,…,A i K ​ ​ ). ◆ Computation with DP We have found out that the minimum number of operations when using (A i 1 ​ ​ ,…,A i K ​ ​ ), excluding the constant difference, is the sum of: a linear combination of i k ​ : ∑ k=1 K ​ a k ​ i k ​ , and the inversion number of (A i 1 ​ ​ ,…,A i K ​ ​ ). Particularly, for 0≤K ′ ≤K, we can define the “partial” cost when the first K ′ terms to use are decided as (A i 1 ​ ​ ,…,A i K ′ ​ ​ ), as the sum of: a linear combination of i k ​ : ∑ k=1 K ′ ​ a k ​ i k ​ , and the inversion number of (A i 1 ​ ​ ,…,A i K ′ ​ ​ ). We can solve the problem with DP where dp[S] is the minimum cost when the set of chosen K ′ elements is S. The time complexity is O(2 K N). E - Infinite Operations Editorial by evima ◆ Without updating queries For a sequence A=(A 1 ​ ,…,A N ​ ), let us denote F(A)=∑ i<j ​ ∣A i ​ −A j ​ ∣. We will show that lim n→∞ ​ f(n)=F(A)/2. Let us call an operation on (A i ​ ,A j ​ ) good when there is no k such that A i ​ <A k ​ <A j ​ . We can see that the following holds for an operation in general and a good operation. An operation gaining x points decreases F(A) by at least 2x. A good operation gaining x points decreases F(A) by exactly 2x. We will omit the proofs since they are easy. From the definition, F(A) will never be less than 0. Thus, we can first see that 2f(n)≤F(A) holds for any n. To show that lim n→∞ ​ f(n)=F(A)/2, it is enough to show that we can make F(A) tend to 0 by repeating good operations only. We assume A 1 ​ ≤A 2 ​ ≤⋯, after reindexing the elements if necessary. Here, a simple calculation shows that ∀i,∣A i ​ −A i+1 ​ ∣<C⟹F(A)< 2 N(N−1) ​ C. From its contraposition, we can see that there exists i such that ∣A i ​ −A i+1 ​ ∣≥ N(N−1) 2F(A) ​ . Specifically, it is possible to do a good operation with x= N(N−1) F(A) ​ , which multiplies F(A) by exactly r=1− N(N−1) 2 ​ . By repeating this n times, we can make F(A) multiplied by r n in n good operations. Since 0≤r<1, this shows that it is possible to make F(A) tend to 0 with good operations only. ◆ Computing the answer and dealing with queries The order of elements in A is irrelevant to the problem, so we see A as a multiset. Consider computing the increment of the answer while handling additions and deletions of elements. We can see that we just need to compute ∑ a∈A ​ ∣x−a∣ for some number x. This can be computed by retrieving the count and sum of a∈A in segments [0,x) and [x,∞). We can do this by compressing the values and using Fenwick Tree or Segment Tree, for example. It is also possible to directly compute the answer, rather than its increment, with Segment Tree. F - Affine Sort Editorial by evima ◆ Notation Let S=∑ i ​ ∣X i ​ ∣ in analysis of complexity. For a positive integer K, let g(K) denote the number of valid triples with c=K, that is, pairs of integers (a,b) that satisfy the following. 0≤a,b<K. Y 1 ​ <Y 2 ​ <⋯<Y N ​ holds, where Y i ​ is the remainder when aX i ​ +b is divided by K for each i. ◆ Relation between f(K) and g(K) We have f(K)=∑ k=1 K ​ g(k). As explained later, it is possible to show that the limit c=lim K→∞ ​ K 2 g(K) ​ exists. Let us assume this fact for now and find the answer. Take an arbitrary positive real number ε>0. When c=lim K→∞ ​ K 2 g(K) ​ , (c−ε)K 2 ≤g(K)≤(c+ε)K 2 holds for any sufficiently large K. From this, (c−2ε)∑ k=1 K ​ k 2 ≤f(N)≤(c+2ε)∑ k=1 K ​ k 2 holds for any sufficiently large K. Since ∑ k=1 K ​ k 2 = 3 1 ​ K 3 +O(K 2 ), (c−3ε)⋅ 3 1 ​ K 3 ≤f(K)≤(c+3ε)⋅ 3 1 ​ K 3 holds for any sufficiently large K. This formula can be rephrase into 3 1 ​ c−ε≤ K 3 f(K) ​ ≤ 3 1 ​ c+ε. From the fact that for any ε>0, there is a sufficiently large K that satisfies this inequation, we can see that lim K→∞ ​ K 3 f(K) ​ = 3 1 ​ c. Thus, under the assumption that the limit c=lim K→∞ ​ K 2 g(K) ​ exists, it has been shown that the answer is 3 1 ​ c. ◆ Rephrasing with continuous values Let us consider when Y i ​ =(aX i ​ +b)modK are increasing. By considering Y i ​ /K instead of Y i ​ , we can see that the decimal part of K a ​ X i ​ + K b ​ holds the key. For a real number x, let {x} denote its decimal part, that is, {x}=x−⌊x⌋. Y i ​ are increasing when {(a/K)X i ​ +(b/K)} are increasing, so let us define a subset D of R 2 as: D={(α,β)∈[0,1] 2 ∣{αX 1 ​ +β}<{αX 2 ​ +β}<⋯}. g(K) can be seen as the number of pairs 0≤a,b<K such that (a/K,b/K)∈D. As explained below, D is a union of figures surrounded by a finite number of segments, and lim K→∞ ​ K 2 g(K) ​ equals the area of D. The answer is the area of D multiplied by 1/3, so let us try to find this area. ◆ Computing D Since pairs (α,β) such that {αX i ​ +β}={αX i+1 ​ +β} exactly holds are irrelevant to the area of D, we ignore this case in the argument below. Let us see the interval [0,1) as a circumference by pasting together the ends, 0 and 1, and consider {αX i ​ +β} to be a point on this circumference. Then, {αX i ​ +β} is the result of translating {αX i ​ } by β in the positive direction. We can see that, when {αX i ​ +β} are increasing, {αX i ​ } are also in the order i=1,2,… when seen from some position on the circumference. Let us first examine the condition that α must satisfy to make this happen. {αX i ​ } are in the order i=1,2,… when seen from some position on the circumference, if and only the following holds for any i: ∑ i=1 N ​ f i ​ (α)=1 holds, where f i ​ (α) is the distance from {αX i ​ } to {αX i+1 ​ } measured in the positive direction. (Here, we define X N+1 ​ =X 1 ​ .) When α continuously increases from 0 to 1, f i ​ (α)={α(X i+1 ​ −X i ​ )} changes at the rate X i+1 ​ −X i ​ around most points, and changes by ±1 at a finite number of rational numbers whose denominator is ∣X i+1 ​ −X i ​ ∣. ∑ i ​ f i ​ (α) is constant around most points and changes by an integer value at a finite number of border points. Thus, we can enumerate all ranges of α where {αX i ​ } are in desired relative positions on the circumference, by computations such as enumerating rational numbers whose denominators are ∣X i ​ −X i+1 ​ ∣ and sorting them. Since ∑∣X i ​ −X i+1 ​ ∣=O(S), this can be done in O(SlogS) time. Furthermore, when α satisfies this condition, the condition that β should satisfy can be represented as {αX 1 ​ +β}<{αX N ​ +β}. In the end, the area of D can be computed as the sum of ∫ l r ​ {α(X 1 ​ −X N ​ )}dα over a finite number of open intervals (l,r). ◆ Proof that K 2 g(K) ​ converges to the area of D Let μ(D) denote the Lebesgue measure of the set D⊂R 2 . Also, let D ∘ and D respectively denote the interior and closure of D. Furthermore, let us define the indicator function χ D ​ of the set D as χ D ​ (x)={ 1 0 ​ (x∈D) (x∈ / D) ​ . Let us show that the following holds. Assume that D⊂R 2 is bounded and its boundary is a null set, that is, μ(D ∘ )=μ( D ) holds. Let g(K) be the number of pairs a,b∈Z such that (a/K,b/K)∈D. Then, lim K→∞ ​ K 2 g(K) ​ =μ(D) holds. Let us define the sets of points A K ​ ,A K ∘ ​ , A K ​ as follows: A K ​ ={(a,b)∣Ka∈Z,Kb∈Z,(a,b)∈D}, A K ∘ ​ ={(a,b)∣Ka∈Z,Kb∈Z,[a,a+1/K)×[b,b+1/K)⊂D ∘ }, A K ​ ={(a,b)∣Ka∈Z,Kb∈Z,[a,a+1/K)×[b,b+1/K)∩ D  =∅}. Also, let the functions F K ∘ ​ , F K ​ defined as follows: F K ∘ ​ is the indicator function of ⋃ (a,b)∈A K ∘ ​ ​ [a,a+1/K)×[b,b+1/K), F K ​ is the indicator function of ⋃ (a,b)∈ A K ​ ​ [a,a+1/K)×[b,b+1/K). Then, we can see the following: A K ∘ ​ ⊂A K ​ ⊂ A K ​ , ∫ x ​ F K ∘ ​ (x)dx=∣A K ∘ ​ ∣/K 2 , ∫ x ​ F K ​ (x)dx=∣ A K ​ ∣/K 2 , lim K→∞ ​ F K ∘ ​ (x)=χ D ∘ ​ (x) pointwise, lim K→∞ ​ F K ​ (x)=χ D ​ (x) pointwise. From the boundedness of D, we can apply Lebesgue’s convergence theorem to see that lim K→∞ ​ ∫ R 2 ​ F K ∘ ​ (x)dx=∫ R 2 ​ χ D ∘ ​ (x)dx. Thus, we have lim K→∞ ​ ∣A K ∘ ​ ∣/K 2 =μ(D ∘ ). Similarly, lim K→∞ ​ ∣ A K ​ ∣/K 2 =μ( D ). From A K ∘ ​ ⊂A K ​ ⊂ A K ​ , μ(D ∘ )=μ( D ), and the squeeze theorem, we can see that lim K→∞ ​ ∣A K ​ ∣/K 2 =μ(D) holds, which completes the proof. D in this problem is the union of regions defined by a finite number of linear inequalities, whose boundary is contained in the union of a finite number of lines. Thus, it satisfies the assumption above that its boundary is a null set. A - Dial Up Editorial by evima Let us count the number of times we shift a. It is obviously 0 if T consists of S 1 ​ only. Assume otherwise. If S does not have a character that is not S 1 ​ , the answer is −1. Assume S has such a character, and let x and y be its leftmost and rightmost positions, respectively. When such a character occurs in T for the first time, we need to shift a to bring the x-th or y-th character to the beginning. What will we do if a character equal to S 1 ​ occurs later in T? It turns out we just need to shift a once to bring a character equal to S 1 ​ to the beginning, because of how x and y were chosen. By reusing this argument, from then on, each time we need a character different from the last, we can shift a once to bring such a character to the beginning of a, which is obviously the fewest number of moves possible. Therefore, the only choice we need to make is to use the x-th character or the y-th one. The fewer number of moves used in these two scenarios is the answer. The time complexity of this solution is O(N+M). B - Squares Editorial by evima Assume there exists a non-negative integer z such that x 2 −y=z 2 . We can transform the formula into x 2 −z 2 =(x+z)(x−z)=y. Let p=x+z,q=x−z. Instead of counting pairs x,y, we will count pairs of integers p,q that satisfy the following conditions: p≥q; x=(p+q)/2 is an integer; 1≤x=(p+q)/2≤N; 1≤y=pq≤N. From these conditions, we first see that p and q are positive integers. Additionally, it follows from pq≤N that (p+q)/2≤N. Here, we can try all possible values for q, because q≤ N ​ . Once we decide the value for q, p must satisfy q≤p≤N/q and p≡qmod2, and we can count such values for p in O(1) time. Therefore, the whole problem can be solved in O( N ​ ) time. C - LIS to Original Sequence Editorial by evima We will prove that there is always a solution for any input satisfying the condition in Problem Statement by induction on N, and simultaneously give the lexicographically smallest construction of P. Let us decide the values in the sequence from left to right. First, if K=1, the only solution is P=(N,N−1,N−2,⋯,1). Consider the case K≥2. When A 1 ​ =1, we may choose P 1 ​ =1. For the remaining values (P 2 ​ ,P 3 ​ ,⋯,P N ​ ), we will choose them recursively. That is, we find the solution for the input (A 2 ​ −1,A 3 ​ −1,⋯,A K ​ −1) (which is possible from the induction hypothesis) and use it after adding 1 to each value. When A 1 ​ >1, it turns out that P 1 ​ =A 1 ​ will be chosen. If P 1 ​ <A 1 ​ , P 1 ​ <A 1 ​ <A 2 ​ <⋯<A K ​ would be a subsequence of P, which violates the requirement that A is a LIS. On the other hand, a solution with P 1 ​ =A 1 ​ always exists, as shown below, so P 1 ​ =A 1 ​ must hold in order for P to be the lexicographically smallest. Next, it also turns out that P 2 ​ =1, because there exists a solution with P 2 ​ =1, which will be the lexicographically smallest choice. Now, we will prove that there is a solution with P 1 ​ =A 1 ​ and P 2 ​ =1. We can show from the induction hypothesis that there is a permutation (P 3 ​ ,P 4 ​ ,⋯,P N ​ ) of (2,3,⋯,A 1 ​ −1,A 1 ​ +1,⋯,N) whose LIS is (A 2 ​ ,A 3 ​ ,⋯,A K ​ ). The length of the LIS of such P is indeed K, because P 1 ​ >P 2 ​ and the increasing subsequence using P 2 ​ has the length of 1+(K−1)=K. Naturally, P contains A as a subsequence, satisfying the requirement. Additionally, by choosing the lexicographically smallest values for (P 3 ​ ,P 4 ​ ,⋯,P N ​ ), the entire sequence P will also be the lexicographically smallest. Therefore, we can solve the problem recursively following the procedure shown above. In the actual implementation, it would be simpler to maintain a list of unused values rather than calling a recursive function. The total time complexity will be O(N). D - Unique Subsequence Editorial by evima For convenience, let A 0 ​ =0,A N+1 ​ =N+1 and we will count subsequences containing A 0 ​ and A N+1 ​ . Assume that, for 0=x 0 ​ <x 1 ​ <⋯<x k ​ <x k+1 ​ =N+1, there is a unique way to extract the subsequence s=(A x 0 ​ ​ ,A x 1 ​ ​ ,⋯,A x k+1 ​ ​ ). Then, it is necessary that the following holds for each 0≤i≤k: None of A x i ​ +1 ​ ,A x i ​ +2 ​ ,⋯,A x i+1 ​ −1 ​ equals A x i ​ ​ or A x i+1 ​ ​ . Otherwise, there would be another way to extract the same subsequence. On the other hand, when the above condition is satisfied, the extraction of s is unique. We can show this from the fact that the greedy extraction of s from the beginning of A (making the used indices lexicographically smallest) will coincide with the greedy extraction of s from the end of A (making the used indices lexicographically largest). Thus, we can find the answer by counting the sequences of indices x satisfying the condition above. We can implement it with Binary Indexed Tree to achieve the time complexity of O(NlogN). E - Snack Editorial by evima Formularizing the problem with maximum flow, we get the following. The graph has the vertices S, T, L 1 ​ ,L 2 ​ ,⋯,L N ​ , R 1 ​ ,R 2 ​ ,⋯,R M ​ . For each 1≤i≤N, there is an edge S→L i ​ with a capacity A i ​ . For each 1≤i≤N and 1≤j≤M, there is an edge L i ​ →R j ​ with a capacity B j ​ . For each 1≤j≤M, there is an edge R j ​ →T with a capacity C j ​ . The answer is the maximum flow from S to T. Naturally, the graph is too large to compute the flow directly. Let us try to find the minimum cut instead, which is equal to the maximum flow. Assume that we have split the vertices L i ​ to the sets X and Y ― the former sides with S in the cut, and the latter sides with T. Then, for each vertex R j ​ , we can independently decide whether it sides with S or T in the cut. That is, we compare the cost when R j ​ belongs to S, which is C j ​ , and the cost when R j ​ belongs to T, which is ∣X∣B j ​ , and choose the side with the smaller cost. Here, after choosing X and Y, it was just the size of X that mattered. Therefore, we can first decide the size of X, and then choose the vertices to be used as X from L i ​ in descending order of A i ​ . We will try all possible sizes of X from 0 to N and find the costs of the corresponding cuts. Except for sorting A i ​ , this can be done in O(N+M) time with prefix sums. Thus, the total time complexity of this solution is O(NlogN+M). F - Tree Degree Subset Sum Editorial by evima Let d 1 ​ ,d 2 ​ ,⋯,d N ​ be the degrees of the vertices, where each value is decreased by 1. For each 0≤s≤N−2, let m(s) and M(s) be the minimum and maximum sizes of a subset of d i ​ whose sum is s, respectively. (If there is no such subset, let m(s)=∞,M(s)=−∞ for convenience.) Then, the following property holds: For every m(s)≤c≤M(s), it is possible to choose c elements from d whose sum is s. If we accept this, the problem is easy to solve. Consider finding m(s) with DP. Because there are at most O( N ​ ) different values in d, we can classify the elements according to the values and use the sliding window algorithm for each value to accelerate the transitions, finding m(s) in O(N N ​ ) time. Then, M(s) can be immediately found from m(s). Therefore, we can solve the problem in O(N N ​ ) time. Finally, we will prove the property we assumed above. Let z be the number of 0s in d. We are done if we show M(s)−m(s)≤2z. This is because a solution achieving M(s) always uses z 0s, and a solution achieving m(s) always uses no 0s. Incidentally, for any subset x of d, we have −z≤s−c≤z−2, where c and s are the size and sum of z, respectively. This is because the sum of d i ​ −1 such that d i ​ −1<0 is −z, and the sum of d i ​ −1 such that d i ​ −1>0 is z−2. Then, it follows from −z≤s−M(s)≤s−m(s)≤z−2 that M(s)−m(s)≤2z, completing the proof. A - LR Constraints Editorial by evima It is important to note that for i and j such that i  =j, the integer written on the i-th card from the left does not affect the integer written on the j-th card. Let us find the number of different integers that we can write on each card. We can write an integer x on the i-th card from the left if and only if the condition 1 below and one of the conditions 2 and 3 are satisfied. There is no integer y such that x  =y and k y ​ =i. c x ​ is L and k x ​ ≤i. c x ​ is R and i≤k x ​ . This approach works in O(NK) time, which is fast enough. Sample Implementation (C++) Copy #include <iostream> #include <vector> using ll = long long; using namespace std; int main() { int N, K; cin >> N >> K; vector<int> a(N, 0); vector<int> b(N, 0); for (int i = 0; i < K; i++) { char c; int k; cin >> c >> k; k--; b[k] = 1; for (int j = 0; j < N; j++) { if (c == 'L' && k <= j) a[j]++; if (c == 'R' && j <= k) a[j]++; } } const ll MOD = 998244353; ll ans = 1; for (int i = 0; i < N; i++) if (!b[i]) ans = ans * a[i] % MOD; cout << ans << endl; return 0; } B - XOR Matching 2 Editorial by evima Let ⊕ denote the bitwise XOR. When x is fixed, whether it is possible to permute b so that a i ​ ⊕b i ​ =x holds is equivalent to whether it is possible to permute b so that b matches c where c i ​ =a i ​ ⊕x. We can check the latter in O(NlogN) time by sorting, for example. As candidate values of x, it is enough to try N values a 1 ​ ⊕b 1 ​ ,a 1 ​ ⊕b 2 ​ ,…,a 1 ​ ⊕b N ​ . The whole process to list all good integers takes O(N 2 logN) time, which is fast enough. C - LCM of GCDs Editorial by evima For a fixed pair of X and Y, it is possible to determine in O(N) time whether there is a way to put the balls in the bags so that the greatest common divisor of the integers in the red bag is a multiple of X, and the greatest common divisor of the integers in the blue bag is a multiple of Y. Now, let us exhaustively search for X and Y. Assume that we put a 1 ​ in the red bag and b 1 ​ in the blue bag. Then, X and Y are divisors of a 1 ​ and b i ​ , respectively, so we just need to try d(a 1 ​ )d(b 1 ​ ) candidates for X and Y, where d(n) is the number of divisors of n. This approach works in O(d(a 1 ​ )d(b 1 ​ )N) time, which is fast enough. D - Yet Another Sorting Problem Editorial by evima Consider a directed graph with edges i→p i ​ . We paint Vertices 1,…,N red and Vertices N+1,…,N+M blue. To get straight to the point, the answer is N+M−K+2max(R,B), where K is the number of connected components in this graph, R is the number of connected components of size 2 or greater consisting of red vertices, and B is the number of connected components of size 2 or greater consisting of blue vertices. We can compute it in O(N+M) time, which is fast enough. Below, we will show the validity of the above. First, the operation in the original problem corresponds to choosing vertices i and j with different colors and doing the four actions below. Remove the edge i→p i ​ . Remove the edge j→p j ​ . Add an edge i→p j ​ . Add an edge j→p i ​ . As a result, the number of connected components increases by 1 if i and j belonged to the same connected components before the operation, and decreases by 1 otherwise. We will show that we need at least N+M−K+2max(R,B) operations. Let us define K i ​ ,R i ​ ,B i ​ as follows. We want to find the minimum n such that we can have K n ​ =N+M,R n ​ =0,B n ​ =0. K i ​ : The number of connected components when the i-th operation is done. R i ​ : The number of connected components of size 2 or greater consisting of red vertices when the i-th operation is done. B i ​ : The number of connected components of size 2 or greater consisting of blue vertices when the i-th operation is done. From the properties of the operations, ∣K i+1 ​ −K i ​ ∣=1,∣R i+1 ​ −R i ​ ∣≤1,∣B i+1 ​ −B i ​ ∣≤1 must hold. Additionally, we can have R i+1 ​ −R i ​ =1 only if K i+1 ​ −K i ​ =1. Similarly, we can have R i+1 ​ −R i ​ =−1 only if K i+1 ​ −K i ​ =−1. The same goes for B i ​ . Here, it is possible to prove that f(i)≤f(i+1) holds where f(i)=i+N+M−K i ​ +2max(R i ​ ,B i ​ ). From this, we can state that we need at least N+M−K 0 ​ +2max(R 0 ​ ,B 0 ​ ) operations. This lower bound can be achieved with the following greedy strategy. Repeat the following as long as it can be done. If there are a connected component of size 2 or greater consisting of red vertices and a connected component of size 2 or greater consisting of blue vertices, do the operation between them. Repeat the following as long as it can be done. If there is a connected component of size 2 or greater consisting of red vertices, choose any two connected components both of which contain blue vertices and do the operation. Repeat the following as long as it can be done. If there is a connected component of size 2 or greater consisting of blue vertices, choose any two connected components both of which contain red vertices and do the operation. Repeat the following as long as it can be done. Choose i such that i and p i ​ have different colors and doing the operation with i and p i ​ would not create a connected component of size 2 or greater consisting of vertices in a single color, and do the operation with i and p i ​ . (Such an i always exists.) E - Pass to Next Editorial by evima Let c i ​ be the number of balls that Person i hands to the neighbor to the right. When min(c)  =0, decreasing every c i ​ by 1 would not change the resulting sequence, so we just need to consider the case min(c)=0. Below, we assume min(c)=0. There are ∏ i=1 N ​ (a i ​ +1)−∏ i=1 N ​ a i ​ such sequences c, all of which result in distinct sequences. Thus, we are done if we can find the resulting sequence for every sequence c such that min(c)=0, and find the sum of their products. The value ∏ i=1 N ​ x i ​ is equal to the number of ways to choose one from each person’s balls after the procedure. To find the sum, we can use dynamic programming to find counts such as the number of ways to decide c 1 ​ ,c 2 ​ ,…,c i ​ and choose one ball from each of Persons 1,2,3,…,i,i+1 (note that we need to consider the case we have not chosen a ball from Person 1, Person i+1, or both). This can be done in O(N) time, which is fast enough. F - Chance Meeting Editorial by evima Let us decrease H and W by 1 so that we have H vertical moves and W horizontal moves. There are ( H 2H ​ ) ways to move the two animals up and down, but they will be in the same row after H of those moves regardless of how we make them. Thus, the way we make vertical moves is unimportant, and we just need to consider the case they meet in the H-th row. Let f(n) be the number of ways in which the two animals move right n times each and the camel moves down H times for them to meet for the first time on (H,n). The answer is ( H 2H ​ )∑ i=0 W ​ f(i)f(W−i). Let us try to find f. Let g(n) be the number of ways in which the two animals move right n times each and the camel moves down H times for them to meet (not necessarily for the first time) on (H,n). Then, we can represent it as g(n)=( n 2n ​ )( H 2n+H ​ ). Thus, we have f(n)=g(n)−2∑ i=0 n−1 ​ g(i)C(n−i−1), where C(n) is the Catalan number. Using FFT, we can find f in O(H+WlogW) time, which is fast enough. A - Arithmetic Sequence Editorial by evima ◆ Dimensionality reduction The sequence A is arithmetic if and only if 2A 2 ​ −A 1 ​ −A 3 ​ =0, so it is the value 2A 2 ​ −A 1 ​ −A 3 ​ that matters, rather than A i ​ themselves. Therefore, let us define X=2A 2 ​ −A 1 ​ −A 3 ​ . We can compute the value of X after doing some operations without using the values of A i ​ themselves, so let us ignore them. In the end, our problem is as follows. Given is an integer X. We can do the following two kinds of operations. Add −1 to X. (Equivalent to choosing i=1 or 3.) Add 2 to X. (Equivalent to choosing i=2.) Find the minimum number of operations to make X=0. Now our situation is simpler with just one variable (dimension) X instead of three: A 1 ​ ,A 2 ​ ,A 3 ​ . ◆ Finding the answer Let k be the number of times we add 2 to X. Then, it is necessary that k≧0 and X+2k≧0, which can be represented as k≧k 0 ​ where k 0 ​ =max(0,⌈(−X)/2⌉). If we fix k≧k 0 ​ , we need to do X+2k additions of −1, for a total of X+3k operations. In order to minimize this number, we should minimize k, which means the answer is X+3k 0 ​ . The time complexity of our approach is Θ(1). B - Increasing Triples Editorial by evima Let us call a tuple (A i ​ ,B j ​ ,C k ​ ) such that A i ​ <B j ​ <C k ​ simply a triple. The problem can be rephrased into choosing as many triples as possible under the restriction that each element can be used at most once. Below, we assume that A 1 ​ ≦⋯≦A N ​ , B 1 ​ ≦⋯≦B N ​ , and C 1 ​ ≦⋯≦C N ​ , by sorting the input. Let us call a situation an optimal solution where the maximum possible number of triples are chosen. ◆ The structure of optimal solutions (1) We can show that one of the following holds. The optimal solution chooses no triple. There exists an optimal solution that chooses A i ​ . Let us prove this. Assume that there is an optimal solution choosing one or more triples without using A 1 ​ . We can replace one of the chosen triples in such an optimal solution, (A i ​ ,B j ​ ,C k ​ ), with (A 1 ​ ,B j ​ ,C k ​ ). This does not change the number of chosen triples, so an optimal solution remains an optimal solution. Thus, we can see that there exists an optimal solution choosing A 1 ​ . From this, we can see that we only need to consider the case A 1 ​ is chosen. ◆ The structure of optimal solutions (2) Next, let us think about the choice of B j ​ . We cannot use B j ​ such that B j ​ ≤A 1 ​ in our triples. Thus, we can delete these B j ​ in the first place and move on. The case B is empty is trivial, so let us assume otherwise. That is, we assume A 1 ​ <B 1 ​ . We can show that one of the following holds. The optimal solution chooses no triple. There exists an optimal solution that uses A 1 ​ and B 1 ​ in the same triple. Let us prove this. Assume that there is an optimal solution choosing one or more triples without using A 1 ​ and B 1 ​ in the same triple. From this, if we can show that there exists an optimal solution that uses A 1 ​ and B 1 ​ in the same triple, we are done. First, similarly to the proof in (1), we can show that there exists an optimal solution that uses both A 1 ​ and B 1 ​ in some triples. Now, assume that A 1 ​ and B 1 ​ are not in the same triple, and they belong to triples (A 1 ​ ,B j ​ ,C k ​ ) and (A i ​ ,B 1 ​ ,C k ′ ​ ), respectively. Because of the minimumness of B 1 ​ , we can rearrange these triples into (A 1 ​ ,B 1 ​ ,C k ′ ​ ) and (A i ​ ,B j ​ ,C k ​ ), yielding an optimal solution that uses A 1 ​ and B 1 ​ in the same triple. ◆ The structure of optimal solutions (3) We cannot use C k ​ such that C k ​ ≦B 1 ​ in our triples. Thus, we can delete these B j ​ in the first place and move on assuming that A 1 ​ <B 1 ​ <C 1 ​ . Similarly to (1) and (2), we can prove the following: There exists an optimal solution that uses A 1 ​ , B 1 ​ , and C 1 ​ in the same triple. ◆ Solution Summing up the above, we obtain the following greedy algorithm. If A is empty, terminate. Otherwise, let A 1 ​ be the minimum value among A, and delete all B j ​ that are not greater than A 1 ​ . If B is empty, terminate. Otherwise, let B 1 ​ be the minimum value among B, and delete all C k ​ that are not greater than B 1 ​ . If C is empty, terminate. Otherwise, let C 1 ​ be the minimum value among C. Choose the triple (A 1 ​ ,B 1 ​ ,C 1 ​ ). Delete A 1 ​ ,B 1 ​ ,C 1 ​ and go back to the beginning. By efficiently retrieving and deleting the minimum values, we can solve the problem in Θ(NlogN) time. There are several ways to implement the algorithm, such as the following. Iterate in the sorted arrays without explicitly deleting elements. (Python) https://atcoder.jp/contests/arc123/submissions/24233121 Use priority queues, for example, to delete elements. (C++) https://atcoder.jp/contests/arc123/submissions/24233042 C - 1, 2, 3 - Decomposition Editorial by evima Let us call a positive integer good whose every digit is 1, 2, or 3. For N≧0, let f(N) be the minimum number of good integers when representing N as the sum of good integers. We have f(0)=0. Additionally, for convenience, we let f(N)=∞ for N<0. ◆ The structure of the sum of good numbers Let us first understand what kind of numbers can be represented as the sum of K good numbers. Let us represent each A i ​ as A i ​ =10a i ​ +b i ​ using the quotient and remainder when dividing it by 10. Then, A i ​ is good if and only if: b i ​ is 1, 2, or 3; and a i ​ is a good number or 0. Thus, a number can be written as the sum of K good numbers if and only if it can be written as the sum of the following: an integer between K and 3K; the sum of at most K good numbers, multiplied by 10. Using this fact, let us recursively compute f(N). ◆Computing f(N) Assume N≧1. Also, let us assume that f(N ′ ) is known for every N ′ <N to come up with a way to compute f(N). From the above statement, for each K=1,2,3,… in this order, we can determine whether N can be written as the sum of K good numbers in O(K) time. For example, we can: try all integers r between K and 3K; if there exists an integer n such that N=10n+r and it satisfies f(n)≦K, N can be written as the sum of K good numbers. We can do this check for each K in order and let f(N)=K when it first succeeds. ◆ The upper bound of the answer and analysis of complexity It turns out that f(N)≦5 for any N≧0. We can easily prove this by induction from the fact that we can always choose n and r such that N=10n+r and 5≦r≦15 when N≧5. We can find f(N) by doing the above check for K=1,2,3,4, which can be done in O(1) time under the assumption that f(N ′ ) is known for every N ′ <N. Additionally, we can see that f(N) is determined by two values f(n) and f(n−1), where n=⌊N/10⌋. Thus, we only need to compute f(n) sequentially for values that can be written as n=⌊N/10 k ⌋ or n=⌊N/10 k ⌋−1. There are Θ(logN) such numbers n, so we can solve the problem in Θ(logN) time per test case. D - Inc, Dec - Decomposition Editorial by evima We will explain two approaches. Θ(NlogN) solution by accelerating DP: this article Θ(N) solution by examining the structure of the optimal solution: https://atcoder.jp/contests/arc123/editorial/2321 ◆ Reorganizing the problem The problem asks us to choose the best set of 2n integers B i ​ and C i ​ , but fixing B i ​ will automatically fix C i ​ , so let us rephrase the problem into setting n integers. In the end, it turns out that we need to solve a problem in the following form: Given are constant numbers a i ​ and b i ​ . Find the minimum possible value of ∑∣x i ​ ∣+∣x i ​ −b i ​ ∣ when setting integers x 1 ​ ,x 2 ​ ,…,x N ​ so that x i ​ +a i ​ ≤x i+1 ​ holds. Below, we use these symbols x i ​ ,a i ​ ,b i ​ . ◆ Calculating the answer with DP Let dp n ​ (x) be the minimum possible value of ∑ 1≦i≦n ​ (∣x i ​ ∣+∣x i ​ −b i ​ ∣) when setting x 1 ​ ,…,x n ​ so that x i ​ +a i ​ ≤x i+1 ​ and x n ​ =x. The following recurrence formula culculates dp n ​ (x): dp 1 ​ (x)=∣x∣+∣x−b i ​ ∣ dp n+1 ​ (x)=min y≦x−a i ​ ​ dp n ​ (y)+∣x∣+∣x−b i ​ ∣ However, x can take infinitely many values in the first place, so we cannot directly maintain the value dp n ​ (x) for every x. Let us consider some other way to maintain information equivalent to dp n ​ (x). ◆ Functional representation based on changes in slope We can see that the functions dp n ​ that appear in the above process are convex functions that are concatenations of linear functions with integer slope. We can represent these functions using the set of coordinates where the slope changes, which enables us to efficiently process the operations on functions described below. This method of handling convex functions that are concatenations of linear functions is called the slope trick. Below are some references: https://maspypy.com/slope-trick-1-%e8%a7%a3%e8%aa%ac%e7%b7%a8 (Japanese) https://codeforces.com/blog/entry/47821 ◆ Operations needed in this problem Let us sort out the operations needed to obtain dp n+1 ​ from dp n ​ . Let f=dp n ​ and g=dp n+1 ​ . Remember that their relation can be represented as g(x)=min y≦x−a i ​ ​ f(y)+∣x∣+∣x−b i ​ ∣. We can decompose the process of obtaining g from f as follows: f 1 ​ (x)=f(x+a i ​ ) f 2 ​ (x)=min y≦x−a i ​ ​ f(y)=min y≦x ​ f(y−a i ​ )=min y≦x ​ f 1 ​ (y) g(x)=f 2 ​ (x)+∣x∣+∣x−b i ​ ∣ That is, we can obtain g from f by performing the following: translation; “accumulated” min; addition of the form ∣x−a∣. These are basic operations in the slope trick, which can be done efficiently with priority queues. The whole problem can be solved in Θ(NlogN) time. E - Training Editorial by evima ◆ Rephrasing the problem Let us use the symbols f(x),F(x),g(x),G(x) as follows. f(x)=A X ​ +x/B X ​ ,F(x)=⌊f(x)⌋ g(x)=A Y ​ +x/B Y ​ ,G(x)=⌊g(x)⌋ The problem asks the number of integers x that satisfies the following. 1≦x≦N F(x)=G(x) ◆Narrowing the range Below, we use symbols to represent intervals, such as [L,R)={x∈R∣L≦x<R}. It is not easy to guess that when F(x)=G(x), the real number f(x)−g(x) is close to 0. Translating this idea into formulae, we have the following: When f(x)∈(−∞,g(x)−1): F(x)=G(x) never holds. When f(x)∈[g(x)−1,g(x)): F(x)∈{G(x)−1,G(x)} holds. When f(x)∈[g(x),g(x)+1): F(x)∈{G(x),G(x)+1} holds. When f(x)∈[g(x)+1,∞): F(x)=G(x) never holds. Let us separately process these four cases to find the answer. Since f(x) and g(x) are functions of degree at most 1, we can easily find out what x goes to which of the four categories. ◆ Calculating the answer We end up with a problem in the following form. Given are integers L and R. It is known that F(x)∈{G(x)−1,G(x)} always holds for L≦x<R. Count the integers x in this interval such that F(x)=G(x). F(x) and G(x) seem to be easy to handle, while the difference F(x)−G(x) does not, since it involves a mixture of two cycles B X ​ and B Y ​ . Therefore, let us avoid directly handling F(x)−G(x) and try to find the answer by separately handling F(x) and G(x). Considering that F(x)∈{G(x)−1,G(x)} in our interval, we can see that we can count x such that F(x)=G(x) from ∑ L≦x<R ​ F(x) and ∑ L≦x<R ​ G(x). Furthermore, using facts such as ∑ L≦x<R ​ F(x)=∑ 0≦x<R ​ F(x)−∑ 0≦x<L ​ F(x), we will end up with the problem of calculating a formula in the form ∑ 0≦x<n ​ ⌊A+ B x ​ ⌋. One approach to this is to divide the interval into smaller ones with B elements each to reduce it to calculating the sums of arithmetic sequences, which can be done in Θ(1) time. There are also other approaches, such as using [AtCoder Library floor_sum] to calculate it in Θ(1) time. Reference: https://atcoder.jp/contests/practice2/tasks/practice2_c F - Insert Addition Editorial by evima First, the number of operations replacing A with f(A), N, is not very important. Let us assume that sufficiently many operations will be done. From now on, we do not refer to the number of operations. ◆ The coefficient sequence The inserting operations change the sequence A as follows. a,b a,a+b,b a,2a+b,a+b,a+2b,b a,3a+b,2a+b,3a+2b,a+b,2a+3b,a+2b,a+3b,b ⋮ As seen here, every term is in the form xa+yb, so let us consider the sequences of coefficients (x,y) for these elements. (1,0),(0,1) (1,0),(1,1),(0,1) (1,0),(2,1),(1,1),(1,2),(0,1) (1,0),(3,1),(2,1),(3,2),(1,1),(2,3),(1,2),(1,3),(0,1) ⋮ Below, we call these sequences of pairs coefficient sequences. The properties of the coefficient sequence We can show the following. [Property (1)] If (x 1 ​ ,y 1 ​ ) and (x 2 ​ ,y 2 ​ ) are adjacent in a coefficient sequence after some number of inserting operations, x 1 ​ y 2 ​ −x 2 ​ y 1 ​ =1. We can easily prove it by induction. Conversely, we can also show the following. [Property (2)] If x 1 ​ y 2 ​ −x 2 ​ y 1 ​ =1 holds for 0≦x 1 ​ ,y 1 ​ ,x 2 ​ ,y 2 ​ , (x 1 ​ ,y 1 ​ ) and (x 2 ​ ,y 2 ​ ) will be adjacent in a coefficient sequence after some number of inserting operations. We can easily prove it by, for example, induction on x 2 ​ +y 1 ​ . If x 2 ​ +y 1 ​ >0 and x 1 ​ y 2 ​ −x 2 ​ y 1 ​ =1, we can prove that one of the following holds. x 1 ​ ≦x 2 ​ and y 1 ​ ≦y 2 ​ ; x 1 ​ ≧x 2 ​ and y 1 ​ ≧y 2 ​ . In the former case, if we let (x 3 ​ ,y 3 ​ )=(x 2 ​ −x 1 ​ ,y 2 ​ −y 1 ​ ), we have x 3 ​ ,y 3 ​ ≧0 and x 1 ​ y 3 ​ −x 3 ​ y 1 ​ =1. From the inductive hypothesis, these mean that (x 1 ​ ,y 1 ​ ) and (x 3 ​ ,y 3 ​ ) will be adjacent in a coefficient sequence after some number of inserting operations. Then, the subsequent operation will insert (x 2 ​ ,y 2 ​ ) between them. Similarly goes the proof for the latter case. From these properties, we can also see the following. [Property (3)] A pair (x,y) of non-negative integers such that gcd(x,y)=1 will appear in a coefficient sequence after some number of inserting operations. [Property (4)] In a coefficient sequence at any point, pairs (x,y) will be in ascending order of y/x. (For (x,y)=(0,1), y/x is treated as \infty$.) ◆ The sequence B in other words In the end, the sequence B turns out to be the following. Among the pairs of non-negative integers x,y such that ax+by≦N, consider the ones that satisfy gcd(x,y)=1. Sort these pairs (x,y) in ascending order of y/x. Then, B i ​ =ax i ​ +by i ​ holds, where (x i ​ ,y i ​ ) is the i-th pair. ◆ Computing B n ​ Let us first solve the partial problem of computing one B n ​ . In combination with binary search, it will be reduced to the following counting problem. Given are positive integers a,b,N and a rational number c. Count the pairs of non-negative integers (x,y)  =(0,0) that satisfy all of the following conditions: ax+by≦N; gcd(x,y)=1; y/x≦c. Let us fix a,b,c and let f(N) denote the answer to the above counting problem. Additionally, let F(N) denote the answer when ignoring the condition gcd(x,y)=1. By classifying pairs (x,y) according to gcd(x,y)=d, we have F(N)=∑ d=1 N ​ f(⌊N/d⌋). (We have omitted the pair (x,y)=(0,0) to make this classification simpler.) From the Möbius inversion formula, we have f(N)=∑ d=1 N ​ μ(d)F(⌊N/d⌋), using which we can compute f(N). Since we can compute F(1),F(2),…,F(N) in a total of O(N) time using accumulated sums and so on, we can compute f(N) in O(N) time assuming that the Möbius function is precomputed. By combining it with binary search, we have found that we can compute one term B n ​ in O(NlogN) time. As a side note, assuming that the Möbius function is precomputed, we can also compute B n ​ in O(N 1/2 log 2 N) time, by computing each F(n) in O(logn) time using [AtCoder Library] floor_sum. ◆ Computing B L ​ ,…,B R ​ Considering how the sequence B is constructed, when B n ​ and B n+1 ​ are known, we can find B n+2 ​ in O(1) time. Thus, if we just compute B L ​ and B L+1 ​ , we can compute the remaining B i ​ in a total of O(R−L), solving the problem. We can also solve the problem by jointly listing the L-th through R-th coefficients (x,y) by combining binary searches on L and R, and then sorting these coefficients. ◆ Reference: The connection to the Farey sequences A Farey sequence is the sequence of completely reduced fractions between 0 and 1 whose denominators are at most N, in ascending order. Below are some of these sequences. For n=1: 1 0 ​ , 1 1 ​ For n=2: 1 0 ​ , 2 1 ​ , 1 1 ​ For n=3: 1 0 ​ , 3 1 ​ , 2 1 ​ , 3 2 ​ , 1 1 ​ For n=4: 1 0 ​ , 4 1 ​ , 3 1 ​ , 2 1 ​ , 3 2 ​ , 4 3 ​ , 1 1 ​ For n=5: 1 0 ​ , 5 1 ​ , 4 1 ​ , 3 1 ​ , 5 2 ​ , 2 1 ​ , 5 3 ​ , 3 2 ​ , 4 3 ​ , 5 4 ​ , 1 1 ​ It is known that the Farey sequences can be calculated as follows. (We can apply our arguments in “The properties of the coefficient sequence” almost as is.) Begin with 1 0 ​ , 1 1 ​ . Repeatedly insert x 1 ​ +x 2 ​ y 1 ​ +y 2 ​ ​ between x 1 ​ y 1 ​ ​ and x 2 ​ y 2 ​ ​ . This method is extremely similar to the computation of coefficient sequences in this article. Actually, we can associate the coefficient sequences with the Farey sequences by making a pair of non-negative integers (x 1 ​ ,y 1 ​ ) correspond to a fraction x 1 ​ +y 1 ​ x 1 ​ ​ . We will show another way to see the problem, with more awareness of the connection to the Farey sequences. First, since we can easily reduce it to the case gcd(a,b)=1, below we assume that it holds. From gcd(a,b)=1, we can take non-negative integers a ′ ,b ′ such that a ′ b−ab ′ =1. Instead of (a,b), let us consider two fractions (a ′ /a,b ′ /b). Then, if by inserting (y 1 ​ +y 2 ​ )/(x 1 ​ +x 2 ​ ) between y 1 ​ /x 1 ​ and y 2 ​ /x 2 ​ , the inserting operation in the problem can be identified with the insertion in the method to calculate the Farey sequences. Thus, the sequence B in the problem can be rephrased into the following. Arrange in ascending order the completely reduced fractions y/x between a ′ /a and b ′ /b whose denominators are at most N. Extracting just the denominators x from this will produce the sequence B. For example, if a=2,b=1,N=6, we have the following. The sequence B: (2,5,3,4,5,1) The list of completely reduced fractions between 1/2 and 1/1 whose denominators are at most 6, sorted in ascending order: ( 2 1 ​ , 5 2 ​ , 3 2 ​ , 4 3 ​ , 5 4 ​ , 1 1 ​ ) In the end, it has turned out that the problem is equivalent to the following. Of the list of completely reduced fractions between a a ′ ​ and b b ′ ​ whose denominators are at most N, sorted in ascending order, what are the denominators of the L-th through R-th terms? A - Many Formulae Editorial by evima We should do DP to find the number of ways to form a prefix of the formula so that A i ​ follows a + or a -. More specifically, we should let dp[i][j] to be the number of ways to arrange a total of i signs so that no two -s occur in a row and the last sign is + if j=0 and - if j=1. For each 2≤i≤N, if we fix the sign that comes just before A i ​ , we can independently decide the first i−2 signs and the last N−i signs, and we can find the number of ways to set them using the values in dp above. The complexity of this solution is O(N). B - Insurance Editorial by evima We should minimize the value of the function Nx−∑ i ​ (A i ​ −min(2x,A i ​ )). This function is convex downward, so a ternary search on x can do it. The complexity of this solution is O(Nlog(max(A i ​ )/ϵ)), where ϵ is the error tolerance. Alternatively, by considering the slope of the function, we can see that the function takes the minimum value at x=m/2, where m is the median of A i ​ . Thus, we can solve the problem in O(NlogN) time (by sorting A i ​ to find the median) or O(N) time (by using std::nth_element, for example). C - Calculator Editorial by evima Consider the following alternation: Operation 4→3→4→3→⋯. Let us say we did a total of S operations here. For convenience, we assume S to be even. For each i ( 0≤i≤S), consider inserting Operation 1 or 2 just after the i-th operation above. We can see the following: If i is even: doing Operation 1 once increases the final value of x by fib(S−i). If i is odd: doing Operation 2 once increases the final value of x by fib(S−i). Here, fib(n) denotes the Fibonacci number, where fib(0)=1, fib(1)=1, and fib(n)=fib(n−1)+fib(n−2) for 2≤n. Let us consider doing Operation 1 and 2 at most once in total for each i. In this case, we should choose the largest S such that fib(S)≤10 18 , since it does not help to choose a greater S. A calculation shows that we should choose S=86. What remains is to solve the problem of representing N as the sum of fib(S−i). We can solve it greedily: in ascending order of i, we should use the value whenever possible. Here, we will never take i and i+1 at the same time, since we would take i−1 instead in that case. Thus, we will do Operation 1 and 2 at most S/2+1=44 times in total (in reality, at most 43 times). Therefore, we will have at most 86+44=130 operations in total, which solves the problem. D - XOR Game Editorial by evima Consider whether the score gets v or smaller. If it is possible to divide A into N pairs so that the XOR of each pair is v or smaller, Bob can play according to such division to ensure that the score gets v or smaller. On the other hand, if there is no such division, the score will be at least v+1, since assuming otherwise leads to contradiction immediately. Thus, the problem becomes a matching problem where we should minimize the XORs of the pairs. Let L=30. First, consider whether the L-th lowest bit of the answer is 1. If we have an even number of integers whose L-th lowest bits are 0 and an even number of integers whose L-th lowest bits are 1, we can classify the integers according to that bit, and solve the same problem for each category where L:=L−1. Otherwise, we should make at least one pair of an integer whose L-th lowest bit is 0 and an integer whose L-th lowest bit is 1. On the other hand, if we make just one such pair, we can match 0 to 0 and 1 to 1 for the remaining pairs. Therefore, the problem is reduced to the one where we have two sets of integers X and Y, and we have to choose one element from each of the sets to minimize their XOR. We can solve it by building a trie. The total complexity of our solution is O(NL). E - Increasing LCMs Editorial by evima A i ​ can be at the end of x if and only if GCD(LCM j  =i ​ (A j ​ ),A i ​ )<A i ​ , which we can rewrite to LCM j  =i ​ (GCD(A j ​ ,A i ​ ))<A i ​ . If there is no such A i ​ , the answer is No. Otherwise, it turns out that we can arbitrarily choose one such A i ​ and make it the last element of x. We can see this from the following fact: if a solution exists, any solution will still be valid after moving A i ​ that satisfies the above condition to the end. Therefore, we can fix the elements of x one by one from the end. A naive implementation of this approach will still take just O(N 3 log(max(A i ​ ))) time, which is fast enough. F - Domination Editorial by evima We consider just the red stones that have no other red stones to the upper right. Without loss of generality, we assume RX 1 ​ <RX 2 ​ <⋯<RX N ​ and RY 1 ​ >RY 2 ​ >⋯>RY N ​ . First, for a given placement of blue stones, the following two conditions are equivalent. There are K or more blue stones to the upper right of each red stone. It is possible to divide the blue stones into K groups so that every group has a blue stone to the upper right of each red stone. It is obvious that the latter implies the former. We can prove that the former implies the latter by induction, considering the fact that the set of red stones covered by each blue stone forms an interval. Next, we consider the way to solve the problem for the case K=1. Let us first consider the cost to cover the red stones [l,r] for some given 1≤l≤r≤N. We will reduce it to the following problem: Consider a token that can move along the X- and Y-axes. Along the X-axis, the cost of moving by 1 in the positive/negative direction is 1/0. Along the Y-axis, the cost of moving by 1 in the positive/negative direction is 0/1. Additionally, for each blue stone j, it can jump from the point (0,BY j ​ ) along the Y axis to the point (BX j ​ ,0) along the X axis, for no cost. Then, the smallest cost needed to get from (0,RY l ​ ) to (RX r ​ ,0) is the cost to cover the red stones [l,r]. It is obvious that this reduction is valid. Here, for each 1≤i≤N−1, let us span an edge of cost 0 from (RX i ​ ,0) to (0,RY i+1 ​ ). We can see that the shortest route from RY 1 ​ to RX N ​ will then answer the problem for the case K=1. For a general K, we can simply find the minimum cost to send a flow of amount K in the same graph. Here, only the edges corresponding to the blue stones have the capacity of 1. The validity of this follows from the equivalent condition we stated in the beginning. The total complexity of our solution is O(K(N+M)log(N+M)). A - 2nd Greatest Distance Editorial by evima We have no time to compute each of the 2 N(N−1) ​ distances and sort them in O(N 2 logN) time. Let us make more use of the property of the distance. Consider finding the following: The greatest difference in x-coordinates of two houses The greatest difference in y-coordinates of two houses The second greatest difference in x-coordinates of two houses The second greatest difference in y-coordinates of two houses We can easily find the first two of them, and the second greatest difference in x-coordinates is one of the following: The second largest x-coordinate minus the smallest x-coordinate The largest x-coordinate minus the second smallest x-coordinate We can find the second greatest difference in y-coordinates similarly. Now, can we just print the second greatest value among the four differences? Unfortunately, it could be incorrect if the same pair of houses appears twice among them. To fix this issue, let us list all houses that appear in these four pairs, and find the distance between every pair of houses in the list. Since the list will contain at most 8 houses, an efficient implementation will work in O(N) time, which is fast enough. Sample Implementation (C++) Copy #include <algorithm> #include <iostream> #include <vector> #include <set> using ll = long long; using namespace std; const char EOLN = '\n'; int n; vector<vector<int>> a; set<int> ids; int main() { cin >> n; for (int i = 0; i < n; i++) { int x, y; cin >> x >> y; a.emplace_back(vector<int>{x, y, i}); } for (int k = 0; k < 2; k++) { sort(a.begin(), a.end()); for (int i = 0; i < 2; i++) { ids.emplace(a[i][2]); ids.emplace(a[n - 1 - i][2]); } for (auto &v : a) swap(v[0], v[1]); } vector<pair<int, int>> b; for (auto v : a) if (ids.count(v[2]) != 0) b.emplace_back(v[0], v[1]); vector<ll> d; for (int i = 0; i < b.size(); i++) for (int j = i + 1; j < b.size(); j++) d.emplace_back(max(abs(b[i].first - b[j].first), abs(b[i].second - b[j].second))); sort(d.begin(), d.end()); cout << d[d.size() - 2] << endl; return 0; } B - RGB Matching Editorial by evima If R, G, andB all appear even numbers of times, the answer is 0. Below, we assume R and G appear odd numbers of times and B appears an even number of times. (We can handle the other cases similarly.) Positive dissatisfactions only result from making pairs of RG, GB, BR. We can see that there is an optimal solution with at most one RG pair, at most one GB pair, and at most one BR pair. This is because if a solution has two RG pairs, for example, we can recompose two of them into an RR pair and a GG pair, which will not increase the total dissatisfaction. We can also see that there is an optimal solution with at most two pairs that are RG, GB, or BR. This is because if a solution has an RG pair, a GB pair, and a BR pair, we can recompose them into an RR pair, a GG pair, and a BB pair, which will not increase the total dissatisfaction. From these two facts and our assumption, we can see that one of the following is true for the optimal solution: It has one RG pair, and all other pairs are RR, GG, or BB. It has one GB pair and one BR pair, and all other pairs are RR, GG, or BB. To find the smallest dissatisfactions in these cases, we can simply find the smallest difference in cuteness between R and G, between G and B, and between B and R, because if the GB pair and the BR pair shares the same dog, it will not be better than making an RG pair. This solution will run fast enough in O(NlogN) time, since the bottleneck is sorting. C - Odd Even Sort Editorial by evima There are many possible solutions. Here, we will describe one of them. Let us focus on k=N,N−1,…,5 in this order. To bring k to the k-th position, let us only do swaps that move k to the right. If the parity is not matched in the beginning, we will do a swap somewhere that does not affect k (since k≥5, there is such a position). Then, we can repeatedly do swaps to move k to the k-th position. We can use similar tactics on k=4, but if we have (1,3,4,2,…) and the next swap is even-numbered, for example, not affecting k is impossible. In such a case, we will do swaps choosing 2→3→2→3 as i. For the remaining three, we can sort them in ascending order by alternating between the two operations, as follows: (1,2,3)→(2,1,3)→(2,3,1)→(3,2,1)→(3,1,2)→(1,3,2)→(1,2,3) This algorithm works in approximately 2 N(N+1) ​ swaps. It turns out that it also handles the case N=2,3,4 in not more than N 2 swaps. D - 1 or 2 Editorial by evima Assume that we can only choose to eat two candies at a time, and the total number of candies is even. Then, we can show that an optimal solution eats the candy with the i-th highest tastiness and the one with the i-th lowest tastiness together. This is because max(A+D,B+C)≤max(A+C,B+D)),min(A+C,B+D)≤min(A+D,B+C) holds for four integers A, B, C, and D such that A≤B≤C≤D. Eating one candy x is equivalent to adding a candy with the tastiness of 0 and then eating it together with x. From this, we can reduce the original problem to the version above. Therefore, we can solve the original problem by finding the smallest answer to the problem above when we add between 0 and N candies of the tastiness of 0. It can be done in O(N 2 ) time, which is fast enough. E - Directed Tree Editorial by evima The problem asks to count the ways to write numbers in the vertices satisfying the N conditions in the form: “Vertex i cannot have an index of a vertex that is a descendant of i.” Let us use the inclusion-exclusion principle. Then, for each of the 2 N subsets of conditions, we want to find the number of ways that violate all conditions in that subset. Let us just decide the positions violating the conditions and fill the other positions all at once in the end. Also, let dp(i,j) be the number of ways to write numbers in the subtree rooted at i so that j positions are violating the conditions. Then, the answer can be represented as ∑ j=0 N ​ (−1) j dp(1,j)(N−j)!. We can compute this DP table in O(N 2 ) time, which is fast enough. F - Logical Operations on Tree Editorial by evima Let us first consider the decision problem where the vertices and edges are already labeled. We say a tree is good when we can make the last remaining vertex labeled 1. The case N=1 is obvious. Let us handle the other cases. If a leaf is labeled 1, and the edge incident to that leaf is labeled OR, we can do the operation on this edge last to make the final vertex labeled 1, so it is a good tree. Below, we assume that the given tree does not have such a part. Then, there are three important facts, as follows: If a leaf is labeled 0 and the edge incident to that leaf is labeled AND, whenever we do the operation on this edge, the label of the vertex adjacent to the leaf will become 0. If the tree after doing this operation is good, the original tree is also good. If a leaf is labeled 0 and the edge incident to that leaf is labeled OR, whenever we do the operation on this edge, the label of the vertex adjacent to the leaf will not change. If the tree after doing this operation is good, the original tree is also good. If a leaf is labeled 1 and the edge incident to that leaf is labeled AND, whenever we do the operation on this edge, the label of the vertex adjacent to the leaf will not change. If the tree after doing this operation is good, the original tree is also good. From these facts, it can be seen that we can keep doing operations on leaves greedily to solve the decision problem. Below, let us consider the counting problem. Let the tree rooted at Vertex 1. Consider doing operations on the subtree rooted at Vertex i. If we get a 1-OR leaf during the operations, the tree is good, no matter how the remaining part of the tree is labeled. If we do not get such a leaf during the operation, we can leave the descendants of Vertex i deleted. That is, doing operations on the subtree leads to one of the following three states: The tree is confirmed to be good. 0 is written on Vertex i. 1 is written on Vertex i. Maintaining such states, we can do DP to solve the problem in O(N) time, which is fast enough. A - Max Add Editorial by evima Let us examine the way f(a) behaves. Let m be the maximum value of an element in a. Then, a 1 ​ gets added by m. Here, since we have a 1 ​ >0, a 1 ​ will now be the maximum element in a. Similarly, a i ​ will be the maximum element in a when it has just get added. Thus, we have f(a)=(a 1 ​ +m)+(a 2 ​ +(a 1 ​ +m))+(a 3 ​ +(a 2 ​ +(a 1 ​ +m)))⋯=nm+na 1 ​ +(n−1)a 2 ​ +(n−2)a 3 ​ +⋯+1⋅a n ​ , where n is the length of n. Now, let us consider compute f(a) each time after adding an element at the end of a. Assume that we are now adding x at the end of a whose current length is n. We should do the following re-calculation: We compute the term nm each time after updating m. The increase of n by 1 increases the value na 1 ​ +(n−1)a 2 ​ +(n−2)a 3 ​ +⋯+1⋅a n ​ by a 1 ​ +a 2 ​ +a 3 ​ +⋯+a n ​ , so we maintain this value and add it. We have a new term 1⋅a n+1 ​ =x, which we should add. In summary, we can solve the problem by updating the value f(a) while maintaining the sum and maximum value of A 1 ​ ,A 2 ​ ,A 3 ​ ,…,A i ​ , in O(N) time. B - Uniformly Distributed Editorial by evima Consider any 2×2 submatrix in the grid. Let (i,j),(i+1,j),(i,j+1),(i+1,j+1) be the squares in it, and consider the following two sequences of moves: (i,j)→(i,j+1)→(i+1,j+1) (i,j)→(i+1,j)→(i+1,j+1) For each of them, let us think of a way to get from (1,1) to (H,W) using it. Here, we arbitrarily choose the paths from (1,1) to (i,j) and from (i+1,j+1) to (H,W), but we just make sure we use the same ones. Then, we can see that (i,j+1) and (i+1,j) must have the same color. By applying it on all 2×2 submatrices, we obtain the following fact: All squares (i,j) with the same sum i+j must have the same color. One move increases i+j by 1, so we never visit multiple squares with the same sum i+j. Thus, the above condition is not just a necessary condition; it is a sufficient condition of the one in the statement. Thus, the answer is the product of the following over all sets of squares with the same sum i+j: 2 if they are all .; 0 if they contain both R and B (contradiction); 1 if none of the above holds. C - Swaps 2 Editorial by evima Let A i ′ ​ =A i ​ +i. Then, the operation swaps A i ′ ​ and A i+1 ′ ​ . Thus, we now want to solve the following problem after setting A i ​ ←A i ​ +i,B i ​ ←B i ​ +i: Determine whether it is possible to make A=B by repeatedly swapping A i ​ and A i+1 ​ for a chosen i. If it is possible, find the minimum number of operations needed. If A and B are not equal as sets, it is impossible to make A=B. Otherwise, if we decide a sequence s such that we will eventually bring A i ​ to B s i ​ ​ , the minimum number of operations needed to realize it is the inversion number of s, which we can find in O(Nlog(N)) time. The problem is that s is not uniquely determined since A and B may contain duplicates, but it turns out that we can find the optimal s as follows: Assume that the same value c appears as A i 1 ​ ​ ,A i 2 ​ ​ ,A i 3 ​ ​ ,…,A i n ​ ​ (i 1 ​ <i 2 ​ <i 3 ​ <⋯<i n ​ ) and B j 1 ​ ​ ,B j 2 ​ ​ ,B j 3 ​ ​ ,…,B j n ​ ​ (j 1 ​ <j 2 ​ <j 3 ​ <⋯<j n ​ ). We can freely rearrange s i 1 ​ ​ ,s i 2 ​ ​ ,s i 3 ​ ​ ,…,s i n ​ ​ . However, swapping s i ​ and s j ​ when i<j and s i ​ >s j ​ decreases the inversion number, so s i k ​ ​ =j k ​ obtained by repeating such an operation is optimal. D - Bracket Score 2 Editorial by evima Let us paint the largest N elements in A black and the rest white. (Ties are broken arbitrarily.) If all pairs of parentheses corresponding each other matches black and white elements, the score will be ( i=N+1 ∑ 2N ​ A i ′ ​ )−( i=1 ∑ N ​ A i ′ ​ ), where A ′ is the result of sorting A in ascending order, which is obviously the maximum possible score. It turns out that we can construct a parenthesis sequence that achieves it, as follows: Let S be the parenthesis sequence to construct. Maintain a stack a, which is initially empty. For each i=1,2,3,…,2N in this order, do the following: If a has an element of the color different from A i ​ , pop one from a, set the character in S at the position corresponding to the popped element to (, and set S i ​ to (. Otherwise, push A i ​ to a. (We postpone deciding S i ​ .) From the property of stack, a ( and a ) that are set at the same time will correspond to each other. Also, the two elements of A corresponding to such two parentheses obviously have different colors. a will not contain white elements and black elements at the same time, so a will be empty in the end, since there are equal numbers of black and white elements. Therefore, the procedure constructs a valid parenthesis sequence S that achieves the maximum possible score. E - 1D Party Editorial by evima It is optimal for each person to do one of the following action: Type 1: move to the left at a speed of 1 until meeting the person to the left, and then move to the right at a speed of 1. Type 2: move to the right at a speed of 1 until meeting the person to the right, and then move to the left at a speed of 1. Let us pair two people a and b such that the first person a meets is b and vice versa (that is, Person i and i+1 when they do actions of Type 2 and 1, respectively). Then, we can prove that we can ignore the scenario where there are two consecutive people that are not paired. At this point, we can solve the problem with one-dimensional dynamic programming in O(N) time. Below is the proof of the above fact. In the figure below, the horizontal axis is the number line, and the vertical axis corresponds to time. Green, red, purple, and yellow points and lines represent parts of the actions of People i−1,i,i+1,i+2, respectively. Here, we assume both People i and i+1 are unpaired. If Person i−1 is of Type 1, the green line represents their path after meeting Person i−2 and turning around. The yellow line represents the path of Person i+2 similarly, though it is horizontally flipped. We have assumed that both People i and i+1 are unpaired, so we can see that the situation here requires the party to be held until the time at the blue point, as follows: If People i and i+1 are of Type 1 and 1, respectively: People i+1 and i+2 will meet at the blue point. If People i and i+1 are of Type 1 and 2, respectively: People i and i+1 will meet at the blue point. If People i and i+1 are of Type 2 and 2, respectively: People i−1 and i will meet at the blue point. On the other hand, if we pair People i and i+1 here (that is, make them of Type 2 and 1, respectively), the situation here requires the party to be held until the time earlier than the blue point. Thus, it is not disadvantageous for us to pair two consecutive people that are unpaired. By repeatedly pairing such people, we can reach a situation without disadvantage where there is at most one person between a pair and the next pair. F - Wine Thief Editorial by evima Let us find the sequence b where b i ​ is the number of ways to steal bottles, including the i-th bottle from the left, without getting noticed by Takahashi. If we find it, the answer is i=1 ∑ N ​ A i ​ b i ​ . It would be easy if b 1 ​ =b 2 ​ =b 3 ​ =⋯=b N ​ . However, because the row of bottles has ends, the bottles have not much symmetry, besides the horizontal one. For now, let us consider a slightly different version of the problem where N bottles are arranged in a circle, that is, Bottles 1 and N are also adjacent. In this case, all N bottles are symmetric to each other, so b 1 ​ =b 2 ​ =b 3 ​ =⋯=b N ​ = N xK ​ , where x is the number of all ways to steal bottles without getting noticed. Let f(n,k) be the number of ways to steal k bottles from n bottles arranged in a circle, where no two stolen bottles are adjacent. Also, let g(n,k) be the number of ways to steal k bottles from n arranged in a line, where no two stolen bottles are adjacent. We can see that f(n,k) is equal to g(n−3,k−1)+g(n−1,k), by dividing such ways into the ones where Bottle 1 is stolen and the ones where it is not stolen. Additionally, g(n,k) is equal to the number of ways to arrange k black stones and n−k white stones so that no two black stones are adjacent. We can represent this number as k+1 ​ H n−k−(k−1) ​ using combination with repetition, by starting from a alternating row with k black stones and k−1 white stones and adding n−k−(k−1) white stones to it. Now, we have solved the circular version of the problem. If the bottles are arranged in a line, we can divide the ways to steal bottles into the following two categories: The ways that are also allowed in the circular version: As we discussed above, each of b 1 ​ ,b 2 ​ ,b 3 ​ ,…,b N ​ gets added by N f(N,K)K ​ . The ways that choose both Bottles 1 and N, which is not allowed in the circular version: Such ways contribute g(N−4,K−2) to each of b 1 ​ and b N ​ . The contributions to b 3 ​ ,b 4 ​ ,b 5 ​ ,…,b N−2 ​ can be recursively found by letting N←N−4,K←K−2. If we do pre-computation to enable ourselves to compute n ​ C r ​ in O(1) time, we can find f(n,r) and g(n,r) in O(1) time. Since there are O(N) recursions, if we efficiently do additions to ranges in b by, for example, using accumulated sums, we can compute b in O(N) time, allowing us to find the final answer. Watch out the corner cases such as N=K=1 that can appear during the recursive process. F2 - Wine Thief Editorial by evima Let F(n,k) be the number of ways to choose k bottles from n bottles. Also, for G(n,k,i), let G(n,k,i) be the number of ways among the above where the i-th bottle is chosen. Our objective is to find G(N,K,i) for every i. Consider D≤i≤N−D+1. G(N,K,i) is the number of ways to choose K−1 bottles from N bottles, with intervals of at least D, while not choosing the (i−D+1)-th, ⋯, (i+D−1)-th bottles. This is equal to the number of ways to choose K−1 bottles from N−D bottles, with intervals of at least D, while not choosing the (i−D+1)-th, ⋯, (i−1)-th bottles, which is F(N−D,K−1)−∑ i−D+1≤j≤i−1 ​ G(N−D,K−1,j). We can also build a similar formula for i≤D−1 and N−D+2≤i, but with slightly different ranges for j in ∑ j ​ G(N−D,K−1,j). Using these relations, we can construct the following algorithm: Define V(t)=(G(N−tD,K−t,1),G(N−tD,K−t,2),⋯,G(N−tD,K−t,N−tD)) and obtain V(0) by repeatedly finding V(t−1) from V(t) using the above formulae. Below, for convenience, we will see the sequence V(t) as the coefficient sequence of a polynomial and do operations for polynomials on it. Roughly speaking, we find V(t−1) from V(t) as follows: Multiply V(t) by ∑ 1≤i≤D−1 ​ −x i . Add to every term of V(t) a constant value ( =F(N−tD,K−t)). First, regarding 2., by maintaining data in the form “every term is added the value foo,” we do not have to perform real additions. However, it will cause a misalignment of values between the lowest D−1 terms and highest D−1 terms, so we will add a value negating it. This value to add is determined by the value foo and can be easily computed. Here, consider finding the answer without modifying the highest D−1 terms. Doing so will cause V(t) to hold incorrect values, of course. However, by symmetry, the effect of the modification of lower terms to the 1-st, 2-nd, ⋯, terms and that of the modification of higher terms to the N-th, (N−1)-th, ⋯, terms are identical. Thus, if we just find the effect of the modification of lower terms, we can also know that of the modification of higher terms by reversing it. In the end, we only need to: multiply V(t) by ∑ 1≤i≤D−1 ​ −x i and add to it a pre-computed polynomial with degree D−2.’ We can do it with a divide-and-conquer algorithm with FFT in O(Nlog(N)log(N/D)). Thus, our algorithm runs in a total of O(Nlog(N)log(N/D)) time. A - 119 × 2^23 + 1 Editorial by evima Note that when N=a×2 b +c and N≤10 18 , we only need to consider 60 values for b: from 0 to 59. (If b≥60 and N=a×2 b +c, a must be 0, so we can change b to 0 while still satisfying N=a×2 b +c.) We can try all of them and let a=⌊N÷2 b ⌋,c=N−⌊N÷2 b ⌋×2 b to minimize a+b+c for each of those values to find the minimum possible value of a+b+c. B - Electric Board Editorial by evima The operation does not change the number of 0s, so if S and T have different number of 0s, the objective is unachievable. Otherwise, assume that the 0s in S are its a 1 ​ -th, a 2 ​ -th, ⋯, a K ​ -th characters, and the 0s in T are its b 1 ​ -th, b 2 ​ -th, ⋯, b K ​ -th characters. We will show that the answer is equal to the number of indices i (1≤i≤K) such that a i ​  =b i ​ . First, we need at least this number of operations because one operation changes only one of a 1 ​ ,a 2 ​ ,⋯,a K ​ . (Illustration of the operation) Additionally, we can achieve the objective in this number of operations with, for example, the following strategy: If there exists i such that a i ​ >b i ​ : Let p be the minimum i such that a i ​ >b i ​ . Use the operation to change a p ​ to b p ​ . Otherwise: Let q be the maximum i such that a i ​ <b i ​ . Use the operation to change a q ​ to b q ​ . (Illustration of the strategy) (The sentences to the left says “The minimum i such that a i ​ >b i ​ is 4”, “The maximum i such that a i ​ <b i ​ is 3”, and the one to the right says “We have one less i such that a i ​  =b i ​ !”) C - ARC Wrecker 2 Editorial by evima We will show that the objective for the segment [l,r] is achievable if and only if the following condition holds: Condition 1: A l ​ +A l+2 ​ +A l+4 ​ +⋯=A l+1 ​ +A l+3 ​ +A l+5 ​ +⋯. First, CoCondition 1 1 is necessary because the operation does not change the difference (A l ​ +A l+2 ​ +A l+4 ​ +⋯)−(A l+1 ​ +A l+3 ​ +A l+5 ​ +⋯). (Illustration of the operation) (The sentence at the top right says “No matter what we do, the difference doesn’t change,” and “奇数” and “偶数” means odd numbers and even numbers (positions).) To show the sufficiency of Condition 1, note that we can ignore the following restriction of the second operation without affecting the achievability of the objective. This operation can only be done when both of those buildings have heights of 1 or greater. This is because if there is a sequence of operations that achieves the objective but violates this restriction, we can make it obey the restriction by changing the order of the operations so that all “increase” operations happen before all “decrease” operations. Ignoring this restriction, we can successively make the heights of the buildings 0 from left to right. When we have made the heights of Buildings l,l+1,⋯,r−1 all zero, the height of Building r will be A r ​ −A r−1 ​ +A r−2 ​ −A r−3 ​ +⋯, which is also 0 when Condition 1 holds. (Illustration of the strategy) (The sentence at the top-left says “Doing operations from left to right…”, the one at the top-right says “1 - 3 + 1 - 2 + 3 = 0 so we can make the heights all zero!”, and “ビル 1・2 に操作を行った” means “done operations on Buildings 1, 2.”) Now that we have proven that the answer is the number of pairs (l,r) satisfying Condition 1, let us rephrase it into the following: Condition 2: Define a sequence B=(B 1 ​ ,B 2 ​ ,⋯,B N ​ ) as follows: B i ​ =A i ​ if i is odd; B i ​ =−A i ​ if i is even. Then, B l ​ +B l+1 ​ +⋯+B r ​ =0 holds. Furthermore, let us rephrase it again into the following: Condition 3: Define a sequence C by C i ​ =B 1 ​ +B 2 ​ +⋯+B i ​ . Then, C r ​ −C l−1 ​ =0 holds. Now, the problem simply asks us to count pairs (i,j) [0≤i<j≤N] such that C i ​ =C j ​ . We can solve it using an associative array such as std::map, or using sorting to “compress” the values. D - Grid Repainting 3 Editorial by evima We can rephrase the problem as follows: We have a bipartite graph with yellow vertices 1,2,⋯,H and grey vertices 1,2,⋯,W. The edges in this graph correspond to red squares throughout the process. That is, initially, there is an edge connecting yellow vertex i and grey vertex j bidirectionally if and only if c i,j ​ =R, and you can do the following: Operation X: Choose a yellow vertex with degree 1 or above and erase all edges incident to it. Operation Y: Choose a grey vertex with degree 1 or above and erase all edges incident to it. The number of white squares will be HW−(H−X)(W−Y), where X and Y are the number of times Operation X and Y are done, respectively. Find one way to maximize this count. For example, the following grid: Copy RRR BBR BBR BRR RRR BBR BBR BRR corresponds to the following graph: (“操作前”: “Before the operations”, “操作 X/Y を行う”: “Do Operation X/Y”) First, let us consider the case the graph is a tree. We will first prove it is impossible to erase all vertices, by contradiction. Assume it is possible to erase all of them. In such a case, there would be a moment where there is just one vertex. However, the degree of that vertex would be 0 at that moment, so we would be unable to do any operation, leading to a contradiction. On the other hand, it is possible to erase all but one vertex, by repeatedly erasing a vertex with degree 1. This is possible because a tree always has a vertex with degree 1, and erasing it does not disconnect the tree, so we can continue doing it until the graph has no edge, when it has just one vertex. Since we can choose which vertex to erase in the final operation, we have two optimal choices: Do Operation X H times and Operation Y W−1 times. Do Operation X H−1 times and Operation Y W times. (Illustration of an example) (The yellow sentence to the left says, “Note that although all squares become white, the number of operations is not ‘full’ ( H+W).”) Next, let us consider the case the graph is forest. Let K be the number of connected components with two or more vertices. If the i-th connected component contains a i ​ yellow vertices and b i ​ gray vertices, it is optimal to do one of the following actions: Type A: Do Operation X a i ​ times and Operation Y b i ​ −1 times. Type B: Do Operation X a i ​ −1 times and Operation Y b i ​ times. Since we can make this choice for each connected component independently, the total numbers of operations will be one of the following: Do Operation X (a 1 ​ +a 2 ​ +⋯+a K ​ ) times and Operation Y (b 1 ​ +b 2 ​ +⋯+b K ​ )−K times. Do Operation X (a 1 ​ +a 2 ​ +⋯+a K ​ )−1 times and Operation Y (b 1 ​ +b 2 ​ +⋯+b K ​ )−(K−1) times. Do Operation X (a 1 ​ +a 2 ​ +⋯+a K ​ )−2 times and Operation Y (b 1 ​ +b 2 ​ +⋯+b K ​ )−(K−2) times. ⋮ Do Operation X (a 1 ​ +a 2 ​ +⋯+a K ​ )−K times and Operation Y (b 1 ​ +b 2 ​ +⋯+b K ​ ) times. Now, let x be the number of times we do the type-A action. Then, the number of white squares, f(x), is represented by the following quadratic function: f(x)=HW−(H−(a 1 ​ +a 2 ​ +⋯+a K ​ −x))(W−(b 1 ​ +b 2 ​ +⋯+b K ​ −(K−x))). Since it is convex downward, the optimal choice is one of the following: Do the type-A action for every connected component. Do the type-B action for every connected component. For example, in the case shown in the figure below, we can achieve the maximum number of white squares, 76, by entirely resorting to the type-A action. (Illustration of an example) (“操作Xの回数”: “count of Operation X”, “白の個数”: “number of white squares”) Finally, let us consider the problem for a general graph. It turns out that adding edges to trees does not change the answer, because it is impossible to erase all vertices in a connected component, whatever the graph is. Thus, we can extract a spanning tree from each component using a Union-Find tree, for example, and ignore the remaining edges without changing the final number of white squares. Then, we will have a forest, and we have already solved this case. (“最大白マス数”: “maximum number of white squares”. The bottom sentence says, “Adding edges to trees do not change the answer, as long as the connected components remain the same!”) Summary of the solution: Step 1: Rephrase the problem on a grid to a problem on a bipartite graph. Step 2: Construct the bipartite graph according to the grid. Step 3: For each connected component, extract its spanning tree and ignore the remaining edges. Step 4: Based on the sizes of the connected components, choose to do the Type-A or Type-B action all the time. Step 5: For each connected component, implement the chosen action by repeatedly erasing a vertex with degree 1, or in some other proper way. It has the time complexity of O(HW). In Step 5, we can naively search a vertex with degree 1 in O(H+W) time for each operation and still make it run in time, since there will be at most H+W operations. E - Pancakes Editorial by evima First, let us observe the change caused by a reversion to the tower and its ugliness: As seen in this figure: Inside the reversed segment, the total difference of sizes does not change, since they just get reversed. Outside the reversed segment, the total difference of sizes does not change. At both ends of the reversed segment, the differences of sizes do change. Thus, when evaluating the change in the ugliness caused by a reversion, we only need to consider the changes at both ends of the reversed segment. For example, in the figure above, the ugliness changes from 17 to 13 because the differences at both ends of the reversed segment change from 6,3 to 4,1. More specifically, we can calculate the change in the ugliness as follows. Basically, the ugliness decreases by ∣A l−1 ​ −A l ​ ∣+∣A r ​ −A r+1 ​ ∣−∣A l−1 ​ −A r ​ ∣−∣A l ​ −A r+1 ​ ∣, because the difference at the left end changes from ∣A l−1 ​ −A l ​ ∣ to ∣A l−1 ​ −A r ​ ∣ and the right end changes from ∣A r ​ −A r+1 ​ ∣ to ∣A l ​ −A r+1 ​ ∣. However, it is slightly different if l=1 or r=N, as follows. If l=1 and r  =N: the ugliness decreases by ∣A r ​ −A r+1 ​ ∣−∣A l ​ −A r+1 ​ ∣, since there is no pancake at the left end. If l  =1 and r=N: the ugliness decreases by ∣A l−1 ​ −A l ​ ∣−∣A l−1 ​ −A r ​ ∣, since there is no pancake at the left end. If l=1 and r=N: the ugliness does not change, since the whole tower just gets reversed. Now, for each choice of l,r, we can find the resulting ugliness in constant time, but we have no time to try all O(N 2 ) choices. Let us find a more efficient way to find the optimal choice. As we seen above, the change in the ugliness depends only on the sizes of the four pancakes at both ends of the reversed segment: A l−1 ​ ,A l ​ ,A r ​ ,A r+1 ​ . Let us consider the correlation between their magnitude relation and the change in the ugliness. As shown below, there are six possible magnitude relations between A l−1 ​ ,A l ​ ,A r ​ ,A r+1 ​ , when we do not distinguish two relations that are the same after flipping one of them horizontally, vertically, or both. The yellow part marks the differences in sizes of pancakes, which contribute to the difference in the ugliness. Which of these six patterns decrease the ugliness? In patterns 1 and 2, both yellow parts get longer, so the ugliness increases. In patterns 3 and 4, one of the yellow parts gets shorter, but the other gets longer by the same amount, so the ugliness does not change. In patterns 5 and 6, both yellow parts get shorter, so the ugliness decreases. Thus, the ugliness decreases in patterns 5 and 6. Additionally, it decreases by the length of the intersection of the two yellow parts, multiplied by 2. Let us sort out our findings: If A l−1 ​ <A l ​ and A r ​ <A r+1 ​ : If the segment A l−1 ​ ≤x≤A l ​ and the segment A r ​ ≤x≤A r+1 ​ have an intersection, the ugliness decreases by its length multiplied by 2. If A l−1 ​ >A l ​ and A r ​ >A r+1 ​ : If the segment A l ​ ≤x≤A l−1 ​ and the segment A r+1 ​ ≤x≤A r ​ have an intersection, the ugliness decreases by its length multiplied by 2. If neither of the above holds, the ugliness does not decrease. Thus, to maximize the decrease in the ugliness, we need to choose l,r with the longest intersection. Now, let us consider the following problem: Problem: Longest Intersection You are given M segments; the i-th segment is L i ​ ≤x≤R i ​ . You will choose two of them. Find the maximum possible length of the intersection of the chosen segments. If no two segments have an intersection, your answer should be 0. If we can solve this problem, we can find the answer as follows: Find Z 1 ​ , the Longest Intersection among all the segments A i ​ ≤x≤A i+1 ​ for all positions where A i ​ <A i+1 ​ . Find Z 2 ​ , the Longest Intersection among all the segments A i+1 ​ ≤x≤A i ​ for all positions where A i ​ >A i+1 ​ . Then, the maximum possible decrease for the case l  =1,r  =N is max(2Z 1 ​ ,2Z 2 ​ ). For the case l=1 or r=N, we can try all possible choices, since there are not many of them. Now, what remains is to solve Longest Intersection. We will describe one way to solve Longest Intersection in O(MlogM) time. The intersection of Segment i, L i ​ ≤x≤R i ​ , and Segment j, L j ​ ≤x≤R j ​ , is max(L i ​ ,L j ​ )≤x≤min(R i ​ ,R j ​ ). We want to find i,j that maximize its length. Now, let us sort L i ​ and assume L 1 ​ ≤L 2 ​ ≤⋯≤L M ​ . Then, the intersection of Segments i,j (i<j) is L j ​ ≤x≤min(R i ​ ,R j ​ ). Thus, for a fixed j, the length of the intersection is maximized by choosing the i with the maximum R i ​ . For example, in the figure below, the optimal choice for j=4 is i=2 (resulting in the intersection L 4 ​ =25≤x≤48=R 2 ​ ), and the optimal choice for j=7 is i=5 (resulting in the intersection L 7 ​ =37≤x≤65=R 7 ​ ). Therefore, the following algorithm finds the Longest Intersection: Sort the M segments in ascending order of L i ​ . For each j=2,3,⋯,M, in this order, compute the longest intersection when j is fixed to that value: L j ​ ≤x≤min(R j ​ ,max(R 1 ​ ,R 2 ​ ,…,R j−1 ​ )). The answer is the longest of all those intersections, or 0 if there is no such intersection. Here, we can cumulatively find the values max(R 1 ​ ,R 2 ​ ,…,R j−1 ​ ), so the bottleneck of this algorithm is sorting, resulting in the complexity of O(MlogM). Summary of the solution: The change in ugliness depends only on the two ends of the reversed segment, and is ∣A l−1 ​ −A l ​ ∣+∣A r ​ −A r+1 ​ ∣−∣A l−1 ​ −A r ​ ∣−∣A l ​ −A r+1 ​ ∣ (when 2≤l<r≤N−1). The ugliness decreases only when A l−1 ​ <A l ​ and A r ​ <A r+1 ​ , or A l−1 ​ >A l ​ and A r ​ >A r+1 ​ , by the length of the intersection of the segment with endpoints A l−1 ​ and A l ​ and the segment with endpoints A r ​ and A r+1 ​ , multiplied by 2. If we separately deal with the case A i ​ <A i+1 ​ and the case A i ​ >A i+1 ​ , our objective is to find the longest intersection of two segments chosen from M segments. We can find the longest intersection in O(MlogM) time. One way to do this is to sort the segment in ascending order of L i ​ , the left end. This solution solves the problem in O(NlogN) time. F - AtCoder Express 3 Editorial by evima We will consider a dynamic programming approach. However, it would be hard to do it based on a breadth-first search to find the shortest path from Station 0 to N, since it would require us to maintain a complex state. Thus, we will develop an easier way to find the shortest path, and then use it to build a dynamic programming solution. For convenience, we will call stations and railways administered by Ko-soku red, and those administered by Jun-kyu blue. First, we will develop a way to find the shortest path when the color of every station is fixed. For now, let us assume that we never go back, that is, we only go from Station x to Station y where x<y. In such a case, the following algorithm finds the shortest path from Station 0 to N. For i=1,2,⋯,N−1, in this order, update the value (α,β). Initially, (α,β)=(0,0). (They are the lengths of the shortest paths to the last red station and the last blue station.) If c i ​ is A and c i−1 ​ is A: update α to α+1. If c i ​ is A and c i−1 ​ is B: update α to min(α,β)+1. If c i ​ is B and c i−1 ​ is A: update β to min(β,α)+1. If c i ​ is B and c i−1 ​ is B: update β to β+1. (If i=1, assume c i−1 ​ to be A or B; whichever you choose, the value of (α,β) will be the same. Then, the length of the shortest path to Station N is min(α,β)+1. Unfortunately, there are cases the shortest path does not satisfy the assumption. The figure below shows one such case where the shortest path has a backward move: However, when the shortest path goes backward, it is always by Local Train. Additionally, such a backward move never happens twice in a row in the shortest path. This is because going backward by Red or Blue Train, or by Local Train twice in a row, would result in stopping at the same station twice or more, which should not happen in the shortest path. The figure below transforms the network to make it easier to see this fact: It means we can slightly modify the algorithm above to compute the shortest path, as follows: For i=1,2,⋯,N−1, in this order, update the value (α,β). Initially, (α,β)=(0,0). (They are the lengths of the shortest paths to the last red station and the last blue station.) If c i ​ is A and c i−1 ​ is A: update α to α+1. If c i ​ is A and c i−1 ​ is B: update α to min(α,β)+1, then use the new value of α to update β to min(β,α+1). If c i ​ is B and c i−1 ​ is A: update β to min(β,α)+1, then use the new value of β to update α to min(α,β+1). If c i ​ is B and c i−1 ​ is B: update β to β+1. (If i=1, assume c i−1 ​ to be A or B; whichever you choose, the value of (α,β) will be the same. Then, the length of the shortest path to Station N is min(α,β)+1. The figure below shows the behavior of this algorithm on some network, where a number represents the length of the shortest path to that point. In the case to the left, the bold edge is traversed from left to right; in the case at the center, the bold edge is irrelevant; in the case to the right, the bold edge is traversed from right to left. In all of those cases, each of the red and blue layers is one-way, enabling us to sequentially update (α,β). Now, let us use this algorithm to build a dynamic programming solution. We need the following information in the DP: pos, the index of the last station we have seen. α, the length of the shortest path to the last red station. β, the shortest length of the shortest path to the last blue station. pos, the color of the last station pos. (Use 0 for red and 1 for blue.) Let dp[pos][α][β][pre] store the number of ways to set the colors of the stations until Station pos leading to the state (pos,α,β,pre), where pre is 0 if the last station pos is red and 1 if it is blue. Since we are allowed to let pre=0 in the beginning, we can assume that the initial state is (pos,α,β,pre)=(0,0,0,0). Similarly to the algorithm above, the transitions from (pos,α,β,pre) are as follows: If pre=0: (the last station is red) if c pos+1 ​ is A or ?, the state can transition to (pos+1,α+1,β,0); if c pos+1 ​ is B or ?, the state can transition to (pos+1,min(α,min(β,α)+1+1),min(β,α)+1,1)=(pos+1,min(α,β+2),min(β,α)+1,1). If pre=1: (the last station is blue) if c pos+1 ​ is A or ?, the state can transition to (pos+1,min(α,β)+1,min(β,min(α,β)+1+1),0)=(pos+1,min(α,β)+1,min(β,α+2),0); if c pos+1 ​ is B or ?, the state can transition to (pos+1,α,β+1,1). We can fill the table in this way to find the answer as the sum of dp[N−1][α][β][pre] over all triples (α,β,pre) such that min(α,β)<K, in O(N 3 ) time, which is not fast enough. The above DP has O(N 3 ) states, which must be reduced to make it run fast enough. Now, see the following figure, where α=4 stays the same but β gets greater and greater: β=4,5,6,7,8,9,…. We needed to store values for many pairs (α,β) because of such a case. However, if the next station is red, β will be updated to 6, no matter how large it is. That is, as shown in the figure below, we can assume β=6 when β becomes 6 or greater, without affecting the final length of the shortest path. More generally, the following holds: If pre=0, we can assume α=β+2 if α≥β+2, making −2≤β−α≤+1 always hold. If pre=1, we can assume β=α+2 when β≥α+2, making −1≤β−α≤+2 always hold. It limits the pairs (α,β) to consider, and now our DP table has approximately 8N 2 states (pos,α,β,pre). In the actual implementation, we will have to maintain values as dp[pos][α][β−α+2][pre] or in some other way. Now the problem is solved in O(N 2 ) time. Summary of the solution: Let dp[pos][α][β][pre] be the number of ways to set the colors of the stations until Station pos so that the length of the shortest path to the last red and blue stations are α and β, respectively, and the color of the last station is pre. Try to find these values sequentially. We may need to move backward, but we only have to do so by Local Train, and at most once in a row, so we can update (α,β) accordingly, leading to an O(N 3 ) solution. Actually, we can assume β=α+2 when β−α≥2, and assume α=β+2 when α−β≥2, which reduces the number of states to O(N), leading to an O(N 2 ) solution. (By multiplying polynomial matrices with FFT, we can modify our O(N 2 ) solution so that it runs in O(Nlog 2 N) time. However, it would be practically much slower than the original because of the huge constant factor.) A - Tax Included Price Editorial by evima Let f(A) denote the tax-included price of an integer A. ◆Solution 1: Using Periodicity When A increases by 100, 100 100+t ​ A increases by 100+t, so we have f(A+100)=f(A)+(100+t). From this, we can see that the property of whether a positive integer x can be the tax-included price of some integer has a period of 100+t. For example, if the tax rate is 3 percent as in 【Sample Input 2】, the values that cannot be the tax-included price of any integer are: (34,68,102),(137,171,205),(240,274,308),… They start with values less than 100+t=103, (34,68,102), and have a period of 103. In the end, we can solve the problem as follows: Compute f(1),…,f(100) to find out which of the values at most 100+t cannot be the tax-included price of any integer. Let us say that the N-th smallest value that cannot be the tax-included price of any integer is the x-th value in the y-th period. Find x and y to compute the answer. This solution solves the problem in O(1) time. 【Sample Implementation】 https://atcoder.jp/contests/arc118/submissions/22160671 (Python, O(1) time) ◆Solution 2: Using Binary Search by Counting For example, if the tax rate is 10 percent, f(100)=110. Since different integers are sold for different tax-included prices, there are 100 values among 1,2,…,110 that can be the tax-included price of some integer, and 10 values among 1,2,…,110 that cannot be the tax-included price of any integer. In this way, we can count the values not exceeding a certain value that cannot be the tax-included price of any integer in O(1) time: there are f(A)−A such values not exceeding f(A). Using this fact and binary search, we can compute the maximum A satisfying the following: there are less than N values not exceeding f(A) that cannot be the tax-included price of any integer. We can also see that we can use 100N as the upper limit for this binary search from the above observation. Then, the answer is greater than f(A) and less than f(A+1). From the fact that f(A+1)≤f(A)+2 under t≤100, the answer is f(A)+1. This solution solves the problem in O(logN) time. 【Sample Implementation】 https://atcoder.jp/contests/arc118/submissions/22160677 （Python, O(logN) time） Regarding Computation Errors We may not be able to compute f(A) correctly if we do so in the following manner: first, find x=(100+t)/100×A; then, find ⌊x⌋. For example, the codes below result in x=112, which is incorrect. x = int(113 / 100 * 100) in Python; int x = 113 / 100.0 * 100; in C++. If a real number x is exactly an integer, ⌊x⌋  =⌊x−ε⌋ holds for any positive integer ε>0, so the value ⌊x⌋ may be incorrectly computed even if we compute x within the absolute error of ε. This problem cannot be resolved, no matter how much the precision of computation is increased. If we need the exact value after truncating, we need to compute it in a different method. In this problem and under the constraints, we can compute f(A) correctly if we do so in the following manner: using integer division rounding down to divide (100+t)×A by 100; calculating x=(100+t)/100×A as a fraction and then adding a small value before truncating (for example, calculate ⌊x+0.001⌋ instead of ⌊x⌋). B - Village of M People Editorial by evima ◆Solution 1: Using Binary Search Since ∣ ∣ ∣ ​ M B i ​ ​ − N A i ​ ​ ∣ ∣ ∣ ​ = NM 1 ​ ∣NB i ​ −MA i ​ ∣, let us think of minimizing max i ​ ∣NB i ​ −MA i ​ ∣ instead. Examining the Decision Problem Let us use binary search to find the minimum possible value of max i ​ ∣NB i ​ −MA i ​ ∣. For that, we want to solve the decision problem of whether there is an integer sequence B satisfying the following for a constant x: max i ​ ∣NB i ​ −MA i ​ ∣≤x; B i ​ is an non-negative integer satisfying ∑B i ​ =M. max i ​ ∣NB i ​ −MA i ​ ∣≤x is equivalent to ∀i,∣NB i ​ −MA i ​ ∣≤x. Here the condition is independent for each i, which is the good point of converting the problem into a decision one. Moreover, from the following: ∣NB i ​ −MA i ​ ∣≤x⟺MA i ​ −x≤NB i ​ ≤MA i ​ +x⟺⌈ N MA i ​ −x ​ ⌉≤B i ​ ≤⌊ N MA i ​ +x ​ ⌋ after setting the values L i ​ ,R i ​ properly, the problem is reduced to determine whether there is an integer sequence B satisfying the following: L i ​ ≤B i ​ ≤R i ​ B i ​ is an non-negative integer satisfying ∑B i ​ =M. Solution of the Decision Problem For B to exist, it is necessary that ∑L i ​ ≤M≤∑R i ​ . On the other hand, under this necessary condition, we can prove the existence of a sequence B satisfying the condition, which can be actually built as follows: First, set the sequence B i ​ to B i ​ =L i ​ . For each i=1,2,…,K in this order, do the following: make B i ​ as large as possible while making sure that the sum of B is at most M and B i ​ ≤R i ​ . Let us confirm it. First, in the above steps, we can easily see that: L i ​ ≤B i ​ ≤R i ​ always holds; the sum of B monotonically increases throughout the algorithm and does not exceed M. From the monotonicity, what remains is to show that it is never the case that the sum of B is always less than M. If it is the case, each step of the algorithm chooses B i ​ =R i ​ , leading to the final sequence of B=(R 1 ​ ,…,R K ​ ). However, we have assumed that M≤∑R i ​ , so this result contradicts the assumption of the sum of B always being less than M. Summary We have seen that we can determine whether max i ​ ∣NB i ​ −MA i ​ ∣≤x can be realized by computing L i ​ ,R i ​ and checking if ∑L i ​ ≤M≤∑R i ​ holds. Thus, we can solve the decision problem in O(K) time, and doing so in the binary search finds the minimum possible value of max i ​ ∣NB i ​ −MA i ​ ∣ in O(KlogNM) time. The problem also asks to construct a sequence B that achieves the minimum value, which can also be done in O(K) time in the method described above. Therefore, we can solve the problem in O(KlogNM) time. 【Sample Implementation】 https://atcoder.jp/contests/arc118/submissions/22249436 (Python, O(KlogNM) time) ◆Solution 2: Greedy Strategy By improving the above solution, we can also directly construct the solution. The problem is easy if B i ​ does not have to be an integer; in that case, we should set B i ​ = N MA i ​ ​ . From this, can we make the following conjecture? B i ​ in the optimal solution is the integer nearest to N MA i ​ ​ on either side. The optimal solution satisfies max i ​ ∣ ∣ ∣ ​ B i ​ − N MA i ​ ​ ∣ ∣ ∣ ​ <1. We will begin by proving them and narrow the range to be searched. Narrowing the Solution Space In the decision problem in Solution 1, let us set x=N−1. Remember that we can solve the problem as follows: let L i ​ =⌈ N MA i ​ −N+1 ​ ⌉, R i ​ =⌊ N MA i ​ +N−1 ​ ⌋; if ∑L i ​ ≤M≤∑R i ​ , B exists. We can prove that this condition ∑L i ​ ≤M≤∑R i ​ always holds. Actually, from L i ​ =⌊ N MA i ​ ​ ⌋ and R i ​ =⌈ N MA i ​ ​ ⌉, we can see that L i ​ ≤ N MA i ​ ​ ≤R i ​ . From this and ∑ N MA i ​ ​ =M, the condition always holds. This means that, to find the optimal B, we only need to search it from the sequences satisfying L i ​ ≤B i ​ ≤R i ​ . It follows from R i ​ <L i ​ +2 that B i ​ ∈{L i ​ ,L i ​ +1}: we have two choices for each B i ​ that need to be checked. Rephrasing the Problem and Taking a Greedy Strategy Now, let B i ​ =L i ​ +x i ​ and rephrase the problem into the choices of x i ​ ∈{0,1}. Since ∣NB i ​ −MA i ​ ∣=∣N(L i ​ +x i ​ )−MA i ​ ∣=∣Nx i ​ +(NL i ​ −MA i ​ )∣, let C i ​ =NL i ​ −MA i ​ and n=M−∑L i ​ to reduce the problem into the following: Given is a sequence C=(C 1 ​ ,…,C K ​ ). Among the ways to choose n of the indices i and adding N to C i ​ for each chosen i, find the one that minimizes max∣C i ​ ∣. If n≥1, among the optimal solutions, there exists one that chooses the minimum C i ​ . This is because if the minimum C i ​ is not chosen in some solution, we can change one of the choices to C i ​ without making max∣C i ​ ∣ larger. By making a similar observation in the situation with the remaining K−1 numbers and n−1 choices, we can see that an optimal solution chooses the two smallest C i ​ if n≥2. Continuing this way, we can see that the problem above can be solved with the following greedy algorithm: choose the n smallest elements C i ​ for adding N. Summary We can solve the problem as follows: Let L i ​ =⌊ N MA i ​ ​ ⌋, C i ​ =NL i ​ −MA i ​ , n=M−∑L i ​ . Let B i ​ =L i ​ . Choose the n smallest elements from C i ​ and add 1 to B i ​ for each chosen i. The sequence B i ​ we have now is one of the optimal solution. This can be done in O(KlogK) time with sorting, or in O(K) time with a linear time selection algorithm. 【Sample Implementation】 https://atcoder.jp/contests/arc118/submissions/22249102 (Python, O(K) time) C - Coprime Set Editorial by evima The problem is basically harder for larger N, so let us think of a way to make N larger. ◆Basic Strategy If a set A={a 1 ​ ,…,a n ​ } satisfies the conditions, it will still satisfy them after we add a multiple of a i ​ to it. For example, let us start with Sample Output 1: A={84,60,105,70}. We can add multiples of 84 and multiples of 60 while still satisfying the conditions. After making as many additions as possible, we can achieve N=429: the set of all numbers that are multiples of 84, 60, 105, or 70. ◆Our Solutions Starting with A={84,60,105,70} achieved N=429. We can make a better choice of A at the beginning to achieve larger N. Writer’s solution: the set of all numbers that are multiples of 6, 10, or 15 has 2666 elements and satisfies the conditions. Tester’s solution: the set of all numbers that are multiples of 6, 10, 14, 22, or 1155 has 2926 elements and satisfies the conditions. We can solve the problem by printing a coprime subset of such a set. 【Sample Implementation】 https://atcoder.jp/contests/arc118/submissions/22269560 （Python, N≤2666） D - Hamiltonian Cycle Editorial by evima Let G={1,2,…,P−1}. Below, multiplication, division, exponentiations, and so on are all performed modulo P. Also, since the problem asks about a Hamiltonian cycle in an undirected graph where G is the vertex set and edges are spun between two vertices when one is the other multiplied by a or b, we frequently use the terms in graph theory. Let the subset G a,b ​ of G be defined by G a,b ​ ={a i b j ∣i,j∈Z} ( Z is the set of all integers). To build a hamiltonian path, every vertex should be reachable from 1, so G=G a,b ​ must hold. Let us examine the structure of G a,b ​ first. ◆The structure of G a,b ​ Let us take the minimum n≥1 such that a n =1 and let H={a i ∣0≤i<n}. Since a n =1, we can also represent it as H={a i ∣i∈Z}. Also, let us take the minimum m≥1 such that b m ∈H. Then, the following holds: For every x∈G a,b ​ , there uniquely exist integers 0≤i<n and 0≤j<m such that x=a i b j . 【Proof】 (Existence) Let us arbitrarily take an element x=a k b l ( k,l∈Z) of G a,b ​ . If we let q and j be the quotient and remainder when l is divided by m, it follows from l=qm+j that a k b l =a k (b m ) q b j . From b m ∈H, we have a k (b m ) q ∈H, so there exists some 0≤i<n such that a k (b m ) q =a i . Therefore, x=a k b l =a i b j , and these i and j satisfy 0≤i<n and 0≤j<m, so we have shown the existence of them. (Uniqueness) Let us assume for 0≤i 1 ​ ,i 2 ​ <n and 0≤j 1 ​ ,j 2 ​ <m that a i 1 ​ b j 1 ​ =a i 2 ​ b j 2 ​ . Proving i 1 ​ =i 2 ​ and j 1 ​ =j 2 ​ will prove the uniqueness of them. Without loss of generality, we assume j 1 ​ ≤j 2 ​ . It follows from a i 1 ​ b j 1 ​ =a i 2 ​ b j 2 ​ that a i 1 ​ −i 2 ​ =b j 2 ​ −j 1 ​ . Particularly, we have b j 2 ​ −j 1 ​ ∈H. Since 0≤j 2 ​ −j 1 ​ <m, we can see from the way we chose m (the part “let us take the minimum m≥1”) that j 2 ​ −j 1 ​ =0, that is, j 1 ​ =j 2 ​ . Therefore, a i 1 ​ =a i 2 ​ . Similarly, using a i 1 ​ −i 2 ​ =1 and the definition of n and so on, we can see that i 1 ​ =i 2 ​ . Therefore, it is shown that i 1 ​ =i 2 ​ and j 1 ​ =j 2 ​ . ◆The necessary condition Based on the above groundwork, we can obtain the necessary condition for the existence of the hamiltonian cycle in question. It is necessary that G=G a,b ​ , which will be ∣G a,b ​ ∣=nm after taking n and m as stated above, so it is necessary that P−1=nm. Below, we assume that this necessary condition is satisfied. ◆The connection between G and a grid graph Remember that every element in G=G a,b ​ is uniquely written in the form a i b j ( 0≤i<n, 0≤j<m). From this, by associating a n element of G with a square (i,j), we can see that G contains an n×m grid graph as a subgraph. That is, if we put a i b j at the i-th row and j-th column, adjacent squares will contain numbers connected by an edge in the problem. For example, the figure below shows the placements of numbers for the case P=13, a=4, and b=5. Actually, there are also edges “outside” the grid. In the above example, we can go between positions where the same English letter is written in the figure to the right. From a n =1, for the direction of moves regarding multiplying by a, we can go between the top and bottom rows in the same column. ◆Building a Hamiltonian Cycle If n=1 or m=1: In this case, the n×m grid graph may not contain a Hamiltonian cycle, but we can build one by using the edge outside the grid. One such example is 【Sample Input 2】. If n,m>1 (Method 1) In this case, it follows from P>2 that nm=P−1 is even, so n or m is even. If m is even, we can build a Hamiltonian cycle in the following form: If m is odd, rotate the grid and build a similar cycle. If n,m>1 (Method 2) It was not in the writer’s mind that nm was even. By using the move between the top and bottom rows in the same column, we can build a Hamiltonian cycle as follows: If n,m>1 (Method 3 by Tester) If n is odd under the necessary condition, we can prove that swapping a,b and recalculate n,m makes n even. From the facts that n is even and that we can go between the top and bottom rows in the same column, we can build the following Hamiltonian cycle: E - Avoid Permutations Editorial by evima Below, we will use the following terms. For i where A i ​  =−1, we call (i,A i ​ ) a forbidden square. We call a permutation satisfying P i ​ =A i ​ for each forbidden square (i,A i ​ ) simply a permutation. We call a path that does not visit forbidden squares simply a path. For a permutation P, a path X and a square (i,j), we say P and X collide at (i,j) when P i ​ =j and X visits (i,j). Let K denotes the number of forbidden squares, and S denote the set of squares whose row ID and column ID are both between 1 and N. ◆Applying the Inclusion-Exclusion Principle What we want to find, ∑ P ​ f(P), can be rephrased into the number of pairs (P,X) of a permutation P and a path X that do not collide at any (i,j)∈S. Let us count it with the inclusion-exclusion principle. For T⊂S, a permutation P and a path X, let us call the following condition the collision condition: if (i,j)∈T, P and X collide at (i,j). If g(T) is the number of tuples (T,P,X) satisfying the collision condition for a fixed T, the answer is ∑ T ​ (−1) ∣T∣ g(T) from the inclusion-exclusion principle. Thus, we can compute the answer by counting tuples (T,P,X) satisfying the collision condition for each ∣T∣. ◆Counting P Let us count such tuples (T,P,X). We say a pair (T,X) of T⊂S and a path X is valid when the following conditions are satisfied: T⊂X. T does not contain squares that share a row or a column with a forbidden square. T does not contain two squares that are in the same row or the same column. For a (T,X) that is not valid, no (T,P,X) satisfies the collision condition. Thus, for (T,X), we only need to consider valid ones. When (T,X) is valid, how many (T,P,X) satisfies the collision condition? This is equal to the number of permutations under K+∣T∣ conditions of the form P i ​ =j that are consistent with each other, so we can compute it as (N−K−∣T∣)!. Particularly, the number of P only depends on ∣T∣. In the end, we have reduced the problem of counting (T,P,X) satisfying the collision condition to a problem of counting valid (T,X) for each ∣T∣. ◆Using DP Let us count valid pairs (T,X) for each ∣T∣, through the following DP: Consider the number of pairs (T,X) of a path X to square (i,j) and a set T⊂S∩X that are valid and satisfy ∣T∣=n. Additionally, we have two boolean values row,col∈{0,1}, according to whether we have chosen a element in T from the i-th row, and from the j-th row. Let dp[i,j,n,row,col] be the number of such pairs (T,X), and sequentially compute them in some topological order on the squares (i,j). We can solve the problem in a total of O(N 3 ) time from all of the above. F - Growth Rate Editorial by evima ◆Recurrence Formula For positive integers n and x, let dp n ​ (x) denote the number of sequences X=(X n ​ ,…,X N+1 ​ ) starting at the n-th element, satisfying the conditions and X n ​ =x. Then, the recurrence formula below determines dp n ​ (x) for n=N+1,N,…,1, in this order. dp N+1 ​ (x)={ 1 0 ​ (1≤x≤M) (M<x) ​ dp n ​ (x)=∑ A n ​ x≤y ​ dp n+1 ​ (y) The answer is ∑ x ​ dp 1 ​ (x), but M is too huge to compute dp i ​ (x) directly for each x. ◆ dp i ​ and Polynomials For i=N+1,N,…,1, we can recursively prove the existence of the following integers R i ​ and polynomials f i ​ ,F i ​ : dp i ​ (x)=0 if x>R i ​ . f i ​ has a degree of N+1−i and satisfies dp i ​ (x)=f i ​ (x) for each 1≤x≤R i ​ . F i ​ has a degree of N+2−i and satisfies ∑ 1≤y≤x ​ dp i ​ (y)=F i ​ (x) for each 0≤x≤R i ​ . Now, instead of maintaining a big table dp i ​ (x), let us maintain R i ​ ,f i ​ ,F i ​ . ◆How to Maintain Polynomials and Compute Them There are several ways to maintain data that is equivalent to a polynomial f i ​ . Here, let us store the following values, which makes it easier to handle prefix sums than storing coefficients of the polynomial. R i ​ f i ​ (1),f i ​ (2),…,f i ​ (N+2−i) F i ​ (0),F i ​ (1),…,F i ​ (N+2−i) We can compute R i ​ from R N+1 ​ =M and R i ​ =⌊ A i ​ R i+1 ​ ​ ⌋, and compute F i ​ from F i ​ (x)=∑ 1≤y≤x ​ f i ​ (y). f i ​ can be computed from f i ​ (x)=F i+1 ​ (R i+1 ​ )−F i+1 ​ (A i ​ x−1). Here we need the value of F i+1 ​ at a point that is not directly stored, but we can compute it through polynomial interpolation described below. Polynomial Interpolation When we have a polynomial F of degree n and know the values F(0),…,F(n), we can compute F(x) in O(n) time for any x. This can be done by performing Lagrange interpolation in O(n) time using the fact that the evaluation points are evenly spaced. Reference: https://atcoder.jp/contests/arc033/tasks/arc033_4 ◆Analysis of Complexity and How to Reduce It Straight forward implementation of the above results in O(N 2 ) time for each i, for a total of O(N 3 ) time. Here, note that almost all A i ​ is 1 when N is large. If A i ​ is large, almost all of the things we have to do in polynomial interpolation is to compute F(x) when F(0),…,F(n) and 0≤x≤n are given. We can obviously compute it in O(1) time by just reading the value stored. By performing this “obvious” polynomial interpolation in O(1) time, we can solve the problem in a total of O(N 2 logM) time: O(N 2 ) time for each i where A i ​ ≥2, and O(N) time for each i where A i ​ =1. We can also use a fast multipoint evaluation algorithm to solve the problem in O(Nlog 2 NlogM+N 2 ) time. A - God Sequence Editorial by evima If A≥B, we can make a god sequence as follows: let E 1 ​ =1,E 2 ​ =2,⋯,E A ​ =A; let E A+1 ​ =−1,E A+2 ​ =−2,⋯,E A+B−1 ​ =−(B−1); then, let E A+B ​ =−∑ i=B A ​ E i ​ =−∑ i=B A ​ i=−(B+(B+1)+...+(A−1)+A)≤−B. if A<B, we can make a god sequence as follows: let E 1 ​ =1,E 2 ​ =2,⋯,E A−1 ​ =(A−1); let E A+1 ​ =−1,E A+2 ​ =−2,⋯,E A+B−1 ​ =−(B−1); then, set E A ​ so that the sum of the sequence is 0 ( E A ​ will be at least A). Sample implementation in C++: (Link) Copy #include <iostream> using namespace std; int A, B, E[1 << 18]; int main() { // Input cin >> A >> B; // Make "God Array" if (A >= B) { for (int i = 0; i < A; i++) E[i] = i + 1; for (int i = A; i < A + B - 1; i++) E[i] = -(i - A + 1); for (int i = 0; i < A + B - 1; i++) E[A + B - 1] -= E[i]; } else { for (int i = 0; i < A - 1; i++) E[i] = i + 1; for (int i = A; i < A + B; i++) E[i] = -(i - A + 1); for (int i = 0; i < A + B; i++) { if (i != A - 1) E[A - 1] -= E[i]; } } // Output for (int i = 0; i < A + B; i++) { if (i) cout << " "; cout << E[i]; } cout << endl; return 0; } B - ARC Wrecker Editorial by evima If there are Q i ​ “floors” such that there are i buildings with it, there can be between 0 and Q i ​ such floors in the final scenery, for every i. Thus, the answer is ∏ i=1 N ​ (A i ′ ​ −A i−1 ′ ​ +1), where A ′ =(A 1 ′ ​ ,A 2 ′ ​ ,...,A N ′ ​ ) is the result of sorting A in ascending order and A 0 ′ ​ =0. C - Tricolor Pyramid Editorial by evima Let us call the colors 0,1,2. Then, on top of two blocks of colors a and b, a block of color −(p 1 ​ +p 2 ​ )mod3 will be placed. Thus, the answer is (−1) N−1 ×∑ i=0 N ​ (c i−1 ​ × N−1 ​ C i−1 ​ ), modulo 3. (See figures below.) To compute a binomial coefficient n ​ C r ​ modulo 3, compute the values f(n!),f(r!),f((n−r)!),g(n!),g(r!),g((n−r)!), where f(m) is the number of times m can be divided by 3, and g(m) is the result, modulo 3, of dividing m by 3 until it is no longer divisible by 3. For a given integer m, we can compute f(m!) and g(m!) in O(logm) time. D - Miracle Tree Editorial by evima We can rephrase the following: Condition 2: ∣E i ​ −E j ​ ∣≥dist(i,j) holds for every pair (i,j) (1≤i<j≤N). into the following: Condition 2: Assume E p 1 ​ ​ <E p 2 ​ ​ <E p 3 ​ ​ <⋯<E p N ​ ​ . Then, dist(p i ​ ,p i+1 ​ )≤E p i+1 ​ ​ −E p i ​ ​ holds for every pair 1≤i≤N−1. because dist(p L ​ ,p R ​ )≤dist(p L ​ ,p L+1 ​ )+dist(p L+1 ​ ,p L+2 ​ )+⋯+dist(p R−1 ​ ,p R ​ ) holds for any L,R. Thus, to minimize the maximum among E i ​ , we should set them as follows: Condition 2 + Condition 3: dist(p i ​ ,p i+1 ​ )=E p i+1 ​ ​ −E p i ​ ​ for every 1≤i≤N−1. The minimum among E i ​ will be 1, so the maximum among E i ​ will be dist(p 1 ​ ,p 2 ​ )+dist(p 2 ​ ,p 3 ​ )+⋯dist(p N−1 ​ ,p N ​ )+1. Now we want to find the following: We will start at some vertex and visit all the vertices. What is the order to visit the vertices p 1 ​ →p 2 ​ →⋯→p N ​ that minimizes the total distance traveled? For that, we can use the following fact: To start at some vertex, visit all the vertices, and return to the starting point, we need to travel a distance of at least 2(N−1) in total. The figure below describes this fact: Now, let us consider the following problem: Visit all N vertices with the shortest possible distance traveled. Here, we must start at Vertex s and end at Vertex t. In this case, the shortest possible distance is 2(N−1)−dist(s,t), which can be achieved as follows: Do a depth-first search from Vertex s, traversing the vertices in pre-order. However, make sure that the edge going to Vertex t is traversed last. The figure below illustrates some examples: Thus, we can choose s,t that maximize dist(s,t) to minimize 2(N−1)−dist(s,t), the distance traveled. This maximum distance is called the diameter of a tree, which is known to be found in linear time. Writer’s code: https://atcoder.jp/contests/arc117/submissions/21730882 Tester’s code: https://atcoder.jp/contests/arc117/submissions/21780162 Bonus: can you write the code that judges submissions to this problem? That is, given a description of a tree N,A i ​ ,B i ​ and an output of a contestant E i ​ , determine whether the output satisfies the conditions. Our solution runs in O(NlogN) time. E - Zero-Sum Ranges 2 Editorial by evima First, let us solve the following problem: Given is a sequence of length n: a=(a 0 ​ ,a 1 ​ ,…,a n−1 ​ ). How many pairs of integers l,r (1≤l≤r≤N) satisfy a l ​ +a l+1 ​ +⋯+a r−1 ​ =0? (It is this problem: https://atcoder.jp/contests/agc023/tasks/agc023_a) We will briefly express the solution to this. Let s i ​ =a 0 ​ +a 1 ​ +⋯+a i−1 ​ . Then, a l ​ +a l+1 ​ +⋯+a r−1 ​ equals s r ​ −s l ​ , so the answer is the number of ways to choose two equal values from s 0 ​ ,s 1 ​ ,…,s n ​ . Now, let us go back to the original problem. Consider building the sequence of prefix sums “from top to bottom”: We will try a dynamic programming approach to count such sequences s i ​ . For now, let us only count such sequences that every s i ​ is 0 or greater. Let dp[size][cnt][hole] be the number of sequences such that: the number of elements is size; the number of zero-sum ranges is cnt; the number of “holes” between two consecutive elements with the same value of s i ​ is hole. (At the next level, we have to put at least one element in each hole, in addition to the left and right ends.) Note that we do not have to store the levels of the sequences in this table because it is irrelevant to the transitions. Then, considering the case we add x elements at the next level, we have x−1 ​ C hole+1 ​ ways to transit from each state (size,cnt,hole) to (size+x,cnt+ 2 1 ​ x(x−1),x−(hole+2)). (Each of the x elements should be added to one of the hole+2 places: the holes and the two ends, and each place should have at least one element, so the number of ways to transit is equal to the number of sequences of (hole+2) positive integers totaling x). Since we have O(N 4 ) states, we can fill the whole table in O(N 5 ) time to count such sequences that every s i ​ is 0 or greater. Using this table, we can find the number of all sequences: it is the sum of dp[x][y][z]×dp[(2N+1)−x][K−y][z−1] over all states (x,y,z). (Alternatively, you can introduce to the table a new binary state representing level≥0 or level<0.) F - Gateau Editorial by evima Let b i ​ be the number of strawberries on Piece i. Then, we can express the request of Friend i as follows: if i<N, b i ​ +b i+1 ​ +⋯+b i+N−1 ​ ≥A i ​ ; if i≥N, b i ​ +b i+1 ​ +⋯+b 2N−1 ​ +b 0 ​ +⋯+b i−N−1 ​ ≥A i ​ . We want to minimize the total number of strawberries b 0 ​ +b 1 ​ +⋯+b 2N−1 ​ while satisfying these conditions. Let X opt ​ be the minimum number of strawberries needed. Then, for any X≥X opt ​ , we can have exactly X strawberries on the whole cake, so let us do a binary search on the answer to turn the problem into a decision problem: can we have exactly X strawberries on the whole cake? Conveniently, for a fixed total number of strawberries, the condition for i≥N, b i ​ +b i+1 ​ +⋯+b 2N−1 ​ +b 0 ​ +⋯+b i−N−1 ​ ≥A i ​ , is equivalent to b i−N ​ +b i−N+1 ​ +⋯+b i−1 ​ ≤X−A i ​ . Additionally, let s i ​ =d 0 ​ +d 1 ​ +⋯+d i−1 ​ . Then, the request of Friend i can be expressed as follows: if i<N, s i+N ​ −s i ​ ≥A i ​ ; if i≥N, s i ​ −s i−N ​ ≤X−A i ​ . Thus, the problem is equivalent to determining whether it is possible to satisfy all of the following conditions, where L i ​ =A i ​ ,R i ​ =X−A i+N ​ : 0=s 0 ​ ≤s 1 ​ ≤⋯≤s 2N ​ =X; L i ​ ≤s i+N ​ −s i ​ ≤R i ​ for every i=0,1,…,N−1. Let us first consider the case the value of s N ​ is fixed to M. We can solve this case as follows: First, we have s 0 ​ =0,s N ​ =M. For each i=1,2,…,N−1 in this order, do the following: if L i ​ ≤s i+N−1 ​ −s i−1 ​ ≤R i ​ , let (s i ​ ,s i+N ​ )=(s i−1 ​ ,s i+N−1 ​ ); if s i+N−1 ​ −s i−1 ​ <L i ​ , let (s i ​ ,s i+N ​ )=(s i−1 ​ ,s i−1 ​ +L i ​ ); if s i+N−1 ​ −s i−1 ​ >R i ​ , let (s i ​ ,s i+N ​ )=(s i+N−1 ​ −R i ​ ,s i+N−1 ​ ). If we end up with both s N−1 ​ ≤s N ​ and s 2N−1 ​ ≤X, we have made a sequence satisfying the conditions. Otherwise, there is no sequence satisfying them. We have no time to do this for all possible values of s N ​ , but notice the following property: Let f 1 ​ (a,b),f 2 ​ (a,b) be respectively the values of s N−1 ​ ,s 2N−1 ​ obtained in the greedy algorithm above when we first set s 0 ​ =a,s N ​ =b. If a≤a ′ ,b≤b ′ , then f 1 ​ (a,b)≤f 1 ​ (a ′ ,b ′ ) and f 2 ​ (a,b)≤f 2 ​ (a ′ ,b ′ ) hold. From this, the larger s N ​ is, the larger s 2N−1 ​ will be, so the condition s 2N−1 ​ ≤X will hold when s N ​ is not larger than some constant value (possibly −∞). Additionally, the larger s N ​ is, the smaller s N ​ −s N−1 ​ will be, because if we hypothetically let s 0 ​ =−M,s N ​ =0, the smaller M is, the larger s N−1 ​ will be. Thus, the condition s N−1 ​ ≤s N ​ will hold when s N ​ is not less than some constant value (possibly ∞). Therefore, we can do a binary search to find the range of s N ​ where we can make a sequence, which solves the decision problem in O(NlogA) time, and the whole problem in O(Nlog 2 A) time. It is also possible to solve the decision problem in O(N) time, resulting in the total complexity of O(NlogA). (Although it will not run in time, we note that it is possible to solve the decision problem using the Bellman-Ford algorithm in O(N 2 ) time by seeing it as a special case of a linear programming problem.) A - Odd vs Even Editorial by evima When N=2 d ×a ( a: even), the set of the divisors of N is: {2 i ×j ∣ ∣ ∣ ​ 0≤i≤d,j is a divisor of a} Thus, if N has m odd divisors, it has dm even divisors. Therefore, the answer is: Even, if N is divisible by 4; Same, if N is divisible by 2 but not by 4; Odd, if N is not divisible by 2. B - Products of Min-Max Editorial by evima Let us set some order between elements with the same value and sort A. A i ​ ×A j ​ (i<j) gets added to the answer 2 j−i−1 times, so the answer is: i=1 ∑ N ​ j=i+1 ∑ N ​ A i ​ ×A j ​ ×2 j−i−1 + i=1 ∑ N ​ A i ​ ×A i ​ where i=1 ∑ N ​ j=i+1 ∑ N ​ A i ​ ×A j ​ ×2 j−i−1 = i=1 ∑ N ​ A i ​ ( j=i+1 ∑ N ​ A j ​ ×2 j−i−1 )(1) and ⎝ ⎛ ​ j=(i−1)+1 ∑ N ​ A j ​ ×2 j−(i−1)−1 ⎠ ⎞ ​ =2×( j=i+1 ∑ N ​ A j ​ ×2 j−i−1 )+A i ​ Thus, we can compute (1) in descending order from i=N in O(N) time, so we can solve the problem in O(NlogN) time. C - Multiple Sequences Editorial by evima Let us try to find the answer for each A N ​ =1,2,…,M and sum them up. The answer for fixed A N ​ can be found as the product of n binomial coefficients, where n is the number of prime factors of A N ​ , by focusing on where in the sequence the number of times each prime factor is multiplied increases. The total number of prime factors of i=1,2,…,M can be evaluated as O(MlogM). Thus, excluding the precomputation for binomial coefficients, we can solve the problem in O(MlogM) time. D - I Wanna Win The Game Editorial by evima If we consider the lowest bit and the other bits separately, “the other bits” can be reduced to the same problem with a smaller input. More specifically, let: dp i ​ = the number of non-negative integers totaling i whose xor is 0 Then, we have the following recurrence relation: dp i ​ ={ ∑ j ​ ( 2∗j N ​ )dp (i−2j)/2 ​ 0 ​ if i is even if i is odd ​ By filling the DP table in ascending order according to this recurrence relation, we can solve the problem in O(M 2 ) time, excluding the precomputation for binomial coefficients. E - Spread of Information Editorial by evima The problem can be written as follows: Problem P 1 ​ : Given a tree with N vertices, choose K special vertices v 1 ​ ,…,v K ​ to minimize max 1≤v≤N ​ min 1≤i≤K ​ dist(v,v i ​ ). Let us modify it and consider the following decision problem: Problem P 2 ​ : Given a tree with N vertices, determine whethere it is possible to choose K special vertices v 1 ​ ,…,v K ​ so that max 1≤v≤N ​ min 1≤i≤K ​ dist(v,v i ​ )≤X. If we can solve P 2 ​ fast, we can do a binary search for the answer to solve P 1 ​ fast. Now, let us consider the following problem: Problem P 3 ​ : Find the minimum number of special vertices required to satisfy the following condition: for every vertex u, there is a special vertex v such that dist(u,v)≤X. If we can solve P 3 ​ , we can solve P 2 ​ by checking whether the answer to P 3 ​ is not greater than K. Actually, we can solve it: let us make the tree rooted in some way and write dynamic programming on it where each vertex v stores the following information considering only the subtree rooted at v: if there are special vertices whose distances from v is not greater than K, the minimum among those distances; otherwise, the maximum distance from v to a vertex without a special vertex within the distance of X; additionally, the number of special vertices in the subtree. In this way, we can solve P 2 ​ in O(N) time. Since the answer to P 1 ​ is obviously not greater than N, we can do a binary search for the answer to P 1 ​ to solve it in O(NlogN) time. F - Deque Game Editorial by evima Let us first simplify the problem and then make it progressively harder. Case 1: K=1 and N 1 ​ is odd Let us define a function f for an odd-length sequence: f(B)={ B 1 ​ min(B 2 ∣B∣+1 ​ ​ ,max(B 2 ∣B∣+1 ​ −1 ​ ,B 2 ∣B∣+1 ​ +1 ​ )) ​ (∣B∣=1) (∣B∣≥3) ​ Then, the answer is f(A 1 ​ ). We can prove by induction that Takahashi can make the last value at least f(A 1 ​ ) using the following strategy: if A 1, 2 ∣A 1 ​ ∣+1 ​ −1 ​ ≥A 1, 2 ∣A 1 ​ ∣+1 ​ +1 ​ , delete the last element of A 1 ​ ; otherwise, delete the first element of A 1 ​ . On the other hand, we can again prove by induction that Aoki can make the last value at most f(A 1 ​ ) using the following strategy: if ∣A 1 ​ ∣≥4, delete the element in the direction opposite from the direction in which Takahashi deleted an element; if ∣A 1 ​ ∣=2, keep the element he prefers. Case 2: N i ​ is odd (i=1,2,…K) The answer is ∑ i=1 K ​ f(A i ​ ). We can prove by induction that Takahashi can make the sum of the last values remaining at least ∑ i=1 K ​ f(A i ​ ) using the following strategy: if this is the first operation of Takahashi or Aoki made an even-length sequence odd-length in his previous move, choose some sequence A i ​ of length at least 2 and use on it his strategy in Case 1; (We can prove that the length of A i ​ is odd as long as he follows this strategy.) otherwise, use Aoki’s strategy in Case 1 on the sequence A i ​ Aoki made his previous move on. (We can prove that the length of A i ​ is even as long as he follows this strategy.) On the other hand, Aoki can make the sum of the last values remaining at most ∑ i=1 K ​ f(A i ​ ) using the following strategy: use his strategy in Case 1 on the sequence A i ​ Takahashi made his previous move on. (We can prove that the length of A i ​ is even as long as he follows this strategy.) Case 3: the general case Let us consider the case ∑ i=1 K ​ N i ​ −K is even here. We can interpret the strategies above where N i ​ is odd (i=1,2,…K), as follows: Making an operation on an odd-length sequence A i ​ is not profitable. If ∣A i ​ ∣≥5, the middle three elements will remain the same if the opponent deletes an element from the opposite direction; if ∣A i ​ ∣=3, it is more profitable for a player when the opponent first makes a move on A i ​ and then the player makes a move on it, than when the player first makes a move on A i ​ and then the opponent makes a move on it. From this observation, we can generalize the strategies of the two players in Case 2, as follows: if all sequences have odd lengths, choose some sequence A i ​ of length at least 2 and delete the element at one of the two ends that is nearer to the less preferred element between A i, 2 ∣A i ​ ∣+1 ​ −1 ​ ,A i, 2 ∣A i ​ ∣+1 ​ +1 ​ ; otherwise, compute the difference of f(A[1:∣A i ​ ∣−1]) and f(A[2:∣A i ​ ∣]) for each even-length sequence A i ​ and make the operation with the greatest profit. Let us prove by induction that this strategy is optimal. If there is no even-length sequence, the proof is similar to the one in Case 2. Let us consider the case with some even-length sequences. If we make a move on an even-length sequence, from the inductive assumption, the next move by the opponent and the following moves will be made greedily, preferring the operation with the greatest profit, and it comes down to the case with only odd-length sequences. By considering this resulting situation, we can see that it is optimal to do the operation with the greatest profit in this turn. On the other hand, if we make a move on an odd-length sequence, the opponent can delete an element in this sequence from the opposite direction, resulting in a state where we have fewer elements in total, the same even-length sequences, and odd-length sequences that are not better than the ones we had. By considering the optimal strategy here obtained by inductive assumption, this progression is not better than the one that results if we make a move on an even-length sequence in the first place. Thus, we can see that the strategy above is optimal. Therefore, by computing the difference of f(A[1:∣A i ​ ∣−1]) and f(A[2:∣A i ​ ∣]) and assuming that Takahashi and Aoki alternately choose the operation with the greatest profit greedily, the case can be reduced to Case 2, so we can solve the problem in O(NlogN) time. The case ∑ i=1 K ​ N i ​ −K is odd is similar, but note that we have to change the definition of f, since it will be Aoki, not Takahashi, who makes moves on odd-length sequences. A - Two Choices Editorial by evima Consider whether some two students can have the same number of correct answers. (In other words, consider the case N=2.) We can ignore the questions where the two students gave the same response. Let D be the number of questions where the two students gave different responses. Note that, in each of these D questions, exactly one student has the correct answer. When D is even, if one student has correct answers in D/2 of these questions and the other has correct answers in the other D/2 questions, they have the same number of correct answers. On the other hand, when D is odd, they never have the same number of correct answers. Thus, two students never have the same number of correct answers if and only if their responses differ in an odd number of questions. When the two students give different responses to a question, that question flips the parity of the difference of the numbers of times they choose 1. On the other hand, when the two students give the same response, this parity does not change. Thus, the two students’ responses differ in an odd number of questions if and only if the numbers of times they choose 1 have different parities. Therefore, two students never have the same number of correct answers if and only if the numbers of times they choose 1 have different parities. The answer is the number of students who chose 1 odd numbers of times, multiplied by the number of students who chose 1 even numbers of times. B - Plus Matrix Editorial by evima We can assume that the minimum value in A is 0, because if there is some pair A,B satisfying the condition such that the minimum value in A is m(>0), we can subtract m from all elements in A and add m to all elements in B, and the pair still satisfies the condition. If the minimum element in A is 0, we can determine A as A i ​ =C i,0 ​ −m, where m is the minimum value among C i,0 ​ , and B as B j ​ =C 0,j ​ −A 0 ​ . Lastly, we check if this pair A,B actually satisfies all conditions, and the problem is solved. C - ℕ Coloring Editorial by evima For example, A i ​ =(the number of prime factors of i)+1 achieves the objective. Two numbers such that one divides the other have different numbers of prime factors, so all conditions are satisfied. Let 2 k be the greatest power of 2 less than or equal to N. Then, A 1 ​ ,A 2 ​ ,A 4 ​ …,A 2 k−1 ​ ,A 2 k ​ must be distinct, so the greatest value in A has to be at least k+1. In our choice of A above, the gratest value is k+1, too, so it is optimal. D - Odd Degree Editorial by evima Consider the case the graph is a tree. For a fixed set of vertices with odd degrees, there are 0 spanning subgraphs if the size of that set is odd, and 1 spanning subgraph otherwise. (Proof: when N=1, we have 1 subgraph when there are 0 vertices with odd degrees and 0 subgraphs when there is 1 such vertex. When N>1, if we take some leaf and choose whether we keep the edge incident to that leaf according to the desired degree of that leaf, the problem is reduced to the case with N−1 vertices. Here, the reduction does not change the parity of the size of the set of vertices with odd degrees, so the answer is still 1 when there is an even number of vertices with odd degrees and 0 if there is an odd number of such vertices.) Thus, the answer is 0 if K is odd and N ​ C K ​ if K is even. Consider the case the graph is connected. If we take some spanning tree of the graph and arbitrarily choose whether we keep each of the edges not contained in that spanning tree, the problem is reduced to the case the graph is a tree. Thus, the answer is 0 if K is odd and 2 M−N+1 × N ​ C K ​ if K is even. For a disconnected graph, we separately solve the problem for each connected component and combine the results with dynamic programming or multiplication of polynomials to find the final answer. The complexity of this solution is O(N 2 ) or O(Nlog 2 N). E - LEQ and NEQ Editorial by evima Let us use the inclusion-exclusion principle. Let dp[pos][k] be the number of choices of X[1],X[2],…,X[pos] where the parity of the number of i for which we purposely make X i ​ =X i+1 ​ is k. The answer is dp[N][0]−dp[N][1]. We have the following transitions: dp[pos ′ ][k+(pos ′ −pos−1)]+=min(A[pos+1],..,A[pos ′ ])×dp[pos][k], but directly implementing it results in a complexity of O(N 2 ) and runs out of time. By focusing on the structure of the Cartesian Tree, we can jointly deal with the transitions with the same min(A[pos+1],..,A[pos ′ ]). The sketch of this follows: In ascending order of i, we deal with the transitions where min(A[pos+1],..,A[pos ′ ]) is A[i]. If A contains repetitions, we assign them some order. Before we do the transition for i, all values in dp where pos<i are determined. We maintain prefix sums for each parity of pos+k. Then, from i to the destinations (pos≥i), we do an addition to an interval for each parity of pos+k, using another array of prefix sums. If we find the Cartesian Tree using a stack, the complexity of the solution is O(N). F - Migration Editorial by evima We have the following greedy strategy. Among the moves that move a piece to a lower vertex (with a lower value of H i ​ ), do the one with the smallest maximum potential during and after the move. Here, the vertices with the same height are assigned some order. We apply this strategy to the initial and final states in parallel, preferring the move with the smaller maximum potential, until the positions of all pieces become the same between the two states. The answer is the greatest of the maximum potentials we had. By using priority queues, the complexity of this solution can be O(NKlogN). Moreover, by doing some precomputations and moving the pieces on the same vertex at once, we can improve the complexity to O(NlogN+K). Validity of the solution: Let us call a combination of the positions of the pieces a state. For a fixed upper limit of the potential, we can see that if applying the greedy strategy to states A and B result in the same final state, A and B are reachable from each other via that state. Note that transitions are bidirectional. For a fixed upper limit of the potential, applying the greedy strategy to states A and B result in the same final state if A and B are reachable from each other. (Proof: the greedy strategy results in the state where each piece is on the lowest vertex reachable. This follows from the fact that each step moves a piece to a position lower than where it is now, and because the position of each piece never gets lower, once a move of a piece becomes available, it never becomes unavailable. Since A and B are reachable from each other, the set of reachable vertices for each piece is the same for these two starting states, and so is the final state the strategy results in.) Thus, for a fixed upper limit of the potential, the greedy strategy results in the same state for the initial and final states if and only if the initial and final states are reachable from each other. If we consider that the aforementioned algorithm fixes the upper limit, tries it, makes it a little bigger, and tries it again, we can see it is valid. A - Not coprime Editorial by evima X i ​ and Y being not coprime means some integer d≥2 divides both X i ​ and Y. Here, we only need to consider minimal such d, that is, a prime number. Since there are 15 prime numbers not greater than 50, we can try all 2 15 subsets of those primes to find the minimum Y. For each subset, we try to let Y be the product of the elements, and if there is X i ​ that is coprime with Y, that choice of Y is invalid. The time complexity of this solution is O(N2 p(L) logL)(L:=maxX), where p(i) is the number of primes not greater than i. B - Special Subsets Editorial by evima What does the condition mean? The first condition requires that, if i∈T, all of i,f(i),f(f(i)),⋯ belong to T. Since S is finite, there is k>0 such that f k (i) equals f l (i)(l<k). Let us take the minimum such k and the corresponding l. Then, after f k (i), the sequence is a repetition of f l (i),⋯,f k−1 (i). (In terms of graph theory, each (weakly) connected component in the graph with directed edges (i,f(i)) is a cycle plus some paths entering it.) Here, if l>0, we have f l−1 (i)  =f k−1 (i), but f l (i)=f k (i), which contradicts with the second condition. That is, the conditions require that i belong to a cycle, and if i∈T, all vertices in the cycle belong to T. Cycles do not affect each other, so the answer is 2 C −1, where C is the number of cycles, which is simply equal to the number of connected components because of the special form of the graph. We can find it in O(N) time. C - Sequence Scores Editorial by evima First, let us consider the value f(A) for fixed A. This is the number of connected component in a graph where there is an undirected edge between vertices i<j iff A i ​ =A j ​ and there is no i<k<j such that A k ​ <A i ​ . We can achieve it by dealing with the connected components in the descending order of the value and using the vertices with the smallest and largest indices as the endpoints in the operation. We cannot meet the objective with fewer operations. The proof of this roughly goes as follows: for each value in descending order, we consider the necessity of the operation. Then, we need the above number of times for the largest value, and if we do this number of operations beforehand, we can remove the part with this value and proceed. Actually, we only need to consider edges that are minimal as segments in the graph. At the leftmost vertex, a cost of 1 is incurred; at the other vertices, a cost of 0 ( 1) is incurred if there is (not) an edge to the immediate left of it. Thus, we can find the sum by subtracting from N×M N the total number of vertices with the cost 0. For a fixed edge (i,j) and a fixed value A i ​ =x, there are ∑ i=0 N−1 ​ ∑ j=0 i−1 ​ (∑ x=1 M ​ (M−x) i−j−1 )∗M N−(i−j)−1 sequences where j has the cost 0 because of this edge. This only depends on i−j and x, so we can compute the sum in O(NM) time. Bonus: for how much value of N and M can you solve the problem? D - Moving Pieces on Line Editorial by evima First, since the vertices lie in a wide enough region, we can rephrase the maroon’s objective as making {t 1 ​ ,t 2 ​ ,⋯,t K ​ } the set of points with two incident edges in different colors. Let us sort the initial positions of the pieces beforehand. Let b 1 ​ ,b 2 ​ ,⋯,b N ​ be the final positions of the N pieces. Then, the combination of colors of edges does not depend on the paths of the pieces but only depends on the positional position between a i ​ and b i ​ . Thus, for a fixed set of final positions, the minimum number of operations needed is ∑ i=1 n ​ ∣a i ​ −b i ​ ∣. Here, we can obviously assume b 1 ​ ≤b 2 ​ ≤⋯≤b N ​ . Now, what type of b achieves the desired combination of colors? Consider adding a i ​ and b i ​ into a multiset S, and let T be the set of numbers occurring an odd number of times in S. If the set of points with two incident edges in different colors equal T, such b achieves the objective. That is, we can consider everything mod2. From a and t, the set of numbers occurring an odd number of times in b is uniquely determined (let it be {c 1 ​ <c 2 ​ <⋯<c l ​ }), and we can freely let numbers occur an even number of times in b. If the size of this set of numbers occurring an odd number of times is greater than N, the objective is unachievable. Let us minimize the cost. We choose some elements in a and make them correspond to those in c. For the other elements, we should pair the two leftmost ones by moving them to the same position, pair the next two elements, and so on. (Since K is even, we do not have to care about the parity of the number of elements.) From those observations, by letting dp[ i][ j][ f] be the smallest total cost when a 1 ​ ,⋯,a i ​ are handled, c 1 ​ ,⋯,c j ​ are tied, and f elements in a are waiting in an incomplete pair, we can compute the answer in O(N(N+K)) time. (We can also do it without maintaining f, because if there are tied elements between a pair, we can shift that pair.) E - Paper Cutting 2 Editorial by evima If the smallest rectangle containing the two black squares does not change, the answer does not change, so we assume h 1 ​ ≤h 2 ​ ,w 1 ​ ≤w 2 ​ without loss of generality. If we let A,B,C,D be the number of edges that can be cut above, below, to the left of, to the right of the rectangle, and let dp[ A][ B][ C][ D] be the expected number of cuts from such a situation, we can compute the answer in O(L 4 ), but it is too slow. Let us rephrase the problem into the following problem. We have: A red balls with 1,2,⋯,A written on them B yellow balls with 1,2,⋯,B written on them C green balls with 1,2,⋯,C written on them D brown balls with 1,2,⋯,D written on them E=(h 2 ​ −h 1 ​ )+(w 2 ​ −w 1 ​ ) red balls with 1,2,⋯,E written on them We will randomly rearrange these balls in a row. What is the expected value of the index (position) of the first black ball? Actually, the answer to this does not equal the answer to the original problem, since the piece without the black squares will be thrown away. To handle it, after the rearranging, we will ignore a ball if another ball in the same color with a smaller number occurs earlier in the sequence. Intuitively, we can choose balls in the sequence from front to back and throw away balls that should be ignored without changing the probabilities for relevant balls. In the end, from the linearity of expectation, we can find the expected value in question by summing up the probability that each pair of (color, value) occurs earlier than black balls to avoid being ignored. For example, the probability for the pair (red, i) is the probability that it appears the earliest among (red, 1), (red, 2), …, (red, i) and blacks, so it is i+E 1 ​ . Therefore, after precomputing the modulo inverse of each i and accumulated sums in O(L) time, we can find the answer in O(1) time. F - Permutation Division Editorial by evima What will Maroon do after the division? Since P is a permutation of 1,⋯,N, he will simply sort the blocks in descending order of the value of the frontmost element before concatenating them. Based on this, let us think of the optimal division. Obviously, Q will never be lexicographically smaller than P. Thus, Q will equal P, or equal P until at some element Q>P. In the latter case, having a longer common part results in being lexicographically smaller. Here, for simplicity, let us consider the following two cases: When P 1 ​ ≤K We can minimize the frontmost element of Q by dividing P so that the blocks begin with 1,2,⋯,K, in which case Q will begin with K. We have no other choice. When P 1 ​ >K For example, if we divide P so that the blocks begin with P 1 ​ ,1,2,⋯,K−1, we can keep P 1 ​ at the beginning. How long can the common part of P and Q become? Consider the situation where we can make the first x blocks in Q match P, and each block begins at indices i 1 ​ (=1),i 2 ​ ,⋯i x ​ . Here, P i 1 ​ ​ >P i 2 ​ ​ >⋯,P i x ​ ​ holds. If up to the right end of this rightmost block are fixed, we should have as many blocks to the left of it for a fixed i x ​ . This is because the more blocks the remaining part has, the greater the frontmost element of the remaining part will be. Based on this observation, we precompute the array dp, where dp i ​ is the maximum possible k for (1=)j 1 ​ <j 2 ​ <⋯,j k ​ (=i) such that P j 1 ​ ​ >P j 2 ​ ​ ⋯,P j k ​ ​ . We can do it in O(NlogN) time in a way similar to the way we find LIS, using segment tree, for example. Now, in the previous situation, let us fix i:=i x ​ , the index where the rightmost block in the common part of P and Q begins, and consider the maximum possible length of this block. In the remaining part to the right of this block, we need to make K−dp i ​ blocks. Each of these blocks has to begin with an element smaller than P i ​ , or it will affect the order of blocks and lead to a contradiction. Also, we want this block to be as long as possible, so let us extend this block until just before the (K−dp i ​ )-th value from the right among the values smaller than P i ​ . Then, in the right part, we will make each of the K−dp i ​ blocks begin with one of the smallest K−dp i ​ values. Now, we want to compare the optimal divisions for individual choices of i. Among those divisions for i that can handle the right part properly, we want to choose the one with the lexicographically greatest following value: (the length of the common part of P and Q, the maximum number of blocks so far). We can find the lengths of the common part by dealing with i in the order P i ​ =1,2,⋯,N, doing the following operations: get the (K−dp i ​ )-th greatest value of a set add i to a set We can do them in O(Nlog 2 N) time if we naively do binary searches using, for example, BIT, and in O(NlogN) if we do binary searches on BIT or use Policy-Based Data Structures, for example, in C++. Therefore, we can solve the problem in O(NlogN) in total. ( O(Nlog 2 N) should also be accepted.) A - A*B*C Editorial by evima There are just O(KlogK) pairs (A,B) such that AB≤K (keyword: harmonic series), and there are ⌊ AB K ​ ⌋ candidates for C when A,B are fixed, so we can find the answer as the sum of this value over all candidates of (A,B), in O(KlogK) time. We can also find the answer with brute force in O(Klog 2 K), which is fast enough. B - A^B^C Editorial by evima For integers A,i, the ones digit of the decimal notation of A i has a period of 4 over i. That is, instead of using B C itself, we can use the remainder of B C when divided by 4 (if the remainder is 0, we see it as 4) to find the ones digit of A B C in the decimal notation. For integers B,C, the ones digit of the decimal notation of B C basically has a period of 2 over C. That is, instead of using C itself, we can basically use the parity of C to find the remainder of A B C when divided by 4. The exception is when the remainder of B divided by 4 is 2 and C is odd, in which case the remainder of B C divided by 4 is 2 when C=1 and 0 otherwise. C - String Invasion Editorial by evima Let a block be a part consisting of two or more consecutive same letters. Also, let us call a block essential when it is the first block in S or consists of a letter different from that of the previous block. For example, the string abbbcbbccca has two essential blocks: one composed of the 2-nd, 3-rd, 4-th characters b and another composed of the 8-th, 9-th, 10-th characters c. The block composed of the 6-th, 7-th characters b is not essential since there is another block consisting of b just before it. Now, consider the sequence of operations below. For an essential block B, let the first and last characters of B be the l(B)-th and r(B)-th characters of S. If there is no essential block B such that r(B)  =∣S∣, terminate. If there is such a block, do the operation on the (r(B)−1)-th, r(B)-th, (r(B)+1)-th characters of B. Let us prove that this sequence achieves the maximum number of operations possible. For each essential block B, we define its potential ϕ(B) as the sum of the following, where B ′ is the essential block that appears just after B. The number of characters different from the letter in B among the sequence composed of the (r(B)+1)-th, …, (l(B ′ )−1)-th characters of S. The number of characters in the sequence composed of the l(B ′ )-th, …, ∣S∣-th characters of S: ∣S∣−l(B ′ )+1. The potential of the string S, ϕ(S), is defined as the sum of potentials ϕ(B) over all essential blocks B. Now, from the definition, we can see that every operation decreases ϕ(S) by at least 1. On the other hand, we can also see that every operation in the above sequence decreases ϕ(S) by exactly 1, and ϕ(S)=0 in the end. Thus, this sequence achieves the maximum number of operations possible. Since we can find ϕ(S) in linear time, we can now solve the problem in linear time. D - Sky Reflector Editorial by evima Let (i,j) denote the square at the i-th row and j-th column. If N=1, the integer written on (1,j) is B j ​ . Thus, once the sequence B is set, the value A 1 ​ will be automatically determined. Therefore, the answer is K M . If M=1, by a similar argument, the answer is K N . Now, let us assume N,M≥2. Without loss of generality, we can assume A 1 ​ is the maximum among A i ​ , and B 1 ​ is the minimum among B i ​ . Then, the integer written on (1,1) needs to be between A 1 ​ and B 1 ​ (inclusive), so it is necessary that A 1 ​ ≤B 1 ​ . On the other hand, we can prove that if A 1 ​ ≤B 1 ​ , there is a way to write integers that is consistent with the sequences. Actually, we can do so as follows: write A 1 ​ ,A 2 ​ ,B 1 ​ ,B 2 ​ on (1,1),(2,2),(2,1),(1,2), respectively; write A 3 ​ ,…,A N ​ on (3,1),…,(N,1), respectively; write B 3 ​ ,…,A M ​ on (1,3),…,(1,M), respectively; write A i ​ on each of the remaining squares in the i-th row. By considering the case where the maximum value among A i ​ is fixed to x, we can see that there are ∑ x=1 K ​ (x N −(x−1) N )(K−x+1) M such pairs of sequences. E - Rvom and Rsrev Editorial by evima Below, let s i ​ denote the i-th character of S, and assume that S has c a ​ occurrences of a and c b ​ occurrences of b. First, let us do a case analysis on the last character of S. If S ends with a: Let k be the minimum integer such that s k ​ =⋯=s ∣S∣ ​ = a. Also, let s 0 ​ = b for convenience. By repeating the operation below, we can make S start with bb...b ( c b ​ bs), so bb...b is a lower bound of the answer. If there exists 1≤i<k such that s i−1 ​ = b, s i ​ = a, s i+1 ​ = a, do the operation on s i ​ and s k ​ . Otherwise, if there are multiple indices 1≤i<k such that s i−1 ​ = b, s i ​ = a, s i+1 ​ = b, choose two of them arbitrarily and do the operation between them. Otherwise, if there exists i<k such that s i ​ = a, do the operation on s i ​ and s k ​ and terminate. Otherwise, terminate. The proof of this relies on the facts that the first two operations keep the property that S ends with a, and that there is at most one index i<k such that s i ​ = a when the first two operations cannot be done. To achieve the lexicographically maximum result, we need to find the maximum t such that we can change S to bb...baa...a ( c b ​ bs and t as). Let us prove that the above operation achieves the maximum value of t, that is, minimizes the number of operations. Let us call the consecutive as at the end of S the tail. Assume that there are x substrings of length 1 consisting of a and y substrings of length 2 consisting of b other than the tail. That is, there are x pairs of integers 1≤i<j<k such that s i−1 ​ = b, s i ​ =⋯=s j ​ = a, s j+1 ​ = b whose “length” j−i+1 is 1, and y such pairs of integers whose length is 2. Here we define the potential of S, ϕ(S), as x+2y. Then, we can see that any operation on two as decreases ϕ(S) by at most 2. Since the desired string has the potential of 0, we need at least ⌈ϕ(S)/2⌉ operations. Additionally, we can see that the above operation achieves this minimum number of operation required, from the facts that the first and second actions in the operation decrease ϕ(S) by 2, and that the third action is done at most once. Thus, in this case, we can find the answer from the potential. We can easily find the potential in linear time, so the answer can also be found in linear time. If S ends with b: In this case, it is impossible to make S ends with a without deleting b. Let us do another case analysis on the parity of c a ​ and what the tail looks like. If c a ​ is even: By repeating the operation on two as, we can change S to bb...b ( c b ​ bs), and we cannot bring a to the end of S, so the answer is bb...b ( c b ​ bs). If c a ​ is odd and S ends with ab: By repeating the operation on two as that are not at the end of S, we can change S to bb...bab ( c b ​ −1 bs, one a, and one b). It is impossible to make a lexicographically greater string by deleting bs, and we cannot bring a to the end without deleting b, so this is the lexicographically greatest string we can make. If c a ​ is odd and S ends with abb: By repeating the operation on two as that are not at the end of S, we can change S to bb...bab ( c b ​ −2 bs, one a, and two bs). It is impossible to make a lexicographically greater string by deleting bs, and we cannot bring a to the last two positions in S without deleting b, so this is the lexicographically greatest string we can make. If c a ​ is odd and S ends with bbb: If S is aa...abb...b ( c a ​ as and c b ​ bs), we cannot bring b to the beginning, so the lexicographically greatest string we can make is stbb...b (one a and c b ​ bs), which can be obtained by repeating the operation on two as. Otherwise, we can bring a to the end of S by doing the following operation just once: If there exists 1≤i≤∣S∣−2 such that s i ​ = b, s i+1 ​ = a, s i+2 ​ = a, do the operation on s i ​ and s ∣S∣ ​ (Operation A). Otherwise, choose 1≤i≤∣S∣−2 such that s i ​ = b, s i+1 ​ = a, s i+2 ​ = b and do the operation on s i ​ and s ∣S∣ ​ (Operation B). To the string obtained this way, we can do the operation described above in the case where S ends with b to make S begin with bb...b ( c b ​ −2 bs). Since it is impossible to make S begin with c b ​ −2 or more consecutive bs without deleting bs, so there will be c b ​ −2 consecutive bs at the beginning of the answer. Now, similarly to the previous case, in order to achieve the lexicographically greatest result, we need to find the maximum t such that we can change S to bb...baa...a ( c b ​ −2 bs and t as). Let us prove that the above operation achieves this maximum value of t, that is, minimizes the number of operations. We define the potential of S, ϕ(S), in the same way as in the previous case. In order to bring a to the end of S, we need to do the operation on the b at the end of S. This operation decreases ϕ(S) by at most 2. To keep c b ​ −2 bs, we can do at most one operation on bs, so any operation, including the ones on as, decreases ϕ(S) by at most 2, and we need ⌈ϕ(S)/2⌉ operations. If there exists 1≤i≤∣S∣−2 such that s i ​ = b, s i+1 ​ = a, s i+2 ​ = a, Operation A decreases ϕ(S) by 2, so we can make the lexicographically greatest string by the method above. Below, we assume there is no such i. Then, Operation B decreases ϕ(S) by 1. Thus, if the ϕ(S) is initially odd, we can make the lexicographically greatest string by the method above. If the ϕ(S) is initially odd, the method above does ϕ(S)/2+1 operations. That is, we have to show that it is impossible to change S to bb...baa...a ( c b ​ −2 bs and t as) in ϕ(S)/2 operations. Note that, in such a sequence of operations, every operation must decrease ϕ(S) by 2. In S, the operations that we can do on as are as follows. Here, we call the consecutive as at the beginning of S the head. Do the operation on two as in the head, which decreases ϕ(S) by at most 1. Do the operation on an a in the head and an a not in the head. ϕ(S) will decrease by 2 only when the head has two or fewer as, but this will not make new 1≤i such that s i ​ = b, s i+1 ​ = a, s i+2 ​ = a. Do the operation on two as not in the head. This will not make new 1≤i such that s i ​ = b, s i+1 ​ = a, s i+2 ​ = a. Thus, after all, we can see that it is impossible to decrease ϕ(S) by 2 when doing the operation on bs, so we need ϕ(S)/2+1 operations. From this fact, we can restore the value t. Since we can find the value ϕ(S) in linear time, we have solved the problem in linear time using all the arguments above. F - Social Distance Editorial by evima Let f(z) be the probability that the answer is not less than z. Then, we can find the probability by integrating f, so let us try to find f(z). We can solve the problem for a fixed z as follows. Let us consider the N intervals [x i ​ −(i−1)z,x i+1 ​ −(i−1)z]. Then, we have to find the probability that the real numbers y i ​ chosen uniformly at random from those intervals satisfy y 1 ​ <y 2 ​ <…<y N ​ . Let us sort the endpoints of the intervals and let v 1 ​ <v 2 ​ <…<v 2N ​ denote them. Then, we have the following DP solution: dp[i][j][k]= (The probability that y i−k ​ <v j ​ <y i−k+1 ​ <…<y i ​ ≤v j+1 ​ when the values up to y i ​ are chosen. This makes us able to compute the transitions. The important transition is dp[i][j][k]→dp[i+1][j][k+1], where the “weight” of the transition is the probability where y i+1 ​ is in [v j ​ ,v j+1 ​ ], multiplied by 1/(k+1), which corresponds to the change from the probability that k values are in ascending order to the probability that k+1 values are in ascending order. With this DP, we are now able to find the answer for a fixed z in O(poly(N)) time. Now, let us unfix z. The values v i ​ are all in the form −az+b. Also, the result of the DP above is a polynomial of variables v i ​ . In the end, for sequences (v 1 ​ ,v 2 ​ ,…,v 2N ​ ) that are the same when seen as polynomials of z whose degrees are 1, the result of the DP is the same polynomial of z. Thus, for unfixed z, we focus on the moment when the values v i ​ change (the magnitude relation of the polynomials changes), and do the DP above for parts where they do not change. If we store the values in the DP table as polynomials of z, or evaluate the result for some number of z and use polynomial interpolation, we can integrate f(z) in the end. Since the values v i ​ change most O(N 2 ) times, we now have a solution that works in O(poly(N)) time. Our intended solution is O(N 6 ), but solutions such as O(N 7 ) will also pass if the constant factors are not too big. A - B = C Editorial by evima First, for an integer C, how many pairs A,B of integers between L and R (inclusive) satisfy A−B=C? If C>R−L, there is no such pair; otherwise, there are R−C−L+1 pairs: (B,A)=(L,L+C),…,(R−C,R). Thus, we can find the answer by summing this over C=L,L+1,…,R. This can be done by first finding the range of numbers such that C≤R−L and then using the formula to find the sum of an arithmetic progression, in O(1) time. B - -- - B Editorial by evima Exactly C yen First, what can we make from an integer B using exactly C yen? Let us consider a specific sequence of operations and focus on an operation that subtracts 1. Ultimately, that operation has the following effect on the final number: if we multiply the number by −1 an odd number of times later, the subtraction increases the final number by 1; if we multiply the number by −1 an even number of times later, the subtraction decreases the final number by 1. Thus, except when we never multiply the number by −1, we can assume we can do all multiplications in the beginning to make both addition and subtraction available for 2 yen. When C is odd We can write C=2n+1 with an integer n. Since the subtractions always cost an even number of yen in total, we need to do the multiplication an odd number of times. After that, Snuke’s integer becomes −B. We can do the multiplication any odd number of times, so we can do the addition and subtraction in the end any number of times not exceeding n. Thus, we can make every integer from −B−n through −B+n. When C is even We can write C=2n with an integer n. If C=0, we can make B only. Below, we assume C>0 (that is, n>0). Similarly to the “odd” case, we need to do the multiplication an even number of times. If we never use the multiplication, we can make B−n. If we do use the multiplication, Snuke’s integer is still B after an even number of multiplications. We can do the multiplication any positive even number of times, so we can do the addition and subtraction in the end any number of times not exceeding n−1. Thus, we can make every integer from B−n+1 through B+n−1. Therefore, we can make every integer from B−n through B+n−1. The solution to the original problem From the conclusions for the above case where we use exactly C yen, we can see that every number that can be made with C=k yen can also be made with C=k+2 yen. Thus, we just need to consider two cases where we use exactly C yen and exactly C−1 yen. Let us say we can make the numbers from a through b with C yen and the numbers from c through d with C−1 yen. There are b−a+1 numbers that can be made with C yen, and d−c+1 numbers that can be made with C−1 yen. The intersection of these two sets contains max(0,min(b,d)−max(a,c)+1) numbers, so the answer is: \begin{aligned} (b-a+1) +(d-c+1) -\max(0, \min(b,d)-\max(a,c)+1) \end{aligned} C - DFS Game Editorial by evima Once the piece enters some subtree, it never exits from it until there is no more coin in it. Also, once the piece exits from a subtree, it never reenters it. Thus, we can solve the problem for each subtree recursively. Let f(v) be the number of coins the first player gets minus the number of coins the second player gets when they play the game in the subtree rooted at v. We compute f(v) recursively along the tree. The optimal play When they play the game in the subtree rooted at v, the first player gets the coin on v first. Then, the second player chooses the vertex to which the piece goes. To consider the optimal choice, we will divide the children u of v into three categories: f(u)<0 and the size of the subtree rooted at u is even; f(u)≥0 and the size of the subtree rooted at u is even; the size of the subtree rooted at u is odd. If a player moves the piece to a vertex of category 1, he will be able to get more coins than the opponent does (in that subtree), and he will get to choose a child of v again. That is, moving the piece there does not make him lose anything, so if a vertex of category 1 is available among the children of v, he should always choose it. If a player moves the piece to a vertex of category 2, he will never be able to get more coins than the opponent does, then he will get to choose a child of v again. That is, whether he chooses that vertex or not does not affect the turns, and there is no profit in choosing it, so he has no reason to choose it; he should avoid choosing a vertex of category 2 unless he is forced to do so. If a player moves the piece to a vertex of category 3, after all the coins are taken from the subtree rooted there, he will return the piece to v himself. That is, the opponent will choose a child of v next, so he should immediately choose the “best” subtree, or the opponent will do so. Thus, if a vertex of category 3 is available among the children of v, he should choose the one with the minimum f(u). As a result, if there are multiple vertices of category 3, the second player will take one with the minimum f(u), the first player will take one with the second minimum f(u), the second player will take one with the third minimum f(u), and so on. We can solve the problem by computing f(v) based on this optimal play. We need to sort the vertices of category 3, so the solution will have the complexity of O(nlogn). D - Skate Editorial by evima Problem proposed by: potetisensei Starting at anywhere on the rink, we can stop on (1,1), so if the rink is efficient from (1,1), we can say the rink is efficient from every square. Thus, we just need to consider the case where we start by standing still on (1,1). Let us call a row good when we can start at (1,1) and stop on some of the squares in that row. Similarly, let us call a column good when we can start at (1,1) and stop on some of the squares in that c.olumn. The following two conditions are equivalent: (A) The rink is efficient from (1,1). (B) All rows are good, or all columns are good. Let us show this. We will first show that if (B) holds, (A) holds. Assume all rows are good. Choose an arbitrary square (r,c). Since all rows are good, we can stop in the r-th row. If we then start moving east or west, we can pass (r,c), so (A) holds. The case where all columns are good is similar. Next, we will show the contraposition of “if (A) holds, (B) holds.” Assume there is r such that we can stop on none of the squares in the r-th row, and there is c such that we can stop on none of the squares in the c-th column. Thanks to the walls, we can always stop in the 1-st row and in the 1-st column, so neither r nor c is 1. Here, we can never pass (r,c). This is because, in order to do so, we need to start moving east or west after stopping somewhere in the r-th row or start moving north or west after stopping somewhere in the c-th column. Solution Thanks to the walls, the following holds: The 1-st row is good ⟺ The 1-st column is good The 1-st row is good ⟺ The W-th column is good The H-th row is good ⟺ The 1-st column is good The H-th row is good ⟺ The W-th column is good The 1-st row is good Additionally, if (r,c) is a ground square, the following holds: The r-th row is good ⟺ The c-th column is good Consider a graph where there is a vertex for each row and each column and there is an edge between each pair of vertices such that “the r-th row is good ⟺ the c-th column is good.” Changing an ice square to a ground square corresponds to adding an edge to this graph. The r-th row is good iff the vertex corresponding to the r-th row and the vertex corresponding to the 1-st row are connected. That is, all vertices corresponding to the rows are connected iff all rows are good. Thus, the minimum number of changes needed to make all rows good is equal to the minimum number of edges needed to make all vertices corresponding to the rows. We can find this minimum number of edges by subtracting 1 from the number of connected components containing vertices corresponding to rows. We can also handle the columns similarly. Therefore, the answer is min((the number of connected components containing vertices corresponding to rows)−1, (the number of connected components containing vertices corresponding to columns)−1). We can find it by depth-first search or breadth-first search in O(HW) time, or using disjoint set union. E - Cigar Box Editorial by evima Let us say an operation is essential when it is the last operation applied to that number. The condition that the numbers of essential operations must satisfy Consider the case we did L essential operations that moves a number to the beginning and R essential operations that moves a number to the end. Then, a L+1 ​ ,…,a n−R ​ were never subject of an operation, so their relative order did not change from the initial state (1,2,…,n). Thus, this sequence must be monotonically increasing. An O(n 2 m) solution The number chosen in the i-th last essential operation that moves a number to the beginning will be the i-th term in the final sequence, so this operation must choose a i ​ . Similarly, the i-th last essential operation that moves a number to the end must choose a n−i+1 ​ . A non-essential operation may choose any number that will be chosen by a later operation and move it to either the beginning or the end. From these, for L+R≤n such that a L+1 ​ ,…,a n−R ​ is monotonically increasing, there will be a unique sequence of operations if the following is decided: which L essential operations moves a number to the beginning; which R essential operations moves a number to the end; for each non-essential operation: whether it moves a number to the beginning or the end; which essential operation will move the number moved by that operation. Thus, we can find the number of sequences of operations of length i containing l essential operation to the beginning and r essential operation to the end, dp[i][l][r], with the following dynamic programming: (the recurrence formula corresponds to constructing the sequence of operations backward.) Copy for i=0..m, l=0..n, r=0..n dp[i+1][l][r] += dp[i][l][r] * 2 * (l + r) dp[i+1][l+1][r] += dp[i][l][r] dp[i+1][l][r+1] += dp[i][l][r] for i=0..m, l=0..n, r=0..n dp[i+1][l][r] += dp[i][l][r] * 2 * (l + r) dp[i+1][l+1][r] += dp[i][l][r] dp[i+1][l][r+1] += dp[i][l][r] After computing dp[i][l][r], we can sum up dp[m][L][R] over all L+R≤n such that a L+1 ​ ,…,a n−R ​ is monotonically increasing to find the answer, but this method will have the complexity of O(n 2 m). An O(n 2 m) solution Here, let j=l+r (that is, the number of integers that will be subject of some operation). Let dp2[i][l][r] be the number of ways to decide the following for a sequence of operations of length i containing j essential operations: whether each operation is essential; for each non-essential operation, which essential operation will move the number moved by that operation. Choosing which of the j essential operations move a number to the beginning will determine the sequence of operations, so we have dp[m][l][r] == dp2[m][l+r] * binom(l+r, l) (binom is the binomial coefficient). We can compute dp2[i][j] as follows: Copy for i=0..m, j=0..n dp2[i+1][j] += dp2[i][j] * 2 * j dp2[i+1][j+1] += dp2[i][j] for i=0..m, j=0..n dp2[i+1][j] += dp2[i][j] * 2 * j dp2[i+1][j+1] += dp2[i][j] Now we are able to solve the problem in O(nm) time, which is fast enough under the constraints. F - Die Siedler Editorial by evima Let (c 1 ​ ,…,c n ​ ) (call it Snuke’s hand) denote the fact that Snuke has c j ​ copies of Card j. The necessary and sufficient condition for being Snuke’s possible hand When you can exchange cards, you may always do so Let us consider a function f(c 1 ​ ,…,c n ​ )=∑ j=1 n ​ 2 j−1 (j−1)!c j ​ that answers the following question: “initially we had just copies of Card 1, then exchanged cards some number of times, and now our hand is (c 1 ​ ,…,c n ​ ). What is the minimum possible number of copies of Card 1 we initially had?” The remainder when the value of this function is divided by N:=2 n n!−1 does not change by exchanging cards. From this, we can show that when to exchange cards is irrelevant to what the final hand will be, so we will always do so when possible. Then, we only need to consider hands (c 1 ​ ,…,c n ​ ) such that 0≤c j ​ <2j. The necessary and sufficient condition This function takes the same value modulo N only when f(0,…,0)≡f(2−1,…,2n−1)≡0 (mod N), but the constraints guarantee that our hand cannot be empty, so we can assume that there is one-to-one correspondence between the hands and the values of the function. The necessary and sufficient condition for (d 1 ​ ,…,d n ​ )  =(0,…,0) being Snuke’s possible hand is \begin{aligned} d \equiv c ~(\text{mod gcd} (N,s_1,\dots,s_m)) ~\cdots (1) \end{aligned} where c=f(c 1 ​ ,…,c n ​ ) mod N,d=f(d 1 ​ ,…,d n ​ ) mod N,s i ​ =f(s i,1 ​ ,…,s i,n ​ ) mod N. Proof It follows from the Chinese remainder theorem (or extended Euclidean algorithm) that (1) is equivalent to (1’): \begin{aligned} \exists a_0\dots,a_m\in \mathbb{Z}, d - c = a_0N+a_1s_1+\dots +a_ms_m ~\cdots (1’) \end{aligned} Let a 1 ​ ,…,a m ​ be the numbers of times we buy Card Pack i, and −a 0 ​ be the number of times we exchange cards with j=n. Then, we have d=c+a 0 ​ N+a 1 ​ s 1 ​ +⋯+a m ​ s m ​ , so (2) is a necessary and sufficient condition for (d 1 ​ ,…,d n ​ ) being a possible hand. Thus, we just need to show that (1’) and (2) are equivalent. It is obvious that (1’) holds if (2) holds, so we will show (2) from (1). Let us take integers a 0 ​ ,…,a m ​ such that d−c=a 0 ​ N+a 1 ​ s 1 ​ +⋯+a m ​ s m ​ . For j=1,…,m in this order, do the following operation: Copy while (a_0 > 0 or a_j < 0) { a_0 -= s_j // decreases a_0 N + a_1 s_1 + ... + a_m s_m by N s_j a_j += N // increases a_0 N + a_1 s_1 + ... + a_m s_m by N s_j } while (a_0 > 0 or a_j < 0) { a_0 -= s_j // decreases a_0 N + a_1 s_1 + ... + a_m s_m by N s_j a_j += N // increases a_0 N + a_1 s_1 + ... + a_m s_m by N s_j } Then, a 0 ​ ,…,a m ​ will satisfy all conditions in (2). Solution Let g:=gcd(N,s 1 ​ ,…,s m ​ ). When g is large There are only N/g possible hands not greater than N. If we can afford O(N/g) time, try them all. When g is small Consider it as the shortest path problem and do a breadth-first search to solve it in O(gn) time. More specifically, consider a graph with vertices 0,…,g−1 corresponding to the hand (d 1 ​ ,…,d n ​ ) being f(d 1 ​ ,…,d n ​ ) mod g=0,1,…,g−1 and directed edges (v+1) mod g,…,(v+2 j−1 (j−1)!) mod g,…,(v+2 n−1 (n−1)!) mod g. The answer is the length of the shortest path from the vertex 0 to the vertex f(c 1 ​ ,…,c n ​ ) mod g (considering only paths of length greater than 0). Solution for the general case There are only 15 possible values for N: 2 2 2!−1,2 3 3!−1…,2 16 16!−1, and the gcd can only be a divisor of one of them. After writing a program to list their divisors or using WolframAlpha, it turns out that each of those divisors is large or small, which enables us to solve the problem. A - Two Sequences 2 Editorial by evima We can represent c n ​ as c n ​ =max(c n−1 ​ ,max(a 1 ​ ,a 2 ​ ,…,a n ​ )b n ​ ), that is, the greater of the following: c n−1 ​ , and the maximum value among the first n values in a multiplied by b n ​ . We can easily find the maximum value among the first n values in a. It is also easy to find c 1 ​ from c 1 ​ =a 1 ​ b 1 ​ . Thus, we can find c 2 ​ ,c 3 ​ ,…,c N ​ in this order in a total of O(N) time, which is fast enough for N≤2×10 5 . Copy #include <algorithm> #include <iostream> #include <vector> using ll = long long; using namespace std; const char EOLN = '\n'; int n; int main() { cin >> n; vector<ll> a(n), b(n), c(n); for (int i = 0; i < n; i++) cin >> a[i]; for (int i = 0; i < n; i++) cin >> b[i]; ll ma = a[0]; c[0] = a[0] * b[0]; for (int i = 1; i < n; i++) { ma = max(ma, a[i]); c[i] = max(c[i - 1], ma * b[i]); } for (int i = 0; i < n; i++) cout << c[i] << endl; return 0; } B - Mex Boxes Editorial by evima Let us assume that the boxes show numbers also before we finish putting the balls in them. Initially, all K boxes show 0. Let X denote the number of balls with 0. We can make at most min(K,X) boxes show values not less than 1. On the other hand, for at least K−min(K,X) boxes, we have no choice but to let them show 0. We can see that, after putting balls with 0 in boxes, if we throw away the boxes not showing 1 and subtract 1 from the values shown by the boxes and the values written on the balls, we get the original problem again. It can also be seen that it is the number of remaining boxes that affects the final answer. We can show from this that we should keep as many boxes as possible. In the end, we should put the balls in the boxes in ascending order of written value and make as many changes as possible to the values shown by the boxes. We can do this in O(NlogN) or O(N) time, which is fast enough for N≤3×10 5 . C - Robot on Grid Editorial by evima The sum of the numbers of paths the robot can take from (1,1) to (H,W) over all ways to write letters, is equal to the following: the sum, for all paths from (1,1) to (H,W), of the numbers of ways to write letters so that the robot can take the paths. Instead of dealing with the former, let us try to find the latter. We assume that, from an empty square, both moves are available: right and down. Let dp(h,w,k) be the number of paths the robot can take from (1,1) to (h,w) that traverse k empty squares. On the empty squares traversed by the robot, we need to write X or the letter corresponding to the direction the robot went from that square. On the other squares, we are allowed to write any letter. Thus, the answer is ∑ 1≤k≤H+W ​ dp(H,W,k)2 k 3 HW−K−k , which we can find in O(HW(H+W)) time. Here, instead of keeping k as a part of the state, we can multiply the numbers by 3 2 ​ in the transition and by 3 HW−K in the end, we can find it in O(HW) time, which is fast enough for H,W≤5000. D - Choosing Up Sides Editorial by evima We will describe the admin’s solution, which is easy to explain. Let popcount(n) denote the number of 1s in the binary notation of n, and x AND y denote the bitwise AND of x and y. Let M=2 N−1 . In one operation, the total number of pairs of players belonging to different teams increases by M 2 . Thus, it is necessary that (n+m)M 2 =m( 2 2M ​ ) holds, which can be transformed into n:m=M−1:M. From this, we can see that the number of operations must be a multiple of 2 N −1 to achieve the objective. In the end, we can achieve it in 2 N −1 operations, the minimum number of operations possible, as follows: in the i-th operation, put Person j in Team A if popcount(i AND j) is odd, and in Team B if it is even. We can do it in O(4 N ) time, which is fast enough for N≤8. E - Greedy Ant Editorial by evima The result of the game does not change if we change Snuke’s actions in the game to the following: Before the start of the game, Snuke prepares a mat and some coins. Initially, no coin is on the mat. In Snuke’s turn, he does the following: Put one coin on the mat. (Let k be the number of coins on the mat after this.) Choose an integer n between 0 and k. Remove n coins from the mat and take n candies of his choice. If Snuke takes the candy Ant ignored in her last turn, it corresponds to taking that candy in this turn in the original game. On the other hand, if he takes one of the other candies, in the original game, it corresponds to taking that candy in this turn, or some previous turn when the candy Snuke took is not yet determined. In the end, we should maximize the total tastiness of the candies Snuke takes in this new game. With a DP where the state consists of the pair of candies to the left and right of Ant and the number of coins on the mat, we can do it in O(N 3 ) time, which is fast enough for N≤400. F - Keyence Repetition Editorial by evima Let us first consider the case s is, for example, a repetition of abcde. It turns out it is easy to solve. Let f i ​ denote the position of the i-th character of t in s. The character t i ​ uniquely determines the value f i ​ mod5, so let g i ​ =floor((f i ​ +4)/5) and let us only consider g i ​ . Depending on the characters t i ​ and t i+1 ​ , we have a contraint of the form g i ​ ≤g i+1 ​ or g i ​ <g i+1 ​ . Also, 1≤g i ​ ≤N must naturally hold. Then, the number of sequences g i ​ satisfying those constraints equals the number of ways to extract t from s. We can find this count as a simple formula with a binomial coefficient. Let us go back to the case where s is a repetition of keyence. We cannot directly apply the above method because the positions of es mod7 are not uniquely determined. (Note that, on the other hand, the positions of other characters mod7 are uniquely determined.) Here, for each e in t, let us fix its position mod7. Then, we have constraints of the form g i ​ ≤g i+1 ​ or g i ​ <g i+1 ​ , and we have to count the sequences g i ​ satisfying them. We said we could find this count by “a simple formula,” which can be written in a form that depends only on the number of indices i such that we have the constraint g i ​ <g i+1 ​ . (The other variables in the formula, such as N and ∣t∣, are determined from the input.) For parts involving e, we can have either of the constraints g i ​ ≤g i+1 ​ and g i ​ <g i+1 ​ . For each maximal substring of t consisting of e, we want to solve the following problem: For each e, we have three options for its position mod7. How many ways to make these choices result in k constraints of the form g i ​ <g i+1 ​ ? Let L be the length of the substring consisting of e we are now looking at. We can solve this problem in O(LlogL) time with FFT and binary lifting. However, we have the coefficient of 27 in the computation time since we have to classify the substrings according to the positions mod7 of the first and last es. (Quiz: this algorithm takes O(k 3 LlogL) time, where k is the number of options for the positions in the cycle, but we can also solve this problem in O(kL+LlogL) time.) Finally, we should regard the answer to the above problem for each maximal substring as a polynomial and multiply all of them, which can be done in O(∣T∣log 2 ∣T∣) time. Therefore, we can solve the problem in a total of O(∣T∣log 2 ∣T∣) time. A - Simple Math 2 Editorial by evima We can compute the formula with, for example, the code below (Python), but it will result in TLE or MLE. Copy print((10 ** n) // m % m) print((10 ** n) // m % m) This is because 10 N (10 ** n) is too large. Generally speaking, the amount of memory needed to handle large integers (without errors) is proportional to the number of digits. Here in AtCoder, we often consider very large numbers mod998244353. Can we use some mod this time as well, instead of handling 10 N itself? It turns out we can use 10 N modM 2 instead of 10 N . We can show that subtracting a multiple of M 2 from 10 N does not affect the answer, as follows: ⌊ M 10 N −kM 2 ​ ⌋≡⌊ M 10 N ​ −kM⌋≡⌊ M 10 N ​ ⌋−kM≡⌊ M 10 N ​ ⌋(modM)(k∈Z) Thus, in the end, the following code gets AC. Copy n, m = map(int, input().split()) print(pow(10, n, m * m) // m % m) B - Reversible Cards Editorial by evima Consider the graph G where there is a vertex for each color and an edge for each card. Then, we can rephrase the problem as follows: For each edge in G, we can light one of the endpoints. At most how many vertices can be lit? We can handle each connected component in G separately, so let us consider just one connected component. If the connected component is a tree, we can light n−1 vertices, where n is the number of vertices in the connected component. We can do this as follows: let us choose some vertex and make it the root, then light the “younger” vertex to light n−1 vertices other than the root. Since the graph is a tree, it has only n−1 edges, so we cannot light more vertices. If the connected component is not a tree, we can light all n vertices. We can do this as follows: let us choose some spanning tree and specify as the root one of the endpoints of an edge e that is not in the spanning tree. Then, do the thing we did where the graph was a tree, and use e to light the root. Thus, the problem boils down to determining whether each connected component in T is a tree. We can do it in linear time with respect to the number of vertices and edges in G, with depth-first search, for example. C - Too Heavy Editorial by evima First, the task is obviously impossible if there is a person who is initially tired and has an “incorrect” piece of baggage. It turns out it is always possible otherwise. Consider the graph where there is an edge from i to p i ​ for each Person i. Since p is a permutation of 1,…,n, it is a set of cycles. Let C be the number of cycles. Let us think of a lower bound of the number of operations. Even if tired people can take part in operations, we need at least N−C operations, so we do need at least N−C operations. Actually, we can construct a sequence of N−C operations, as follows. Let us treat each cycle separately. It is important to notice the following: When an operation is done with two untired people i,j, Person i does not get tired if a i ​ ≥a j ​ . From this fact, if we choose the lightest person i in a cycle, we can reduce the problem to a problem with one less vertex in the cycle. We are done when the cycle has just one vertex, so we can achieve the objective within the cycle with n−1 operations, where n is the initial number of vertices in the cycle. By doing this for each cycle, we can achieve the whole objective with N−C operations. For explanation, we separately treated each cycle, but when implementing the solution, we can just give the correct pieces of baggage to the people in ascending order of weight. D - Orientation Editorial by evima For edges with c a i ​ ​  =c b i ​ ​ , we can easily select the direction. For edges with c a i ​ ​ =c b i ​ ​ , which means there are equal numbers of vertices reachable from a i ​ and b i ​ , it must be reachable from a i ​ to b i ​ and vice versa, that is, they must be strongly connected. Thus, the problem can be rephrased as one where we are given a connected undirected graph and asked to direct the edges so that the graph becomes strongly connected. Actually, we can do it as follows: make a DFS tree, direct each edge in the tree away from the root, and direct the edges not in the tree towards the root. The highlights of the proof of this method are: showing that the graph has no bridge; showing that the root is reachable from every vertex, by paying attention to the lowlinks. Our intended solution takes O(N+M) time under the constraint that guarantees the existence of a solution, and O(N+M+ σ N(N+M) ​ )(σ:wordsize) time without this constraint. E - Simple Math 3 Editorial by evima The problem asks the number of positive integers i such that: there is no multiple of D (call it x) that satisfies A+B×i≤x≤A+C×i. First, note that the segment of available numbers always contains a multiple of D when it is wide enough. More formally, when the width of the segment is D−1 or greater, the segment always contains a multiple of D. Thus, we can assume i≤ C−B D−2 ​ (, from which we can show the answer is finite.) The essence of the problem is to notice that the following two conditions are equivalent: there is no multiple of D (call it x) that satisfies Y≤x≤Z; ⌊ D Y−1 ​ ⌋=⌊ D Z ​ ⌋. Furthermore, if the width of the segment is less than D−1, ⌊ D Z ​ ⌋−⌊ D Y−1 ​ ⌋ is 0 or 1. Thus, if we let K=⌊ C−B D−2 ​ ⌋, the answer to the problem is: K− i=1 ∑ K ​ (⌊ D A+C×i ​ ⌋−⌊ D A+B×i−1 ​ ⌋) . We can compute it fast with floor_sum in AC Library. F - Do you like query problems? Editorial by evima Instead of the sum, let us deal with the expected value. Let us first consider E(t,i):=E[a i ​ after processing t queries]. Then, let P(t,i,v):=P[v≤a i ​ after processing t queries] and X(t,i,v) be the corresponding indicator function. Since a i ​ only takes values among 0,…,M−1, we have E(t,i)=∑ v=1 M−1 ​ P(t,i,v). Let us fix t,i,v. We will say the k-th query matters when l k ​ ≤i≤r k ​ and (it is a “max” query with v k ​ ≥v, or it is a “min” query with v k ​ <v). That is, a query is said to matter when it can affect X(t,i,v). A max query that matters always have a i ​ ≥v, and a min query that matters always have a i ​ <v. If there is no query that matters, X(t,i,v)=0. If there is at least one query that matters, we have X(t,i,v)=1 if and only if the last one is a max query, so we have X(t,i,v)=1 with probability (M−v)/M and X(t,i,v)=0 with probability v/M. Regardless of v, a query matters with probability p i ​ := ( 2 N+1 ​ ) i(N+1−i) ​ ⋅ 2M+1 M ​ , so we have P(t,i,v)=[1−(1−p i ​ ) t ]⋅ M M−v ​ , from which we have E(t,i)=[1−(1−p i ​ ) t ]⋅ 2 M−1 ​ . In the (t+1)-th query, E(t,i) contributes to the answer when the query is a “sum” query and the segment contains i, which happens with probability q i ​ := ( 2 N+1 ​ ) i(N+1−i) ​ ⋅ 2M+1 1 ​ . In the end, the expected value can be computed as ∑ t=0 Q−1 ​ ∑ i=1 N ​ E(t,i)⋅q i ​ . After substituting the values we calculated above, we get a formula with NQ terms. The sum of them for a fixed i over t has a similar form to a geometric series, which we can compute in O(logQ) time, so we can find the answer in O(NlogQ) time. A - Hands Editorial by evima Since the buildings are not so high, we can solve the problem fast enough using the shortest path algorithms such as Dijkstra’s and Floyd-Warshall. We can also solve it in O(1) time with simple implementation, as follows. Consider the sequence of floors arranged in the order visited when going from the 1-st floor of A to the 100-th floor of B using only corridors: A1 - B1 - A2 - B2 - … - A100 - B100 In this sequence, we can move one floor in x minutes and move two floors in y minutes. Let y ′ be min(2x,y), the shortest time needed to move two floors. Then, if the destination is two or more floors away from where we are (in the above sequence), the optimal action is to move two floors in y ′ minutes; if the destination is just one floor away, the optimal action is to move one floor in x minutes. Thus, the answer is floor(d/2)y ′ +x, where d=∣2b+1−2a∣ is the difference between the positions of the a-th floor of A and b-th floor of B in the sequence. Here, ∣x∣ denotes the absolute value of x, and floor(x) denotes truncation, that is, the greatest integer not exceeding x. B - log Editorial by evima The optimal strategy is to buy the log of length n+1, cut it to make as many shortest logs as possible, and buy the rest of the logs. To find how many shortest logs can be made, we need to find the maximum integer k such that 1+⋯+k≤n+1. We can find it with binary search using 1+⋯+k=k(1+k)/2. It may be possible to directly compute the answer from k(1+k)/2≤n+1, but watch out for errors in computing. C - Large RPS Tournament Editorial by evima The problem is easier in both implementation and theory when n is even, so let us concatenate two copies of s and call it s (without changing the answer). After every player ends his/her first round, what is the i-th ( 0-indexed) hand from the left among the hands still surviving? From the way the rounds are arranged, we can see that this is the winner of the match between Player 2i and Player 2i+1. This state is the same as the one with 2 k−1 players where the hands are represented by the string t defined below: Copy for i = 0, 2, ... ,n-2 t[i/2] = the non-loser of a match between s[i] and s[i+1] for i = 0, 2, ... ,n-2 t[i/2] = the non-loser of a match between s[i] and s[i+1] Thus, we can find the answer as the first character of the string obtained by repeating this process k times. D - く / L Editorial by evima For each L-placement of stones, let us consider the sum of x-coordinates and that of y-coordinates: (ax+bx+cx,ay+by+cy). Different placements have different pairs of coordinate sums, which can be shown as follows: Let (x,y) be the coordinates of the stone at the center of an L. We can then represent the coordinates of the other stones as (x+dx,y),(x,y+dy), where dx,dy∈{1,−1}. Here, the sums of x- and y-coordinates are (3x+dx,3y+dy). Thus, when the sums of x- and y-coordinates are (X,Y), we can compute the x-coordinate of the central stone by rounding off X/3. We can also compute dx,dy, so we can restore the coordinates of each stone from the sums of x- and y-coordinates, completing the proof. Therefore, the problem can be rephrased as changing the pairs of coordinate sums from (1,1) to (ax+bx+cx,ay+by+cy). With a breadth-first search, let us find the shortest paths within a small region. The result is as follows: Copy 7, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 7, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 5, 5, , 5, 5, , 5, 5, , 5, 5, , 5, 6, , 6, 7, , 6, 5, , 4, 4, , 4, 4, , 4, 4, , 4, 4, , 5, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 4, 3, , 3, 3, , 3, 3, , 3, 4, , 4, 5, , 6, 7, , 6, 5, , 4, 3, , 2, 2, , 2, 2, , 3, 3, , 4, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 4, 3, , 2, 1, , 1, 1, , 2, 3, , 4, 5, , 6, 7, , 6, 5, , 4, 3, , 2, 1, , 0, 1, , 2, 3, , 4, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 4, 3, , 2, 2, , 1, 1, , 2, 3, , 4, 5, , 6, 7, , 6, 5, , 4, 3, , 3, 2, , 2, 2, , 2, 3, , 4, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 4, 4, , 3, 3, , 3, 3, , 3, 3, , 4, 5, , 6, 7, , 6, 5, , 5, 4, , 4, 4, , 4, 4, , 4, 4, , 4, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 6, , 5, 5, , 5, 5, , 5, 5, , 5, 5, , 5, 5, , 6, 7, , 7, 6, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 6, , , , , , , , , , , , , , , , , , , , , , 8, , 7, 7, , 7, 7, , 7, 7, , 7, 7, , 7, 7, , 7, 7, , 7, 7, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 7, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 5, 5, , 5, 5, , 5, 5, , 5, 5, , 5, 6, , 6, 7, , 6, 5, , 4, 4, , 4, 4, , 4, 4, , 4, 4, , 5, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 4, 3, , 3, 3, , 3, 3, , 3, 4, , 4, 5, , 6, 7, , 6, 5, , 4, 3, , 2, 2, , 2, 2, , 3, 3, , 4, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 4, 3, , 2, 1, , 1, 1, , 2, 3, , 4, 5, , 6, 7, , 6, 5, , 4, 3, , 2, 1, , 0, 1, , 2, 3, , 4, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 4, 3, , 2, 2, , 1, 1, , 2, 3, , 4, 5, , 6, 7, , 6, 5, , 4, 3, , 3, 2, , 2, 2, , 2, 3, , 4, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 5, , 4, 4, , 3, 3, , 3, 3, , 3, 3, , 4, 5, , 6, 7, , 6, 5, , 5, 4, , 4, 4, , 4, 4, , 4, 4, , 4, 5, , 6, , , , , , , , , , , , , , , , , , , , , , 7, , 6, 6, , 5, 5, , 5, 5, , 5, 5, , 5, 5, , 5, 5, , 6, 7, , 7, 6, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 6, 6, , 6, , , , , , , , , , , , , , , , , , , , , , 8, , 7, 7, , 7, 7, , 7, 7, , 7, 7, , 7, 7, , 7, 7, , 7, By observing this table, we can see that the whole table can be computed as follows: Copy long long solve(long long x,long long y) { 	x = (x>0 ? x-x/3 : x+(2-x)/3) - 1; 	y = (y>0 ? y-y/3 : y+(2-y)/3) - 1; 	if(x==0 && y==0) return 0; 	if(x==1 && y==1) return 1; 	return max({x,-x,y,-y}) + (x==y); } long long solve(long long x,long long y) { 	x = (x>0 ? x-x/3 : x+(2-x)/3) - 1; 	y = (y>0 ? y-y/3 : y+(2-y)/3) - 1; 	if(x==0 && y==0) return 0; 	if(x==1 && y==1) return 1; 	return max({x,-x,y,-y}) + (x==y); } We can prove the validity of this by mathematical induction on the number of steps where we consider the change on the pair of coordinate sums by each way of moving a stone. E - 1D Reversi Builder Editorial by evima How to find the number of black stones in the end from the colors of squares and s If the squares at both ends have the same color, all n stones will be of that color. Otherwise, let S B ​ and S W ​ be the connected components of black and white squares at the ends, respectively. Then, If the distance from s to S W ​ is less than the distance to S B ​ , there will be ∣S B ​ ∣ black stones; otherwise, there will be n−∣S W ​ ∣ black stones. Why? We can prove that the white stones always form a connected component, and so do the black stones. Additionally, once a stone is placed at either end, the color of that stone never changes. Thus, if the squares at both ends have the same color, all stones will be of that color. Let us move on to the case the squares at the ends have different colors. We will consider two cases: the case S W ​ gets a stone first, and the case S B ​ gets a stone first. If S B ​ gets a stone first, at the moment just before S W ​ gets a stone later, the leftmost and rightmost stones already placed are both black, so all the stones placed are black, similarly to the argument above. The colors of stones never change from then on, so there will be n−∣S W ​ ∣ black stones in the end. In the same way, if S W ​ gets a stone first, there will be ∣S B ​ ∣ black stones in the end. Therefore, Kuro will put stones trying to reach S B ​ as fast as possible, and Shiro will try to reach S W ​ as fast as possible, so the result depends on the distance from s to S B ​ and S W ​ , in the way stated above. The counting Let W and B be the expected number of white and black stones, respectively. Then, W+B=n, so we can find W if we can find W−B. Now, consider the effect of inverting the colors of squares on the result. In almost all cases, inverting a game that ends with x black stones results in a game that ends with x white stones. Thus, those cases do not contribute to W−B, so we will ignore them. The only other cases are the cases the distances from s to S B ​ and S W ​ are equal. Consider when S B ​ is to the left, and s is to the left of the middle. The difference between the final numbers of black and white stones is 4s−2∣S B ​ ∣−n+2 with probability 2 −n+2s−2∣S B ​ ∣−1 . Thus, we need to efficiently compute the sum of (4s−2∣S B ​ ∣−n+2)2 −n+2s−2∣S B ​ ∣−1 over ∣S B ​ ∣=1,2,…,s−1. This sum has the form Σ i=0 k ​ (a+bi)4 i . Now, consider when S B ​ is to the left, and s is to the right of the middle. The difference between the final numbers of black and white stones is n−2∣S W ​ ∣ with probability 2 n−2s−2∣S W ​ ∣−3 . Thus, we need to efficiently compute the sum of (n−2∣S W ​ ∣)2 n−2s−2∣S W ​ ∣−3 over ∣S W ​ ∣=1,2,…,n−c−2. This sum also has the form Σ i=0 k ​ (a+bi)4 i . The other cases also go similarly, so we just need to compute these sums efficiently. We can do so by precomputing Σ i=0 k ​ 4 i and Σ i=0 k ​ i4 i for each k=0,…,n in a total of O(n) time, and then summing them up after multiplying them by some coefficients. The other option is to transform Σ i=0 k ​ i4 i into Σ i=1 k ​ 4 i Σ j=0 k−i ​ d j , and then transform it again using the formula to find the sum of geometric series to compute it in O(logk) time. Sample Implementation in C++ (We directly dealt with expected values in this article, but this implementation finds the count of stones and then divides it.) F - 1D Kingdom Builder Editorial by evima Let us define the following terms: A black connected component is a maximal segment consisting of black squares. A white connected component is a maximal segment consisting of white squares. A connected component of pieces is a maximum segment of squares with a piece on each of them. Solution The necessary and sufficient condition for a final placement of pieces to be valid is (A) or (B), where: (A) We define the following: a1: the white square at the middle of three consecutive white squares; a2: a black connected component; a3: a black square. The condition: there is a way to encircle all connected component of pieces by encircling them one by one, as follows: You may choose one connected component of pieces containing a1 and encircle it, or not. You may choose any number of connected components of pieces containing a2 and encircle them. You may choose one connected component of pieces containing a3 and encircle it, or not. (B) Similar to (A), but white and black are inverted. DP Let us consider placements of pieces that satisfy (A) and also put a stone on every square where it is required. By maintaining only the states where those conditions are met, we can find the minimum number of stones we need to put. More specifically, we make the DP table have the indices below and maintain the minimum number of stones placed while satisfying the conditions. The number of squares already considered The flag of whether rule 1 is already used The flag of whether rule 3 is already used The flag of whether Square i gets a piece (When Square i gets a piece) the flag of whether the current connected component of pieces contains a1 (When Square i gets a piece) the flag of whether the current connected component of pieces contains the left end of a2 (When Square i gets a piece) the flag of whether the current connected component of pieces contains a2 (When Square i gets a piece) the flag of whether the current connected component of pieces contains a3 We will do a similar DP for condition (B), and the answer is the smaller of the results. The validity of the solution Sufficiency We can realize a final placement of pieces satisfying the condition, as follows: Put a piece on a1. Put a piece on each a2. Put a piece on a3. Expand each connected component of pieces in some order. Necessity First, we can see that we do not have to decrease the number of connected components of pieces. That is, we do not have to put a piece on Square i when there is a connected component of Squares l through i−1 and another of Squares i+1 through r. This is because, after making the connected component of Squares l through i−1, we can put pieces on Squares i,i+1,…,r in this order to get the same result. After putting at least one piece for each connected component of pieces in the final placement, we can easily expand each connected component, so we will only consider the first phase of making new connected components. During the process of putting pieces one by one, let us focus on which of the following patterns each connected component falls into: a: Adjacent to only white squares. b: Adjacent to only black squares. c: Adjacent to both colors of squares. To make a new connected component, one of the following must hold: all of the existing connected components are “a,” or all of them are “b.” We can prove that it is unnecessary to use “a” sometimes and use “b” the other times. That is, if we first choose a or b and stick to that choice when making a new connected component, we can still achieve the optimal placement. Let us show this. Assume that, at some point, all connected components were “a,” but now they are all “b.” We are done if we can show that we can achieve the same placement of pieces not via the state where all of them are “a.” For each connected component, there are only two cases: A connected component of pieces that was “a1” at the point If we add pieces to such a connected component of pieces so that it is adjacent to only black squares, we must put pieces on the whole white connected component containing a1. A connected component of pieces that was placed on a black connected component If we add pieces to such a connected component of pieces so that it is adjacent to only black squares, we must put pieces on both the white connected component to the immediate left and the white connected component to the immediate right. We can instead put pieces on just one of those components. Then, we can see that we have no choice but (A) or (B). A - Sum and Product Editorial by evima We have min(N,M)≤ P ​ . We just need to use brute force to check if there is an integer x such that x(S−x)=P in the range 1≤x≤ P ​ . It works in O( P ​ ) time and is fast enough. Sample Implementation (Python) Copy S,P = map(int, input().split()) for i in range(1000050): if i*(S-i) == P: print("Yes") exit(0) print("No") B - Abbreviate Fox Editorial by evima Let t be a string which is initially empty. We can solve the problem by repeating the following until s becomes empty. Remove the character at the beginning of s and append it to the end of t. Then, if the last three characters in t are fox, remove those characters. It works in O(N) time and is fast enough. C - Keep Graph Connected Editorial by evima It turns out there is always a solution for a tree. Thus, we just need to randomly choose some spanning tree of the graph and consider only that tree. Below is one possible algorithm to find a good way of writing integers on a tree. Let us make the tree rooted and write integers from the root to the bottom. We first write 1 on the root, then write numbers on the vertices just beneath the root, and so on. When we write a number on some vertex u, the parent p of u already has a number written. If the number on p equals the label of the edge, we write some other number; otherwise, we write the number that is the label of the edge. It can work in O(N+M) time, and it is fast enough. D - AB Editorial by evima The answer is obviously 1 for N=2,3. Below, we assume N>3. Let us consider the case c AB ​ = B. (The case c AB ​ = A is almost the same.) If c BB ​ = B, there is only one string that can be made. Below, we assume c BB ​ = A. If c BA ​ = A here, we can construct every string that begins with AB and ends with B, so the answer is 2 N−3 . If c BA ​ = B, among the strings that begin with AB and end with B, we can construct everything that does not contain AA as a substring. In this case, the answer is F N−2 ​ , where F is defined as follows: F n ​ ={ 1 F n−1 ​ +F n−2 ​ ​ if n≤1 otherwise ​ E - Random IS Editorial by evima Let us add Chair 0 at the left end and Chair N+1 at the right end. We see these chairs as marked. Let f(l,r) be the expected number of chairs - considering only the l-th through r-th chairs from the left - that will get marked from now on when the l-th and r-th chairs are already marked, but the others are not. The answer we should find is f(1,N+2). If we have no nice chairs here, f(l,r)=0. Otherwise, it is 1+∑ i=1 k ​ (f(l,s i ​ )+f(s i ​ ,r))/k, where the nice chairs are Chairs s 1 ​ ,s 2 ​ ,…,s k ​ . We can find f in O(N 3 ) time with DP on segments, but it would be too slow. Let us consider separately finding ∑ i=1 k ​ f(l,s_i) and ∑ i=1 k ​ f(s i ​ ,r). Then, what we need to do is to find the sum of f(l,j) and that of f(j,r) over j such that l<j<r,a l ​ <a j ​ <a r ​ . We can do it in O(logN) time with Fenwick Tree or Segment Tree. We can do the whole process in O(N 2 logN) time, which is fast enough. F - Paint Tree Editorial by evima Let D be the diameter of the tree and x,y be the endpoints of the diameter. If x and y are of the same color, the niceness is obviously D. Below, we only consider the case x is white and y is black. An important fact is that there is a white vertex whose distance from x is X. The same goes for y and Y. We can prove this from the fact that x and y are the endpoints of the diameter. Thus, the distances from x and y only matter; the distances between the other vertices do not matter. From here, we can see the following: if there is a vertex whose distances from x and y are both greater than d, there is no way of painting the tree with niceness at most d; otherwise, there are 2 k such ways, where k is the number of vertices whose distances from x and y are both at most d. Using these, we can find the total niceness of all ways of painting the tree. It can be done in O(N) time, which is fast enough. A - Simple Math Editorial by evima We have: a=1 ∑ A ​ b=1 ∑ B ​ c=1 ∑ C ​ abc = a=1 ∑ A ​ a b=1 ∑ B ​ b c=1 ∑ C ​ c = 2 A(A+1) ​ 2 B(B+1) ​ 2 C(C+1) ​ We just need to compute it. Sample Implementation in Python3 follows: Copy A, B, C = map(int, input().split()) sum = A*(A+1)//2 * B*(B+1)//2 * C*(C+1)//2 print(sum % 998244353) A, B, C = map(int, input().split()) sum = A*(A+1)//2 * B*(B+1)//2 * C*(C+1)//2 print(sum % 998244353) By the way, we can also get this formula by entering Sum[ Sum[ Sum[ abc, {c, 1, C}], {b, 1, B}], {a, 1, A}] in https://www.wolframalpha.com/. B - Quadruple Editorial by evima The large value of N makes it impossible to try all possible quadruples (a,b,c,d). Let us first consider the following easier version of the problem: Given integers N and K, find the number f(N,K) of pairs of integers (a,b) such that 1≤a,b≤N and a+b=K. We can find it with a simple formula; actually, we have f(N,K)=min(K−1,2N+1−K) for K=2,3,…,2N. For example, the distribution of sums when roling 2 dice is 1,2,3,4,5,6,5,4,3,2,1 for K=2,..,12. Let us get back to the original problem. We can rephrase the condition as (a+b)−(c+d)=K, so let us first fix x=a+b. Then, we can rewrite the condition as “ a+b=x and c+d=x−K”, so this case contributes f(N,x)×f(N,x−K) to the answer. Thus, we can find the answer by summing this value over x=2,..,2N. The time complexity of this solution is O(N). By the way, we can also solve this problem in O(1) using the inclusion-exclusion principle and so on. C - Shuffle Permutation Editorial by evima The answer is “the answer when only rows can be swapped” multiplied by “the answer when only columns can be swapped.” This can be seen from the fact that swapping rows does not affect the condition for swapping columns. Let us find “the answer when only rows can be swapped.” If we draw an edge between row vectors that can be swapped, it turns out that we can swap connected vectors in any way we like. For example, if we want to swap A and D in A - B - C - D, we can do so as follows: Copy A - B - C - D -> B - A - C - D -> B - C - A - D -> B - C - D - A -> B - D - C - A -> D - B - C - A A - B - C - D -> B - A - C - D -> B - C - A - D -> B - C - D - A -> B - D - C - A -> D - B - C - A Thus, the answer is the product of (the size of a connected component)! over all connected components. You can, for example, use atcoder/dsu to implement this solution. D - Number of Multisets Editorial by evima In this problem, we want to find the following: - The number of ways to decompose K into N numbers, each of which is 1 or 2 1 ​ or 4 1 ​ or … Let us divide these decompositions into two categories: decompositions using 1 at least once and decompositions not using 1. Decompositions using 1: The number of such decompositions is equal to the following: The number of ways to decompose K−1 into N−1 numbers, each of which is 1 or 2 1 ​ or 4 1 ​ or … Decompositions not using 1: The number of such decompositions is equal to the following: The number of ways to decompose K into N numbers, each of which is 2 1 ​ or 4 1 ​ or … By multiplying all values by 2, we can see that this is equal to the following: The number of ways to decompose 2K into N−1 numbers, each of which is 2 1 ​ or 4 1 ​ or … Thus, we have dp[N][K] = dp[N-1][K-1] + dp[N][2K], where dp[N][K] is the answer to the problem. Note that, from the definition of the problem, we have dp[N][K] = 0 for N<K, and we can solve the problem in O(N 2 ) time. E - Mex Mat Editorial by evima Below is the result of an experiment for n=20 and completely random input: Copy 11221202210202021111 02010120101010102020 10101012010101010101 01010101201010101010 20101010120101010101 12010101012010101010 01201010101201010101 02010101010120101010 01201010101012010101 20120101010101201010 12012010101010120101 10101201010101012010 21010120101010101201 20101012010101010120 12010101201010101012 20101010120101010101 01010101012010101010 10101010101201010101 12010101010120101010 01201010101012010101 11221202210202021111 02010120101010102020 10101012010101010101 01010101201010101010 20101010120101010101 12010101012010101010 01201010101201010101 02010101010120101010 01201010101012010101 20120101010101201010 12012010101010120101 10101201010101012010 21010120101010101201 20101012010101010120 12010101201010101012 20101010120101010101 01010101012010101010 10101010101201010101 12010101010120101010 01201010101012010101 We can see that, for somewhat large i and j, the same value appears again and again from upper-left to lower-right. Actually, we can show that a 4,4 ​ =a 5,5 ​ always holds by case analysis or brute force. Thus, by naively computing just the four topmost rows and four leftmost columns, we can solve the problem in O(N) time. F - Sum of Abs Editorial by kobae964 Using the following as the definition of scores doesn’t change the answer: Assign to each vertex either +1 or −1 as its weight. Here, vertices with different weights cannot be connected by edges. The score is the maximum possible sum of (Vertex i’s weight )×B i ​ . Therefore, the problem can be reduced to the following problem: Assign to each vertex one of type +1, type deleted or type −1. Type +1 vertices and type −1 vertices cannot be adjacent. For each vertex, the cost of assigning each type to it is defined as follows. Find the minimum possible cost of an assignment. If B i ​ ≥0 : the cost of assigning types +1, deleted, −1 is 0, B i ​ +A i ​ , 2B i ​ respectively. B i ​ <0 : the cost of assigning types +1, deleted, −1 is 2∣B i ​ ∣, ∣B i ​ ∣+A i ​ , 0 respectively. This problem can be reduced to the minimum cut problem. Specifically, let us have two terminal vertices, S and T, and vertices X i ​ and Y i ​ corresponding to each vertex i in the original graph. After that, add an edge Y i ​ →X i ​ with capacity ∞. In this network, let us pick an arbitrary cut. On which side of the cut X i ​ and Y i ​ are has three possibilities: (S,S), (S,T) or (T,T) where S and T denotes the source’s side to the sink’s side respectively. By assigning types +1, deleted and −1 to these three, the aforementioned problem is reduced to the minimum cut problem. The resulting flow network has O(N) vertices and O(N+M) edges. By using Dinic’s algorithm, the minimum cut of this flow network can be found in O(N 2 (N+M))-time. A - 106 Editorial by evima We have 3 38 >10 18 and 5 26 >10 18 , so if a solution exists, 1≤A≤37 and 1≤B≤25 must hold. Thus, we can solve the problem by computing 3 x +5 y for all pairs (x,y) such that 1≤x≤37 and 1≤y≤25 and printing the following: If there is a pair such that the computed value is N, print it; If there is no such pair, print −1. When implementing it, watch out for overflows and so on. Sample Implementation in Python: https://atcoder.jp/contests/arc106/submissions/17609303 B - Values Editorial by evima In one operation, the sum of values on the two vertices connected by the chosen edge does not change. Furthermore, the sum of values in the connected component containing the chosen edge does not change. Thus, to make the value on each vertex b i ​ , the following must hold for each connected component C: v∈C ∑ ​ a v ​ = v∈C ∑ ​ b v ​ It turns out that, if the above holds, we can always make the value on each vertex b i ​ with proper operations. We will prove it from now on. First, by mathematical induction, we will show the following: for every integer N at least 1, (★) if a tree with N vertices and sequences a,b are given and 1. is satisfied, it is possible to make the value on each vertex b i ​ with proper operations. If N=1, a 1 ​ =b 1 ​ follows from 1., so the objective is acheived with zero operations. Assume that (★) holds for N=K. We now have to show that (★) holds for N=K+1. Let us assume that a tree with N+1 vertices and sequences a,b of length N+1 are given and 1. is satisfied. We randomly choose a leaf in the tree. Let l be the leaf, and m be the vertex connected to the leaf with an edge. Let us choose the edge connecting l and m multiple times in operations to increase a l ​ by +b l ​ −a l ​ and a m ​ by +a l ​ −b l ​ . After these operations, the sums of a and b over the vertices except l will be equal. (We can see this from the following facts. First, the premise in (★) guarantees that the sums of a and b are equal. Second, a l ​ =b l ​ holds after the operations.) Consider the subgraph obtained by removing l from the tree after the operations. l was a leaf, so this subgraph will be a tree again. Additionally, this tree has K vertices, and the sums of a and b are equal. Thus, from the induction assumption, we can change the value on each vertex v except l to b v ​ . Since we already made the value on l b l ​ , we have shown that (★) also holds for N=K+1. We know from the above argument that 1. is the sufficient condition for a graph that is a tree. If the given graph is not a tree, we can decompose the graph into connected components and pick up the spanning tree within each connected component to reduce the problem to the tree version. C - Solutions Editorial by evima The problem P is called the interval scheduling problem, and it is known that the greedy algorithm represented by Takahashi’s program finds the optimal solution. If M<0: As mentioned above, Takahashi’s program prints the optimal solution, so this is never the case. If M=N: The value printed by Aoki’s program is always 1 or greater, so this is never the case. If M=N−1 and N≥2: The value printed by Aoki’s program is always 1 or greater, so in order for M=N−1 to hold, Takahashi’s and Aoki’s programs must print N and 1, respectively. However, in an input where Takahashi’s program prints N, no two intervals intersect, so Aoki’s program also prints N, making the input not a solution for N≥2. If M=0: If we place all intervals so that no two of them intersect, the condition will be satisfied. If none of the above holds, that is, if 1≤M≤N−2: Let us choose one large interval and place M+1 intervals inside it so that no two of them intersects. Then, if we place the remaining N−M−2 intervals so that they do not intersect the other intervals, the condition will be satisfied. D - Powers Editorial by evima Instead of finding: $ L=1 ∑ N−1 ​ R=L+1 ∑ N ​ (A L ​ +A R ​ ) X $ we will first find: i=1 ∑ N ​ j=1 ∑ N ​ (A i ​ +A j ​ ) X and subtract i=1 ∑ N ​ (A i ​ +A i ​ ) X from it and then divide the result by 2. We have: i=1 ∑ N ​ j=1 ∑ N ​ (A i ​ +A j ​ ) X ​ = i=1 ∑ N ​ j=1 ∑ N ​ k=0 ∑ X ​ ( k X ​ )A i k ​ A j X−k ​ = i=1 ∑ N ​ j=1 ∑ N ​ k=0 ∑ X ​ X!⋅ k! A i k ​ ​ ⋅ (X−k)! A j X−k ​ ​ =X! k=0 ∑ X ​ ( i=1 ∑ N ​ k! A i k ​ ​ )( j=1 ∑ N ​ (X−k)! A j X−k ​ ​ ) ​ Thus, by pre-computing i=1 ∑ N ​ k! A i k ​ ​ for every k in a total of O(NK) time, we can find i=1 ∑ N ​ j=1 ∑ N ​ (A i ​ +A j ​ ) X for each X in O(K) time. The total time complexity of this solution is O(NK+K 2 ). (We can also compute the answer in O(NK+KlogK) time using convolution.) E - Medals Editorial by evima Let us do a binary search by considering whether the objective can be achieved no later than Day D. Consider a bipartite graph with N×K+D vertices, N×K of them representing the pairs of an employee and a medal, and D of them representing the days. Let U be the set consisting of the N×K vertices representing the pairs of an employee and a medal. We will draw an edge from the vertex representing each day to the vertices corresponding to the employees working on that day. Then, the objective is equivalent to the existence of a matching covering U. By using Hall’s marriage theorem, we can rephrase this condition as ∣A∣≤∣Γ(A)∣ for every subset A of U. The value ∣Γ(A)∣ only depends on the set of employees contained in A. Thus, for the vertices corresponding to a certain employee, we just need to consider two cases: the case A contains none of those vertices and the case A contains all those vertices. Therefore, we can solve the problem if, for every non-empty subset of employees, we can find the number of days when at least one of the employees contained in the subset comes to work. We can compute it by finding the set of employees who come to work on each day and applying the fast zeta transform. Furthermore, ∣A∣≤NK≤∣Γ(A)∣ holds on Day 2NK and later, so we can see that it takes at most 2NK days to achieve the objective. The total time complexity of this solution is O((NK+N⋅2 N )log(NK)). F - Figures Editorial by evima Let S=∑ i ​ d i ​ . If S≥2(N−1): We will choose one special hole for each part. Let us use the N−1 connecting components one by one as follows: Do the following N−2 times. Choose an unused non-special hole. Among the special holes in parts that are disconnected from the part with the chosen hole, choose an unused one. Connect these two holes. Finally, connect the two unused special holes. Then, in each part, the hole nearest to the last added connected component will be the special hole. The number of ways to complete the figure in this way is: i ∏ ​ d i ​ ×(S−N)(S−N−1)⋯(S−2N+3)×(N−1)! ​ Here, each way to complete the figure is counted multiple times for different order of adding edges, so the answer in this case is: i ∏ ​ d i ​ ×(S−N)(S−N−1)⋯(S−2N+3) ​ If S<2(N−1): In this case, there are not enough holes to insert connecting components, so the answer is 0. Here, if (N≤)S<2(N−1), we have the following: i ∏ ​ d i ​ ×(S−N)(S−N−1)⋯(S−2N+3)=0 ​ Therefore, the answer is always: i ∏ ​ d i ​ ×(S−N)(S−N−1)⋯(S−2N+3) ​ A - Fourtune Cookies Editorial by evima We can assume A≤B≤C≤D without loss of generality, so we do so from now on. The sum of the deliciousness of the eaten cookies and that of the remaining cookies will be equal if and only if A+D=B+C or A+B+C=D. We just need to check whether this holds using, for example, “if” statements. Sample Implementation(C++) Copy #include <algorithm> #include <iostream> using ll = long long; using namespace std; int main() { int a[4]; for (int i = 0; i < 4; i++) cin >> a[i]; sort(a, a + 4); if (a[0] + a[3] == a[1] + a[2] || a[0] + a[1] + a[2] == a[3]) cout << "Yes" << endl; else cout << "No" << endl; return 0; } B - MAX-=min Editorial by evima It takes too much time to simulate the procedure naively. An important fact is that gcd(x,y)=gcd(x,y−x) holds for x and y such that 0≤x≤y. From this, we can show that gcd(a) does not change during the procedure. Thus, we just need to find gcd(a), which can be done fast enough in O(N+log(maxA i ​ )) time using Euclidian Algorithm. C - Camels and Bridge Editorial by evima The collapse of the bridge is unavoidable only if max(w)>min(v). From now on, we assume max(w)≤min(v). Let us consider the case in which the camels must be in the order Camel 1, 2, …, N. Then, we will have N(N−1)/2 restrictions in this form: for i and j such that 1≤i<j≤N, the distance between Camel i and j must be at least x i,j ​ . x i,j ​ can be found in O(logM) after precomputation. Here, the answer (for the fixed order of camels) corresponds to the length of the longest path from Vertex 1 N in the graph where there are directed edges of length x i,j ​ from Vertex i to j. This graph does not have cycles, so we can find the length of the longest path in O(N 2 ) with dynamic programming. We can try all possible orders of camels and find the length of the longest path in each case to find the final answer. This can be done in O(N!N 2 logM) time, which is fast enough. D - Let's Play Nim Editorial by evima Let x i ​ be the number of coins on Dish i after N operations. We will omit the details and just state that it only matters whether ⊕x i ​ is 0 or not, where ⊕ is the bitwise XOR. The players’ objectives depend on the parity of N. If N is odd: the first player plays so that ⊕x i ​ becomes 0, and the second player plays so that ⊕x i ​ does not become 0. If N is even: the first player plays so that ⊕x i ​ does not become 0, and the second player plays so that ⊕x i ​ becomes 0. Let us first explain the case in which N is even. If there is an even number of bags with n coins for every integer n, the second player always wins. This is because the second player can always play symmetrically to the first player so that ⊕x i ​ is always 0 after the second player’s move. On the other hand, the first player always wins in all other cases. This is because the first player can always choose the dish with the most coins and the bag with the most coins, which puts more than half of the coins on one dish, which guarantees ⊕x i ​ will not be 0. Then, let us explain the case in which N is odd. We can see that this case is almost the same as the case above: the second player can always choose the dish with the most coins and the bag with the most coins to put more than half of the coins on one dish. Thus, the second player always wins if N is odd. We can check if the conditions above hold in O(NlogN) time, which is fast enough. E - Keep Graph Disconnected Editorial by evima At the end of the game, G will consist of two connected components that are complete graphs. Let n and N−n be the sizes of these components containing Vertex 1 and Vertex N, respectively. Then, there are N(N−1)/2−n(N−n) edges in total. Since the players alternately take turns, the first player wins if N(N−1)/2−n(N−n)−M is odd, and the second player wins if it is even. Here, if N is odd, one of n and N−n must be even, so the parity of N(N−1)/2−n(N−n)−M does not depend on the two players’ moves. Thus, we just need to check the parity of N(N−1)/2−M in this case. If N is even, the parity of N(N−1)/2−n(N−n)−M does depend on the parities of n and N−n. Let x and y be the sizes of the components containing Vertex 1 and Vertex N, respectively, at the beginning of the game. We will show the following: if x and y have different parities, the first player always wins; otherwise, the first player wins if N(N−1)/2−xy−M is odd, and the second player wins if it is even. If x and y have different parities, the first player can play his first move so that the parities of x and y change in his favor. Then, whatever moves the second player play, the first player can always play a move to negate the change in the parities of x and y, or a move that does not affect the parities, leading to his victory. The case in which x and y have the same parities is almost the same as the case above. If N(N−1)/2−xy−M is odd at the beginning of the game, whatever the second player does, the first player can always negate the change in the parities or avoid affecting the parities, leading to his victory. If N(N−1)/2−xy−M is even at the beginning, the second player can do almost the same to guarantee his victory. We can check if these conditions hold in O(N+M) time, which is fast enough. F - Lights Out on Connected Graph Editorial by evima G=(V,E) is good if and only if G is a connected bipartite graph. For S⊆V, let f(S) be the number of ways to remove some edges from G[S], the subgraph induced in G by S, so that the resulting graph G[S] ′ is a connected bipartite graph. We are done if we can find f(V), but it is hard to compute f directly, so let us introduce a supplementary function. For S⊆V, let g(S) be the sum of the number of ways to paint G[S] ′ using two colors over all graphs G[S] ′ that can result from removing some edges in G[S], the subgraph induced in G by S. We can compute g by finding the number of ways to paint the vertices black, white, or grey and then remove edges so that every remaining edge connects a black vertex and a white vertex. f(S) can be found by subtracting from g(S) the number of the colorings where S is disconnected, then dividing the result by 2. We can compute f in the order from the empty set to V. When properly implemented, it takes O(2 N M+3 N ) time, which is fast enough. A - Plus Minus Editorial by evima By rearranging A=X+Y,B=X−Y, we can find that X=(A+B)/2,Y=(A−B)/2. Sample Implementation: Copy A, B = map(int, input().split()) print((A + B) // 2, (A - B) // 2) B - DNA Sequence Editorial by evima First, let us consider what kinds of strings satisfy the condition. A is complementary to T T is complementary to A C is complementary to G G is complementary to C Thus, it is necessary and sufficient that: (the number of A) = (the number of T) (the number of C) = (the number of G) To check if each segment satisfies these conditions, we can, for example, process the segments with the same left end together to solve the problem in a total of O(N 2 ) time. Bonus: N≤2×10 5 Copy #include <bits/stdc++.h> using namespace std; int main() { int N; string S; cin >> N >> S; int ans = 0; for (int i = 0; i < N; ++i) { int c1 = 0, c2 = 0; for (int j = i; j < N; ++j) { if (S[j] == 'A') c1++; else if (S[j] == 'T') c1--; else if (S[j] == 'C') c2++; else c2--; if (c1 == 0 && c2 == 0) ans++; } } cout << ans << endl; return 0; } C - Fair Elevator Editorial by evima First, let us sort out the conditions. Assume that: A i ​ <B i ​ A 1 ​ ,B 1 ​ ,A 2 ​ ,B 2 ​ ⋯,A N ​ ,B N ​ are all different. Let us say that the person who got on at Floor 1 gets off at Floor x. Then, we can see that the persons who got on at Floor 2,3,⋯,x−1 get off at Floor x+1,x+2,⋯,2x−2. By repeating this argument, we can see that the condition is satisfied if and only if it is possible to divide the 2N floors into segments where the persons with (A,B)=(x,x+k),(x+1,x+k+1),⋯,(x+k−1,x+2k−1) get on and off. Now, let us think of a way to determine, for a fixed division, if it is possible to fill in A and B so that the above holds. Let us make an array that stores (left/right, the person’s ID) for each floor if there is a person bound to get on/off on that floor. For each segment, the following is necessary: There is no person with fixed A and B such that only one of them is contained in the segment. If a person has both A and B in the segment, they are in the correct positions. If the persons who got on/off at Floor x+i/ x+k+i are both already fixed, they are the same person. There is no pair of floors ( x+i, x+k+i) such that the person at Floor x+i is “left.” There is no pair of floors ( x+i, x+k+i) such that the person at Floor x+k+i is “right.” On the other hand, if the above is satisfied for every segment, we can find one correct record by filling in A and B properly. Thus, the problem can be solved by DP. Let dp[ i]:= (true if a segment ends exactly at Floor i and there is no contradiction until Floor i, false otherwise), and make dp[ r] true when a new segment [i+1,r] has no contradiction. The time complexity is O(N 3 ). D - Multiset Mean Editorial by evima A naive DP would have the count of each number and the sum as the states, but its time complexity would be O(N 4 K 2 ) even after optimization, which is too slow, so we need to exploit the particular setting. Let us say we want to count sets whose average is m. We can consider it as the number of balanced states where there is a straight bar that pivots on a fulcrum at coordinate m, and we attach at most K objects of weight 1 at coordinates 1,2,⋯,N. (This is because we can transform (∑ x∈S ​ x)/∣S∣=m to (∑ x∈S ​ (x−m))=0.) An easy-to-implement solution Let us divide the bar at the fulcrum into the left and right parts. Now we have to choose two subsets from S={1,2,⋯,m−1},T={1,2,⋯,N−m} so that the sums are equal. Thus, if we precompute dp[ i][ j] := (the number of sets totaling j considering 1,2,⋯,i) for every i and j, we can process the queries in O(N 2 K) time on average per query. For the precomputation, it is dp[ i−1][ j], dp[ i−1][ j−i] ,⋯, dp[ i−1][ j−i∗K] that transition to dp[ i][ j] above, so we can optimize it by maintaining the sum while “sliding” within each modi, and the time complexity will be O(N 3 K). Sample Implementation A solution using Formal Power Series Even if we do not notice the use of precomputation, we can still maintain the distribution of sums in the left and right parts while shifting the average one by one. (Since the counts are fixed, the relative distribution only changes at both ends.) If we think of the DP above as maintaining ∏(1+x i +x 2i +⋯+x Ki ), since (1+x i +x 2i +⋯+x Ki )=(1−x (K+1)i )/(1−x i ), the addition and removal at both ends can be regarded as multiplying or dividing this formula. This solution has the same time complexity as the solution above and an improved space complexity. E - Random LIS Editorial by evima First, when we consider the length of the LIS, it is only the state after “compression” of the elements that matters. The number of ways to divide N objects into some number of groups and ordering them is called the Ordered Bell number or Fubini number, and there are 4683 such ways for N=6. For a fixed such way, after taking the minimum within a group, we need to solve the following problem: Find the number of strictly increasing sequences of length k such that 1≤a i ​ ≤M i ​ (1≤i≤k). Let us compress M i ​ and let dp[ i][ j]:= (the number of combinations of first i elements such that the last belongs to the j-th segment). We can compute it correctly by only considering the transitions that choose the i+1,⋯,k elements from the same segment that is Segment j+1 or above. The time complexity of this part will be O(N 3 ). (The coefficient has the form ( y x ​ ) where x is large, but y is at most N, so we can compute it fast.) F - Visibility Sequence Editorial by evima Consider the graph with edges i−P i ​ , which is a forest. For simplicity, let us add a positive infinity at the beginning of the sequence, and we can assume the graph is a tree. Here, the vertices 1,2,⋯,N are arranged in the pre-order. That is, if we consider the tree rooted by regarding 0 as the root, each subtree corresponds to the segment [l,r] for some l and r, and the root of the subtree is l. Before counting P, let us consider, for a fixed tree, whether there is a sequence H that produces a graph that is identical to the tree. We can determine it by greedily assigning the vertices the smallest values possible so that the graph matches the tree. More specifically, if a vertex v has children u 1 ​ <u 2 ​ ⋯<u k ​ , because of how edges are spanned, H v ​ >max(H u 1 ​ ​ ,H u 2 ​ ​ ,⋯H u k ​ ​ ) and H u 1 ​ ​ ≤H u 2 ​ ​ ≤⋯≤H u k ​ ​ must hold, and it is sufficient for this to hold for every vertex. Thus, if we greedily assign values in DFS where the children are visited in the order from left to right, writing max(brothers to the left, max of children + 1) to each vertex, we can find the minimum possible value written in each vertex. (We can achieve those minimum values simultaneously.) We will consider a DP using the state after this greedy algorithm as the key. Let us define the following: dp T ​ ree(l,r,x):= considering only the segment [l,r], the number of trees where x is written on the root after the above greedy algorithm dp F ​ orest(l,r,x):= considering only the segment [l,r], the number of states where there are one or more trees and x is written on the root of the rightmost tree after the algorithm Then, the following holds: dp T ​ ree is dp F ​ orest(l+1,r,x−1). dp F ​ orest can be computed from dp T ​ ree+∑ m=l r−1 ​ dp F ​ orest(l,m,a)∗dp T ​ ree(m+1,r,b) ( max(a,b)=x), which can be done faster using prefix sums. (To describe it intuitively, after separately considering the tree that we assign to the right, we just match the root if it is smaller than the value to the left.) The total time complexity will be O(N 4 ). AtCoder Beginner Contest 111 / AtCoder Regular Contest 103 解説 writer: nuip 並びに semiexp 2018 年 9 月 29 日 For International Readers: English editorial starts on page 200. A: AtCoder Beginner Contest 999 与えられる 3 文字をそれぞれ問題文のとおりに置き換えればよいです。 1 #include<iostream> 2 3 using namespace std; 4 5 int main(){ 6 string n; 7 cin >> n; 8 for(char c:n){ 9 if(c == ’1’){ 10 cout << 9; 11 }else{ 12 cout << 1; 13 } 14 } 15 return 0; 16 } 文字列を相互に置き換える処理は次のようにも書けます。 1 #include<iostream> 2 3 using namespace std; 4 5 int main(){ 6 string n; 7 cin >> n; 8 for(char c:n){ 9 cout << (char)(’1’ + ’9’ − c); 10 } 11 return 0; 12 } これを応用して次のようなシンプルなコードでも解けます。 1 #include<iostream> 2 3 using namespace std; 4 5 int main(){ 6 int n; 7 cin >> n; 8 cout << 111 + 999 − n << endl; 9 return 0; 10 } 1 B: AtCoder Beginner Contest 111 x 回目の ABC が黒橋君が初めて参加する ABC としてふさわしいかどうかは，各桁の数字を見ることで確かめられ ます．なので，x = N から始めて，条件を満たすまで 1 ずつ x を大きくしていけば解くことができます． ところで，この問題では，100 ≤ N ≤ 999 という条件から，答えとなる x は必ず 3 桁になります．3 桁で条件を満た す x はすべて 111 の倍数（逆もしかり）なので，N 以上の最小の 111 の倍数を求める方法でも解くことができます． • C++ による解答例: https://beta.atcoder.jp/contests/abc111/submissions/3279754 • Java による解答例: https://beta.atcoder.jp/contests/abc111/submissions/3279759 • Python 3 による解答例: https://beta.atcoder.jp/contests/abc111/submissions/3279761 • Ruby による解答例: https://beta.atcoder.jp/contests/abc111/submissions/3279762 • Rust による解答例: https://beta.atcoder.jp/contests/abc111/submissions/3279784 • Bash による解答例: https://beta.atcoder.jp/contests/abc111/submissions/3279843 C: /\/\/\/ 数列 v1, v2, . . . , vn から偶数番目を取り出した数列 v2, v4, . . . , vn を e とおき、奇数番目を取り出した数列 v1, v3, . . . , vn−1 を o とおきます。問題の条件を e と o を使って言い換えると、次のようになります。 1. e の要素はすべて同じ 2. o の要素はすべて同じ 3. e ̸= o みっつめの条件を無視して考えると、e と o それぞれについて、各要素を数列の最頻値に書き換えるのが最適になりま す。e と o それぞれの最頻値が異なっていれば、その書き換え方でみっつめの条件もクリアできます。そうでない場合は どちらかを最頻値でない値に書き換えなければなりません。 e で一番出現回数の多い要素を E1 とおき、二番目に出現回数の多い要素を E2 とおきます（E1 と E2 の出現回数が同 じということもありえます）。同様に、o で一番出現回数の多い要素を O1 とおき、二番目に出現回数の多い要素を O2 と おきます。今、E1 = O1 であるため、次のふたつの書き換え方のうちどちらかが最適です。 • e を E1 で書き換え、o を O2 で書き換える • e を E2 で書き換え、o を O1 で書き換える この 2 通りを両方試して、書き換える項の数の小さい方が答えです。 D: Robot Arms まず，ロボットアームを決めると，(xm + ym) mod 2 は，モードの設定によらず一定になります．なので，(Xj + Yj ) (mod 2) が一定でなければ，条件を満たすことは不可能です． (Xj + Yj ) (mod 2) が一定であるとします．今，(Xj + Yj ) (mod 2) = 1 と仮定します ((Xj + Yj ) (mod 2) = 0 の場 合は，長さ 1 の腕を追加することで，(Xj + Yj ) (mod 2) = 0 の場合に帰着できます)． 座標 (x, y) に対して，u = x + y, v = x − y とおいて (u, v) を考えます．すると，(ui , vi) と (ui+1, vi+1) の間に次の 関係が成り立ちます： 2 • 腕 i のモードが L のとき，(ui+1, vi+1) = (ui − di , vi − di) • 腕 i のモードが R のとき，(ui+1, vi+1) = (ui + di , vi + di) • 腕 i のモードが D のとき，(ui+1, vi+1) = (ui − di , vi + di) • 腕 i のモードが U のとき，(ui+1, vi+1) = (ui + di , vi − di) よって，{di} を決めたときに {ui}, {vi} を決定する問題を u, v について独立に解けば，各関節のモードも決定できるこ とになります． この {ui} を決定する問題を考えます．ui+1 = ui + di なる i ∈ {1, . . . , m} の集合を S とすると，um = − ∑m i=1 di + ∑ i∈S 2di が成り立ちます．(Xj + Yj ) (mod 2) = 1 の仮定より，Uj , Vj はすべて奇数です．また，−2 31 < −2 · 109 ≤ Uj , Vj ≤ 2 · 109 < 2 31 が成り立っています．よって，m = 31, di = 2i−1 とすると，∑ i∈S 2di = Uj + (231 − 1) が成り立 つように S を選ぶことができます（Uj+(231−1) 2 の二進展開を考えればよいです）．よって，この問題を解くことができ ました． E: Tr/ee s の i 文字目を si で表します。条件を満たす木が存在するためには、以下の条件が必要です。 • s1 = 1 葉につながっている辺を取るとサイズ 1 の連結成分ができるため • sn = 0 どの辺をとっても非連結な頂点対ができるのだから、連結成分は n よりも真に小さくなるため • si = sn−i 木から辺を 1 つとると連結成分はちょうど 2 こできるため。 逆に、以上の条件をすべてみたしている場合、条件を満たす木を構築することができます。直感的には、存在しては いけないサイズの部分木が存在しないように、うまく根付き木を構成していけばよいです。 s の n 文字目を 1 に書き換えた文字列を s ′ とします。頂点 n を根とした木で、次の条件を満たす木を構成します。 1. 辺 i は頂点 i とその親をつなぐ 2. s ′ i = 1 であるとき、 頂点 i の部分木のサイズは i 3. s ′ i = 0 であるとき、頂点 i は葉 このような木は、頂点 i の親を i < j かつ s ′ j = 1 となる最小の j とすると構成できます。これを確かめます。親とな る頂点が s ′ i = 1 であるような i に限られることから条件 3 が満たされることが分かります。また、s ′ j = 1 かつ i ≤ j で ある場合、頂点 i から何度か親をたどることで頂点 j に到達することができることから、1, 2, . . . , j の j 個の頂点は頂点 j の部分木に含まれます。それ以外の頂点が部分木に含まれないことも明らかであるため、条件 2 も満たされます。 • C++ による解答例: https://beta.atcoder.jp/contests/arc103/submissions/3288872 3 F: Distance Sums S(v) で，頂点 v から他の点までの距離の和を表すことにします．木の中に辺 uv があるとき，辺 uv を除去したとき の u, v を含む連結成分の頂点数をそれぞれ nuv, nvu と書くことにすると，S(u) = S(v) + nvu − nuv = S(v) + N − 2nuv が確かめられます． 一般性を失わず，D1 < D2 < · · · < DN としてよいです．木を頂点 1 を根とする根付き木として考えます．ここ で，頂点 1 から他の頂点までのパス 1, p1, p2, . . . , pk を考えます．まず，S(1) < S(p1) より，n1p1 > n 2 です．また， n1p1 < np1p2 < np2p3 < · · · < npk−1pk より，npipi+1 > n 2 であるから，S(pi) < S(pi+1) も成り立ちます．よって，頂点 1 以外の任意の頂点について，それより D の値が小さい頂点への辺がちょうど 1 本存在します． 頂点 N から順に，そのような辺を順次決定していくことを考えます．頂点 i + 1, . . . , N までは確定したとして，頂点 i について考えます．頂点 i に隣接する，i より番号の小さい唯一の頂点を j とすると，S(j) = S(i) + 2nji − N ですが， nji は頂点 i を根とする部分木の大きさに等しく，この値は計算できるので（辺を追加するときに順次更新すればよいで す），S(j) が決まります．Di はすべて異なるという条件から，j を求めることができます．ここで，そのような j が存 在しない（i より大きくなる場合を含む）ときは，条件を満たす木は存在しません． 頂点 2 まですべて決定できた場合は，一つの木ができます．この木について，実際に S(i) の値を計算して（動的計画 法などで可能です），Di に一致していればその木が答えです．一致していない場合は，条件を満たす木は存在しません． 4 AtCoder Beginner Contest 111 / AtCoder Regular Contest 103 Editorial writer: nuip and semiexp September 29th, 2018 A: AtCoder Beginner Contest 999 Some example implementations: 1 #include<iostream> 2 3 using namespace std; 4 5 int main(){ 6 string n; 7 cin >> n; 8 for(char c:n){ 9 if(c == ’1’){ 10 cout << 9; 11 }else{ 12 cout << 1; 13 } 14 } 15 return 0; 16 } 1 #include<iostream> 2 3 using namespace std; 4 5 int main(){ 6 string n; 7 cin >> n; 8 for(char c:n){ 9 cout << (char)(’1’ + ’9’ − c); 10 } 11 return 0; 12 } 1 #include<iostream> 2 3 using namespace std; 4 5 int main(){ 6 int n; 7 cin >> n; 8 cout << 111 + 999 − n << endl; 9 return 0; 10 } 1 B: AtCoder Beginner Contest 111 Some example implementations: • C++: https://beta.atcoder.jp/contests/abc111/submissions/3279754 • Java: https://beta.atcoder.jp/contests/abc111/submissions/3279759 • Python 3: https://beta.atcoder.jp/contests/abc111/submissions/3279761 • Ruby: https://beta.atcoder.jp/contests/abc111/submissions/3279762 • Rust: https://beta.atcoder.jp/contests/abc111/submissions/3279784 • Bash: https://beta.atcoder.jp/contests/abc111/submissions/3279843 C: /\/\/\/ Let E be the sequence v2, v4, . . . , vn, and let O be the sequence v1, v3, . . . , vn−1. We want to do the following (and minimize the number of changes): 1. Change all elements of E to x. 2. Change all elements of O to y. 3. x ̸= y If we ignore the third condition, the problem is easy: x should be the mode (the most frequent element) of E and y should be the mode of O. Thus, in case the mode of E and the mode of O are different, this is the optimal solution. Otherwise, we should try two cases. Let e be the mode of E and e2 be the second most frequent element of E. (Strictly speaking, e2 is the most frequent element of E except for e. It’s possible that e and e2 appear the same number of times in E.) SImilarly, let o be the mode of O and o2 be the second most frequent element of O. Then, the optimal solution is one of the following two: • x = e, y = o2 • x = e2, y = o We try both and choose the better one. 2 D: Robot Arms For a fixed robot arm, the parity of xm + ym is a constant (it must match the parity of the sum of di). Thus, in case (Xj + Yj ) (mod 2) are not the same for all j, it is impossible to satisfy the conditions. Assume that Xj + Yj is odd for all j. (In case they are all even, add a section of length 1 and we can reduce to the ”all even” case.) It turns out that a robot arm with lengths 1, 2, 4, 8, . . . can cover all such positions: • If the robot arm has only one section and its length is 1, the set of positions where the last joint can go is {(1, 0),(0, 1),(−1, 0),(0, −1)}. • If the robot arm has two sections and their lengths are {1, 2}, the set of positions where the last joint can go is {(x, y)||x|+|y| ≤ 3, x ≡ y (mod 2)}. In other words, it can cover all integer points (with correct parities) within a ”rotated square” whose vertices are at (3, 0),(0, 3),(−3, 0),(0, −3). • By induction, we can prove that, if the lengths of sections are {1, 2, . . . , 2 k}, we can cover all vertices with correct parities within a ”rotated square” whose vertices are at (M, 0),(0, M),(−M, 0),(0, −M), where M = 2k+1 − 1. Thus, if we use k = 30, we can reach all given points. To find a way to reach a given point, determine the mode of sections from the longest ones. For example, suppose that we know the position of (xi , yi). If we determine the mode of Section i, we can get the coordinates of (xi−1, yi−1). We should choose it such that (xi−1, yi−1) fits within the valid region (i.e., it should be reachable by lengths {1, 2, . . . , 2 i−2}). E: Tr/ee Clearly, the following conditions are necessary: • s1 = 1 (If we cut a leaf we can get a component with size 1) • sn = 0 (If we cut an edge the sizes of components are less than n) • si = sn−i (When we have a component of size i, the other component has size n − i) These conditions are actually sufficient. Suppose that 0 < x1 < x2 < · · · < xk < n are the positions where s is one (i.e., sxi = 1). Then, the following caterpillar (https://en.wikipedia.org/wiki/Caterpillar tree) satisfies the conditions: 1. The caterpillar has k + 1 ”body” vertices, labelled with 1, . . . , k + 1. They form a path in this order. 2. For each i (2 ≤ i ≤ k), the body vertex i has xi − xi−1 − 1 ”feets”. (In other words, prepare xi − xi−1 − 1 new vertices and attach them to vertex i.) 3 F: Distance Sums Consider a vertex v with the largest value of Dv. Intuitively, v is a vertex that is far from majority of other vertices. We can prove that v is a leaf, and if w is the only vertex adjacent to v, Dw = Dv − (n − 2). We can determine one edge this way (vw), and by repeating similar process we can uniquely determine the entire tree. Let’s formalize this. Without loss of generality, we can assume that D1 < D2 < · · · < DN . Consider the tree as a rooted tree whose root is Vertex 1. In the decreasing order of i, we want to determine the parent of Vertex i. Suppose that the tree contains an edge uv, and when the edge uv is removed from the tree, the sizes (number of vertices) of the two connected components are nuv and nvu (nuv corresponds to the component with u). Then, Du = Dv + nvu − nuv = Dv + N − 2nuv holds. Consider a path 1, p1, p2, . . . , pk. Since D1 < Dp1 , n1p1 > n 2 . Also, since n1p1 < np1p2 < np2p3 < · · · < npk−1pk , npipi+1 > n 2 holds for all i and Dpi < Dpi+1 holds. Thus, if Vertex j is the parent of Vertex i, j < i holds. Suppose that we know the parents of Vertices i + 1, . . . , N. At this point, we know the subtree rooted at Vertex i. If Vertex j is the parent of Vertex i, as we mentioned above, Dj = Di + 2nji − N holds. Since nji is the size of the subtree rooted at i, we can uniquely determine j. (In case such j doens’t exist, we get a contradiction.) We repeat this process until we determine the parents of Vertices 2, . . . , n. Then, we have a tree, and check if this tree really satisfies the conditions. If yes, this is the desired tree (otherwise we get a contradiction). 4 ARC 102 解説 DEGwer 2018/09/01 For International Readers: English editorial starts on page 6. A: Pair K 以下の偶数は ⌊K/2⌋ 個、奇数は ⌈K/2⌉ 個あるので、これらを足し合わせればよいです。 #i n cl u d e <s t d i o . h> i n t main ( ) { i n t k ; s c a n f (”%d ” , &k ) ; p r i n t f (”%d\n ” , ( k / 2 ) ∗ ( ( k + 1 ) / 2 ) ) ; } B: Ruined Square 以下のコードのような式で、残りの点の座標を求めることができます。 #i n cl u d e <s t d i o . h> u si n g namespace s t d ; i n t main ( ) { i n t a , b , c , d ; s c a n f (”%d%d%d%d ” , &a , &b , &c , &d ) ; i n t x = c − a , y = d − b ; p r i n t f (”%d %d %d %d\n ” , c − y , d + x , a − y , b + x ) ; } 1 C: Triangular Relationship K が奇数の時、a, b, c を K で割ったあまりはすべて 0 である必要があります。K が偶数の時、a, b, c を K で割ったあまりはすべて 0 であるか、あるいはすべて K/2 である必要があります。このような組の個数 は、N 以下で K で割って 0 あまるものの個数と K/2 あまるものの個数から求めることができるので、この 問題を解くことができました。 D: All Your Paths are Different Lengths 2 r ≤ L なる最大の r を取ります (r ≤ 19 に注意)。まず、以下のようにすれば、長さ 0 以上 2 r − 1 以下の パスをすべて 1 本ずつ作ることができます。 • r + 1 個の頂点 1, ..., r + 1 を用意し、N = r + 1 とする • 頂点 i から 頂点 i + 1 へ、長さ 0 の辺と長さ 2 i の辺を 1 本ずつ張る さて、こうして作ったグラフの頂点 t から頂点 N に長さ X の辺を張れば、長さ X, X + 1, ..., X + 2t−1 −1 のパスを 1 本ずつ作ることができます。よって、t = N − 1, ..., 1 の順に見て、L − 2 t−1 ≥ 2 r なら頂点 t か ら頂点 N に長さ L − 2 t−1 の辺を張り、L を 2 t−1 だけ減らし、そうでなければ何もしないことを繰り返せば よいです。 E: Stop. Otherwise... どの 2 つのサイコロの出目の和も t にならないような出目の組の個数を高速に数えることができれば、こ の問題を解くことができます。 t が奇数の時、条件は a + b = t となるような各 1 ≤ a, b ≤ K に対し、a, b のどちらか片方は現れないこ とです。このような (a, b) の組の個数を p とすれば、p 個の組のうちいくつか (q 個とする) については組の 目の両方とも出目として現れず、残りについては片方のみ現れることになります。ここで、q を全通り試せば この場合の数は簡単な二項係数 (と 2 べき) で表せる形になるので、この場合は O(K) 時間で解くことができ ます。 t が偶数の時、条件は上記のものに K/2 が 1 個以下しか現れないという条件を加えたものです。よって、 K/2 がいくつ (0 個または 1 個) 現れるかで場合分けをし、上と同様に解けばよいです。 時間計算量は O(K2 + N) です。 F: Revenge of BBuBBBlesort! 列 {ai} = (1, 2, ..., N) から ai−1 < ai < ai+1 なる連続 3 項を反転する (以下「i で操作する」) ことを繰り 返して列 p を作れるか判定すればよいです。このようにして作れる列 p の性質を見ていくことにしましょう。 まず、隣接 2 要素の両方で操作することはないことがわかります。これは以下のように証明されます。 証明: i で操作する前に、i−1 や i+1 で操作したことがあるとする。最後に i−1 で操作したなら pi−1 > pi に、最後に i + 1 で操作したなら pi > pi+1 になっているので、i では操作できない。 2 特に、i で操作したなら、i の位置にある数はそれ以降変化することはありません。 以下、l + 1, l + 3, ..., r − 1 のすべてで操作しており、l − 1, r + 1 では操作していないような区間 [l, r] に列 を分解して考えます。これらの区間に対して操作は独立に行われるので、以下ひとつの区間についてのみ考え ます。 l + 1, l + 3, ..., r − 1 の位置にある数は (l, l + 2, ..., r では操作しないので)(l + 1, l + 3, ..., r − 1 のまま) 変 化することはありません (これらをピボットと呼ぶことにしましょう)。ピボットでない数が操作によって移 動したとします。もしこの数が左に移動したなら、この数のすぐ右にあるピボットの値はこの数より小さく、 よってそれ以降この数は現在の位置より右に移動することはないことが分かります。右に移動した場合も同様 に、それ以降この数が現在の位置より左に移動することはありません。この議論はすべての操作について成り 立つので、ピボットでない数は左に移動し続けるか右に移動し続けるかのどちらかになります (区間の取り方 より、移動しないことはありません)。 さて、左に移動し続ける数同士の順番が変化するなら、それらが入れ替わるときに片方は右に移動している ことになって矛盾します。よって、初期状態より左に移動した数は、常にその相対的な順序を保つことになり ます。同様に、初期状態より右に移動した数も、常にその相対的な順序を保つことになります。 逆に、これらの条件が満たされるとき、すなわち各区間 (区間への分解は上記の議論より列 p から定まる) においてその偶数番目の数は移動せず、奇数番目の数はすべて移動し、左に移動する数たちと右に移動する数 たちはそれぞれその相対的な順序を保つ場合、数が (まだ右に移動する数 ピボット まだ左に移動する数) と いう順に並んでいる場所を一個取って操作を行うことを繰り返すことで p を作ることができることが分かり ます。 よって、以上の条件を満たすかどうかを判定すればよく、これは線形時間で可能なので、この問題を解くこ とができます。 3 ARC 102 Editorial DEGwer 2018/09/01 A: Pair There are ⌊K/2⌋ even numbers and ⌈K/2⌉ odd numbers among positive integers up to K. The answer is the product of these values. #i n cl u d e <s t d i o . h> i n t main ( ) { i n t k ; s c a n f (”%d ” , &k ) ; p r i n t f (”%d\n ” , ( k / 2 ) ∗ ( ( k + 1 ) / 2 ) ) ; } B: Ruined Square You can compute the coordinates of the reaming points as in the code below: #i n cl u d e <s t d i o . h> u si n g namespace s t d ; i n t main ( ) { i n t a , b , c , d ; s c a n f (”%d%d%d%d ” , &a , &b , &c , &d ) ; i n t x = c − a , y = d − b ; p r i n t f (”%d %d %d %d\n ” , c − y , d + x , a − y , b + x ) ; } 1 C: Triangular Relationship When K is odd, a triplet (a, b, c) satisfies the conditions when all of them are divisible by K. It’s easy to count such triplets. When K is even, a triplet (a, b, c) satisfies the conditions when all of them are divisible by K, or when all of them are equivalent to K/2 modulo K. We can count such triplets by counting the number of integers up to N that are equivalent to 0 or K/2, modulo K. D: All Your Paths are Different Lengths Solution 1. Let’s take the maximum integer r such that 2r ≤ L. First, consider the following graph: • There are N = r + 1 vertices numbered 1, . . . , N. • For each i, add two edges from vertex i to vertex i + 1. One of them has length 0, and the other has length 2i−1 . In this graph, there are 2r paths from vertex 1 to vertex N, and their lengths are 0, . . . , 2 r − 1. What happens if we add an edge of length X from vertex t to vertex N? This way we can add X, X + 1, . . . , X + 2t−1 − 1 to the set of lengths. By adding edges of this type properly (by writing L as a sum of powers of two using binary representation), we can get a desired graph. Solution 2. Suppose that we have a graph G that satisfies the condition for L = X. We’ll show how to construct solutions for L = X + 1 and L = 2X using this graph. By repeating these operations properly, we can get a desired graph. • L = X + 1 is easy: just add an edge of length X from source to sink to G. • L = 2X can be constructed as follows. First, double the lengths of all edges in G. Now the set of lengths is 0, 2, . . . , 2X − 2. Then, add a new vertex to G (it will be the new sink), and add two edges from the old sink to the new sink, with lengths 0 and 1. Now the set of lengths is 0, 1, 2, . . . , 2X − 1, and this is what we want. 2 E: Stop. Otherwise... Let’s handle each query independently. For a fixed value of t, we want to count the number of combinations of dice such that the sum of no two dice is t. For simplicity, we say ”x exists” when at least one die shows x. Suppose that t is odd. In this case, the condition can be restated as follows: for each pair (a, b) such that a + b = t, at least one of a or b should not exist. Let’s divide integers 1, . . . , K into pairs, such that the sum of two numbers in each pair is t (and some numbers will be left unpaired). Let p be the number of pairs formed this way. Then, the combination of dice must be of the following form for some integer q: • For q pairs, exactly one of the two numbers in the pair exists. • For the remaining p − q pairs, both numbers don’t exist. • K − 2p numbers are left unpaired: we don’t care if these numbers exist. There are ( p q ) 2 q ways to choose the set of existing numbers (among paired numbers). After that, the number of ways to distribute the number of occurrences of those numbers among N dice are equal to the number of solutions to the following equation: • x1 + · · · + xq + y1 + . . . + yK−2p = N • x1, · · · , xq are positive integers • y1, · · · , yK−2p are non-negative integers Here, x1, · · · , xq corresponds to the number of occurrences of each existing paired numbers, and y1, · · · , yK−2p corresponds to the number of occurrences of each unpaired numbers. This is a well-known task and the answer can be represented by a binomial coefficient. By trying all possible values of q, we can count the desired number in O(K) time (assuming that we do some pre-computation and we can get binomial coefficients and powers in O(1)). When t is even, there is an additional constraint that the number of occrrences of t/2 must be either 0 or 1. Try both possibilities, and the remaining part is the same as above. This solution works in O(K2 + N) time. 3 F: Revenge of BBuBBBlesort! Let’s see the operations in the reverse order: we start with a sequence {ai} = (1, 2, ..., N), and we repeat performing operations of the following type: Choose i such that ai−1 < ai < ai+1, and reverse their orders (we call it ”an operation on i”). We want to check if we can get p this way. First, we’ll prove that we can never make operations in two adjacent positions. Suppose that before performing an operation on i, we have performed operations on i − 1 or i + 1. If the last operation on i − 1 or i + 1 was on i − 1, after the opeartion, ai−1 > ai holds. We can never change this inequality: an operation on i − 2 only makes ai−1 greater, by the assumption above we don’t make operations on i + 1, and operations on other positions obviously don’t affest this inequality. Similarly, if the last operation was on i + 1, ai > ai+1 holds, and we can never change this inequality. Thus, we can’t make an opeation on i, and we get a contradiction. Let’s split the sequence into intervals as follows: al , . . . , ar forms an interval if we perform operations on all of l + 1, l + 3, ..., r − 1, but not on l − 1, r + 1. All elements move within these intervals, thus we can consider these intervals independently. From now on, we only considers the interval al , . . . , ar. We start with al , . . . , ar = l, . . . , r. How can we change these numbers by performing operations only at l + 1, l + 3, ..., r − 1? Elements at positions l + 1, l + 3, ..., r − 1 will never move. Let’s call these elements ”pivots”. Consider a non-pivot element x in this interval. From the definition of intervals, this element must move (unless l = r). Suppose that it moves to the left in the first operation that involves this element. Then, after that, this element is always greater than the pivot to the right of it; and it can never move to the right in the future. We can do the same observaion when it moves to the right first. Thus, each non-pivot element keeps moving in the same direction. Consider two non-pivot elements that moves to the left. The relative order of these elements will not change: to change their relative order, we must swap them, but this is impossible because they must keep moving left. We can say the same thing for elements moving right. On the other hand, these conditions are sufficient; we can achieve the goal by repeating operations on consecutive three elements such that ((An element that wants to go right), (pivot), (An element that wants to go left)). To summarize, the conditions are: • al+1, al+3, . . . , ar−1 must not change, and other elements must change. • If we only consider all elements that moves to the left, they are increasing from left to right. • If we only consider all elements that moves to the right, they are increasing from left to right. From the first condition, we can uniquly determine the way to split the sequence into intervals; after that, the remaining two conditions can be checked in linear time. 4 ABC #107 / ARC #101 Editorial writer: sugim48 2018 年 8 月 25 日 A: Train 答えは N + 1 − i です． • C++ のコード例: https://beta.atcoder.jp/contests/abc107/submissions/3070852 • Java のコード例: https://beta.atcoder.jp/contests/abc107/submissions/3070854 • Python 3 のコード例: https://beta.atcoder.jp/contests/abc107/submissions/3070856 B: Grid Compression まず，黒いマスが含まれる行および列をマークします．その後，マークされた行とマークされた列が交差す る位置の ai,j のみを出力すればよいです． • C++ のコード例: https://beta.atcoder.jp/contests/abc107/submissions/3070967 • Java のコード例: https://beta.atcoder.jp/contests/abc107/submissions/3070968 • Python 3 のコード例: https://beta.atcoder.jp/contests/abc107/submissions/3070969 C: Candles 連続する K 本のろうそくに火を付けるのが最適です．N 本のうち連続する K 本のろうそくを選ぶ方法は N − K + 1 通りしかないので，全探索することにします．連続する K 本のろうそくのうち，最も左のもの を l とし，最も右のものを r とします．l と r を訪れれば，自然と残りのろうそくを訪れることになります． よって，「座標 0 を出発し，座標 xl と座標 xr をともに訪れるための最短時間」が求めるべき値です．これは 次の 2 通りの値の最小値です: • l → r の順に訪れる場合: |xl | + |xr − xl | • r → l の順に訪れる場合: |xr| + |xr − xl | 連続する K 本のろうそくを選ぶ方法を全探索し，この値の最小値を求めれば，それが答えです．時間計算量 は O(N) です． 1 D: Median of Medians まず，中央値の性質を調べてみましょう．長さ M の整数列 b の中央値を x とします．このとき，x は次 の性質を満たします: • b 中に x 以上の要素が ⌈M 2 ⌉ 個以上含まれる． • x は，上の性質を満たす整数の中で最大である． よって，中央値を求める際には二分探索が有効であると分かります．すなわち，前者の性質を満たすような最 大の整数を二分探索で求めればよいです． 以上の方針をこの問題に適用すると，次の問題を解ければよいことになります: ml,r (1 ≤ l ≤ r ≤ N) のうち x 以上の要素は何個か？ 上述の中央値の性質を用い，問題をさらに言い換えます: a の連続部分列 a[l, r] (1 ≤ l ≤ r ≤ N) のうち，x 以上の要素を ⌈ r−l+1 2 ⌉ 個以上含むものは何通りか？ この言い換えにより，a の各要素は x 以上か否かという情報のみが必要であることが分かります．そこで， a の各要素を，x 未満ならば A へ，x 以上ならば B へ置き換えてしまいます．すると，問題は次のように言 い換えられます: a の連続部分列 a[l, r] (1 ≤ l ≤ r ≤ N) のうち，(A の個数) ≤ (B の個数) を満たすものは何通りか？ 見通しをより良くするために，さらに A を −1 へ，B を +1 へ置き換えると，問題は次のように言い換えら れます: a の連続部分列 a[l, r] (1 ≤ l ≤ r ≤ N) のうち，要素の総和が 0 以上のものは何通りか？ 連続部分列の要素の総和は，累積和を用いると簡単に扱えます．(±1 へ変換後の) a の累積和の列を S とし ます．すなわち，各 0 ≤ i ≤ N について Si = ∑i j=1 ai とします．すると，a[l, r] の要素の総和は Sr − Sl−1 と計算できます．よって，最終的な問題は次のようになります: 組 (l, r) (0 ≤ l < r ≤ N) のうち，Sl ≤ Sr を満たすものは何通りか？ これは，数列 S の転倒数を求める問題とほぼ同じです．非常に典型的なので，「転倒数 アルゴリズム」など で検索すると多くの解説が見つかります．この問題は O(N log N) 時間で解くことができます．よって，二分 2 探索のステップ数を掛け合わせると，元の問題は O(N log N log A) 時間で解くことができます．ここで，A は a の要素の最大値です． E: Ribbons on Tree 「辺に少なくとも 1 本のリボンが張られている」という条件よりも，「辺にリボンが張られていない」という 条件の方が扱いやすいので，包除原理を用いることにします．包除原理を用いると，答えは次のように計算で きます: ∑ F ⊆E (−1)|F | (F のどの辺にもリボンが張られないようなペアの分け方の通り数) ここで，E は与えられた木の辺集合とし，F は E の部分集合全体を動きます． まず，F をひとつ固定したとき，「F のどの辺にもリボンが張られないようなペアの分け方の通り数」を求 めてみましょう．木から F の各辺を取り除き，木を |F| + 1 個の連結成分へ分割します．すると，各ペアは同 一の連結成分内の頂点からなる必要があります．よって，各連結成分の頂点数をそれぞれ n1, n2, . . . , n|F |+1 とすると，通り数は g(n1) · g(n2) · · · · · g(n|F |+1) となります．ここで，g(·) は次のように定義されます: g(n) := { (n − 1) · (n − 3) · · · · · 3 · 1 (n : 偶数) 0 (n : 奇数) 当然 F を全探索することはできないので，代わりに根付き木上で DP をします．DP の状態は，「今の部分 木」「今の連結成分の頂点数」に加え，「これまでに取り除いた辺の本数の偶奇」が必要です．よって，dp(·, ·, ·) を次のように定義します: dp(v, x, p) := ( 頂点 v を根とした部分木において，v を含む連結成分の頂点数が x で， 部分木内で取り除いた辺の本数の遇奇が p の場合の，ペアの分け方の通り数 ) この dp を葉から根へ向かって順に更新し，最後に根 r における dp を参照することで，答えが求まります． 部分木どうしの dp をマージするとき，常に x を 0 から N まで回してしまうと，各マージごとに O(N2 ) 時間が掛かります．マージは全体で N − 1 回行われるので，合計で O(N3 ) 時間が掛かり，TLE してしまい ます．ここで，頂点数 X の部分木の dp においては，x は X まで考慮すればよいことを利用します．する と，頂点数 X の部分木と頂点数 Y の部分木の dp をマージするのに掛かる時間は O(X · Y ) に抑えられます． これは定数倍改善でしかないように思えますが，実は計算量を本質的に改善し，全体で O(N2 ) 時間となりま す．これは十分に高速です．計算量解析は省きますが，「木 DP 二乗」などで検索すると解説が見つかります． F: Robots and Exits まず，最も左の出口より左に置かれているロボットたちと，最も右の出口より右に置かれているロボットた ちは無視してもよいです． ある時点におけるロボットの変位の履歴を考えます．この履歴の最小値を x とし，最大値を y とします． 最初，(x, y) = (0, 0) です．すぬけ君は，(x, y) から (x + 1, y) または (x, y + 1) のいずれかを自由に選び， 変化させることができます．これは，すぬけ君が二次元平面上の原点から，右または上へ距離 1 ずつ移動して いくことと等価です． この言い換えのもとで，各ロボットがいずれの出口を通るかを考えます．ロボット i について，すぐ左の出 口までの距離を ai とし，すぐ右の出口までの距離を bi とします．すると，x が ai に達するタイミングと 3 y が bi に達するタイミングを比較し，前者が早ければロボット i はすぐ左の出口を通り，後者が早ければロ ボット i はすぐ右の出口を通ります．すなわち，二次元平面上に点 (ai , bi) をプロットしたとき，すぬけ君が この点の下側を通るか，左側を通るかによって，ロボット i の通る出口が変わります． 4 ABC #107 / ARC #101 Editorial writer: sugim48 2018 年 8 月 25 日 A: Train The answer is N + 1 − i. • C++ Code Example: https://beta.atcoder.jp/contests/abc107/submissions/3070852 • Java Code Example: https://beta.atcoder.jp/contests/abc107/submissions/3070854 • Python 3 Code Example: https://beta.atcoder.jp/contests/abc107/submissions/3070856 B: Grid Compression Mark all rows/columns that contain at least one black cell, and print intersections of marked rows and marked columns. • C++ Code Example: https://beta.atcoder.jp/contests/abc107/submissions/3070967 • Java Code Example: https://beta.atcoder.jp/contests/abc107/submissions/3070968 • Python 3 Code Example: https://beta.atcoder.jp/contests/abc107/submissions/3070969 C: Candles Clearly, we should light K consecutive candles. Let l, r be the leftmost/rightmost indices of candles we light. Since there are only N − K + 1 pairs of (l, r), let’s try them all. For a fixed (l, r), we should compute the minimum time required to visit both xl and xr (then all other candles between them will be visited too). There are two cases: • Visit in the order l → r: |xl | + |xr − xl | • Visit in the order r → l: |xr| + |xr − xl | The answer is the minimum of these values. This solution works in O(N) time. 1 D: Median of Medians Let b be a sequence of length M. If the median of b is x, • b contains at least ⌈M 2 ⌉ elements that are greater than or equal to x. • x is the largest possible value that satisfies the condition above. Let’s fix a parameter x. We want to solve the following problem: Count the number of pairs (l, r) (1 ≤ l ≤ r ≤ N) such that ml,r ≥ x. If we can solve this, by doing a binary search on x (using the property of median mentioned above), we can solve the original problem. For simplicity, we call an element ”large” if the element is x or greater, and call it ”small” otherwise. Notice that ml,r ≥ x holds if and only if (the number of large elements in it) is greater than or equal to (the number of small elements in it). Thus, we replace each large element with 1 and each small element with −1. Now ml,r ≥ x holds if and only if al + . . . + ar ≥ 0. To count such pairs, we use prefix sums. We want to count the number of pairs (l, r) such that Sl−1 ≤ Sr, where Si := ∑i j=1 ai . Now the problem is reduced to a standard inversion-number problem. This solution works in O(N log N log max a) time in total. 2 E: Ribbons on Tree By inclusion-exclusion principle, we want to compute the following value: ∑ F ⊆E (−1)|F | f(F) Here, E is the edge set of the given tree, and f(F) is the number of ways to split vertices in pairs such that no edge in F is decorated with ribbons. For a fixed F, we can compute f(F) as follows. Suppose that the number of vertices of the |F| + 1 connected components we get by removing edges in F from the tree are n1, n2, . . . , n|F |+1. Then, f(F) = g(n1)· g(n2)· · · · · g(n|F |+1), where g(n) is defined as follows (this is the number of ways to split n things into pairs): g(n) := { (n − 1) · (n − 3) · · · · · 3 · 1 (n : even) 0 (n : odd) To compute the sum of f(F) quickly, let’s use DP. Suppose that the tree is rooted in some way. We decide pairings from leaves, and we keep ”current subtree”, ”the number of vertices in current component”, and ”the parity of removed edges”. Define dp(v, x, p) as follows: Consider the subtree rooted at v. We remove some edges from the subtree and get some connected components. Then, within each component, we split vertices into pairs. Here, the parity of the number of removed edges must be p, and the number of vertices in the component with v (the root of the subtree) must be x. How many ways are there to do this? Strictly speaking, we need a slight technical modification to this. We split vertices into pairs within each component, but as an exception, we don’t make pairs for the vertices in the component with v (in other words, we don’t multiply g(x)). (Otherwise you will have trouble updating this DP table). This solution works in O(N2 ) time. 3 F: Robots and Exits We’ll update it later! 4 ARC100 / ABC102 解説 writer : maroonrk 平成 30 年 7 月 1 日 For International Readers: English editorial starts from page 8. A : Multiple of 2 and N N が偶数のとき、答えは N です。また、N が奇数のとき、答えは 2N です。 C++による解答コード 1 B : Maximum Difference 数列の最大値を最小値を求め、その差を答えればよいです。最大値と最小値が一致する場合、添 字が異なる、という条件を無視してしまうように思えますが、最大値と最小値が一致するというこ とは、すべての要素が等しいので、問題ありません。 C++による解答コード 2 C : Linear Approximation Bi = Ai − i と定義すれば、問題は、自由に整数 b を選び、abs(Bi − b) の総和を最小化する問 題です。ここで、b を Bi の中央値にするのが最適であることがわかります。中央値でない場合は、 中央値に近づけることで損をしないことからこれはわかります。よって、Bi をソートして中央値 を求め、実際に答えを計算すればよいです。ソートがボトルネックとなり、この問題は O(NlogN) で解けます。 3 D : Equal Cut 予め累積和を求めておき、ある区間の和を O(1) で求められるようにしておきます。 切り込みを入れる 3 箇所のうち、真ん中の切れ込みを 1 つ固定したとします。真ん中の切れ込み で切ったあとの 2 つの数列を L,R とします。あとは、L と R をそれぞれ 1 回ずつ切ることを考え ます。 L の切り方を考えると、切ったあとの 2 つの数列の要素の総和ができるだけ近いほうが良いこと がわかります。よって、真ん中の切れ込みを固定すると、左の切れ込みの位置を決めることが出来 ます。真ん中の切れ込みの位置が、i 番目の要素と i + 1 番目の要素の間の時、最適な左の切れ込 みの位置を F(i) とおきます。このとき、F(i) は i に関して単調増加であり、尺取り方を用ること で F(i) をすべての i に対して O(N) で求めることが出来ます。 右の切れ込みについても、同様にして求めることが出来ます。これで、すべての真ん中の切れ込 みの位置に対して、残りの 2 つの切れ込みの位置を求めることが出来ました。あとは、実際にそれ ぞれの場合に対して答えを計算すれば、答えが求まります。 よって、O(N) でこの問題は解けました。 4 E : Or Plus Max 各 x について、max Ai + Aj s.t. (i or j) = x が求められれば、あとは単に累積 max を取れば良 いので、この問題は簡単です。しかし、これを求めるのは難しいです。そこで代わりに、各 x につい て、max Ai +Aj s.t. (i or j) ⊆ x を求めます。ただしここで便宜的に、a ⊆ b を、a を bit で表した ときの 1 の位置が、b を bit で表したときの 1 の位置の部分集合となっている、の意味で使います。 これを求めたあと累積 max を求めても、正しい答えは得られます。（(i or j) ⊆ x → (i or j) ≤ x なので） これを求めるためには、各 x について、i ⊆ x なる i について Ai を列挙したときの上位 2 つが 求まれば良いです。逆から見ると、各 i について、i ⊆ x なるすべての x について、Ai で上位 2 つを更新する、という操作ができれば良いです。これは、高速ゼータ変換の要領で、高速に行うこ とができます。よってこの問題は、O(N2 N ) で解くことが出来ます。 5 F : Colorful Sequences カラフルとは限らない、長さ N で、各要素が 1 以上 K 以下の整数列すべてについて、A を含 む個数の総和を求めるのは簡単です。A が登場する位置が N − M + 1 通り考えられ、それを一つ 固定すると、残りの N − M 要素を自由に決定できるので、その位置に A を含む整数列の総数は KN−M 個になります。 あとは、カラフルでない長さ N の整数列すべてについて A を含む個数を数える問題を解きます。 これが解ければ、引き算をして答えが求まります。 まず、そもそも A がカラフルであった場合、答えは 0 です。 ✓ 残りのパターンを考える前に、次の問題を解いておきます。 ✏ 長さ N のカラフルでない整数列の個数を求めよ。 ✒ ✑ DP をします。dp[i][j] = 長さ i で、最後の j 個の要素はすべて異なるが、最後の (j + 1) 個の要 素の中には重複があるような整数列の個数 と定めます。この DP の遷移を考えます。dp[i][j] から dp[i + 1][j ′ ] への遷移にかかる係数は、以下のようになります。 • j + 1 < j′ のとき: 0 • j + 1 = j ′ のとき: K − j • j + 1 > j′ のとき: 1 最初のパターンは簡単です。どんな要素を追加しても、最後の (j + 2) 個の中に必ず重複は存在 するので、このような遷移はありません。次のパターンは、元の数列の最後 j 個以外の要素を追加 することで起こる遷移です。追加する要素の候補は K − j 個なので、この遷移になります。最後の パターンは、j ′ の値を決めると、追加する要素が一意に定まるので、この遷移になります。 この DP を愚直に書くと、状態数 O(NK)、遷移 (K) で合計 O(NK2 ) となり間に合いませんが、 累積和を用いると遷移を高速化でき、O(NK) で解くことが出来ます。 この DP の結果を用いて、A がカラフルでない場合を解きます。 ✓ まず、A 内に重複する要素がない場合を考えます。ここで、次の問題を考えてみます。 ✏ 長さ N のカラフルでない整数列すべてについて、長さ M 個の連続する部分列であって、重 複する値を含まないものの個数を数える。 ✒ ✑ この問題では、A の要素には一切関知せず、M だけを考えている点に注意してください。この問 題は、カラフルでない数列を数える上記の DP を変形して（長さ M の重複を含まない連続部分列 がすでに登場したか、という 0, 1 の次元を足す）答えを求めることが出来ます。長さ M で、各要素 が 1 以上 K 以下の、重複する要素を含まない整数列は、N!/(N − M)! 通りありますが、この問題 において、これら全ては同じ回数だけ数え上げられます。よって、この問題の答えを N!/(N −M)! で割れば、A を含む個数の総和が求まることになります。 最後に、A 内に重複する要素がある場合を考えます。A 内に重複する要素があるので、次の条件 を満たす整数 F,B を定義することが出来ます。 • A の先頭 F 個の要素はすべて異なるが、A の先頭 F + 1 個の要素の中には重複がある • A の末尾 B 個の要素はすべて異なるが、A の末尾 B + 1 個の要素の中には重複がある 6 すべての i(0 ≤ i ≤ N − M) について、A の先頭に i 個の要素を足し、A の末尾に N − M − i 個の要素を足して、カラフルでない整数列を作る方法が何通りあるかを求めます。ここで、長さ i + F で、最後の F 要素がすべて異なるカラフルでない数列の個数、を求めることが出来ます。こ れは単に、上記の DP の結果を利用すれば良いです。長さ F で、各要素が 1 以上 K 以下の、重 複する要素を含まない整数列は、N!/(N − F)! 通りありますが、これらはすべて、先程数えた数 列の末尾 F 個として均等に登場します。よって、割り算をすることで、長さが i + F で、最後の F 要素が A の先頭 F 個と一致するカラフルでない数列の個数が求まります。同様にして、長さが B + N − M − i で、先頭の B 要素が A の末尾 B 個と一致するカラフルでない数列の個数が求ま ります。この 2 つの通り数を掛け合わせれば、ある i に対する答えを求められます。ここで数えた 先頭、末尾に足される数列の組合せが必要十分であることは、簡単に確かめられます。 これで、すべてのパターンを数え上げることが出来ました。最初の DP がボトルネックとなり、 O(NK) でこの問題は解くことが出来ます。 7 Atcoder Regular Contest Editorial writer : maroonrk July 1, 2018 A : Multiple of 2 and N If N is even, the answer is N; otherwise the answer is 2N. C++ solution B : Maximum Difference Print max minus min. C++ solution C : Linear Approximation Define Bi = Ai−i. Then, we want to minimize the value of the sum of abs(Bi−b) by choosing a variable b. It turns out that the optimal value of b is the median of Bi . This is because, if b is not the median, if we continuously change b to the direction of the median, the sum of abs(Bi − b) never increases. We can get the median by sorting the array B. This solution works in O(NlogN) time. 1 D : Equal Cut Let’s pre-compute prefix sums (and now we can get interval sums in O(1). We need to make three cuts. Let’s fix the position of the second (the middle) cut. Now we have two parts, and we need to make one more cut for each of the two parts. Let L, R be the sum of all elements in left and right parts, respectively. Let L1, L2 be the sum of all elements in the two smaller parts we get from the left part (define R1, R2 similarly). How should we choose L1, L2? Notice that we should always make a cut that minimizes the value of |L1 − L2|, regardless of the value of R1 and R2. No matter what the values of R1 and R2, this choice always minimizes max{L1, L2, R1, R2} and maximizes mub{L1, L2, R1, R2}. (This is because the average of L1 and L2 is always L/2. The value of max{L1, L2} becomes the closest to L/2 (and the smallest) when |L1 − L2| is minimized. The same observation holds for the min.) Thus, once we decide the position of the second cut, we can uniquely determine the positions of the first cut and the third cut. Let F(i) be the optimal position of the first cut when the second cut is made at position i. Since F(i) is monotonously increasing, we can compute this function by using two-pointers. Similarly, we can compute the position of the third cut. This solution works in O(N) time. E : Or Plus Max In this editorial, for two integers a and b, ”a ⊆ b” means that the set of positions of ones in the binary representation of a is a subset of that of b. Ideally, for each x, we want to compute max Ai +Aj s.t. (i or j) = x. Then, we can compute the solutions as prefix maximums of this array. However, this is difficult. Instead, for each x, compute max Ai + Aj s.t. (i or j) ⊆ x. Notice that the prefix maximums of this array give the same results because (i or j) ⊆ x → (i or j) ≤ x. To compute this, for each x, we want to get the two largest values of Ai such that i ⊆ x. Let’s use an algorithm similar to Fast Zeta Transform. Imagine a set Sx, the (multi)set of all Ai such that i ⊆ x. We are only interested in the largest two elements of Sx. • For each k from 0 to N − 1, – For each x from 0 to 2N−1 such that the k-th bit of x is zero, ∗ Sx|(1<<k) := Sx|(1<<k) ∪ Sx ∗ If Sx|(1<<k) contains more than two elements, discard small elements while it has more than two elements. This solution works in O(N2 N ) time. 2 F : Colorful Sequences It’s easy to compute the total number of occurrences of A in (not necessarily colorful) all sequences of length N: since there are N − M + 1 possibilities for the position of A and you can freely choose the remaining N −M elements, this is (N − M + 1)KN−M. From now on, let’s compute the total number of occurrences of A in noncolorful sequences of length N. The answer to the original problem is (N −M + 1)KN−M minus this number. ✓ As a warm-up, consider the following problem: ✏ Count the number of non-coloful sequences of length N. ✒ ✑ Define dp[i][j] as the number of non-colorful sequences of length i, such that the last j elements are pairwise distinct but the last j + 1 elements are not. The transition coefficients from dp[i][j] to dp[i + 1][j ′ ] is as follows: • In case j + 1 < j′ , 0. • In case j + 1 = j ′ , K − j. • In case j + 1 > j′ , 1. This is O(NK2 ) with straightforward implementation, but with prefix sums we can do it in O(NK). Let’s return to the problem. Consider three cases: Case 1. A is colorful. Obviously, the answer is 0. Case 2. All elements in A are pairwise distinct. A is not colorful. ✓ Consider the following problem: ✏ For each non-colorful sequence of length N, count the number of contiguous subsequences of length M whose elements are pairwise distinct. Find the sum of these counts. ✒ ✑ Note that the elements in A are irrelevant to this problem: we only care the value of M. This problem can be solved in the almost same way as the DP solution in warm-up problem. Notice that each of K!/(K − M)! sequences of length M occur in all non-colorful sequences the same number of times. Thus, the solution to the original problem is the solution to this problem, divided by K!/(K − M)!. 3 Case 3. There are duplicated elements in A. A is not colorful. Define F, B as follows: • The first F elements of A are pairwise distinct, but the first F +1 elements are not. • The last B elements of A are pairwise distinct, but the last B + 1 elements are not. For each i(0 ≤ i ≤ N −M), let’s compute the number of ways to make a noncolorful sequence by attaching i elements to the beginning of A and N −M −i to the end of A (the answer is the sum of these values). Notice that we can handle two directions independently. That is, this is the product of (the number of ways to make a non-colorful sequence (of length M +i) by attaching i elements to the beginning of A) and (the number of ways to make a non-colorful sequence by attaching N − M − i elements to the end of A). These values can be computed in the same way as the warm-up problem. For all three cases, this solution works in O(NK) time. 4 AtCoder Beginner Contest 101 / AtCoder Regular Contest 099 解説 writer: semiexp 2018 年 6 月 23 日 For International Readers: English editorial starts on page 5. A: Eating Symbols Easy 高橋君が思い浮かべている整数を，S の各文字ごとに更新していけばよいです．あるいは，S の中に現れる + の個数 から，- の個数を引くことでも求められます． • C++ による解答例: https://abc101.contest.atcoder.jp/submissions/2711190 • Ruby による解答例: https://abc101.contest.atcoder.jp/submissions/2711191 • Python による解答例: https://abc101.contest.atcoder.jp/submissions/2711198 B: Digit Sums Easy S(n) を計算できればよいです．これは，「現在の n の 1 の位を求め合計値に足し込み，1 の位を取り去る」ことを繰 り返せばよいです．1 の位は 10 で割った余りとして求められます．また，1 の位を取り去った値は 10 で割った商とし て求められます． • C++ による解答例: https://abc101.contest.atcoder.jp/submissions/2711205 • Ruby による解答例: https://abc101.contest.atcoder.jp/submissions/2711210 • Python による解答例: https://abc101.contest.atcoder.jp/submissions/2711212 C: Minimization 数列の最小値は 1 です．どのように操作を行っても，最小値が 1 以外に変化することはありません．なので，数列の 要素をすべて 1 にすることを考えます． 数列中の 1 の個数は，はじめ 1 です．この個数は，1 回の操作で K − 1 までしか増やすことができません．なぜな らば，1 の個数を増やすためには，操作で選ぶ要素の中に 1 が含まれている必要があるためです．よって，少なくとも ⌈ N−1 K−1 ⌉ 回の操作が必要であることがわかります． 一方，うまく操作を行うことで，⌈ N−1 K−1 ⌉ 回の操作ですべての要素を 1 にすることが可能です．はじめ Ap = 1 である とします．ここで，1 + g(K − 1) ≤ p ≤ 1 + (g + 1)(K − 1) なる整数 g をとります．このとき，次のように操作を行え ばよいです： • i = g, g −1, g −2, . . . , 1 に対して，この順で要素 i(K −1) + 1, i(K −1) + 2, . . . , i(K −1) + K を選んで操作を行う． 1 • i = g + 1, g + 2, . . . , ⌈ N−1 K−1 − 1⌉ に対して，この順で要素 i(K − 1) + 1, i(K − 1) + 2, . . . , i(K − 1) + K を選んで操 作を行う． • 要素 N − K + 1, N − K + 2, . . . , N を選んで操作を行う． D: Snuke Numbers 「N 以上の整数 n であって， n S(n) を最小にするもの (複数ある場合は，そのうち n が最小になるもの)」を f(N) で 表します．すると，N = 1 から始めて，N ← f(N + 1) という更新を順次繰り返すことで，すぬけ数を小さいほうから 順に列挙することができます．以降，この f(N) について考えます． まず， x S(x) の x ≥ N での最小値が常に存在することを示しておきます．10d−1 ≤ n < 10d のとき，n の最小値は 10d−1，S(n) の最大値は 9d であることから， x S(x) ≥ 10d−1 9d です．この下界は d ≥ 1 では d を 1 増加させると少なくと も 5 倍になるので，十分 d を大きくすると N S(N) より大きくなります．よって，このような d に対して 10d 未満の整数 x のみを考えればよいことから，最小値は存在します． x ≥ N で x S(x) を最小にする x (複数ある場合は，そのうち最小のもの) をとります．x > N と仮定して，x と N を 上位の桁から比較していったとき，初めて異なる値になる桁を 10d の位とします．このとき，x = 10d+1⌊ N 10d+1 + 1⌋ − 1 であること（つまり，x の 100 , . . . , 10d の位の数字がすべて 9 であること）を示します． まず，x の 100 , 101 , . . . , 10d−1 の位の数字はすべて 9 です．さもなくば，x ′ = 10d+1⌊ N 10d+1 ⌋−1 を考えると，N ≤ x ′ < x かつ S(x ′ ) ≥ S(x) であることから，x が x S(x) を最小にすることに反します． よって，x0 = 10d ⌊ N 10d + 1⌋ − 1 とおくと，ある 1 ≤ w ≤ 9 が存在して，x = x0 + w · 10d かつ S(x) = S(x0) + w とな ります．x の最適性より， x0 S(x0) > x S(x) = x0+w·10d S(x0)+w が成立します．よって，x0 > S(x0 · 10d が成り立ちます．一方，同 様にして，w を大きくすればするほど x S(x) が小さくなることもわかります．実際には x の 10d の位が 9 を超えること はできないので，その範囲で w を大きくするのが最適です．よって，x の 10d の位も 9 であることが示されました． よって，x の候補として考えられるものが N 並びに d = 0, 1, 2, ..., に対して x = 10d+1⌊ N 10d+1 + 1⌋ − 1 の形で書ける ものに限られることがわかりました．ここで，d としては log10 N + 1 以下で考えれば十分です．よって，候補を十分少 なく絞ることができたので，これらすべてに対して x S(x) を計算して比較すれば答えが得られます． E: Independence 問題を言い換えると，次のようになります： グラフから，できるだけ多くの辺を取り除いて，グラフ全体がちょうど 2 つのクリークの合併になるように する． これを，グラフを補グラフ（グラフの辺の有無を反転して得られるグラフ）にして考えると，次のように言い換える ことができます： グラフに，できるだけ多くの辺を加えて，グラフ全体が完全二部グラフになるようにする． 以降，補グラフについて考えることにします． 元のグラフが二部グラフでなければ，如何に辺を加えてもグラフ全体を完全二部グラフにすることは不可能です．一 方，元のグラフが二部グラフの場合は，頂点集合を 2 つの disjoint な集合 S, T に分割して，S, T にまたがる辺のみが 存在するようにできるので，S, T にまたがる辺すべてを追加することで，グラフ全体を完全二部グラフにすることがで きます． グラフを連結成分分解すると，各成分においては頂点集合の（いずれの辺も異なる集合間にまたがるような）二分割 は，集合の入れ替えを除いて一意に定まります．i 番目の連結成分の頂点集合をこのように二分割したものを Si , Ti とし 2 ます．すると，S は各 i に対して Si , Ti のちょうど片方を選んで，それらの和集合をとることで構成することができま す．（T は頂点全体から S に含まれる頂点を除くことで得られます） さて，この問題中で問われている「両端の都市が同じ州内に属しているような道の本数」は，S の大きさのみによっ て定まることがわかります．よって，S の大きさとしてありうるものをすべて列挙すればこの問題を解くことができま す．これは，「1, 2, ..., i 番目の連結成分に対して Si , Ti のうち選ぶほうを決めて，和集合をとることでできる集合の大き さ」を動的計画法で順次求めることで計算することができます． F: Eating Symbols Hard L = 109 とおきます．A, P を定めたとき，X の多項式 fA,P を次で定めます： fA,P = ∑ L i=−L AiXi−P 明らかに，A と A′ の各要素が一致することと，fA,0 ≡ fA′ ,0 は同値です． 文字列 S に対して，高橋君が S を 1 文字目から順に食べた後に高橋君が思い浮かべている数列 A を T(S) で表し， t(S) = fT(S),0 とします．このとき，t(S) に対して，次の関係が成り立つことがわかります： • t(ϵ) = 0 (ϵ は空文字列) • t(+S) = t(S) + 1 (+S は，文字 + と文字列 S をこの順でつなげたもの．以下同様) • t(-S) = t(S) − 1 • t(>S) = t(S)X−1 • t(<S) = t(S)X よって，X の多項式から X の多項式への関数 τ+, τ-, τ>, τ< を次で定めると，t(S) = τS1 ◦ τS2 ◦ · · · ◦ τS|S| (0) となる ことがわかります（◦ は関数合成）： • τ+(p) = p + 1 • τ-(p) = p − 1 • τ>(p) = pX−1 • τ<(p) = pX よって，求める値は，組 (i, j) (1 ≤ i ≤ j ≤ |S|) であって，τSi ◦ · · · ◦ τSj (0) = t(S) なるものの個数です．i を固定し たときに，これを満たす j が何個あるかを効率的に数えることを考えます． ここで，τc を合成して得られる関数は，p 7→ Ap + B (A, B は X の多項式，A ̸≡ 0) の形をしています．A[i,j) , B[i,j) を，それぞれ τSi ◦ · · · ◦ τSj−1 を p 7→ Ap + B の形で書いたときの A, B とします．A[i,j) , B[i,j) , A[j,k) , B[j,k) がわかって いるとき，A[i,k) , B[i,k) は次のようにして求められます： A[i,k) = A[i,j) · A[j,k) , B[i,k) = A[i,j) · B[j,k) + B[i,j) このことから， B[i,j) = B[i,k) − A[i, j) · B[i,k) = A[i,k) ( B[i,k) A[i,k) − A[i,j) · B[j,k) A[i,k) ) = A[i,k) ( B[i,k) A[i,k) − B[j,k) A[j,k) ) 3 がわかります．よって，τSi ◦ · · · ◦ τSj−1 (0) = t(S) のとき， B[j,|S|+1) A[j,|S|+1) = B[i,|S|+1) − t(S) A[i,|S|+1) が成り立ちます．よって，各 j に対して B[j,|S|+1) A[j,|S|+1) を計算しておけば，i を固定したとき，j > i であって B[j,|S|+1) A[j,|S|+1) = B[i,|S|+1)−t(S) A[i,|S|+1) なる j の個数を求めることで，問題の答えが得られます． ところで，B[j,|S|+1) A[j,|S|+1) は，一般には (N 次多項式) / (N 次多項式) の有理式になるため，これをすべての j に対して求 めて記録することは難しいです．一方，この有理式を直接記録する代わりに，十分多くの X および mod M で有理式の 値を計算しておくことは可能です． 十分多くの X, M に対して有理式の値が一致すれば，十分高い確率で正しい答えが得られることを示します．この問 題で考える有理式は，高々 (N 次多項式) / (N 次多項式) であるため，P/Q = P ′/Q′ すなわち P Q′ = QP′ かの判定は， 高々 2N 次の多項式同士の比較に相当します．P Q′ ̸= QP′ であるにもかかわらず (P Q′ )(X) = (QP′ )(X) (mod M) と なるような X は，高々 2N 個しか存在しません．よって，X を一様ランダムに選んでくると，高々確率 2N M でこの 2 つは一致していると誤って判定されます． 比較すべき有理式の組は (N+1)N 2 組です．よって，ランダムに X を k 個とって比較する場合，いずれかの組で誤っ た判定が起きる確率は，高々 (N+1)N 2 · ( 2N M )k です．M ∼ 109 程度の素数をとれば，例えば k = 6 でこの確率は 10−12 未満となり，十分高確率で正解することができます． このアルゴリズムの計算量は，i ごとに一致する j の発見を map などを用いて行うと，O(kN log N) となります． 4 AtCoder Beginner Contest 101 / AtCoder Regular Contest 099 Editorial writer: semiexp June 23rd, 2018 A: Eating Symbols Easy • C++ example: https://abc101.contest.atcoder.jp/submissions/2711190 • Ruby example: https://abc101.contest.atcoder.jp/submissions/2711191 • Python example: https://abc101.contest.atcoder.jp/submissions/2711198 B: Digit Sums Easy • C++ example: https://abc101.contest.atcoder.jp/submissions/2711205 • Ruby example: https://abc101.contest.atcoder.jp/submissions/2711210 • Python example: https://abc101.contest.atcoder.jp/submissions/2711212 C: Minimization The minimum of the entire sequence is 1. Since this value never changes, we want to make all elements equal to 1. Initially, the sequence contains only one 1. In each step, the number of 1s increases by at most K − 1 (because the minimum of the chosen interval doesnt’t change). Thus, we need at least ⌈ N−1 K−1 ⌉ steps. On the other hand, we can always achieve the goal within this number of steps, as follows. Let Ic be the interval c(K − 1) + 1, c(K − 1) + 2, . . . , c(K − 1) + K. Note that for each c, Ic and Ic+1 shares an element, and I1, . . . , I⌈ N−1 K−1 −1⌉ covers the entire sequence. (Strictly speaking, to avoid the intervals going outside the sequence, we shuold shift the last interval to fit within the sequence.) Suppose that initially, Ig contains the only 1. Then, perform the following: • For each i = g, g − 1, g − 2, . . . , 1 in this order, perform an operation on the interval Ii . • For each i = g + 1, g + 2, . . . , ⌈ N−1 K−1 − 1⌉ in this order, perform an operation on the interval Ii . 1 D: Snuke Numbers Let f(N) be the integer n ≥ N that minimizes the value of n S(n) (in case of tie, choose the smallest one). We start with N = 1, and by repeating N ← f(N + 1), we can list all Snuke numbers in the increasing order. Now we want to compute f(N) for a given N. We’ll prove that f(N) can be always obtained by changing the last (least important) k digits of N to 9 for some k. Let x = f(N). For simplicity, let xi denote the i-th digit of x (i.e., the digit with coefficient 10i ). Assume that x > N and the d-th digit is the first (most significant) digit where x and N differ. (Note that N and x always have the same number of digits - it’s easy to check that 999...999 is always a Snuke Number.) We want to prove that x0 = · · · = xd = 9. Suppose that for some i < d, xi < 9. Let y be the integer obtained by changing xi to 9 and xd to xd − 1. Clearly, N ≤ y < x and S(y) ≥ S(x) holds. This contradicts the minimality of x S(x) . Thus, x0 = · · · = xd−1 = 9. Now, we know that x0 = · · · = xd−1 = 9, xd is unknown, and xd+1, . . . are the same as corresponding digits of N. Let z be the value of x in case xd = 0, and let w = xd. Then, we get x = z + w · 10d , S(x) = S(z) + w, and x S(x) = z+w·10d S(z)+w . Since this is a monotonous function of w, the optimal value of w is either the smallest valid value (the d-th digit of N) or the largest valid value (9). We know that d-th digit is the digit where x and N differ, thus, xd = 9. (This observation is not necessary - even without this observation, the number of candidates is limited enough.) Now we have limited candidates for x. For each candidate compute the value of x S(x) , and f(N) is the one that minimizes this value. E: Independence By taking the complement of the graph, we can restate the condition of the problem as follows: Color the vertices of the graph with two colors. Between two vertices of the same color, there must not be an edge (of the complement graph). From now on, simply the ”graph” means ”complement graph”. The condition above is equivalent to the standard rule of coloring: for each edge, the color of its two endpoints must be different. Clearly, if the given graph is not bipartite, the answer is −1. Otherwise, for each connected component, we can uniquely determine a valid coloring (except for swapping two colors). Let Si , Ti be the set of vertices of each color in the i-th component. Then, the set of vertices in State Taka must be formed in the following way: for each i, choose one of Si or Ti , and take their union. ”The number of roads whose endpoint cities belong to the same state” only depends on the size of S. Since we can list all possible sizes of S by a simple DP, we can solve the problem. 2 F: Eating Symbols Hard Let’s use rolling hashes. Fix a large prime M, and also fix a random integer X. For a string (of symbols) S, we define t(S) as follows. Let A be the sequence we get when we eat S. Then, t(S) = (∑ i AiXi ) (mod M) We can use the following properties to compute t(S) (note that all equations will be evaluated modulo M): • t(ϵ) = 0 (ϵ is an empty string) • t(+S) = t(S) + 1 (+S is a concatenation of a character + and a string S in this order) • t(-S) = t(S) − 1 • t(>S) = t(S)X−1 • t(<S) = t(S)X Thus, t(S) = τS1 ◦ τS2 ◦ · · · ◦ τS|S| (0) （◦ are compositions of functions）, where functions τ+, τ-, τ>, τ< are defined as follows: • τ+(p) = p + 1 • τ-(p) = p − 1 • τ>(p) = pX−1 • τ<(p) = pX Let c be the hash value we get when we execute the entire sequence. We want to count the number of pairs (i, j) such that τSi ◦ · · · ◦ τSj (0) = c. Notice that the functions τ+, τ-, τ>, τ< are bijective, and we can define their inverses. We have the following: τSi ◦ · · · ◦ τSj (0) = c ⇔ τ −1 SN ◦ · · · ◦ τ −1 Si ◦ τSi ◦ · · · ◦ τSj (0) = τ −1 SN ◦ · · · ◦ τ −1 Si (c) ⇔ τ −1 SN ◦ · · · ◦ τ −1 Sj+1 (0) = τ −1 SN ◦ · · · ◦ τ −1 Si (c) For an integer i, define ai , bi as follows: • ai = τ −1 SN ◦ · · · ◦ τ −1 Si (0) • bi = τ −1 SN ◦ · · · ◦ τ −1 Si (c) Notice that the inverses of τ+, τ-, τ>, τ< are linear functions, and their compositions are also linear functions. Thus, by keeping τ −1 SN ◦ · · · ◦ τSi as a linear function, we can compute ai , bi for all i in linear time. Now our task is to count the number of pairs (i, j) such that aj+1 = bi . It can be easily done with maps, and works in O(N log N) time. Let’s estimate the collision probability of hashes. If we regard t(S) as a function of X, S = S ′ if and only if t(S) = t(S ′ ). Otherwise, t(S) and t(S ′ ) are different as functions, and since they are polynomials of degree 2N (after some scaling), the number of X that makes t(S) = t(S ′ ) is at most 2N. By choosing X uniformly at random from the field FM, the probability of collision is 2N M . By using k different values for X, since we compare (N+1)N 2 pairs of polynomials, the total failure probability is at most (N+1)N 2 · ( 2N M )k . This is less than 10−12 for M ∼ 109 and k = 6. 3 Atcoder Regular Contest 解説 writer : maroonrk 平成 30 年 5 月 26 日 For International Readers: English editorial starts from page 7. A : Add Sub Mul 整数の足し算、引き算、掛け算はほとんどのプログラミング言語で標準サポートされているで しょう。あとは、3 つの整数の最大値が求められれば良いです。これは if 文による条件分岐で実装 出来ますが、プログラミング言語によっては、与えられたいくつかの整数の最大値を求める関数が 用意されている場合もあります。 C++による解答コード 1 B : Cut and Count 文字列を分割する位置を全探索します。英小文字 26 種類すべてについて、分割されたあとの 2 つの文字列の両方に含まれるかの判定を行えば、「X と Y の両方に含まれる文字の種類数」が求ま ります。あとはその中で最大値を求めれば良いです。 26 種類の文字全てに対して、if(s[i] == ‘a‘), if(s[i] == ‘b‘) · · · と言ったふうに判定関数を書 くのは骨の折れる作業ですが、ASCII コードで、‘a‘ ‘b‘ · · · ‘z‘ が並んでいるという性質を利用する とコードが簡単になります。 C++による解答コード 2 C : Attention 西から i 番目の人がリーダーになった際、向く方向を変える必要のある人は、西から j(j < i) 番 目に並んでいて西を向いている人と、西から j(j > i) 番目に並んでいて東を向いている人です。 ここで、「ある範囲に存在する西 (東) を向いている人の人数」は、累積和を使うと、前処理 O(N) 時間、1 クエリあたり O(N) 時間で求められます。 よって、まず最初に O(N) 時間で累積和を求めておくと、各人について、その人がリーダーに なった際に向く方向を変える必要のある人の人数を求めることが O(1) 時間ででき、合計 O(N) 時 間で全員分求まります。あとはその中で最小値を求めればよいです。 3 D : Xor Sum 2 整数列 c1, c2, · · · , cm が、c1 xor c2 · · · xor cm = c1 + c2 + · · · + cm を満たす条件を考える と、これは、すべての k(0 ≤ k) に対して、2 進法表記したときの 2 k の位が 1 であるよう ci の個数 が 1 以下であることと同値です。これは、a + b − (a xor b) = 2 × (a and b)（ただしここで and はビットごとの論理積を表す）であることからわかります。 l を固定したときに、(l, r) が条件を満たすような最大の r を f(l) とおきます。すると、f は l に 対して広義単調増加です。よって、l を増加させながら尺取り法の要領で f(l) を求めることができ、 O(N) で答えを求めることが出来ます。 この他にも、各 bit についてそのビットが立っている位置を保存することで、直接的に f(l) を求 める解法も存在します。 4 E : Range Minimum Queries 取り除いく要素の最小値 X を決めたとします。この条件のもので、乗り除く要素の最大値 Y を 最小化することを考えます。 最小値が X という条件を守るためには、X より小さい要素を含むような区間に対して操作をす ることは出来ません。そこで、与えられた数列を、X より小さい要素の位置で切ると、いくつか の列に分割されます。分割されたあとの列の中で完結する操作は自由に行なえます。 分割したあとの列の一つを c1, c2, · · · , cm とします。この列からは、高々m − K + 1 個の要素 を取り除くことが出来ます。小さい方から取り除くほうが好ましいので、この列から取り除かれる 可能性があるのは、c1, c2, · · · , cm の中で小さい方から m − K + 1 個の要素です。 分割したあとの各列について、取り除かれる可能性のある値を列挙すると、それらすべての中で Q 番目に小さいものが、Y の最小値になります。 列の要素の小さい方から何要素かを得るのは、列をソートすれば出来ます。よって、X を決めて おくと、Y の最小値は O(NlogN) で求まることになります。 X は N 通りあるので、合計 O(N2 logN) でこの問題は解けます。 余談ですが、実はこの問題は N ≤ 105 で解くことが出来ます。 5 F : Donation 各頂点 v について、Cv = max(Av − Bv, 0) と定義します。ここで、問題で行う操作を逆から見 ると、次のようなゲームをしていると思うことが出来ます。 ✓ ✏ 適当な頂点 s から、スタートする。このときの所持金は好きな値でよい。これから、以下の 2 つの操作を好きな順序で好きなだけ繰り返す。 • 今いる頂点を v としたとき、Bv 円を得る。ただし、今いる頂点をでお金をもらえるの は 1 度だけである。 • 今いる頂点を v としたとき、所持金が Av 円以上なら、隣接する頂点から好きなものを 選んでそこに移動する。 すべての頂点でお金をもらい、かつ、最後に立っている頂点を t としたときに、所持金が At 円以上ならゲームクリアとなる。 ✒ ✑ このゲームの性質を考えると、今まで訪れたことのない頂点に移動してきた際には、すぐにお 金を得るのが最善です。また、一度訪れた頂点は、その後自由に移動できます。以上の考察より、 ゲームを更に次のように簡略化出来ます。 ✓ ✏ 適当な頂点 s から、スタートする。このときの所持金は Cs 円以上でなくてはならない。これ から、以下の操作を、すべての頂点を訪れるまで繰り返す。 • 今まで訪れた頂点に隣接する、まだ訪れていない頂点を一つ選び、移動する。移動先の 頂点を v とすると、このときの所持金は Cv 円以上でなくてはならない。そして、移動 したあと Bv 円を得る。 すべての頂点を訪れることができればゲームクリアとなる。 ✒ ✑ このゲームでは、次に移動可能な頂点の中で Cv が最小のものを選び、移動するという戦略が最 適だとわかります。 Cv が最大の頂点をz とします。ここで、z をグラフから取り除いたあとの連結成分をP1, P2, · · · PL とおきます。（ここで L は 0 かもしれません）最適解においてスタートする頂点が z だとします。そ の場合、ゲームクリアのための所持金の最小値は、Cz に、Bv の総和を足したものになります。最適 解においてスタートする頂点が Pi 内にあったとします。その場合、ゲームクリアのための所持金の 最小値は、Pi だけでゲームをクリアするための所持金の最小値を Qi とすると、max(Qi , Cz) + Pi 以外の頂点の Bvの総和 となります。 これで多項式解法が得られましたが、愚直にグラフを分割していては間に合いません。グラフが 分割される様子を逆から見ると、Cv の小さい頂点だけでできるだけ大きな連結成分を作っている と思うことが出来ます。よって、各辺のコストを、端点の Cv の max だと思って、小さいコストの 辺から優先的に使っていくと考えれば、Union-Find を使って、グラフが分割される様子を表す根 付き木を作ることが出来ます。この木の各頂点は、Cv がある一定の値以下の頂点のみからなるあ る連結成分に対応することになります。この木の各頂点に対して、対応するグラフ内だけの問題を 解いたときの答え、及び Bv の総和を求めると、木 DP によって全体の答えが求まります。 Cv の昇順に頂点を並べたり、Union-Find の操作をするのがボトルネックになり、この問題は O(NlogN) で解けます。 6 Atcoder Regular Contest Editorial writer : maroonrk 平成 30 年 5 月 26 日 A : Add Sub Mul C++ Example B : Cut and Count C++ Example C : Attention If the i-th (from the west) person is chosen as the leader, the j-th person have to change the direction in the following two cases: • j < i and the j-th person is facing west. • j > i and the j-th person is facing east. First, let’s pre-compute prefix sums: for each i, count the number of people among the westmost i people who are facing east. This can be done in O(N) time. After that, we can answer a query of the form ”How many people in a given range are facing east (west)?” in O(1) time, thus the two values above can be computed in O(1) after we fix the leader. This solution works in O(N) time in total. 1 D : Xor Sum 2 Notice that a + b − (a xor b) = 2 × (a and b). The inequality a + b ≥ a xor b always hold, and the equality holds if and only if a and b = 0. (Intuitively, the equality holds if we get no ”carries” when we add a and b as binary numbers.) Therefore, for a sequence of non-negative integers c1, c2, · · · , cm, the equation c1 xor c2 · · · xor cm = c1 + c2 + · · · + cm holds if and only if for all k, the number of elements among c1, . . . , cm that contains the k-th bit (in binary representation) is at most one. For a fixed l, the interval [l, r] satisfies the condition in the statement if no bit is repeated among al , . . . , ar. Thus, there exists an integer f(l), and the condition is satisfied if and only if r ≤ f(l). Since f(l) is monotonously non-decreasing, we can compute the value of f(l) for all l in O(N) time using two-pointers. It is also possible to directly compute f(l): for each k, list the indices of all elements that contains the k-th bit. E : Range Minimum Queries Let’s fix the value X: the lower bound of removed integers. Under the condition that we are never allowed to remove integers less than X, let’s minimize the value of Y (the upper bound of removed integers). Note that we slightly modified the definition of X: now it is not necessary to remove X. In order to satisfy the condition, we can never choose an interval that contains an integer less than X. Thus, let’s split the entire sequence by integers less than X. Now we get (possibly multiple) sequences that don’t contain integers less than X, and we can freely perform operations within each of these sequences. Let c1, c2, · · · , cm be one of the sequences we get after the split. We can remove at most m − K + 1 elements from this sequence (because before the last operation there must be at least K elements). It is clearly optimal to remove integers from the smallest ones. Thus, the m−K +1 smallest elements in this sequence have possibility to be removed. We do the same thing for each part of splitted sequences, and list all elements that may be removed. If there are Q or more such elements, the minimum possible value for Y is the Q-th smallest element among them. We can do this in O(N log N) for a fixed X. If we try all N possibilities for X, this solution works in O(N2 log N) time in total. Note that this problem is solvable even for N ≤ 105 . This part is left as an exercise for readers. 2 F : Donation Let’s modify the problem a bit. Instead of the condition about Av, we require the following constraint: for each vertex v, whenever you are at vertex v, your money must be at least Cv := max(Av − Bv, 0) (even after you donate money to the vertex). It turns out that this problem is equivalent to the original problem. It’s clear that a valid sequence of moves in the original problem is also a valid sequence of moves in the modified problem. On the other hand, since it never makes sense to visit a vertex again after you donate for this vertex (in this case, we can ”postpone” the donation), a valid sequence of moves in the modified problem can be converted to a valid sequence of moves in the original problem. Let v be the vertex that maximizes the value of Cv. From the observation above, we can assume that, after we donate for this vertex we never visit this vertex. Let G1, . . . , Gk be connected components we get when we remove the vertex v from the graph. Suppose that we end the game inside Gi . Then, after we donate for v, we must move inside Gi . We claim that (one of) optimal solutions is of the following form: • We donate for all vertices in G1, . . . , Gi−1, Gi+1, . . . , Gk. • Move to the vertex v, and donate for it. • We donate for all vertices in Gi . We never go out of this subgraph during this phase. Suppose that there is an optimal solution that is not of this form. Then, there exists a vertex w in Gi such that we donate for w before v. In this case, we can cancel the donation for w, and instead we add a donation for w right after the donation for v, and improve the solution. Therefore, we proved the claim above. Let’s construct a rooted tree as follows: • v (the vertex that maximizes Cv) is the root of the tree. • Recursively construct rooted trees for subgraphs G1, . . . , Gk. • Add an edge between v and the root of the tree for Gi for each i. We can construct this tree in O(N log N) time in the order from leaves to root by handling vertices in the increasing order of C. Now, we can do a DP on this tree. For each vertex u, define dp[u] as the minimum amount of money required to donate for all vertices in the subtree rooted at u. Then we can fill the DP table in the order from leaves to the root. This solution works in O(N log N) time. 3 ABC097 / ARC097 ղઆ sigma425 For International Readers: English editorial starts on page ???. A: Colorful Transceivers ໰୊จͷ௨Γ࣮͢·͠૷ɻೋ఺ a,b ؒͷڑ͸཭ඪ४తͳޠݴͳΒઈର஋ؔ਺ͰࢉܭͰ͖ΔͰ͠ΐ͏ɻࣗ෼ Ͱఆٛͯ͠΋ྑ͍ͱࢥ͢·͍ɻͨͱ͑͹ C++ ͳΒ abs(a − b) ͱॻ͚·͢ɻ͋ͱ͸ɺ(A ͱ C ͕௚઀ձ࿩Մ ೳ) ·ͨ͸ ((A ͱ B ͕௚઀ձ࿩Մೳ) ͔ͭ (B ͱ C ͕௚઀ձ࿩Մೳ)) ͱ͍͏࿦ཧߏ଄Λɺ࿦ཧԋࢠࢉΛ࢖r ͯίʔυʹམͱ͠ࠐΊ͹Α͍Ͱ͢ɻҎԼ͸ C++ ͷίʔυྫͰ͢ɻ #include <bits/stdc++.h> using namespace std; int main(){ int a,b,c,d; cin >>a>>b>>c>>d; if(abs(a-c)<=d || (abs(a-b)<=d && abs(b-c)<=d)) puts("Yes"); else puts("No"); } B: Exponential ֤ 1 Ҏ্ X ҎԼͷ੔਺ x ʹରͯ͠ɺexpox := x ͕΂͖৐਺͔ ͱ͍͏ਅِ஋Λߟ͢·͑ɻ͜Ε͕ਖ਼͘͠ܭ ࢉͰ͖Ε͹౴͑͸ٻ·Γ·͢ɻ 1 Ҏ্ͷ੔਺ b ͱɺ 2 Ҏ্ͷ੔਺ p શͯͷϖΞʹରͯ͠ x := bp Λࢉܭ͠ɺx ͕ 1 Ҏ্ X ҎԼͳΒ expox Λ true ʹॻ͖׵͑Δ ͱ͍͏͜ͱΛ͢ΔͱఆٛΑΓਖ਼͘͠ٻ·Γ·͕͢ɺ౰વ͢΂ͯͷ੔਺ͷϖΞΛࢼ͢ͷ͸ ෆՄೳͰ͢ɻ ·ͣɺ b ͱͯ͠ࢼ ͸஋͖΂͢1 Ҏ্ X ҎԼͷ੔਺ ͷΈͰΑ͍Ͱ͢ (ͳͥͳΒɺ b>X ͳΒ೚ҙͷ p >= 2 ʹରͯ͠ bp > X ͔ͩΒ౴͑ʹӨڹΛٴ͞¨ͳ͍)ɻ ಉ༷ʹɺ p ͱͯ͠ࢼ) ͸஋͖΂͢ͱͯ΋ࡶʹݟ (΋xr΋ੵ2 Ҏ্ X ҎԼͷ੔਺ ͷΈͰे෼Ͱ͢ɻΑͬͯ ೋॏϧʔϓͰ b, p ͷશͯͷϖΞΛࢼ͜͢ͱͰ expox ͕ਖ਼͘͠ٻ·Γ·͢ɻ ࣌ؒࢉܭ ͸ྔO(X2) Ͱ͢ɻ ͔͠͠ɺΦʔόʔϑϩʔΛى͜͞ͳ͍ͨΊʹ΋ҎԼͷํ๏͕ྑ͍ͱࢥ͢·͍ɻ ֤ b ʹରͯ͠ɺp = 2, 3, .. ͱॱ൪ʹ, expobp Λ true ʹॻ͖׵͢·͖͍x͑ɻ͜͜Ͱɺ΋͠ࠓௐ΂͍ͯΔ஋ bk ͕ X ΑΓେ͖͔ͬͨΒɺk Ҏ߱ͷ஋͸ p ͱͯ͠ߟ͑Δඞཁ͕͋Γ·ͤΜɻैͬͯͦ͜Ͱ p ͷϧʔϓΛଧ ͪ੾ͬͯྑ͍Ͱ͢ɻͨͩ͠ b = 1 ͷ࣌͜͸ʹͷ৚݅Ͱͷଧͪ੾Γ͸ൃੜ͠ͳ͍ͷͰ஫ҙ͍ͯͩ͘͠͞ɻ #include <bits/stdc++.h> using namespace std; 1 int main(){ int X; cin >>X; vector <bool > expo(X+1); expo[1] = 1; for(int b=2;b<=X;b++){ int v = b*b; while(v<=X){ expo[v] = 1; v *= b; } } for(int i=X;i>=1;i--) if(expo[i]){ cout <<i<<endl; return 0; } } C: K-th Substring ղઆͰ͸ N := |s| ͱ͓͖·͢ɻ ·ͣ෦෼఺ղ๏ (N < 50) Λઆ໌͠·͢ɻશͯͷ s ͷ substring Λྻڍ͠ɺॏෳΛআ͖ɺιʔτ͠·͢ɻ͜ Εʹ͸͍Ζ͍Ζͳํ๏͕͋Γ·͕͢ɺྫ͑͹ C++ ͩͱ sort ͨ͋͠ͱ unique ؔ਺Λ࢖crΓɺset Λ࢖͏ͳ Ͳ͕ߟ͑ΒΕ·͢ɻͦͷޙɺখ͍͞ํ͔Β K ൪໨ͷจࣈྻΛग़ྗ͢Ε͹Α͍Ͱ͢ɻ ࢉܭ ,͸ྔO(N2) ݸͷ ௕͞ O(N) ͷจࣈྻΛιʔτ͢ΔͷͰɺ O(N3logN) ʹͳΓ·͢ɻ(ൺֱճ਺͕ O(N2logN), 1 ճͷൺֱʹ͔͔Δ࣌ ͕ؒO(N)) ຬ఺ղ๏Ͱ͸ɺ౴͑ͷจࣈྻͷ௕͕͞ߴʑ K Ͱ͋Δͱ͍͏͜ͱʹண໨͠·͢ɻ(͜Ε͸ɺจࣈ ྻt ͷ prefix(Ͱ͋ͬͯ t Ͱͳ͍΋ͷ) ͕ શͯҟͳΓɺ͔ͭ strict ʹ t ΑΓখ͍͜͞ͱ͔Βࣔ͢·eɻ) ͜ͷ࣮ࣄ͔Β ͸͡Ίʹྻڍ͢Δඞཁ͕͋Δͷ͸ ௕͞ K ҎԼͷ substring O(NK) ݸ͚dͰ͢ɻ͜ΕΛιʔτ͢Δͱɺ ࣌ ؒࢉܭ ͸ྔO(NK2(logNK)) ͱͳΓɺे෼ߴ଎Ͱ͢ɻ D: Equals ҎԼͷΑ͏ͳແ޲άϥϑ G Λߟ͢·͑ɻ ௖఺ू߹: 1 Ҏ্ N ҎԼͷ੔਺ ลू߹: ֤ 1 ≤ j ≤ M ʹରͯ͠ɺ(xj , yj ) ͱ͍͏ลΛுΔ ͢Δͱ࣍ͷ͜ͱ͕ࣔ:͢·e S := {i|G ʹ͓͍ͯ i ͱ pi͕ಉ͡࿈݁੒෼ʹ͋Δ } ͱ͓͘ͱɺ ࠷ऴঢ়ଶͰશͯͷ i ∈ S ʹରͯ͠ಉ࣌ʹ pi = i ͱ͢Δ͜ͱ͕ग़དྷΔ ূ໌͸ޙʹճ͠·͢ɻٯ ʹG ʹ͓͍ͯ i ͱ pi ͕ҟͳΔ࿈݁੒෼ʹଐͯ͠͠·͍ͬͯΔ৔߹, ૢ࡞Λߦxr ΋ pi = i ͱग़དྷͳ͍͜ͱ͸໌Β͔Ͱ͢ɻैͬͯɺ|S| ͕౴͑ʹͳΓ·͢ɻ֤ i ͕ S ʹ ଐ͢Δ͔͸ UnionFind ౳Λ࢖͏ͱٻΊΔ͜ͱ͕ग़དྷ·͢ɻ ূ໌: ࣋ؾhతʹ͸ಉ͡࿈݁੒෼಺Ͱ͸޷஋ʹ͖ΛೖΕସ͑ΒΕΔ͜ͱ͔ΒΘ͔Γ·͢ɻͪΌΜͱ΍Δͱɺ ֤࿈݁੒෼ C ʹରͯ͠ɺ C ͔Β {pi|i ∈ C} ΁ͷશ୯ࣹ f Ͱ͋ͬͯ i ∈ S ͳΒ f(i) = i ͱͳΔΑ͏ͳ΋ͷ͕ 2 ͱΕͯɺ࿈݁੒෼ͷશҬ໦Λͱͬͯɺͻͱͭͷ༿ i ʹਖ਼͍͠஋ f(i) Λஔ͘ͱ͍͏͜ͱΛ܁Γฦͤ͹ࣔ͢·eɻ E: Sorted and Sorted ؆୯ͷͨΊɺ i ͕ॻ͔Εͨ ࠇ/͍ന͍ ϘʔϧΛ ࠇ/ന ͷ i ͱݺͼ·͢ɻ ࠷ऴঢ়ଶΛҰͭݻఆͨ࣌͠ʹɺͦͷঢ়ଶʹͳΔ·Ͱʹඞཁͳ࠷খͷૢ࡞ճ਺ f ͸స౗਺Ͱදͤ·͢ɻ͢ͳ Θͪɺf = #{(x, y) : Ϙʔϧͷ૊ |x ͸ॳظঢ়ଶͰ y ΑΓࠨ͋ʹΔ ∧ x ͸࠷ऴঢ়ଶͰ y ΑΓӈʹ͋Δ } Ϙʔϧ x Λݻఆ্ͨ࣌͠ʹͷू߹ʹೖΔ (x, y) ͷݸ਺Λ fx ͱஔ͖·͢ɻ f = !fx Ͱ͢ɻ ࣍ͷΑ͏ͳ DP Λߟ͢·͑ɻdpi,j = ࠷ऴঢ়ଶʹ͓͍ͯϘʔϧΛࠨ͔Βॱʹஔ͍͍ͯͬͯɺࠇ͍ϘʔϧΛ i ݸ ,ന͍ϘʔϧΛ j ݸ ஔ͍ͨ࣌ͷ, ͜Ε·Ͱஔ͍ͨϘʔϧ x ʹؔ͢Δ fx ͷ࿨ ͷ࠷খ஋ ͜Ε͸࣍ͷΑ͏ʹߋ৽Ͱ͖·͢ɻdpi,j = min(dpi−1,j + costbi−1,j , dpi,j−1 + costwi,j−1) ͜͜Ͱɺcostbi,j ͱ͸ɺ ࠇ͍ϘʔϧΛ i ݸ ,ന͍ϘʔϧΛ j طݸʹஔ͍͍ͯΔ࣌ ʹࠇͷ i + 1 Λஔ͍ͨ࣌ͷ fࠇͷ i+1 ͷ஋Ͱ͢ɻ ͜Ε͸ well-defined Ͱ͢ɻ(ͭ·Γɺ͜Ε͔ΒͲ͏ஔ͔͘΍ɺ͜Ε·ͰͲ͏ஔ͍͔ͨʹ͸ґଘ͍ͯ͠·ͤΜ) ͜ ͷ͜ͱ͸ x ͷࠨ͋ʹΔϘʔϧͷू߹͕ i, j ͚͔ͩΒҰҙʹఆ·Δ͜ͱ͔ΒΘ͔Γ·͢ɻcostw ΋ಉ༷Ͱ͢ɻ costb, costw ͸ BIT Λ࢖ xrO(N2logN) ͰٻΊͨΓ, “ࠨ k ݸ͋ʹΔ i ҎԼͷࠇ͍Ϙʔϧͷݸ “਺ͳͲΛ લࢉܭc͠Γ͢Δ͜ͱͰ O(N2) ͰٻΊΔ͜ͱ͕ՄೳͰ͢ɻ͢Δͱશͯͷ dpi,j ΋ O(N2) ͰٻΊΒΕ·͢ɻ ౴͑͸ dpN,N Ͱ͢ɻ F: Monochrome Cat ·ͣࠇ͍༿ΛΘ͟Θ͟๚ΕΔඞཁ͸͋Γ·ͤΜɻͳͷͰɺࠇ͍༿͕͋Ε͹ͦΕΛফ͢ɺͱ͍͏͜ͱΛͰ͖Δ ͚ͩ܁Γฦ͠·͢ (͜Ε͸ queue ౳Λ࢖͏ͱ؆୯ʹͰ͖·͢)ɻ͢Δͱ͍͔ͭ͸શͯͷ༿͕ന͘ͳΓ·͢ɻҎ Լ͜ͷ໦ʹ͍ͭͯߟ͢·͑ɻ “ࡏݱ͍Δ௖఺ͱྡ઀ͨ͠௖఺Λͻͱͭબͼͦͷ௖఺ʹҠಈ͢ΔɻͦͷޙɺҠಈઌͷ௖఺ͷ৭Λ൓స͢Δɻ” ͱ͍͏ૢ࡞Ͱ ௖఺ a ͔Β ௖఺ b ʹҠಈͨ͠৔߹ɺ͜ͷૢ࡞Λ a ⇒ b Ͱද͠·͢ɻ ·ͨɺ” ࠓ͍Δ௖఺ͷ৭Λ൓స͢Δ” ͱ͍͏ૢ࡞Λ ௖఺ a Ͱߦ߹৔crɺ͜ͷૢ࡞Λ flip a Ͱද͠·͢ɻ ·ͣɺͻͱͭͷลΛ 3 ճҎ্౉Δ͜ͱ͸͋Γ·ͤΜɻͳͥͳΒɺ(ૢ࡞ ྻ1) → (a ⇒ b) → (ૢ࡞ ྻ2) → (b ⇒ a) → (ૢ࡞ ྻ3) → (a ⇒ b) → (ૢ࡞ ྻ4) ͱ͍͏ૢ࡞͸ྻɺ(ૢ࡞ ྻ1) → (ૢ࡞ ྻ3) → (flip a) → (a ⇒ b) → (flip b) → (ૢ࡞ ྻ2) → (ૢ࡞ ྻ4) ͱมߋ͢Δͱɺૢ࡞ճ਺͸อͬͨ··ɺଞͷลͷ࢖༺ճ਺Λ ม͑ͣʹɺล (a, b) ͷ࢖༺ճ਺ΛݮΒͤΔ͔ΒͰ͢ɻ Α֤ͬͯล͸ߴʑ 2 ճ͔͠࢖Θͳ͍ͱͯ͠Α͍Ͱ͢ɻ ·ͨɺશͯͷ༿͕നͳͷͰҰ౓͸๚ΕΔඞཁ͕͋Δ͜ͱ͔Βɺ͢΂ͯͷ௖఺Λ๚ΕΔඞཁ͕͋Δ͜ͱ͕Θ͔ Γ·͢ɻಛʹ֤ลΛগͳ͘ͱ΋ 1 ճ͸࢖͢·͍ɻ ͜ͷ 2 ͭͷ࡯ߟ͔ΒɺೣͷҠಈͷ༷ࢠ͸࣍ͷਤͷ੺ઢͷΑ͏ʹݶఆ͞Ε·͢: 3 ͢ͳΘͪɺ࢝ ఺௖s ͔Β Euler tour Λ͢Δ్தɺ͢΂ͯͷ௖఺Λ๚Εͨ͋ͱͳΒ ऴ௖఺ t ͰҠಈΛ΍Ίͯ ྑ͍ ͱ͍͏ܗͰ͢ɻ Ҡಈૢ࡞ͷྻ͕ܾ·͍ͬͯΔ࣌ɺflip ૢ࡞ ΛԿճߦ͸͔͍͍͹͑Ұҙʹఆ·Γ·͢ɻͳͥͳΒɺ֤௖఺Λগ ͳ͘ͱ΋Ұ౓͸๚Ε͍ͯΔͷͰɺ΋͠” ͢΂ͯͷҠಈૢ࡞͕ऴΘͬͨ͋ͱʹ௖఺ v ͷ৭͕നʹͳ͍ͬͯΔ” ͳ Β͹ɺ ௖఺ v Λ๚ΕͨλΠϛϯάͰ flip v Λ͢Δ͜ͱʹ͢Ε͹Α͍͔ΒͰ͢ɻ ͜͜ͰɺEuler tour ͕ޙ࠷·Ͱ׬ྃ͢ΔΑ͏ʹɺૢ࡞ʹྻ੨ͷഁઢͷΑ͏ʹ௥Ճ͢Δ͜ͱΛߟ͢·͑ɻ͜ͷ ࣌ͷૢ࡞ճ਺͸ɺ2(N − 1) + #{v ∈ G| (v : white) xor (degv is odd) } ͱͳΓɺs,t ΍ಈ͖ํʹ͸ґଘ͠· ͤΜɻ ͔͜͜Β੨ͷ௥Ճ෼Λফ͢͜ͱΛߟ͢·͑ɻૢ࡞ճ਺͕Ͳͷ͘Β͍ݮΔ͔͸ɺ੨ͷഁઢͷ path Λ t = b0, b1, .., bK−1, bK = s ͱ͓͘ͱɺ࣍ͷ f Ͱදͤ·͢ɻ f := K + #{v ∈ {b1, b2, ., bK}| (v : white) xor (degv is odd) } - #{v ∈ {b1, b2, ., bK}| (v : white) xor (degv is even) } มܗx͠ɺ f = 2 × #{v ∈ {b1, b2, ., bK}| (v : white) xor (degv is odd) } ͜ͷ f Λ࠷େԽ͢Δͷ͕໨తͰ͢ɻ͜Ε͸ t, s ͷΈʹґଘ͢Δ͜ͱʹ஫ҙ͍ͯͩ͘͠͞ɻ :͢·ΒΕ͑׵͍ݴʹ͏ͷΑ࣍͸୊໰ͷ͜ ແ޲άϥϑ͕༩͑ΒΕΔɻ֤௖఺ʹ͸஋ 0 ͔ 1 ͕ॻ͍ͯ͋Δɻ࠷େͰԿݸ 1 ͕ॻ͍ͯ͋Δ௖఺ΛؚΊΔ path ͕ͱΕΔ͔? (∵ b0, .., bK ͸೚ҙͷ path ΛͱΕ·͢. path ΛΘ͟Θ͟୹͘͢Δඞཁ͸ͳ͍ͷͰ, b0, bK ͸༿ͱͯ͠Α͍ Ͱ͢ɻ௖఺਺͕ 2 Ҏ্ͳΒ ఆ͔ٛΒ༿, ಛʹ b0 ʹॻ͍ͯ͋Δ஋͸ 0 ͳͷͰɺ݁ہ্) ͷ໰୊ͷ౴͑) ×2 ͕ f ʹͳΓ·͢ɻ) ͜Ε͸໦ͷ௚ܘΛٻΊΔͷͱಉ༷ͷΞϧΰϦζϜͰ dfs 2 ճͰՄೳͰ͢ɻ ͜ΕͰ O(N) Ͱݩͷ໰୊ͷ౴͑ ͕ٻ·Γ·ͨ͠ɻ ॳظঢ়ଶͰന͍௖఺͕ 0 ݸ,1 ݸͷίʔφʔέʔεʹ஫ҙ͍ͯͩ͘͠͞ɻ(1 ݸͷ৔߹͸্ͷ ∵ ಺ͷଠࣈ෼෦ ͕੒Γཱͨͳ͍ͷͰ) 4 ABC097 / ARC097 Editorial sigma425 A: Colorful Transceivers C++ example: # include < bits / stdc ++. h > using namespace std ; int main (){ int a ,b ,c ,d; cin >>a > >b > >c >> d; if ( abs (a -c ) <= d || ( abs (a - b ) <= d && abs (b -c ) <= d )) puts (" Yes "); else puts (" No "); } B: Exponential C++ example: # include < bits / stdc ++. h > using namespace std ; int main (){ int X ; cin >>X; vector < bool > expo (X +1); expo [1] = 1; for ( int b =2; b <= X; b ++){ int v = b*b ; while (v <= X ){ expo [v] = 1; v *= b ; } } for ( int i =X;i >=1; i - -) if ( expo [i ]){ cout <<i << endl ; return 0; } } 1 C: K-th Substring For an arbitrary string t, each of its proper suffix is lexicographically smaller than t, and the lexicographic rank of t is at least |t|. Thus, the length of the answer is at most K. Generate all substrings of s whose lengths are at most K. Sort them, unique them, and print the K-th one. This solution works in O(NK2 (logNK)) time, where N = |S|. D: Equals Consider a graph G: there are N vertices numbered 1 through N, and for each j there is an edge (xj , yj ). Then, by performing some operations, pi can be i if they are in the same connected component of the graph. We can also prove that we can satisfy pi = i for all such i simultaneously. (Formal proof: take a spanning tree of a connected component. Choose its leaf v, perform opeartions such that pv = v is satisfied, and never make operations involving v after that.) We can compute the number of such i by DFS or DSU. 2 E: Sorted and Sorted Suppose that we know the final order of balls. Then, we can compute the number of operations as an inversion number: the number of ordered pairs of two balls (x, y) such that x is to the left of y at the beginning, but x is to the right of y in the final order. Let’s decide the positions of balls and place them one by one, from left to right (in the final order). From the constraints in the statement, at any moment, the set of placed balls must be of the form ”i black balls numbered 1 through i, and j white balls numbered 1 through j”. Define dpi,j as the minimum possible inversion number among them when we place those balls. The answer is dpN,N . Then, the recurrence formula will be as follows: dpi,j = min(dpi−1,j + costbi−1,j , dpi,j−1 + costwi,j−1) Here, costbi,j is the cost required to append black i+ 1 when the first i black balls and the first j white balls are already placed. That is, the number of balls that are already placed and initially placed to the right of black i + 1. Similarly, costwi,j are defined. We can pre-compute the arrays costbi,j , costwi,j like prefix sums in O(N2 ). Thus, this solution works in O(N2 ) time. 3 F: Monochrome Cat If the tree contains a black leaf, it never makes sense to visit it. Thus, we can repeatedly remove black leaves until all leaves become white. (This can be implemented by, for example, using a queue.) From now on, we assume that all leaves in the input tree are white. We also assume that the tree has at least two white vertices to avoid some special cases. Suppose that we are given two vertices s and t, and the cat must start at s and end at t. How many operations do we need in this case? First, for each edge e, let’s compute the number of times the cat passes through e. • It never makes sense to pass through it three or more times. For example, suppose that we move between two vertices a and b three times. The sequence of operations will look like ”W → (a ⇒ b) → X → (b ⇒ a) → Y → (a ⇒ b) → Z” However, we can replace it with ”W → Y → (flip a) → (a ⇒ b) → (flip b) → X → Z” and the number of operations will be smaller. Here, W, X, Y, Z represent some sequences of operations, a ⇒ b denotes an operation of the first type, and flip a denotes an operation of the second type. • We must pass through each edge at least once (otherwise some white leaves will be left unvisited.) Thus, if e is on the path between s and t, we pass through it exactly once, otherwise we pass through it exactly twice. The trajectory of the cat will look as follows: Now, we know the number of operations of the first type. How can we compute the number of operations of the second type? Suppose that if we never make operations of the second type, k white vertices remains. Then, we need k extra steps to change the color of those vertices. This is always possible because we visit all vertices. Let’s call those k vertices ”bad vertices”, and other vertices ”good vertices”. Depending on the initial color and the parity of degree of the vertex, there are two types of vertices: • It becomes a bad vertex if it is on the s − t path, otherwise it becomes a good vertex. • It becomes a good vertex if it is on the s − t path, otherwise it becomes a bad vertex. In summary, the total number of opeartions can be computed as follows (for a given pair of s, t): • Add twice the total number of edges. 4 • Subtract the distance between s and t. • Subtract the number of bad vertices. This can be simplified as follows. For each vertex, the cost of zero or two is assigned depending on the type of the vertex mentioned above. Then, • Add twice the total number of edges, plus one. • Subtract the total cost of all vertices on the path between s and t. Now our objective is to find a path that maximize the total cost of vertices on it. This is similar to the computation of diamater of a weighted tree, and can be done in O(N). 5 ABC 095 / ARC 096 Editorial (Japanese) 問題・解説: evima 2018 年 4 月 21 日 For International Readers: English editorial starts on page 7. A: Something on It この問題を解くには、以下の手順を踏む必要があります。 0.（言語によっては不要）文字列変数 S を宣言する。 1. 標準入力から S を文字列として受け取る。 2. S から何らかの方法で答えとなる整数を得る。 3. 求めた値を標準出力に出力する。 手順 0, 1, 3 については、practice contest の問題 A の問題別サンプルコードが参考になる（少し書き換え れば使える）でしょう。手順 2 については、S の 3 つの文字それぞれを if 文でチェックするか、もしくは 言語の機能を用いて S に含まれる o の個数を数えることになります。前者の C++ による実装例と後者の Python(3) による実装例を示します。 1 #include <iostream> 2 using namespace std; 3 int main(){ 4 string S; 5 cin >> S; 6 int ans = 700; 7 if(S[0] == 'o') ans += 100; 8 if(S[1] == 'o') ans += 100; 9 if(S[2] == 'o') ans += 100; 10 cout << ans << endl; 11 } 1 print(700 + 100 * input().count('o')) 1 B: Bitter Alchemy 入力例の説明でほのめかされているように、「まずすべての種類のドーナツを 1 個ずつ作り、残ったお菓子 の素で最も『安い』ドーナツを作れるだけ作る」という方針で問題ありません。つまり、m1, m2, ..., mN の和 を S、m1, m2, ..., mN のうち最小の値を M として、答えは N + ⌊(X − S)/M⌋ となります。*1主な課題は、 m1, m2, ..., mN の値を読み込むことと、S や M の値を実際に求めることです。なお、割り算と小数部分切り 捨ての部分に関しては、多くのプログラミング言語では単に A / B と書くことで ⌊A/B⌋ が求められます。*2 言語によってやや事情が異なるかもしれません。C++, Java などの言語では、ループ構造を用いるのが素 直でしょう。C++ での実装例を挙げます。 1 #include <iostream> 2 using namespace std; 3 4 int main(){ 5 int N, X, m[101]; 6 cin >> N >> X; 7 int S = 0, M = 1001001001; 8 for(int i = 0; i < N; ++i){ 9 cin >> m[i]; 10 S += m[i]; 11 if(m[i] < M){ 12 M = m[i]; 13 } 14 } 15 int ans = N + (X - S) / M; 16 cout << ans << endl; 17 } Python, Ruby といった言語でももちろん上のようなアプローチが可能ですが、こういった言語では sum, max といった関数がはじめから用意されていることがあり、便利です。*3これを用いた Python(3) での実装例 を次ページに挙げます。 *1 ⌊x⌋ は x の整数部分を表します。 *2 A, B が正でない場合はこの限りでなく、またここに実装例を掲載した Python3 はこれに該当しません。 *3 このような機能のため、AtCoder Beginner Contest で出題されうる程度の問題の解法を手っ取り早く実装する上で、スクリプ ト言語はとても役立ちます。ただし、この範囲を超えると、どうしても実行速度が足りない場面が急速に増えます。競技プログラ ミングに本格的に取り組む場合、C++ とは言わずとも Java に匹敵する実行速度を有する言語を一つ習得する必要がある、とい うことをお伝えしておきます。 2 1 N, X = map(int, input().split()) 2 m = [] 3 for i in range(N): 4 m.append(int(input())) 5 print(N + (X - sum(m)) // min(m)) C: Half and Half まず、AB ピザを奇数枚買って 1 枚余らせるのは無意味なので、AB ピザは 2 枚 1 組で考えます。つまり、 2C 円で A ピザ 1 枚と B ピザ 1 枚を買えると考えることにし、この 2 枚の組み合わせをこれ以降 AB セッ トと呼ぶことにします。 この問題の重要な制約は、X, Y ≤ 105 です。これは、A ピザ、B ピザ、AB セットのどれについても、買 う個数は 10 万個以下でよいことを意味します。したがって、この三種類のうちどれか一種類を選んで、それ を買う個数を 0 から 10 万まですべて試す、という方針が考えられます。*4 さて、三つのうちどれについて購入個数を全列挙するべきでしょうか？結論を述べると、AB セットです。 AB セットを i 個 (0 ≤ i ≤ 105 ) 購入した場合、i ≥ X であれば A ピザを買い増す必要はなく、i < X であれ ば A ピザを X −i 枚買い増す必要があります。これらをまとめて、買い増すべき A ピザの数は max(0, X −i) 枚であるということもできます。同様に、B ピザを max(0, Y − i) 枚買い増す必要があります。以上から、 AB セットを i 枚購入した場合の所要金額は i × 2C + max(0, X − i) × A + max(0, Y − i) × B 円であり、こ の値を 0 以上 10 万以下のすべての整数 i について計算して最小値を取ることで答えが求まります。 なお、定数時間で答えを求めることもできます。練習問題として解説は省きます。 *4 なお、二種類を選んでしまうと考慮する可能性の数が約 100 億通りになり、2018 年現在の一般的な計算機が 2 秒で探索するには 厳しいです。今日の一般的な計算機が 1 秒あたりに処理できる式の数はおよそ 1 億個といったところで、短い単純な式であれば 10 億個程度まで伸び、逆に実数の割り算など複雑な演算を伴う場合は数千万個程度に落ちます。 3 D: Static Sushi 中橋君の靴にペンキが塗られていて、通ったところの床にペンキが塗られると想像してください。最終的 に、ペンキが塗られた区間に含まれる寿司をすべて食べることになります。 初期位置を O とし、退店するときにペンキが塗られている区間を円弧 AB とします（O から時計回りに進 んだときに先に到着する方の円弧の端を A とします。なお、円周全体が塗られる場合は最適でないため考え ません）。点 A と B の片方もしくは両方（即座に退店したとき）が O と一致する場合もあります。すると、 最適な歩き方は、「A まで時計回りに歩き、方向転換して反時計回りに B まで歩いて退店」もしくは「B ま で反時計回りに歩き、時計回りに A まで歩いて退店」となります。 前者での移動距離は OA + AB = 2OA + OB、後者での移動距離は同様に OA + 2OB となります。A と B を定めたとき、OA ≤ OB のとき前者、OA ≥ OB のとき後者の歩き方をするのが最適となりますが、実 はそれを意識する必要はあまりなく、前者の歩き方をすると決めたときの最適解と後者の歩き方での最適解を 別々に求め、よりよい方を答えとするのが単純です。以下では、後者の歩き方での最適解を求めます。前者の 場合も同様に求められます。 解を求めるには、もう一つの観察が必要です: A, B はどちらも、寿司のある位置か初期位置のいずれかであ るべきです。そうでなければ、含まれる寿司を減らすことなく円弧を縮められるためです。よって、N ≤ 100 の部分点のためのテストセットは、A, B の位置をそれぞれ全探索することで解けます。愚直に実装すれば O(N3 ) 時間、v1, v1 + v2, ..., v1 + v2 + ... + vN や vN , vN + vN−1, ..., vN + vN−1 + ... + v1 を事前に計算し ておけば O(N2 ) 時間の解法が得られます。 N ≤ 105 の満点用テストセットも、これを少し改善することで解けます。A, B のうちどちらかの位置を全 て試す時間はあるため、ここでは B の位置をすべて試すことにします。B の位置を xb に固定したとき、A の位置は x1, x2, ..., xb−1 のいずれかであり、このうち f(a) := v1 + v2 + ... + va − xa が最大となるような a に対応する xa を選択するべきです（差し引きの摂取カロリーは、f(a) に vN + vN−1 + ... + vb − (C − xb) を 加えたものですが、この部分は a に依存せず一定値をとるためです）。よって、事前に f(0), f(1), ..., f(N) の 値を求めておき、さらに g(a) := max(f(0), f(1), ..., f(a)) を a = 0, 1, ..., N に対して計算しておけば（g(0) から順に求めます）、B の位置を固定したときに直ちに最適な A の位置を選ぶことができ、O(N) 時間の解法 が得られます。 4 E: Everything on It まず、包除原理 (Wikipedia) を適用しないことには進展はないでしょう。トッピングの対称性から、答え を A として次が得られます。*5 A = ∑ N i=0 (−1)iC(N, i)ways(i) ここで C(N, i) は二項係数であり、ways(i) は何杯かのラーメンの組み合わせであって、トッピング 1, 2, ..., i がいずれも 1 杯以下にしか乗っていないようなものの個数です（トッピング i + 1, i + 2, ..., N につ いては不問）。各 ways(i) を O(N) 時間で求めることができれば、満点が得られます。 j = 0, 1, .., i のそれぞれに対して、上の条件を満たすようなラーメンの組み合わせであって、トッピング 1, 2, ..., i のうち一つ以上が乗っているラーメンがちょうど j 杯あるようなものの個数（ways2(i, j) としま す）を O(1) 時間で求めることができれば、それらを足し合わせることで O(N) 時間で ways(i) が求まりま す。そして、これは可能です。 このようなものを数える上で最も重要な「部品」は、トッピング 1, 2, ..., i がどのように分割されるか、す なわち、「i 個の区別可能な物体から一部を選んで j 組の空でないグループを作る方法の数（同じ物体は複数 組に属せないが、ゼロ組に属することは可能）」です（下記の図を参照してください）。これは、第二種スター リング数 (Wikipedia) に非常に近い概念で、それと同様に動的計画法による O(N2 ) 時間の事前計算により 必要なすべての値を求めることができます。ここで、i 個のトッピングのうち何個が実際にラーメンに乗って いるか、はさほど重要でないことに注意してください（この数で場合分けをしてしまうと、解法の所要時間が O(N3 ) になってしまいます）。 図: N = 10 のとき ways2(6, 3) に数えられるラーメンの組み合わせの例（各枠がラーメン一杯に対応） これに、残りのトッピング i+1, i+2, ..., N を考慮して 2 (N−i)j や 2 2 N−i を掛け合わせることで ways2(i, j) を定数時間で求めることができ（上記の他にも事前計算が必要です）、目標が達成されます。 *5 この文と次の式の意味がよく分からない方は、N = 3 や 4 のケースで包除原理をそのまま適用した結果を観察してみてください。 ここでの「対称性」という単語の意味は「交換可能」といったところです。 5 F: Sweet Alchemy di = ci − cpi 　とします。例外として i = 1 (根) 　のとき　 di = ci 　とします。 これを用いると、次のように言い換えられます： • 各 i > 1 　について 0 ≤ di ≤ D が成り立つ。d1 は任意の非負整数である。 • 各 i 　について以下を di 回行う: i を根とする部分木内の各頂点 j に対し、ドーナツ j 　を一個作る。 • 上の条件の下でドーナツの個数を最大化せよ。 これはさらにナップザック問題に言い換えられます。頂点 v 　を根とする部分木内の頂点を w1, · · · , wk と すると、この部分木に対する操作を行うことは Yv := k 個のドーナツを Xv := mw1 + · · · + mwk グラムの素 を使って作ることと同値です。これを重さ Xv 価値 Yv 　のアイテムとみなします。 以下を解きたいです： • N 種類のアイテムがある。 • i 　種類めの重さは Xi 　価値は Yi 　である。 • 重さの合計が X 　以下、種類 i を選ぶ個数は Zi 以下となるようにするとき、価値の合計の最大値を 求めよ。 • Constraints: N ≤ 50, Yi ≤ 50. 他の値は大きい。 直感的には、効率の良いものから greedy にとるべきです。アイテムが効率の良い順にソートされていると します (Y1/X1 ≥ Y2/X2 ≥ · · ·) これを厳密に述べると、二種類のアイテム p, q (p < q) 　を考えます。アイテム p が 50 個以上選ばれずに 残り、またアイテム q が 50 個以上選ばれずに残っているとします。このとき、アイテム q を Yp 個捨てて、 アイテム p を Yq 個新たに選ぶことで、価値の総和を増やすことができます。したがって、このような組 p, q は存在しないと仮定することができます。 これにより、次が示されます：二つの袋があり、各 i に対して、アイテム i のうち min(50, Zi) 個を一つ目 の袋に入れ、残りのアイテム i を二つ目の袋に入れます。このとき、最適解においては、一つ目の袋に入って いるアイテムから一部を選び、二つ目の袋からはアイテムを単に greedy に（効率の良い順に）選ぶべきです。 あとは簡単です。一つ目の袋に入っているすべてのアイテムの価値の総和は N3 以下です。各 0 ≤ Y ≤ N3 に対し、一つ目の袋から選んだアイテムの価値の総和が Y であると仮定して、それらのアイテムの重さの総 和を最小化します（これは O(N4 log N) 時間の単純な DP で可能です）。そして、二つ目の袋からさらにア イテムを貪欲に（重さの上限に達するまで）選んでいきます。 この解法は O(N4 log N) 時間で動作します。 6 ABC 095 / ARC 096 Editorial (English) evima April 21, 2018 A: Something on It To solve this problem, you need to go through the procedure below: 0. (Unnecessary for some languages) Declare a string variable S. 1. Receive S as a string from Standard Input. 2. Obtain the answer from S in some way. 3. Print the found value to Standard Output. For steps 0, 1 and 3, the sample code for each language for Problem A in practice contest would be helpful (can be actually used after modifying a bit). For step 2, you would need to check each of the three characters in S using if statements, or count the number of o in S using some feature in your language. The former approach in C++ and the latter approach in Python(3) are shown below: 1 #include <iostream> 2 using namespace std; 3 int main(){ 4 string S; 5 cin >> S; 6 int ans = 700; 7 if(S[0] == 'o') ans += 100; 8 if(S[1] == 'o') ans += 100; 9 if(S[2] == 'o') ans += 100; 10 cout << ans << endl; 11 } 1 print(700 + 100 * input().count('o')) 7 B: Bitter Alchemy As implied in the notes for the sample inputs, the following strategy works fine: “first make one doughnut for each kind, then make as many ‘cheapest’ doughnuts as possible”. That is, the answer is N + ⌊(X − S)/M⌋ *1 , where S is the sum of m1, m2, ..., mN , and M is the minimum value among m1, m2, ..., mN . The main challenge is to read the values of m1, m2, ..., mN , and actually find the values of S and M. For the “division and rounding down” part, ⌊A/B⌋ can be found by just writing A / B in many languages *2 . The situation may be different for different languages. In languages such as C++ and Java, it would be straightforward to use loop structures. A sample implementation in C++ is shown below: 1 #include <iostream> 2 using namespace std; 3 4 int main(){ 5 int N, X, m[101]; 6 cin >> N >> X; 7 int S = 0, M = 1001001001; 8 for(int i = 0; i < N; ++i){ 9 cin >> m[i]; 10 S += m[i]; 11 if(m[i] < M){ 12 M = m[i]; 13 } 14 } 15 int ans = N + (X - S) / M; 16 cout << ans << endl; 17 } The above approach is also possible in languages such as Python and Ruby, but in these languages there are occasionally built-in functions such as sum and max, which are convenient. *3 A sample implementation in Python(3) using these functions is shown in the next page: *1 ⌊x⌋ represents the integer part of x. *2 Not necessarily true when A or B is not positive. Also, Python3, which is used here for the sample implementation, is an exception of this statement. *3 Because of these functionalities, script languages are very useful in quickly implementing the solution of problems of difficulties suited for AtCoder Beginner Contest. However, for harder problems, there are suddenly many situations where these languages are simply too slow. I’m letting you know that, if you intend to do competitive programming seriously, you would need to learn one language that can rival Java for speed, if not C++. 8 1 N, X = map(int, input().split()) 2 m = [] 3 for i in range(N): 4 m.append(int(input())) 5 print(N + (X - sum(m)) // min(m)) C: Half and Half First, since buying an odd number of AB-pizzas and having one leftover is nonsense, we will always buy these in pairs. That is, we will assume that we can buy one A-pizza and one B-pizza for 2C yen, and we will call this set an AB-set. The important constraint in this problem is X, Y ≤ 105 . This means that we need to buy at most 100000 A-pizzas, at most 100000 B-pizzas and at most 100000 AB-sets. Thus, we can select one of these three menus and try every possible number of that menu purchased from 0 to 100000. *4 Which among the three should we focus on? Our conclusion is AB-sets. When we buy i AB-sets (0 ≤ i ≤ 105 ), we don’t need to buy extra A-pizzas if i ≥ X, and we need to buy X − i extra Apizzas if i < X. In other words, we should buy max(0, X − i) extra A-pizzas. Similarly, we should buy max(0, Y − i) extra B-pizzas. Therefore, we need i × 2C + max(0, X − i) × A + max(0, Y − i) × B yen if we buy i AB-sets, and the answer can be found by computing this value for every integer i from 0 to 100000, and taking the minimum obtained value. A constant time solution is also possible, which is left as an exercise. *4 If we select two, there are about 10 billion possibilities to consider, which is too much for an ordinary computer today to enumerate in 2 seconds. A rough guess of the number of formula that an ordinary computer today can process in 1 second is about 100 million. This number can grow up to about 1 billion if the formula is a short, simple one. On the other hand, it can decline down to about several ten millions if the formula involves complex operation such as division of real numbers. 9 D: Static Sushi Imagine that his shoes are wet with paint, and he paints the floor where he walks. In the end, he eats all sushi in the painted segment. Let the initial place be O, and the painted segment in the end be arc AB (If we walk clockwise from O, we reach A first. We ignore the case where the whole counter is painted, which is not optimal). Note that A and/or B may coincide with O. The optimal way to walk is to ”walk clockwise until A, then turn around and walk counterclockwise until B”, or ”walk counterclockwise until B, then turn around and walk clockwise until A”. The distance covered in the first way of walking is OA + AB = 2OA + OB, and OA + 2OB in the second way. When A and B is fixed, it is optimal to perform the first way if OA ≥ OB, and the second way if OA ≥ OB, but we actually don’t have to care this too much. We just need to find the optimal solution when we stick to the first way, and the optimal solution when we stick to the second way, and take the better one. We will deal with the second way from now on (the first way can be dealt similarly). One more observation is required to find the solution, both A and B must be a position where a sushi is placed or O. This is because the arc could be shortened without losing sushi otherwise. Thus, the partial test set can be solved with trying every possible choice of A and B. This results in an O(N3 ) time solution if implemented naively, and O(N2 ) if v1, v1+v2, ..., v1+v2+...+vN and vN , vN +vN−1, ..., vN +vN−1+...+v1 are precomputed. The full test set can be solved with just a little improvement from here. There is enough time to try every choice of A or B, and we will go with B here. When B is fixed as xb, A is one of x1, x2, ..., xb−1, and we should select xa corresponding to a that maximizes f(a) := v1 + v2 + ... + va − xa. (This is because, the calories taken in is equal to f(a) plus vN + vN−1 + ... + vb − (C − xb), which has a constant value independent of a when b is fixed). Thus, if we find f(0), f(1), ..., f(N) beforehand, and find g(a) := max(f(0), f(1), ..., f(a)) for each a = 0, 1, ..., N (starting from g(0)), we can immediately make the optimal choice of A when B is fixed, thus we have an O(N) time solution. 10 E: Everything on It We have no choice but to apply inclusion-exclusion principle (Wikipedia). Let A be the answer. From the symmetry of the toppings, the following holds:*5 A = ∑ N i=0 (−1)iC(N, i)ways(i) Here, C(n, i) is binomial coefficients, and ways(i) is the number of the sets of some ramen such that each of the toppings 1, 2, ..., i is on at most one of those ramen (we don’t care toppings i+ 1, i+ 2, ..., N). If we can find each ways(i) in O(N) time, we can obtain the full score. For each j = 0, 1, .., i, if we can find the number of those sets of ramen that satisfy the condition above such that there are exactly j ramen topped with one or more toppings among toppings 1, 2, ..., i (let this number be ways2(i, j)) in O(1) time, we can find ways(i) in O(N) by summing them up. This is indeed possible. The most important ”part” for counting these entities is, how the toppings 1, 2, ..., i are divided, that is, ”the number of ways to make j non-empty groups out of i distinguishable objects (an object can’t belong to multiple groups, but can belong to zero group)”. This is a very similar concept to Stirling numbers of the second kind (Wikipedia), and all the required values can be computed in O(N2 ) time beforehand by dynamic programming. Note that it does not really matter how many of the i toppings are actually used in some ramen (if we classify the sets according to this number, the solution would take O(N3 ) time). Figure: One example of a set of ramen counted in ways2(6, 3) where N = 10 (Each frame corresponds to a ramen) We then multiply this by 2(N−i)j and 22 N−i , consider the remaining toppings i + 1, i + 2, ..., N, and we can find ways2(i, j) in a constant time (other pre-computations are also required), which was our goal. *5 If you are not sure of this sentence and the following formula, please try observing the direct application of inclusionexclusion principle to the case N = 3 or 4. The meaning of the word “symmetry” here is “interchangable”. 11 F: Sweet Alchemy Let di = ci − cpi . As an exception, when i = 1 (the root of the tree), we define di = ci . Using this, the problem can be restated as follows: • For each i > 1, 0 ≤ di ≤ D must hold. d1 can be an arbitrary non-negative integer. • For each i, we do the following di times: for each node j in the subtree rooted at j, make one Doughnut j. • Under the conditions above, compute the maximum number of Doughnuts you can make. This can be further restated as a knapsack problem. Consider a node v, and let w1, · · · , wk be the nodes in the subtree rooted at v. Then, performing an operation for this subtree is equivalent to making Yv := k doughnuts using Xv := mw1 + · · · + mwk grams of Moto. Regard it as an item with weight Xv and value Yv. Now we want to solve the following problem: • There are N types of items. • The weight of an i-th type of item is Xi . Its value is Yi . • You want to choose some items such that the total weight is at most X. You can choose at most Zi items of type i. What is the maximum total value you can achieve? • Constraints: N ≤ 50, Yi ≤ 50. Other parameters can be very large. Intuitively, we should choose the most ”efficient” ones greedily. For simplicity, assume that the items are sorted in the decreasing order of efficiency: that is, Y1/X1 ≥ Y2/X2 ≥ · · · . Now, we formally state the intuition. Consider two types of items p, q (p < q). Assume that there are at least 50 unchosen items of type p and at least 50 chosen items of type q. Then, we can improve the value by taking Yq itmes of type p and discarding Yp items of type q. Thus, we can assume that there are no such pairs of p, q. This proves the following: We have two bags of items. For each i, we put min(50, Zi) items of type i to the first bag, and the remaining items of type i to the second bag. In the optimal solution, we should choose some subset of items from the first bag, and from the second bag we just choose items greedily (by efficiency). The remaining part is easy. The total value of all items in the first bag is at most N3 . For each 0 ≤ Y ≤ N3 , assume that the total value of all items you choose from the first bag is Y , and minimize their total weight (this can be done by a simple DP in O(N4 log N) time). Then, we choose more items from the second bag greedily (until we reach the weight capacity). This solution works in O(N4 log N) time. 12 AtCoder Beginner Contest 094 / AtCoder Regular Contest 095 解説 writer: semiexp, nuip 2018 年 4 月 14 日 For International Readers: English editorial starts on page ?. A: Cats and Dogs 猫の数は，B 匹すべてが犬のときに最小 (A 匹) になります．一方，B 匹すべてが猫のときに最大 (A + B 匹) になり ます． よって，X が A 以上 A + B 以下かどうか判定すればよいです． • C++ による解答例: https://abc094.contest.atcoder.jp/submissions/2343785 • Python による解答例: https://abc094.contest.atcoder.jp/submissions/2344330 1 B: Toll gates ゴールするまでに，元いたマスへ引き返すことをする必要はありません．すなわち，マス X からマス X −1, X −2, . . . , 0 と進むか，X + 1, X + 2, . . . , N と進むかのいずれかです．この 2 パターンそれぞれについて，通る料金所の個数を数え， 最小値を求めればよいです． • C++ による解答例: https://abc094.contest.atcoder.jp/submissions/2343740 • Python による解答例: https://abc094.contest.atcoder.jp/submissions/2344333 2 C: Many Medians 入力をソートしたものを Y1 ≤ Y2 ≤ · · · ≤ YN とします．このとき Bi を考えます．ソートした後に Ai が li 番目に現 れるとします（すなわち Yli = Ai が成り立ちます）．Bi は Y1, . . . , Yli−1, Yli+1, . . . , YN の中央値であることに注意しま す．すると，Y1 ≤ · · · ≤ Yli−1 ≤ Yli+1 ≤ · · · ≤ YN より，この N − 1 個の値のうち N 2 番目の値を求めればよいことが わかります．これは，li ≤ N 2 であれば YN/2+1，li ≥ N 2 + 1 であれば YN/2 になることが確かめられます． 3 D : Binomial Coefficients comb(n, r) を並べた表はパスカルの三角形 (https://ja.wikipedia.org/wiki/と呼ばれています。これを観察すると下に 行くほど（n が大きくなると）値が大きくなることが分かります。また、同じ段なら真ん中よりのほうが値が大きくなる ことが分かります。このことから、a1, a2, . . . , an のうち最大のものを n として使い、n 以外で n/2 に最も近いものを r として使うと最大になることが予想できます。 この予想が正しいことを示します。次の事実を使います。 comb(n, r) = n(n − 1)(n − 2). . .(n − r + 1) r(r − 1)(r − 2). . . 1 まず、最初の予想が正しいことを確かめるために次を示します。 主張. r > 0 のとき、comb(n + 1, r) > comb(n, r) 証明. r = 1 のときは明らか。r > 1 とする。 comb(n + 1, r) − comb(n, r) = (n + 1)n(n − 1). . .(n − r + 2) r(r − 1)(r − 2). . . 1 − n(n − 1)(n − 2). . .(n − r + 1) r(r − 1)(r − 2). . . 1 = n(n − 1). . .(n − r + 2) r(r − 1)(r − 2). . . 1 ((n + 1) − (n − r + 1)) = n(n − 1). . .(n − r + 2) r(r − 1)(r − 2). . . 1 r > 0 次に、二番目の予想が正しいことを示すのには、n 個から r 個選ぶのと n 個から選ばない n − r 個を決めるのが同じ であることを踏まえると、次を確かめれば十分です。 r + 1 ≤ n/2 のとき、comb(n, r + 1) > comb(n, r) これは comb(n,r+1) comb(n,r) を計算すれば分かります。 4 E: Symmetric Grid 行の入れ替えの操作と，列の入れ替えの操作は，交換可能であることに注意します．よって，最初に何回か行の入れ 替えの操作のみを行った後，何回か列の入れ替えの操作のみを行うとしてもかまいません． まず，行の入れ替えの方法を固定して，その後列の入れ替え操作のみでマス目を点対称的にできるかどうか判定する ことを考えます．j = 1, 2, . . . , W に対して，点対称的なマス目の j 列目は，W + 1 − j 列目を上下反転したものになっ ていることに注意します．特に，W が奇数のとき，(W + 1)/2 列目は上下対称になります．逆に，この条件が成り立て ば，マス目は点対称的になります． よって，これは次の方法で判定することができます．(実際の実装では，具体的に点対称的にする方法を構成する必要 はありません） • はじめ，すべての列を未使用としておく．盤面も，すべての列を取り出して，空にしておく． • 未使用の列がある場合，それを上下反転したような未使用の他の列が存在するか判定する． – もし存在すれば，その 2 つの列を使用済みにし，まだ埋まっていない最も左，最も右の列にそれぞれ配置する． – 存在しない場合，もし W が偶数ならば，点対称的にすることは不可能である．W が奇数ならば，その列が 上下対称か判定し，対称ならばその列を (W + 1)/2 列目に置く．すでに (W + 1)/2 列目が埋まっているか， 対称でないならば，点対称的にすることは不可能である． このアルゴリズムは O(HW2 ) で動作します．（列をソートするなどの方法で，O(HW log W) にすることもできます） 次に，行の入れ替えの方法を考えます．単純に考えると，行の入れ替えの方法は H! 通りあり，大きすぎます．ここで， 1, H 行目，2, H −1 行目，. . . のように行同士をペアにして考えると (H が奇数の場合，ペアにならない行が 1 行だけ存在 します），ペア関係が同一な入れ替え方法では，点対称的にできるかどうかは全く同じになることがわかります．なので，行 同士をペアにする異なる方法をすべて試し，それぞれの方法に対しては適当に行の入れ替えをしてから，先の列の入れ替え による判定を行うことで，この問題を解くことができます．ペアにする方法は，最大で 11!! = 11×9×7×5×3×1 = 10395 通りしかないので，十分この問題を解くことができます． 5 F : Permutation Tree 高橋くんの能力は言い換えると次のようになります。 max を −1 として、pi の小さい順に次の処理をする。 • pi ̸= 1 のとき、max と i を辺でつなぐ • i > max であれば、 max を i で書き換える つまり、今までに出てきた添字のうちの最大のところに辺を貼っていく操作になります。添字の最大が更新された頂点だ けに注目すると、これらの頂点は pi の小さい順に頂点を並べたパスをなしていることが分かります。一方で、最大が更新 されていない頂点は、このパスに含まれる頂点と直接つながることが分かります。このようなグラフは caterpillar(https: //en.wikipedia.org/wiki/Caterpillar_tree) と呼ばれています。先程言及したパスのことを今後胴体と呼び、胴体 に含まれていない頂点のことを脚と呼ぶことにします。 以上で、高橋くんの能力で作れるグラフは必ず caterpillar であることが分かりました。実は caterpillar であれば必ず その木を作れるような順列が存在します。 caterpillar 判定 与えられた木が caterpillar であるかどうかを判定する方法は次のとおりです。まず、木の直径を求めます (http:// www.prefield.com/algorithm/graph/tree_diameter.html)。与えられた木が caterpillar である場合、この木の直径 を胴体とみなすことができます。これは脚の長さが 1 であることから明らかです。胴体が求まったので、あとは残りの 頂点が直接胴体に繋がれているか判定するだけです。 順列の生成 次に、与えられた caterpillar を作る順列の作り方を考えます。胴体が左右に並んでいて、左から右に添字も値も増加 しているとします。胴体の頂点の添字を左から b1, . . . , bl とします。 胴体のうちのある頂点 bi に注目します。この頂点から脚が ki 本生えているとき、その ki 個の頂点は頂点 bi よりも値 が大きくて、添字が小さい必要があります。この条件の元で辞書順で小さくなるよう気をつけると、次のようにしてで きる順列が答えの候補になります。 (1, 2, . . . , n) という順列から始める。 各 i = 1, 2, . . . , l について、左から ∑i−1 j=0(ki + 1) 番目の数を ki こ分右にずらす。 caterpillar のとり方と答え 与えられた木を caterpillar とみなす時、胴体にあたるパスの取り方は複数通りありえます。上記の caterpillar の構築 方法をふまえると、胴体はできるだけ長くなるように取った方がいいことが分かります。胴体の向きが 2 通りあります が、これは両方試して辞書順で小さい順列が得られたほうを答えとすれば良いです。 6 AtCoder Beginner Contest 094 / AtCoder Regular Contest 095 Editorial writer: semiexp, nuip April 14th, 2018 A: Cats and Dogs • C++ example: https://abc094.contest.atcoder.jp/submissions/2343785 • Python example: https://abc094.contest.atcoder.jp/submissions/2344330 B: Toll gates • C++ example: https://abc094.contest.atcoder.jp/submissions/2343740 • Python example: https://abc094.contest.atcoder.jp/submissions/2344333 C: Many Medians Let Y1 ≤ Y2 ≤ · · · ≤ YN be the sorted list of X. Suppose that Yli = Ai . Bi is the median of Y1, . . . , Yli−1, Yli+1, . . . , YN . Thus, Bi is the N 2 -th value of Y1, . . . , Yli−1, Yli+1, . . . , YN . This is YN/2+1 if li ≤ N 2 , and YN/2 if li ≥ N 2 + 1. D : Binomial Coefficients We shuold choose the maximum of a1, a2, . . . , an as n because for a fixed r, the function comb(n, r) is monotonously increasing. This follows from the following fact: If r > 0, comb(n + 1, r) > comb(n, r) (because comb(n + 1, r) = comb(n, r) + comb(n, r − 1)) Once we choose n, we should choose r that is closest to n/2. This follows from the following fact: If r + 1 ≤ n/2, comb(n, r + 1) > comb(n, r) Compute comb(n,r+1) comb(n,r) to prove this. 1 E: Symmetric Grid Notice that an operation about rows and an operation about columns are commutative. Thus, assume that we first perform operations about rows, and then operations about columns. Suppose that we finished operations about rows. How can we check if we can achieve a goal by operations about columns? Notice that, for each j = 1, 2, . . . , W, the j-th column must be the reverse of the W + 1 − j-th column. In particular, when W is odd, (W + 1)/2 is a palindrome. Therefore, we can use the following method do check if we can achieve a goal by operations about columns: • Initially, all rows are ”unused”. • Choose a particular unused row. Reverse it, and check if it matches with another unused row. – If it matches with another row, mark the two rows as ”used”. – Otherwise, if W is even, the answer is ”NO”. If W is odd and the current row is not a palindrome, the answer is ”NO”. If W is odd and the current row is a palindrome, we should put it in the (W + 1)/2-th row. If this row is already filled, the answer is ”NO”. It works in O(HW2 ) time (or by binary search you can do it in O(HW log W)） If we consider all H! possible orders of rows, it will be too slow. Instead, notice that only the set of pairs ((1, H)-th rows, (2, H − 1)-th rows, . . .) matters. (In case H is odd, one row is left unpaired.) Thus, we only need to try all pairings of rows. Since there are at most 11!! = 11 × 9 × 7 × 5 × 3 × 1 = 10395 ways of pairings, it’s fast enough. 2 F : Permutation Tree We can restate the generation of a tree as follows: Let max = −1. Initially, all vertices are painted black. Perform the following operation in the increasing order of pi (that is, first we choose an i such that pi = 1 and perform the operation, and so on): • If pi ̸= 1, add an edge between vertex max and vertex i. • If i > max, replace max with i, and color vertex i red. It’s clear that when you add an edge, it is always between vertex i (the current vertex) and the most recently painted red vertex. Also, when we paint a vertex, it is always the current vertex. Thus, • The red vertices will form a path. • A black vertex is a leaf, and it’s incident to a red vertex. Such graphs are called caterpillar(https://en.wikipedia.org/wiki/Caterpillar_tree). From now on, we call red vertices ”body”, and black vertices ”feet”. Also, we call one end of the body ”head”, and the other end ”tail”. The head corresponds to the vertex with pi = 1. Therefore, if the given tree is not a caterpillar, we should print ”-1”. Otherwise, it turns out that the solution always exists, as we describe later. Check if the given tree is a caterpillar Find the diameter of the tree. The tree is a caterpillar if and only if it forms the body (i.e., all vertices are either in the diameter or adjacent to one vertex in the diameter). Find the lexicographically smallest permutation that generates a given caterpillar Let’s fix a caterpillar. How can we find a permutation that generates this caterpillar? Let b1, . . . , bl be the vertices in the body in the order from head to tail. Let ki be the number of feet that grow from bi . For example, in the picture above, {ki} = {0, 0, 2, 0}. For each foot, the index of its parent must be greater than its index. The value of its parent must be less than its value. The lexicographically smallest permutation that satisfies these conditions is the following permutation: Consider a permutation (1, 2, . . . , n). For each i = 1, 2, . . . , l in this order, do the following: move the ∑i−1 j=0(ki + 1)-th (from left, 1-indexed) element to the right by ki positions. For example, we get 1, 2, 4, 5, 3, 6 for the example above. It’s easy to see that this permutation generates a desired caterpillar. 3 How to choose a head and a tail of a caterpillar There are multiple ways to choose a head and a tail of a caterpillar. From the construction above, it’s clear that we shuold maximize the length of the body, so we should choose a diameter and the head and the tail should be two ends of the diameter. There are two ways to orient the body: we should try both ways. 4 ARC 094/ABC 093 解説 DEGwer 2018/04/07 A: abc of ABC 3 つの文字がどの 2 つも相異なるかどうかを調べればよいです。 #i n cl u d e <s t d i o . h> i n t main ( ) { ch a r s [ 1 0 ] ; s c a n f (”% s ” , s ) ; i f ( s [ 0 ] != s [ 1 ] && s [ 1 ] != s [ 2 ] && s [ 2 ] != s [ 0 ] ) p r i n t f ( ” Yes \n ” ) ; e l s e p r i n t f ( ”No\n ” ) ; } 1 B: Small and Large Integers 出力すべき範囲を適切に記述し、その範囲の整数をすべて出力すればよいです。A 以上 B 以下の整数が 2K 個未満の場合に注意しましょう。 #i n cl u d e <s t d i o . h> #i n cl u d e <v e c t o r> #i n cl u d e <al g o ri thm> u si n g namespace s t d ; i n t main ( ) { i n t a , b , k ; s c a n f (”%d%d%d ” , &a , &b , &k ) ; f o r ( i n t i = a ; i <= min ( b , a + k − 1 ) ; i++) p r i n t f (”%d\n ” , i ) ; f o r ( i n t i = max( b − k + 1 , a + k ) ; i <= b ; i++) p r i n t f (”%d\n ” , i ) ; } C: Same Integers 3 つの整数の和の偶奇は操作によって不変です。また、整数を減少させることはできないので、3 つの整数 が等しくなったならば、その時の値は 3 つの整数の最大値 (以下これを M とする) 以上です。よって、もし 3M と最初の 3 つの整数の和の偶奇が等しいなら、3 つの整数が等しくなった時の値は M 以上、そうでなけ れば M + 1 以上です。 逆に、この下限が達成できることは簡単にわかるので、この問題を解くことができました。 D: Wide Flip 1 回目のコンテストで A 位、2 回目のコンテストで B 位を取ることを (A, B) を取ると呼ぶことにします。 高橋君が (A, B) を取ったとします。A ≤ B として一般性を失いません。 A = B の場合、高橋君よりスコアが小さい人は 1 回目のコンテストまたは 2 回目のコンテストで A − 1 位 以内の順位を取っています。よって、そのような人の人数は 2A−2 人以下です。逆に、(1, 2A−1), · · · ,(A− 1, A + 1),(A + 1, A − 1), · · · ,(2A − 1, 1) を取った人が存在する場合、その上限値を達成できます。 A+ 1 = B の場合、高橋君よりスコアが小さい人は 1 回目のコンテストで A− 1 位以内を取るか、2 回目の コンテストで A 位以内を取っています。また、2 回目のコンテスト A 位を取った人のスコアが高橋君より小 さくなるためには、その人は 1 回目のコンテストで A − 1 位以内を取る必要があります。よって、高橋君より スコアが小さい人の人数は 2A−2 人以下です。逆に、(1, 2A), · · · ,(A−1, A+ 2),(A+ 2, A−1), · · · ,(2A, 1) を取った人が存在する場合、その上限値を達成できます。 そうでない場合、C 2 < AB を満たす最大の整数 C を取ります。 C(C + 1) ≥ AB のとき、高橋君よりスコアが小さい人は 1 回目のコンテストまたは 2 回目のコンテスト 2 で C 位以内の順位を取っています。1 回目のコンテストで C 位を取った人のスコアが高橋君のスコアより小 さくなるためには、その人は 2 回目のコンテストで C 位以内を取らなければなりません。よって、高橋君よ りスコアが小さい人の人数は 2C − 2 人以下です。逆に、(1, A + B − 1), · · · ,(A − 1, B + 1),(A + 1, 2C − A − 1), · · · ,(C, C), · · · ,(2C − 1, 1) を取った人が存在する場合、その上限値を達成できます。 C 2 < AB のとき、高橋君よりスコアが小さい人は 1 回目のコンテストまたは 2 回目のコンテストで C 位以内の順位を取っています。よって、高橋君よりスコアが小さい人の人数は 2C − 1 人以下です。逆に、 (1, A + B − 1), · · · ,(A − 1, B + 1),(A + 1, 2C − A), · · · ,(C, C + 1),(C + 1, C), · · · ,(2C, 1) を取った人が 存在する場合、その上限値を達成できます。 以上の場合で尽くされるので、この問題を解くことができました。 E: Tozan and Gezan とざん君を先手、げざん君を後手と呼ぶことにしましょう。もし数列 A, B が最初から等しいなら、答えは 0 です。そうでない場合、答えは以下の値になることを証明します。 • 数列 A の総和から、Ai > Bi を満たす Bi の中で最小のものを引いた値 一般性を失わずに、Ai > Bi を満たす i の中で Bi を最小にするものが 1 であるとして良いです。まず、先 手が操作回数をこの値以上にできることを示します。 先手は以下の戦略にのっとって操作を進めればよいです: A の 1 番目以外の整数をすべて 0 になるまで減 らし、そのあと Ai を減らしていく この操作で上記の値以上の回数の操作が必要になるのは明らかです。 さて、後手が操作回数をこの値以下にできることを示しましょう。後手は以下の戦略にのっとって操作を進 めればよいです: Bi > Ai なる i をひとつ選び、Bi を減らす 後手がこの戦略にのっとって行動したとき、ある Ai > Bi なる i が存在し、操作の終了時にも Bi の値が 変わっていないことを証明できればよいです。Ai > Bi である間、後手が Bi を減少させることはないので、 Ai > Bi であるような i がなくなる直前に先手が操作を行った i について、Bi の値が減らされていることは ありません。これが操作の終了まで変化しない Bi の例となっているので、操作回数の上界と下界が一致し、 この問題を解くことができました。 F: Normalization もし S のすべての文字が等しいなら、答えは 1 です。以下、そうでない場合を考えます。 文字 A,B,C を順に整数 0, 1, 2 に対応させることにすると、操作によって文字列全体の対応する値の和を 3 で割ったあまりは変化しません。すなわち、文字列全体の対応する値の和を 3 で割ったあまりが S と等しい 文字列のみ作ることができます。また、S に 1 回以上の操作を行って作ることのできる文字列には、必ず同 じ文字が連続する箇所があります。 さて、作ることのできる可能性のある文字列は上記の条件を満たすものと S 自身に限られました。逆に、 これらの文字列をすべて作ることはできるでしょうか？ 実は、|S| ≥ 4 ならこれらの文字列をすべて作ることができることが証明できます。|S| = 4 の場合は全通 り試せば示すことができ、|S| が 5 以上の場合は先頭の文字を適切に変化させることによって |S| が 1 小さい 3 場合に帰着できます。 よって、この問題は以下のようにして解くことができます。 • S のすべての文字が等しいなら、1 を出力 • |S| ≤ 3 なら、全探索を行う • そうでないなら、 上記の条件を満たす文字列の個数を求め、S がその条件を満たさないならさらに 1 を足した値を答えとする 上記の条件を満たす文字列の個数は簡単な線形時間の DP で求めることができるので、この問題を線形時 間で解くことができました。 4 ARC 094/ABC 093 Editorial DEGwer 2018/04/07 A: abc of ABC Check if the characters in s are pairwise distinct. #i n cl u d e <s t d i o . h> i n t main ( ) { ch a r s [ 1 0 ] ; s c a n f (”% s ” , s ) ; i f ( s [ 0 ] != s [ 1 ] && s [ 1 ] != s [ 2 ] && s [ 2 ] != s [ 0 ] ) p r i n t f ( ” Yes \n ” ) ; e l s e p r i n t f ( ”No\n ” ) ; } 1 B: Small and Large Integers The integers you should print will be two intervals. Make sure to handle cases such that the number of integers between A and B is less than 2K. #i n cl u d e <s t d i o . h> #i n cl u d e <v e c t o r> #i n cl u d e <al g o ri thm> u si n g namespace s t d ; i n t main ( ) { i n t a , b , k ; s c a n f (”%d%d%d ” , &a , &b , &k ) ; f o r ( i n t i = a ; i <= min ( b , a + k − 1 ) ; i++) p r i n t f (”%d\n ” , i ) ; f o r ( i n t i = max( b − k + 1 , a + k ) ; i <= b ; i++) p r i n t f (”%d\n ” , i ) ; } 2 C: Same Integers Suppose that when you finish the operations, all integers are X. Since the sum of three integers always increases by two in each operation, the total number of operations is (3X − (A + B + C))/2. Thus, we want to minimize X. Let M be the maximum of A, B, C. Since we can never decrease integers, X ≥ M must hold. Also, since we can never change the parity of sum of three integers, 3X ≡ A+B +C (mod 2) must hold. (It’s easy to see that these are sufficient conditions). Therefore, • If 3M ≡ A + B + C (mod 2), X = M. • Otherwise, X = M + 1. and we should print (3X − (A + B + C))/2. 3 D: Worst Case Let us denote a participant who was ranked x-th in the first contest and y-th in the second contest as (x, y). Takahashi is (A, B). Without loss of generality, assume that A ≤ B. One possible way to solve the problem is to consider the following cases: • If A = B, the answer is at most 2A − 2 because you must get top A − 1 places in at least one contest to beat Takahashi. We can achieve this value by (1, 2A−1), · · · ,(A−1, A+ 1),(A+ 1, A− 1), · · · ,(2A − 1, 1). Thus, the answer is 2A − 2. • If A + 1 = B, the answer is at most 2A − 2 because you must get top A − 1 places in at least one contest to beat Takahashi. (Note that the A-th place in the first contest is filled by Takahashi, and getting the A + 1-th in the first and A-th in the second is not enough.) We can achieve this value by (1, 2A), · · · ,(A − 1, A + 2),(A + 2, A − 1), · · · ,(2A, 1). Thus, the answer is 2A − 2. • Otherwise, let C be the maximum integer such that C 2 < AB. – If C(C + 1) ≥ AB, the answer is at most 2C − 2 because you must get top C − 1 places in the first contest or top C places in the second contest to beat Takahashi. (Note that one of ”the top C − 1 places in the first contest” is Takahashi, we shouldn’t count him.) We can achieve this value by (1, A+B −1), · · · ,(A−1, B + 1),(A+ 1, 2C −A−1), · · · ,(C, C), · · · ,(2C −1, 1). Thus, the answer is 2C − 2. – If C(C + 1) < AB, the answer is at most 2C −1 because you must get top C places in the first contest or top C places in the second contest to beat Takahashi. (Note that one of ”the top C places in the first contest” is Takahashi, we shouldn’t count him.) We can achieve this value by (1, A + B − 1), · · · ,(A − 1, B + 1),(A + 1, 2C − A), · · · ,(C, C + 1),(C + 1, C), · · · ,(2C, 1). Thus, the answer is 2C − 1. Another possible solution is binary search on the answer: for a fixed X, we want to know the following: • Consider the smallest X positive integers except for A. • Consider the smallest X positive integers except for B, and reverse the order. • Check if for all i, the product of the i-th integer in the first list and the i-th integer in the second list is smaller than AB. To do this, use the fact that the lists are ”piecewise” arithmetic sequences (and the number of pieces is constant). 4 E: Tozan and Gezan If A, B are the same, the answer is 0. We assume that A ̸= B. What is a good strategy for the second player? If Ai < Bi for some i, the second player needs to decrease Bi , regardless of the moves of the first player. He can do this without giving any valuable information for the first player. Thus, the second player should always choose one of such i (it always exists because the sums are the same), and decrease Bi by one. What is a good strategy for the first player? Intuitively, when Ai = Bi + 1, it’s not a good idea to decrease Ai by one. Let’s make sure not to do this unless the first player is forced to do so. If both players follow the rules mentioned above, when the game finishes, for all i but one (let’s say i ̸= k), Ai = Bi = 0 holds. Bk is unchanged from the beginning. The first player wants to minimize Bk because the number of steps is (the sum of all elements) minus Bk. Here, Ak > Bk must hold, but among such k’s the first player can choose anything (by properly choosing what to do when he is forced to perform an operation for Ai = Bi + 1). It turns out that the answer is the following: • X := (The sum of all elements in A) minus (The minimum Bi such that Ai > Bi) Here is a formal proof: Without loss of generality, assume that the minimum Bi such that Ai > Bi is B1. First, we prove that the first player can make sure that the number of steps become at least X. He follows the following strategy: first, decrease A2, . . . , AN to 0, and then decrease A1. It’s clear that by this strategy, the steps will be at least X. Then, we prove that the second player can make sure that the number of steps become at most X. The second player follows the strategy mentioned above. Consider the last moment when Ai > Bi holds for some i. Then, the first player decreases this Ai , and in the next step the game finishes. For this i, Bi is unchanged during the entire game. Thus, the number of steps will be at most X. 5 F: Normalization When can we convert a string S into a string T? We can make the following observations: • Let’s assume the letters A, B, C as integers 0, 1, 2. By performing the operations, the sum of all integers in the string never changes in modulo 3. Thus, if the sum of all integers in S and the sum of all integers in T are different (in modulo 3), the answer is ”no”. • If all letters in S are the same, we can perform any operations. The answer is ”no” unless S = T. • If no two adjacent letters in T are the same, T can’t be a result of an operation. Thus, the answer is ”no” unless S = T. Do we find all ”no” cases? It’s very difficult to answer this question on paper, so let’s write a brute force solution. What we get is the following: • If |S| ≤ 3, the behavior is mysterious. From now on, assume that |S| ≥ 4. • If S = T, ”yes”. From now on, assume that S ̸= T. • If at least one of the three conditions above (the sum of S and T are different in modulo 3, all letters in S are the same, or no two adjacent letters in T are the same), ”no”. Otherwise, ”yes”. (We can prove this by induction on |S|: |S| = 4 can be verified by brute force, otherwise we can change the first letter properly and decrease |S| by one.) Thus, we can solve the original problem as follows: • If all letters in S are the same, print 1. • If |S| ≤ 3, compute the answer by brute force. • Otherwise, count the number of strings T such that – |T| = |S| – sum(S) = sum(T) (mod 3) – There is at least one pair of adjacent same letters in T. (This can be done by a simple DP). Make sure not to forget to add one to the answer in case no two adjacent letters in T are the same. 6 ARC093 / ABC092 解説 wo01 2018 年 3 月 25 日 A 問題 答えは min(A, B) + min(C, D) となります。 以下に C++ による実装例を示します。 #include<cstdio> #include<algorithm> using namespace std; int main(){ int A, B, C, D; scanf("%d%d%d%d", &A, &B, &C, &D); printf("%d\n", min(A, B) + min(C, D)); return 0; } B 問題 i 人目の参加者は合宿中にチョコレートを 1 + ⌊(D − 1)/Ai⌋ 個食べます。ここで、⌊x⌋ は x を超えない最 大の整数です。 よって、答えは X + ∑ 1≤i≤N (1 + ⌊ D − 1 Ai ⌋ ) となります。 以下に C++ による実装例を示します。C++ を含む多くの言語で、正の整数同士の除算の際はあまりが切 り捨てられます。 1 #include<cstdio> using namespace std; const int MAX_N = 100; int N; int A[MAX_N]; int D; int X; int main(){ scanf("%d", &N); scanf("%d%d", &D, &X); for(int i = 0; i < N; ++i){ scanf("%d", A + i); } int ans = X; for(int i = 0; i < N; ++i){ int tmp = (D - 1) / A[i] + 1; ans += tmp; } printf("%d\n", ans); return 0; } C 問題 入力で与えられる A1, A2, . . . , AN に加えて、A0 = AN+1 = 0 としておきます。求めたいものは、各 i (1 ≤ i ≤ N) に対する Si = |A0 − A1| + |A1 − A2| + · · · + |Ai−2 − Ai−1| + |Ai−1 − Ai+1| + |Ai+1 − Ai+2| + · · · + |AN − AN+1| の値です。 ここで、 S = ∑ 0≤j≤N |Aj − Aj+1| とします。この値は O(N) 時間で求められます。 このとき、 Si = S + |Ai−1 − Ai+1| − (|Ai−1 − Ai | + |Ai − Ai+1|) 2 となります。よって、Si の値は各 i に対して O(1) 時間で求められます。 以上から、全体で O(N) 時間で解くことができます。 D 問題 条件を満たすグリッドは以下のようにして構成することができます。 • K = 50 として、2K × 2K のグリッドを用意する。 • 上から K 行以内にあるマスを全て黒く塗り、残りのマスをすべて白く塗る。 • 上から K − 1 行以内のマスのうち A − 1 個のマスを上下左右斜めに隣り合わないように選び、それら の色を白に変える。 • 下から K − 1 行以内のマスのうち B − 1 個のマスを上下左右斜めに隣り合わないように選び、それら の色を黒に変える。 E 問題 与えられたグラフを G とし、 G の最小全域木 T を一つ選びます。また、その重みを S とします。 T の 2 頂点 u, v に対して、pathMax (u, v) を T の uv パス上の辺の重みの最大値と定義します。さらに、 G に含まれるが T に含まれない辺 e = {u, v} が重み c を持つとき、diff (e) = c − pathMax (u, v) と定義し ます。T が最小全域木であることから、すべての e に対して diff (e) ≥ 0 となります。 さて、G の辺を白色または黒色に塗ったとき、白く塗られた辺と黒く塗られた辺をともに含む全域木のうち 最小の重みのものの重み S ′ は以下のようになります。 • T に白色の辺と黒色の辺がともに含まれる場合、S ′ = S • そうでない場合、T の辺と異なる色で塗られた辺のうち最小の diff の値を持つものを e として、 S ′ = S + diff (e) このことから、求めたい塗り方の個数は以下のようにして求められます。 まず、D = X − S とします。さらに、diff (e) < D, diff (e) = D, diff (e) > D を満たす e の個数をそれぞ れ lower , equal, upper とします。このとき、 • D < 0 のとき、塗り方の個数は 0 • D = 0 のとき、 – T の辺に 2 種類の色を両方用いる場合、塗り方の個数は (2N−1 − 2)2M−N+1 – そうでない場合、塗り方の個数は 2 × (2equal − 1) × 2 upper • D > 0 のとき、塗り方の個数は 2 × (2equal − 1) × 2 upper 以上で答えが求まりました。 F 問題 条件を満たす p のうち p1 = 1 であるものの個数がわかれば十分です。以下、p1 = 1 を仮定します。 3 選手 1 が優勝または敗退するまでに対戦する可能性がある選手の番号は p2, min{p3, p4}, . . . , min{p2N−1+1, . . . , p2N } です。上の N 個の値がどれも集合 {A1, A2, . . . , AM} に含まれないとき、選手 1 が優勝します。 選手 2, 3, . . . , 2 N を番号順に場所 p2, p3, . . . , p2N に割り当てていくことを考えます。また、これらの場所 は N 個のグループ G1 = {p2}, G2 = {p3, p4}, . . . , GN = {p2N−1+1, . . . , p2N } に分かれているとします。グ ループ Gi が開始済みグループであるとは、グループ Gi に属する選手が 1 人以上決まっていることを言うこ とにします。また、{1, 2, . . . , N} の部分集合 U に対して、 sz(U) = ∑ i∈U 2 i−1 と定めます。 次のような DP を考えます。 dp1,i,U = 選手 2, 3, . . . , Ai の場所を決める方法であって、 開始済みグループの集合 T が T = U を満たすものの個数 dp2,i,U = 選手 2, 3, . . . , Ai の場所を決める方法であって、 開始済みグループの集合 T が T ⊆ U を満たすものの個数 dp3,i,U = 選手 2, 3, . . . , Ai − 1 の場所を決める方法であって、 開始済みグループの集合 T が T ⊆ U を満たすものの個数 dp4,i,U = 選手 2, 3, . . . , Ai − 1 の場所を決める方法であって、 開始済みグループの集合 T が T = U を満たすものの個数 この DP テーブルは以下のように計算することができます。 • 各 U に対して dp1,i,U が求まっているとき、各 U に対する dp2,i,U は高速ゼータ変換 (の変形) によ り求められます。 • 各 U に対して dp2,i,U が求まっているとき、各 U に対する dp3,i+1,U は、t = max(0,sz(U) − Ai), d = Ai+1 − 1 − Ai として、 dp3,i+1,U = t × (t − 1) × · · · × (t − d + 1) × dp1,i,U として求められます。 • 各 U に対して dp3,i,U が求まっているとき、各 U に対する dp4,i,U は高速ゼータ変換 (の変形) によ り求められます。 • 各 U に対して dp4,i,U が求まっているとき、各 U に対する dp1,i,U は dp1,i+1,U = (sz(U) − (Ai − 1)) × dp4,i,U として求められます。 この DP テーブルが求められれば、あとは適切に足し合わせて適切な係数をかけるだけで答えが求められ ます。 以上で答えが求まりました。 4 ARC093 / ABC092 Editorial wo01 March 25th, 2018 Problem A The answer is min(A, B) + min(C, D). C++ example: #include<cstdio> #include<algorithm> using namespace std; int main(){ int A, B, C, D; scanf("%d%d%d%d", &A, &B, &C, &D); printf("%d\n", min(A, B) + min(C, D)); return 0; } Problem B The i-th participant eats 1+⌊(D−1)/Ai⌋ chocolates. Here ⌊x⌋ denotes the largest integer that doesn’t exceed x. Therefore, the answer is X + ∑ 1≤i≤N (1 + ⌊ D − 1 Ai ⌋ ) C++ example: 1 #include<cstdio> using namespace std; const int MAX_N = 100; int N; int A[MAX_N]; int D; int X; int main(){ scanf("%d", &N); scanf("%d%d", &D, &X); for(int i = 0; i < N; ++i){ scanf("%d", A + i); } int ans = X; for(int i = 0; i < N; ++i){ int tmp = (D - 1) / A[i] + 1; ans += tmp; } printf("%d\n", ans); return 0; } 2 Problem C Let A0 = AN+1 = 0. For each i (1 ≤ i ≤ N), we want to compute the following value: Si = |A0 − A1| + |A1 − A2| + · · · + |Ai−2 − Ai−1| + |Ai−1 − Ai+1| + |Ai+1 − Ai+2| + · · · + |AN − AN+1| Let S = ∑ 0≤j≤N |Aj − Aj+1| and we pre-compute this value in O(N) time. Then, since Si = S + |Ai−1 − Ai+1| − (|Ai−1 − Ai | + |Ai − Ai+1|) we can compute the value of Si in O(1) for each i. This solution works in O(N) time in total. Problem D We can construct the grid as follows: • Let K = 50 and prepare a grid of dimensions 2K × 2K. • Paint all cells in the topmost K rows black. Paint the other cells white. • From the topmost K −1 rows, choose A−1 cells such that no two chosen cells are 8-adjacent, and paint them white. • From the bottommost K − 1 rows, choose B − 1 cells such that no two chosen cells are 8-adjacent, and paint them black. 3 Problem E Let G be the given graph, and let T be (one of) its MSTs. Let S be its weight. For two vertices u, v in T, define pathMax (u, v) as the weight of the heaviest edge on the path uv along T. Also, if an edge e = {u, v} is not contained in T, define diff (e) = c − pathMax (u, v), where c is the weight of edge e. Note that for edges e in T, the value of diff (e) is undefined (make sure not to regard them as zeroes). Since T is an MST, for all edge e outside T, diff (e) ≥ 0 holds. Suppose that we paint the edges of G black and white. The weight of the MST that contains both black and white edges can be computed as follows (let’s denote it S ′ ): • If T contains both black and white edges, S ′ = S. • If T contains only black edges, S ′ = S + diff (e). Here, e is a white edge that minimizes the value of diff (e). • (Similarly, we can handle the case where all edges in T are white). Therefore, the answer can be computed as follows. First, let D = X − S. Let lower , equal, upper be the number of edges e such that diff (e) < D, diff (e) = D, and diff (e) > D, respectively. Then, • If D < 0, the answer is 0. • If D = 0, – In case we use both colors at least once for the edges in T, there are (2N−1 − 2)2M−N+1 ways to paint edges: (2N−1 − 2) ways to color T by using both colors, and 2M−N+1 ways to arbitrarily color other edges. – Otherwise, there are 2 × (2equal − 1) × 2 upper ways to paint edges: two ways to color edges in T, (2equal − 1) ways to color edges in ”equal” (the color of at least one edge must be different from T’s color), and 2upper ways to arbitrarily color ”upper” edges. • If D > 0, the answer is 2 × (2equal − 1) × 2 upper : two ways to color edges in T and ”lower”, (2equal − 1) ways to color edges in ”equal” (the color of at least one edge must be different from T’s color), and 2upper ways to arbitrarily color ”upper” edges. 4 Problem F Assume that p1 = 1 (and later multiply the answer by 2N ). Player 1 can win the tournament if he can beat all of the following players: p2, min{p3, p4}, . . . , min{p2N−1+1, . . . , p2N } Thus, we want to compute the number of permutations such that none of the N numbers above are contained in the set {A1, A2, . . . , AM}. Consider N groups of positions: G1 = {p2}, G2 = {p3, p4}, . . . , GN = {p2N−1+1, . . . , p2N }. We want to count the number of permutations such that for each group g in {G1, . . . , GN }, the minimum element in g is not in {A1, A2, . . . , AM}. Let’s use inclusion-exclusion principle. For each subset S of {G1, . . . , GN }, we want to compute f(S), the number of permutations such that • For each group g in S, the minimum element of g is in {A1, A2, . . . , AM}. To compute these values, do the following DP. Assume that A1 > A2 > · · · > AM. For each i = 1, · · · , M in this order, do one of the following: • For some integer k, choose 2k − 1 players greater than Ai , and assign them to the group Gk, together with the player Ai . Now the minimum element in Gk is in {A1, A2, . . . , AM}. • Do nothing. For each integer 0 ≤ i ≤ M and a set S ⊆ {G1, . . . , GN }, define dpi,S as the number of ways such that when we process players A1, · · · , Ai as described above, the groups in S are filled, and other groups are empty. Then, we can compute f(S) as dpM,S times some coefficients, and by inclusion-exclusion principle, the answer is ∑f(S)(−1)|S| . 5 ARC 091/ABC 090 解説 Kohei Morita(yosupo) 平成 30 年 3 月 19 日 For International Readers: English editorial starts on page 7. A: Two Coins A, B, C を入力し，A + B ≥ C を判定すれば良いです。 [https://beta.atcoder.jp/contests/abc091/submissions/2218039] 1 B: Two Colors Card Game どのカードにも書かれていない，めちゃくちゃな文字列を言えば 0 点を取 ることが出来ます。そして，1 点以上を取るためには，少なくとも青いカー ドのうちどれかに書かれた文字列を言う必要があります。 よって，青いカードに書かれた文字列それぞれについて，その文字列を言っ たら何点貰えるかを計算し，その最大値を計算すれば良いです。 [https://beta.atcoder.jp/contests/abc091/submissions/2218376] 2 C: 2D Plane 2N Points 青い点のうち，最も x 座標が小さいもの (bA とします) に注目します。こ の点と仲良しペアになれる点が存在した場合，そのような点のうち最も y 座 標が大きいもの (rA とします) と仲良しペアにしてよいです。 証明ですが，bA がどの点ともペアにならなかった場合と，rA 以外とペア になった場合それぞれについて，bA と rA をペアにしても同じ個数，もしく はそれ以上の個数の仲良しペアが作れることを示します。 bA がどの点ともペアにならなかった場合 rA がどの点ともペアになってい なかったら，bA と rA をペアにすれば良いです。rA が他の青い点 (bB とし ます) とペアになっていたら，そのペアを解消し，bA と rA をペアにすれば 良いです。 bA が rA 以外とペアになった場合 (bA とペアになっている点を rB としま す) rA がどの点ともペアになっていなかったら，bA の仲良しペアを解消 し，bA と rA をペアにすれば良いです。 rA が他の青い点 (bB とします) とペアになっていた場合，つまり bA-rB, rA-bB というペアが出来ていた場合を考えます。この場合は，ペアの相手を 交換し，必ず bA-rA, rB-bB というペアに出来ます。これは，以下の 2 つか ら示せます。 • bA が青い点のなかで一番 x 座標が小さいので，bB の x 座標は必ず bA より大きい，つまり rB よりも大きいです。 • rB は (bA とマッチング出来ていたので，) 必ず rA より y 座標が小さい です。また，bB は (rA とマッチング出来ていたので，) 必ず rA より y 座標が大きいです。よって，bB の y 座標は，必ず rB より大きいです。 以上より，bA はかならず rA とペアにしていいことが示せます。 この性質より，青い点を x 座標の小さい順に見ていき， • 青い点より x, y 座標が小さく，まだ仲良しペアになっていない赤い点 を探す • なかったらなにもしない • あったら，その中で最も y 座標が大きいものを探し，仲良しペアにする というアルゴリズムで最適解が求まります。 余談 この問題は，二部グラフの最大マッチング問題としても考えることが 可能で，これは最大流アルゴリズムを使用すれば解くことが出来ます。 3 D: Two Sequences まず，この問題では bit は 0-indexed とします。つまり，2 進数で一番下の 桁から，0-bit 目，1-bit 目, ..., と呼びます。 答えを各 bit ごとに求めます。k-bit 目を求めたいとします。 xor の定義より，N2 個の ai + bj のうち，k-bit 目が 1 のものが偶数個ある か奇数個あるか判定できれば良いです。 ここで重要な考察として，ai + bj の k-bit 目を考えているので，ai , bj の k + 1-bit 目以降は無視してよい，つまり ai , bj は 2 k+1 で mod を取ってしまっ て良いというのがあります。 すると，ai+bj はたかだか 4T(T = 2k ) 未満です。そして，k-bit 目が 1 の範 囲は，[T, 2T), [3T, 4T), [5T, 6T), ... なので，ai +bj のうち，[T, 2T), [3T, 4T) の範囲にあるものの個数を求めればよいことがわかります。 これは，ai を固定してしまえば，bj のうち [T −ai , 2T −ai), [3T −ai , 4T −ai) の範囲にあるものの個数を求めれば良くなり，これは bj を sort しておけば 二分探索で O(logN) で求められます。 余談 この問題の O(N2 ) 解は非常に単純なうえ，SIMD で高速化が効き，と てつもなく高速に動作します。 writer が素直な O(N2 ) を書き，ブロック化を行ったら 3770ms となったの で，SIMD が得意な人ならばもしかすると愚直解で通せてしまうのではとも 考えています。 ぜひ SIMD が得意な人は挑戦してみてください。 4 E: Both Sides Merger 最終的な数列の要素は，当然 ai をいくつか足したものになります。 ここで，この i の集合に注目します。例えばサンプル 1 なら最終的な要素 は a2 + a4 なので，{2, 4} という集合に注目します。 この集合にはどのような性質があるでしょうか？実は，必ずこの集合の要 素は，偶奇は全て等しくなります。 つまり，偶奇の違うペア，例えば a1, a2 や a4, a7 は，絶対に一つの要素に 合わせられないです。 これは，どのような操作をしてもこのペアの要素は偶奇が異なったまま (な ので，一つの要素にまとめることは不可能) であることから示せます。 実は，これが必要十分です。つまり，すべての要素が偶奇が等しい集合が 与えれば，最終的な要素がそれに対応した要素の和になるような手順が必ず 存在します。 構築の方法ですが，両端のいらない要素をまず全てカットします。その後 • 両端がどちらも残したい要素，かつ自分自身は残したくない要素 (A) • 両端がどちらも残したくない，かつ自分自身も残したくない要素 (B) この A, B を満たす要素のうちどちらかは必ず取れるので，これを取って いけばかならず要素数が少なくなっていき，最終的に 1 つになります。 なぜこのどちらかは必ず存在するのかというと，集合の要素の偶奇が等し いということは，oxxxoxo，のように残したい要素同士の間には，残したく ない要素が奇数個挟まっています。 もし 1 個挟まっていれば，その要素は A の条件を満たし，3 個以上挟まっ ていれば，(そのうち両端以外は)B の条件を満たします。よって，必ずどち らかを満たす要素が存在します。 以上より，この問題は，「数列から添字の偶奇が同じように要素を取って， 総和を最大化してください」という問題になります。これは，偶奇を固定し， 0 以上の要素をすべて取るだけでよいです。 コーナーケースは全部の要素が負の場合です。十分注意してください。 5 F: Two Faced Edges 各辺 i に対し，以下の条件を満たすかを調べたいです。 • 1. もし辺 (ai , bi) を消したとしても，ai から bi に到達可能か？ • 2. bi から ai に到達可能か？ この 2 つの条件を両方達成するか，両方達成しない場合，辺の反転で SCC の成分数が変わらないことが容易に示せます。 条件 2 は O(N + M) や O(N(N + M)) で容易に調べられます。ですので， この問題の本質は条件 1 を高速に求めることです。 方針としては，頂点を固定し，そこから出ていく辺すべてについての条件 1 を O(N + M) で求めます。つまり，ai を固定します。 まず，ai から出てくる辺に，適当に連番を振っておきます。 当然 (ai , bi) を使わずに ai から bi に到達可能ならば，ai から出ていく他 の辺を使う必要があります。そしてその辺の番号は (ai , bi) より小さいかま たは大きいです。 よって，まずは小さい辺を使った場合のみ，つまり以下の条件を考えます。 当然小さい辺を使った場合のみに限定して解ければ，辺に降った番号を逆順 にしてもう一度同じ問題を解けば良いので，この問題が解けます。 • 3. もし辺 (ai , bi) を消したとしても，ai から (ai , bi) より小さい番号の 辺を使い，bi に到達可能か？ 条件 3 は，辺の番号が小さい順に辺を追加していき，追加する直前に今ま で追加した辺を利用して bi に到達できるか，を調べられれば良いです。 これは，辺を追加するたびに dfs を走らせ，二度同じ頂点は辿らないよう にするだけで，まとめて O(N + M) となります。 よってこの問題はまとめて O(N(N + M)) で解けました。 6 A: Two Coins [https://beta.atcoder.jp/contests/abc091/submissions/2218039] 7 B: Two Colors Card Game [https://beta.atcoder.jp/contests/abc091/submissions/2218376] 8 C: 2D Plane 2N Points Let A be a blue point with the minimum x-coordinate. If A can be paired with red points, we should choose a red point B such that B can be paired with A, and among all such points the y-coordinate is the maximum possible. (If B is paired with other point, for example if there are pairs B − C and A − D, we can rearrange them because A − C and B − D are also valid pairs). By doing this, we can reduce the number of points by 1 (if A can’t be paired at all) or 2 (if we find a pair A − B). In summary, we first sort all 2N points together by x-coordinates, and process points in this order. We also keep a set of points (initially this is empty). Then, for each point, do the following: • If a red point appears, add its y-coordinate to the set. • If a blue point appears, let p be its y-coordinate. If all elements in the set are greater than p, do nothing (we can’t do anything with this blue point). Otherwise, choose the maximum element q in the set such that q < p, remove it, and increase the answer by one (the current blue point and the point that corresponds to q are paired). 9 D: Two Sequences Since we can handle each bit independently, let’s consider only the k-th bit. We want to count the number of pairs (i, j) such that the k-th bit of ai +bj is one. (And if this number is add, we should add 2k to the answer.) Let T = 2k . An important observation is that, we are only interested in the values of ai , bi in modulo 2T. Thus, let’s replace ai with ai%(2T) and bi with bi%(2T), and assume that ai , bi < 2T. Then, there are two cases when the k-th bit of ai + bj is one: • T ≤ ai + bj < 2T • 3T ≤ ai + bj < 4T Let’s sort b in an increasing order. For a fixed i, the set of j that satisfies T ≤ ai +bj < 2T forms an interval. Thus, we can count the number of such js by binary search (or two-pointers). Similarly, we can handle the second case. This solution works in O(NlogNlogMAX) time, where MAX is the maximum number that can appear in the input. 10 E: Both Sides Merger The answer of this problem will be the sum of a subset of {ai}. For example, consider example 1. In this sample, the answer is a2 + a4, so the set of indices is {2, 4} Suppose that we are given a set of indices, I. Let’s check if we can perform operations such that the final integer corresponds to the sum of all elements with indices in I. It turns out that the following are neccesary and sufficient conditions: • The parity of all indices in I are the same. • I is non-empty. It’s easy to prove that these conditions are necessary. Suppose that initially, x is in an odd-indexed position and y is in an even-indexed position. Then, no matter what operations we perform, the parities of the indices of x, y never become the same. These are also sufficient conditions because we can construct a sequence of operations, as we describe below. To compute the answer, fix a parity, and take all non-negative elements in the positions with chosen parity. When all elements are negative, you need to be careful not to make it empty. To construct a sequence of operations, we first remove all unnecessary elements from both ends. Then, we repeat choosing elements while we have more than one elements. We can choose an element x if one of the following holds: • x is adjacent to two elements (call it y, z), and we want to keep both y and z in the final element. • x is adjacent to two elements (call it y, z), and we want to remove both y and z from the array. It’s easy to see that such elements always exist. 11 F: Two Faced Edges For each edge i, we want to determine the following two things: • 1. If we remove an edge from ai to bi , is bi still reachable from ai (by using other edges)? • 2. Is ai reachable from bi? It’s easy to see that the number of SCCs won’t change after the reversion of edge i if and only if the answers to the two questions above are the same (i.e., both are yes or both are no). Since the second question can be solved easily in O(NM) by running dfs from all vertices, we will focus on the first question. Consider a particular vertex x. We will solve the first question for all edges such that ai = x, in O(M) time. Then, we can solve the entire problem in O(NM). Suppose that there are k edges that goes out of the vertex x, and let’s name the destinations y1, . . . , yk. We will do the following: • By running a dfs from y1, we mark all vertices that are reachable from y1 without visiting x. • By running a dfs from y2, we mark all unmarked vertices that are reachable from y2 without visiting x. • By running a dfs from y3, we mark all unmarked vertices that are reachable from y3 without visiting x. • And so on. Then, for each vertex z, we know the minimum integer p(z) such that z is reachable from x by using an edge x− > yp(z) (and without visiting the vertex x again). Similarly, by running dfs in the reverse order, for each vertex z, we know the maximum integer q(z) such that z is reachable from x by using an edge x− > yq(z) (and without visiting the vertex x again). The question 1 for an edge x− > yi is ”yes” if and only if at least one of p(yi) ̸= i or q(yi) ̸= i holds. This solution works in O(NM) time. 12 ABC 090/ARC 091 解説 DEGwer 2018/03/11 For International Readers: English editorial starts on page 6. A: Diagonal String c11, c22, c33 を順に出力すればよいです。 #i n cl u d e <s t d i o . h> i n t main ( ) { ch a r a [ 1 0 ] [ 1 0 ] ; s c a n f (”% s%s%s ” , a [ 0 ] , a [ 1 ] , a [ 2 ] ) ; p r i n t f (”%c%c%c \n ” , a [ 0 ] [ 0 ] , a [ 1 ] [ 1 ] , a [ 2 ] [ 2 ] ) ; } B: Palindromic Numbers A 以上 B 以下の全ての整数について、(5 桁であることを適宜利用して) 回文数かどうか判定していけばよ いです。 #i n cl u d e <s t d i o . h> i n t main ( ) { i n t a , b ; s c a n f (”%d%d ” , &a , &b ) ; i n t r = 0 ; f o r ( i n t i = a ; i <= b ; i++) { i n t s = i % 1 0 , t = i / 10000 % 1 0; i n t u = i / 10 % 1 0 , v = i / 1000 % 1 0; i f ( s == t&&u == v ) r++; 1 } p r i n t f (”%d\n ” , r ) ; } C: Flip,Flip, and Flip...... N ≤ M として一般性を失いません。偶数回裏返されるカードは全操作の終了後には表を、奇数回裏返され るカードは裏を向くことになるので、各マスのカードが何回裏返されるかを考えることにしましょう。 N = 1 かつ M = 1 のとき、1 枚だけあるカードは 1 回裏返されるので、答えは 1 です。 N = 1 かつ M ̸= 1 のとき、M 枚のカードのうち両端のカードは 2 回、それ以外のカードは 3 回裏返され るので、答えは M − 2 です。 N ≥ 2 のとき、N ≤ M より M ≥ 2 で、このとき、 • 四隅のカードは 4 回 • それ以外の周上のカードは 6 回 • それ以外のカードは 9 回 裏返されるので、答えは (N − 2)(M − 2) です。 以上で答えがすべて求まりました。 D: Remainder Reminder b を固定して考えましょう。b = 1, 2, · · · N に対し、a を b で割った余りが K 以上であるような 1 ≤ a ≤ N の個数が高速に求められれば良いです。簡単のため、a = 0 も許すことにして、あとで a = 0 の場合 (これは 簡単に求められます) を引くことにしましょう。 さて、整数 p, q を用いて N = pb + r(0 ≤ r < b) という形で N を一意的に表したとき、a を 0 から N ま で順に動かせば、a を b で割った余りを順に並べたものは、0, 1, 2, · · · b − 1 という列が p 回繰り返され、最 後に 0, 1, 2, · · · r という列が付け加わったものになります。 0, 1, 2, · · · b − 1 という列が p 回繰り返される部分には条件を満たす a の個数は p × max(0, b − K) 個、最 後の部分には max(0, r − K + 1) 個あるので、条件を満たす a の個数が O(1) 時間で求められ、O(N) 時間 でこの問題を解くことができました。 E: LISDL まず、条件を満たす列が存在する条件を考えてみましょう。増加部分列と減少部分列は 2 つ以上の要素を 共有できないため、A + B − 1 ≤ N が必要です。また、長さ N の列 P と 1 ≤ i ≤ N について、f(i) で P の i 番目の要素を最後の要素とするような P の増加部分列の最大長を表すことにすることにすれば、f(i) の 値が等しいような i について i 番目の要素を取ってきて全て順に並べた列は減少列となるので、f(i) が等し いような P の要素の個数は最大で B 個以下であり、よって (f(i) ≤ A より) AB ≥ N が必要です。 逆に、これらの条件が満たされれば、条件を満たす列を構成することができます。以下、これを示します。 AB = N の場合に、ある最長増加部分列とある最長減少部分列が 1 つの要素を共有するようなものが構成 2 できれば、あとはそこから (その最長増加部分列または最長減少部分列に含まれる A + B − 1 個の要素を残す ように) 要素を必要なだけ取り除き、座標圧縮を行うことで条件を満たす列を構成することができます (もち ろん、計算量が大きくならないような適切な実装をする必要がありますが、それについては簡単なので割愛し ます)。よって、以下ではそのような構成のみ考えます。 N 個の要素を A 個ずつの要素を含む B 個のブロックに分け、i 個目のブロックの j 個目の要素を Pij と呼ぶ ことにしましょう。すなわち、作る列では、要素が P11, · · · , P1A, P21, · · · , P2A, · · · , PB1, · · · , PBA の順に並ぶ ようにするとしましょう。このとき、要素を小さい方から順に PB1, · · · , P11, PB2, · · · , P12, · · · , PBA, · · · , P1A と並ぶようにすれば、条件をすべて満たすことを証明できます。実際、長さ A の増加部分列と長さ B の減少 部分列が存在することは容易にわかり、また、 • 増加部分列について、ブロック内でその要素が何番目かを表す値 (P の 2 番目の添え字) は狭義単調 増加 • 減少部分列について、その要素が属するブロックの番号 (P の 1 番目の添え字) は狭義単調増加 することから、その長さを超える増加部分列や減少部分列が存在しないことも分かります。よって構成がで き、この問題が解けました。 F: Strange Nim 各山については独立したゲームとなっているため、各山についてその Grundy 数が求められれば良いです。 石 N 個からなり、整数 K の定まった山を山 (N, K) と呼ぶことにします。 このとき、以下が主張できます。 • N が K の倍数のとき、山 (N, K) の Grundy 数は N/K • そうでないとき、山 (N, K) の Grundy 数は山 (N − ⌊N/K⌋ − 1, K) の Grundy 数に等しい これを帰納法で証明しましょう。帰納法の仮定に「山 (N, K),(N −1, K), · · · ,(N −⌊N/K⌋, K) の Grundy 数はすべて異なる 0 以上 ⌊N/K⌋ 以下の整数である」という条件を追加し、帰納法を回します。 N = 0 のときは明らかです。N = t − 1 で正しいとし、N = t で主張を証明しましょう。 山 (N, K) の Grundy 数は (N − 1, K),(N − 2, K), · · · ,(N − ⌊N/K⌋, K) の Grundy 数のどれとも異な る最小の値です。N が K の倍数のとき、帰納法の仮定よりこれらはすべて異なる 0 以上 ⌊N/K⌋ − 1 以 下の整数であり、よって 0 以上 ⌊N/K⌋ − 1 以下の全ての整数値をとり、よって山 (N, K) の Grundy 数 は N/K です。そうでない場合、これらはすべて異なる 0 以上 ⌊N/K⌋ 以下の整数であり、よって 0 以上 ⌊N/K⌋ 以下の整数のうちちょうど 1 つだけここに現れないものがあります。山 (N − 1, K) の Grundy 数 を求めたときにはその Grundy 数への遷移が考慮されていたことから、結局山 (N, K) の Grundy 数は山 (N − ⌊N/K⌋ − 1, K) の Grundy 数に等しいことが分かります。また、追加した条件が満たされることは Grundy 数の定義から容易に導かれます。 よって帰納法が回り、上記が示されました。しかし、この通りに計算してもまだ計算量は大きいままです。 以下、計算量を落とすことを考えましょう。 この計算量は、遷移をある程度「一気に行う」ことで削減可能です。N < K2 のとき、上記を愚直に実装す れば N の値は N/K ほどしか減少しません。しかし、もし遷移先でも ⌊N/K⌋ の値が変化しないのならば、 N の減少分も変化しません。よって、⌊N/K⌋ の値が変化しないギリギリまで N の値を減らす操作をまとめ 3 て行うことで、遷移の回数を減らすことができます。 計算量を見積もりましょう。N < K2 の領域では、遷移をまとめて行えば ⌊N/K⌋ の値は定数回の操作で 1 減少するため、O(min(N/K, K)) 時間ですべての遷移を行うことができます。そうでない領域では、N の 値は 1 回の操作で必ず K−1 K 倍以下になり、よって K 回の操作でおよそ 1 e 倍以下になります。よって必要 な遷移の回数は O(K log(N/K2 )) 回であり、この値は K を動かせば K = √ Ne−1 で最大値 O(K) を取り ます。N ≥ K2 よりこれは O(min(N/K, K)) で、よって各山について O(min(N/K, K)) ≤ O( √ N) 時間で Grundy 数を求めることができるので、この問題を解くことができました。 4 ABC 090/ARC 091 Editorial DEGwer 2018/03/11 A: Diagonal String Print c11, c22, c33 in this order. #i n cl u d e <s t d i o . h> i n t main ( ) { ch a r a [ 1 0 ] [ 1 0 ] ; s c a n f (”% s%s%s ” , a [ 0 ] , a [ 1 ] , a [ 2 ] ) ; p r i n t f (”%c%c%c \n ” , a [ 0 ] [ 0 ] , a [ 1 ] [ 1 ] , a [ 2 ] [ 2 ] ) ; } B: Palindromic Numbers For each integer between A and B, check if it is a palindrome (possibly by using the fact that it’s a 5-digit number). #i n cl u d e <s t d i o . h> i n t main ( ) { i n t a , b ; s c a n f (”%d%d ” , &a , &b ) ; i n t r = 0 ; f o r ( i n t i = a ; i <= b ; i++) { i n t s = i % 1 0 , t = i / 10000 % 1 0; i n t u = i / 10 % 1 0 , v = i / 1000 % 1 0; i f ( s == t&&u == v ) r++; } p r i n t f (”%d\n ” , r ) ; 1 } C: Flip,Flip, and Flip...... Without loss of generality, we can assume that N ≤ M. For each card, let’s count the number of times it is flipped: it will be faced down if this number is odd. In case N = 1 and M = 1, the only card will be flipped once. The answer is 1. In case N = 1 and M ̸= 1, the two cards at the end will be flipped twice, and other cards will be flipped three times. The answer is M − 2. In case N ≥ 2, since N ≤ M, we have M ≥ 2, and in this case • Four cards at the corners will be flipped 4 times. • Other cards at the edge will be flipped 6 times. • The cards that are completely surrounded by other cards will be flipped 9 times. Thus, the answer is (N − 2)(M − 2). D: Remainder Reminder Let’s fix b. For each b = 1, 2, · · · N, we want to count the number of a that satisfies both 1 ≤ a ≤ N and a%b ≥ K. For simplicity, we allow a = 0 and assume that 0 ≤ a ≤ N (and subtract the cases with a = 0 later). For a fixed b, we want to count the number of terms that are greater than or equal to K, in the sequence 0%b, 1%b, · · · , N%b. If N = pb + r(0 ≤ r < b) (we can represent N in this form uniquely using two integers p, r), the sequence starts with p repetitions of 0, 1, 2, · · · b − 1, followed by 0, 1, 2, · · · r. In the former part, there are p×max(0, b−K) terms that are greater than or equal to K. In the latter part, there are max(0, r − K + 1) terms that are greater than or equal to K. Thus, for a fixed b, we can compute the number of such as in O(1) time. This solution works in O(N) time in total. 2 E: LISDL When does a solution exist? First, since a LIS and a LDS can share at most one element in common, A + B − 1 ≤ N is necessary. Also, we can prove that AB ≥ N as follows. Let f(i) be the length of the longest increasing sequence that ends with the i-th element. For a fixed c (1 ≤ c ≤ A), consider a subsequence that contains the i-th element if and only if f(i) = c. This sequence must be decreasing, and the length must be at most B. Thus, we get AB ≥ N. On the other hand, when A + B − 1 ≤ N ≤ AB holds, we can construct a sequence as follows. First, suppose that N = AB. In this case, the sequence (B − 1)A + 1,(B − 1)A + 2, · · · , BA,(B − 2)A + 1,(B − 2)A + 2, · · · ,(B − 1)A, · · · , 1, 2, · · · , A satisfies the conditions. (It consists of B blocks of length A, each block is an increasing consecutive sequence). It’s clear that this sequence contains an increasing sequence of length A and a decreasing sequence of length B. Also, these are the longest because • All elements in an increasing sequence must be in the same block. • No two elements in a decreasing sequence must be in the same block. When N < AB, we first construct a sequence above, keep A + B − 1 elements that contain both LIS and LDS, and remove arbitrary AB − N elements from others. Then, the length of LIS and LDS won’t change. We compress the sequence while keeping the relative order of elements, and we get a desired sequence. (Of course, make sure not to spend O(AB) to implement this.) 3 F: Strange Nim Since the piles are independent, it is sufficient to compute grundy numbers of all piles. Let g(N, K) be the grundy number of a pile with N stones and a parameter K. If we perform an experiment for a fixed K, we notice that g(N, K) = N/K when N is divisible by K. Also, we notice that even if we remove the K-th, 2K-th, 3K-th, · · · elements from the sequence g(1, K), g(2, K), · · · , the sequence doesn’t change. Thus, we get • If N is a multiple of K, g(N, K) = N/K • Otherwise, g(N, K) = g(N − ⌊N/K⌋ − 1, K) Once we get the pattern it’s straightforward to prove this: just make sure that from each state with grundy number g, it’s possible to reach states with grundy numbers 0, 1, . . . , g − 1, but not g. How can we compute grundy numbers using the fact above? We start with an integer N, and while N is not divisible by K, we keep replacing N with N − ⌊N/K⌋ − 1. We are interested in the final value of N. However, a straightforward implementation of this will get TL. To make it faster, notice that if the value of ⌊N/K⌋ doesn’t change after an operation, we can perform multiple steps at once. More explicitly, if currently ⌊N/K⌋ = d, we keep decreasing N by d + 1 while N ≥ dK. Thus, instead of performing steps one by one, we can make multiple steps at once until we first get N < dK. What’s the time complexity after this improvement? • Since the value of ⌊N/K⌋ decreases in each step, it’s O(N/K). • Since the value of N is multiplied by a factor of at most K−1 K in each step, in every K steps this is multiplied by a factor of approximately 1 e . Thus, this is O(K log N). We should take the better of the two analysis above: it’s O(min(N/K, K log N) = O( √ N log N). 4 ARC090 / ABC087 解説 wo01 2018 年 1 月 28 日 A 問題 答えは X − A を B で割った余りとなります。 整数を整数で割った余りを求める演算子は多くの言語で用意されています。 以下に C++ による実装例を示します。 #include<cstdio> using namespace std; int main(){ int X, A, B; scanf("%d%d%d", &X, &A, &B); printf("%d\n", (X - A) % B); return 0; } B 問題 ループを用いて 500 円玉、100 円玉、50 円玉を選ぶ枚数の組 (i, j, k) をすべて試すことで答えが求められ ます。 以下に C++ による実装例を示します。 #include<cstdio> using namespace std; int A, B, C; int X; 1 int solve(){ int ans = 0; for(int i = 0; i <= A; ++i){ for(int j = 0; j <= B; ++j){ for(int k = 0; k <= C; ++k){ int tmp = i * 500 + j * 100 + k * 50; if(tmp == X) ans++; } } } return ans; } int main(){ scanf("%d%d%d%d", &A, &B, &C, &X); int ans = solve(); printf("%d\n", ans); return 0; } C 問題 移動方法は「ある i (0 ≤ i ≤ N) を選び、以下のように移動する」というものになります。 1. 右に i 回移動する 2. 下に 1 回移動する 3. 右に N − i 回移動する 最初に右に移動する回数 i の候補は O(N) とおりしかなく、その値を決めたとき回収できるアメの個数は O(N) 時間で計算できるので、求める最大値は O(N2 ) 時間で計算できます。 D 問題 各 i について 0 ≤ xi ≤ 109 であるという条件は考慮しなくて良いことがすぐにわかります。よって、xi と して M 個の情報と矛盾しない限り任意の整数をとることができるものとして考えることにします。 以下のような重み付き有向グラフ G を考えます。 • 頂点は N 個あり、1, 2, . . . , N の番号が付けられている • 各 i (1 ≤ i ≤ M) に対して、頂点 Li から頂点 Ri に向かう重み Di の辺と、頂点 Ri から頂点 Li に 向かう重み −Di の辺が存在する • それ以外に辺は存在しない 2 問題の条件を満たす (x1, x2, . . . , xN ) が存在することは、グラフ G の各頂点 v に整数 xv を割り当てて、 G に頂点 u から頂点 v へ向かう重み d の辺があるならば xv − xu = d が成り立つようにできることと同値 です。 このような割り当てを行うことができるかどうかの判定は、グラフ G に深さ優先探索や幅優先探索を行い、 実際に各頂点に値 x を割り当てて矛盾が生じないか確かめることで行えます。 実装の際は、グラフ G が非連結な場合があることに注意してください。 E 問題 各頂点 v について、頂点 S から頂点 v への最短距離を dv と表すことにします。頂点の組 (u, v) について、 頂点 u から頂点 v への最短路を逆向きにすると頂点 v から頂点 u への最短路が得られることに注意します。 頂点 u と頂点 v を結ぶ長さ c の辺 (このような辺を辺 ({u, v}, c) と書くことにします) が、頂点 S から頂 点 v への最短路に使われうる条件は du + c = dv が成り立つことです。このことを用いると、各頂点 v につ いて、頂点 S から頂点 v への最短路の個数 dp1 [v] を dv が小さい順に動的計画法を行うことで求めることが できます。同様に、頂点 v から頂点 T への最短路の個数 dp2 [v] を dv が大きい順に動的計画法を行うことで 求められます。 dp1 および dp2 の値から、以下のことがわかります。 • 2 人が途中で出会うようなものも含めた、2 人の最短路の選び方の組は dp1 [T] 2 通りある • 2 人が頂点上で出会うような最短路の選び方の組は、2dv = dT となる各頂点 v について、dp1 [v] 2dp2 [v] 2 通りある • 2 人が辺上で出会うような最短路の選び方の組は、2du < dT かつ 2dv > dT かつ du + c = dv を満た 各辺 ({u, v}, c) について、dp1 [u] 2dp2 [v] 2 通りある 求めるべき最短路の組の個数は、2 人が途中で出会うようなものも含めた最短路の選び方の組の個数から、 2 人が途中で出会うような最短路の選び方の組を引くことで求められます。 F 問題 d 桁の正の整数の個数 10d − 10d−1 を Nd と書くことにします。 f(r) − f(l) ≤ 2 のとき、∑ l≤i≤r f(i) > (f(l) + 1)Nf(l)+1 となります。f(r) − 1 ≥ 8 のとき、(f(l) + 1)Nf(l)+1 ≥ 8N8 > 108 となるので、問題の条件 S ≤ 109 のもと、f(r) − f(l) ≥ 2 ならば f(r) − 1 < 8 で あることがわかります。 このことに注意して、以下のように場合分けを行います。 1. f(l) = f(r) の場合 2. f(r) < 9 かつ f(r) ≥ f(l) + 1 の場合 3. f(r) ≥ 10 かつ f(r) = f(l) + 1 の場合 上記のそれぞれの場合について (l, r) の個数を求め、足し合わせれば良いことになります。 それぞれの場合における (l, r) の個数の求め方について見ていきます。 3 1. f(l) = f(r) の場合 値 d = f(l) として考えられるものは S の約数だけです。また、値 d = f(l) を決めると、組 (l, r) の 個数は max(0, Nd − S/d + 1) と求められます。よって、d の値をすべて試すことで組 (l, r) の個数が 求められます。 2. f(r) < 9 かつ f(r) ≥ f(l) + 1 の場合 2 つの組 (l1, r1) と (l2, r2) がともに条件を満たし、l1 < l2 が成り立つとき r1 < r2 も成り立つことに 注意して、l としてあり得る値をすべて試すことにより組 (l, r) の個数が求められます。 3. f(r) ≥ 10 かつ f(r) = f(l) + 1 の場合 整数 t を 10t < S かつ t は S の約数でないようなものとします。このとき、r − l + 1 = t であるよう な (l, r) はちょうど 1 つ存在することがわかります。すなわち、l は ⌊S/t⌋ 桁の整数のうち大きい方か ら t − (S mod t) 番目、r は ⌈S/t⌉ 桁の整数のうち小さい方から S mod t 番目となります。 このことから (l, r) の個数は S/10 未満の整数のうち S の約数でないものの個数と一致し、この値は 簡単に求められます。 すべての場合について (l, r) の個数を求めることができたので、これらを足し合わせることで答えが求まり ます。 4 ARC090 / ABC087 Editorial wo01 January 28th, 2018 Problem A C++ Example: #include<cstdio> using namespace std; int main(){ int X, A, B; scanf("%d%d%d", &X, &A, &B); printf("%d\n", (X - A) % B); return 0; } 1 Problem B C++ Example: #include<cstdio> using namespace std; int A, B, C; int X; int solve(){ int ans = 0; for(int i = 0; i <= A; ++i){ for(int j = 0; j <= B; ++j){ for(int k = 0; k <= C; ++k){ int tmp = i * 500 + j * 100 + k * 50; if(tmp == X) ans++; } } } return ans; } int main(){ scanf("%d%d%d%d", &A, &B, &C, &X); int ans = solve(); printf("%d\n", ans); return 0; } 2 Problem C The sequence of movements must be in the following form for some integer i (0 ≤ i ≤ N): 1. Move to the right i times. 2. Move downward. 3. Move to the right N − i times. There are O(N) possibilites for i. For a fixed i, we can compute the total number of candies in O(N). Thus, brute force works in O(N2 ) time. Problem D Consider the following directed graph G: • There are N vertices numbered 1, 2, . . . , N. • For each i, there are an edge from vertex Li to vertex Ri with weight Di , and an edge from vertex Ri to vertex Li with weight −Di . The problem asks whether we can assign an integer xv to each vertex v in G, such that for each edge from u to v with cost d, xv − xu = d holds. (Clearly, we can ignore the condition 0 ≤ xi ≤ 109 .) We handle each connected component in G independently. For each connected component, we choose an arbitary vertex v and assume that xv = 0. By running a dfs from v, we can uniquly determine the values of xi in this component. After that, we should check if the conditions are actually satisfied. 3 Problem E For each vertex v, let d1v be the length of the shortest path from S to v. Let dp1 [v] be the number of shortest paths from S to v. An edge between u and v with cost c can be a part of a shortest path from S to v (in the direction from u to v) if and only if d1u + c = d1v. By using this, we can compute the values of dp1 [v] from the verteices with smaller values of d1. Similarly, define d2v as the length of the shortest path from T to v, and dp2 [v] as the number of shortest paths from T to v. From dp1 and dp2 , we can get the following values: • The total number of pairs of shortest paths is dp1 [T] 2 . • Let D = d1T . For each vertex v such that d1v = d2v = D/2, there are dp1 [v] 2dp2 [v] 2 pairs of paths such that the two people meet on v. • Consider an edge between vertices u and v with cost c. If d1u < D/2, d2v < D/2, and d1u +d2v + c = D, there are dp1 [u] 2dp2 [v] 2 pairs of paths such that the two people meet on this edge (except for endpoints). The answer is (the first value) - (the second value) - (the third value) mentioned above. 4 Problem F Let Nd = 10d − 10d−1 be the number of d-digit integers. If f(r) − f(l) ≥ 2, it means that all integers with l + 1 digits are in the chosen range. Since the total number of digits of 8-digit integers is 8N8 = 720000000 > 108 , l + 1 must be less than 8 in this case. Now, consider the following two cases: The case with f(l) ≤ 7 In this case, l < 10000000, and under the constraints of the problem, it turns out that r < 23000000. Thus, we can generate the first 23000000 terms of the sequence f(1), f(2), · · · , and we can get the answer by two-pointers method. The case with f(l) ≥ 8 Let t be an integer between 1 and floor(S/8). It turns out that, except for special cases, there is exactly one pair (l, r) such that f(l) ≥ 8, f(l) + · · · + f(r) = S, and r − l + 1 = t (i.e., there are exactly t terms in the chosen range). This is because there is exactly one interval that starts with t − (S mod t) occurrences of ⌊S/t⌋-digit integers followed by S mod t occurrences of ⌈S/t⌉-digit integers. Thus, we should add floor(S/8) to the answer. The only exception happens when t is a divisor of S. In this case, there are Nt −S/t+ 1 such intervals. To handle this, we should add Nt − S/t to the answer for each divisor t between 1 and floor(S/8). Exercise: can you compute the answer if S ≤ 1012? 5 ABC086 / ARC089 解説 sigma425 For International Readers: English editorial starts on page 5. A: Product 整数 a, b を読み込み、a × b を計算し、2 で割ったあまりを計算すればいいです。 int main (){ int a ,b; cin >>a > >b; int c = a * b ; if ( c %2 == 0) puts (" Even "); else puts (" Odd "); return 0; } B: 1 21 整数として読み込むよりも、文字列として読み込んで連結したものを整数に直すのが簡単かもしれません。 C++ には標準で文字列を整数に直す stoi 関数があります。この整数は高々 100100 なので、平方数かどうか は、1 × 1, 2 × 2, .. , 1000 × 1000 くらいまでのどれかと一致するかループを回して確かめれば良いです。 int main (){ string s ,t; cin >>s > >t; int x = stoi (s+ t ); for ( int i =1; i <=1000; i ++){ if ( i*i == x ){ puts (" Yes "); return 0; } } puts (" No "); } C: Traveling t0 = 0,(x0, y0) = (0, 0) と置きます。各 0 以上 N − 1 以下の i について、時刻 ti に場所 (xi , yi) にいた後、 時刻 ti+1 に場所 (xi+1, yi+1) にいることができるか、を判定して、どれか一つでも不可能なら No を、全て可 能なら Yes を出力すれば良いです。 1 この判定は、t := ti+1 − ti , d := abs(xi − xi+1) + abs(yi − yi+1) とおくと、d ≤ t ∧ t%2 = d%2 で判定で きます。(d ≤ t でないと不可能なのは明らか、毎秒 x + y の偶奇は変わるので 2 で割ったあまりは一致する 必要がある。 逆に d, t がこれを満たすなら実際に条件のように動くことが可能) D: Checker マス (x, y) が白 と マス (x, y + K) が黒 は同値なので、(x, y,′ W′ ) という入力を (x, y + K,′ B′ ) に置き換 えても条件は同じです。これで入力の ci を全て’B’ に変換することが出来ます。 マス (x, y) の色とマス (x, y + 2K),(x + 2K, y) の色は一致します。なので、入力の x, y を x%2K, y%2K で置き換えても答えは変わりません。すると 0 ≤ x, y < 2K と変換することが出来ます。 市松模様の黒い部分の左下のマスのうちひとつを定めるとマスの塗られ方全体が定まります。ここで、定め るマスは [0, 2K) × [0, 2K) の中にあると仮定して問題ありません (なぜなら、どんな市松の塗られ方でも黒い 部分の左下のマスのうちひとつはこの中にあるため)。なので、左下マスを (2K) 2 すべて試すと、左下を決め れば各条件が満たされるかどうかは O(1) で判定できるので、全体で O(NK2 ) になります。 ここから計算量を落とすには、条件 i を満たせるような左下マスの集合が K ∗ K の正方形区間のようになっ ていることに着目して、その範囲に +1 を足し、全体での max を取ります。ただし毎回範囲に +1 をしてい ては遅いので、差分を取って左下と右上に +1, 左上と右下に −1 を足しておき、あとで累積和を取ることで O(N + K2 ) で同じことが可能です。 E: GraphXY まずグラフ,S, T が与えられた時に,X = x, Y = y の時の最短距離 Dx,y がどういう振る舞いをするかを考 えます。0 以上の整数の組 (a, b) に対して、「X の辺をちょうど a 回,Y の辺をちょうど b 回使った時に S か ら T への (整数が書いてある辺の重みのみを考慮した) 最短距離」 を fa,b とおきます。 すると、 Dx,y = min a,b≥0 xa + yb + fa,b 逆に次のようなグラフを考えれば、fa,b を 0 以上の整数値に自由に決めて上のように Dx,y を設定できます。 なので、fa,b を決めることでこの D を入力の d と一致させることが目標です。 入力 d が与えられた時,d の値の範囲が高々 100 であることから、a や b が 100 より大きいと xa + yb + fa,b が 100 より大きくなってしまい D を d と一致させる役には立ちません。 よって 0 ≤ a, b ≤ 100 をみたす整数の組 (a, b) に対して fa,b を決めることにします。fa,b は、任意の 1 ≤ x ≤ A, , 1 ≤ y ≤ B に対し dx,y ≤ xa + yb + fa,b を満たす、という条件のもとで最も小さくする (ただし 0 以上である必要はある) のがベストです。 2 なので、 fa,b = max(0, max 0≤a,b≤100 (dx,y − xa + yb)) として、これで計算した D と入力の d が一致していればこれを出力、していなければ Impossible です。 F: ColoringBalls 以下では赤、青、白色のボールをそれぞれ R,B,W で表します。まずボールの列が与えられた時に、それが 実現できるか判定することを考えます。例えば”WRRBRBBWWRRRRWRBBWWRRBBRR” というボー ル列を考えます。まず’W’ で区切って R,B からなる列の (多重) 集合に変換します。 {“RRBRBB”, “RRRR”, “RBB”, “RRBBRR”} 次に、RR を R に、BB を B にする操作をできるだけ繰り返します (つまり連続している R(B) をひとつの R(B) に置き換える操作をします)。 {“RBRB”, “R”, “RB”, “RBR”} さらに、これらが次のうちどのグループに属しているかをカウントします： グループ 1 : “R” グループ 2 : “B”, “RB”, “BR”, “RBR” グループ 3 : “BRB”, “RBRB”, “BRBR”, “RBRBR” グループ 4 : “BRBRB”, “RBRBRB”, “BRBRBR”, “RBRBRBR” : (以下同様) グループ id を降順にならべた配列を f とおきます。 上の例だと f = [3, 2, 2, 1] です。 重要なのは、この配列 f が一緒になるようなどんなボール列も実現できるかどうかは変わらないということ です。以下説明します。 まず列の集合に変換した結果が同じなら (つまり列の順番を並び替えたり無駄な W を挿入したりするだけ) 結果も明らかに同じなのでここは OK です。 次に連続する R の個数を増やしたりしてもそういう塗り方が出来るかは変わらないのでこれも OK です。 最後にグループ分けですが、赤で塗る操作を r, 青で塗る操作を b, どちらでもいいので塗る操作を?とか くと、 グループ 1 は r で実現できる グループ 2 は rb で実現できる グループ 3 は rb? で実現できる グループ 4 は rb?? で実現できる グループ 5 は rb??? で実現できる : ということがわかります。つまり同グループに属していれば操作列によって実現可能かどうかは一緒です。 最終的に、配列 f が同じならば、実現可能性は同じであることがわかりました。 配列 f となるようなボール列が実現可能かどうかは次のように判定できます。操作列を s とおきます。 3 f の各要素 x に、操作列の部分列であってグループ x を実現できるもの を割り当てられるかの判定をすれ ば良いです。(操作列の各文字はひとつにしか割り当てられません) 実は最適な割当は以下の貪欲法で構成することが出来ます (以下の貪欲で構成できなければ不可能です)。 はじめに、s の要素を左から見ていって、k 個目にでてきた r を f の k 個目の要素に割り当てます。これが 出てきた場所を rk とおきます。 次に、f の要素を左から見ていって、もし値が 2 以上なら、rk より右にあってまだ割り当てていないうち最 も左の b を割り当てます。これが出てきた場所を bk とおきます。 最後に、f の要素を左から見ていって、値 x が 3 以上なら、bk より右にあってまだ割り当てられていない もののうち左にある x − 2 個 (r,b どちらでもよい) を割り当てます。 これらはそれぞれグループ分け部分で説明した必要な文字列のうち、r,b,? の部分に対応するものをとる操 作です。 この貪欲の証明は、 i) r を左から貪欲にとってよい ii) b を (対応する r より右で) 左から貪欲にとってよい iii) グループ番号が大きいものをできるだけ左に対応させるのがよい iv) 残りの?に対応する部分も、対応する b より右で左から貪欲にとってよい の 4 つを示せば完了します。省略しますがこれは証明できます。 この貪欲は O(NK) で走ります。 ところで N = 70 でありうるボールの色の列から生成される f は 418662 通りしか無いことがわかります。 なので、実際に f を生成し、上の貪欲アルゴリズムで可能かどうか判定し、可能なら,f を生成するボール列が 何通りあるかを求めて (これは適切な combination をかけ合わせるとできます) 十分高速に答えが求まります。 N, K の多項式時間で走る DP で計算することも出来ます。f にある 1 の個数、1 以外の個数 を全探索し て、そのあと f の要素を小さい方から追加していく (1 を何個追加するか、2 を何個追加するか・・・ を順番 に決めていく) のですが、「今追加しようとしている値」「これまで追加した値の総和」「これまで何個値を追加 したか」を DP のキーに持てば可能です。 4 ABC086 / ARC089 Editorial sigma425 A: Product int main (){ int a ,b; cin >>a > >b; int c = a * b ; if ( c %2 == 0) puts (" Even "); else puts (" Odd "); return 0; } B: 1 21 int main (){ string s ,t; cin >>s > >t; int x = stoi (s+ t ); for ( int i =1; i <=1000; i ++){ if ( i*i == x ){ puts (" Yes "); return 0; } } puts (" No "); } C: Traveling Let t0 = 0,(x0, y0) = (0, 0). For each i between 0 and N − 1, we check the following: can we reach (xi+1, yi+1) at time ti+1 if we start (xi , yi) at time ti? If the answer is no for at least one i, we print ”No”, otherwise we print ”Yes”. We can check this as follows. Let t := ti+1 − ti , d := abs(xi − xi+1) + abs(yi − yi+1). If d ≤ t and t%2 = d%2, the answer is yes, otherwise the answer is no. 1 D: Checker The cell (x, y) is white iff the cell (x, y + K) is black. Thus, we can replace a query (x, y,′ W′ ) with (x, y + K,′ B′ ). Assume that all ci are ’B’s. The colors of (x, y) and (x, y + 2K),(x+ 2K, y) are same. Thus, we can replace a query (x, y,′ B′ ) with (x%2K, y%2K,′ B′ ). Assume that 0 ≤ x, y < 2K for all queries. If we fix a black cell at the lower-left corner of a K × K block, we can uniquely determine the colors of all cells. Here, we can assume that the black cell is inside [0, 2K) × [0, 2K). Therefore, by trying all (2K) 2 possibilities, and by checking the colors of all N cells that appear in the queries, we get an O(NK2 ) solution. To make it faster, after we fix the black cell at the corner, we should compute the number of queried cells inside certain rectangles in O(1). This can be done by pre-computing rectangle sums. Now the solution becomes O(N + K2 ). 2 E: GraphXY Let’s fix a graph (and S, T). How does Dx,y (the shortest path when X = x, Y = y) behave? For a pair of non-negative integers (a, b), define f(a, b) as the smallest possible sum of integers on an S − T path that contains exactly a edges with ’X’ and exactly b edges with ’Y’. Then, Dx,y = min a,b≥0 xa + yb + fa,b On the other hand, if D satisfies the equation above (for some fa,b), we can construct a desired graph as follows: Thus, our objective is to find fa,b that matches with given d. Since each integer in d is at most d, we don’t need to care the values of f(a, b) for a > 100 or b > 100 because xa + yb + fa,b > 100 in this case. Thus, we want to decide fa,b for each pair (a, b) such that 0 ≤ a, b ≤ 100. We should minimize the value of fa,b under the constraint that dx,y ≤ xa + yb + fa,b for all 1 ≤ x ≤ A, , 1 ≤ y ≤ B. Therefore, define fa,b = max(0, max 0≤a,b≤100 (dx,y − xa + yb)) and compute D. If it matches with the input, we should print the graph described above. Otherwise, the answer is ”Impossible”. 3 F: ColoringBalls We start with a slow solution: generate all 3N sequences of balls of length N, and for each sequence, check if the sequence can be constructed by given operations. However, we don’t need to check all 3N sequences. Some sequences turn out to be equivalent regardless of the operations. Let R,B,W denote red, blue, and white, respectively. As an example, we use a sequence of balls ”WRRBRBBWWRRRRWRBBWWRRBBRR”. We want to transform it into a ”canonlcal form” (while keeping the string equivalent to the original string). First, obviously, we can split the string by ’W’: {“RRBRBB”, “RRRR”, “RBB”, “RRBBRR”} Next, we can replace ”RR” with ”R” and ”BB” with ”B”: {“RBRB”, “R”, “RB”, “RBR”} Next, replace each string with its group number: Group 1 : “R” Group 2 : “B”, “RB”, “BR”, “RBR” Group 3 : “BRB”, “RBRB”, “BRBR”, “RBRBR” Group 4 : “BRBRB”, “RBRBRB”, “BRBRBR”, “RBRBRBR” : Here, the groups represent strings that can be obtained by the following sequences of operations: Group 1 : r Group 2 : rb Group 3 : rb? Group 4 : rb?? Group 5 : rb??? : Finally, we can arbitrary shuffle the elements of the array of integers we get. In this case, we get f = [3, 2, 2, 1]. It turns out that the number of distinct final arrays we get is O(partitionnumber(N)∗N). In particular, when N = 70, there are only 418662 possible fs. Now, our solution is as follows. We generate all 418662 possible fs. For each f, check if it can be obtained by the given sequence of operations. If yes, count the number of sequences of balls that lead to f (this is simply the product of some binomial coefficients), and add it to the answer. How to check if we can get f with the given sequence of operations? Let s be the sequence of operations. For each integer x in f, we want to assign a subsequence of s that matches with x (for example, if x = 4, the subsequence must be ”rb??”). Here, the subsequences must be disjoint. 4 We can assign subsequences greedily as follows: • Suppose that f is sorted in non-decreasing order. • For each k, assign the k-th ’r’ in s (suppose that this is the rk-th character in s) to f[k]. • For each f[k] = x, (we check elements of f from left to right) if x ≥ 2, assign the leftmost ’b’ in s to the right of the rk-th character of s to f[k]. Suppose that this is the bk-th character. • Finally, for each f[k] = x, if x ≥ 3, we assign the leftmost x − 2 unused letters of s to the right of bk-th to f[k]. We omit the proof here, but it is relatively straightforward. The solution above is fast enough to get accepted. If you want a polynomial solution, we can do DP. We first fix the total number of 1s in f and the number of elements in f. Then, we add integers to f in the increasing order. Here, the keys of DP is (the ineger we will add next), (the sum of all integers we’ve added so far), and (the number of integers we’ve added so far). Since it’s complicated and not significantly faster than the brute force above, we omit details. 5 ARC 088/ABC 083 解説 DEGwer 2017/12/23 A: Libra 整数 A, B, C, D を読み込み、A + B と C + D の大小比較をすればよいです。 #i n cl u d e <s t d i o . h> i n t main ( ) { i n t a , b , c , d ; s c a n f (”%d%d%d%d ” , &a , &b , &c , &d ) ; i f ( a + b > c + d ) p r i n t f ( ” L e f t \n ” ) ; e l s e i f ( a + b == c + d ) p r i n t f ( ” Balanced \n ” ) ; e l s e p r i n t f ( ” Right \n ” ) ; } 1 B: Some Sums N 以下の整数の各桁の和を求め、適切に場合分けをして足し合わせてやればよいです。 #i n cl u d e <s t d i o . h> i n t main ( ) { i n t n , a , b ; s c a n f (”%d%d%d ” , &n , &a , &b ) ; i n t r = 0 ; f o r ( i n t i = 1 ; i <= n ; i++) { i n t c = 0 , t = i ; f o r ( i n t j = 0 ; j < 5 ; j++)c += t % 1 0 , t /= 1 0; i f ( a <= c&&c <= b ) r += i ; } p r i n t f (”%d\n ” , r ) ; } C: Multiple Gift 作る数列を A1, ..., A|A| とします。条件より X ≤ A1 であり、またすべての i に対し 2Ai ≤ Ai+1 となり ます。よって、Ai ≥ X × 2 i−1 がわかります。 逆に、Ai = X × 2 i−1 とすれば、これは条件を満たします。すべての i に対し Ai の最小値を達成できてい るので、条件を満たす数列のうちこのようにして作られるもののみを考慮すればよく、時間計算量 O(log B A ) でこの問題を解くことができます。 D: Wide Flip 与えられる文字列の長さを n とします。 k 文字目と k + 1 文字目が異なるとします。このとき、すべての文字を 0 にするためには、k 文字目と k + 1 文字目の片方のみを書き換えるような操作を 1 回以上行わなければなりません。すなわち、max(k, n − k) 文 字以下の連続する部分を書き換えるような操作が必要となります。 S の、k 文字目と k + 1 文字目が異なるような箇所のうちの、max(k, n − k) の最小値を T(S) とします。 K ≥ T(S) のとき、T の値の最小値をとる k をとり、k = max(k, n − k) なら最初 k 文字を、そうでないな ら最後 n − k 文字を書きかえれば、連続する文字が異なるような箇所の個数を、T(S) を減らさずに 1 減らす ことができます。また、T(S) = 0 のとき、もし全文字が 0 ならこれが目的の文字列であり、そうでないなら 全体に対して操作を行えば目的の文字列を作ることができます。 よって答えは最初の文字列 S における T(S) の値で、これは O(n) 時間で求められます。 2 E: Papple Sort まず、奇数回しか出てこない文字が 2 つ以上ある場合、回文を作ることはできません。以下、それ以外の場 合を考えます。 最終的に (最小の交換回数で) 作る回文を T とし、S で添え字 i の文字が T では添え字 pi となるとします。 同じ文字同士を入れ替えるのは無意味なので、各文字に対してその文字の出現回数を求めれば、文字列中の すべての添え字の (|S| 個の) 文字に対し、その文字が最終的に T の左半分に属するか、ちょうど真ん中の文 字となるか、右半分に属するかは一意に定めることができます。 上述の 3 つの添え字集合をそれぞれ A, B, C とします。A の添え字の文字を順序を保ったまま左半分に、 B の添え字の文字を真ん中に、C の添え字の文字を順序を保ったまま右半分に移動して作った文字列を X と します。このとき、これら 3 種類の添え字の文字同士の swap が起こりますが、T に関する上述の条件より、 i < j かつ pi > pj となるような文字 Si , Sj の swap のみが起こることがわかります。よって (バブルソート の交換回数とはそのような添え字 (i, j) の組の個数に他ならないので) S から T への変換での交換回数は、S から X への変換での交換回数と X から T への変換での交換回数の合計と等しくなることが分かります。 さて、X から T に変換するとき、A 内の要素同士、または C 内の要素同士の swap のみが起こります。も し A 内の要素同士の swap が起きる場合、その代わりに C 内での対応する要素同士を swap することにして も、最終的な文字列が回文になるという条件は依然満たされます。よって、A 内の要素同士は swap しないと して問題ありません。 A 内の要素の順番が定まれば C 内の要素の順番も定まるので、結局 pi の値がすべての i に対して一意に 定められたことになります。あとは、順列 p のバブルソートの交換回数を、BIT などを用いて数えてやれば よいです。時間計算量は O(|S| log |S|) です。 F: Christmas Tree この問題は、以下の条件を満たす辞書順最小の (A, B) を求める問題だと言い換えることができます。 • 木の辺たちを A 色で塗り分ける。このとき、同じ色が塗られた辺の集合は、長さ B 以下のパスをなし ている必要がある。 まず、A の最小値を求めましょう。次数奇数の頂点に対し、その点を端点とするようなパスが 1 つ以上必 要です。逆に、次数奇数の頂点間のパスをとって取り除いていくことを考えれば、次数奇数の頂点の個数の半 分の個数のパスがあれば十分であることもわかります。よって、A の最小値は、次数奇数の頂点の個数の半分 です。 B の最小値を求めるために、二分探索を考えましょう。B の値を固定し、そのような塗りわけが存在する かどうかを求める DP を考えましょう。 まず、次数 1 の頂点を根として入力の木を根付き木にします。便宜上、根からも上向きに辺が出ているもの として扱います。各頂点 v に対し、DP[v] を、v を根とする部分木に属するパスの長さがすべて B 以下とな るように塗り分けるときの、v から親方向にのびるパスの長さの最小値 とします。 この DP 値はどのように求めればよいでしょうか。v の子を u1, ..., uk とし、DP[ui ] の小さい順に並べ替 え、改めて添え字を (u1, ..., uk と) つけなおしておきます。条件より、 3 • k が奇数のとき、ui たちから親方向に伸びるパスからペアを k−1 2 個作ってつなぎ合わせ、残ったパス を v から親方向に伸ばすことにする • k が偶数の時、ui たちから親方向に伸びるパスからからペアを k 2 個作ってつなぎ合わせ、v から新し いパスを親方向に伸ばすことにする、またはペアを k 2 − 1 個作ってつなぎ合わせ、残った 2 本のパス のうち 1 本の端点を v にし、もう 1 本のパスを v から親方向に伸ばすことにする する必要があります。 パスたちをペアにするときは、各ペアについてその合計長さが B を超えないようにする必要があります。 すなわち、合計の長さの最大値を最小にするようなペアの組み方を考え、そのときの最大長が B 以下かどう か判定すればよいです。このとき、greedy な考察により、2m 本のパスを m 個のペアに分けるとき、すべて の x に対し、x 番目に長いパスと x 番目に短いパスを組み合わせるのが最適であることがわかるので、この 判定は O(m) 時間で行うことができます。 上の場合分けでの前者の場合、1 本のパスを選んで取り除いた後に、パスをペアにしていく必要がありま す。取り除くパスは、DP 値の定義より、なるべく短いものを選びたいです。これは、「どのパスを取り除く べきか」で二分探索を行うことで最適化することができます。 後者の場合、ペアを k 2 個作る場合は上述のアルゴリズムが動作します。そうでない場合、端点を v にする パスは最も長いパスを選ぶのが良いです。このように選べば、あとは k が奇数の場合と同じ問題に帰着され ます。 以上より、子を k 個もつ頂点での DP 値の更新が O(k log k) 時間でできることが分かりました。最後に、 (次数 1 の頂点を根に選んだことに注意すれば) 根から親方向に伸びるパスの長さを評価することで外側の二 分探索の評価関数が正しく動作し、よって全体で O(N log2 N) 時間でこの問題を解くことができました。 4 ARC 088/ABC 083 Editorial DEGwer 2017/12/23 A: Libra #i n cl u d e <s t d i o . h> i n t main ( ) { i n t a , b , c , d ; s c a n f (”%d%d%d%d ” , &a , &b , &c , &d ) ; i f ( a + b > c + d ) p r i n t f ( ” L e f t \n ” ) ; e l s e i f ( a + b == c + d ) p r i n t f ( ” Balanced \n ” ) ; e l s e p r i n t f ( ” Right \n ” ) ; } 1 B: Some Sums #i n cl u d e <s t d i o . h> i n t main ( ) { i n t n , a , b ; s c a n f (”%d%d%d ” , &n , &a , &b ) ; i n t r = 0 ; f o r ( i n t i = 1 ; i <= n ; i++) { i n t c = 0 , t = i ; f o r ( i n t j = 0 ; j < 5 ; j++)c += t % 1 0 , t /= 1 0; i f ( a <= c&&c <= b ) r += i ; } p r i n t f (”%d\n ” , r ) ; } 2 C: Multiple Gift Let A1, ..., A|A| be the sequence. X ≤ A1 must be satisfied, and for each i, 2Ai ≤ Ai+1 must be satisfied. Thus, we get Ai ≥ X × 2 i−1 . Therefore, the maximum length can be achieved when Ai = X × 2 i−1 . (For all i, the lower bound of Ai is achieved by this sequence.) This solution works in O(log B A ) time. D: Wide Flip Let n be the length of the string. If the k-th and the k + 1-th (1-based) characters of the string are different, in order to achieve the goal, we must perform at least one operation that flips exactly one of the two characters. In this operation, we flip at most max(k, n − k) consecutive characters. Let T(S) be the minimum vaule of max(k, n − k) such that the k-th and the k + 1-th characters of S are different. As we see above, K must be at most T(S). On the other hand, we can prove that when K = T(S), we can achieve the goal. • If i <= N − K, we can flip a single character Si by flipping [i, N] and [i + 1, N]. • Similarly, if i > K, we can flip a single character Si . • By the definition of T(S), all characters between the N − K + 1-th and the K-th are the same. Thus, by repeating the first two types of operations, we can make all characters equal, and (possibly by performing the third operation once) we can achieve the goal. Therefore, the answer is T(S), and it can be computed in O(n) time. 3 E: Papple Sort If two or more letters appear odd number of times, we can’t make a palindrome. For simplicity, suppose that each letter appears even number of times (when a letter appears odd number of times, we know which letter will go to the center of the final string, and the solution doesn’t change a lot.) Let n be the length of the string. Let T be the final palindrome we make (by performing the minimum possible number of operations), and let Tpi be the destination of Si . Consider a particular letter c, and suppose that it appears as i1-th, i2-th, . . ., i2k-th letters of S. Since it makes no sense to swap the same letters, the relative positions of these letters won’t change. Thus, we know that i1 and i2k will be paired in T (i.e., pi1 + pi2k = N + 1), i2 and i2k−1 will be paired, and so on. Therefore, we know which characters will be paired in T, and we can assume that S contains N/2 different types of characters, and each character appears exactly twice. Now, consider two particular types of letters in S (call it ’A’, ’B’). There are six possibilities for their relative positions. For example, they can appear as ...A...A...B...B... If the pair of A becomes ”outer” pair and the pair of B becomes ”inner” pair in T, we need two swaps among these characters. If the pair of B becomes ”outer” pair and the pair of A becomes ”inner” pair in T, we need two swaps among these characters. Thus, it doesn’t matter. By similar observations, it turns out that when they appear as ...A...B...B...A... A should be ”outer” and B should be ”inner”, and if they appear as ...B...A...A...B... B should be ”outer” and A should be ”inner”. In other cases it doesn’t matter. Thus, when we sort the pairs, we should make sure that these properties hold. For example, when we compare two pairs at positions (l1, r1) and (l2, r2), we make (l1, r1) ”outer” if l1 < l2. Now, we know which characters in A will go to which position in T (i.e. we know the values of pi), and we can compute the inversion number in O(|S| log |S|). 4 F: Christmas Tree We want to paint the edges of the tree using A colors. The set of edges of a specific color must form a path of length at most B. What is the minimum possible value of A? Suppose that the tree has O vertices with odd degree. Since an odd vertex must be an endpoint of at least one path, we need at least O/2 paths. On the other hand, by repeatedly removing a path that connects two odd vertices, we can achieve A = O/2. Now, we want to minimize B under the condition that A = O/2. Let’s do a binary search on B. Now we want to check if a valid coloring exists for a fixed B. Choose an arbitrary leaf of the tree, and make it the root. For convenience, we attach an edge to the root (an edge between the root and ”the root’s parent”). Let’s define DP[v] as follows. Consider a subtree rooted at v, plus an edge between v and v’s parent (we call it ev). We want to color each edge inside this subtree, such that • The length of each color must be at most B (of course, each color must form a path). • We should minimize the number of paths: each odd vertex is an endpoint of exactly one path, and each even vertex is an endpoint of no path. • Under these conditions, we want to minimize the length of the color that contains ev. Let DP[v] be this length. How do we compute DP[v]? Suppose that a vertex v has k children u1, ..., uk, and assume that DP[u1] ≤ DP[u2] ≤ .... If k is odd, we need to make k−1 2 pairs among the children, and pair the only remaining child (call it ur) with ev. Obviously, we want to minimize r. Let’s do a binary search again on r. For a fixed r, we want to check if the values DP[u1], . . . , DP[ur−1], DP[ur+1], . . . , DP[uk] can be divided into pairs whose sums are at most B. This can be done greedily by pairing the x-th largest value and the x-th smallest value. Then, DP[v] = DP[ur] + 1. If k is even, add an imaginary child u0 such that DP[u0] = 0, and it reduces to the case with odd k. If we don’t get contradictions and dp[root] ≤ B + 1, the chosen value of B is valid. Since we need O(k log k) time to handle a vertex with k children, we need O(N log N) per step, and in total this solution works in O(N log2 N) time. 5 ABC #082 / ARC #087 Editorial writer : sugim48 2017 年 12 月 16 日 For International Readers: English editorial starts on page 5. A: Round Up the Mean • C++ のコード例 : https://beta.atcoder.jp/contests/abc082/submissions/1872729 • Java のコード例 : https://beta.atcoder.jp/contests/abc082/submissions/1872732 • Python 3 のコード例 : https://beta.atcoder.jp/contests/abc082/submissions/1872734 B: Two Anagrams s の文字を昇順にソートし，t の文字を降順にソートした後，s < t を判定すればよいです． • C++ のコード例 : https://beta.atcoder.jp/contests/abc082/submissions/1872811 • Java のコード例 : https://beta.atcoder.jp/contests/abc082/submissions/1872812 • Python 3 のコード例 : https://beta.atcoder.jp/contests/abc082/submissions/1872814 C: Good Sequence それぞれの正の整数 x について，a 中の値 x の個数を nx とします．nx < x の場合，a 中の値 x はすべて 取り除かなければならないので，nx 回の操作が必要です．nx ≥ x の場合，a 中の値 x の個数を x にすれば よいので，nx − x 回の操作が必要です．すべての x についてこれらの操作回数を合計したものが答えです． 実際には，すべての x ではなく，a 中の値 x のみ調べればよいです．x の値は最大で 109 と大きいので， 普通の配列の代わりに連想配列を用いて各 nx を数えればよいです． • C++ のコード例 : https://beta.atcoder.jp/contests/abc082/submissions/1872852 D: FT Robot s の長さを N とし，目標の座標を (xt, yt) とします． まず思いつく解法は，dpi,x,y,k := (i 文字目の命令後に座標 (x, y) に向き k ∈ { 左, 上, 右, 下 } でいられるか) 1 と定義し，DP をする解法です．しかし，この DP の状態数は O(N3 ) で，遷移は O(1) なので，全体の時間 計算量は O(N3 ) となり，TLE してしまいます． ロボットの動き方をよく観察することで，DP の状態数を減らしましょう．命令列を T を区切り文字として 分割したとき，i 番目の区間に含まれる F の個数を di とします．このとき，ロボットの動き方は • 右に距離 d1 だけ動く • 上または下の好きな向きに距離 d2 だけ動く • 左または右の好きな向きに距離 d3 だけ動く • 上または下の好きな向きに距離 d4 だけ動く • 左または右の好きな向きに距離 d5 だけ動く • 以下同様 となっています．よって，x 軸方向の移動と y 軸方向の移動を独立に考えることができます．例えば，x 軸方 向の移動については， • 右に距離 d1 だけ動く • 左または右の好きな向きに距離 d3 だけ動く • 左または右の好きな向きに距離 d5 だけ動く • 以下同様 という移動を終えた後，x 座標が xt になっているようにできるか判定すればよいです． これは次のような DP で計算できます． • 定義: dpi,x := (i 回目の x 軸方向の移動の後に x 座標が x になっているようにできるか)． • 初期化: 1 回目の x 軸方向の移動距離を d1 とすると，dp0,d1 = true． • 漸化式: i (i ≥ 2) 回目の x 軸方向の移動距離を di とすると，dpi,x = dpi−1,x−di ∨ dpi−1,x+di． この DP の状態数は O(N2 ) で，遷移は O(1) なので，全体の時間計算量は O(N2 ) となり，十分に高速です． y 軸方向の移動についても，同様の DP で計算できます． E: Prefix-free Game 長さ L 以下の 0, 1 のみからなる文字列全体からトライ木を作ると，これは高さ L + 1 の完全二分木となり ます．ただし，完全二分木の高さは，根から葉までのパスに含まれる頂点の個数と定義します．この完全二分 ✓ 木を用いると，ゲームは次のように言い換えられます． ✏ 高さ L + 1 の完全二分木がある．最初，いくつかの頂点には駒が置かれている．ただし，どの駒どうし も先祖-子孫の関係ではない．Alice と Bob は交互に，駒のない頂点をひとつ選んで駒を置く．ただし， どの駒どうしも先祖-子孫の関係ではないという条件を保つようにする．先に駒を置けなくなった方が負 けである． ✒ ✑ 2 上図は初期状態の例 (L = 3) です．青いマル印は駒を表しており，赤いバツ印は駒を置けない頂点を表して います．このとき，駒を置ける頂点の集合は，いくつかの完全二分木 (緑の三角形) の和になっています．こ れらの完全二分木は先祖-子孫の関係ではないので，独立に考えることができます．また，完全二分木のある頂 点に駒を置くと，その完全二分木はいくつかの完全二分木に分裂します．具体的には，高さ i の完全二分木の 深さ j (0 ≤ j ≤ i − 1) の頂点に駒を置くと，高さ i − 1, i − 2, ..., i − j の完全二分木 1 個ずつに分裂します． ✓ 以上より，ゲームはさらに次のように言い換えられます． ✏ 最初，いくつかのアイテムがある．各アイテムには正整数のレベルが設定されている．Alice と Bob は 交互に次の操作を行う． • アイテムを 1 個選ぶ．選んだアイテムのレベルを i とする．選んだアイテムを取り除き，整数 k (1 ≤ k ≤ i) を選んでレベル i − 1, i − 2, ..., k のアイテムを 1 個ずつ追加する． 先に操作を行えなくなった方が負けである． ✒ ✑ このようなゲームの勝敗判定には Grundy 数が有用です．レベル i (i ≥ 1) のアイテムの Grundy 数を gi と します．すると，gi は • 0 • gi−1 • gi−1 ⊕ gi−2 • . . . • gi−1 ⊕ gi−2 ⊕ · · · ⊕ g1 に含まれない最小の非負整数です．実験すると，(g1, g2, g3, g4, g5, g6, g7, g8, . . .) = (1, 2, 1, 4, 1, 2, 1, 8, . . .) と なっています．実験結果から分かるように，gi = (i を割り切る最大の 2 の冪) であることが示せます．各ア イテムの Grundy 数の総 XOR が 0 でないならば Alice が勝ち，0 ならば Bob が勝ちます． 元の問題に戻ると，レベル i のアイテムは高さ i の平衡二分木に対応します．よって，初期状態におけるそ れぞれの完全二分木の高さを求められればよいことになります．これは，入力文字列から作られるトライ木を 辿り，子の個数がちょうど 1 個の頂点を見ていくことで可能です． 3 F: Squirrel Migration まず，移動距離の総和を最大化するような移動方法がどのようなものか考えます．そのために，移動距離 の総和の最大値がどのような値か考えます．まずは，移動距離の総和の上限を見積もってみましょう．あ る移動方法に対して，各辺 e について e を通過したリスの個数を se とします．すると，移動距離の総和 は ∑ e se となります．ここで，辺 e = (v, w) の v 側の頂点数を nv とし，w 側の頂点数を nw とすると， se ≤ 2 min{nv, nw} です．よって，移動距離の総和の上限はこれらの総和となります．実は，この上限を達 成するような移動方法が常に存在します．それは次のような移動方法です． 木の重心に注目します．重心は 1 個または 2 個です．重心が 1 個の場合，それを c とします．すると，ど のリスの移動経路にも c が含まれるとき，かつそのときに限り，移動距離の総和は上限を達成することが分か ります．また，重心が 2 個の場合，それらを c1, c2 とします．すると，どのリスの移動経路にも 辺 (c1, c2) が含まれるとき，かつそのときに限り，移動距離の総和は上限を達成することが分かります． 以上の移動方法を数え上げます．重心が 2 個の場合の方が簡単なので，先に考えます．重心を c1, c2 とし ます．さらに，c1 側の部分木を T1 とし，c2 側の部分木を T2 とします．このとき，木の頂点数 N は偶数で あり，T1, T2 の頂点数はともに N/2 です．T1 の各リスは，T2 のどの頂点へも移動できます．同様に，T2 の 各リスは，T1 のどの頂点へも移動できます．よって，移動方法は (N/2)! × (N/2)! 通りです． 次に，重心が 1 個の場合を考えます．重心を c とします．さらに，c の周りの部分木を T1, T2, ..., TK と します．このとき，c のリスはどの頂点へも移動できます．また，各 i について，Ti のリスは Ti 以外のどの 頂点へも移動できます．この移動方法を O(N2 ) 時間で直接数え上げるのは難しいです． そ こ で ，包 除 原 理 を 用 い ま す ．T := T1 ∪ T2 ∪ · · · ∪ TK と し ま す (す な わ ち ，T は 木 の 頂 点 集 合 か ら c を 除 い た も の)．す る と ，答 え は ∑ S⊆T (−1)|S|fS と な り ま す ．た だ し ，fS := 「( S 中の各リスは自分の部分木の頂点へ移動する」という条件を満たす移動方法の通り数) です．各 S1 ⊆ T1, ..., SK ⊆ TK について，次が成り立ちます． fS1∪···∪SK = ( N − ∑ K k=1 |Sk| ) ! ∏ K k=1 ( |Tk| |Sk| )2 |Sk|! よって，答えは ∑ S1⊆T1,...,SK⊆TK (−1) ∑K k=1 |Sk| ( N − ∑ K k=1 |Sk| ) ! ∏ K k=1 ( |Tk| |Sk| )2 |Sk|! と な り ま す ．( |Tk| |Sk| )2 |Sk|! の 部 分 は ，各 k ご と に 独 立 に 計 算 で き る こ と に 注 目 し ま す ．ま た ， (−1) ∑K k=1 |Sk| ( N − ∑K k=1 |Sk| ) ! の部分は，∑K k=1 |Sk| さえ分かっていれば計算できることに注目し ます． 以上の考察をもとに DP を設計します． • 定義: dpi,x := (∑i k=1 |Sk| = x のとき ∏i k=1 ( |Tk| |Sk| )2 |Sk|! の総和) ． • 初期化: dp0,0 = 1． • 遷移: 各 0 ≤ y ≤ |Ti | について，dpi,x+y に dpi−1,x × ( |Ti| y )2 y! を足し込む． x の状態数は O(N) で，遷移は 1 ≤ i ≤ K の合計で O(N) なので，全体の時間計算量は O(N2 ) となり，十 分に高速です．最終的に，∑N−1 x=0 (−1)x (N − x)! × dpK,x が答えです． 4 ABC #082 / ARC #087 Editorial writer : sugim48 December 16, 2017 A: Round Up the Mean • C++ Code Example : https://beta.atcoder.jp/contests/abc082/submissions/1872729 • Java Code Example : https://beta.atcoder.jp/contests/abc082/submissions/1872732 • Python 3 Code Example : https://beta.atcoder.jp/contests/abc082/submissions/1872734 B: Two Anagrams Sort s, sort t, reverse t, and check if s < t. • C++ Code Example : https://beta.atcoder.jp/contests/abc082/submissions/1872811 • Java Code Example : https://beta.atcoder.jp/contests/abc082/submissions/1872812 • Python 3 Code Example : https://beta.atcoder.jp/contests/abc082/submissions/1872814 C: Good Sequence Let nx be the number of occurrences of x in a. If nx < x, add nx to the answer. If nx ≥ x, add nx − x to the answer. • C++ Code Example : https://beta.atcoder.jp/contests/abc082/submissions/1872852 1 D: FT Robot Let N be the length of s and (xt, yt) be the coordinates of the goal. Let’s separate the sequence of operations by T, and let di be the number of F in the i-th part. Then, the movement of the robot can be described as follows: • Move d1 to right. • Move d2 upward or downward. • Move d3 to left or right. • Move d4 upward or downward. • Move d5 to left or right. • And so on. Thus, the x-coordinate and the y-coordinate can be handled independently. For example, for the x-coordinate, the robot will perform the following operations: • Move d1 to right. • Move d3 to left or right. • Move d5 to left or right. • And so on. We want to check if x can be xt after all operations. This can be done by a straightforward DP in O(N2 ). The y-coordinate can be handled similarly. 2 E: Prefix-free Game Let’s construct a trie of all strings of length L. It will be a complete binary tree. On this tree, the game can be described as follows: ✓ ✏ Initially, some vertices contain tokens. Alice and Bob alternately put tokens. Here, no two tokens can be put on two vertices with ”ancestor - descendant” relation. The player who fails to put a token loses. ✒ ✑ For example, the picture below shows the case with L = 3 and two strings 000 and 10. Blue vertices contain tokens, red vertices are forbidden, and you can put tokens on green vertices. The green vertices will be a disjoint union of complete binary trees, and each part (complete binary tree) can be handled independently. Thus, we can use Grundy Numbers. Let gi be the Grundy Number of a complete binary tree of height i (i.e., a complete binary tree with i layers). If you perform an operation on a complete binary tree of height i, it will be splitted into complete binary trees with heights i − 1, i − 2, ..., i − j for some j (0 ≤ j ≤ i − 1). Thus, gi is the smallest integer that doesn’t appear in the following: • 0 • gi−1 • gi−1 ⊕ gi−2 • . . . • gi−1 ⊕ gi−2 ⊕ · · · ⊕ g1 3 If you perform an experiment, you get (g1, g2, g3, g4, g5, g6, g7, g8, . . .) = (1, 2, 1, 4, 1, 2, 1, 8, . . .). In general, gi is the maximum power of two that divides i. (We omit the proof, it is straightforward.) If the XOR of all Grundy Numbers is 0, Bob wins, otherwise Alice wins. To get the set of green binary trees, you should construct a trie for all input strings, and check all nodes with exactly one child. 4 F: Squirrel Migration Consider an edge e = (v, w) in the tree. Let nv, nw be the sizes of two subtrees we get when we cut the tree by e. Then, the number of squirrels that pass through this edge (call it se) is st most 2 min{nv, nw}. The total distance defined in the statement is the sum of se, thus it is at most ∑2 min{nv, nw}. It turns out that this value is always achievable. There are two different cases: The tree has two centroids Call them c1, c2. The maximum can be achieved when all squirrels pass through an edge between c1 and c2. There are (N/2)! × (N/2)! such ways. The tree has one centroid Call it c. The maximum can be achieved when all squirrels pass through the vertex c. Let T1, T2, ..., TK be the subtrees we get when we remove c from the tree. We want to count the number of permutations such that for each i, no squirrel in Ti moves to a vertex in Ti . We use inclusion-exclusion principle. Let T := T1 ∪ T2 ∪ · · · ∪ TK (i.e., the entire vertex set minus c). The answer is ∑ S⊆T (−1)|S|fS, where fS is the number of permutations of squirrels such that each squirrel in S moves to a vertex in the same group. Now, for each k, we want to compute the sum of fS for all S such that |S| = k. Let gk be the number of ways to choose k squirrels and there destinations, such that all chosen squirrels will travel to a vertex in the same group. Formally, gk is the number of pairs of two k-tuples of vertices (s1, . . . , sk),(t1, . . . , tk) such that: • s1 < s2 < · · · (the order of chosen squirrels doesn’t matter) • For each i, si and ti are in the same subtree (and they are not c). • ti are pairwise distinct. Since we can freely choose destinations for unchosen squirrels, the sum of fS for all S such that |S| = k is gk(N −k)!. Therefore, the answer is ∑N−1 k=0 gk(N − k)!(−1)k . Since gk can be easily computed in O(N2 ) by a simple DP, we can also get the answer in O(N2 ). 5 AtCoder Beginner Contest 081 / AtCoder Regular Contest 086 解説 writer: semiexp 並びに anonymous 2017 年 12 月 9 日 For International Readers: English editorial starts on page 7. A: Placing Marbles それぞれの文字が 1 か 0 かを判定して 1 の数を数えればよいです．マスの数は高々 3 つなので，for 文を使わなくて も簡単に実装できます． #include <iostream> #include <string> using namespace std; int ans; string s; int main(){ cin >> s; if(s[0]=='1') ans++; if(s[1]=='1') ans++; if(s[2]=='1') ans++; cout << ans << endl; } 1 B: Shift only 黒板に書いてある整数を管理しておいて，「書かれている整数がすべて偶数である限り」「書かれている整数すべてを 2 で割る」をシミュレートすればよいです． あるいは，ほとんど同じことですが，最初書かれている整数それぞれに対して「最大で何回 2 で割れるか」を求め，そ の最小値をとってもよいです． • C++ による解答例: https://abc081.contest.atcoder.jp/submissions/1842477 • Python による解答例: https://abc081.contest.atcoder.jp/submissions/1842030 2 C: Not so diverse 「できるだけ少ない数のボールの整数を書き換える」というのは，「できるだけ多くのボールの整数を，変更しないま まにしておく」というのと同じです．ここで，変更を行わないボールたちに書かれている整数は K 種類以下でなければ なりません．逆に，これが K 種類以下なら，他のボールに書かれている整数も，変更しないでおくボールに書かれてい る整数から選んで書き換えることで，全体として書かれている整数を K 種類以下にすることができます． よって，問題は「整数を K 個選んで，それらのうちのどれかが書かれているボールの数を最大化する」と言い換えら れます．選ぶ整数としては，できるだけそれが書かれているボールの数が多いようなものから順に選んでいくのが最適 です． 最初書かれている整数として考えられるものは 1 以上 N 以下なので，各整数に対して「その整数が書かれているボー ルは何個あるか」を容易に求めることができます．この個数分布をソートして，大きいほうから K 個の和をとることで， 書き換えないボールの個数の最大値がわかります．あとは N からこの値を引くと，求める値を計算することができます． 3 D: Non-decreasing 簡単な場合から考えていきます．a が非負整数のみからなる場合を考えてみます．このとき，a の先頭からの累積和を 取った数列は明らかに条件を満たします．よって，a2+= a1, a3+= a2, . . . , aN += aN−1 という順番で操作をすればその ような数列を作ることができ，N − 1 回の操作で条件を満たすことができます．a が 0 以下の整数のみからなる場合も ほぼ同様の方法で N − 1 回の操作で条件を満たすことができます． a に負の数も正の数も含まれるとき，N 回以下の操作で a が非負整数のみからなるように，あるいは 0 以下の整 数からなるようにすることができるかどうかを考えてみます．MAX := max(a), MIN := min(a) とします．このとき， |MAX| ≥ |MIN| ならば，すべての数に MAX を足せば a を非負整数のみからなる数列にすることが可能です．同様に， |MAX| < |MIN| ならば，すべての数に MIN を足せば a を 0 以下の整数のみからなる数列にすることが可能です． 以上より 2N 回以下の操作で条件を満たすことができることが分かりました．これは O(N) で実行可能です． 4 E: Smuggling Marbles 同じ頂点の上に複数のビー玉が乗ったとき，木の上から取り除かれるという手順について考えます．ある 2 つの頂点 に置かれたビー玉が同じ頂点の上に乗るためには，これらの頂点の根からの距離が等しい必要があります．よって，根 からの深さ d の頂点にのみビー玉を置くとき，最終的に箱にビー玉が移動するようなビー玉の初期配置がいくつあるか を考えていくことにします． dp[i][j] = 頂点 i を根とする部分木に着目したとき，頂点 i に j(0 ≤ j ≤ 1) 個のビー玉が置かれるような頂点 0 からの 距離が d の頂点へのビー玉の配置の数，として DP をすることで O(N) で数え上げることができます．なお，DP の計算 途中では頂点にビー玉が置かれる個数が 2 個以上になりえますが，最終的に取り除かれるため 2 個として扱っても問題あ りません．こうして得られた結果は，深さ d 以外の頂点の配置を考慮していないので，dp[0][1] × 2 N−深さ d にある頂点の個数 が求めるべき答えです．これを各深さごとに行えば O(N2 ) で数え上げることができ部分点を獲得できます． ここで，この DP には無駄な遷移が多く含まれていることに着目します．例えば，ある頂点に複数個のビー玉が置か れるためにはその頂点の直接の子が 2 つ以上ある必要がありますが，先程の DP では子が 1 つしかないような場合でも 毎回計算を行っていました．これらをうまく無視して計算する方法を考えます． dp[i][d][j] = 頂点 i に j 個のビー玉が置かれるような，頂点 i から深さ d の頂点へのビー玉の初期配置の数，としま す．この DP の d についてデックを用いて動的に管理をします．d = 0 については，頂点 i のみ考えればよいため，最 後にデックの先頭に付け加えることにします．それ以外の深さの更新については以下の図 1 のように子頂点どうしの 2 つのデックのうち長さの短い方を長い方へとマージするような要領で更新をしていきます．このようにすることで全体 として O(N) で数え上げることができ，満点を獲得できます． 図 1: 頂点 r を根とする DP の更新の模式図 最後にこれが O(N log N) ではなく O(N) になることの概略を述べておきます．全ての頂点には 0 が書かれていると します．根から距離 d に ad 個の頂点があるとします．まずこれら ad 個の頂点たちを行きがけ順に並べます．その後， 隣り合う頂点のペア (u, v) について，それぞれ u と v の LCA(最小共通先祖) であるような頂点に 1 を加算します．こ のとき，各頂点に書かれた整数の数が，その頂点において，根から深さ d の頂点たちに対する DP の更新を行う必要が ある (あるいはデックのマージを行う) 回数になります．これらの和は明らかに ad − 1 回となります．よって，更新の回 数は O( ∑N d=0 max(0, ad − 1)) = O(N) となります． 5 F: Shift and Decrement 操作 B を行う回数を k とします．入力で与えられる整数は 1018 < 2 60 以下なので，0 ≤ k ≤ 60 として問題ありませ ん (60 回 B を行うとすべての整数が 0 になるため，61 回目を行う意味はありません)．i = 0, 1, . . . , k に対して，i 回目 の操作 B と i + 1 回目の操作 B の間で行う操作 A の回数を pi で表すことにします (ただし，p0 は「最初の操作 B を 行う前に行う操作 A の回数」，pk は「最後の操作 B を行った後に行う操作 A の回数」とします)． pi を 2d 減らして pi+1 を d 増やしても，黒板上の整数の書かれ方は変わらないことに注意します．このことから， i = 0, 1, . . . , k − 1 に対して，pi = 0 または pi = 1 としてよいということがわかります．(なぜならば，pi ≥ 2 であれ ば，pi を 2 減らして pi+1 を 1 増やすことで，最終的な黒板上の整数の書かれ方を保ちつつ，操作回数を減らすことが できるからです．) また，pi を 1 減らして p0 を 2 i 増やしても，黒板上の整数の書かれ方は変わらないことも従います． よって，{pi} に対応する一連の操作は，「操作 A を P = ∑k−1 i=0 2 ipi 回行い，操作 B を k 回行い，最後に操作 A を pk 回行う」一連の操作と等価です．pi = 0, 1 としたので，0 ≤ P ≤ 2 k − 1 が成り立ちます． Ai を 2 k で割った商を Bi，余りを Ci (0 ≤ Ci ≤ 2 k − 1) とします．また，Ci (i = 1, . . . , N) から重複を除去し，ソー トしたものを C ′ 1 ≤ C ′ 2 ≤ · · · ≤ C ′ M とします．0 ≤ P ≤ 2 k − 1 であることから，一連の操作によって Ai は次の値にな ることがわかります． • P ≤ Ci ならば，Bi − pk • Ci ≤ P ならば，Bi − pk − 1 よって，すべての i に対して「P ≤ Ci かどうか？」が同じであれば，異なる P に対しても同じ整数の書かれ方が得ら れることがわかります．ゆえに，考えるべき P は次のように区分されます． • 0 以上 C ′ 1 以下 • C ′ 1 + 1 以上 C ′ 2 以下 • . . . • C ′ M−1 + 1 以上 C ′ M 以下 ここで，P ごとに実際に行われる操作 A の回数は，2 進表記したときに現れる 1 の個数と等しいです．この操作回数を できるだけ少なくすることを考えると，P としては「区分の範囲内で，最も 2 進表記における 1 の個数が少なくなるも の」を用いるべきであることがわかります (具体的方法は後述します)．なお，C ′ M + 1 以上については，P = 0 として pk に 1 を加えるのと同じであることから，考える必要がありません． よって，各 k に対して考えるべき P の候補が M ≤ N 通りにまで絞られました．それぞれの候補に対して，最後の 操作 B を行うまでの操作回数を計算することができるので，pk の範囲を求めることができます．(ここで，負の整数が 現れてはいけないことに注意します．) 黒板に書かれているすべての整数に同じ整数を加減することで移り変わるような 整数の書かれ方同士を同じグループとみなすことにすると，pk を変更しても所属するグループは変わりません．なので， 考えるべきグループは全体で (k, P のとり方に対応して) 61 × N 個以下です．それぞれのグループごとに，「A1 は最終 的に何に書き換えられるか」としてありうる範囲の集合を求めることができます．このような範囲も合計で 61 × N 個 以下です．あとは，各グループごとに，範囲の重複を除いて可能なパターン数を求めればよいです． このアルゴリズムの計算量は，グループおよび範囲が全部で O(log Amax ·N) 個あり，グループのインデックスは N −1 要素の配列で管理できることから，O(log Amax · N2 log(log Amax · N)) になります． 最後に，X より大きく Y 以下の整数で (X < Y )，最も 2 進表記における 1 の個数が少なくなるものを求める方法を 述べておきます．2 進表記において X, Y で異なる値になる桁が存在するので，そのうち最も上位のものを l ビット目と します．すると，l ビット目より上位のビットについては，X, Y と同じにするほかありません．一方，l ビット目および それより下位のビットをすべて 0 にすることはできない (X 以下になるため) ので，少なくともこの範囲で一つは 1 が 必要です．ところで，l ビット目のみを 1 にし，より下位のビットはすべて 0 にすると，X より大きく Y 以下となりま す．よって，このようにして得られた整数が，最も 2 進表記における 1 の個数が少なくなるものになります． 6 AtCoder Beginner Contest 081 / AtCoder Regular Contest 086 Editorial writer: semiexp and anonymous December 10th, 2017 A: Placing Marbles #i n cl u d e <i o s t re am> #i n cl u d e <s t ri n g > u si n g namespace s t d ; i n t ans ; s t r i n g s ; i n t main ( ) { ci n >> s ; i f ( s [ 0]== ’ 1 ’ ) ans++; i f ( s [ 1]== ’ 1 ’ ) ans++; i f ( s [ 2]== ’ 1 ’ ) ans++; c ou t << ans << e n dl ; } B: Shift only • C++ implementation: https://abc081.contest.atcoder.jp/submissions/1842477 • Python implementation: https://abc081.contest.atcoder.jp/submissions/1842030 C: Not so diverse For each integer x between 1 and N, count the number of occurrences of x in the input, and sort it. The answer is N minus the sum of K greatest integers in the frequency list. 1 D: Non-decreasing In case all numbers in a are non-negative, the sequence of prefix sums (i.e., a1, a1 + a2, a1 + a2 + a3, · · ·) is nondecreasing. Thus, the sequence of operations ”a2+= a1, a3+= a2, . . . , aN += aN−1” satisfies the condition. Similarly, in case all numbers are non-positive, ”aN−1+= aN , aN−2+= aN−1, . . . , a1+= a2” satisfies the condition. In general, there are two cases. Let MAX := max(a), MIN := min(a). If |MAX| ≥ |MIN|, we first add MAX to all elements of a, and a will be a sequence of non-negative numbers. Then, we can make it non-decreasing as we described above. Similarly, if |MAX| < |MIN|, we first add MIN to all elements of a, and a will be a sequence of non-positive numbers. In both cases, we need 2N − 1 operations. This solution works in O(N). 2 E: Smuggling Marbles When multiple marbles are on the same vertex, they will be removed. This happens only when the marbles come from vertices of the same depth. Thus, we can handle each depth independently. For each d, consider all subsets of vertices of depth d, and count the number of subsets that will end up with a single marble at the root. How can we solve this problem for a fixed d? For simplicity, from now on, we use probabilities - each vertex initially contains a marble with probability 1/2. Let dp[i][j] be the probability that vertex i contains j(0 ≤ j ≤ 1) marble at the end, when we only consider the subtree rooted at i (and initially we put marbles only on vertices of depth d). The answer is sum of dp[0][1] × 2 N over all depths. This solution works in O(N) per depth, and O(N2 ) in total. You can get partial score. To make it faster, we compute these values for all depths at once. Let dp[i][d][j] be the following value: Consider a subtree rooted at vertex i. We put marbles to some vertices of depth d (i.e., the distance to i is d), with probability 1/2 for each such vertex. What is the probability that vertex i contains j marbles at the end? Let’s call a tuple of three doubles dp[i][d] = (dp[i][d][0], dp[i][d][1], dp[i][d][2]) ”state”. Here, j = 2 means that a vertex contains two or more marbles (it happens during the computation, as described below). Then, dp[i] is a sequence of states (dp[i][0], dp[i][1], ...) and its length is (the depth of subtree rooted at i) plus one. We represent it as a deque of states. The figure below shows how to compute dp[r] when it has three children a, b, c. While r has two or more children, we ”merge” the shortest deque into the second shortest deque. For example, if dp[a][i] contains x marbles and dp[b][i] contains y marbles, the new deque dp[ab][i] will contain min(x + y, 2) marbles. It can be done in O(min(len(dp[a]), len(dp[b]))). Make sure that you don’t create a new deque - if len(dp[a]) > len(dp[b]), reuse dp[a], and rewrite its first len(dp[b]) elements. Then, if r has only one children, you just need to push a state (1/2, 1/2, 0) to the front. Don’t forget to convert j = 2 to j = 0 at the end. Why is it O(N) (and not O(NlogN))? Suppose that initially all vertices contain 0. Let ad be the number of vertices of depth d. First, we sort these vertices in dfs pre-order. For each consecutive pair of two vertices (u, v) (of depth d), add 1 to the integer written on LCA of u and v. Then, the integers written on each vertex represents the number of merges that comes from vertices of depth d. The sum of those integers is ad − 1. Thus, the total number of merges is O( ∑N d=0 max(0, ad − 1)) = O(N). 3 F: Shift and Decrement Suppose that we perform operation A k times. Since 1018 < 2 60, we can assume that 0 ≤ k ≤ 60 (after 60 operations all numbers will be zero)．For each i = 0, 1, . . . , k, let pi be the number of operation Bs we perform between i-th A and i + 1-th A. (p0 and pk are defined naturally). An operation A maps an integer x to floor(x/2), and an operation B maps an integer x to x − 1. Notice that we don’t need to take floor after each opertaion A - instead, we compute numbers as doubles, and only at the end of all operations we apply the floor function. Thus, the sequence of operations is equivalent to the following: • Perform operation B P = ∑k−1 i=0 2 ipi times. • Perform operation A k times. • Perform opertaion B pk times. Also, we can assume that 0 ≤ P ≤ 2 k −1 (otherwise, we can decrease P by 2k and increment pk by one, and decrease the total number of operations). Let Ai = 2k × Bi + Ci (0 ≤ Ci ≤ 2 k − 1). Let C ′ 1 ≤ C ′ 2 ≤ · · · ≤ C ′ M be a sorted list of integers that appear in C (after removing duplicates). After all operations, the value of Ai will be following: • If P ≤ Ci , Bi − pk • If Ci ≤ P, Bi − pk − 1 Thus, the only important thing for P is ”Is P ≤ Ci?” for each Ci . P will be in one of the following intervals: • [0, C1] • [C1 + 1, C2] • . . . • [CM−1 + 1, CM] The number of opertaion Bs in the first phase is popcount(P) (the number of 1s in the binary representation of P). Thus, in each interval, we should choose P that minimizes this value (see below for the way to compute P). Now, for each k, we have only M ≤ N candidates for P. For each candidate, we can compute the valid range for pk (to make the total number of opertaions at most K, make sure that it won’t be negative). We consider two sequences of integers to be in the same group if we can convert one of them to the other by performing operation Bs. Since the value of pk doesn’t affect its group, we need to consider at most 61 × N groups (at most one group per each (k, P) pair). For each group, compute the possible range for A1 (the total number of those ranges is also at most 61 × N). Then, for each group, we compute the number of possible values for A1 (after remoging duplicates). There are O(log Amax ·N) groups and ranges, and since each group can be represented as a sequence of length N −1, this solution works in O(log Amax · N2 log(log Amax · N)) time. Now, we describe how to compute an integer between X + 1 and Y (X < Y ) that minimizes its popcount. Let l be the largest integer such that the l-th digits in X and Y differ. Since the integer we choose must be between X + 1 and Y , all digits above l-th must be the same as X, Y . If we make the l-th digit one and the remaining digits zero, the number will be between X + 1 and Y . This is optimal because it only adds one to popcount (and we can’t make all digits up to l-th zeroes because the number must be at most X + 1). 4 ARC 085/ABC 078 解説 Kohei Morita(yosupo) 平成 29 年 11 月 11 日 For International Readers: English editorial starts on page 8. A: HEX 16 進数に直さずとも，実は入力した文字の ASCII コードを比較するだけ で十分です (C, C++ならば char 型のまま比較すれば ASCII コードで比較で きます)。 想定解 1 B: ISU 人が n 人座るためには椅子の幅は何センチメートルあればよいでしょうか？ これは Y × n + Z × (n + 1) センチメートルです。Y × n が人の占有する 幅で，Z × (n + 1) が人と人，人と椅子の間に開ける幅です。 よって n = 1, 2, ... と順に増やしていき，座れる人数のうち最も多い人数を 調べればよいです。なお，人数の最大は入力例 3 の 49999 人です。 想定解 2 C: HSI 1 回の実行にかかる時間を x ms，全てのケースに正解する確率を p，この 問題の答えを y ms とします。x = 1900M + 100(N − M), p = 1/2M です。 まず，一回目の提出で必ず x ms はかかります。その後は，確率 p で終了し ます，そして確率 1 − p でその提出には失敗し，更に提出を繰り返します。確 率 1 − p で失敗した場合の，その時点からかかる時間の期待値は y ms です。 よって，y = x + (1 − p) × y が成立し，これを解くと y = x/p が得られ ます。 よって答えは x/p = (1900M + 100(N − M)) × 2M です。 3 D: ABS まず，N=1 の場合の答えは |a1 − W| です。 2 ≤ N の場合を考えます。X は初手で全部のカードを引くことにより， |aN − W| が達成できます。また，初手で N − 1 枚のカードを引くことで |aN−1 − aN | が達成できます。 実は，初手で行うべき操作はこの 2 通りのみ，つまり 2 枚以上カードを残 す理由はありません。なぜならば，その直後の手番で Y さんは，残り 1 枚に なるようにカードを引くと |aN−1 −aN | を達成できます。よって 2 枚以上カー ドを残してもスコアが |aN−1 − aN | より高くなることはないからです。 以上より，この問題の (2 ≤ N の時の) 答えは max(|aN −W|, |aN−1 −aN |) です。 4 E: MUL 結論から言うと，この問題は最大流問題の双対問題である最小カットを使 い解くことができます。 具体的には，頂点 S, V, 1, 2, ..., N を用意し，各 i について， • ai ≤ 0 ならば，S → i に容量 −ai の辺を張る • ai > 0 ならば，i → T に容量 ai の辺を張る • 各 j = 2i, 3i, 4i, ... について，i → j に容量 ∞ の辺を張る と辺を張り，ai > 0 なる ai の総和から，構築したグラフの最小カットを引 いたものが答えです。 最小カット問題の答えは最大流問題を解くことで得られます。頂点数がO(N) で，変数は O(N log N)，そして N ≤ 100 と小さいため，計算量が流量に依 存しない最大流アルゴリズムならだいたい間に合うと思います。 理由 最小カット問題とは，S, T 以外の頂点を S 側と T 側に振り分け，S 側から T 側へ張られる辺の容量の総和を最小化する問題です。 ここで，S 側を 0，T 側を 1 として見ると，S には 0, T には 1，それ以外の 頂点には 0, 1 を割り振り，(0 が割り振られた頂点) から (1 が割り振られた頂 点) へ張られる辺の容量の総和を最小化する問題，と考えられます。 これを更に言い換えると，以下のような問題が解けることがわかります。 • 変数 qs, qt, q1, q2, ..., qv を考える • 罰金条件 (x, y, z) がたくさん与えられる。これは，qx が 0 で qy が 1 な ら罰金 z 円，という意味である。 • あなたは変数にそれぞれ 0, 1 のどちらかを割り当て，罰金を最小化し たい。ただし qs = 0, qt = 1 は固定である。 当然，変数が頂点，罰金条件が辺に対応します。なお，罰金条件の罰金 z は 必ず非負でないといけないことに注意してください。非負を許した場合，こ の問題は最大カット問題も含み，NP-hard となります。 では，元の問題をこのような問題に変形することを考えます。 まず，ある i, j(j は i の倍数) について，i が破壊されていて，j が破壊され ていない場合，明らかにおかしいです。 よって，この条件を表すために，i が破壊されていて j が破壊されていない と罰金 ∞ 円とすることを考えます。 5 これは，(0 を割り振る)=破壊されている，(1 を割り振る)=破壊されてい ない，とし，罰金条件 (i, j, ∞) を足せばよいです。 実は，全ての i, j(j は i の倍数) について，「i が破壊されているならば，j が 破壊されている」が成立する場合，このような破壊の方法が存在します。 よって，あとは破壊されていないと ai 円，つまり qi = 1 ならば ai 貰える， という処理です。 ai ≤ 0ならばこれは罰金と考えられるので問題ないです。罰金条件(S, i, −ai) を足します。 ai > 0 ならば，言い換えて，「i が破壊されていると，ai 円が貰えない=ai 円罰金」と考えます。すると事前に答えに ai を貰っておくことにし，罰金条 件 (i, T, ai) を足します。 以上より，この問題は最小カット問題に帰着できました。 今回の問題は N 個の宝石に破壊された，破壊されていない，の 2 つの状態 を割り振る問題でした。このように，幾つかの要素に 2 つの状態を割り振り， 何かを最大化/最小化する問題で，更に DP ではとても解けそうにない場合， 最小カットを疑うとよいです。 6 F: MUL この問題は，ai ̸= bi，つまり (ai , bi) = (0, 1),(1, 0) の個数を最小化する問 題です。 ((ai , bi) = (0, 1),(1, 0) の個数) = ((ai , bi) = (0, 1) の個数) + ((ai , bi) = (1, 0) の個数) = ((ai , bi) = (0, 1) の個数) + (bi = 0 の個数) − ((ai , bi) = (0, 0) の個数) であり，bi = 0 の個数は定数であるため，((ai , bi) = (0, 1) の個数) − ((ai , bi) = (0, 0) の個数) を最小化することを考えても良いです。 言い換えると，ai = 1，つまり塗った場合のコストは 0 で，塗らなかった 場合のコストは 1 だったり −1 するので，コストの総和を最小化してくださ いという問題です。 操作それぞれについて行うかどうかを全探索していてはとても間に合いま せん。うまく探索する必要があります。 操作を行うかどうかとスコアの計算を並び換え， li = 1 の操作たちを行うかどうか決め，a1 のスコアを計算する → li = 2 の操作たちを行うかどうか決め，a2 のスコアを計算する → li = 3 の操作たちを行うかどうか決め，a3 のスコアを計算する → li = 4 の操作たちを行うかどうか決め，a4 のスコアを計算する → … という風に，操作を行うかどうかとスコアの計算を交互に行うことを考え ます。このような順番にしても答えは変わりません。 なぜこのような順番にするかというと，ax のスコアを計算した後はa1, a2, ..., ax の色は忘れてよく，更に ax+1, ax+2, ..., aN については，あるところまでは 1， その後全て 0 という形になっているからです。 よって，この並び替えを行うだけで (まだ TLE ですが)DP を行い，計算量 を多項式にすることができます。DP のキーは (x, y) の 2 つで，「ax のスコア まで計算し，ay まで 1 になっている」という状態を現します。 (x, x),(x, x+ 1),(x, x+ 2), ...,(x, N) から (x+ 1, x+ 1),(x+ 1, x+ 2),(x+ 1, x + 3), ...,(x, N) まで同時に遷移することを考え，この遷移を SegTree で 高速化します。 区間 l(= x), r の操作については，(x, x),(x, x + 1), ...,(x, r) の最小値を (x + 1, r) に遷移させれば良いです。ax のスコアを計算する，のパートは簡 単です。最初の考察により，ax = 0，つまり y = x の場合以外はスコアが 0 だからです。 以上より，区間の min を取るのが本質であり，この操作は SegT ree で簡 単に実装できます。 7 ARC 085/ABC 078 Editorial Kohei Morita(yosupo) November 11, 2017 A: HEX https://abc078.contest.atcoder.jp/submissions/1751369 B: ISU https://abc078.contest.atcoder.jp/submissions/1751697 C: HSI Let x = 1900M + 100(N − M) be the time required to submit (and judge) one solution. Let p = 1 2M be the probability that one submission passes. Let y be the answer of this problem. It takes x ms to submit once. With probability p, it passes and the process ends, and with probability 1−p, you need more submissions and you need y ms more on average. Thus, you get y = x + (1 − p) × y, and y = x/p. Therefore, the answer is y = x/p = (1900M + 100(N − M)) × 2M. D: ABS If N = 1, the answer is |a1 − W|. Suppose that 2 ≤ N. X can achieve the final result of |aN − W| all cards in his first turn. Also, X can achieve the final result of |aN−1 − aN | by drawing N − 1 cards in his final turn. It turns out that X can’t do better than the two strategies above. Suppose that X leaves at least two cards (k cards) in his first turn. Then, Y can take k − 1 cards in the next turn and the result will be |aN−1 − aN |. Therefore, the answer is max(|aN − W|, |aN−1 − aN |). 1 E: MUL Let’s solve this problem as a minimum S-T cut problem. We divide all integers 1, 2, . . . , N into two groups. Group S is a set of integers that are smashed, and Group T is a set of integers that are not smashed. Ideally, we should smash all integers with negative costs, and we shouldn’t smash any integers with non-negatove costs. Let X be the total money you can get in this ideal situation. However, this situation is not always possible. If for some i, j such that j is a multiple of i, i is smashed and j is not smashed, we get a contradiction. (Note that this is a sufficient condition: if a set of integers satisfies this condition, we can perform operations on all smashed integers and still we don’t smash anything else.) Now, you get the following penalties: • If for some i, j such that j is a multiple of i, i is in group S and j is in group T, we get an infinite penalty. • If ai ≤ 0 and i is in group T, we get a penalty of −ai . • If ai > 0 and i is in group S, we get a penalty of ai . To represent these penalties, construct the following graph: Construct a graph with N + 2 vertices. The vertices are labelled with S, T, 1, 2, ..., N, and for each i, we add the following edges: • If ai ≤ 0, add an edge S → i with capacity −ai . • If ai > 0, add an edge i → T with capacity ai . • For each j = 2i, 3i, 4i, ..., add an edge i → j with capacity ∞. The answer is X minus the minimum S-T cut of the graph above. Since there are O(N) vertices and O(N log N) edges, it works in time. 2 F: NRE In this problem, we want to minimize the number of i such that ai ̸= bi , that is, (ai , bi) = (0, 1)or(1, 0). The number of i such that (ai , bi) = (0, 1),(1, 0) = (The number of i such that(ai , bi) = (0, 1)) + (The number of i such that bi = 0) - (The number of i such that (ai , bi) = (0, 0)) Here, since the number of i such that bi = 0 is a constant, we want to minimize (The number of i such that(ai , bi) = (0, 1)) - (The number of i such that (ai , bi) = (0, 0)) In other words, when you paint the i-th cell (ai = 1), there’s no cost, and when you don’t paint it (ai = 0), you get a cost of 1 or −1. Let’s perform the operations and compute the cost in the following order: Perform some operations with li = 1 and compute the cost of a1 → Perform some operations with li = 2 and compute the cost of a2 → Perform some operations with li = 3 and compute the cost of a3 → Perform some operations with li = 4 and compute the cost of a4 → … Here, after you compute the cost of ax, you can forget about a1, a2, ..., ax, and at this point, ax+1, ax+2, ..., aN is of the form ”111...111000...000”. Therefore, we get the following DP, and it works in polynomial time. dp(x, y) means the minimum possible cost you get from a1, . . . , ax, given that at this point ax+1, . . . , ay = 1 and the remaining elements are zeroes. Now, how can we get the DP values of (x+ 1, x+ 1),(x+ 1, x+ 2),(x+ 1, x+ 3), ...,(x, N) from (x, x),(x, x + 1),(x, x + 2), ...,(x, N)? To handle an operation in the interval [l(= x), r], we replace (x + 1, r) with the minimum of (x, x),(x, x + 1), ...,(x, r). It’s easy to compute the cost of ax because when ax = 0, you get no cost. Therefore, the only data structure you need is to get the minimum of an interval, and this can be done in segment tree (or RMQ). 3 ARC084/ABC077 解説 DEGwer 2017/11/04 For International Readers: English editorial starts on page 5. A: Accepted...? 改行を無視して 6 文字を読み込み、1 文字目と 6 文字目、2 文字目と 5 文字目、3 文字目と 4 文字目がそれぞれ等しいかどうかを調べればよいです。 以下の実装では、1 文字目から 3 文字目までを配列 a に、4 文字目から 6 文字目までを配列 b に、それぞれ読み込んでいます。 #i n cl u d e <s t d i o . h> i n t main ( ) { ch a r a [ 1 0 ] , b [ 1 0 ] ; s c a n f (”% s%s ” , a , b ) ; i f ( a [ 0 ] == b [ 2 ] && a [ 1 ] == b [ 1 ] && a [ 2 ] == b [ 0 ] ) p r i n t f ( ”YES\n ” ) ; e l s e p r i n t f ( ”NO\n ” ) ; } 1 B: Different Distribution 答えの候補を小さい順に試していきます。i 2 が n を初めて超えたときの、(i − 1)2 が答えです。 #i n cl u d e <s t d i o . h> i n t main ( ) { i n t num; s c a n f (”%d ” , &num ) ; f o r ( i n t i = 1 ; ; i++) { i f ( i ∗ i > num) { p r i n t f (”%d\n ” , ( i − 1 ) ∗( i − 1 ) ) ; break ; } } } C: Snuke Festival Ai < Bj < Ck なる組 (i, j, k) の個数を数える問題です。j を固定すれば、求める個数は Ai < Bj なる i の個数と、Bj < Ck なる k の個数の積となります。 よって、全ての j に対し、上述の i, k の個数を数えて掛け合わせ、足し合わせればよいです。 では、i の個数や k の個数はどのように求めればいいでしょうか？　愚直に配列をすべて見る と、O(N2 ) となり間に合いません。 配列 A, C をあらかじめソートしておきます。すると、i や k の個数は、二分探索を用いて求めるこ とができます。C++ の場合、標準ライブラリに用意されている lower bound 関数や upper bound 関数を用いるのが良いでしょう。 時間計算量は O(NlogN) となり、間に合います。 D: Small Multiple 全ての正整数は、1 から始めて、以下の 2 つの操作を繰り返すことで作ることができます。 • 今の数に 1 を足す。このとき、各桁の和は 1 増える。(1 の位が 9 のときはこの限りではあ りませんが、この問題を解くにあたっては考慮しなくていいことをあとで示します) • 今の数を 10 倍する。このとき、各桁の和は変わらない。 さて、全ての正整数を頂点とし、以上の操作の「今の数」から「新しい数」に辺をはったグラフ を考えます。求めるべきは、1 から K の倍数のうちのいずれかへの、このグラフ上での最短経路 長に 1 を足したものです。 2 このままでは頂点数は無限ですが、辺のはられ方を考えれば、各正整数に対応する頂点たちは modK で同一視できることが分かります。よって、各頂点を modK で同一視した K 頂点のグラ フ上で、1 から 0 への最短路を求めればよく、これは 01BFS を用いることで O(K) 時間で求める ことができます。1 の位が 9 の整数に 1 を足す遷移は、最短路のアルゴリズムを思い出せば行き 先の頂点がすでに訪れられていることがわかるので、特別に扱う必要はありません。 なお、01BFS とは、deque (両端キュー) を用意し、コスト 0 の辺の遷移は deque の先頭に、1 の辺の遷移は deque の末尾に要素を追加することによる、幅優先探索のアルゴリズムです。 E: Finite Encyclopedia of Integer Sequences 数列に使える整数の種類数 K が偶数の場合、最初の整数が K/2 以下である数列と K/2 + 1 以 上である数列の個数は等しいので、答えは K/2 の後に K が N − 1 個続いた数列になります。以 下 K が奇数の場合を考えます。 (K + 1)/2 が N 個続いた数列 (これを B とおく) の前にある数列の個数と、後ろにある数列の個 数の差はいくつでしょうか？　ある数列 X が B の前にあるとき、X の各要素 Xi を K + 1 − Xi で置き換えれば、X が B の接頭辞でない限りは、B の後ろにきます。逆に、ある数列 X が B の 後ろにあるとき、同様に置き換えれば、X が B の接頭辞でない限りは、B の前にきます。 よって、B の接頭辞以外の数列については B の前にある数列と後ろにある数列の間で一対一対 応が成り立つため、B の前後の数列の個数の差は、B の接頭辞の個数、すなわち N − 1 になりま す。すなわち、求める数列は、B の ⌊ N−1 2 ⌋ 個前にある数列になります。 さて、これはどのように求めればいいでしょうか？　 1 個前の数列を得る操作は、 • 末尾が 1 の場合、取り除く • 末尾が 1 でない場合、その整数を 1 減らし、さらに N 文字になるまで末尾に K を付け加 える という操作です。これはならし O(1) 時間で実装できるので、この問題を O(N) 時間で解くこと ができました。 F: XorShift 与えられた 2 進数たちを、F2 上の多項式として見ます。すなわち、2 進数 akak−1 . . . a1a0 を、 多項式 akx k + ak−1x k−1 + . . . + a1x + a0 と同一視し、さらにその係数は mod2 で見ることにし ます。 操作を多項式の言葉に翻訳します。数を 2 倍することは多項式を x 倍することに、数同士の xor を取ることは多項式同士の和を取ることに対応します。 多項式を 2 つとってきます。次数の大きいほうを P 、小さいほうを Q として、その次数の差 を d とします。Q を d 回 x 倍し、P と足し合わせることで、P より次数の低い多項式を作ること ができます。こうしてできた多項式を新しい P として (適宜 P, Q を入れ替えて) 同様の操作を続 けるアルゴリズムは、ユークリッドの互除法にほかなりません。すなわち、2 つの多項式の GCD を黒板に書くことができます。 これを繰り返せば、最初に黒板に書かれた多項式たちすべての GCD である多項式 P を黒板に 書くことができます。また、全ての多項式は P を因子に持ち、操作によってその性質が崩される 3 ことはないため、黒板に書ける多項式は P の倍数のみです。さらに、x 倍をする操作と和を取る 操作を適切に繰り返せば、P の任意の多項式倍を黒板に書くことができます。よって、黒板に書け る多項式は P の倍多項式全てです。 この多項式たちの中で、2 進数として見て X 以下のものの個数を数えましょう。P の次数を d とします。P の倍多項式の d 次以上の係数がすべて定まれば、残りの係数は一意に定まります。d 次以上の部分が X の d 次以上の部分より (2 進数としてみて) 小さいようなものに対しては、ちょ うど 1 個の P の倍多項式が定まります。等しいものに対しては、その d − 1 次以下の係数を実際 に求め (これは高次の係数から順に決めて行くことで求められます)、X より小さいかどうかを調 べればよいです。 時間計算量は、GCD は 1 回あたり O(d 2 ) 時間で求められ (ただし、d は与えられる整数の桁 数)、O(N d2 ) となります。また、bitset などを用いて xor を並列的に計算することで、(m = 32 または 64 として) O(N d2/m) 時間で計算することも可能です。 4 ARC084/ABC077 Editorial DEGwer 2017/11/04 A: Accepted...? #i n cl u d e <s t d i o . h> i n t main ( ) { ch a r a [ 1 0 ] , b [ 1 0 ] ; s c a n f (”% s%s ” , a , b ) ; i f ( a [ 0 ] == b [ 2 ] && a [ 1 ] == b [ 1 ] && a [ 2 ] == b [ 0 ] ) p r i n t f ( ”YES\n ” ) ; e l s e p r i n t f ( ”NO\n ” ) ; } 1 B: Different Distribution #i n cl u d e <s t d i o . h> i n t main ( ) { i n t num; s c a n f (”%d ” , &num ) ; f o r ( i n t i = 1 ; ; i++) { i f ( i ∗ i > num) { p r i n t f (”%d\n ” , ( i − 1 ) ∗( i − 1 ) ) ; break ; } } } 2 C: Snuke Festival We want to compute the number of triplets (i, j, k) such that Ai < Bj < Ck. If we fix j, the number of such triplets is the product of the number of i such that Ai < Bj and the number of k such that Bj < Ck. Therefore, for each j, we compute the number of i, k mentioned above, and we can get the answer. How can we compute the number of such i (or k) for all j? Straightforward solution works in O(N2 ) and too slow. Let’s sort A, C in advance. Then, the number of such i (or k) can be computed using a binary search. This solution works in O(NlogN) time. 3 D: Small Multiple All positive integers can be obtained by performing the following two types of operations to 1 zero or more times: • Add 1. By this operation, the sum of digits increases by one (unless the last digit is 9, but this is not important). • Multiply the current number by 10. The sum of digits remains the same. Construct a graph with infinite number of vertices. Each vertex corresponds to a positive integer. In this graph, • For each x, we add an edge from x to x + 1 with cost 1. • For each x, we add an edge from x to 10x with cost 0. The answer is (the shortest distance from 1 to one of multiples of K in this graph) plus one. We can compree this graph to K vertices. When x ≡ y (mod K), assume that x and y are the same vertex. Then, in this graph, the answer is the shortest distance from 1 to 0, plus one. This can be done in O(K) by 01-bfs (a variant of Dijkstra’s algorithm, when all costs are 0 or 1, you can use a deque instead of priority queue). Note: Isn’t the trouble with ’9’ important? Suppose that the algorithm above finds an invalid solution that contains a digit ”10” at position i. However, due to the periodicity of powers of tens, (when K is comprime to 10) we can find another j such that 10i and 10j are the same in modulo K, so we can move one digit from i to j. Even when K is not coprime to 10, we can make it periodic by attaching sufficient number of zeroes at the end. 4 E: Finite Encyclopedia of Integer Sequences If K is even, exactly half of sequences starts with an integer K/2 or less. Thus, the answer is K/2 followed by N − 1 occurrences of K. Suppose that K is odd. Let B be a sequence that contains N occurrences of (K + 1)/2 (this is very close to the middle). What is the difference between the number of sequences before B and after B? For a sequence X, let f(X) be a sequence such that Xi in X is replaced with K + 1 − Xi . This is almost an bijection from a sequence after B to a sequence before B. The only exception happens for prefixes of B. Therefore, the difference is N − 1 (the number of non-trivial prefixes of B), and B is the ceil(X/2) + floor(N/2)-th sequence. We start with B, and repeat the following operation ⌊ N−1 2 ⌋ times: • If the current sequence ends with 1, remove it. • Otherwise, decrement the last element by 1, and while the sequence contains less than N elements, attach K at the end. This operation takes O(1) on average, so the amortized complexity of this solution is O(N). 5 F: XorShift Let’s interpret the given binary numbers as polynomials on F2. That is, a binary number akak−1 . . . a1a0 corresponds to a polynomial akx k+ak−1x k−1+. . .+a1x+a0, here the coefficients are computed modulo 2. You can perform the following operations for the polynomials: • Multiply a polynomial by x. (corresponds to ”double”) • Compute the sum of two polynomials. (corresponds to ”xor”) Let P, Q be two given polynomials, and suppose that degP > degQ. By computing P ′ = P + (Q ∗ x degP −degQ), you can get a polynomial whose degree is smaller than P. Then, you can repeat the same operation for two polynomials P ′ and Q (when necessary, you swap P and Q). This is similar to Euclid’s algorithm, and you will eventually get gcd(P, Q). Let G be the GCD of all given polynomials. As we see above, we can write G on the blackboard. Then, by using the two types of operations properly, you can write all multiples of G (H is a multiple of G if H can be written as H = H′G using some polynomial H′ ). On the other hand, all polynomials on the blackboard are always divisible by G. Therefore, we want to compute the number of polynomials P such that: • P is a multiple of G. • P is less than or equal to X (as a binary number). Let d = degG and D = degX. If we know all coefficients of a polynomial except for the last (least significant) d coefficients, we can uniquely determine the remaining d coefficients to make it a multiple of G. Therefore, if the first D − d + 1 coefficients of P are smaller than that of G (as a binary number), we can uniquely determine P. If the first D − d + 1 coefficients are the same, we compute the remaining d coefficients and compare it with X. It takes O(d 2 ) time per one gcd computation (where d is the number of digits), thus the complexity of this solution is O(N d2 ). This is fast enough. You can also use bitsets to achieve O(N d2/m) (m = 32or64). 6 ARC083 / ABC074 解説 三谷庸 (wo01) 2017 年 9 月 16 日 For International Readers: English editorial starts on page 6. A 問題 N × N のマス目にはマスが N2 個あります。そのうち A マスを白く塗る ので、黒く塗るマスは N2 − A 個あります。 したがって、入力から N, A を読み込んで N2 − A を出力すればよいこと になります。 以下に C++ によるコード例を示します。 #include<cstdio> using namespace std; int main(){ int N, A; scanf("%d%d", &N, &A); printf("%d\n", N * N - A); return 0; } B 問題 i 番目のボールは i 番目のタイプ A のロボット、または i 番目のタイプ B のロボットで回収できます。タイプ A のロボットで回収するときはロボット の移動距離は 2xi となり、タイプ B のロボットで回収するときはロボットの 移動距離は 2(K − xi) となります。 i = 1, 2, . . . , N について順にボールの位置を見ていき、2xi と 2(K − xi) のうち小さい方 (同じであるときはその値) を足し合わせれば答えが求まり ます。 1 以下に C++ によるコード例を示します (このコード例ではループの各段 階ではなく最後に答えを 2 倍しています)。 #include<cstdio> #include<algorithm> using namespace std; const int MAX_N = 100; int N, K; int X[MAX_N]; int main(){ scanf("%d", &N); scanf("%d", &K); for(int i = 0; i < N; ++i){ scanf("%d", X + i); } int ans = 0; for(int i = 0; i < N; ++i){ int tmp = min(X[i], K - X[i]); ans += tmp; } printf("%d\n", ans * 2); return 0; } C 問題 ビーカーにちょうど x [g] の水を入れられる必要十分条件は、非負整数 i, j が存在して x = 100Ai + 100Bj となることです。同様に、ビーカーに y [g] の砂糖を入れられる必要十分条件は、非負整数 i, j が存在して y = Ci + Dj となることです。 x, y としては F 以下の値だけを考えればよいので、x, y としてありうる値 は O(F 2 ) 時間かけてすべての i, j を試すことで列挙できます。 最後に、すべての (x, y) の組 (O(F 2 ) 個しかありません) について、ビー カーに水を x [g] と砂糖を y [g] 入れたときに砂糖が水にすべて溶けているか どうか調べ、溶けているものについて濃度が最大のものをとって出力すれば よいです。 2 D 問題 都市を頂点、道路を辺としてグラフ理論の言葉で説明します。 条件を満たすグラフが存在するとき、任意の頂点 u, v について、これら の間には辺がないか、長さ Au,v の辺があるかのどちらかとなります。なぜ なら、 • u, v の間に Au,v よりも長い辺があった場合、この辺は取り除いても最 短距離に影響を与えず、 • u, v の間に Au,v よりも短い辺があった場合、u, v 間の最短距離は明 らかに Au,v よりも短くなる からです。 グラフ G を任意の u, v の間に長さ Au,v の辺を張ったグラフとします。上 の考察より、G の部分グラフに関してのみ考えればよいことになります。 どの頂点間に辺を張る必要があるか考えます。 A (の対角線上以外の要素) のうち Au,v が最小値であるとき、A が最短距 離を表す表であるようなグラフには u と v を長さ Au,v で結ぶ辺が必要です。 なぜなら、そうでないとすると他の頂点 w を経由して頂点 u から頂点 v ま で距離 Au,v で移動できる必要がありますが、そのとき頂点 u と頂点 w の距 離は Au,v よりも小さくなるからです。 同様に G のすべての辺について短い方から見ていくことで、求めるべきグ ラフは以下のとおりであることがわかります (G から辺 {u, b} を取り除いた グラフを G\{u, v} と書いています)。 • ある u, v について、G\{u, v} における uv 最短距離が Au,v 未満であ るとき、条件を満たすグラフは存在しない。 • そうでないとき、G\{u, v} における uv 最短距離が Au,v より大きいよ うな u, v に限り辺を張ったグラフが求めるべきグラフである。 G\{u, v} における uv 最短路の長さを A′ u,v と書くことにします。A′ u,v と Au,v の大小を比較するために、まず G における全点対最短距離を WarshallFloyd 法を用いて求め、その値を B とします。 Bu,v < Au,v となる u, v が存在するとき、この u, v について、A′ u,v = Bu,v < Au,v となります。よって条件を満たすグラフは存在しません。 あとは、任意の u, v について Au,v = Bu,v であったとして、A′ u,v が Au,v と 等しいか、それより大きいかを判定できればよいことになります。A′ u,v = Au,v であることは、以下と同値です。 ∃w, u ̸= w, v ̸= w, Bu,v = Bu,w + Bw,v (1) 3 実際、A′ u,v = Au,v のとき、w として G\{u, v} における uv 最短路上の頂 点をとれます。逆に、上のような w が取れるとき、G における w を通った uv 最短路は G\{u, v} における uv 最短路にもなっています。 よって、条件を満たすグラフが存在するとき、答えは条件 (1) を満たす u, v について Au,v(= A′ u,v = Bu,v) の和をとったものになります。 N をグラフの頂点の数とするとき、B を求めるための Warshall-Floyd 法 の計算量は O(N3 ) です。また、条件 (1) は各 u, v について O(N) で確かめ られるので、全体の計算量は O(N3 ) です。以上から、アルゴリズム全体の 計算量は O(N3 ) となるので、十分高速です。 E 問題 頂点 v の子孫について色と重みの割り当てができているとして、頂点 v の 色と重みを決めることを考えます。頂点 v の直接の子を u1, u2, . . . , uk とし ます。 各 ui について、ui およびそのすべての子孫に割り当てた色を反転させて も、頂点 ui およびその子孫への色と重みの割り当ては条件を満たしたまま です。また、これらの頂点のうち頂点 v と異なる色の重みの和 y はできるだ け小さくしたほうが v の先祖に色と重みを割り当てやすくなります。 よって、頂点 v を根とする部分木に含まれる頂点の色と重みを決めるには、 次の問題を解けばよいことになります。 • u1, u2, . . . , uk のうちいくつかを v と同じ色に、それら以外を v と異な る色に塗り、v の子孫 (v を除く) に含まれる v と同じ色の頂点の重み の和を Xv 以下にできるか。できる場合、それらの頂点のうち v と異 なる色であるものの重みの和の最小値はいくらか。 この問題は、x1, x2, . . . , xk (ただし xi = Xui ) の情報の他に、ui を根とす る部分木に含まれる頂点であって ui と異なる色のものの重みの和 yi の情報 がわかれば、動的計画法により解くことができます。 与えられた木の頂点を根から遠い順に並べ、それぞれについて上の動的計 画法を行うことで、与えられた木全体への色と重みの割り当てが可能かどう か判定できます。 F 問題 まず、与えられた点集合から、以下のようなグラフ G を構築します。 • 頂点集合は (X, 1),(X, 2), . . . ,(X, N),(Y, 1),(Y, 2), . . . ,(Y, N) の 2N 個。これらにそれぞれ番号 0, 1, . . . , 2N − 1 を付ける。 4 • 頂点 (X, x) と頂点 (Y, y) は、ある i が存在して xi = x かつ yi = y で あるときに限り辺で結ばれている。 • それら以外に辺は存在しない。 グラフ G の頂点はボールを回収するロボットに、辺は回収されるボールに 対応します。また、辺 {u, v} に対応するボールは、頂点 u または頂点 v に 対応するロボットによってのみ回収できます。以下、このグラフに関する問 題として考えることにします。 まず、G の連結成分に頂点の数と辺の数が異なるものが存在する場合、答 えは 0 です。そうでない場合、G の連結成分ごとに順序を数えられれば十分 であるので、以下では G が連結であるとして説明します。 ロボットの起動順序を考える前に、ロボットとそれが回収するボールの対 応付けの方法を考えます。 2N 頂点 2N 辺のグラフにはサイクルがちょうど 1 つあります。このサイ クルに含まれない頂点に対応するロボットについては、それが回収すべきボー ルは一意に決まります。また、サイクルに含まれる頂点に対応するロボット については、回収すべきボールとの対応付けが (サイクル全体で) 2 とおりに 決まります。これらを両方試すことにすると、ロボットとボールの対応付け が定まったことになります。 次に、ロボットの起動順序について考えます。 グラフ G において頂点 v は頂点 u1 < u2 < · · · , uk に隣接しているとしま す。また、頂点 v に対応するロボットは辺 {v, ui} に対応するボールを回収 することになっているとします。このとき、頂点 u1, u2, . . . , ui−1 に対応する ロボットは頂点 v に対応するロボットよりも先に起動する必要があります。 また、この条件がすべての v に対して満たされていれば、決めた対応のとお りにロボットがボールを回収できることもわかります。 グラフ G と同じ頂点集合について、各頂点 v について v から上の記法に おける u1, u2, . . . , ui−1 に向けた辺を張ったグラフを G′ とします。このグラ フ G′ は森になるので、G′ 上で動的計画法を行うことで求める順序の個数が 得られます。 以上で答えが求まりました。 5 ARC083 / ABC074 Editorial wo01 September 16, 2017 A #include<cstdio> using namespace std; int main(){ int N, A; scanf("%d%d", &N, &A); printf("%d\n", N * N - A); return 0; } 1 B #include<cstdio> #include<algorithm> using namespace std; const int MAX_N = 100; int N, K; int X[MAX_N]; int main(){ scanf("%d", &N); scanf("%d", &K); for(int i = 0; i < N; ++i){ scanf("%d", X + i); } int ans = 0; for(int i = 0; i < N; ++i){ int tmp = min(X[i], K - X[i]); ans += tmp; } printf("%d\n", ans * 2); return 0; } 2 C We can pour exactly x grams of water if there exist non-negative integers i, j such that x = 100Ai + 100Bj. Similarly, we can pour exactly y grams of sugar if there exist non-negative integers i, j such that y = Ci + Dj. Since x, y ≤ F, we can generate all possible values of x, y in O(F 2 ) time. Finally, for each possible pair (x, y) (There are O(F 2 ) such pairs), consider the case where we put x grams of water and y grams of sugar, check whether it satisfies the conditions, and compute the maximum density. 3 D If there exist three vertices u, v, w such that Au,v + Av,w < Au,w, the distances are contradictory, thus you should output −1. From now on, we assume that there are no such triplets. We call a (unordered) pair of two distinct vertices (u, v) important if there exists no w such that w ̸= u, w ̸= v, Au,w + Aw,v = Au,v. • If (u, v) is important, the shortest path between u and v must not pass through other vertices. Thus, we must add an edge between u and v with cost Au,v. • If (u, v) is not important, we don’t need to add any edges between these vertices. For some w, it satisfies Au,w + Aw,v = Au,v, and you can just follow the shortest path between u and w and the shortest path between w and v. Therefore, the answer is the sum of Au,v over all important pairs (u, v). 4 E Suppose that we’ve already decided the colors and weights of all descendants of v, and among those vertices, the conditions are satisfied. The only things that matter for the decision of colors and weights of other vertices (ancestors of v) are: • The sum of weights of all black vertices in the subtree rooted at v. • The sum of weights of all white vertices in the subtree rooted at v. One of these two values must be exactly Xv. To make things better in the future, we want to minimize the other value. Let dp[v] be the minimum of the other value. How can we compute dp[v]? Let u1, u2, . . . , uk be the children of v. Without loss of generality, we can assume that v is black. We keep two values: B (the sum of weights of black vertices) and W (the sum of weights of white vertices). They are initialized to zeroes. Now, for each ui , we do one of the following: • Make ui black: add Xui to B and dp[ui ] to W. • Make ui white: add dp[ui ] to B and Xui to W. After that, we want to minimize the value of W, under the constraint that B must be at most Xv. This can be done in O(kXv) by a simple DP. 5 F First, construct a graph G as follows: • There are 2N vertices: X1, . . . , XN , Y1, . . . , YN . (Also, let’s number the vertices 0, 1, . . . , 2N − 1 in this order.) • For each i, add an edge between two vertices Xxi and Yyi . Each vertex in G corresponds to a robot, and each edge in G corresponds to a ball. An edge (ball) between two vertices u and v can be collected by either vertex (robot) u or vertex (robot) v. For each connected component in this graph, the number of edges and vertices must be the same. Otherwise, the answer is 0. We will assume that the graph is connected (otherwise, solve the problem independently for each component and combine the results). Thus, we have a connected graph with 2N vertices and 2N edges. How can we assign edges to vertices? The graph contains exactly one cycle, and for edges in the cycle, there are two ways to assign them to vertices. For other edges, the assignment can be uniquely determined. Let’s fix an assignment of edges to vertices. In how many ways can we activate the vertices to satisfy this assignment? Suppose that in the graph G, a vertex v is adjacent to vertices u1 < u2 < · · · , uk. Also, suppose that v is assigned to the edge {v, ui}. Then, the vertices u1, u2, . . . , ui−1 must be activated before v. These conditions are sufficient: if this is satisfied for all v, the robots can collect all balls. Now, construct another graph G′ : for each v, add an edge from v to u1, u2, . . . , ui−1 in G′ . The answer is the number of topological orderings in this graph. Since G′ is a (directed) forest, it’s east to compute the answer. 6 ABC072 / ARC082 解説 sigma425 For International Readers: English editorial starts on page 3. A: Sandglass2 X > t なら X − t[g] 残っていて、X ≤ t なら 0[g] になっています。これは max(X − t, 0) と書くことも出 来ます。コードにすると次のようになります。 int main (){ int X , t; cin >>X >>t; if (X >t) cout <<X -t < < endl ; else cout < <0 < < endl ; return 0; } B: OddString for 文をまわすなどして答えの文字列を求めると良いです。 int main (){ string s; cin >>s ; int N = s. size (); string ans ; for ( int i =0; i < N;i +=2) ans += s [i ]; cout << ans << endl ; } C: Together X を先に選んでから数に対する操作をすることにします。X を決めると、この個数を最大にするには、 • すべての X − 1 に +1 する • すべての X をそのままにする • すべての X + 1 に −1 する をすると他は関係ないので、(X − 1 の個数)+(X の個数)+(X + 1 の個数) となります。従って先に各数の個 数を数えておき、この X を考えうる範囲で全て試すことで答えが求まります。 1 D: Derangement pi ̸= i となっている部分に o を, そうでない部分に x をつけることにします。N 箇所全て o にな れば ok です。ox とならんでいる部分は、swap することで oo となります (xo も同様)。(∵ もともと pi = x(x ̸= i),pi+1 = i + 1 だったとすると、x ̸= i + 1 でもあるから、pi = i + 1 も pi+1 = x も o になる) xx とならんでいる部分も、swap することで oo となります。(∵ もともと pi = i(x ̸= i),pi+1 = i + 1 だっ たとすると、pi = i + 1 も pi+1 = i も o になる) 従って、先頭から順番に見ていき、箇所 i に x があったら i と i + 1(i = N なら i − 1 と i) を swap する、 とするのが最善になります。(i にある x を消すのに i − 1, i の swap と i, i + 1 の swap どちらかは必要で、前 から見ると i − 1 はもう o なので i + 1 を巻き込んだほうが得) E: ConvexScore n − |S| というのは,「S の凸包 (境界含む) に含まれる与えられた点のうち S の点を除いた集合」(TS とお く) の要素数と等しいです。なので、2 n−|S| は TS の部分集合の個数と等しくなります。 ここで、凸包の面積が正の部分集合 X を任意に取ってきます。そして X の凸包の頂点集合を SX としま す。すると、S を決めた時、{X|S = SX} と {S ∪ t|t ∈ TS} は集合として等しいです。 このことから、凸包の面積が正の部分集合 X はちょうど一回 S = SX の時に一回分カウントされる、とみ なすことが出来ます。 従って、答えは凸包の面積が正の部分集合の個数になります。これは 2 N − (共線な (一直線上に載せること の出来る) 頂点集合の数) となるので共線な頂点集合の数を計算すれば良いです。0 点集合は 1 個,1 点集合は N 個で固定なので、2 点以上で共線なものの個数を数えます。 これは、2 点以上乗りうる直線（高々 N C2 本) をすべて試し、この上に k 点乗っていれば 2 k − k − 1 を足 すことで求まります。計算量は O(N3 ) です。 直線を正規化し set で管理するなどによって O(N2 logN) で解くことも出来ます。 F: Sandglass t 秒後にパーツ A に入っている砂の量を、はじめパーツ A に入っている砂の量 x の関数とみて ft(x) とお きます。 すると、ft(x) は常に次のような形の関数になります。 ft(x) =    a + c (0 ≤ x ≤ a) x + c (a < x < b) b + c (b ≤ x ≤ X) (ただし a = b となり定数関数に潰れている場合もあります) これは、d を定数として、f(x) + t,max(f(x), 0),min(f(x), X) が上述の形で閉じていることからわかります。(時間の経過やパーツに入るの が 0 以上 X 以下であることから起こる ft(x) の変化は全て上の 3 つのどれかの合成として書けるので、この 3 つだけ考えれば良い) よって、上の関数に含まれる a, b, c を保持して更新しながらその都度クエリに答えていけば良いです。 2 ABC072 / ARC082 Editorial sigma425 A: Sandglass2 int main (){ int X , t; cin >>X >>t; if (X >t) cout <<X -t < < endl ; else cout < <0 < < endl ; return 0; } B: OddString int main (){ string s; cin >>s ; int N = s. size (); string ans ; for ( int i =0; i < N;i +=2) ans += s [i ]; cout << ans << endl ; } C: Together Let’s choose X first. For a fixed X, the optimal choices are: • Add 1 to all X − 1. • Do nothing for all X. • Subtract 1 from all X + 1. The number of X after these operations is (the number of X −1 in the initial sequence) + (the number of X in the initial sequence) + (the number of X + 1 in the initial sequence). We can compute the optimal value by trying all possible values for X. 1 D: Derangement Define a sequence of ’o’ and ’x’ of length N as follows: if pi ̸= i, the i-th symbol is ’o’, otherwise the i-th symbol is ’x’. Our objective is to change this sequence to ’ooo...ooo’. • If there is a part ”ox” (or ”xo”) in the sequence, we can change it to ”oo” by swapping these two elements. (∵ If pi = x(x ̸= i) and pi+1 = i + 1 in the initial sequence, after the swap, both pi = i + 1 and pi+1 = x will be ’o’.) • If there is a part ”xx” in the sequence, we can change it to ”oo” by swapping these two elements. (∵ If pi = i(x ̸= i) and pi+1 = i + 1 in the initial sequence, after the swap, both pi = i + 1 and pi+1 = i will be ’o’.) Thus, we should check the sequence from left to right, and if we find an ’x’ at the i-th position, we should swap i and i + 1 (unless i = N, in this case we should swap i and i − 1). E: ConvexScore For a set S that forms a convex polygon (from now on, we call it ”convex set”), let TS be the set of points in the convex hull of S, except for the vertices (points in S). Since |TS| = n − |S|, 2n−|S| corresponds to the number of subsets of TS. In the problem, for each convex set S, we are asked to count it 2(n − S) times. Instead, for each pair of sets (S, U) such that S is a convex set and U is a subset of TS, let’s count S ∪ U once. • When we know S ∪U, we can recover S: it must be the convex hull of S ∪U. Thus, this way each set is counted at most once. • A set of points X is counted if and only if the convex hull of X has positive area: let S be the convex hull of X and U be X \ S. Therefore, the answer is equal to the number of subsets of all N points whose convex hull has a positive area. This can be computed by subtracting the number of colinear sets (sets whose points are on the same line) from 2N . This can be done in O(N3 ) or O(N2 logN). F: Sandglass Let the amount of sand in bulb A at time t be a function ft(x), where x is the initial amount of sand in bulb A. We can prove that this function is always of the following form (for some constants a, b, c): ft(x) =    a + c (0 ≤ x ≤ a) x + c (a < x < b) b + c (b ≤ x ≤ X) When bulb A contains y grams of sand at some time, one second later, the amount of sand in bulb A 2 is either g1(y) = max(y − 1, 0) (in case A is above B) or g2(y) = max(y + 1, X) (in case B is above A). Since the set of functions of the form above is closed under functions g1 and g2, ft is always of this form. Therefore, we can simulate the process while keeping the function ft (i.e., parameters a, b, c) and answer queries. 3 AtCoder Beginner Contest 071 / AtCoder Regular Contest 081 解説 writer: semiexp 2017 年 8 月 20 日 For International Readers: English editorial starts on page 5. A: Meal Delivery 定義どおりに，すぬけ君の住んでいる位置と，店 A, B の間の距離を求めます．この距離の大小に応じて，より近いほ うを出力すればよいです． • C++ による解答例: https://abc071.contest.atcoder.jp/submissions/1518940 • Ruby による解答例: https://abc071.contest.atcoder.jp/submissions/1518942 • Rust による解答例: https://abc071.contest.atcoder.jp/submissions/1516215 B: Not Found 英小文字 26 種類のそれぞれについて，S の中に現れるかを記録する配列を持っておきます．この配列は最初すべて 「現れない」(false) で初期化しておきます．S を 1 文字目から順に見ていって，出てきた文字それぞれについて，配列 上でその文字に対応する位置を「現れる」(true) に更新します．S の最後の文字まで見終わった後には，この配列を見 るだけである文字が S の中に現れるかわかるようになります． 最後に，この配列を，a, b, ..., z の順に見ていって，false となった最初の文字を出力すればよいです．ただし，z ま で見終わっても false が現れなかった場合は，すべての英小文字が S 中に現れているということなので，None を出力 します． • C++ による解答例: https://abc071.contest.atcoder.jp/submissions/1518956 • Ruby による解答例: https://abc071.contest.atcoder.jp/submissions/1518966 • Rust による解答例: https://abc071.contest.atcoder.jp/submissions/1516216 C: Make a Rectangle H × W の長方形を作るためには，長さ H, W の棒が 2 本ずつ必要です．ただし，H = W の場合は，長さ H の棒が 4 本必要です． 各辺に使う棒は，上の条件のもとで，できるだけ長い棒を貪欲に使えばよいです．{Ai} をソートすると，同じ値は連 続した区間に集まるため，各長さの棒が何本あるかを知ることができます．なので，長さの長い順に見ていって，次の ように辺の長さを決定すればよいです． 1 • 同じ長さの棒が全部で 4 本以上ある場合: その長さの棒を縦，横両方に使う (すでに片方の辺が決定している場合 はそちらを優先) • 同じ長さの棒が全部で 2 本または 3 本ある場合: その長さの棒を縦，横のうち片方に使う • 同じ長さの棒が全部で 1 本しかない場合: その長さの棒は使えない 途中で両方の辺が決定した場合は，長方形が作れているので，その長方形の面積 (縦 × 横) を出力します．最後の辺ま で見ても長方形の辺が足りない場合は，長方形を作ることはできないので，0 を出力します． D: Coloring Dominoes ドミノの並べ方は，縦 2 × 横 1 のドミノを 1 個並べるか (X) ，縦 1 × 横 2 のドミノを 2 個縦に並べるか (Y ) のど ちらかを，横につなげたような並べ方になります． 左から順にドミノを塗ることを考えます．縦に 2 個ドミノが並んでいる箇所については，この 2 個を同時に塗ります． 一番左の箇所については， • X: 3 通り • Y : 6 通り の塗り方があります． また，それ以外の箇所については，それより左の箇所がすべて塗られているとしたとき， • X (すぐ左が X): 2 通り • X (すぐ左が Y ): 1 通り • Y (すぐ左が X): 2 通り • Y (すぐ左が Y ): 3 通り の塗り方があります． 2 よって，ドミノの並べ方を判定した上で，左から順に上の規則で並べ方の個数を求めていけばよいです． E: Don’t Be a Subsequence 以下，文字列は英小文字のみからなるもののみを考えます． 文字列 A に対して，「その文字列の suffix であって，すべての英小文字を含むもののうち，最も短いもの」を順次取り 除くことを考えます．ただし，そのようなものが存在しなくなったら終了します．この時，suffix を取り除くことができ た回数を K とします．また，i 番目に取り除いた suffix を SK−1−i，最後に残った文字列を A′ とします．このとき，A は A′ , S1, S2, . . . , SK をこの順に並べた文字列になります． A の部分列でない最短の文字列の長さは K + 1 になることを示します．まず，長さ K の任意の文字列 B が A の部 分列であることを示します．(長さ K 未満の場合は，末尾に適当に文字を加えて長さ K にした場合について示されるの で十分です) S1, . . . , SK はいずれもすべての英小文字を含むため，Si を構成する文字を B の i 文字目に一致する文字 1 個を除いて取り除くことができます．また，A′ を構成する文字はすべて取り除きます．すると，S から文字を取り除い て B が得られるため，B は S の部分列です． 次に，A の部分列でない長さ K + 1 の文字列が存在することを示します．文字列 C = c0c1 . . . cK を次で定めます． • c0 は，A′ に現れない文字のうち 1 つとする (A′ からは suffix を取り除けなかったことから，このような文字は必 ず存在します)． • ci (i = 1, 2, . . . , K) は，Si の最初の文字とする． すると，C は A の部分列ではありません．実際，A を構成する文字をいくつか取り除いて C を得ようとすると， • c0 が A の中で初めて現れるのは S1 の中であるため，A′ はすべて取り除かなければなりません． • c1 は S1 の中では 1 文字目にしか現れないため (取り除く suffix の最小性より)，c0 の次に c1 を得るためには，S1 は c0 を得るために残した文字を除いてすべて取り除かなければなりません． • ... • cK は SK の中では 1 文字目にしか現れないため，cK−1 の次に cK を得るためには，SK は cK−1 を得るために 残した文字を除いてすべて取り除かなければなりません．すると，cK のために使える文字が A にまったく残らな くなってしまします． よって，A の部分列でない最短の文字列の長さは K + 1 になることがわかりました． 3 上の議論から，suffix を取り除く作業を行うことで，A の任意の suffix についても「部分列でない最短の文字列の長 さ」を求めることができます． すると，1 文字目から貪欲に文字を決定していくことで，辞書順最小の答えを求めることができます．文字 c を使う ことができるかどうかは，現在の位置以降の最初の c の現れの位置 pc を求め，S の pc 文字目以降についての「部分列 でない最短の文字列の長さ」が，現在の位置以降の「部分列でない最短の文字列の長さ」よりちょうど 1 小さくなって いるかで判定することができます．pc は，各文字の現れる位置をソートして持っておくと，二分探索で O(log |A|) で求 めることができます． 各位置に対しては文字種を m として O(m log |A|) で次の文字を決定することができ，答えの長さは O(|A|/m) なの で，以上のアルゴリズムにより，答えを O(|A| log |A|) で求めることができます． F: Flip and Rectangles マス目に含まれる 2 × 2 の部分であって，黒マスを奇数個 (1 個または 3 個) 含むものを「悪い部分」とよぶことにし ます．うまく操作を行えば長方形 S を選ぶことができることと，S が悪い部分を含まないことは同値です． 実際，S が悪い部分を含むならば，どう操作を行ってもその部分をすべて黒で塗られた状態にすることはできません． 次に S が悪い部分を含まない場合を考えます．このとき，S の一番上の行，一番左の列をすべて黒く塗られた状態に することができます．ここで，どのような操作を行っても，悪い部分が悪くない部分に変わったり，その逆が起きたりす ることはないことに注意します．よって，この状態においても，S は悪い部分を含まないため，S の上から 2 行目，左 から 2 列目のマスは黒で塗られています．同様に，上から 2 行目，左から 3 列目，... のマスはすべて黒で塗られてい ることがわかり，上から 2 行目はすべて黒で塗られていることがわかります．さらに同様にして，上から 3 行目，... の マスもすべて黒で塗られていることがわかり，結果として S 全体が黒で塗られていることがわかります．よって，S 全 体を黒で塗られた状態にすることができ，S を選ぶことができることがわかります． ここで，マス目において．すべての悪い部分の中心の格子点に，印を付けることを考えます．すると，選ぶことがで きる長方形は，内部に (頂点や辺上にはあってもよい) 印を含まない長方形になります． この「印を含まない長方形」は，最大長方形のアルゴリズムを用いると O(HW) で求めることができます． 4 AtCoder Beginner Contest 071 / AtCoder Regular Contest 081 Editorial writer: semiexp August 20th, 2017 A: Meal Delivery • C++ solution: https://abc071.contest.atcoder.jp/submissions/1518940 • Ruby solution: https://abc071.contest.atcoder.jp/submissions/1518942 • Rust solution: https://abc071.contest.atcoder.jp/submissions/1516215 B: Not Found • C++ solution: https://abc071.contest.atcoder.jp/submissions/1518956 • Ruby solution: https://abc071.contest.atcoder.jp/submissions/1518966 • Rust solution: https://abc071.contest.atcoder.jp/submissions/1516216 1 C: Make a Rectangle In order to make an H × W rectangle, you need two sticks of length H and two sticks of length W. In case H = W, you need four sticks of length H. Under the constraints above, you should choose the longest possible sticks greedily. First, you sort {Ai} in the decreasing order. Since sticks of the same lengths are grouped together after the sorting, we can count the number of sticks of each length. We check the sticks in the decreasing order of their lengths, and do the following: • If we haven’t chosen any sticks and we find four (or more) sticks of the same length, we choose them and finish the process. • If we haven’t chosen any sticks and we find two or three sticks of the same length, we choose them (and continue the process). • If we have chosen two sticks and we find two (or more) sticks of the same length, choose two of them and finish the process. • Otherwise, skip sticks of current length. If we successfully choose four sticks after this process, print the area of the rectangle. Otherwise, print 0 instead. 2 D: Coloring Dominoes The arrangement of dominoes is a concatenation of the following two patterns: We paint dominoes from left to right. The number of ways to paint the leftmost part is as follows: • X: 3 • Y : 6 For other parts, the number of ways to paint a part is as follows (assuming that the left part is already painted): • X (to the right of X): 2 • X (to the right of Y ): 1 • Y (to the right of X): 2 • Y (to the right of Y ): 3 The answer is the product of these numbers. 3 E: Don’t Be a Subsequence First, let’s compute the length of the desired string. Later, we’ll describe how to extend the solution to compute the lexicographically smallest string. Let f(s) be the length of the shortest string that is not a subsequence of s. Suppose that t is not a subsequence of s. What t should we choose, assuming that t starts with a c (arbitrary character)? • If s doesn’t contain c, the length of t can be 1: a single c. • Otherwise, let i be the leftmost occurrence of c in s (s[i] = c). t is not a subsequence of s if and only if t.substr(1) is not a subsequence of s.substr(i + 1). Here, s.substr(i) means the suffix of s from the i-th character. Therefore, we can compute the length of f(s) using the following DP: Define dp[i] as the length of f(s.substr(i)). Also, precompute next(i, c): the minimum index j such that j ≥ i and s[j] = c. Then, dp[i] = min c {dp[next(i, c) + 1]} + 1 (1) holds. How can we compute the lexicographically smallest string? The first character of the answer should be the lexicographically smallest character c that satisfies: dp[i] = dp[next(i, c) + 1] + 1 (2) The remaining part of the solution should be the lexicographically smallest shortest string that is not a subsequence of s.substr(next(0, c)), so we can repeat the same process. This solution works in O(|A|m), where m = 26 is the number of characters. 4 F: Flip and Rectangles Consider a 2 × 2 subsquare inside the grid. If it contains odd (1 or 3) number of black squares, we call it ”bad”. We can prove that, we can choose a rectangle S (after some ”invert” operations) if and only if S doesn’t contain any bad parts. If S contains a bad part, the bad part always contain odd number of black squares even after operations, so we can never choose S. Suppose that S doesn’t contain bad parts. By performing operations properly, we can make all squares in the topmost row and the leftmost column of S black. Notice that a good part (not bad part) always remain good after operations. Thus, when all squares in the topmost row and the leftmost column of S are black, the square on the second row of the second column of S must be black. Similarly, we can prove that all squares in S are black. Now, let’s put a token on the center of each bad part. We can choose a rectangle S if and only if S doesn’t contain any tokens. This problem can be solved in the same way as the well-known problem ”find the largest rectangle that consists only of black squares”. 5 ABC #069 / ARC #080 Editorial writer : sugim48 2017 年 8 月 6 日 For International Readers: English editorial starts on page 5. A : K-City 南北方向の通りの本数は n なので，それらの間の個数は n − 1 です．同様に，東西方向の通りの本数は m なので，それらの間の個数は m − 1 です．区画の個数はこれらの積なので，(n − 1)(m − 1) です． • C++ のコード例 : https://abc069.contest.atcoder.jp/submissions/1480689 • Java のコード例 : https://abc069.contest.atcoder.jp/submissions/1480691 • Python 3 のコード例 : https://abc069.contest.atcoder.jp/submissions/1480692 B : i18n s の先頭文字，|s| − 2，s の末尾文字の順に出力すればよいです．ただし，|s| は s の長さを表します． • C++ のコード例 : https://abc069.contest.atcoder.jp/submissions/1480693 • Java のコード例 : https://abc069.contest.atcoder.jp/submissions/1480695 • Python 3 のコード例 : https://abc069.contest.atcoder.jp/submissions/1480696 C : 4-adjacent 2 で割り切れる回数によって a の要素を分類します．0 回ならば ⃝1 と書き，1 回ならば ⃝2 と書き，2 回 以上ならば ⃝4 と書くことにします．また，⃝1 , ⃝2 , ⃝4 の個数をそれぞれ b1, b2, b4 とします．すると，「隣り 合う要素の積が 4 の倍数である」という条件は，「⃝1 と隣り合う要素は ⃝4 でなければならない」という条件 へ言い換えられます． まず，⃝2 が存在しない場合を考えます．この場合，⃝1 ⃝4 ⃝1 ⃝4 ⃝1 のように並べるのが最適です．よって， b1 ≤ b4 + 1 ならば Yes，そうでないならば No となります． 次に，⃝2 が存在する場合を考えます．例として ⃝2 ⃝4 ⃝1 ⃝4 ⃝2 ⃝2 ⃝4 ⃝2 ⃝2 と並べてみます．この例を見ると， ひと繋がりの ⃝2 は単体の ⃝1 と等価であることが分かります．⃝1 はできるだけ少ない方が嬉しいので， ⃝2 はすべてまとめてひと繋がりにするのが最適です．すると，⃝1 を 1 個だけ増やした上で，⃝2 が存在し 1 ない場合へ帰着できます．よって，b1 ≤ b4 ならば Yes，そうでないならば No となります．具体的には， ⃝1 ⃝4 ⃝1 ⃝4 ⃝1 ⃝4 ⃝2 ⃝2 ⃝2 のように並べるのが最適です． D : Grid Coloring 次図のようにマスを順序付けした上で，最初の a1 マスを色 1 で塗り，次の a2 マスを色 2 で塗り，…，最 後の aN マスを色 N で塗ればよいです． E : Old Maid p, q 上の位置を左から順に 0, 1, ..., N − 1 とします．辞書順で最小の列を求める問題では，「列の先頭から 順に，その時点であり得る最小の値を確定していく」という方法が有効です． まず，q0 としてあり得る最小の値を確定しましょう．q0 になり得るのは，p 上で偶数番目の要素です．こ れらのうち最小の要素を q0 として確定します．また，この要素の p 上の位置を i とします．次に，q1 とし てあり得る最小の値を確定しましょう．q1 になり得るのは，p 上で奇数番目の要素であって，位置 i より右 にあるものです．これらのうち最小の要素を q1 として確定します．また，この要素の p 上の位置を j とし ます．すると，p の残った要素は，3 つの区間 [0, i), [i + 1, j), [j + 1, N) へ分割されます．続いて，q2 とし てあり得る最小の値を確定しましょう．q2 になり得るのは，各区間上で偶数番目の要素です．これらのうち 最小の要素を q2 として確定します．また，この要素が区間 S 上にあるとし，この要素の S 上の位置を i ′ と します．次に，q3 としてあり得る最小の値を確定しましょう．q3 になり得るのは，S 上で奇数番目の要素で あって，位置 i ′ より右にあるものです．これらのうち最小の要素を q3 として確定します．また，この要素の S 上の位置を j ′ とします．すると，S の残った要素は，位置 i ′ , j ′ を境にして 3 つの区間へ分割されます． 以上のような手続きを繰り返せば，辞書順で最小の q が求まります． 以上の方法を愚直に実装すると，全体で O(N2 ) 時間となり TLE してしまいます．TLE を回避するために は，1) ある区間上の偶数 (奇数) 番目の要素の最小値を求めるステップ，2) 次にどの区間から要素を選ぶかを 決めるステップ，の両方を高速化する必要があります．1) については，前処理として，p の偶数 (奇数) 番目 の要素だけを取り出したものをセグメント木に乗せておけばよいです．このとき，最小値と同時に位置も得ら れるようにしておきます．2) については，今あるすべての区間を優先度付きキューに入れておき，各区間の 優先度には，その区間の偶数番目の要素の最小値を設定すればよいです．以上の方法は，全体で O(N log N) 時間で，十分に高速です． 2 F : Prime Flip 各カードの向きによって，数列 a = (a1, a2, . . .) を定義します．具体的には，カード i が表ならば ai = 1 で，カード i が裏ならば ai = 0 とします．さらに，a の差分をとった数列 b = (b0, b1, b2, . . .) を定義します． 具体的には，bi = ai−1 ⊕ ai とします．ただし，a0 = 0 とします．すると，カード [l, r) をそれぞれひっくり 返すという操作は，bl , br の 0/1 をそれぞれ反転するという操作と等価です．また，すべてのカードが裏向き であるという状態は，すべての bi が 0 であるという状態と等価です．以上より，問題は次のように言い換え られます． ✞ ☎ ✝ ✆ 0/1 の列 b = (b0, b1, b2, . . .) がある．「0 以上の整数 l と 3 以上の素数 p を選び，bl , bl+p の 0/1 をそれ ぞれ反転する」という操作を繰り返し行うことができる．すべての bi を 0 にするために必要な操作回数 の最小値を求めよ． 操作の順序は結果に影響しません．また，ある時点で bi = 1 であるならば，後に必ず bi を反転する操作を 行う必要があります．よって，各操作において bl または bl+p の少なくとも一方は 1 である，と仮定できる ことが分かります．以上より，問題は次のように言い換えられます． ✞ ☎ ✝ ✆ マス 0, 1, 2, .... がある．最初，bi = 1 ならばマス i には駒が 1 つ置かれており，bi = 0 ならばマス i は空である．次の操作を繰り返し行うことができる． • 3 以上の素数 p を選ぶ．ある駒をちょうど p だけ離れたマスへ移動する．移動先のマスに既に駒 があるならば，2 つの駒は共に消える． すべての駒を消すために必要な操作回数の最小値を求めよ． b の定義より，初期状態において駒の個数は偶数です．これを M とします．M 個の駒を M/2 組のペアに 分け，各ペアの 2 つの駒を共に消すことにします．このときの操作回数の最小値は，各ペアを消すための最小 手数の総和になります．マス i, j (i ̸= j) 上の 2 つの駒を共に消すための最小手数を d(i, j) とすると， d(i, j) =    1 (|i − j| が奇数であって，3 以上の素数である) 2 (|i − j| が偶数である) 3 (|i − j| が奇数であって，3 以上の素数でない) となります (ゴールドバッハ予想を主に用いて示せます)．初期状態において，偶数 / 奇数マス上の駒の個数 をそれぞれ Me, Mo とします．ここで，最小手数が 1 のペアを k (k ≤ Me, Mo) 組作ることができたとしま す．すると，残った駒たちの最適なペア分けは，偶数マス上の駒たちから ⌊(Me − k)/2⌋ 組ペアを作り，奇数 マス上の駒たちから ⌊(Mo − k)/2⌋ 組ペアを作り，もし Me − k, Mo − k が奇数ならば，余った偶数マス上の 駒と奇数マス上の駒で 1 組ペアを作る，というようになります (次図)．このときの最小手数の総和は k × 1 + (⌊(Me − k)/2⌋ + ⌊(Mo − k)/2⌋) × 2 + ((Me − k)%2) × 3 となりますが，これは k の増加に対して広義単調減少です．よって，k の最大値を求められればよいことが分 かります．これは二部グラフの最大マッチングなので，フローを用いて簡単に解くことができます． 3 4 ABC #069 / ARC #080 Editorial writer : sugim48 2017 年 8 月 6 日 A : K-City • C++ Code Example : https://abc069.contest.atcoder.jp/submissions/1480689 • Java Code Example : https://abc069.contest.atcoder.jp/submissions/1480691 • Python 3 Code Example : https://abc069.contest.atcoder.jp/submissions/1480692 B : i18n • C++ Code Example : https://abc069.contest.atcoder.jp/submissions/1480693 • Java Code Example : https://abc069.contest.atcoder.jp/submissions/1480695 • Python 3 Code Example : https://abc069.contest.atcoder.jp/submissions/1480696 C : 4-adjacent • When an element in a is an odd number, we represent it as ⃝1 . • When an element in a is an even number but not divisible by 4, we represent it as ⃝2 . • When an element in a is divisible by 4, we represent it as ⃝4 . Let b1, b2, b4, be the number of ⃝1 , ⃝2 , ⃝4 . We want to arrange them such that all elements that are adjacent to ⃝1 are ⃝4 . In case b2 = 0 The optimal arrangement will look like ⃝1 ⃝4 ⃝1 ⃝4 ⃝1 . If b1 ≤ b4 + 1, the answer is Yes, otherwise the answer is No. In case b2 > 0 For example an arrangement will look like ⃝2 ⃝4 ⃝1 ⃝4 ⃝2 ⃝2 ⃝4 ⃝2 ⃝2 . Here, a maximal consecutive sequence of ⃝2 is equivalent to ⃝1 . Thus, we should concatenate all ⃝2 and handle them like a single ⃝1 . If 1 b1 ≤ b4, the answer is Yes, otherwise the answer is No. In particular, we should arrange them like ⃝1 ⃝4 ⃝1 ⃝4 ⃝1 ⃝4 ⃝2 ⃝2 ⃝2 . D : Grid Coloring We number the cells as follows. Then, we color the first a1 cells with color 1, the next a2 cells with color 2, and so on. E : Old Maid Here we use 0-based indices, i.e., p = (p0, . . . , pN−1 and q = (q0, . . . , qN−1). Which element can be q0? It must be at an even position in p. Since we want to minimize q lexicographically, we want q0 to be minimized. We can determine q0 as the minimum number among elements in p at even positions. Let q0 = pi . Which element can be q1? If q1 = pj , j must be odd, and j > i. We should choose j that minimizes pj under the constraints above. Now, p is divided into (at most) three intervals: [0, i), [i + 1, j), [j + 1, N). How should we choose q2? In p, it must be in one of the three intervals above, and the parity of its position must be the same as the parity of the first element of its intervals. We should choose q3 from the same intervals (in the same way as q1). By repeating this, we get an O(N2 ) solution. To make it O(N log N), • We should use Range Minimum Query to get the minimum in an interval. • We should keep all intervals in a priority queue. The priority of an interval [l, r) is the minimum of pi such that l ≤ i < r, i ≡ l (mod 2). F : Prime Flip Define bi as follows: • If the card i and the card i − 1 are faced in the same way, bi = 0. 2 • Otherwise, bi = 1. (Assume that card 0 is face down.) When you perform an operation on cards [l, r), you flip bl and br. Thus, we can restate the problem as follows: ✞ ☎ ✝ ✆ You are given a sequence of 0/1, b = (b0, b1, b2, . . .). In each operation you can choose a (nonnegative) integer l and an odd prime p, and flip both bl and bl+p. Compute the number of operations required to transform the sequence to 0, 0, 0, . . .. Consider each 1 in the sequence as a token. In each operation, you can move a token by a distance of odd prime. When two tokens meets, they disappear altogether. When there are two tokens at i and j, d(i, j), the cost required to erase them, can be computed as follows: • If |i − j| is an odd prime, d(i, j) = 1. • If |i − j| is an odd composite, d(i, j) = 3. • If |i − j| is even, d(i, j) = 2. (Strictly speaking, this is related to distribution of primes, for example we have to prove that arbitrary even number can be a difference of two primes. We confirmed this up to the constraints of the problem experimentally.) Let y1, . . . , yM be the initial positions of the tokens. We want to divide them into M/2 pairs, (a1, b1), . . . ,(aM/2, bM/2), and minimize the sum of d(ai , bi). Let Me, Mo be the number of tokens initially at even, odd positions, respectively. If we make k (k ≤ Me, Mo) pairs of cost 1, the total cost will be: k × 1 + (⌊(Me − k)/2⌋ + ⌊(Mo − k)/2⌋) × 2 + ((Me − k)%2) × 3 Since this is a monotonous function of k, we want to maximize k. This maximum k can be computed by a bipartite matching. 3 4 AtCoder Regular Contest 079 Editorial Kohei Morita(yosupo) 平成 29 年 7 月 29 日 A: ABCxxx まず、標準入力から n を入力します。 次に、ABC という文字列を出力します。 最後に、最初に入力した n を出力し、改行文字を出力します。 C++のコード例は以下です。 #include <iostream> using namespace std; int main() { int n; cin >> n; // n を入力 cout << "ABC"; // ABC を出力 cout << n; // n を出力 cout << endl; // 改行文字 return 0; } 1 B: Break Number たとえば、2 で 3 回割れる数のうち最も小さいものはなんでしょうか？ これは、2 を 3 回かけた数、つまり 8 です。 同様に、2 で k 回割れる数のうち最も小さいものは 2 を k 回かけた数です。 2 を k 回かけた数、という形になっているのは、100 以下だと1, 2, 4, 8, 16, 32, 64 の 7 種類しかありません。 よって、この 7 種類のうち、N 以下で最も大きいものを出力すれば良い です。 2 C: Cat snuke and a voyage 島 i(i = 2, 3, ..., N − 1) について、島 1 と島 i、島 i と島 N のどちらの間に も定期便が通っているような i が存在するかどうかを調べれば良いです。 最初に辺をハッシュマップに入れると、島 1 と島 i の間に辺があるかを O(1) で調べることができます。 他にも、長さ N の boolean 配列を 2 つ用意して、島 1 と島 i の間に辺があ るか、島 i と島 N の間に辺があるか、を格納しても良いです。こちらのほう が定数倍が速いです。 よって、O(N) で判定を行うことができます。 辺の前処理に O(M) かかるため、まとめて O(N + M) です。 なお、ダイクストラ法というアルゴリズムを使用すると、最小でいくつの 定期便を使えば島 N にたどり着けるかも調べることができます。 3 D: Decrease (Contestant ver) 操作を逆から考えます。 すると、1 つ要素を選び、値を N 増やす。そしてそれ以外を 1 減らす。と なります。更に条件として、 1. 逆操作後に、選んだ要素の値が最大になっている 2. 逆操作後に、選ばれなかった要素の値が −1 以下になっていない を満たしている必要があります。 すべての要素が 0 以上 N − 1 の数列から、以上の条件を満たしながら K 回 逆操作を行うことが出来れば、その数列が答えとなることが示せます。 結論から言うと、0, 1, 2, ..., N−1という数列を考え、1, 2, ..., N, 1, 2, ..., N, 1, 2, ... 番目の順で逆操作を行えばよいです。 これを発想するのは難しいですが、これが以上の条件を満たすことを示す のはあまり難しくありません。 1, 2, ..., N 番目に 1 回ずつ逆操作を行うと、全体が +1 されることに注目す ると、最後のたかだか N − 1 回の操作のみ真面目にシミュレーションすれば よいので、十分高速です。 4 E: Decrease (Judge ver) ✓ ✏ 数列のうち最も大きい要素を求める、複数ある場合はどれか 1 つ選ぶ。 この要素の値を N 減らす。これ以外の要素の値を 1 増やす。 ✒ ✑ ✓ という操作を ✏ 数列のうち N 以上の要素を好きに 1 つ選ぶ。この要素の値を N 減らす。 これ以外の要素の値を 1 増やす。 ✒ ✑ としても、操作回数に変わりはないという性質が重要です。 これは、直感的にはあまりおかしくは感じないと思うのですが、証明する のはやや大変です。 ある手順で操作をすると A 回で全部の要素が N − 1 以下になったとしま す。このとき、どのような手順で操作しても A 回操作できたならば、その時 点での数列は一意になります。 なぜならば、この操作というのは mod(N + 1) で考えるとすべての要素に +1 という操作になります。よってどのような手順で操作しても mod(N + 1) は不変です。また、どのような手順で操作をしても ∑ai は不変で、操作回数 のみに依存します。 更に、すべての要素が 0 以上 N − 1 以下になる手順が存在することより、 操作後の数列が一意になることがわかります。 以上より、どのような手順で操作をしても操作回数が一意になることが示 せました。 ✓ この性質により、 ✏ S = ∑N i=1⌊ai/N⌋ とする。各 i について ai を ⌊ai/N⌋N 減らし、S − ⌊ai/N⌋ 増やす。 ✒ ✑ という行動を考えることができます。 これは、S 回の操作をまとめて考えているだけです。内訳は、i 番目の要素 には ⌊ai/N⌋ 回操作をしています。 この行動を、すべての要素が N − 1 以下になるまで繰り返せば答えが求ま ります。 そして、実はこれは十分高速であることが示せます。 行動前の数列を ai、行動後の数列を bi とします。 S = ∑⌊ai/N⌋ ≥ ∑(ai − (N − 1))/N ゆえ、 ∑bi ≤ ∑ai − ∑(ai − (N − 1))/N よって ∑(bi −(N −1)) ≤ ∑(ai −(N −1))(1−1/N) = (1−1/N) ∑(ai −(N −1)) 5 以上より、∑(ai − (N − 1)) は指数的に減っていくことがわかり、この指 数の底は (1 − 1/N) ≤ 49/50 であることがわかります。 x を行動回数として、 50×(1016+1000)/(49/50)x < 1、つまり (49/50)x > 50 × (1016 + 1000) となるくらい行動すると、 ∑(ai − (N − 1)) が 0 以下となります。なお、この x を計算すると 2000 弱 となります。 そしてこのとき、 ∑ai ≤ N(N − 1) ≤ 2450 となり、 1 回の行動で ∑ai が 1 は減ることを考えると、 ここからの行動回数はかならず 2450 回以下です。 よって、多くとも 4450 回ほど行動を行えば操作は終了し、1 回の行動は O(N) でシミュレーションできるため、十分間に合います。 6 F: Namori Grundy まず、定義より、グラフはどのような形をしているかを考えます。 これは、サイクルが 1 つあり、サイクルの各頂点から木が生えているグラ フになっています。 また、ai は、頂点 i から辺が伸びている頂点に書かれていない値のうち最 小です。(これは Grundy Numbers と呼ばれる数の定義に酷似しており、今 回の問題タイトルの由来となっています) まず、サイクルに含まれない頂点たちについては、葉からどんどん削って いく幅優先探索などを使い、簡単に ai を定めることができます。 サイクルに含まれる頂点の値を考えます。まず、サイクルの頂点のうち 1 つを適当に選びます。そして、この頂点から辺が伸びている頂点で、サイク ルに含まれないものに書かれていない値のうち、最小と 2 番目に小さいもの を求めます。 すると、この頂点の値はこの 2 つのうちどちらかになることがわかります。 これは、この頂点から辺が伸びている、サイクルに含まれる頂点の値で場合 分けをするとわかります。 そしてこの頂点の値を定めると、他のサイクルの頂点の値もすべて決まる ため、すべて決めた後に整合性を保っているか判定すれば良いです。 計算量は O(N) となります。 7 AtCoder Regular Contest 079 Editorial Kohei Morita(yosupo) July 29, 2017 A: ABCxxx #i n cl u d e <i o s t re am> u si n g namespace s t d ; i n t main ( ) { i n t n ; ci n >> n ; c ou t << ”ABC” ; c ou t << n ; c ou t << e n dl ; r e t u r n 0 ; } 1 B: Break Number #i n cl u d e <i o s t re am> u si n g namespace s t d ; i n t main ( ) { i n t n ; ci n >> n ; f o r ( i n t i = 0 ; i < 2 0; i++) { i f ( n < (1<<( i +1))) { c ou t << (1<< i ) << e n dl ; break ; } } r e t u r n 0 ; } 2 C: Cat snuke and a voyage #i n cl u d e <i o s t re am> #i n cl u d e <v e c t o r> u si n g namespace s t d ; i n t main ( ) { i n t n , m; ci n >> n >> m; v e c t o r<bool> v i s ( n+1, f a l s e ) ; b o ol ans = f a l s e ; f o r ( i n t i = 0 ; i < m; i++) { i n t a , b ; ci n >> a >> b ; a s s e r t ( 1 <= a && a < b && b <= n ) ; i f ( a == 1 ) { i f ( v i s [ b ] ) { ans = t r u e ; } v i s [ b ] = t r u e ; } e l s e i f ( b == n ) { i f ( v i s [ a ] ) { ans = t r u e ; } v i s [ a ] = t r u e ; } } i f ( ! ans ) c ou t << ”IM ” ; c ou t << ”POSSIBLE” << e n dl ; r e t u r n 0 ; } 3 D: Decrease (Contestant ver) Consider the inverse of an operation. In each inverse-operation, you choose an element and increase it by N, and decrease each of the other elements by 1. Furthermore, the following conditions must be satisfied: 1. After the inverse-operation, the chosen element must become the largest. 2. After the inverse-operation, all elements must be non-negative. Let’s start from a sequence whose elements are betwen 0 and N −1, inclusive. If you can perform inverse-operations K times on this sequence, that is a valid answer for this problem. For example, if you start from the sequence {0, 1, 2, ..., N − 1}, you can perform the inverse-operations infinite number of times, by choosing elements 1, 2, ..., N, 1, 2, ..., N, 1, 2, ... in this order. (You should use N = 50 to fit within the constraints of output.) Notice that if you perform the inverse-operations once for each of the elements 1, 2, ..., N, each element will be incremented by one. Using this, you can easily simulate floor(K/N) ∗ K steps. Also, you can simulate the remaining K%N steps by brute force. 4 E: Decrease (Judge ver) In each operation, the sum of all elements in the sequence decreases by exactly one. Let S be the sum of all elements in the initial sequence. Until the maximum becomes at most N − 1, we must perform at least S − N2 operations. Let’s perform X operations, for a given large X. Instead of performing the operations as they are described in the statement, • We first increase each element by X. • Then, repeat the following X times: choose the maximum element, and decrease it by D = N + 1. How can we perform the second step quickly? By binary search, we can find the smallest integer Y such that T = floor(max{(a1 − Y )/D, 0}) + . . . + floor(max{(aN − Y )/D, 0}). . . X (1) Once we find this Y , we can perform T steps at once, by replacing each ai by ai − floor(max{(ai − Y )/D, 0}). Since X − T ≤ N, we can simulate the remaining X − T steps by brute force. After the simulation of S − N2 steps, the sum of elements will be at most N2 , so there will be at most N2 remaining steps/ Therefore, we can handle the remaining part by straightforward simulations. 5 F: Namori Grundy It is well-known that in this type of graph, there is exactly one cycle in the graph, and from each vertex on the cycle a tree may ”grow”. We want to assign integers ai to each vertex, such that ai is the smallest non-negative integer that doesn’t appear in av1 , . . . , avk , where v1, . . . , vk are the destinations of edges from the vertex i. (This is known as Grundy Numbers). Let’s call a vertex in the cycle ”cycle vertex”, and call the others ”forest vertex”. First, for each forest vertex, we can uniquely determine their Grundy Numbers in the order from leaves to roots. How can we determine the Grundy Number of a cycle vertex v? Let c1, . . . , ck be forest vertices that are direct children of v, and let w be the cycle vertex that follows v. Then, av must be the smallest non-negative integer that doesn’t appear in the set ac1 , . . . , ack , aw. We know the values of ac1 , . . . , ack , but we don’t know the value of aw. However, regardless of the value of aw, there are only two candidates for av: one of the two smallest integers that don’t appear in ac1 , . . . , ack . Now, choose an arbitrary cycle vertex x. There are two candidates for ax, so we try both. Once we fix ax, we can determine all Grundy Numbers along the cycle, and we can verify if the Grundy Numbers we get are valid. This solution works in O(N). 6 ABC 067 / ARC 078 解説 writer : camypaper 2017 年 7 月 15 日 For international readers: English editorial starts from page 7. A : Sharing Cookies A, B, A + B のいずれかが 3 で割り切れるかどうかを調べればよい．なお，答えが Impossible となるのは A ≡ B ≡ 1 mod 3 あるいは A ≡ B ≡ 2 mod 3 の場合のみである． #include <iostream> using namespace std; int main(){ int a,b; cin>>a>>b; if(a%3 == 0 || b%3 == 0 || (a+b)%3==0) cout<< "Possible" <<endl; else cout<< "Impossible" <<endl; } 1 B : Snake Toy N 個の棒が長さの昇順に並んでいる場合には，末尾から K 個の棒の長さの和が答えとなる． よって，初めに棒たちを長さの昇順に並び替えたのち，上述したような貪欲法を適用すればよい． C++ などの多くのプログラミング言語では，ソート用の関数が予め用意されていることが多い ため，ソート関数を実装する必要はないだろう． #include <algorithm> #include <iostream> #include <vector> using namespace std; int main(){ int n,k; cin>>n>>k; vector<int> l(n); for(int i=0;i<n;i++){ cin>>l[i]; } sort(l.begin(),l.end()); int ans=0; for(int i=0;i<k;i++){ ans+=l[n-1-i]; } cout<<ans<<endl; } 2 C : Splitting Pile N 枚のカードに書かれた数の総和を X とする．カードの山の先頭 i 枚のカードに書かれた数の 総和が xi であったとすると，残ったカードたちに書かれた数の和 yi は X − xi であり，|yi − xi | は |X − 2xi | となる． 1 から N − 1 までの全ての i について |X − 2xi | を試せばよい．これは O(N) で実行可能であ り，十分高速である． #include <algorithm> #include <iostream> #include <vector> using namespace std; int main(){ int n; long long X=0,x=0,ans=1000000000000000000LL; cin>>n; vector<long long> a(n); for(int i=0;i<n;i++){ cin>>a[i]; X+=a[i]; } for(int i=0;i<n;i++){ x+=a[i]; if(i+1<n)ans=min(ans,abs(X-2*x)); } cout<<ans<<endl; } 3 D : Fennec VS. Snuke 「マスに色を塗った回数の多いプレイヤーの勝ち，同数の場合は後手の勝ち」というルールのゲー ムを考えることにする．元のゲームでどちらかのプレイヤーが敗北したあとも色を塗ることが可能 である，と考えると新しいゲームの勝敗と元のゲームの勝敗が一致することが分かる．このとき， 2 人の目的は，自分が色を塗る回数を最大化し，相手が色を塗る回数を最小化することである． 与えられるグラフが木であることから，2 人の最善戦略は「マス 1 からマス N へのパス上に色 が塗られていないマスが存在するならば色を塗る」であることが示される．マス 1 からマス N へ のパス上に色が塗られていないマスが存在するにも関わらず，それ以外のマスに色を塗った場合， 自分が不利になり相手が有利になることは直感的にも明らかであろう．例えば図 ?? に示されるよ うな配置からゲームを開始したとき，上記の戦略に従ったときのみ先手は勝利可能である．従わな かった場合，後手が最適に行動すると 7 個以上のマスを白く塗ることが可能となり，先手が勝つこ とは不可能である． 上記の戦略に従うと，マス i と j の距離を d(i, j) として，マス i の色は d(1, i) ≤ d(N, i) なら ば黒，そうでなければ白となる．結論としてマス 1 とマス N の 2 点から幅優先探索や深さ優先探 索などを行うことで O(N) でこの問題を解くことが可能である． 図 1 ゲームの初期状態と最終状態の例 4 E: Awkward Response 解の一例を説明する． q(n) を n についての質問の答えが Yes ならば 1 を，そうでなければ 0 を返す関数とする．N が L 桁の整数であったと仮定する．このとき，L 桁の整数 n と N の大小は，str(n) と str(N) の 大小と一致する．ここで，L + 1 桁の整数 10n と N の大小を考えたとき，10n > N が必ず成立 し，str(10n) と str(N) の大小は以下のように表される． • n < N のとき： str(10n) < str(N) • n ≥ N のとき： str(10n) > str(N) 以上より，q(10n) が 1 を返す最小の整数 n が N と一致することが分かる．さらに，q(10n) に は単調性が存在するので n について二分法を行うことで lg N 回程度の質問で N を求めることが 可能である． 次に，N の桁数 L を求める方法を 1 つ説明する． q(10k−1 ) が式 (??) で表されることから，N ̸= 10L−1 の場合は，q(10k−1 ) = 1 を満たす最大の k を求めることで L を求められる． q(10k−1 ) =    1 (k < L) 1 (k = L) 0 (k > L かつ N ̸= 10L−1 ) 1 (k > L かつ N = 10L−1 ) (1) N = 10L−1 の場合は，q(2 × 10k−1 ) が式 (??) のように表されることから，q(2 × 10k−1 ) = 1 を満たす最小の k を求めることで，L を求められる． q(2 × 10k−1 ) =    0 (k < L) 1 (k = L) 1 (k > L) (2) 解法をまとめると，以下のように表される． 1. N = 10L−1 の場合に注意して，N の桁数 L を求める． 2. 二分法を用いて q(10n) = 1 なる最小の n を求める． どのような場合でも質問回数は max(2L, L + lg N) 回以下となり，64 回という制限に対しては 十分余裕がある． 5 F : Mole and Abandoned Mine はじめに，問題設定を以下のように言い換えておく．言い換えた問題設定での答えを x として， ∑M i=1 ✓ ci − x が元の問題の答えである． ✏ N 頂点の辺のないグラフが与えられる．いくつか辺を追加して，頂点 1 から頂点 N への点 素パスがただ 1 つ存在するようにしたい． 辺を追加する方法は M 個あり，頂点 ai , bi 間に辺を追加すると ci 利得を得る．得られる利 得の総和を最大化せよ． ✒ ✑ 頂点 1 から頂点 N への点素パスがただ 1 つ存在するための条件は，「頂点 1 から頂点 N への パス上にある辺がいずれも橋である」ことである．頂点 1 から頂点 N へのパスがただ 1 つ存在 し，そのパス上に，橋でない辺が存在したとする．このとき，そのような辺を取り除いてもグラフ は連結であるから，頂点 1 から頂点 N へのパスは他にも存在するはずである．これは点素パスが ただ 1 つ存在することに矛盾する． ここで，頂点 1 から頂点 N への点素パスがただ 1 つ存在するグラフにおいて，頂点 1 から N へのパス上 (両端を含む) にある頂点をターミナルと呼ぶことにする．最適解においては，ターミ ナル同士をつなぐ辺を取り除いたとき，各連結成分内においては可能な限り辺が追加されているは ずである．そのため，O(2N × M) かけて事前に計算をしておけば，各連結成分内での利得の総和 は容易に計算可能である． さて，パスを 1 つ固定して，その他の頂点たちがどのターミナルに属するかを全探索すること を考えよう．このままでは，実行時間制限には間に合わない．そこで，頂点 1 から N までのター ミナルを順番に決めていきながら，現在着目しているターミナルに属する頂点たちを全て試して いくことを考える．S を {1, 2, 3, . . . , N} の部分集合として，dp(S, t) を「S に含まれる頂点たち を使用しており，t が現在着目しているターミナルであるときの，得られる利得の総和の最大値」 とする．遷移としては，次のターミナルに接続するか，現在のターミナルに属する頂点集合を試す か，の 2 つの遷移を試せばよい．適切に実装を行うことで，全体として O(3N × N) で実行可能で ある． 6 ABC 067 / ARC 078 Editorial writer : camypaper July 15th, 2017 A, B, C See the sample codes of Japanese editorial above. 1 D : Fennec VS. Snuke Let v1 = 1, v2, . . . , vk−1, vk = N be the only path from cell 1 to cell N. Let d(i, j) be the distance between cell i and cell j. In the optimal strategy, Black should color the vertices in the order v2, v3, . . . (while this is possible), and after that Black can choose arbitrary valid moves. This way, Black can make sure that she can get all vertices v such that d(1, v) ≤ d(N, v), no matter how White plays. On the other hand, White should color the vertices in the order vk1 , vk−2, . . . (while this is possible), and after that White can choose arbitrary valid moves. This way, White can make sure that he can get all vertices v such that d(1, v) > d(N, v), no matter how Black plays. To summarize, we can solve this task in O(N) by computing distances from two cells 1 and N. 図 1 An example of a game 2 E: Awkward Response First, we should query with 109 . We get ’Y’ iff N = 1, 10, . . . , 109 . Next, we want to compute the number of digits in N. Let’s call it L. Let q(n) denote the result of the query: 1 means Yes, 0 means No. In case N = 10L−1 , we use the following fact: q(2 × 10k−1 ) =    0 (k < L) 1 (k = L) 1 (k > L) (1) Thus, L is the minimum k that satisfies q(2 × 10k−1 ) = 1. In case N ̸= 10L−1 , we use the following fact: q(10k−1 ) =    1 (k < L) 1 (k = L) 0 (k > LandN ̸= 10L−1 ) 1 (k > LandN = 10L−1 ) (2) Thus, L is the maximum k that satisfies q(10k−1 ) = 1. Next, for a given L-digit number n, we can check if N < n by querying 10n. • If n < N, q(10n) = 0. • If n ≥ N, q(10n) = 1. Thus, we can compute N in lg N queries by binary search. The number of queries is about max(2L, L + lg N). 3 F : Mole and Abandoned Mine Suppose that we have a graph that has exactly one path from vertex 1 to vertex N. In this graph, all edges on the unique path from 1 to N must be bridges. (Otherwise, we can find a path from 1 to N even if we remove one of those edges, and this is a contradiction). Let S be a subset of vertices, and t be a vertex in S. Define dp(S, t) as the minimum cost required to achieve the condition ”There is a unique path from 1 to t that only uses vertices in S”. We have two transitions: (Here, cost(S, T) denotes the sum of costs of all edges between two sets S and T.) • Let u /∈ S be a vertex. If there is an edge between t and u, we can reach dp(S ∪ {u}, u) with cost dp(S, t) + cost(S \ {t}, {u}). • Let T be a set of vertices that is disjoint with S. We can reach dp(S ∪ T, t) with cost (dp(S, t) + cost(S \ {t}, T). With proper pre-computation, we can compute cost(S, T) in O(1) and this solution works in O(3N × N). 4 ABC066 / ARC077 解説 writer: nuip 2017 年 7 月 1 日 For International Readers: English editorial starts from page 8. A : ringring a + b と b + c と a + c の中で一番小さいものを出力する問題です。以下の実 装例では、かわりに a, b, c の中で最も大きいものを求めて、a + b + c から引 いています。 1 # include < stdio .h > 2 3 int main () { 4 int a, b, c; 5 scanf ("%d␣%d␣%d", &a, &b, &c); 6 int max =a; 7 if(b> max ) max =b; 8 if(c> max ) max =c; 9 printf ("%d\n", a+b+c-max ); 10 return 0; 11 } B : ss 偶文字列かどうかを調べるためには、文字列の前半と後半が全く同じかどう かを調べれば良いです。 偶文字列の長さは必ず偶数長なので、偶数の文字列についてのみ調べれば 十分です。最長のものを探しているので、長さ |S| −2 の文字列、長さ |S| −4 1 の文字列、…という順に調べて、条件に合うものが見つかった時にその長さ を出力すると答えが求まります。 1 # include < stdio .h > 2 # include < string .h > 3 4 int main () { 5 char str [222]; 6 scanf ("%s", str ) ; 7 int n= strlen (str ) ; 8 for (int i=n -2; i; i -=2) { 9 if( strncmp (str , str +i/2 , i/2) ==0) { 10 printf ("%d\n" ,i) ; 11 return 0; 12 } 13 } 14 return 0; 15 } C : pushpush 毎回逆向きの並び替えをしていると時間がかかりすぎてしまうので (O(n 2 ))、 これを避ける方法を考えます。入力例を参考に考えると、数列の最初と最後 に交互に ai を追加していくと答えが求まることが分かります。また、最後に 追加した項は最初に来るはずなので、 1. i と n の偶奇が一致していれば、数列の前に ai を追加する。 2. i と n の偶奇が一致していなければ、数列の後ろに ai を追加する。 という操作をすれば良いことが分かります。 この操作を効率よくするためにはどうすれば良いでしょうか？C++を使っ ている場合は、stl::deque という標準ライブラリの機能を使うと簡単に出来 ます。そうでない場合は、大きめの配列を確保して、真ん中あたりから順番 に使っていくと実装できます。この方針で実装した C 言語の実装例は以下の とおりです。 1 # include < stdio .h > 2 3 int array [512345]; 2 4 int a [212345]; 5 6 int main () { 7 int n; 8 scanf ("%d", &n); 9 for (int i=0; i<n; ++i) scanf ("%d", &a[i]) ; 10 int left =212345 , right = left +1; 11 for (int i=0; i<n; ++i){ 12 if(i%2 == (n -1) %2) { 13 array [left - -]=a[i]; 14 } else { 15 array [ right ++]= a[i]; 16 } 17 } 18 for (int i= left +1; i< right ; ++i) { 19 printf ("%d␣",array [i]) ; 20 } 21 return 0; 22 } D : 11 数の種類が n 種で、項が n + 1 項あるので、必ず同じ数の項が複数存在しま す1。また、すべての数が 1 度以上現れるという制約から、同じ数である項は ちょうど 1 組であることが分かります。 同じ数があるので、単純に n + 1 個から k 個を選ぶ組合せ n+1Ck を計算す るだけでは答えが求められません。そこで、重複を除く方法を考えてみます。 同じ数が出てくるのはちょうど 1 組だけなので、n+1Ck から重複してる ものの数を引けば答えが求まります。重複している数列はどのような数列で しょうか？ 取り出した部分列を見てどこから取り出した部分列であるかを考えたと き、1 通りに定まらない場合、その数列は 2 回数えられていることになりま す。次のような例を考えてみます。 23145167 1参考: 鳩ノ巣原理 3 重複している数である 1 は太字で書いてあります。もし部分列で 1 を一度も 選んでいなければ、簡単に復元できます。 256 → 23145167 部分列で 1 を 2 つとも選んでいる場合も、やはり簡単に復元できます。 211 → 23145167 また、1 を選んでいても、2 つの 1 と 1 の間の数 4, 5 を選んでいれば、これら の数と 1 との位置関係から、使われている 1 がどちらの 1 であるか特定でき ます。 51 → 23145167 よって、以上のような場合は重複して数えられない数列です。1 を 1 つだけ 選んでいて、2 つの 1 と 1 の間の数 4, 5 を選んでいない場合はどちらの 1 を 選んでいるかわかりません。これが重複する場合です。 31 → 23145167 ? → 23145167 ? よって、重複している項を al , ar(l < r) とすると、このような部分列の数 は、「al か ar の片方を選んで al と ar で囲われていない項から残りの k − 1 個 を選ぶ場合の数」になります。al と ar で囲われていない項は al の左に l − 1 項と、ar の右に n − r 項あるので、求める場合の数は l−1+n−rCk−1 であるこ とが分かります。 よって、k 行目には、n+1Ck − l−1+n−rCk−1 を出力すれば良いです。 nCk の求め方は、ABC042/ARC058 の D 問題の解説を参照して下さい。 http://arc058.contest.atcoder.jp/data/arc/058/editorial.pdf E : guruguru まず、お気に入りボタンは必ず明るさを切り替える一番最初に押した方が効 率的です。なぜなら、それ以前に他のボタンを押していたとしても、お気に 入りボタンを押した後の明るさは変わらないためです。 順送りボタンのみを使って明るさ A から B に切り替えるためボタンを押 す回数は、A ≤ B なら B − A 回で、A > B なら B + N − A 回です。これは、 まとめて (B + N − A)%N と書けます。ただし、x%y で x を y で割ったあま りを表します。 4 よって、お気に入りボタンを最初に押した場合のボタンを押す回数は 1 + (B + N − X)%N 回で、そうでない場合は (B + N − A)%N 回です。 また、お気に入りボタンを使うのは、ai と ai+1 間（ai+1 を含む）の状態 にお気に入りの明るさ x が存在しているときのみです。 以上を元に、お気に入りが x であるときと x + 1 である時でボタンを押す 回数がどのように変わるか考えてみます。 • ai+1 = x である i お気に入りボタンを 1 回押すだけで済んでいたのが、順送りボタンを (ai+1 + N − ai)%N 回押さないといけなくなります。 • ai と ai+1 間（両端を含まない）に x があるような i 順送りボタンを押す回数が 1 回減ります。 • それ以外 変化無しです。 まとめると、ボタンを押す回数は、ai+1 = xであるすべてのiについて(ai+1+ N − ai)%N − 1 回分増えて、ai と ai+1 間に x があるような i の数だけ減り ます。 ai と ai+1 間に x があるような i の数は、累積和を取る操作を使うと O(n+ m) で求めることができます。imos 法という名前で呼ばれることもあります。 ai+1 = x である i については、当然全部で n 個しか無いので、いちいち計 算して足しても問題ありません。 以上から、x = 0 である場合の答えを求めた後、x = i の場合を使って x = i + 1 の場合を順番に求めていくことで、すべての x についてボタンを押 す回数が求まるため、最小値も求まります。 F : SS まず f がどのような関数か考えてみましょう。 A,B,C をそれぞれアルファベット 1 文字として、 ABCABC という偶文字列を考えます。これに文字を付け加える偶文字列を作るために は、付け加える文字の数は偶数でないといけません（偶文字列の長さは偶数 文字なので）。まずは 2 文字付け加えることを考えてみます。 ABCABC?? 5 これが偶文字列であるなら、赤い文字列と青い文字列は同じである必要があ ります。よって、“AB” と “BC” は同じ文字である必要があります。 同じように、 2k 文字付け加えることを考えてみます。 S1S2 . . . SnS1S2 . . . Sk Sk+1 . . . SnX1X2 . . . X2k この場合、S の最初の n − k 文字と、S の k + 1 文字目以降とが一致している 必要があることが分かります。これは、S が周期 k の文字列であるというこ とを意味します。X1X2 . . . X2k は自由に決められるので、S が周期 k の文字 列である場合、必ず 2k 文字付け加えて偶文字列が作れます2。 以上から、f(S) を求めるには、S の最小周期 k を求めればいいことがわ かりました。 ここで、同じ文字列 S を n 回繰り返してできる文字列を S × n と書くこ とにします。例えば、 “abc”×3 は”abcabcabc” となります。 ここからは、問題を偶文字列 S × 2 のままでなく、「半分」にした文字列 S の状態で考えることにします（そうした方が扱いやすいからです）。半分 にした状態の文字列を扱うために、関数 g を導入します。関数 g を g(S) × 2 = f(S × 2) で定めます。右辺は必ず偶文字列であるため、このような g(S) は必ず存在し ます。g(S) は f(S) の接頭辞になるため、f 10100 (S) のかわりに g 10100 (S) を考 えても同じ結果が得られます。 g がどのような関数であるかを考えます。S の最小周期を x として、S の 長さ x の接頭辞 を T とします。このとき、正の整数 n と S は T の接頭辞で ある文字列 T ′ を使って S = T × n + T ′ と書けます。 もし x が |S| の約数である場合は単純で、S = T × n と書けるので、 f(S × 2) = f(T × 2n) = T × (2n + 2) となります。よって、g(T × n) = T × (n + 1) です。 そうでない場合、先程の結果を使うと、g(S) の長さは |S| + x であるはず なので、 g(S) = T × n + T ′ + T 2 (X1X2 . . . Xn) = (Sn−k+1Sn−k+2 . . . SnS1S2 . . . Sk) とすれば良いです。 6 と分かります。x の最小性から、この文字列T ×n+T ′+T の周期は |T ×n+T ′ | です。よって、もう一度 g でこの文字列を写すと、 g 2 (S) = g(T × n + T ′ + T) = (T × n + T ′ + T) + (T × n + T ′ ) = g(S) + S となります。これはどの偶文字列 S に対しても成り立つため、g n+2(S) = g n+1(S) + g n (S) であることが分かります。 あとは、この式をもとに、各文字 c について、g n (S) に現れる回数を計算 し、i 番目までに c が現れる回数を再帰的に数えれば良いです。 7 ABC066 / ARC077 Editorial writer: nuip July 1st, 2017 A : ringring 1 # include < stdio .h > 2 3 int main () { 4 int a, b, c; 5 scanf ("%d␣%d␣%d", &a, &b, &c); 6 int max =a; 7 if(b> max ) max =b; 8 if(c> max ) max =c; 9 printf ("%d\n", a+b+c- max ); 10 return 0; 11 } 1 B : ss 1 # include < stdio .h > 2 # include < string .h > 3 4 int main () { 5 char str [222]; 6 scanf ("%s", str ) ; 7 int n= strlen (str ); 8 for ( int i=n -2; i; i -=2) { 9 if( strncmp (str , str +i/2 , i /2) ==0) { 10 printf ("%d\n" ,i); 11 return 0; 12 } 13 } 14 return 0; 15 } 2 C : pushpush You can observe that ai are appended to the beginning or the end, alternately. The last element (an) will be appended to the beginning. Therefore, we start from an empty sequence, and in the order a1, . . . , an, 1. If i and n have the same parity, append ai to the beginning of the sequence. 2. If i and n have different parities, append ai to the end of the sequence. This can be implemented in O(n) with a deque. 3 D : 11 There are ( n+1 k ) ways to choose k elements from the sequence, but this way we may count the same subsequence multiple times. For example, consider the following case: 23145167 Fix a subsequence s of this sequence. How many times will s be counted? We can observe that: • If s contains two 1s, the positions can be uniquely determined and it will be counted only once. • If s contains no 1, the positions can be uniquely determined and it will be counted only once. • If s contains 4 or 5, the positions can be uniquely determined and it will be counted only once. • Otherwise, we can’t determine which 1 we chose; it will be counted twice. So, we must subtract the number of ways to choose k − 1 elements from 2, 3, 6, 7. In general, if the distance between two elements of the same value is d, the answer is ( n+1 k ) − ( n−d k−1 ) . 4 E : guruguru Let f(s, t, x) be the number of buttons we must push to change the brightness from s to t, when the favorite brightness is set to x. First consider the following slow solution. We have an array c of length m. Initially all values are zeroes. Then, for each i and x, we add f(ai , ai+1, x) to c[x]. The answer is the minimum value in the sequence c. How can we improve this solution? We want to do this efficiently for a fixed i. Let’s fix i, and let s = ai , t = ai+1. Assume that s < t (the other case can be handled similarly). • If x ≤ s, f(s, t, x) = t − s. • If s < x ≤ t, f(s, t, x) = t − x + 1. • If t < x, f(s, t, x) = t − s. Notice that in all three cases, the value of f is a linear function of x. Thus, we can solve this problem by adding O(N) linear functions to given ranges of c. This can be done by two prefix sums: one for linear part and one for constant part. 5 F : SS Suppose that initially we have a string of length 2n. S1S2 . . . SnS1S2 . . . Sn Can we make it an even string by appending 2k characters? S1S2 . . . SnS1S2 . . . Sk Sk+1 . . . SnX1X2 . . . X2k From this, you see that the first n−k characters of S1S2 . . . Sn and the last n − k characters of S1S2 . . . Sn must be the same. It means that S1S2 . . . Sn has a period of k. In general, f(SS) = ST ST, where T is the first k characters of S, where k is the shortest period of S. Let’s define g(S) = ST, where T is defined in the same way. We can prove the following: • If g(S) = ST and |T| is a divisor of |S|, g(ST) = ST T. • If g(S) = ST and |T| is not a divisor of |S|, g(ST) = ST S. By repeating this, we get: • If g(S) = ST and |T| is a divisor of |S|, g ∞(S) = ST T T T T.... • If g(S) = ST and |T| is not a divisor of |S|, g i+2(S) = g i+1(S) + g i (S) for each i. The remaining part is not very hard. Note that in the actual implementation you don’t need to consider the first case: you get the same value for g ∞(ST) from the second case anyway. === Sketch of the proof for the second case (the first case is easy). Suppose that S = T × n + T ′ where n is a positive integer, |T| is the shortest period of S, and T ′ is a non-trivial prefix of T. We want to prove that the shortest period of g(S) = T × n + T ′ + T is |T × n + T ′ |. Assume that there exists a shorter period x < |t × n + T ′ |. 6 • If x ̸= |T ′ | (mod |T|) and x < |t × n + T ′ |, we can prove that T has a period of gcd(|T|, x−|T ′ |). Thus, S also has a period of gcd(|T|, x−|T ′ |), and it contradicts the fact that the shortest period of S is |T|. • Otherwise, x ̸= 0 (mod |T|) and x ≤ |t × (n − 1) + T ′ |. In this case we can prove that S has a period of gcd(|T|, x), and again we get a contradiction. 7 ARC 076 解説 DEGwer 2017/06/24 For International Readers: English editorial starts on page 4. A: Expired? A ≥ B, A < B ≤ A + X, B > A + X の 3 通りに場合分けをする問題です。C++ での実装例を以下に示 します。 #i n cl u d e <s t d i o . h> i n t main ( ) { i n t x , a , b ; s c a n f (”%d%d%d ” , &x , &a , &b ) ; i f (−a + b <= 0 ) p r i n t f ( ” d e l i c i o u s \n ” ) ; e l s e i f (−a + b <= x ) p r i n t f ( ” s a f e \n ” ) ; e l s e p r i n t f ( ” d an ge r ou s \n ” ) ; } B: Trained? どのボタンが光るかを順にシミュレートしていき、もしボタン 2 が光ったなら、それまでにボタンを押した 回数を出力すればよいです。 では、ボタン 2 が永遠に光らない場合はどうでしょうか。コンピュータは有限回の操作しかできないため、 「いつまでたってもボタン 2 は光らない」ということを直接シミュレーションで確かめることはできません。 N 回ボタンを押してもボタン 2 が光らなかったとします。このとき、その間に N + 1 回いずれかのボタン が光るので、そのうちのある 2 つは同じボタンです。同じボタンが光っている状態から光っているボタンを 押すことを繰り返しても、同じ順にボタンが光るだけなので、この場合ボタン 2 は永遠に光ることはありま せん。 よって、N 回までボタンを押してみて、もし途中でボタン 2 が光ればそれまでにボタンを押した回数を出 力し、そうでなければ −1 を出力すれば、この問題を解くことができます。 以下に C++ による実装例を示します。 1 #i n cl u d e <s t d i o . h> #i n cl u d e <v e c t o r> #i n cl u d e <al g o ri thm> u si n g namespace s t d ; i n t main ( ) { i n t n ; s c a n f (”%d ” , &n ) ; v e c t o r<i n t>v ; f o r ( i n t i = 0 ; i < n ; i++) { i n t z ; s c a n f (”%d ” , &z ) ; z−−; v . push back ( z ) ; } i n t now = 0 , c = 0 ; f o r ( ; ; ) { i f ( now == 1 ) { p r i n t f (”%d\n ” , c ) ; break ; } i f ( c >= n ) { p r i n t f (”−1\n ” ) ; break ; } c++; now = v [ now ] ; } } C: Reconciled? N と M の差 (の絶対値) が 2 以上のとき、条件を満たすように並べることはできません。 2 N と M の差が 1 のとき、N + 1 = M とすれば、条件を満たすためには猿犬猿... 犬猿 の順に並べるこ とになります。このような並べ方は、犬 N 匹を並べる場合の数と、猿 M 匹を並べる場合の数の積なので、 N!M! 通りです。M + 1 = N の場合も同様です。 N = M のとき、猿犬猿... 猿犬と犬猿犬... 犬猿の 2 種類の並べ方があります。上記の場合と同じように考 えれば、それぞれ N!M! 通りの並べ方があることがわかるので、全体の場合の数は 2N!M! 通りです。 109 + 7 で割ったあまりを求めるのを忘れないようにしてください。 D: Built? 最小全域木を求める問題です。素直にグラフを構築し、最小全域木を求めた場合、辺数が O(N2 ) 本となり、 間に合いません。 さて、座標 (a, b) の点と座標 (c, d) の点を結ぶコストは min(|a − c|, |b − d|) ですが、最小全域木を求める 上では、(多重辺はコストが最小のもののみ考えればいいので) コスト |a − c| の辺とコスト |b − d| の辺がそ れぞれ存在すると考えても構いません。 さて、x 座標と点の番号の組がそれぞれ (s, i) < (t, j) < (u, k) (ただし、不等号は辞書式順序で入れる) で ある 3 点を考えたときに、もし 1 番目の点と 3 番目の点をコスト u − s の辺で結ぶ辺を全域木に使うならば、 その代わりに 1, 2 番目の点を結ぶコスト u − t の辺と 2, 3 番目の点を結ぶコスト t − s の辺を使うことにし ても、全域木のコストは大きくなりません。よって、1, 3 番目の点を直接結ぶコスト u − t の辺は、考えなく ていいことが分かります。(点の番号を一緒にして並べているのは、同じ x 座標の点が出現した場合に順序を つけるための便宜的な措置です) 以上より、点たちを x 座標でソートした列において隣接する 2 点と、y 座標でソートした列において隣接 する 2 点の間にそれぞれ辺を張ったグラフの最小全域木を求めればよいです。辺の本数は O(N) 本に減った ため、全体で O(NlogN) 時間でこの問題を解くことができます。 E: Connected? まず、少なくとも片方が長方形の周上以外に書かれている整数については、考慮しなくてよいことを示し ます。 両方が長方形の周上に書かれている整数たちをうまく結べたとします。片方が周上に書かれている整数につ いてはその周上の位置に、そうでない整数については適当な長方形内部に、その整数を 2 つ書き、すでに書か れている曲線たちを「押し出す」ように連続的に変形させることで、新しく書いた整数たちを所望の位置に移 動することができるため、示されました。 さて、両方が長方形の周上に書かれている整数たちだけを考えたとき、条件を満たすように整数たちを結べ るかどうかは、どのように判定すればいいでしょうか？もし整数 i, j が、i, j, i, j の順に周上に現れたなら、 このようなことは不可能です。逆に、そのような i, j が存在しなければ、可能であることもわかります。 これは、周上の適当な位置から順に、時計回りに周上の点たちを stack などを用いて管理していけば、O(N) 時間 (ただし、最初のソートに O(NlogN) 時間) で判定することができます。 3 F: Exhausted? 高橋君の集合 X に対し、その集合内のいずれかの高橋君が座ることのできる椅子の集合を Γ(X) と書くこ とにします。 Hall の定理より、追加すべき椅子の個数の最小値は、全ての高橋君の部分集合 X に対する、|X| − Γ(X) の最大値と一致します。 さて、Γ(X) としてありうるものは、高橋君のこだわりの条件より、「ある s, t(s + 1 < t) に対し、座標 s 以下または座標 t 以上にある椅子すべて」もしくは「椅子すべて」という形をしています。Γ(X) を固定した とき、先の X としてはサイズの一番大きいもののみを考えればよいです。 Γ(X) が全体でない場合、全ての s + 1 < t に対する、座標 s 以下または座標 t 以上にある椅子の個数か ら、Li ≤ s かつ t ≤ Ri なる i の個数を引いたものの最大値を求めればいいです。Γ(X) が全体の場合、X として高橋君全員からなる集合を取れます。以上より、求める答えは、s + 1 < t に対して求めた最大値と、 N − M の大きい方となります。 さて、s + 1 < t に対しては、どのように最大値を求めればいいでしょうか？これは、高橋君たちを Li の昇 順にソートして順に見ていきながら、区間加算と全体 min のクエリの処理できる segment tree を用いるこ とで、O(NlogN) で求めることができます。 4 ARC 076 Editorial DEGwer 2017/06/24 A: Expired? There are three cases: A ≥ B, A < B ≤ A + X, B > A + X. #i n cl u d e <s t d i o . h> i n t main ( ) { i n t x , a , b ; s c a n f (”%d%d%d ” , &x , &a , &b ) ; i f (−a + b <= 0 ) p r i n t f ( ” d e l i c i o u s \n ” ) ; e l s e i f (−a + b <= x ) p r i n t f ( ” s a f e \n ” ) ; e l s e p r i n t f ( ” d an ge r ou s \n ” ) ; } B: Trained? We simulate the process. If 2 is lighten up during the simulation, we get the answer. Otherwise, if 2 is not lighten up in the first N steps, we can prove that this button will never be lighten up, thus the answer is −1. #i n cl u d e <s t d i o . h> #i n cl u d e <v e c t o r> #i n cl u d e <al g o ri thm> u si n g namespace s t d ; i n t main ( ) { i n t n ; s c a n f (”%d ” , &n ) ; v e c t o r<i n t>v ; f o r ( i n t i = 0 ; i < n ; i++) { i n t z ; s c a n f (”%d ” , &z ) ; z−−; 1 v . push back ( z ) ; } i n t now = 0 , c = 0 ; f o r ( ; ; ) { i f ( now == 1 ) { p r i n t f (”%d\n ” , c ) ; break ; } i f ( c >= n ) { p r i n t f (”−1\n ” ) ; break ; } c++; now = v [ now ] ; } } C: Reconciled? If the absolute difference of N and M is at least 2, it is impossible to satisfy the conditions. If N + 1 = M, the animals must be arranged ”MDMDM...DM” (here M stands for monkeys and D stands for dogs). There are N!M! ways to do this. The case where M + 1 = N is similar. If N = M, both ”MDMD...MD” and ”DMDM...DM” are possible, so the answer is 2N!M!. Don’t forget to compute the answer modulo 109 + 7. D: Built? We are asked to compute the minimum spanning tree. Between two points (a, b) and (c, d), instead of adding an edge of cost min(|a − c|, |b − d|), we add two edges: one edge with cost |a − c| and one edge with cost |b − d|. Suppose that there are three points p, q, r, and their x-coordinates satisfy xp < xq < xr. Then, the edge between p and r with cost xr − xp never appear in the MST (it is better to use an edge between p and q with cost xq − xp and an edge between q and r with cost xr − xq). Thus, we only need to consider the following 2(N − 1) edges: • We sort the point by their x-coordinates, and for each adjacent pair of points add an edge between them (the cost is the difference of their x-coordinates). • We sort the point by their y-coordinates, and for each adjacent pair of points add an edge between them (the cost is the difference of their y-coordinates). 2 We compute the MST of these edges. This can be done in O(NlogN). E: Connected? We call an integer ”important”, if both occurrences of this integer is on the boundary of the rectangle. Suppose that there are two important integers i and j, and they appear in the boundary in the order i, j, i, j. In this case, it is clear that we can’t connect both integers without crossing, thus the answer is ”No”. Otherwise, we can connect all integers in the following order: • First, we connect non-important integers one by one. • Then, we connect important integers one by one. This way, we never get stuck. How can we check if there exists such a pair (i, j) of important integers? Start from an arbitrary point on the boundary and check all important points on the boundary one by one in clockwise order (ignore non-important integers on the boundary). Initially we have an empty stack, and whenever we find an important integer x on the boundary, do the following: • If the top element of the stack is also x, pop it. • Otherwise, push x into the stack. If the stack becomes empty after we check all points, the answer is ”Yes”. Otherwise the answer is ”No”. This algorithm works in O(NlogN). F: Exausted? Let X be a set of people. Define Γ(X) as the set of all chairs that can be used by at least one person in X. By Hall’s Theorem, the answer of this task is the maximum of |X| − Γ(X) (here X moves among all subsets of Takahashis). Γ(X) is one of the following forms: • There exists some s, t(s + 1 < t) and Γ(X) is the set of all chairs whose coordinates are at most s or at least t. • Γ(X) is the set of all chairs. For a fixed Γ(X), we only need to consider X with the maximum cardinality. If Γ(X) is the set of all chairs, we can assume that X is the entire set. In this case, |X|−Γ(X) = N − M. If Γ(X) is the set of all chairs whose coordinates are at most s or at least t, the cardinality of X is the number of i such that Li ≤ s and t ≤ Ri . How can we compute the maximum of this value? For each i, we plot a point (Li , Ri) on a plane, and we do a sweepline algorithm with a segment tree. The segment tree supports two queries: ”add a given constant to a given range” and ”find the maximum value among a given range”. This works in O(NlogN). 3 ABC 063 / ARC 075 Editorial (Japanese) 問題・解説: evima 2017 年 6 月 3 日 For international readers: English Editorial starts at page 6. A: Restricted 問題の要求に素直に従うことが求められています。以下に、C++ での実装の例を示します。 1 #include <iostream> 2 using namespace std; 3 4 int main(){ 5 int A, B; 6 cin >> A >> B; 7 if(A + B >= 10){ 8 cout << "error" << endl; 9 }else{ 10 cout << A + B << endl; 11 } 12 } 1 B: Varied いくつかの方針が考えられます。 • ループを二重に組み合わせ、1 ≤ i < j ≤ |S| であるような添字のペア (i, j) すべてについて Si と Sj が異なるか確認する（|S| が大きいと遅くなりますが、今回は |S| ≤ 26 であり問題ありません*1） • S に含まれる文字をアルファベット順にソートし、同じ文字が二つ隣り合わないか確認する • 26 種類の文字それぞれについて S での出現回数を数え、どの文字の出現回数も 1 以下であるか確認 する 以下に、最初の方針の C++ での実装の例を示します。 1 #include <algorithm> 2 #include <iostream> 3 using namespace std; 4 5 int main(){ 6 string S; 7 cin >> S; 8 int N = S.size(); 9 string ans = "yes"; 10 for(int i = 0; i < N; ++i){ 11 for(int j = i + 1; j < N; ++j){ 12 if(S[i] == S[j]){ 13 ans = "no"; 14 } 15 } 16 } 17 cout << ans << endl; 18 } *1 この問題の制約に反しますが、仮に |S| = 105 であったとすると、実行制限時間の 2 秒に間に合わないでしょう。余談ですが、 鳩の巣原理より |S| > 26 のときに直ちに no と出力すれば、そのような長さの入力に対しても実行が間に合います。 2 C: Bugged 方針 1: 「正攻法」 すべての問題の配点の合計を S とします。 • S が 10 の倍数でない場合、S が画面に表示される最大の成績です。 • S が 10 の倍数である場合、画面に 0 でない成績を表示させるためには一問以上の問題で不正解する必 要があります。もし、配点が 10 の倍数でないような問題が一問以上存在するなら、それらのうち配点 が最も低い一問のみで不正解することで、画面に表示される最大の成績を得られます。配点が 10 の倍 数でないような問題が一問も存在しない場合は、画面に 0 が表示されることを防げません。 方針 2: 「オーバーキル」 動的計画法を用いて、「解いた問題の配点の合計」として可能性のあるすべての値を時間計算量 O(N ∑si) で列挙することができます（詳細は省きます）。これは、答えを求めるのに十分過ぎる情報です。 D: Widespread 「残りの体力が最も多い魔物を中心に爆発を起こすことを繰り返す」のは最適な戦略ではありますが、この 戦略を素直にシミュレートしてしまうと、例えば体力 109 の魔物が 105 体存在して A = 2, B = 1 の場合に 長大な時間を要します。 整数 T に対し、 enough(T) を「T 回以内の爆発ですべての魔物を消すことは可能か？」という問いの答 え (Yes または No) とします。このとき、求めたい答えは enough(T) = Yes であるような T の最小値です。 enough は単調性を持つ (enough(X) = Yes であれば X ≤ Y のとき enough(Y ) = Yes) ため、この最小値 を二分探索*2で求めることができます。 定められた T の値に対して enough(T) を判定するには、爆発を起こすことを以下のように捉え直すとよい でしょう:「すべての魔物の体力を B ずつ減らし、魔物を一体選んでその体力をさらに A − B 減らす」。 すると、T 回の爆発を起こすことは、すべての魔物の体力を B × T ずつ減らし、その上で T 回にわたっ て一体の魔物の体力を A − B 減らすこと（以下、この行為を「追加ダメージを与える」と表現します） と同等です。すべての魔物を消すには、体力が B × T より高い魔物 i それぞれに対して追加ダメージを ⌈(hi − B × T)/(A − B)⌉ 回与える必要があり（⌈x⌉ は x 以上の最小の整数を表します）、この回数の合計が T 以下であれば enough(T) = Yes、合計が T を超える場合は enough(T) = No と判定できます。 以上により、一つの T の値に対する enough(T) の判定を時間計算量 O(N) で行うことができ、この解法 の全体の時間計算量は O(N log(hmax/B)) となります。 *2 二分探索自体の説明は省きます。例えば、日本語版 Wikipedia の当該記事に詳細な記述があります。 3 E: Meaningful Mean 問題文中の表記から a の添え字の範囲をずらし、この解説では a = {a0, a1, . . . , aN−1} とします。 a の空でない連続する部分列 {al , al+1, . . . , ar−1} (0 ≤ l < r ≤ N)（これも問題文中の表記と異なり、ar が含まれないことに注意してください）の平均が K 以上であることは、次のように言い換えられます。 ∑r−1 i=l ai ≥ (r − l)K ⇔ ∑r−1 i=0 ai − ∑ l−1 i=0 ai ≥ rK − lK ⇔ ∑r−1 i=0 ai − rK ≥ ∑ l−1 i=0 ai − lK ここで bj = ∑ j−1 i=0 ai − jK (0 ≤ j ≤ N) とおくと、この条件は単に br ≥ bl と書けます。bj (0 ≤ j ≤ N) す べての値は容易に O(N) 時間で求めることができ、残るは br ≥ bl であるようなペア (l, r) (0 ≤ l < r ≤ N) の個数を数えることのみです。これには、何らかのデータ構造を用いることが必要となるでしょう。以下に、 最も簡単と思われる方法を述べます。 まず、N + 1 個の値 b0, b1, . . . , bN を、大小関係を保ったまま 0 から N の範囲の値に圧縮し、その値を c0, c1, . . . , cN とします（ソートと二分探索を用います）。そして、Binary Indexed Tree*3を用いて 0, 1, . . . , N のそれぞれの値の出現回数を保持します。これにより、i = 0, 1, . . . , N のそれぞれに対し、c0, c1, . . . , ci−1 に ci 以下の値が何回出現したかをそれぞれ O(log(N)) 時間で計算することができ、合計 O(N log(N)) 時間で 求めるべきペアの個数を計算することができます。 *3 Binary Indexed Tree 自体の詳細な説明は省きますが、このデータ構造は長さ n の数列を特殊な形式で保持し、二種類の操作 「数列の指定された位置の要素に指定された値を加算する」「数列の先頭から指定された位置までの要素の和を求める」をそれぞれ 時間計算量 O(log(n)) で行うことができます。より詳細な情報は、例えば英語版 Wikipedia の記事 “Fenwick Tree” にありま す。 4 F: Mirrored 与えられた式を rev(N) − N = D とみなします。N の十進表記における桁数を L とし、N = L ∑−1 i=0 10ini (0 ≤ ni ≤ 9, nL−1 ̸= 0) と表記すると、rev(N) − N は次のように変形できます。 rev(N)− N = L ∑−1 i=0 10L−1−ini − L ∑−1 i=0 10ini = L ∑−1 i=0 (10L−1−i −10i )ni = ⌊L/ ∑ 2⌋−1 i=0 (10L−1−i −10i )(ni −nL−1−i) ここで di = ni − nL−1−i (0 ≤ i ≤ ⌊L/2⌋ − 1) とおくと、 rev(N) − N = ⌊L/ ∑ 2⌋−1 i=0 (10L−1−i − 10i )di この式の右辺を f(L, d) とおきます。与えられた式を満たす N の個数を求めることは、f(L, d) = D であ るような L と −9 以上 9 以下の整数の列 d0, d1, . . . , d⌊L/2⌋−1 の組み合わせを列挙することとほぼ同等です （一つの di の列に対し、それに対応する N が複数個存在することを考慮する必要がありますが）。ここで、 0 ≤ i < ⌊L/2⌋ − 1 であるような任意の i に対して次の式が成立します。 10L−1−i − 10i > ⌊L/ ∑ 2⌋−1 j=i+1 ((10L−1−j − 10j ) · 9) + 10L−⌊L/2⌋ （この式の「意味」は次の通りです:「ある i (̸= ⌊L/2⌋ − 1) に対して di = 1 とすると、j > i であるよう なすべての j に対して dj = −9 としても、di = 1 による f(L, d) への正の方向への影響が残り、その残りは 10L−⌊L/2⌋ より大きい」）この式から、次の二点がいえます。 • D の十進表記における桁数を LD とすると、L > 2LD で f(L, d) が正のとき、f(L, d) が D より大き くなることがわかります。したがって、L の値として LD 以上 2LD 以下のすべての値を検討すれば十 分です。 • L の値を定めたとき、f(L, d) = D であるような整数列 d0, d1, . . . , d⌊L/2⌋−1 を列挙するために（そし て与えられた式を満たす N の個数を数えるために）、d0 から順に値を定めていく深さ優先探索を行 うことを考えます。di−1 までの値をすでに定めているとき、di の値として検討する必要がある候補 は、dif = N − ∑ i−1 j=0 ((10L−1−j − 10j )· dj ) として、(10i − 10L−1−i )di ≤ dif であるような最大の値と、 (10i − 10L−1−i )di > dif であるような最小の値の高々二つのみであることがわかります。（直感的に述 べると、探索の途中で f(L, d) の「途中まで」の値が D からあまり離れてしまうとそれ以降「戻って くる」ことはできないため、D の「近くから離れる」べきではありません。）したがって、L の値を定 めたとき、与えられた式を満たす N であって桁数が L であるものの個数を時間計算量 O(2⌊L/2⌋ ) で 求めることができます。 以上の二点より、求めるべき N の個数を時間計算量 O( 2 ∑ LD i=LD 2 ⌊i/2⌋ ) = O(2LD ) で求めることができます。 5 ABC 063 / ARC 075 Editorial (English) Problems and editorial by evima June 3, 2017 A: Restricted It is required to do exactly what is told. C++ implementation follows: 1 #include <iostream> 2 using namespace std; 3 4 int main(){ 5 int A, B; 6 cin >> A >> B; 7 if(A + B >= 10){ 8 cout << "error" << endl; 9 }else{ 10 cout << A + B << endl; 11 } 12 } 1 B: Varied There are several solutions: • Nest two loops and check if Si and Sj differs for all pairs of indices (i, j) such that 1 ≤ i < j ≤ |S| (slower if |S| is larger, but fine in this problem since |S| ≤ 26*1 ) • Sort the characters in S in alphabetical order, and check if no two adjacent letters are the same • For each of the 26 letters, count the occurrences in S, and check if no letter appears more than once C++ implementation of the first solution follows: 1 #include <algorithm> 2 #include <iostream> 3 using namespace std; 4 5 int main(){ 6 string S; 7 cin >> S; 8 int N = S.size(); 9 string ans = "yes"; 10 for(int i = 0; i < N; ++i){ 11 for(int j = i + 1; j < N; ++j){ 12 if(S[i] == S[j]){ 13 ans = "no"; 14 } 15 } 16 } 17 cout << ans << endl; 18 } *1 The constraints in this problem does not allow this, but if |S| = 105 , it would not fit within the execution time limit of 2 seconds. A little off-topic, but if we immediately print “no” when |S| > 26 by pigeonhole principle, it will run in time. 2 C: Bugged Solution 1: “Straight-forward” Let S be the total points allocated to all the problems. • If S is not a multiple of 10, S is the maximum value we seek. • If S is a multiple of 10, in order to display a value other than 0, we need to incorrectly answer at least one question. If there is at least one question with a score which is not a multiple of 10, incorrectly answer one of the problems with the lowest score allocated among them, and we can obtain the maximum grade that can be correctly displayed. If there is no such question, there is no way to prevent the system from displaying 0. Solution 2: “Overkill” By Dynamic Programming, we can enumerate all the possible candidates of “the total score allocated to correctly answered problems” in O(N ∑si) time (we will omit the detail). This is more than enough to find the answer. 3 D: Widespread It is indeed optimal to repeatedly cause an explosion centered at the monster with the most health remaining, but straight-forward simulation of this strategy will take a long time when, for example, there are 105 monsters with 109 health each and A = 2, B = 1. For an integer T, let enough(T) be the answer to the question “is it possible to vanish all the monster in at most T explosions?”: either “yes” or “no”. Then, the answer we seek is the minimum value of T such that enough(T) = yes. Since enough is monotonic (that is, if enough(X) = yes, enough(Y ) = yes when X ≤ Y ), we can perform binary search*2 to find this minimum. In order to determine enough(T) for a fixed value of T, it would be useful to understand causing an explosion in the following way: “decrease the health of all the monsters by B, then further decrease the health of one selected monster by A − B.” Causing T explosions is now equivalent to decreasing the healths of all the monsters by B × T, then do the following T times: further decrease the health of one selected monster by A − B (we will call this an “extra attack”). In order to vanish all the monsters, we need to deliver ⌈(hi −B ×T)/(A−B)⌉ extra attacks to each monster i with a health greater than B ×T. If the total required number of extra attacks is at most T, enough(T) = yes, and otherwise no. We can now determine enough(T) for a fixed value of T in O(N) time, which leads to the total time complexity of O(N log(hmax/B)). *2 We will not explain the notion of binary search itself here. Resources can be found in, for example, Wikipedia. 4 E: Meaningful Mean We will shift the range of the index of a and let a = {a0, a1, . . . , aN−1} in this editorial. We can transform the condition “the non-empty contiguous subsequence of a, {al , al+1, . . . , ar−1} (0 ≤ l < r ≤ N) (note that ar is excluded), has a mean greater than or equal to K” into: ∑r−1 i=l ai ≥ (r − l)K ⇔ ∑r−1 i=0 ai − ∑ l−1 i=0 ai ≥ rK − lK ⇔ ∑r−1 i=0 ai − rK ≥ ∑ l−1 i=0 ai − lK Let bj = ∑ j−1 i=0 ai − jK (0 ≤ j ≤ N), and this condition can be simply written as br ≥ bl . We can easily find all the values of bj (0 ≤ j ≤ N) in O(N) time, and what remains is to count the number of the pairs (l, r) (0 ≤ l < r ≤ N) such that br ≥ bl . It would be necessary to utilize some kind of data structure. We will explain a method that we think is easiest. First, compress the N + 1 values b0, b1, . . . , bN into a range between 0 and N, keeping the magnitude relationship (by sorting and binary search), and let the compressed values be c0, c1, . . . , cN . Then, maintain the numbers of occurrences of the values between 0 and N using Binary Indexed Tree*3 . In this manner, for each of i = 0, 1, . . . , N, we can found the number of occurrences of values less than or equal to ci among c0, c1, . . . , ci−1 in O(log(N)) time, which enables us to compute the desired number of pairs in a total of O(N log(N)) time. *3 We will not explain Binary Indexed Tree in detail here, but here is the summary: this data structure maintains a sequence of length n in a special format, and it can perform each of the following kinds of operations in O(log(n)) time: “incrementing the element at the specified position by a specified amount” and “finding the sum of the elements from the beginning of the sequence up to the specified position”. More information can be found in, for example, Wikipedia (in the name of “Fenwick Tree” in English version). 5 F: Mirrored We will see the given formula as rev(N) − N = D. Let the number of digits of N in decimal notation as L, and N = L ∑−1 i=0 10ini (0 ≤ ni ≤ 9, nL−1 ̸= 0). Then, rev(N) − N can be transformed into: rev(N)− N = L ∑−1 i=0 10L−1−ini − L ∑−1 i=0 10ini = L ∑−1 i=0 (10L−1−i −10i )ni = ⌊L/ ∑ 2⌋−1 i=0 (10L−1−i −10i )(ni −nL−1−i) Here, let di = ni − nL−1−i (0 ≤ i ≤ ⌊L/2⌋ − 1), which results in: rev(N) − N = ⌊L/ ∑ 2⌋−1 i=0 (10L−1−i − 10i )di Let the right side of this formula be f(L, d). Finding the count of N that satisfy the given formula is almost equivalent to enumerating the pairs of L and a sequence of integers between −9 and 9, d0, d1, . . . , d⌊L/2⌋−1 (we also need to take into account that there is more than one N that corresponds to a sequence of di , though). Here, for any i such that 0 ≤ i < ⌊L/2⌋ − 1, the following holds: 10L−1−i − 10i > ⌊L/ ∑ 2⌋−1 j=i+1 ((10L−1−j − 10j ) · 9) + 10L−⌊L/2⌋ (The “meaning” of this is as follows: “Suppose that di = 1 for some i (̸= ⌊L/2⌋ − 1). Then, even if we set dj = −9 for all j such that j > i, the ‘positive effect’ on f(L, d) by di = 1 is not completely negated, and more than 10L−⌊L/2⌋ still remains.”) Based on this, the following can be observed: • Let LD be the number of digits of D in decimal notation. Then, when L > 2LD and f(L, d) > 0, it can be seen that f(L, d) > D. Therefore, it is enough to consider the values between LD and 2LD as the value of L. • For a fixed value of L, consider enumerating the sequences d0, d1, . . . , d⌊L/2⌋−1 such that f(L, d) = D (and finding the count of N that satisfy the given formula), by performing Depth First Search starting from d0. When the values up to di−1 are already decided, it can be seen that there are at most two candidates of the value of di that have to be considered: the maximum value such that (10i − 10L−1−i )di ≤ dif , and the minimum value such that (10i − 10L−1−i )di > dif . (Intuitively, if the “halfway” value of f(L, d) during the search gets too far from D, it is not possible to “get back”, and thus it should “stay close” to D.) Therefore, for a fixed value of L, we can find the count of N that satisfy the given formula in O(2⌊L/2⌋ ) time. The above enables us to find the desired count of N in O( 2 ∑ LD i=LD 2 ⌊i/2⌋ ) = O(2LD ) time. 6 ABC #062 / ARC #074 Editorial writer : sugim48 2017/05/20 For International Readers: English editorial starts on page 5. A: Grouping すべての (x, y) のペアについて Yes / No を記録しておく方法では，( 12 2 ) = 66 通りの場合分けが必要にな り，大変です．代わりに，グループに 1, 2, 3 と番号を振っておき，各 1 ≤ x ≤ 12 ごとに x が属するグループ の番号を記録しておけば，x, y が属するグループの番号を比較することで Yes / No は簡単に判定できます． C++ のコード例 int main () { int a [] = {0 , 1 , 3 , 1 , 2 , 1 , 2 , 1 , 1 , 2 , 1 , 2 , 1}; // 配列の添字は 0 から始まるので，a [0] は 0 にしている． int x , y ; cin >> x >> y ; cout << ( a [ x ] == a [ y ] ? " Yes " : " No ") << endl ; } B: Picture Frame 最初に，縦 H + 2 行，横 W + 2 列の文字配列 b を用意し，# で埋めておきます．次に，各 1 ≤ i ≤ H, 1 ≤ j ≤ W ごとに ai,j を bi+1,j+1 へコピーします．最後に，配列 b の内容を出力すればよいです． ちなみに，迷路などが入力として与えられたとき，この問題のようにあらかじめ外壁で囲んでおくと，その 後の実装が簡単になることがあります． C++ のコード例 char a [100][101] , b [102][102]; int main () { int H , W ; cin >> H >> W ; for ( int i = 0; i < H ; i ++) scanf ("% s " , a [ i ]); 1 for ( int i = 0; i < H + 2; i ++) for ( int j = 0; j < W + 2; j ++) b [ i ][ j ] = ’# ’; for ( int i = 0; i < H ; i ++) for ( int j = 0; j < W ; j ++) b [ i + 1][ j + 1] = a [ i ][ j ]; for ( int i = 0; i < H + 2; i ++) { for ( int j = 0; j < W + 2; j ++) cout << b [ i ][ j ]; cout << endl ; } } C : Chocolate Bar 分割の方法は次図の 4 ケースを考えれば十分です． 左の 2 ケースについて答えを求める方法があれば，H, W を入れ替えて同じ方法を用いることで右の 2 ケースについても答えを求められます．これら 2 通りの答えの最小値が全体の答えとなります． では，左の 2 ケースについて答えを求める方法を考えましょう．まず，長方形 A の縦幅 h (1 ≤ h ≤ H −1) を全探索します．105 オーダーの計算回数ならば，TLE の心配はありません．これで，長方形 A の面積 SA は SA = hW と決まります．あとは，下半分の長方形を長方形 B, C へ分割する方法を決めればよいです． 下半分の長方形を分割する方法は，縦 2 つに分割するケースと，横 2 つに分割するケースがあります．こ れらはどちらも試すことにしましょう．ここでは，横 2 つに分割するケースを説明します．先程と同様に，長 方形 B の横幅を全探索したいところですが，全体で 1010 オーダーの計算回数となり，TLE してしまいます． 実は，Smax − Smin をできるだけ小さくするためには，下半分の長方形もできるだけ均等に分割するのがよ いことが示せます．できるだけ均等に分割しようとすると，長方形 B の横幅 w は w = ⌊W/2⌋ となります． すると，長方形 B の面積 SB は SB = (H − h)w，長方形 C の面積 SC は SC = (H − h)(W − w) と決まり ます．SA, SB, SC がすべて決まったので，この分割における Smax − Smin が求まります．以上すべての分 割における Smax − Smin の最小値が，左の 2 ケースについての答えです． 2 D : 3N Numbers 数列 a のうち，取り除く N 要素を黒色で，a ′ の前半 N 要素を赤色で，a ′ の後半 N 要素を青色で表示す ることにします．例えば，数列 (8, 2, 2, 7, 4, 6, 5, 3, 8) の最適解は (8, 2, 2, 7, 4, 6, 5, 3, 8) となります． 次の条件が成り立つような整数 k を N ≤ k ≤ 2N の範囲で全探索することにします． • a の前半 k 要素は黒色または赤色のみで，a の後半 3N − k 要素は黒色または青色のみである． 各 k について答えを求められれば，それらの最大値が全体の答えとなります．では，各 k について答えを求 める方法を考えていきましょう． k をひとつ固定します．このとき，a の前半 k 要素のうち，ちょうど N 要素が赤色で，残りの要素が黒色です． 同様に，a の後半 3N −k 要素のうち，ちょうど N 要素が青色で，残りの要素が黒色です．ここで，赤い要素の選 び方と青い要素の選び方は独立であることに注意してください．答えは (赤い要素の総和)−(青い要素の総和) の最大値なので，(赤い要素の総和) をできるだけ大きくし，(青い要素の総和) をできるだけ小さくすればよ いことが分かります．以降は，(赤い要素の総和) の最大値の求め方のみを考えることにします． (赤い要素の総和) をできるだけ大きくするためには，a の前半 k 要素のうち大きい方から N 要素を赤くす ればよいです．これは，a の前半 k 要素を大きい順にソートし，前半 N 要素の総和を求めれば，可能ではあ ります．しかし，この方法をすべての k (N ≤ k ≤ 2N) について行うと，全体の計算量は O(N2 log N) と なって TLE してしまいます．すべての k について，a の前半 k 要素のうち大きい方から N 要素の総和を求 める効率的な方法はないでしょうか？ これは，優先度付きキューと呼ばれるデータ構造を用いて簡単に行うことができます．優先度付きキュー は，「要素の push」「最小要素の pop」がともに O(log N) 時間で行えるキューです．あらかじめ，キューに a の前半 N 要素を push しておきます．また，現在キューに入っている要素の総和を保持しておきます．以降， k を N から 2N までインクリメントしていきますが，a の前半 k 要素のうち大きい方から N 要素がキュー に入っている状態を常に保つことにします．これは，要素 ak をキューに push した後，キューの最小要素を pop すれば可能です．また，現在キューに入っている要素の総和も，push / pop された要素の分だけ足し引 きすれば，保持できます．以上の方法で，すべての k について (赤い要素の総和) が O(N log N) 時間で求ま ります． 同 様 に し て ，す べ て の k に つ い て (青い要素の総和) を 求 め て お け ば ，あ と は 各 k に つ い て (赤い要素の総和) − (青い要素の総和) を計算し，それらの最大値を取れば全体の答えが求まります． E : RGB Sequence この問題は O(N3 + N2M) 時間の DP で解けます． 左から順番にマスの色を塗っていくことにします．既に色を塗ったマスのうち，最も右にある赤いマスの index (1-origin) を r とします．ただし，赤いマスが存在しなければ r = 0 とします．同様に，緑のマス，青 いマスについてもそれぞれ g, b を定義します．この状態に対応する色の履歴の通り数を dp[r][g][b] とします． まず，DP の遷移を考えます．k = max{r, g, b} とすると，次に色を塗るマスの index は k + 1 であること が分かります．このマスに 赤 / 緑 / 青 のどれを塗るかによって，それぞれ r / g / b が k + 1 へ変わりま す．例えば，このマスに赤を塗ることに対応する遷移は，dp[k+1][g][b] += dp[r][g][b] となります． 3 次に，条件が成り立たない配色を数え上げない方法について考えます．区間 [li , ri ] に対する条件のチェッ クは，max{r, g, b} = ri のタイミングで行うことにします．説明のため，r < g < b(= ri) とすると，「区間 [li , ri ] にちょうど xi 色含まれる」という条件は，li と r, g の大小関係の条件で表せます．例えば，xi = 2 の 場合，r < li かつ li ≤ g でなければなりません．このような条件が成り立たないような dp[r][g][b] は 0 にし てしまえばよいです． F : Lotus Leaves この問題は，グラフの最小カット問題に帰着できます．以降は，グラフの作り方を説明します． グラフの頂点は，始点 s，終点 t，赤い頂点 1, 2, ..., H，青い頂点 1, 2, ..., W です．赤い頂点 y (1 ≤ y ≤ H) は，カエルが行 y のどこかのマスにいる，という状態を表します．同様に，青い頂点 x (1 ≤ x ≤ W) は，カ エルが列 x のどこかのマスにいる，という状態を表します．よって，マス S が (ys, xs) のとき，始点 s から 赤い頂点 ys と青い頂点 xs へ，それぞれ容量 ∞ の有向辺を張ります．同様に，マス T が (yt, xt) のとき， 赤い頂点 yt と青い頂点 xt から終点 t へ，それぞれ容量 ∞ の有向辺を張ります．さらに，それぞれの蓮の葉 (y, x) について，赤い頂点 y と青い頂点 x の間に，容量 1 の無向辺を張ります．この無向辺は，カエルが葉 (y, x) で行 y 内の移動と列 x 内の移動を切り替えられる，ということを表します． 以上のグラフにおいて，s → t 間の最小カットが問題の答えとなります．これは，s → t 間の最大フローと 一致するので，Ford-Fulkerson のアルゴリズムなどで求まります． 4 ABC #062 / ARC #074 Editorial writer : sugim48 2017/05/20 A: Grouping C++ Code Example int main () { int a [] = {0 , 1 , 3 , 1 , 2 , 1 , 2 , 1 , 1 , 2 , 1 , 2 , 1}; int x , y ; cin >> x >> y ; cout << ( a [ x ] == a [ y ] ? " Yes " : " No ") << endl ; } B: Picture Frame C++ Code Example char a [100][101] , b [102][102]; int main () { int H , W ; cin >> H >> W ; for ( int i = 0; i < H ; i ++) scanf ("% s " , a [ i ]); for ( int i = 0; i < H + 2; i ++) for ( int j = 0; j < W + 2; j ++) b [ i ][ j ] = ’# ’; for ( int i = 0; i < H ; i ++) for ( int j = 0; j < W ; j ++) b [ i + 1][ j + 1] = a [ i ][ j ]; 1 for ( int i = 0; i < H + 2; i ++) { for ( int j = 0; j < W + 2; j ++) cout << b [ i ][ j ]; cout << endl ; } } C : Chocolate Bar There are four cases: In the first two cases, we fix the height h of the rectangle A (and try all possible values of h). The difference between B and C should be as small as possible. In the first case, the heights of B and C should be floor((H − h)/2) and ceil((H − h)/2), and in the second case, the widths of B and C should be floor(W/2) and ceil(W/2). The last two cases are similar to the first two cases. D : 3N Numbers Let’s color the removed elements black, the first N elements of a ′ red, and the last N elements of a ′ blue. For example, one optimal solution for the sequence (8, 2, 2, 7, 4, 6, 5, 3, 8) can be represented as (8, 2, 2, 7, 4, 6, 5, 3, 8). There exists an integer k(N ≤ k ≤ 2N) such that: • The first k elements of a are either red or black. • The last 3N − k elements of a are either blue or black. Fix such an integer k. Obviously, we should choose the largest N integers from the first k elements as red elements, and the smallest N integers from the last 3N − k elements as blue elements. For each k(N ≤ k ≤ 2N), we compute the sum of the largest N integers among a1, . . . , ak. This is a well-known task, and it can be done in O(NlogN) using priority queue. Similarly, we can compute the sum of blue elements for each k, and the answer is the maximum of red minus blue. 2 E : RGB Sequence We color the squares from left to right. Define dp[r][g][b] as the number of ways to color the first k = max{r, g, b} squares, such that: • The last square we painted red is the r-th square (1-based). r = 0 if no square was painted red. • The last square we painted green is the g-th square. • The last square we painted blue is the b-th square. • There’s no contradiction in the first k squares: if ri ≤ k, the number of different colors in the range [li , ri ] must be exactly xi . The transitions will be like ”dp[k+1][g][b] += dp[r][g][b], dp[r][k+1][b] += dp[r][g][b], dp[r][g][k+1] += dp[r][g][b]”. However, when dp[r][g][b] is contradictory, we should do ”dp[r][g][b] = 0;” instead. This solution works in O(N3 + N2M). F : Lotus Leaves Convert the grid into a bipartite graph. We should see the cell (i, j) as an edge that connects the i-th red vertex and the j-th blue vertex. Then, a path of the frog is a path in this bipartite graph. We want to cut S and T by removing leaves (i.e., edges in the bipartite graph). The answer is the minimum s-t cut of the following graph: • The vertices are s, t, red vertices 1, 2, ..., H，and blue vertices 1, 2, ..., W. • If S = (xs, ys), add an edge between s and the xs-th red vertex, and an edge between s and the ys-th blue vertex, each with infinite capacity. • If T = (xt, yt), add an edge between t and the xt-th red vertex, and an edge between t and the yt-th blue vertex, each with infinite capacity. • For each leaf (x, y), add an edge between the x-th red vertex and the y-th blue vertex with capacity 1. 3 AtCoder Regular Contest 073 Editorial Kohei Morita(yosupo) 平成 29 年 4 月 29 日 A: Shiritori 文字列の入力と if 文を書くことが必要になります。 以下に python3 でのコード例を示します。 a, b, c = input().split() if a[len(a)-1] == b[0] and b[len(b)-1] == c[0]: print(’YES’) else: print(’NO’) 1 B: Choice Integers A の倍数はいくつ足しても A の倍数です。よって、実は選ぶ数は 1 個だけ で良いです (いくつか選んで足さなくても、最終的な総和を直接選べます)。 次に、A%B, 2A%B, 3A%B, ... という数列を考えます。なお A%B は A を B で割ったあまりを表します。 ここで、(k + B)A%B = (kA + BA)%B = kA%B に注目すると、この数 列は周期的で、最初の B 個の要素を繰り返す数列になっていることがわかり ます。 よって、この問題は A から BA まで、愚直に B で割った余りを求めて調 べれば良いです。 2 C: Sentou i 人目がスイッチを押した後、i + 1 人目が • T 秒以内に来るならば、ずっとお湯は出続ける • T 秒よりも経ってからくるならば、お湯は T 秒間出て止まる ということがわかります。 よってこの問題の答えは、それぞれの人について、次の人が何秒後に来る かを求め、min(T, 次の人が来るまでの時間) の総和を求めれば良いです。 3 D: Simple Knapsack この問題はナップザック問題として知られていて、効率良く解くアルゴリ ズムは存在しないと信じられています。ただし、特殊な制約がある場合はそ の限りではありません。例えば N や W や vi のうちどれかが小さい場合は ABC032 D 問題で出題されています。 今回は、すべての i = 2, 3, …, N について、w1 ≤ wi ≤ w1 + 3 という特殊 な制約を利用するのだろうと考えられます。 この性質に注目すると、物の重さは高々 4 種類であることがわかります。 よって、各重さについてその重さの物を何個選ぶか決めてしまいます。す ると、各重さごとに価値の高い順に使うことにすれば良くなります。 そして選び方は、最大でも (N/4)4 = 254 = 390625 通りありますが、この 程度ならば全探索が可能です。 使う個数を決めた後は、各重さごとに価値の高いものから使っていくこと になります。この、価値の総和は O(選んだ個数) で計算できます。 C++や Java や D 言語など、高速な言語ならばこれで間に合うと思います が、Python や Ruby などの場合、累積和などを使い O(1) で計算できるよう にしないと厳しいかもしれません。 4 E: Ball Coloring ボールは 400, 000 個もありますが、答えに影響するパラメーターは Rmax, Rmin, Bmax, Bmin の高々 4 個だけであることに注目します。 更に、 MIN = min(x1, x2, ..., xn, y1, y2, ..., yn) MAX = max(x1, x2, ..., xn, y1, y2, ..., yn) とすると、Rmin = MIN, Bmin = MIN のどちらかは満たし、Rmax = MAX, Bmax = MAX のどちらかは満たすことがわかります。 もっというと、Rmin = MIN&Bmax = MAX と Rmin = MIN&Bmax = MAX のどちらかを仮定して良いです。 よってこれで場合分けをします。 Rmin = MIN&Bmax = MAX の場合 この場合、Rmin や Bmax がこれ以上小さくなったり大きくなったりするこ とはありません。よって、各袋について、小さい方を赤色、大きい方を青色 にすれば良いです。 Rmin = MIN&Rmax = MAX の場合 最小のボールと最大のボールが同じ色の場合です。 この場合、赤色の方には何も考えず好きなボールを押し付けられます。 よって青色に塗るボールのみ着目すればよいです。 つまり、各袋からボールを 1 個選び最大-最小を最小化する、という問題を 考えれば良いです。 これは、最初全ての袋について小さい方のボールを選んだと仮定し、 それをそのなかで小さい順に並べ、順番に、そのボールを袋のもう一つの ボールと交換する、ということを行えば良いです。 5 F: Many Move この問題は愚直な DP を考え、それを高速化していく方針を取ります。 まず、O(N3 ) の DP として以下の様なものが考えられます。 dp[i][a][b] := i 個のクエリを処理しており、コマは a と b にある。今まで かかった時間の最小 ここで、どちらかのコマは必ず直前のクエリの位置にいることを考えると、 O(N2 ) に高速化が出来ます。 dp[i][a] := i 個のクエリを処理しており、コマは a と xi にある。今までか かった時間の最小 x0 = B とすると、 dp[0][A] = 0, dp[0][x] = ∞(x ̸= A) を初期値として、 min(dp[Q][1], dp[Q][2], ..., dp[Q][N]) を答えとすれば良いことがわかります。 この DP の漸化式は、 dp[i][a] = dp[i − 1][a] + |xi−1 + xi |(a ̸= xi) dp[i][xi−1] = min(dp[i − 1][xi−1] + |xi−1 + xi |, minj=1,2,...,n(dp[i − 1][j] + |j − xi |)) となります。 ここで、DP テーブル dp[i − 1][1], dp[i − 1][2], ..., dp[i − 1][n] を配列として 持っているとします。そしてここから一気に dp[i][1], dp[i][2], ..., dp[i][n] を計 算することを考えます。 上の漸化式から考えると、 1. 配列全体に |xi−1 + xi| を足し 2. minj=1,2,...,n(dp[i − 1][j] + |j − xi |) を求め、dp[i][xi−1] より小さければ 代入 という操作ができれば良いことがわかります。 難しい操作は minj=1,2,...,n(dp[i − 1][j] + |j − xi |) ですが、これは j と xi の 大小で場合分けをすると minj=1,2,...,xi (dp[i − 1][j] − j + xi) minj=xi+1,2,...,n(dp[i − 1][j] + j − xi) が求められれば良くなります。 これは、dp[i−1][j]−j と dp[i−1][j] +j を持った配列に対する区間の min を求める操作になります 整理すると、実は持つべきは dp[i − 1][j] の配列ではなく、dp[i − 1][j] − j と dp[i − 1][j] + j の配列です。 6 dp[i − 1][j] − j と dp[i − 1][j] + j の配列を持っておくと、全体に add と区 間 min ができれば良くなります。これは、Segment Tree で解くことが出来 ます。 7 AtCoder Regular Contest 073 Editorial Kohei Morita(yosupo) 平成 29 年 4 月 29 日 A: Shiritori python3 example: a , b , c = i n p u t ( ) . s p l i t ( ) i f a [ l e n ( a ) −1] == b [ 0 ] and b [ l e n ( b ) −1] == c [ 0 ] : p ri n t ( ’YES’ ) e l s e : p ri n t ( ’NO’ ) 1 B: Choice Integers The sum of multiples of A is always a multiple of A. Thus, we can assume that we choose only one integer. Consider the sequence A%B, 2A%B, 3A%B, .... Since (k + B)A%B = (kA + BA)%B = kA%B, this sequence has a period of B. Therefore, we can check the first B elements of this sequence by brute force. 2 C: Sentou After the i-th person pushes the switch, the i + 1-th person • If the i+1-th person comes within T seconds, the water keeps emitting. • If the i + 1-th person comes after at least T seconds, the water emits for T seconds and stops. Therefore, the answer is the sum of min(T,ti+1 − ti). 3 D: Simple Knapsack This problem is known as the knapsack problem, and it’s hard to solve in general case. This time we use the constraint w1 ≤ wi ≤ w1 + 3. Because of this, there are at most 4 possible weights for a single item. For each weight w, let’s fix kw, the number of items of weight w we choose. Obviously, we should choose kw items greedily (in the descending order of values). Let A, B, C, D be the number of items of weights w1, w1+1, w1+2, w1+3, respectively. This algorithm works in O(ABCD). In the worst case, this is (N/4)4 = 254 = 390625. 4 E: Ball Coloring Let MIN = min(x1, x2, ..., xn, y1, y2, ..., yn) MAX = max(x1, x2, ..., xn, y1, y2, ..., yn) . One of Rmin = MIN, Bmin = MIN will be satisfied, and one of Rmax = MAX, Bmax = MAX will be satisfied. Without loss of generality, we can consider the following two cases: Rmin = MIN&Bmax = MAX In this case we want to minimize Rmax and maximize Bmin. For each bag, we should color the ball with the larger integer blue, and color the other ball blue. Rmin = MIN&Rmax = MAX In this case we are only interested in blue balls (the value of Bmax−Bmin. First, for each bag, we color the ball with the smaller integer blue, and sort the blue balls in ascending order. Call them z1, . . . , zn (in ascending order). Then, for each i = 1, . . . , n, color zi red and color the opponent of zi blue. 5 F: Many Move Let dp[i][a][b] be the minimum cost required to process the first i queries such that the tokens are at a and b after the queries. This DP works in O(N3 ). We’ll improve this. Let dp[i][a] be the minimum cost required to process the first i queries such that the tokens are at a and xi after the queries. This DP works in O(N2 ). Suppose that we have an array dp[i−1][1], dp[i−1][2], ..., dp[i−1][n], and we want to convert it to the array dp[i][1], dp[i][2], ..., dp[i][n]. The following operations are required: 1. Add |xi−1 + xi| to the whole array. 2. Compute minj=1,2,...,n(dp[i − 1][j] + |j − xi |). This can be done by two RMQs: one of them holds the values of dp[i − 1][j] − j and the other one holds the values of dp[i − 1][j] + j. 6 ABC 059 / ARC 072 解説 writer : hogloid 2017 年 4 月 22 日 A : Three-letter acronym 「小文字を大文字にする」という操作は、ライブラリ関数を用いるか、ASCII 文字コードで大文字や小文字 は連続して配置されていることを利用して文字コードの差を足し算して求めることもできます。 C++ のコード例 int main (){ string a , b , c ; cin >> a >> b >> c ; char dif = ’A ’ - ’a ’; printf ("% c % c % c \ n " , a [0] + dif , b [0] + dif , c [0] + dif ); return 0; } B : Comparison まず、2 つの数の桁数が異なる場合、桁の多い数の方が大きいです。桁数が等しい場合、数の大小は大きい 桁から順に並べた文字列の辞書式比較と等しくなることをプログラムすればよいです。 C : Sequence 偶数番目と奇数番目どちらを正にするかで 2 通り考え、小さい方を答えることにします。番号の小さい順に 数を確定させていきます。 i 桁目までの和の符号が欲しい符号と同じ場合、i 番目の数を変更する必要はありません。すでに i 番目まで の和の符号が合致しているのに i 番目の数を変更して最適解が得られるなら、i 番目の数に対する変更を i + 1 番目の数に持ってくることで同じ最適解が得られるからです。 i 桁目までの和の符号が欲しい符号と異なる場合、まず欲しい符号のうち絶対値最小までは変更しなくては いけません (1 か −1)。これ以後は上と同様の議論が成り立つので、1 か −1 まで変更すれば十分です。 この規則で前から順に決めコストを求めていくことで答えが求まります。 1 D : Alice&Brown 結論としては、|X − Y | ≤ 1 のとき Brown、そうでなければ Alice が勝ちます。以下の帰納法を X + Y の 昇順に回すことで、この性質が成り立つことがわかります。 • X + Y ≤ 1 のとき有効な操作がないため、Brown が勝ちます。 • X + Y > 1, |X − Y | ≤ 1 のときどんな操作をしても、|X − Y | > 1 で相手に手番を渡してしまうため、 帰納法の仮定により相手が勝ち、自分は負けます。 • X + Y > 1, |X − Y | > 1 のとき山のうち石が多くある方の山から適切な数取ることで、|X − Y | ≤ 1 で相手に手番を渡すことができます。帰納法の仮定により相手は負け、自分は勝ちます。 E : Alice in linear land i 番目までの数を入力したときに目的地までの距離 Ai を前もって計算しておきます。 i 番目に入力する数を自由に変更できるとき、その数の入力が終わった時点で ∀x ∈ [0, Bi ] について Alice が目的地 x の距離にいるよう数を設定することができます。逆に、Pi より目的地に遠い場所に移動させるこ とはできません。 よって、i 番目以降の数を入力しても Alice が目的地に辿りつけない最小の距離 Bi が求まれば、i 番目を変 更する計画が可能かは Ai ≥ Bi+1 かどうかと等しくなります。 Bi は実は後ろから順に求めていくことができます。まず、BN+1 = 1 です。 • Bi+1 ≤ ⌊di/2⌋ のとき Bi = Bi+1 ∵ Bi+1 の距離から di を入力しても Bi+1 ≤ ⌊di/2⌋ より動きません。よって、Bi+1 から i 番目以降の 数を入力しても目的地にたどり着きません。これより近い場合、同様に i 回目の数の入力では動きませ んが、i + 1 番目の数を入力する時点で Bi+1 より近い場所にいるので、目的地にたどり着きます。 • それ以外のとき Bi = Bi+1 + di ∵ 同様に、距離 Bi から i 番目以降の入力を行っても目的地にたどり着きません。距離 Bi より近い位 置から i 番目の入力を行ったとき、Bi+1 より目的地に近い位置に動くので、仮定から目的地にたどり 着きます。(以下の図参照) 2 F : Dam i 日目までに流入した水を、流入した日が後になるにつれ水温が昇順するよう管理することを考えます。こ うすることで、水を入れるためにダムから排水するときは、今ある水のうち最も水温の低い (=最も早く流入 した) ものを過去に排出したことにすることで対応できます。 水が流入したとき、その前で流入した水より温度が低いときは、上記の性質が壊れてしまいますが、代わり にその 2 種類の水が混ざって同時に流入してきたものとして扱うことができます。なぜなら、その前で流入し た水を捨てるより、冷たい水が混ざってから捨てたほうが残った水の温度が高くなるからです。 以上の操作は、両端キューを使うことで水の排出は先頭からの削除、水の流入は末尾の削除と追加により毎 回の操作を O(1) で行うことができます。i 日目には、水の排出と流入を終えた後、全体の熱量 (体積×温度) の総和を L で割った値が答えです。1 日の間に要素を複数削除することはありますが、追加は 1 日につき 1 回 なのでならしで O(N) となります。 3 ABC 059 / ARC 072 Editorial writer : hogloid 2017 年 4 月 22 日 A : Three-letter acronym C++ Code int main (){ string a , b , c ; cin >> a >> b >> c ; char dif = ’A ’ - ’a ’; printf ("% c % c % c \ n " , a [0] + dif , b [0] + dif , c [0] + dif ); return 0; } B : Comparison If the two numbers have different lengths, the longer number is greater. Otherwise, if the two numbers have the same lengths, you can compare them lexicographically. C : Sequence Try two possibilities independently: even-length prefixes are positive or odd-length prefixes are positive. You determine the numbers greedily from left to right. When you check the i-th term, if the sum of the first i terms already has the desired sign, you don’t need to change the i-th term. (Instead of changing it, you can do the same thing by performing the same operation for the i + 1-th term). Otherwise, you should change it such that the sum of the first i terms becomes 1 (in case the desired sign is positive) or -1 (in case the desired sign is negative). This way, you can compute the optimal cost. 1 D : Alice&Brown If |X − Y | ≤ 1, Brown wins. Otherwise Alice wins. • Incase|X − Y | ≤ 1, no matter how you move, after your turn |X − Y | > 1 will be held, and your opponent wins. • In case X + Y > 1, |X − Y | > 1, if you take appropriate number of stones, you can satisfy |X − Y | ≤ 1 after your turn and you win. E : Alice in linear land Suppose that the witch changes the q-th number. Let Ai be the distance to the goal after you finish the first i operations (when the which doesn’t do anything). Then, before the q-th operation, you will be at Aq−1. After the q-th operation, you can be at arbitrary integer place between 0 and Aq−1, inclusive (depending on the change made by the witch). Let Bi be the smallest integer such that, if you are at Bi after the first i operations, you won’t reach the goal. Clearly, the answer to the query is ’YES’ if and only if Bq ≤ Aq−1. You can compute Bi in the decreasing order of i as follows: • Obviously, BN = 1. • If Bi+1 ≤ ⌊di/2⌋, Bi = Bi+1 ∵ If you start from Bi+1 and perform the operation di , you won’t be moved by this operation and you won’t reach the goal. If you start from closer positions, you will reach the goal by the definition of Bi+1. • Otherwise, Bi = Bi+1 + di ∵ Check the following picture. Here, the horizontal axis shows the distance before the operation di , and the vertical axis shows the distance after the operation di . 2 F : Dam The state of the dam can be represented by two parameters: [the amount of water] and [the product of the amount of the water and the temperature]. This way, when we mix two cups of water with parameters (x1, y1) and (x2, y2), we get water with the parameter (x1 + x2, y1 + y2). At each time, we should keep the set of possible states of the water in the dam. If you plot this set on an x-y plane, it will always be a concave polyline. For example, after the first day, this is a line segment that connects (0, 0) and (v1, t1v1). How can we store/update this polyline? The polyline can be seen as a sequence of vectors. We keep it using a deque. • When we add water with the state (x, y), we simply push it to the front of the deque. • When we discharge water, replace the polyline with its convex hull. And for each query, we answer the y-coordinate of the polyline at x = V . The amortized complexity is O(N). 3 ABC058 / ARC071 解説 writer: nuip 2017 年 4 月 8 日 For International Readers: English editorial starts from page 7. A : ι ⊥ l 問題文にかかれているとおり、b − a = c − b であるかどうか判定すればよい です。例えばこの処理は C++では次のように書けます。 1 # include < iostream > 2 using namespace std ; 3 int main () { 4 int a, b, c; 5 cin >> a >> b >> c; 6 cout << ( b-a == c-b ? "YES " : "NO" ) << endl ; 7 } B : ∵∴∵ E の文字とO の文字を交互に並べるとパスワードが復元できます。|E|−|O| = 1 のケースに気をつけてください。 1 # include < iostream > 2 using namespace std ; 3 int main () { 4 string E, O; 5 cin >> E >> O; 6 for (int i=0; i < E. size () ; i++) { 7 cout << E[i]; 1 8 if(i < O. size () ) cout << O[i]; 9 } 10 return 0; 11 } C : 怪文書 / Dubious Document 最長の文字列を作るにはできるだけ多く文字を使ったほうがいいです。答え となる文字列に使える a の数を ca とします。また、cb, . . . , cz についても同 様に定義します。 すぬけ君が文字列を作る時に a を k 個使うためには、どの文字列にも a が k 個出てきている必要があります。よって、ca は、「a が最も少ない文字列」 に出てくる a の個数となります。同じことが他の b から z までの文字につい ても言えます。 辞書順で最小の文字列にするためには、a から順番に並べればよいので、 答えは aa . . . a | {z } ca個 bb . . . b | {z } cb個 . . . zz . . . z | {z } cz個 となります。 D : 井井井 / ### 答えを数式で表すと以下のようになります。 ∑ 1≤i<j≤n ∑ 1≤k<l≤m (xj − xi)(yl − yk) これをそのまま計算すると計算量が O(n 2m2 ) で間に合いません。 この式は次のように因数分解することができます。 ( ∑ 1≤i<j≤n (xj − xi) ) ( ∑ 1≤k<l≤m (yl − yk) ) これで x 座標と y 座標を別々に扱うことができるようになりました。しかも どちらも同じ形をしているので、x 座標の式∑ 1≤i<j≤n (xj − xi) をどう計算す るかだけ考えれば良いです。 2 この式もこのままでは計算に O(n 2 ) かかってしまいます。式をよく見る と、n 個の変数 x1, . . . , xn を足したり引いたりしてるだけなので、x1, . . . , xn がそれぞれ何回足されて何回引かれているかさえ分かればこの値は求まりま す。xk が足される回数は、ループの中で j = k である回数と同じです。これ は k より小さい添字の個数と同じなので k − 1 回だとわかります。同様に xk が引かれる回数は、k より大きい添字の個数と同じなので n − k 回だとわか ります。以上のことから、次の等式が成り立ちます。 ∑ 1≤i<j≤n (xj − xi) = ∑ 1≤k≤n ((k − 1)xk − (n − k)xk) この式の右辺の形式だと計算量が O(n) となるため、制限時間内に答えを 出すことができます。よって、この式を使って x, y 両方について計算し、掛 け算すれば答えが O(n + m) で求まります。 E : TrBBnsformBBtion 操作 1 や 2 を A 1 →BB や AAAA 2 →A のように書くことにします。 まず、どちらの操作も（空文字列を作らない限りは）逆の操作が可能です。 A 1 →BB の逆の操作は次のように作れます。 BB 1 → AAB 1 → AAAA 2 → A A と B が逆の場合でも、この操作の A と B を入れ替えればよいです。 AA 1 → BBA 1 → BBBB 2 → B 操作 2 の逆の操作は、消した AAA や BBB の隣の文字を利用して行えま す。たとえば隣の文字が A であれば、次のようにします。 A 1 → BB 1 → AAB 1 → AAAA A 1 → BB 1 → AAB 1 → ABBB A 1 → BB 1 → BAA 1 → BBBA 隣の文字が B の場合でも、この操作の A と B を入れ替えればよいです。 ここで、文字列を「文字列 T に変換できるもの」というグループに分類 することを考えましょう。すると、操作が双方向に行えるので、「文字列 X を Y に変換できるか」と「文字列 X と文字列 Y は同じグループか」が同じ 意味になります。 3 ではグループにはどのようなものが考えられるでしょうか？簡単にする ために、A だけが使われるように変換することにします。また、できるだけ 短くすることを目指します。すると、どの文字列も次の 3 つのうちどれかに なることがわかります。 • A に変換できるもの • AA に変換できるもの • AAA に変換できるもの 逆に、これら 3 つは互いに変換可能ではありません。これを確かめるた めに、文字列について「各文字について A を 1、B を 2 として合計して 3 で 割ったあまり」を考えます。例えば、文字列 A は 1、AA は 2、AAA は 0 で す。この値は操作 1 でも操作 2 でも変わらないので、これら 3 つの文字列は 互いに変換不可能です。 以上のことから、文字列 X と Y のこの値が等しいこと（同じグループで あること）と、X を Y に変換できることは同値です。そのため、各クエリに 対してその部分文字列の値を計算して 3 で割ったあまりが等しいかを判定す れば良いことになります。これは、事前に累積和を計算しておくことで、各 クエリに対して O(1) で判定できます。 F : Infinite Sequence 2 つめの条件がややこしいので、まずこれについて考えましょう。1 である項 については 2 つめの条件は何も関係ありません。では 2 以上の項については どうなるでしょうか？数列のどこかに x, y というふうに 2 以上の数 x, y が連 続して出てきた場合、x についての条件から x, y, y のように y がもう 1 つあ とに続いているはずです。さらに、1 つめの y についての条件から x, y, y, y のようにさらにもう 1 つ y がついていることが分かります。同様の議論が 2 つめ以降の y についても可能なので、ずっと y が続くということが分かりま す。つまり、2 以上の数が連続すると、それ以降の項は 1 通りに定まってし まいます。 次に 1 つめの条件について考えてみましょう。第 n 項からはずっと同じ 数が続いているということですが、この「同じ数の繰り返し」が始まったの はどこからでしょうか？その数が a1 からずっと続いているかもしれない (A) ですし、その前に別の数である項がある (B) かもしれません。 今後、第n項の数をxで表して、第n項に下線をひいて表すことにします。 4 (A) x, x, . . . , x, x, x, . . . (B) ?, ?, . . . , ?, t, x, x, . . . , x, x, x, . . . (A) の場合は単純なので、(B) の場合を考えてみましょう。x の繰り返し の直前にある数を t と呼ぶことにします (t ̸= x)。ではその t のさらに前には どんな数が出てきているでしょうか？t が最初の項から続いている場合 (B1) とそうで無い場合 (B2) があります。 (B1) t, t, . . . , t, x, x, . . . , x, x, x, . . . (B2) ?, ?, . . . , ?, s, t, t, . . . , t, x, x, . . . , x, x, x, . . . t の前の数を s と呼ぶことにします。いま t がいくつか続いているように 書きましたが、前に見たとおり、t > 1 だと t が連続しているはずはありませ ん。t > 1 ということにして場合分けしておきましょう。 (B1-1) 1, 1, . . . , 1, x, x, . . . , x, x, x, . . . (B1-2) t, x, x, . . . , x, x, x, . . . (B2-1) ?, ?, . . . , ?, s, 1, 1, . . . , 1, x, x, . . . , x, x, x, . . . (B2-2) ?, ?, . . . , ?, s, t, x, x, . . . , x, x, x, . . . t ̸= x であったので、(B1-1) と (B2-1) では x > 1 です。まぎらわしいので これらについては x ′ と書いておきます。また、(B2-2) の場合 s としては 1 し かありえません。 (B1-1) 1, 1, . . . , 1, x′ , x′ , . . . , x′ , x′ , x′ , . . . (B1-2) t, x, x, . . . , x, x, x, . . . (B2-1) ?, ?, . . . , ?, s, 1, 1, . . . , 1, x′ , x′ , . . . , x′ , x′ , x′ , . . . (B2-2) ?, ?, . . . , ?, 1, t, x, x, . . . , x, x, x, . . . 以上で、第 n 項から左に辿っていくと、(B1-1) と (B2-1) と (B2-2) では 1 が出てくることが分かりました。そのようなケースは 1 で終わる有限列 に “x ′ , x′ , . . . , x′ , x′ , x′ , . . .” か “t, x, x, . . . , x, x, x, . . .” を付けた数列になって います。 5 以上でどのような数列が条件をみたすのかがわかったので、答えを求め ていきましょう。 (A) のケースは n 通りです。(B1-2) のケースは (n−1)2 通りです1。それ以 外のケースの答えを求めるには、「1で終わる長さiの列で最後の項以外が条件 を満たすものの数」が必要になります。これをdp[i]とします。この値は動的計 画法で求められます（後述）。(B2-2) のように後ろに “t, x, x, . . . , x, x, x, . . .” が付くケースは (dp[1] + dp[2] + . . . + dp[n − 2])(n − 1)2 通りです。(B1-1) と (B2-1) のように後ろに “x ′ , x′ , . . . , x′ , x′ , x′ , . . .” が付くケースについては、 x ′ > 1 なので、(dp[1] + dp[2] + . . . + dp[n − 1])(n − 1) 通りです。よって、答 えは n+(n−1)2+(dp[1]+dp[2]+. . .+dp[n−2])(n−1)2+(dp[1]+dp[2]+. . .+dp[n−1])(n−1) となります。 さて、あとは dp[i] を求めるだけです。「最後の項以外が条件を満たす、1 で終わる長さ i の列」は、次のどれかです。 • (最後の項以外が条件を満たす、1 で終わる長さ i − 1 の列) + “1” • (最後の項以外が条件を満たす、1 で終わる長さ i − 3 の列) + “2, 1, 1” • (最後の項以外が条件を満たす、1 で終わる長さ i − 4 の列) + “3, 1, 1” . . . • (最後の項以外が条件を満たす1で終わる長さ1の列) + “i−2, 1, 1, . . . , 1” • “i − 1, 1, 1, . . . , 1” よって、 dp[i] = { 1 (i = 1) 1 + dp[1] + dp[2] + . . . + dp[i − 1] (i > 1) と計算できます。dp[i] の累積和を計算しておくことで dp[1], dp[2], . . . , dp[n] を O(n) で求めることができます。 この dp[i] の計算を行列とベクトルの掛け算で実装すると O(log n) で解く こともできます。 1 t > 1 に注意 6 ABC058 / ARC071 Editorial writer: nuip April 8th, 2017 A : ι ⊥ l Check if b − a = c − b. 1 # include < iostream > 2 using namespace std ; 3 int main () { 4 int a, b, c; 5 cin >> a >> b >> c; 6 cout << ( b-a == c-b ? "YES " : "NO" ) << endl ; 7 } B : ∵∴∵ Arrange characters in E and O alternately. 1 # include < iostream > 2 using namespace std ; 3 int main () { 4 string E, O; 5 cin >> E >> O; 6 for (int i=0; i < E. size () ; i++) { 7 cout << E[i]; 8 if(i < O. size () ) cout << O[i]; 9 } 10 return 0; 11 } 1 C : Dubious Document Let ca be the maximum integer such that each string contains at least ca occurrences of the character ’a’. Define cb, . . . , cz similarly. The answer is aa . . . a | {z } caoccurrences bb . . . b | {z } cboccurrences . . . zz . . . z | {z } czoccurrences D : ### The answer is ∑ 1≤i<j≤n ∑ 1≤k<l≤m (xj − xi)(yl − yk) which is equal to ( ∑ 1≤i<j≤n (xj − xi) ) ( ∑ 1≤k<l≤m (yl − yk) ) Thus, we can solve the problem for each coordinate independently. In order to solve the problem for x-coordinates quickly, use the following equation: ∑ 1≤i<j≤n (xj − xi) = ∑ 1≤k≤n ((k − 1)xk − (n − k)xk) It works in O(n + m). E : TrBBnsformBBtion Replace ’A’ with ’1’ and ’B’ with ’2’. We claim that we can convert a string s to another string t if and only if the sum of digits of s and the sum of digits of t are equivalent in modulo 3. It is trivial that this is a necessary condition. We want to prove that this is sufficient. First, the operations are revertable (except for the case where the initial string is empty): BB 1 → AAB 1 → AAAA 2 → A 2 A 1 → BB 1 → AAB 1 → AAAA A 1 → BB 1 → AAB 1 → ABBB A 1 → BB 1 → BAA 1 → BBBA Using the operations B → AA, we can convert any (non-empty)string to a string that consists only of ’A’, so any string can be converted into one of the strings ’A’, ’AA’, or ’AAA’. These three strings have different values in modulo 3. Thus, this condition is also sufficient. F : Infinite Sequence Let N be a fixed integer. Let dp[k] be the number of infinite sequences a1, a2, . . . such that • For each i, 1 ≤ ai ≤ N (Note that this N is constant regardless f the value k) • ak = ak+1 = · · · • For each (i, j, k), if i < j < k ≤ i + ai , aj = ak. The problem asks to compute dp[N]. Let’s compute dp[k] by case-analysis: • If the first element is 1, there are dp[k−1] ways to decide the remaining elements. • If the first element is not 1 (call it c), and the second element is also not 1 (call it d), the sequence must be c, d, d, d, . . .. In total there are (N − 1)2 sequences of this form. • If the first element is c > 1 and the second element is 1, – If c + 1 ≤ k, there are dp[k − c − 1] ways to decide the remaining elements. – Otherwise, the sequence must be c, 1, 1, 1, . . .. Thus, dp[k] = dp[k − 1] + (N − 1)2 + dp[k − 3] + dp[k − 4] + · · · + dp[1] + (N − k + 2). 3 ARC070 / ABC056 解説 sigma425 For International Readers: English editorial starts on page 5. A: HonestOrDishonest a =′ H′ , b =′ H′ の場合は ′H′ を、a =′ H′ , b =′ D′ の場合は ′D′ を、a =′ D′ , b =′ H′ の場合は ′D′ を、 a =′ D′ , b =′ D′ の場合は ′H′ を出力すればよいです。コードにすると次のようになります。 int main (){ char a , b; cin >> a >> b; if ( a == ’H ’ && b == ’H ’) cout << ’H ’; if ( a == ’H ’ && b == ’D ’) cout << ’D ’; if ( a == ’D ’ && b == ’H ’) cout << ’D ’; if ( a == ’D ’ && b == ’D ’) cout << ’H ’; return 0; } B: NarrowRectanglesEasy もし既に連結なら答えは 0 です。これは |a − b| ≤ W かどうかで判定できます。そうでない場合は、答えは |a − b| − W になります。 C: Go Home もし 1 + 2 + ... + t < X なら時刻 t には座標 X にはたどり着けません。逆に、1 + 2 + ... + t ≥ X なら 時刻 t に座標 X にたどり着けることが示せます。実際、{1, 2, .., t} の部分集合で和が X になるものが取れ て、そうすると部分集合に選んだ長さのときだけ右にジャンプし、それ以外のときはジャンプしないという戦 略によって座標 X にたどり着けます。よってあとはこのような最小の t を求めれば良いです。これはおおよ そ −1+√ 8X+1 2 になるので、この関数によって計算すると O(1) で求まります。そこまでしなくても、答えが O( √ X) になることから、t を前から順番に試して t(t+1) 2 ≥ X か毎回判定するだけでも, 時間計算量 O( √ X) で答えを求めることが出来ます。 D: No Need まず、「カード i が必要」という条件は次のように言い換えられます: 「カード i を使わずに、総和が K − ai 以上 K 未満な集合が取れる」. 1 左 ⇒ 右 ・・・ 必要ならその証拠となる i を含むよい集合があって、これから i を除いたものが言い換え後 の条件を満たす証拠になっています。 右 ⇒ 左 ・・・ 上とは逆に、この条件を満たす集合に i を加えたものが元の条件を満たす証拠となってい ます。 よって、各カード i ごとに、そのカードを除いた後つぎのような DP をします。 「dp[x][y] = x 枚目まで使ったときに総和を y にできるか?」 y としては K 未満しか考えなくて良いため、この DP の計算量は O(NK) になります。これを N 枚のカー ドに対してやるので、全体の計算量は O(N2K) となり、部分点を取ることが出来ます。 満点解法を取るにはいくつか方法があります。ひとつは、カード i が不必要な時、ai ≥ aj を満たすカード j も不必要である (つまり、単調性が成り立つ) ことを利用する方法で、どのカードまで不必要かを二分探索す ることで、上述の dp の回数を O(logN) 回に減らせるので、全体で O(NKlogN) になります。 他の方法として、dp を, カード 1,2,..,N の順に使う方と N,N − 1,...,1 の順に使う方の両方を途中経過を残 して計算しておいて、その結果を利用することで各 i について O(K) で判定する方法があります。実際、カー ド i について判定するには、1,2,...,i − 1 を使って出来る値の集合と、N,N − 1,..,i + 1 を使ってできる値の集 合がわかっていれば良いです。これがわかっているので、あとは累積和を使ったりすると O(K) で判定でき て、全体の計算量は O(NK) になります。 また、bitset 等を使うことで DP を高速化すると計算量は変わらなくても少し遅い解法でも通るかもしれま せん。 E: NarrowRectangles まず部分点を解くには、次のような dp をすればよいです。 dp[i][x] = 上から i 個までの長方形を動かしていて、i 個めの長方形の横座標を x に動かした時点でのそこ までのコストの最小値 上から順番に動かし方を決めていくと、そこまでが連結なら、そこから下を連結に出来るかどうかは直前の 長方形の一にしか関係がないためこのような dp が出来ます。 計算すると. dp[i][x] = |x − li | + min x−(Ri−1−Li−1)≤x′≤x+(Ri−Li) dp[i − 1][x ′ ] (1) となる (min についている条件は i − 1 と i が連結になる条件です) ので、これを愚直に計算すると、座標幅を X とおくと、O(NX2 ) になり、部分点を取ることが出来ます。 満点を取るには、dp[i][] がどのような形になっているか考える必要があります。dp[i − 1] から dp[i] を計算 するには、 1. x 軸方向に平行移動する 2. ある一定長さの区間の min をとる 3. |x − li | を足す が出来る必要があります。この操作をしていくとどうなるか考えると、dp[i] では、「十分に左では傾きが −i で、そこから単調に傾き (常に整数) が大きくなっていき、十分に右では傾きが i になる」という形になってい ることがわかります。従って、dp[i][x] をすべて持つ代わりに、「傾きが変わる点」の x 座標をすべて持つこと にします。 2 重要な事実として、このような形に対して「ある一定長さの区間の min をとる」をすると、「傾き 0 の部分 (つまり底の部分) がその一定長さ延びる」という結果になることがわかります。なのでこれは底の部分の左右 にわけて両者を平行移動するとみなせます。従って、傾き 0 の区間より左で傾きが変わる点, 右で傾きが変わ る点をそれぞれ set で持って、平行移動は set 全体に対して足された値として管理すると操作 1 と 2 に関して は処理できます. これを持てば操作 3 も簡単に処理できて、「ある点で傾きが 2 回変わることになる」という捉え方をすると、 その点が傾き 0 の区間の中にあるか、左にあるか、右にあるかで場合分けして、set に点を追加して、必要に 応じて片方の set の中身をひとつもう片方の set に移し替えることで実現できます。 最終的な答えは、傾き 0 の部分の高さを常に保持することで求めることが出来ます。計算量は O(NlogN) です。 F: HonestOrUnkind まず、A ≤ B のときは Impossible です。これは、不親切な人が次の戦略を取ると何度質問をしても絶対 に特定できないことからわかります:「不親切な人 B 人のうち A 人をあらかじめ選んでおいて、不親切な人は その A 人が正直者であるかのように質問に答える」 それ以外の場合は常に可能なことを構成的に示します。 まず頂点が 0 から N − 1 の N 個あるグラフを持ち、質問の結果に応じて次のように辺を張っていきます。 a が b のことを正直者だと言ったときには a から b に’Y’ のラベルの付いた辺を張ります。(a Y →b とかく) 同 様に不親切な人だと言ったときには’N’ のラベルの付いた辺を張ります。(a N →b とかく) まず N 回使って正直者を一人特定します。aB Y → aB−1 Y → ... Y → a0 という部分グラフがあるとします (ai はそれぞれ異なるとする)。この時、a0 は正直者です。(∵ ある ai が正直者だったとすると、推移的に a0 も 正直者になります。a0 から aB まで全員不親切な人だとすると、不親切な人が B + 1 人いることになり矛盾 します。) よって基本的には Y → でつながった path を伸ばしていくことを目指します。 a N → b となった場合は、この二人を一旦 N 人から取り除きます。a と b の少なくとも一方は不親切な人で あることがわかるので、こうしたとしても A > B という条件は成り立ったままです。 このことから次のようなアルゴリズムが考えられます。 bool ask ( int a , int b ){ cout < <"? " <<a < <" "<<b << endl ; char c; cin >>c; return c == ’Y ’; } int need = B +1; vector < int > path ; for ( int i =0; i <N ; i ++){ if ( path . empty ()){ path . push_back ( i ); if ( path . size () >= need ) break ; continue ; } bool b = ask (i , path . back ()); if ( b ){ 3 path . push_back ( i ); if ( path . size () >= need ) break ; } else { path . pop_back (); need - -; } } int honest = path . front (); このアルゴリズムは N 回の質問で正直者を一人特定できます。あとはその人に他の人が正直者かを聞くこ とで全体で 2N 回で全ての正直者を特定できます。 4 ARC070 / ABC056 Editorial sigma425 A: HonestOrDishonest int main (){ char a ,b; cin >> a >> b; if (a == ’H ’ && b == ’H ’) cout << ’H ’; if (a == ’H ’ && b == ’D ’) cout << ’D ’; if (a == ’D ’ && b == ’H ’) cout << ’D ’; if (a == ’D ’ && b == ’D ’) cout << ’H ’; return 0; } B: NarrowRectanglesEasy If |a − b| ≤ W, the answer is 0. Otherwise the answer is |a − b| − W. C: Go Home The answer is the minimum t such that 1 + 2 + ... + t ≥ X. 1 D: No need The card ai is unnecessary if there is a subset of the other N − 1 cards whose sum is in the interval [K − ai , K). Thus, the straightforward DP is O(N3 ). There are two ways to improve it: • O(N2 logN): It turns out that if ap < aq and aq is unnecessary, ap is also unnecessary. Do binary search using this fact. • O(N2 ): Do DP twice: for prefixes and for suffixes. Also, it can be 64 times faster if you use bitset. 2 E: NarrowRectangles Define dp[i][x]: the minimum cost to move the first i rectangles such that the last (the i-th) rectangle’s leftmost coordinate is x. This will lead to a solution for partial score. Now, see dp[i] as a function: it returns dp[i][x] for given x. It turns out that this function is a polyline consisting of 2i + 3 sections, and the slopes of the sections are −i − 1, −i, . . . , i, i + 1 from left to right. Thus, this polyline can be represented using 2i + 3 integers l0, l1, . . . , li , r0, r1, . . . , ri , and c. • In the interval (−∞, li ], the slope of the polyline is −i − 1. • In the interval [li , li−1], the slope of the polyline is −i. • · · · • In the interval [l1, l0], the slope of the polyline is −1. • In the interval [l0, r0], the polyline is constant, and the value is c. • In the interval [r0, r1], the slope of the polyline is 1. • · · · • In the interval [ri−1, ri ], the slope of the polyline is i. • In the interval [ri ,∞), the slope of the polyline is i + 1. Now we compute the polylines in the order dp[0], dp[1], . . . , dp[N]. We should keep two sets (or priority queues) representing {l0, . . . , li} and {r0, . . . , ri} meanwhile, and the solution works in O(NlogN). 3 F: NarrowRectangles When A ≤ B, the solution is ”impossible” because A of unkind people can behave like honest people (call each other ”honest” and call everyone else ”unkind”). Otherwise, we can determine honest people in the following way: First, notice that when a person p says ”q is unkind”, p and q can’t be honest at the same time. Thus, even if we ignore both p and q, more than half of the remaining people is honest. Whenever we get the response ”unkind”, we ignore the two people. Create an empty stack and try to push N people to this stack one by one. When we push a person p in to the stack, we do the following. Let q be the person that is currently at the top of the stack. Ask q about person p, and if we get the answer ”unkind”, we pop q from the stack and ignore p and q. Otherwise, push p into the stack. After we try to push N people, what happens in the stack? Let a0, . . . , ak−1 be the people in the stack from bottom to top. From the construction of the stack, for each i, ai says ”ai+1 is honest”. Also, at least one of a0, . . . , ak−1 is honest. Thus, we are sure that ak−1 is honest. Now we can ask additional N queries to this honest person and get the answer. 4 ABC055 / ARC069 解説 writer : camypaper 2017 年 2 月 18 日 A : Restaurant 「何回 200 円もらえるか？」というのが本質的な問題です．n/15 とすることで C++ などの プログラミング言語では n を 15 で割った値の小数点以下切り捨てを求めることが可能です． 200 ∗ n/15 としてしまうと、正しい値を求めることができないことにも注意が必要です． #include <iostream> using namespace std; int main(){ int n; cin >> n; cout<<n*800-(n/15)*200<<endl; } B : Training Camp 「N! を 109 + 7 で割ったあまりを求めよ」という問題です．N! そのものを求めようとすると、 この値は非常に値が大きくなるため 64 ビット符号付き整数ではオーバーフローによって正しく値 を求められなかったり，多倍長整数の乗算計算は時間がかかるため実行時間制限内に計算を終える ことが難しくなります． 求める必要があるのは「109 + 7 で割ったあまり」であることに着目すると，現在のパワーを x として x = i × x mod 109 + 7 として更新していけば、64 ビット符号付整数で収まる範囲で計算 をすることが可能です．32 ビット符号付整数で扱っている場合 x × i が 109 より大きくなってし まいオーバーフローしてしまうことに注意してください． 1 C : Scc Puzzle 「S 字型のピースと c 字型のピースを組み合わせて Scc という組を可能な限り多く作りなさい」 という問題です．ただし，c 字型のピースを 2 つ組み合わせて，S 字型のピースを 1 つ作ること が可能です．このままでは複雑なので，可能な操作を以下の 2 種類だと考えます． 1. S 字型のピース 1 つと c 字型のピース 2 つを組み合わせて Scc の組を 1 つ作る 2. c 字型のピース 4 つを組み合わせて Scc の組を 1 つ作る なぜ，このように言い換えていいかを考えてみましょう．S 字型のピースが残っているにも関わ らず，c 字型のピースを 2 つを組み合わせて S 字型のピースを作る必要がないのは直感的にも明 らかでしょう．すると，S 字のピースがないときのみ c 字型のピース 2 つを使って S 字型のピー スを作る，という操作が行われます．その直後の操作はやはり，S 字型のピース 1 つと c 字型の ピース 2 つを組み合わせて Scc の組を作る，という操作になります．この 2 つの操作を 1 つにま とめると，「c 字型のピース 4 つを組み合わせて Scc の組を 1 つ作る」操作だとみなすことがで きます． 上記のような 2 種類の操作であることがわかると，可能な限り 1 番の操作を行ったのち，可能 な限り 2 番の操作を行うというのが最適なことが分かります．このようにして作ることができる Scc の組の数は簡単な四則演算により O(1) で答えを求めることが可能です． D : Menagerie 「円環状に並んでいる N 匹の動物たちに両隣の動物が同じ種類かどうか訪ねた結果と矛盾しな いような動物の割当てが存在するか？」という問題です．動物は羊と狼の 2 種類だけですが，羊は 本当のことを言うのに対して狼は嘘をつくのが問題を複雑にしています． この問題の重要な性質は「ある連続した 2 匹の種類が分かれば，その隣にいる動物の種類も分か る」ということです．例えば i − 1 番と i 番の動物の種類がそれぞれ分かっているとすると，i 番 の言っていることが本当か嘘かがまず分かります．次に i − 1 番の種類が分かっているので，i + 1 番の種類がどちらか分かる，ということです．さらに，i 番と i + 1 番の種類が分かっているので i + 2 番の種類が分かり，i + 1 番と i + 2 番の種類が分かっているので i + 3 番の種類が分かり， というように連鎖的に動物の種類が分かります． 上の性質から 1 番と 2 番の動物の種類を仮定すると 3, 4, 5, . . . , N 番の動物の種類が連鎖的に定 まります．最後にこの仮定が正しかったかどうかを s と矛盾しないかどうかで調べればよいです． 試す候補は高々 4 通りなので O(N) でこの問題を解くことが可能です． 2 E : Frequency 「N 個の石の山からあるルールで石の山を取り除いて長さ ∑ai の数列 s を辞書順最小になるよ うに構成するとき，s に 1, 2, 3, . . . , N がそれぞれ何回含まれるか？」という問題です．石を 1 個 取り除く山を選ぶときのルールは「(ai , i) が最大であるような i を選ぶ」としてよいです (以下， これを単にルールと呼びます)． ルールに従ったとき s が辞書順最小の数列となることを示します．x を石の数が最大である山 のうち最も左側にある石の山の番号とします． i < x かつ 0 < ai < ax であるような i が存在しない場合を考えます．x 番以外の山の石が取 り除かれたとき，次の操作において s の末尾に追加される数は明らかに x です．x 番の石の山か ら石が取り除かれたとき，その他の石の山は全て ax − 1 個以下の石からなります．さらに x 番よ り左側には石の数が 0 個の山しか存在しないので，石を 1 個取り除いた後も石の数最大であって 最も左側にある石の山は x 番です．よって，このときも次の操作において s の末尾に追加される 数は x です (ax = 0 となった場合は処理が終了するため，考慮する必要はありません)．結果とし て，x のみからなる数列が得られます．x より小さな数が s に追加されることはないため，明らか に辞書順最小です． i < x かつ 0 < ai < ax であるような i が存在している場合を考えます．y を i < x において (ai , i) が最大であるような i とします．このとき，辞書順最小の数列を得るためには x より大きな 値が s に追加されてはならないようにいくつかの石を取り除いて y が可能な限り早く s に現れる ようにする必要があります．これを，石の数を max(0, ai − ay) としたような石の山たちに対して 辞書順最小の数列を作っていくと考えると，x 番より左側には 0 個の山しかないという状況に帰着 させることが可能です．こうして石を取り除いたあと，y 番の山が石の数最大であって最も左側に ある石の山となります．再帰的にこのような処理を行っていけばいつか全ての石がなくなります． 以上より，(ai , i) が最大であるような山から石を取り除く，という操作を繰り返していけば s を 辞書順最小の数列にすることが可能なことが示されました． ルールを愚直にシミュレーションすると実行時間制限に間に合わないので高速化する必要があり ます．石の数が同じ石の山をまとめる，石をまとめて取り除く，という 2 つの高速化を行った以下 のアルゴリズムにより O(N log N) で解くことが可能です． • 石の山と石の番号 (ai , i) で降順にソートしたものを (xi , yi) とする • (ソートしたあとの並びで) 1 番目から順に処理を行う • 今 i 番目の石の山に着目しているとして，i(xi − xi+1) 個の石を取り除き，s に min{y1, y2, . . . , yi} を i(xi − xi+1) 個追加する (便宜上 xN+1 = 0 とする) これは i 番目の山を見ている時点で 1, 2, 3 . . . , i 番の山に含まれる石の数が等しく，i 個の石を 取り除く，という操作を xi − xi+1 回行っていると考えると分かりやすいかもしれません． 3 F: Flags 「i 番の旗を xi か yi のどちらかに設置する，という操作を N 回行ったときの旗同士の距離の最 小値を最大化せよ」という問題です．求める答えが d だとして，旗同士の距離が d−1, d−2, . . . , 0 となるように設置することが可能であったとみなしても問題ありません．そこで二分法を用いて d ✓ を求めていくことを考えます g．d を固定したとき，この問題は以下のように表せます． ✏ N 本の旗があり，i 番の旗は xi か yi のどちらかに設置しなくてはならない．どの 2 つの旗 も距離が d 以上になるように設置することは可能か判定せよ． ✒ ✑ 2 つの旗の距離が d 未満にならないかどうかにのみ着目すればよくなり，見通しがよくなりまし た．旗同士の距離は 2 つの旗の位置関係のみに依存しており，その他の旗は関係ないことは明らか です．すると「i 番の旗を xi に置いたとき，j 番の旗は yj に置いてはならない」というような制 約が最大 O(N2 ) 個与えられるので，条件を満たすように旗を設置することが可能か？という問題 になります．これを 2-SAT に帰着させて解いていきます． まず「i 番の旗を xi と yi のどちらに置くか」という N 個の変数に関する 2-SAT ではなく，z を x と y を連結して昇順に並び替えた数列として「i 番の旗を座標 zi に設置するかどうか」とい う 2N 個の変数に関する 2-SAT として考えます．このようにすると z は昇順の数列となっている ため「距離 d 未満に別の旗があってはならない」という制約が扱いやすくなります．2-SAT とし て考えやすいよう，問題を以下のように言い換えます． ✓ ✏ 真偽値をとる論理変数 v1, v2, . . . , v2N と以下に示されるようないくつかの論理式が与えられ たとき，全ての論理式が真となるような真偽値の割り当てが存在するか判定せよ． • ¬(vi ∧ vj ), ¬(¬vi ∧ ¬vj ) (ただし i, j は旗としての対応関係がある) • ¬(vi ∧ vl), ¬(vi ∧ vl+1), . . . , ¬(vi ∧ vi−1) (l は |zi − zl | < d となる最小の l) • ¬(vi ∧ vi+1), ¬(vi ∧ vi+2), . . . , ¬(vi ∧ vr) (r は |zi − zr| < d となる最大の r) ✒ ✑ このままでは最大で O(N2 ) 個程度の節からなる 2-SAT となってしまいます．ここで，vi が 真 のとき，偽となる必要がある論理変数たちが区間をなすことに着目します．論理変数をさらに 2 倍 程度の個数になるよう増やし，旗であった論理変数と葉が対応するように論理変数をセグメント木 状に配置し，以下のルールで節を作ることで変数の数を O(N)，節の数を O(N log N) に抑えるこ とが可能です． 1. セグメント木の葉であるような i と旗の対応関係がある j について ¬(vi ∧vj ), ¬(¬vi ∧¬vj ) 2. セグメント木上で親の頂点の番号を p として (vi → vp) 3. [l, i), [i + 1, r + 1) をセグメント木上で O(log N) 個の頂点 u1, u2, . . . , uk に分割したとし て ¬(vi ∧ u1), ¬(vi ∧ u2), . . . , ¬(vi ∧ uk) 4 図 1 にルール 2, 3 の具体例として v26 に着目した場面を示します．v26 に真を割り当てるとき， ルール 2 から先祖である赤色の頂点たちもまた真が割り当てられる必要があります．この「ある頂 点に真が割り当てられたならば，その先祖たちは全て真」という性質を「ある頂点に偽が割り当て られたならば，その子孫たち全てもまた偽が割り当てられている」という性質だと考えると，ルー ル 3 のように図中の濃い青色の頂点 v19, v5, v12, v27, v28 に対して節を追加することで「v26 に真 が割り当てられたとき，v19, v20, . . . , v25, v27, v28 は偽が割り当てられる必要がある」という条件 を O(log N) 個の節で表すことが可能となることが分かります． 変数の数 O(N)，節の数 O(N log N) の 2-SAT は 1 回あたり O(N log N) で調べることが可能 なので，二分法と合わせて O(N log N log max zi) で解くことが可能となります． 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 図 1 v26 に着目したときの節の追加ルール 5 ABC053 /ARC068 解説 writer : camypaper 2017 年 1 月 28 日 A : ABC /ARC 整数 x が標準入力から与えられるので x が 1200 未満かどうか判定せよ，という問題です． C++ などのプログラミング言語では以下のように if 文と呼ばれる構文を用いることで条件分岐を 行うことが可能です． #include <iostream> using namespace std; int main(){ int x; cin >> x; if(x < 1200) cout << "ABC" << endl; else cout << "ARC" << endl; } B : A to Z String 文字列 s の部分文字列のうち先頭が A ，末尾が Z であるようなものの最大の長さを求めよ，と いう問題です． 簡単な考察により， A は可能な限り先頭に近いものを用いるのが最適であり，Z は可能な限り末 尾に近いものを選ぶのが最適なことが分かります．それぞれの位置は，O(|s|) で調べることが可能 です． 1 C : X: Yet Another Dice Game 6 面サイコロに対して 90◦ 回転をしたのち，上を向いている面に書かれた整数を y として y 点 得る，という操作を何度も繰り返して合計 x 点以上得るために必要な最小の操作回数を求めよ，と いう問題です． はじめ，1, 6 以外の面が上を向くように置き，6 の面と 5 の面が交互に上を向くように転がすの が最適な操作手順です．このように操作を行ったときに必要な操作回数を求めればよく，これは簡 単な四則演算で O(1) で求められます． D : Card Eater N 枚のカードの山に対して何回か操作を行ってカードに書かれた値が全て異なるようにすると き，最大で何枚のカードを残せるか，という問題です．基本的には 1 枚しかないカードを取り除か れないカードに，余っているカードを取り除かれるカードに選ぶことができるので操作は「 2 枚の カードを選んで取り除く」とみなしてほぼ構いません． カードの山に k 種類のカードがあったとして，k が奇数なら余っているカードは偶数枚あるの で答えは k であり，偶数ならばどこかで必ず 1 枚しかないカードを 1 回取り除く必要があるので 答えは k − 1 となります． E : Snuke-Train 数直線上を原点から一定間隔 d で移動したとき何種類の区間を訪れることが可能か d = 1, 2, 3, . . . , M について調べよ，という問題です． 間隔 d を固定して考えてみましょう．このとき ri − li + 1 > d を満たす区間は必ず 1 回以上訪 れなくてはなりません．また， ri − li + 1 ≤ d を満たす区間は最大でも 1 回しか訪れることはで きません． 必ず 1 回以上訪れる区間は単に区間の長さによってのみ定まることが分かったので簡単に計算 することができます．残っているのは最大でも 1 回しか訪れない区間だけなので，ある位置を含む 区間の種類数を累積和などにより求めたのち， d の倍数を全て調べることで O(N + M) で調べる ことができます． さて d を固定した場合については解けましたが，1, 2, 3, . . . , M の M 種類について調べる 必要があります．M 以下の数について，1 の倍数,2 の倍数,. . .,M の倍数と全て調べることは O(M log M) で行うことが可能ですが，毎回全ての区間について O(N) で調べると O(NM) とな り実行時間制限に間に合いません．d を 1 から増加させていくと，必ず 1 回以上訪れる区間の数 は減少し，最大でも 1 回しか訪れない区間の数は増加していきます．そのため，N 個の区間を予 めその長さごとに分類しておけば各区間について区間に加算する，という操作は 1 回ずつで済み 2 ます．区間への加算も Fenwick Tree 等を用いることで 1 回あたり O(log M) で行うことが可能で す．解法をまとめると， • 区間を長さごとに分類する • d を 1 から M まで順に増加させながら調べる • i 番目の区間が初めて ri − li + 1 ≤ d となったとき， [li , ri ] に対して Fenwick Tree 等を用 いて 1 加算する • d の倍数を全て調べる となり，これらを合わせると O((M log M + N) log M) で解くことが可能です． F: Solitaire ✓ 結論から言えば，この問題は最終的に以下のように言い換えられます． ✏ (1, 2, . . . , N) の並び替えであるような数列 A のうち，以下の条件を満たすものは何通りあ るか？ • Ak = 1 • k ≤ i < j なる i, j について Ai > max(Aj ) あるいは Ai < min(Aj ) を満たす． • i < k において Ai > max(Aj )(i ≤ j) あるいは Ai < min(Bj )(j < i) を満たす． ✒ ✑ N − 1 個のうち k − 1 個を取って先頭側に，残りを末尾側に条件を満たすように並べることに します．また，末尾側に置いた要素の最大値を m とします． 末尾側の並べ方は 2 N−k−1 通りです．先頭側の並べ方について考えます．まず，Ai > max(Aj )(i ≤ j) を満たす要素は赤く塗られている，そうでない要素は青く塗られていると呼 ぶことにします．先頭側に置いた要素のうち m 未満のものは全て青く塗る必要があります．m よ り大きいものは赤く塗ることも青く塗ることも可能ですが，ひとまず赤く塗ったことにしておきま す．こうすると，赤く塗られた要素の最小値は青く塗られた要素の最大値よりも大きい，という性 質を持つため状態としてまとめやすくなります． dp(r, b) を「赤く塗られた要素が r 個，青く塗られた要素が b 個あるときの要素の並べ方」と します．この求め方はあとで考えることにすると，このときの並べ方の総数は ( m−2 N−k−1 ) dp(N − m, k − 1 − (N − m))2N−k−1 です．なお，k = N の場合は単に dp(N − 1, 0) となることに注意 してください． さて， dp(r, b) は以下の漸化式で定められます． dp(r, b) =    1 (r = 0, b = 0) 0 (r < 0 または b < 0) dp(r, b − 1) + ∑r−1 i=0 dp(i, b + r − (i + 1)) (otherwise) 3 この DP では O(N3 ) となってしまい間に合いません．しかし，この漸化式の ∑r−1 i=0 dp(i, b + r − (i + 1)) という部分の遷移は r − (i + 1) 個赤い要素を青く塗り直し，赤い要素を 1 つ取り除く， という形になっています．これを「赤い要素を 1 つ青く塗った次の操作は，赤い要素を 1 つ青く 塗るか，赤い要素を 1 つ取り除くかのどちらかでなくてはならない」と考えると，遷移を O(1) に まとめることが可能です． このようにすると dp(i, j) の前計算に O(N2 ) かかり，取得は O(1) となります．まとめて O(N2 ) となり正解することができました． 最後に上で示した条件を満たす数列であることと，2N 回の操作で構成可能であることが同値で あることを示します． 操作を逆から見ていくことにします．k ≤ i を満たす範囲においては Ai は現在デックに含まれ るどの数よりも大きい，あるいは小さい，という条件を満たすためデックの中身は 1 が最小値であ るような単調増加列となるように並べることが可能です．i < k を満たす範囲においては Ai は現 在デックに含まれるどの数よりも大きい，あるいは今後デックに含まれるどの値よりも小さい，と いう条件を満たします．青く塗られた要素は先頭に，赤く塗られた要素は末尾に挿入することにし ます．するとデックの中身は途中まで単調減少したのち，1 のある位置を境界としてその後単調増 加するような数列になります．こうしてできた数列について 1 を仕切りとして 2 つの単純減少列 をマージして新しい単調減少列を作る，と考えると 1, 2, 3, . . . , N という数列を構成することが可 能なことが分かります． 次にこの条件を満たさない数列は構成不可能なことを示します．k ≤ i を満たす範囲において， Ai が現在デックに含まれるどの数よりも大きい，あるいは小さい，という条件を満たさない箇所 があるとすると 1 のある位置を仕切りとした 2 つの単調減少列となるように出来ないため構成す ることが不可能です．同様に i < k を満たす範囲において，Ai が現在デックに含まれるどの数よ りも大きい，あるいは今後デックに含まれるどの値よりも小さい，という条件を満たさない箇所が あるとしても，やはり先程と同様に構成することが不可能です． 以上より上で述べた条件を満たす数列であることと，2N 回の操作により構成可能であることが 同値であることが示されました． 4 ABC 052 / ARC 067 解説 writer : maroonrk 2017 年 1 月 15 日 A : Two Rectangles 二つの長方形の面積の max を出力すればよいです。 C++ のコード例 int a ,b ,c , d ; cin > > a >> b >> c >> d ; cout < < max ( a *b , c * d ) << endl ; B : Increment Decrement 整数 ans = 0 を用意して、x の値を変更する度に ans と x の max を ans に代入すると答えが求まります。 C : Factors of Factorial ある整数 x が、素因数分解によって x = p n × q m × ... (p, q, ...は素数) と表せる時、x の約数の個数は (n + 1) × (m + 1) × ... となります。よって、N! の素因数全てについて、その素因数で N! が何回割り切れる かを求めればよいです。そして、N! のがどの素因数で何回割れるかは、1 から N までの数がそれぞれどの素 因数で何回割れるかを求めて足し合わせると求まります。今回の問題は N が小さいので、これを愚直に実装 すれば解くことができます。 D : Walk and Teleport 実はこの問題では、「一つ東の町まで歩く」と「一つ東の町までテレポートする」の二つの行動だけで最適 解を達成できます。よって、全ての i(i ≤ N − 1) について、町 i から町 i + 1 に移動する際の疲労度の合計の 最小値を求め、これを全て足し合わせると答えが得られます。町 i から町 i + 1 に移動する際の疲労度の合計 の最小値は、min((Xi+1 − Xi) × A, B) で求めることができるので、これでこの問題は解けました。 1 E : Grouping DP[i][j] = i 人以下のグループのみで、j 人使っている場合の数 という DP を考えます。この DP の遷移は、以下のようになります。 DP[i][j] = ∑ k∈(0,C,C+1,...D) DP[i − 1][j − i × k] ×(n−j+i×k) P(i×k)/(i!)k/k! これでは一見 O(N3 ) に見えますが、k の動く範囲は j/i 以下しか考えなくて良いので、そこだけ計算する ようにすると O(N2 logN) になってこの問題が解けます。 F : Yakiniku Restaurants 最適な行動においては、焼肉店間の移動は、番号の小さい方から大きい方への移動のみと考えて良いです。 そこで、 F(i, j) = 焼肉店 i から出発し、焼肉店 j で終了するように行動した時の、食べる焼き肉の美味しさの合計 の最大値 と置きます。この F(i, j) の値が、全ての i, j の組について求められれば、幸福度を減らす要因である移動 距離は簡単に計算できるため、最終的な答えもすぐにわかります。では、F(i, j) はどのように求めればよい でしょうか。とりあえず、M 種類のチケットごとに考えてみます。 G(x, i, j) = 焼肉店 i から焼肉店 j までの焼肉店で、チケット x を引き換えに食べられる焼き肉の美味しさ の最大値 と置いてみます。全てのチケットについて、G(x, i, j) を愚直に求めていては間に合いません。そこで、x を固定した時の、G(x, i, j) の値について考えてみましょう。まず、G(x, 1, N) = G(x, opt, opt) となる焼肉店 opt が存在します。（この opt は、RMQ を使うと高速に求めることができます）そして、i ≤ opt ≤ j なる全 ての i, j について、G(x, i, j) = G(x, opt, opt) となります。これが何を表しているかというと、格子点 (i, j) の値が G(x, i, j) になる格子を考えた時に、i ≤ opt ≤ j に対応する長方形領域内の値が全て同じであるとい うことです。残った、i, j < opt のパターンと、opt < i, j のパターンも、再帰的に同じことを繰り返すと、格 子点 (i, j) の値が G(x, i, j) になる格子は、N 個の長方形領域に数字を割り振るという操作で作られるという ことになります。ここで、F(i, j) について考えると、これは、全ての x について、G(x, i, j) を足して作られ ます。このことから、格子点 (i, j) の値が F(i, j) になる格子は、M 種類全てのチケットごとに、N 個の長方 形領域に値を加算する、という操作で作られることになります。これは、imos 法を使うことで十分高速に処 理できます。よって、O(NlogNM + N2 ) でこの問題は解けました。 2 ABC 050 / ARC 066 解説 writer : maroonrk 2016 年 12 月 17 日 A : Addition and Subtraction Easy 整数、文字列、整数を空白区切りで読み込み、読んだ文字列が “+” か “-” で条件分岐をします。 C++ のコード例 int a , b ; string op ; cin > > a >> op >> b ; if ( op == "+") cout << a + b << endl ; else cout << a - b << endl ; B : Contest with Drinks Easy それぞれの問題にかかる時間を配列に保存しておきます。ドリンクごとに、配列を一時的に変更し、その総 和を求めて出力すればよいです。なお、予めかかる時間の総和を求めておいて、ドリンクが与えられた時に差 分だけ計算する方法だと、より高速に答えが求まります。 C : Lining Up N が偶数である場合を考えます。N 人が並んだ場合、「自分の左に並んでいた人数と自分の右に並んでいた 人数の差の絶対値」は、N − 1, N − 3, N − 5, ...3, 1, 1, 3, ...N − 5, N − 3, N − 1 となるはずです。この配列 を Bi とします。 するとこの問題は、Ai を並び替えて Bi にする方法は何通りか、という問題になります。まず、Ai と Bi で、ある値の登場する回数が等しくなかった場合、明らかに答えは 0 です。 では、等しい場合はどうなるでしょうか。この配列には、N/2 種類の値が、それぞれ 2 回ずつ登場している はずです。それぞれの値について、並び替える方法は、「Ai で前にあったものが Bi で前にある」と、「Ai で 前にあったものが Bi で後ろにある」の 2 通り考えられます。 N/2 種類の値で独立に並び替えがあるので、求める答えは 2 (N/2) になります。N が奇数である場合も同様 1 に解けますが、その場合 Ai や Bi の中に 0 という値が 1 度だけ登場することに注意してください。 D : Xor Sum 説明のため、and をビットごとの論理積、<< を左シフト演算、>> を右シフト演算とします。 方針としては、a と b のビットを上から決めていく桁 DP を考えます。u = a xor b としている限り、0 ≤ u は常に成り立ちます。また、v = a + b = ((a and b) << 1) + (a xor b) = ((a and b) << 1) + u ≥ u なの で、v ≤ N という条件のみに注意すればよいです。そこで、次のような DP を考えます。 dp[i][j] = a と b の i ビット目以上が決定していて、その段階で v = j となる通り数。 この DP では、以下の 3 パターンの遷移が考えられます。 ・a の i ビット目と b の i ビット目が共に 1 の場合 ・a の i ビット目と b の i ビット目のどちらか片方のみが 1 の場合 ・a の i ビット目と b の i ビット目が共に 0 の場合 しかし、このままではこの DP は O(NlogN) となってとても間に合いません。そこで、この DP を少し修 正して、以下のようにしてみます。 dp[i][j] = a と b の i ビット目以上が決定していて、その段階で (v >> i) = (N >> i) − j となる通り数。 これは一見、先程より複雑になっただけで、計算量が改善していないように見えます。しかし、j ≥ 2 のパ ターンは、その後どのように a, b のビットを選んでも、v が N を超えることが起きません。なので、それら のパターンを全て j = 2 として扱ってよくなります。よって j の範囲は 0～2 だけを考えればよくなり、この DP が O(logN) で行えるようになりました。 E : Addition and Subtraction Hard 簡単のため、最初の数の前に “+” という記号があるものとして扱います。まず、“+” のあとで開き括弧を挿 入しても意味がないことがわかります。また、“-” のあとに開き括弧を必ず挿入しても問題ありません。なぜ なら、そこで開いた括弧を、次の数の直後で閉じれば、括弧をつけていないのと変わらないからです。また、 同じ箇所に開き括弧を 2 個以上挿入するのも無意味です。ここで、次のような DP を考えます。 dp[i][j] = i 項目の直後で、j 個括弧が開いている時の、そこまでの式の値の最大値。 これをどのように更新すればいいのでしょうか。上の議論より、開き括弧の直前には必ず “-” があるはずで す。つまり、x 個括弧が開いている中にある数は、最終的に (−1)x 倍された値として計算されるということで す。これがわかれば更新するのは簡単です。この DP で答えが求まりましたが、これでは O(N2 ) となり、時 間制限に間に合いません。 しかし実は、括弧は 3 個以上開く必要がありません。なぜなら、括弧を 2 個開いたあとは、“-” の前で必ず 一つ括弧を閉じるようにすることで、残りの数を全て “+” として扱うことができるからです。よって j の範 囲は 0～2 だけを考えればよくなり、この DP が O(N) で行えるようになりました。 F : Contest with Drinks Hard 最初に、ドリンクがない状態で、最大スコアを求めましょう。この問題は、 「いくつか区間を選んで、 2 ∑ 選んだ区間 (区間の長さ) ∗ (区間の長さ + 1)/2 − 区間に含まれる問題にかかる時間の合計 を最大化せよ」 と言い換えることができます。まず、次のような DP を考えます。 dp[i] = 問題 i まで考えた時の最大スコア。 この DP の遷移は、以下のようになります。 dp[i] = max(max{0≤j<i}{dp[j] + (i − j) ∗ (i − j + 1)/2 − (sum(i) − sum(j))}, dp[i − 1]) ここで、sum(x) は、問題 1～x までを解くのにかかる時間の総和です。さらに、式を整理すると、以下の ようになります。 dp[i] = max(max{0≤j<i}{−j ∗ i + j ∗ (j − 1)/2 + dp[j] + sum(j)} + i ∗ (i + 1)/2 − sum(i), dp[i − 1]) これは、内側の max の中が、i に関する 1 次式になっているので、ConvexHullTrick を使って高速化する ことができます。よって、この DP は O(N) で計算することができます。 では、クエリに答えるにはどうすればいいのでしょうか。そのためには、各問題について、それを解く時の 最大スコア、解かない時の最大スコアを前計算しておけばよいです。 では、前計算はどうすればいいのでしょうか。上記の DP を、左から進めていったものと、右から進めて いったものを用意すると、ある問題を解かない時の最大スコアはすぐに求まります。 次に、ある問題を解くときの最大スコアについて考えます。まず、M = N/2 として、問題 i(i ≥ M) と M を含む区間を解くときの最大スコアを考えます。これは、さっきの DP を少し変えると求まり、先ほどと同様 に ConvexHullTrick で O(N) で求めることができます。同様に、問題 i(i ≤ M − 1) と M を含む区間を解く ときの最大スコアも求められます。すると、ほかに考えるべきものは、問題 i(1 < M) を含んで、M を含ま ない区間と、問題 i(M < i) を含んで、M を含まない区間だけです。問題を、M の左の部分と右の部分に分 けることができたので、分割統治をすると良いとわかります。分割統治の 1 ステップが O(N) なので、合計 O(NlogN) で求めることが出来ました。 3 ABC 049 / ARC 065 解説 writer : hogloid 2016 年 12 月 10 日 English Editorial starts on page 5. A : 居合を終え、青い絵を覆う 文字を入力し、それが a, e, i, o, u のいずれかであるか判定すればよいです。 if の中に 5 つの条件を連ねる以外にも、以下のように母音全てを含む文字列が c を含むか判定することもで きます。 C++ のコード例 char c ; cin >> c ; const string vowel = " aeiou "; cout << vowel . find ( c ) == string :: npos ? " vowel " : " consonant " << endl ; B : たてなが この問題では、出力する画像をピクセルごとに求める方針でも解くことができますが、出力する画像の 1, 2 行目は元の画像の 1 行目、3, 4 行目は元の画像の 2 行目…のように、上の行から順に 2 回出力を繰り返せばよ いです。 C++ のコード例 int h , w ; cin >> h >> w ; char buf [105]; for ( int i = 0; i < h ; ++ i ) { scanf ("% s " , buf ); printf ("% s \ n % s \ n " , buf , buf ); } 1 C : 白昼夢 文字列 S を dream, dreamer, erase, eraser に分解していくことを考えます。先頭から分解していこうとす ると、例えば dreamer まで読んだとき、dream で切るべきなのか、dreamer で切るべきなのか判定するこ とができません。(dreameraser は dream eraser と切らなければならないので、dreamer まで読んだときに dream で切らなければいけない場合が存在することが分かります) 逆に、後ろから読んでみましょう。4 つの単語を後ろから読むと、それぞれ maerd, remaerd, esare, resare となります。この 4 つの文字列は、ある文字列が他の文字列の接頭辞 (prefix) になっていないため、後ろか ら読んで当てはまるものが見つかれば即座に分解するしかありません。(参考: 語頭符号) S を最終的に分解す ることができなかった場合 NO を、そうでない場合 YES を出力します。 D : 連結 配列 ar で、都市 i と都市 j が道路で連結しているとき ar[i] = ar[j]、そうでないとき ar[i] ̸= ar[j] となる ようなものを取ります。これは、道路の辺を使い深さ優先探索をしたり、道路で直接結ばれた都市をつないだ Union-Find での根の都市の番号を取ることにより実現できます。 同様に、配列 br で、都市 i と都市 j が鉄道で連結しているとき br[i] = br[j]、そうでないとき br[i] ̸= br[j] となるようなものを取ります。 このとき、i と j が鉄道・道路の両方で連結している ⇔ ar[i] = ar[j] ∧ br[i] = br[j] です。よって、各 i に ついて、(ar[i], br[i]) のようにペアとし、同じペアがいくつ出てくるかを配列のソートや連想配列などを用い 求めることで解くことができます。O(K + L + NlogN) です。 E : へんなコンパス まず、(xi , yi) 7→ (xi + yi , xi − yi) と穴の座標を置き換えます。これは、平面を 45 度回転させる操作に対 応します。 これにより、d(i, j) = max(|xi − xj |, |yi − yj |) となります。 必須ではありませんが、この方が何かと実装が平易で済みます。 コンパスにより指される点の組を求めますが、コンパスの指す 2 穴の間の距離 D は常に不変なので、コン パスが指すことのできる穴の集合を求めれば、そこから距離 D の頂点の数を求め総和を取り 2 で割ることで 答えが求まります。 コンパスが指すことのできる穴の集合 S は、以下のように再帰的に求めることができます。 2 擬似コード S := empty dfs ( int v ){ // 穴 v をコンパスが指すことができると分かった S に v を追加 S に追加されておらず、v から距離の穴D u それぞれについて{ dfs ( u ) } } dfs ( a ) ここで、 • S に追加されておらず • v から距離 D の穴 の 2 の条件をともに満たす穴のみを列挙することで O(N) 回の操作になります。 一つ目の条件が欠けていると、例えば変換後に xi = i/2, yi = (i mod 2) ∗ 1000000000 (割り算は切り捨て) と いった場合に、距離 D の穴の組は O(N2 ) 個あるため間に合いません。 また、まだ追加されていない全ての頂点について調べる、などを行うと、これもやはり O(N2 ) となってしま います。 「まだ S に追加されておらず、v から距離 D の穴」を 4 つの部分に分けてみましょう。 • (xv + D, yv − D)...(xv + D, yv + D) の間の点 (v の右側) • (xv − D, yv − D)...(xv − D, yv + D) の間の点 (v の左側) • (xv − D, yv + D)...(xv + D, yv + D) の間の点 (v の上側) • (xv − D, yv − D)...(xv + D, yv − D) の間の点 (v の下側) さらに、順序集合 (C++ なら std::set) を使ってみましょう。順序を x での比較、同じなら y での比較としま す。v の右側の穴を列挙するためには、(xv + D, yv − D) 以上 (xv + D, yv + D) 以下の穴のみが条件を満た します。これらを 1 つずつ走査していけばよいです。S に v が追加されたときに、この順序集合からも穴の座 標を取り除いておけば、一つ目の条件も満たすことができます。左側も同様です。上側・下側の穴は、x, y の 比較の順番を逆にした順序集合を持てば同様に実現できます。 コンパスが指すことのできる点から距離 D の穴の数が求める処理が残っています。これは、穴を順序集合 で持つ代わりに配列で持ち、ソートし、条件を満たす穴の範囲を二分探索で求め、範囲の長さについて加算す れば実現できます。先ほどの操作とは違い、条件を満たすものの数を重複なく数えなければいけないため、四 隅の条件に注意してください。 順序集合からの削除や、二分探索があるため、計算量は O(NlogN) となります。 おまけ: ソートと O(N) 回の Union-Find の操作の他は線形で解くこともできます。 3 F : シャッフル まず、ri ≥ rj , i < j なる j については、j 番目の操作を行っても行わなくても答えは変わりません。 条件を満たす i のうち最大のものを取ると、k(i < k ≤ j) 番目の操作によりシャッフルされる範囲は全て i 番 目のシャッフルにより自由に並べ替えることができるためです。 また、li = lj , ri > rj なる j も、同様に j 番目の操作を行っても行わなくても答えは変わりません。 これにより、答えの変わらない操作を取り除くことで、i < j のとき li < lj , ri < rj を満たすよう操作の列 を取ることができます。 次に、シャッフルは部分文字列の配置を全て決めてしまう操作で、これを行うと状態が爆発してしまうた め、逐次的な操作に置き換えることを考えましょう。文字列を左から順に決めていくことを考えます。k 番目 より左の文字列を決めたとき、 • どこまでがシャッフルされることになっているか (すなわち、自由に並べ替えることができるか) • シャッフルされることになる部分文字列のうち、1 はいくつあるか を覚えておけば、1 か 0 を置いていくことができます。なぜなら、シャッフルにより並べ方は自由になってし まうため、1 の数さえ覚えておけば大丈夫だからです。どこまでがシャッフルされることになっているか、は k により一意に決めることができます。li < k なる最大の i を取ったときの ri です。これを rightendk と表 します。 ここで、DP を考えてみましょう。 dp[k][j] := k 番目より左の文字列は決め、S[k...rightendk] に 1 が j 個あるときの、k 番目までの文字列の決 め方の数 とします。シャッフルされることになる文字列の中の 1 の数を one とします。 • li = k となる i があるとき、S[rightendk...ri ] が新たにシャッフルすることになる部分に加わるので、 one = j + (S[rightendk...ri ] の中の 1 の数 ) とします。 • そうでないとき、one = j とします。 k 番目の文字を決めるとき、 • one > 0 なら 1 を置くことに対応する状態遷移を書きます (dp[k + 1][one − 1]+ = dp[k][j])。 • 同様に、全てが 1 でないとき、0 を置く状態遷移を書きます (dp[k + 1][one]+ = dp[k][j]) 最終的な答えは、dp[N + 1][0] となります。 この DP では、ある文字がどの操作によってもシャッフルされないときを考慮していないため、そのような 場合は「1 文字の部分をシャッフルする」(=実質的に何も行わない) ダミーの操作を加えたり、初めから文字 列を切り分けてしまうことで対応できます。 計算量は O(N2 ) です。 4 ABC 049 / ARC 065 Rough Editorial writer : hogloid 2016 年 12 月 10 日 A : UOIAUAI C++ Code Example char c ; cin >> c ; const string vowel = " aeiou "; cout << vowel . find ( c ) == string :: npos ? " vowel " : " consonant " << endl ; B : Thin Repeat each row twice. C++ Code Example int h , w ; cin >> h >> w ; char buf [105]; for ( int i = 0; i < h ; ++ i ) { scanf ("% s " , buf ); printf ("% s \ n % s \ n " , buf , buf ); } C : Daydream Reverse the strings. Then, the four words will be: maerd, remaerd, esare, resare. This way you can determine the composition greedily. 1 D : Connectivity Construct a graph with roads and find the connected components in it. Then, you can assign values ai to each city i such that the cities p and q are reachable using roads iff ap = aq. Similarly, define values bi for railways. Then, a pair of two cities satisfies the conditions iff their (a, b) values are the same. E : Manhattan Compass Let D be the distance between the two points initially pointed by the compass. We have two things to do: • Construct a graph with N vertices. Two vertices a and b are connected if the distance between them is D. Find connected components in this graph. • For each vertex a, count the number of vertices b such that the distance between a and b is D. The latter is relatively easy, so we describe the former. First rotate the entire plane by 45 degrees. Let dx, dy be the difference of x, y coordinates. Now we are intersted in a pair of points such that max(dx, dy) = D. To do this, we want to find all pairs of points (a, b) such that • xb − xa = D • −D ≤ yb − ya ≤ D Let’s sort the points by the pair (x, y) and renumber them. Then, for a fixed a, the set of b that satisfies the conditions above will form an interval. Let [L, R] be this interval (the interval can be found using binary search). Then, we want to add edges a - L, a - L + 1, . . ., a - R. Instead, it is equivalent to add edges a - L and L - L+ 1, L+ 1 - L+ 2, . . ., R−1 - R. This way, except for O(N) edges, each edge connect adjacent points, so if we compute all edges that connect adjacent points in a clever way, there will be O(N) edges in total. We should do similar things after swapping x and y. After that, we get the desired graph. F : Shuffle If li = lj , ri > rj , we can ignore the pair j. Thus, we can assume that M = N and for each i, li = i. Let dp[L][R][c] be the number of strings we can obtain under the following state: • We’ve fixed all characters to the left of L. • The characters in the range [L, R) are shuffled. c of them are 1. • In the future, we will perform operations with li ≥ L. We compute the values as follows: 2 • When L = N, we’ve finished; the value is 1. • If aL > R, we can extend the ”shuffled range”; change R to aL and increase c by the number of ones in the interval [R, aL]. • Now consider two cases for the characters at L. If this is ’0’ (or ’1’), there are dp[L + 1][R][c] (or dp[L+1][R][c−1]) ways to determine the rest. Thus dp[L][R][c] = dp[L+1][R][c]+dp[L+1][R][c−1]. (Make sure not to access invalid values) This looks like an O(N3 ) solution, but we can notice that for a fixed L, only one R appears during the computation. Thus, we can ignore the value of R and it turns out to be an O(N2 ) solution. 3 ABC 048 / ARC 064 解説 writer : sugim48 2016 年 12 月 4 日 A : AtCoder *** Contest 3 個の文字列を入力し，それらの 1 文字目を続けて出力すればよいです． C++ のコード例 string a , b , c ; cin >> a >> b >> c ; cout << a [0] << b [0] << c [0] << endl ; B : Between a and b ... a 以上 b 以下の整数のうち条件を満たすものの個数を求める問題です．このような問題では， f(n) := 0 以上 n 以下の整数のうち条件を満たすものの個数 と定義しておくと，答えは f(b) − f(a − 1) で求まるので楽です．ただし，a = 0 のときに f(−1) が呼ばれる ことに注意してください．このことに注意すると，f は次のように書けます． f(n) = { n/x + 1 (n ≥ 0) 0 (n = −1) ただし，/ は切り捨ての除算です． C : Boxes and Candies 各 1 ≤ i ≤ N − 1 について ai + ai+1 ≤ x となるように，a の各要素を (非負整数の範囲で) 減らしていき ます．最後に，元の a と比べることで操作回数が分かります．この操作回数を最小化することを目指します． まず，a1 > x ならば a1 = x としておきます．次に，i = 1, 2, ..., N − 1 の順に ai + ai+1 ≤ x を成立させ ていきます．とりあえず，最初から ai + ai+1 ≤ x ならば何もする必要はありません．ai + ai+1 > x ならば， ai + ai+1 = x となるまで ai と ai+1 を減らさなければなりませんが，このとき ai+1 だけを減らすのが最適 であることが分かります．なぜならば，これから各 j > i について aj + aj+1 ≤ x を成立させていくときに， ai+1 が小さいほど操作回数が少なくなることが期待できるからです． 以上の貪欲法により正しく答えを求めることができます．なお，オーバーフローに注意してください． 1 D : An Ordinary Game 結論から述べると，「s の長さが偶数である」と「s の先頭文字と末尾文字が同一である」の排他的論理和が 真ならば後手が勝ち，偽ならば先手が勝ちます．以降はこれを示します． どちらかのプレイヤーが操作を行えなくなったときの，最終的な s について考えます．最終的な s は “abababab...” のように，異なる 2 文字が交互に並んでいるはずです．なぜならば，ルールより同一の文字 が隣り合う箇所はなく，また “abc” のように異なる 3 文字が連続する箇所があれば，まだ真ん中の文字を取 り除けるからです． 最終的な s の長さは一意には定まりませんが，その偶奇は一意に定まります．具体的には，s の先頭文字と 末尾文字が同一ならば “ababa” のように奇数長となり，s の先頭文字と末尾文字が異なるならば “ababab” のように偶数長となります．以上より，最初と最後で s の長さの偶奇が分かっているので，ターン数の偶奇も 分かります．よって，どちらのプレイヤーが先に操作を行えなくなるかが求まります． E : Cosmic Rays 簡単のため，始点 (xs, ys) および終点 (xt, yt) にも半径 0 のバリアが張られていると仮定します．すると， 始点および終点はそれぞれあるバリアの中心に位置することになります． 始点から終点までの最適経路を求めるとき，すぬけ君はバリアの中心どうしを結ぶ線分上のみを移動すると 仮定してもよいことが分かります．なぜならば，あるバリアの境界から別のバリアの境界まで移動するとき は，それらのバリアの中心を結ぶ線分上を移動するのが最適であり，また，あるバリアの内部を移動するとき は，一度そのバリアの中心を経由しても損はしないからです． よって，各バリアの中心を頂点として全点間に辺を張ったグラフを考え，このグラフの最短経路問題を解け ばよいことになります．バリア i, j の中心を結ぶ辺のコストは wij は wij = max { 0, √ (xi − xj ) 2 + (yi − yj ) 2 − (ri + rj ) } と計算できます．辺のコストがすべて非負の最短経路問題なので，Dijkstra 法で解くことができます．時間 計算量は O(N2 ) です．なお，実装によっては，始点から終点まで直接移動する経路を見落とすことがあるの で，注意してください． F : Rotated Palindromes 長さ N の数列 a を考えます．d が N の約数であり，長さ d の数列の繰り返しとして a が表されるとしま す．このとき，d は a の周期であるとします．a の周期のうち最小のものを最小周期と呼ぶことにします．た とえば，(1, 2, 1, 2, 1, 2, 1, 2) の最小周期は 2 で，(1, 2, 1) の最小周期は 3 です． 高橋君が用意する数列 a の最小周期 d を全探索することを考えます．最小周期 d を固定したとき，高 橋君が用意できる数列 a の個数を num[d] とします．num[d] は次のように計算できます．まず，a は回 文なので，a の先頭 d 文字分も回文であることが分かります．長さ d の回文の個数は K⌈d/2⌉ です．では num[d] = K⌈d/2⌉ なのかというと，そうではありません．d ′ (̸= d) を d の約数としたとき，num[d ′ ] も余分 2 に数えてしまっているからです．これを踏まえると，num[d] は num[d] = K⌈d/2⌉ − ∑ d′ |d, d′̸=d num[d ′ ] と計算できます．以上のようにして，小さい d から順に num[d] を埋めていくことができます． 次に，高橋君が最小周期 d の数列 a を用意したとき，青木君の操作によって何通りの数列が得られるかを 考えます．最小周期が d なので，0, 1, ..., d − 1 回操作を行って得られる数列はすべて異なることが分かりま す．また，d 回操作を行うと元の a に戻ることが分かります．よって，最小周期 d の数列 a からは d 通りの 数列が得られることになります．では問題の答えは ∑ d|N num[d] · d なのかというと，そうではありません． 高橋君が用意した別々の数列 a から，青木君の操作によって同一の数列が得られる可能性があるからです．具 体的には，最小周期 d が奇数の数列 a から得られる各数列は，全体でちょうど 1 回ずつ生成されており，最 小周期 d が偶数の数列 a から得られる各数列は，全体でちょうど 2 回ずつ生成されています (証明は後述)． よって，正しい答えは ∑ d|N, d:odd num[d] · d + ∑ d|N, d:even num[d] · d 2 と計算できます． 時間計算量は O(d(N) 2 ) です．ここで，d(N) は N の約数の個数です．N ≤ 109 における d(N) の最大値 は，d(735,134,400) = 1,344 とそこまで大きくありません．よって，O(d(N) 2 ) でも十分間に合います． (証明) 高橋君が用意した別々の数列 a, b から，青木君の操作によって同一の数列が得られたとします．こ れはすなわち，a に何回か操作を行って得られる数列が b に一致するということです．よって，a と b の最小 周期は等しいことが分かります．これを d とおきます．すると，a に 1, 2, ..., d − 1 回操作を行って得られる 数列のどれか 1 つのみが b に一致することになります．ここでは，a に t 回操作を行って得られる数列が b に一致するとします．このとき，a に t 回逆操作を行って得られる数列も b に一致します．なぜならば，数列 a を逆順にした数列を a と書くことにすると， (a に t 回逆操作をした数列) = (a に t 回逆操作をした数列) = (a に t 回操作をした数列) = b = b となるからです．よって，a に d − t 回逆操作を行って得られる数列も b に一致します．a に 1, 2, ..., d − 1 回操作を行って得られる数列のどれか 1 つのみが b に一致するので，t = d − t でなければならず，d = 2t が 得られます． 以上より，最小周期 d が奇数の数列 a については，同一の数列を生成するような別の数列 b は存在しませ ん．逆に，最小周期 d が偶数の数列 a については，同一の数列を生成するような別の数列 b がちょうど 1 つ 存在します．そのような b は，a に d 2 回操作を行って得られる数列です．このとき，仮に a = b とすると d 2 も周期となり矛盾するので，a と b は別々であることが分かります． 3 ARC062 / ABC046 解説 sigma425 A: AtCoDeer くんとペンキ a = b = c の場合は 1 を、a = b ̸= c または a = c ̸= b または b = c ̸= a の場合は 2 を、それ以外の場合は 3 を出力すれば良いです。 B: AtCoDeer くんとボール色塗り まず左端のボールに塗る色を決めます。これは K 通りあります。さらに左から順番に塗る色を決めていき ます。この時、これまでどのように塗っていようが、”ひとつ左のボールに塗られている色”以外の K − 1 通 りの色が塗れるので、全体では K · (K − 1)N−1 通りになります。答えが大きいので、塗り方をすべて試す方 法では間に合いません。 C: AtCoDeer くんと選挙速報 各途中状態で、できるだけ投票数が少ない方がよいです (投票数を増やすのはいつでも出来るので)。今高橋 君に A 票、青木君に B 票入っていて、次に満たすべき比率が x : y だとすると、A ≤ nx ∧ B ≤ ny なるよ うな最小の自然数 n を取れば、次にあり得る最小の得票数は nx, ny であることがわかります。このような n は max(⌈A/x⌉, ⌈B/y⌉) で計算できます。はじめに A = 1, B = 1 として、これを N 回繰り返すことで O(N) で答えが得られます。 D: AtCoDeer くんと変なじゃんけん 相手が P 回パーを出したとします。まず自分が全てグーを出したとすると、この時の得点は −P 点です。 自分のグーのどれかひとつをパーに変えることを考えると、 • そのターンの相手の手がグーのとき　・・・ あいこ (0 点) から勝ち (1 点) に変わるので、 得点は 1 増 えます。 • そのターンの相手の手がパーのとき　・・・ 負け (−1 点) からあいこ (0 点) に変わるので、 得点は 1 増えます。 従って、自分や相手がどのターンでパーを出したかによらず、得点は (自分がパーを出した回数)-(相手がパー を出した回数) 　になります。なのでできるだけ多くパーを出せばよいです。グー, パー, グー, パー,... と出す ことでこれが実現できて、⌊N/2⌋ 回出せます。よって答えは ⌊N/2⌋ − P です。 1 E: AtCoDeer くんと立方体づくり 立方体の上面と底面のパネルとその向きを、どれを使うか全探索します。すると 8 つの頂点の色がすべて決 まるので、あとは各側面に対し置けるパネルの数を数えれば良いです。これはパネルを”正規化”した形で表し て、回転による差異を無視できるようにしてから map に入れて数を数えるなどの方法でできます。(例えば、 入力のように 4 つの数の列でパネルを表すとして、回転によって 4 通りの列が考えられるがそのうち辞書順最 小のものでパネルを表す など) 他の部分に使ったパネルは使えないのでちゃんと使った分は引くことと、パネルの向きの置き方が何通りあ るか (例えば 4 点同じ色のパネルだと,4 通り置ける) に注意すれば、側面の置き方を数えることが可能です。 あとは、同じ立方体を何回重複して数えているか (これは数え方によって異なります) で割れば答えが求まり ます。計算量は O(N2 logN) ですが定数倍はかなり重いです。 F: AtCoDeer くんとグラフ色塗り まず二重 (頂点) 連結成分分解します。異なる辺 x,y に対し, x と y が同じ成分に属する ⇔ x と y を両方含 む単純なサイクルがある なので、各操作はある連結成分内でしか行なえません。なので、各連結成分ごとに 独立に考えられます。 1. 成分が辺一本のとき 塗り方は K 通りです。 2. 成分がサイクルをなすとき サイクルを塗る方法なので、これはポリアの定理から、サイクルを n 頂点とすると、 1 n n∑−1 i=0 Kgcd(n,i) で計算できます。 3. それ以外 この時成分内で任意の置換が作れることがわかります。従って、連結成分の辺の個数を m 本とすると、 答えは、m+K−1CK−1 になります。 従って各連結成分ごとにこれらの値をかけ合わせると答えが求まります。 3 の場合に任意の置換が作れることの証明をします。 まず次の図のように、異なる頂点 x,y を,3 つの edge disjoint な (互いに辺を共有しない)path a,b,c が結ん でいる状況を考えます。このグラフを便宜的に G と呼びます。 2 このとき、次のように操作をすることで、頂点 y に接続する path a の辺と path b の辺を swap することが出 来ます。 また、この操作を使って、グラフ G の任意の隣接する二辺を swap することが可能です。具体的には、まずそ の二辺が y に隣接するようにサイクルを回して、上の操作を行い、はじめにサイクルを回した部分の逆操作を 行えばよいです。 3 これを使うと、グラフ G 上の任意の二辺が swap 出来ます。具体的には、その二辺を両端とする path をと り、その path 上の隣接する辺を swap していくことを二回すると出来ます。 あとは、元のグラフの任意の異なる二辺に対して、その二辺を含む、グラフ G のような構造が取れること が示せれば、その二辺は swap できるため結局全ての置換が作れることがわかり、証明は完了します。よって これを示します。 まず二辺は同じ二重連結であり成分は辺一本ではないので、その二辺を含むサイクルがとれます (図の 2)。 また、成分はただのサイクルではないため、そのサイクルとは別に辺が含まれます。当然二重連結成分は連結 なので、そのような辺としてサイクルに接続しているものがとれます (図の 3)。この辺とサイクルが同じ二重 連結成分に属するためには、また別のサイクルであって、サイクルの辺とこの辺をともに含むサイクルの存在 が必要です。そのサイクルの辺を取ってくると、目的の構造が取れていることがわかります (図の 4)。 よって示されました。 二重 (頂点) 連結成分分解は、関節点を求めるのと同様なアルゴリズムで O(N+M) のものがありますが、今 回の制約だと、dfs してサイクル基底を得て、各サイクルの辺を unionfind でつなぐ O(MNlogM) なども許さ れます。 4 ABC 045 / ARC 061 解説 tozangezan 2016 年 9 月 11 日 1 A: 台形 台形の面積は、上底を a、下底を b、高さを h とすると、(a + b)h/2 で求められます。こ の問題は h が偶数なので、答えは整数に収まるため、int 型で計算できます。 2 B: 3 人でカードゲームイージー ルールの通りにシミュレーションします。実装の方針としては、3 人それぞれのカード の列を string 等で文字列にして持っておき、現在その文字列のうち何番目の文字がその人 の持ってるカードのうち先頭にあるかを変数に持ちます。また、現在誰のターンであるか を表す変数も持っておきます。 それぞれのターンにおいては、まずそのターンの人がカードを全部使い切ったかを確認 し、そうでないならば自分のカードの位置を表すカウントを 1 増やしてから、文字に対応 する人のターンに移動します。 計算量は O(|SA| + |SB| + |SC|) なので、特に問題なく動きます。 3 C: たくさんの数式 与えられる文字列の長さの最大が 10 と小さいので、それぞれの文字と文字の間に ‘+’ を入れるかどうかを全探索で試すことが出来ます。 何番目の数字の後に ‘+’ を入れるかを全て決めたら、split 等の関数がある言語ならば、 実際に新しく ‘+’ を入れた文字列を作り、区切って計算することができます。そうでなく ても、前から順に見ていって、「数字があるたびに現在の値を 10 倍して今書いてある数字 だけ足す」「‘+(’ が出てきたら現在の値が ‘+(’ の直前の整数に等しいので、それを答え に足す」「最後は ‘+(’ が登場せずに数式が終わるので、そこは別に足す」とすると、新し く出来た式の値を求めることができます。 1 4 D: すぬけ君の塗り絵 盤面が大きいので、実際に 2 次元配列で塗ることをシミュレーションすることはできま せん。また、 N が 105 と大きいので、座標圧縮したとしても、メモリ使用量が O(N2 ) となり厳しいです。 ここで気づくべきポイントは、「一つの黒く塗られたマスが影響を与える範囲は、その 周辺にあるいくつかの 3 × 3 領域しかない」ことです。すなわち、それぞれの塗られたマ スに対し、これらの周辺の少しのマスにのみ何かの処理をするだけで計算できれば、高速 に答えが求められることになります。 (i, j) を、上から i 行目で左から j 行目のマスを左上とする 3 × 3 の正方形を表すこと にします。例えば、上から p 行目で左から q 行目のマスを黒く塗ると、 (p − k, q − l)(k = 0, 1, 2)(l = 0, 1, 2) に含まれる黒いマスが 1 つ増えます。(ただし、これらの正方形が盤面 からはみ出すことがあるので、そういうケースは除外します) ということで、入力で与えられる点に対してこれらの正方形の左上のマスを全部列挙し ておき (最大で 9N 個列挙される)、その列挙されたものの中で、それぞれの正方形が何回 出現するかがカウントできればよいです。 これは、pair 型などで (i, j) をソートして前から順に同じ値が何回出てくるかを数えて も良いですし、map 等のデータ構造を使ってもよいです。 最後に、黒いマス 0 個の個数は、全体 ((H − 2)(W − 2) 個) から 1 回以上黒いマスが 出現した 3 × 3 領域の個数を引けば求められます。 計算量は、O(NlogN) となります。 5 E: すぬけ君の地下鉄旅行 (現在いる駅, 最後に使った会社) を頂点に最短路問題を解くことで答えが求められます。 この解法では、頂点数は高々 O(M) です。なぜならば、それぞれの駅に到達するのに最 後に使った会社の種類数は、最大でもその駅から出ている路線の個数です。この個数を全 ての駅で合計しても、路線の個数の定数倍にしかなりません。 しかし、効率的な辺の張り方をしないと、辺の数が O(M2 ) 等になってしまい、制限時 間内に実行が終わらなくなります。 例えば、次のような辺の張り方をすると辺の数は高々 O(N + M) で済みます。 • 同じ会社の路線に乗り換えるケースに関しては、そのまま長さ 0 の辺を全ての路線 の目的地に対して張る • 違う会社の路線に乗り換えるケースの代わりとして、(現在いる駅, −1) という頂点 に移動できるように長さ 0 の辺を張る。(改札から外に出るイメージ) • (現在いる駅, −1) の頂点から全ての会社の路線に対して、目的地に長さ 1 の辺を張 る (改札の中に入るイメージ、この時点で新たに料金がかかる)。 • スタートは、 (1, −1) の頂点。ゴールは、 (N, −1) の頂点。 あとは、Dijkstra 法等で十分早い時間で答えを求めることができます。 2 6 F: 3 人でカードゲーム 6.1 部分点解法 この問題では、3 人がそれぞれカードを N, M, K 枚ずつ持っている設定ですが、誰か がカードを使い果たしてゲームに勝利するまでの動作に関しては、「誰かがカードを出す」 操作の繰り返しだと考えることができます。そこで 3 つのカード列を考える代わりに、1 つの列にまとめて考えることができます。 この状況下で A さんが勝つ必要十分条件は、一列にしたカード列において、b が M 回 以下、c が K 回以下しか出ていないときに a が N 回出ることです。N 回目の a が出るの が、全体で何ターン目にあたるかを全て試します。 i ターン目で N 回目の a が出るとき、条件を満たす配置の個数は、「i ターンで使われな かった余りのカードの選び方 3 N+M+K−i 通り」「i −1 ターン目以前のうち a が出る N −1 回を選ぶ方法の数 i−1CN−1 通り」「a 以外が出る i − N ターンを b と c で埋める方法の数」 の積です。 最初の 2 つは簡単に計算することができます。最後の「a 以外が出る i − N ターンを b と c で埋める方法の数」は、i−N Ck (max(0, i − N − c) ≤ k ≤ min(i − N, b)) の総和で す。これらを全部一つずつ計算すると、ここだけで O((M + K) 2 ) となり、部分点は取れ ますが、満点は取れません。 6.2 満点解法 さっきの二項係数を足す連続する範囲を全ての i についてパスカルの三角形上に書いて みると、このような形になります。 * ** *** ***. ***.. .**... ..*.... ........ これらを、上の段から一段ずつまとめて計算していきます。最初、一番上の段を見てい て、この範囲における求めたい合計は 1 です。 ここから降りていくとき、左下、右下ともに新たに追加されるうちは、その段の合計は、 一つ上の段の合計の 2 倍となります。 左下、右下の片方しか追加されなくなったとき、その段の合計は、一つ上の段の求める 範囲の合計の 2 倍から、追加されないほうの端に影響を与える、一つ上の段で求める範囲 の中にあった点の値を引きます。 3 左下、右下のどちらも追加されなくなったとき、その段の合計は、一つ上の段の求める 範囲の合計の 2 倍から、追加されない両端に影響を与える、一つ上の段で求める範囲の中 にあった点の値を両方引きます。 このようにまとめて段ごとに計算することで、計算量は O(M + K) となり、満点を取 ることができます。 4 ABC 044/ARC 060 解説 1 A: 高橋君とホテルイージー N ≤ K の場合，一泊あたり X 円で N 泊宿泊することになるため，答えは NX となる．N>K の場 合，最初の K 泊については一泊あたり X 円，残りの N − K 泊については一泊あたり Y 円となるため，答 えは KX + (N − K)Y となる． この問題においては，整数の入出力，四則演算等の基本的な演算，条件分岐が必要となる． 2 B: 美しい文字列 各英小文字 (‘a’–‘z’) ごとに，以下を行えばよい． 1. w 中における出現回数を数える． 2. 出現回数が奇数か偶数かを判定する． 出現回数が奇数の文字が 1 種類でもあった場合は “No” を，それ以外の場合は “Yes” を出力する． この問題においては，ループ，文字列の入力および長さの取得などが必要となる．なお，言語によって は，入力した文字列の末尾に改行文字が含まれる可能性がある．特に，長さを取得する際に問題となりうる ため，場合によっては末尾の改行を除去した方が良いこともある．普段使用している言語で改行がどのよう な取り扱いとなっているか，確認しておくことが望ましい． また，多くの言語では，文字は整数として表現されているため，文字と整数は相互に変換できる (https://ja.wikipedia.org/wiki/ASCII 等を参照)．これを用いると実装が楽になるかもしれない． 1 3 C: 高橋君とカード 以下，X = max{x1,...,xN , A} とおく． 3.1 部分点解法 部分点制約では N が小さいので，すべてのカードの選び方 (2N − 1 通り) を試すことができる．全通 り試すにはビット演算を用いるのが楽である．具体的には ABC 014 B 問題 (http://abc014.contest. atcoder.jp/tasks/abc014_2) などを参照するとよい．計算量は全体で O(N · 2N ) となる． 3.2 満点解法 1 以下の 3 次元配列 dp[j][k][s] (ただし 0 ≤ j ≤ N, 0 ≤ k ≤ N, 0 ≤ s ≤ NX) を考える． dp[j][k][s]=(x1,...,xj から k 枚選んで xi の合計を s にするような選び方の総数) この配列は次のように計算することができる． dp[j][k][s] = ⎧ ⎪⎪⎪⎨ ⎪⎪⎪⎩ 1 (j = 0, k = 0, s = 0 のとき) dp[j − 1][k][s] (j ≥ 1,s<xj のとき) dp[j − 1][k][s] + dp[j − 1][k − 1][s − xj ] (j ≥ 1, k ≥ 1, s ≥ xj のとき) 0 (上記いずれでもないとき) さて，選んだカードの xi の平均を A にするには，各 k (1 ≤ k ≤ N) について，k 枚選んだときの合計が kA であればよい．すなわち %N k=1 dp[N][k][kA] が答えとなる． 動的計画法を用いるることで，計算量は全体で O(N3X) 時間となる． 3.3 満点解法 2 「選んだカードの xi の平均が A」であることは，「選んだカードの (xi − A) の合計が 0」と言い換えるこ とができる．すなわち，各カード i について yi = xi − A と定義すると，選んだカードの yi の合計が 0 と なるようなカードの選び方の総数を求めればよいことになり，選んだ枚数を考慮する必要がなくなる．この 考え方に基づく，O(N2X) 時間の解法も存在する． 実装においては，yi が負となりうることを考慮し，以下の 2 次元配列 dp[j][t] (ただし 0 ≤ j ≤ N, 0 ≤ t ≤ 2NX) を考えるとよい． dp[j][t]=(y1,...,yj から 0 枚以上選んで yi の合計を t − NX にするような選び方の総数) この配列は次のように計算することができる． dp[j][t] = ⎧ ⎪⎪⎪⎨ ⎪⎪⎪⎩ 1 (j = 0, t = NX のとき) dp[j − 1][t] (j ≥ 1，かつ，t − yj < 0 または t − yj > 2NX のとき) dp[j − 1][t] + dp[j − 1][t − yj ] (j ≥ 1, 0 ≤ t − yj ≤ 2NX のとき) 0 (上記いずれでもないとき) 1 枚も選ばないパターンを除外する必要があるため，答えは dp[N][NX] − 1 となる． 2 4 D: 桁和 明らかに，s = n の場合は n + 1 が答えである． それ以外の場合，はじめに 2 ≤ b ≤ √n および f(b, n) = s を満たす整数 b が存在するかどうか全探索す る．もしもそのような b が存在するならば，その最小値が答えである． そうでない場合には，√n<b ≤ n および f(b, n) = s を満たす整数 b が存在するかどうか検証する必要 がある．ここで，b > √n である場合には，n は b 進表記で 2 桁となることに着目する．すなわち，上位桁 を p，下位桁を q (1 ≤ q < b, 0 ≤ q<b) とすると， n = pb + q (1) と書くことができる．また，題意より p + q = s (2) が成立する．ところで b > √n であるから，式 1 より n = pb + q ≥ pb > p2 となり，p < √n が導かれる． そこで，上位桁 p を全探索すればよい．式 1,2 より b = (n − s)/p + 1 となるから，p から b は一意に定ま る．最後に，そのような b について，実際に f(b, n) = s を満たすか確認すればよい． 計算量は全体で O( √n) 時間となり，満点が得られる． 5 E: 高橋君とホテル 以下の 2 次元配列 r を考える． r[k][i]=(i 番目のホテルから 2k 日以内に到達可能な最右のホテル番号) r[0][i] は，xj ≤ xi + L を満たす最大の j であり，これは x1,...,xN に対し二分探索などを用いるこ とで，効率よく求めることができる．さらに，r[k + 1][i] = r[k][r[k][i]] となるから，ダブリングにより r[1][·], r[2][·],... を順次求めることができる．各クエリでは，この配列 r を用いて二分探索を行えばよい． 計算量は全体で O((N + Q) log N) となる． 3 6 F: 最良表現 x を文字列，p を正整数とする．0 ≤ i < |x| − p を満たす任意の整数 i に対し x[i] = x[i + p] を満たすな らば，p を x の周期と呼ぶ．また，x の周期の最小値を per(x) と表記する．例えば per(abcabcabcab)=3 である． 入力文字列 w について，その長さを N とする．以下のとおりの場合分けを行う． (a) w が良い文字列である場合 (例: w = ababa) (b) per(w)=1 の場合 (例: w = aaaaa) (c) それ以外の場合 (例: w = abcabcabc) (a) の場合，明らかに最良表現の項数は 1 であり，また最良表現の総数も 1 である．良い文字列かどうか の判定法については後述する． (b) の場合，最良表現の項数は N であり，また最良表現の総数も 1 である． (c) の場合，最良表現の項数が 2 となることが証明できる (後述の定理 5 を参照)．したがって，最良表現 の総数を求めるためには，次の条件をすべて満たす整数 i の総数を求めれば良いことになる． • 1 ≤ i<N • w[0..i − 1] は良い文字列である • w[i..N − 1] は良い文字列である すなわち，w の各接頭辞および各接尾辞について，良い文字列かどうか判定できれば良いことになる．以 下，w の各接頭辞が良い文字列かどうか判定する方法を述べる．接尾辞については，w の逆文字列に対し 同じ方法を適用すればよい． 以下の配列 Z[0..N − 1] を考える． Z[i]=(w と w[i..N − 1] の最長共通部分列の長さ) この配列は，Z algorithm [2] を用いることで O(N) 時間で求められることが知られている．また，次の観 察が得られる． 観察 1. p を，1 ≤ p<N を満たす整数とする．k ≥ 2 および (k − 1)p ≤ Z[p] を満たす任意の整数 k につ いて，w[0..kp − 1] は w[0..p − 1] を k 回繰り返した文字列である．すなわち，w[0..kp − 1] は良い文字列で はない． いま，G[1..N] を，次の条件を満たす bool 型配列とする． G[i] = true ⇐⇒ w[0..i − 1] は良い文字列 観察 1 を用いることで，次の処理により配列 G を求めることができる．すなわち，w の各接頭辞が良い文 字列であるかどうかを効率的に判定できる． 1 for (i = 1; i <= N; i++) { G[i] = true; } 2 for (p = 1; p < N; p++) { 3 for (k = 2; (k - 1) * p <= Z[p]; k++) { 4 G[k * p] = false; 5 } 6 } 上記の計算量は O(N log N) 時間となり，満点が得られる． 4 なお，証明は割愛するが，上記のコードを次のように変更すると，O(N) 時間解法となることが保証さ れる． 1 for (i = 1; i <= N; i++) { G[i] = true; } 2 for (p = 1; p < N; p++) { 3 if (G[p] == false) { continue; } // この行を追加 4 for (k = 2; (k - 1) * p <= Z[p]; k++) { 5 G[k * p] = false; 6 } 7 } さらに，Z algorithm を用いない，O(N) 時間の別解も存在する．ある文字列 x が良い文字列でないこと と，|x|/per(x) が 2 以上の整数であることは同値である (後述の補題 3 を参照)．すなわち，w の各接頭辞 が良い文字列かどうか判定するためには，w の各接頭辞の最小周期を求めれば良いことが分かる．これは Knuth-Morris-Pratt 法 [3] を用いることで，O(N) 時間で求められることが知られている． 6.1 正当性の証明 前述の解法は，(c) の場合において，最良表現の項数が 2 となることを基にしていた．ここではその証明 を述べる． 定理 2 ( [1,3] 等を参照). 正整数 p, q が文字列 x の周期であり，かつ p + q − gcd(p, q) ≤ |x| を満たすなら ば，gcd(p, q) もまた x の周期である． 補題 3. x を空でない文字列とする．以下の 2 つは同値である． (i) x は良い文字列ではない． (ii) |x|/per(x) は 2 以上の整数である． 証明. 良い文字列の定義より，(ii) ならば (i) であることは明らかである．以下，(i) ならば (ii) であること を示す． x が良い文字列でない場合，|x|/per(x) ≥ 2 は定義より明らかである．次に，|x|/per(x) が整数となるこ とを示す．x が良い文字列でないということは，y を k 回繰り返した文字列が x となるような，文字列 y および整数 k ≥ 2 が存在する．ここで p = per(x), q = |y| とおくと，p ≤ q = |x|/k ≤ |x|/2 が成立する． p および q はともに x の周期であり，かつ p + q − gcd(p, q) ≤ |x| を満たすから，定理 2 により gcd(p, q) は x の周期となる．ここで |x|/per(x) が整数でないと仮定すると，q は p の倍数でないことになる．その 場合，gcd(p, q) < p となってしまうので，p = per(x) が x の最小周期であることに矛盾する．よって， |x|/per(x) は整数である． 補題 4. x を長さ 2 以上の文字列とする．また m = |x| とする．さらに y = x[1..m − 1] とおく．x が良い 文字列でなく，かつ per(x) ̸= 1 であるならば，y は良い文字列である． 証明. y が良い文字列でないと仮定する．p = per(x), q = per(y) とおく．補題 3 と仮定より，p は m の約 数であり，q は |y| = m − 1 の約数ということになる．一般に m と m − 1 は互いに素なので，p と q も互 いに素，すなわち gcd(p, q)=1 となる．さらに p ≤ m/2 および q ≤ (m − 1)/2 である．ここで，p は y の周期でもある．したがって，定理 2 より，gcd(p, q)=1 は y の周期となる．よって，x の末尾 m − 1 文 字はすべて同じ文字となってしまい，さらに x[0] = x[p] より，x[0] もまた同じ文字となってしまう．結局 per(x)=1 となり，前提に矛盾する．したがって，y が良い文字列でないという仮定は誤りであることが わかる．ゆえに y は良い文字列である． 5 定理 5. 文字列 w について，w が良い文字列ではなく，かつ per(w) ̸= 1 を満たすと仮定する．このとき， w の最良表現の項数は 2 である． 証明. 長さ 1 の文字列は明らかに良い文字列である．さらに，補題 4 より，w[1..|w| − 1] は良い文字列であ るから，結局，列 (w[0], w[1..|w| − 1]) は w の良い表現の一つである．また，項数 1 以下の w の良い表現 が存在しないことは明らかである．よって，w の最良表現の項数は 2 である． 参考文献 [1] N. J. Fine and H. S. Wilf. Uniqueness theorems for periodic functions. Proc. Amer. Math. Soc., 16:109–114, 1965. [2] D. Gusfield. Algorithms on Strings, Trees, and Sequences. Cambridge University Press, 1997. [3] D. E. Knuth, J. H. Morris, and V. R. Pratt. Fast pattern matching in strings. SIAM Journal on Computing, 6(2):323–350, 1977. 6 ARC 060 / ABC 044 Editorial climpet August 28th, 2016 A: Tak and Hotels (ABC Edit) If N ≤ K, the answer is NX. Otherwise the answer is KX + (N − K)Y . B: Beautiful Strings For each lowercase letter c from ’a’ to ’z’, count the number of occurrences of c in s, and check if the number is even. C: Tak and Cards This problem can be solved by dp. Let dp[i][j][k] be the number of ways to choose j numbers among the first i numbers such that the sum becomes k. You can update this array from smaller i, and when i > 0, dp[i][j][k] = dp[i−1][j][k]+dp[i−1][j −1][k−xi]. (Make sure that you don’t access to negative indices). Then, the answer is the sum of dp[N][t][At] for 0 ≤ t ≤ N. Exercise: the algorithm above is O(N4). Can you improve it to O(N3)? D: Digit Sum Consider two cases: b ≤ sqrt(n) or b > sqrt(n). The former case is easy. Just try all possible values of b. In the latter case, when you write n as a base-b number, the number of digits will be at most two. If you write n as a base-b number, you get n = pb + q for some p, q < b. From the statement, you get p + q = s. By comparing these two equations, you get n − s = (pb + q) − (p + q), which is equivalent to (p − 1)b = n − s. 1 Thus, except for the special case n − s, b must be a divisor of n − s, and again you can try all possible divisors of n − s as candidates for b. The total complexity is O(sqrt(n)). E: Tak and Hotels Assume that ai < bi (the other case is similar). First, for each i, we compute right(i): the maximum integer that satisfies distance(i, right(i)) ≤ L. It means that if you start the hotel i, you can reach up to the hotel right(i) in a single day. This can be computed using binary search. In this task, you want to compute the minimum k such that rightk(ai) ≥ bi. For each i and t, you need to precompute the value of right2t (i). Then, you can compute the answers for queries using binary search. The total complexity is O((N + Q) log N). F: Best Representation The key observation in this task is that, unless all characters in w are the same, the minimum number of elements is always 1 or 2. Let n be the length of w. If neither of the first n − 1 characters of w and the last n − 1 characters of w are good, in other words, if both the prefix of length n − 1 and the suffix of length n − 1 are periodic, we can prove that all characters in w are identical. The key lemma for the proof is the following: • Let p, q are coprime integers, and let s be a string of legnth at least p + q − 1. If both p and q are periods of s, all characters in s are identical. The remaining part of the proof is an exercise for readers. Thus, if we can get all good prefixes and good suffixes of w, we can solve the task. In order to check if a given string s is good, for each divisor d of len(s), you need to check if s[0, len(s) − d) and s[d, len(s)) are the same. You can compare two strings in O(1) time after you pre-compute rolling hashes, so in total this problem can be solved in O(nlogn). Another way to compute all good prefixes/suffixes is to use Z-algorithm (again, an exercise for readers). 2 ABC043 / ARC059 解説 evima & sigma425 A - キャンディーと N 人の子供イージー / Children and Candies (ABC Edit) ループを回して 1+2+..+N を計算すればよい。また、これは N*(N+1)/2 に等しいの でこれを出力してもよい。 B - バイナリハックイージー / Unhappy Hacking (ABC Edit) 素直に、キーが押されるたびに文字列の変化をシミュレートすれば解くことができま す。 プログラミング言語に用意された文字列関連のライブラリを用いると簡潔に実装でき るでしょう。多くの主要なプログラミング言語では文字列を演算子 "+" で連結でき、 文字列の末尾に文字 '0' や '1' を挿入する処理はこれで済みます。文字列の末尾の 1 文字を削除する処理では、言語によって大きく違いが出るかもしれません。文字 列から文字を直接消すのが難しければ、文字列から最後の 1 文字を除いた部分文 字列をとって、それで元の文字列を上書きするという方法も考えられます。（この方 法は文字列が長いと時間がかかるおそれがありますが、今回は問題ありません） もしこのようなライブラリの使い方が分からなければ、文字の配列を文字列に見立て るなどして文字列の処理を「自前で」実装することもできます。その場合、現在の文 字列の長さを保持する変数を用意すると見通しがよくなります。 C - いっしょ / Be Together 全て同じ整数に変えるのだが、変える先の整数 X を全探索してそのうちコストが最 小のものを出力する。この時-100 から 100 までの整数しか考える必要はない。(-100 未満や 100 より大きくしても、各(ai -X)^2 は X=-100 や 100 の時と比べ大きくなるだけ なので、無駄。) 計算量は O(N*座標幅)。 D - アンバランス / Unbalanced 以下、文字列 s の長さを n とします。s には、長さ 2 以上の部分文字列が n(n-1)/2 個存在します。 部分点のデータセットでは n が最大で 100 と小さいため、s の部分文字列をすべて 列挙することができます。それぞれの部分文字列について、各アルファベットの出 現回数を数えることでアンバランスか判定すれば、時間計算量 O(n3 ) で問題を解く ことができます。 満点を得るためには、n が 105 に達するケースにも正解する必要があります。この n の値では、すべての部分文字列を列挙する時間はありません。どうすればよいで しょうか？ 実は、長さ 2 の "XX"（X は何らかの同じアルファベット）というパターンと、長さ 3 の "XYX"（Y は何らかのアルファベット）というパターンのいずれも s に存在しなければ、 アンバランスな部分文字列は存在しません。なぜなら、もしこれらのパターンが存在 しなければ、同じアルファベットの 2 つの文字の間に必ず他の文字が 2 つ以上挟 まっていることになり、一種類のアルファベットが部分文字列の文字の過半数を占め ることはないからです。よって、時間計算量 O(n) で問題を解くことができます。 E - キャンディーと N 人の子供 / Children and Candies まず f(x1 ,x2,...,xN)が具体的にどのような意味のある値になるかを考える。幼稚園の活 発度の式を考えると、N 人に C 個のキャンディーを分配する というのは、変数 xiた ちの多項式でどの変数にいくら次数を割り当てるか(総次数は C) というものだと思え る。すると f は、N 変数 C 次の単項式を集めたもの になる。 (例: N=3,C=3 として、見やすさのため x=x1,y=x2,z=x3と置くと、 f(x,y,z)=x3+y3+z3+x2 y+x2 z+y2 x+y2 z+z2 x+z2 y+xyz) まずは部分点を考える。x 1 ,x2,...,xN が(Ai=Biとして)与えられるので、f(x1 ,x2,...,xN)を求 めればよい。 N や C が大きいので全ての単項式を列挙することは出来ない。次のような DP を考 える。dp[i][j]= 「x1から xiまでの変数を使って次数が j になる単項式の値の和」 先程の例を使うと、 i \ j 0 1 2 3 0 1 0 0 0 1 1 x x 2 x 3 2 1 x+y x 2+xy+y2 x 3+x2 y+xy2+y3 3 1 x+y+z x 2+y2+z2+xy+x z+yz x 3+y3+z3+x2 y+x 2 z+y2 x+y2 z+z2 x +z2 y+xyz 実際は式ではなくこの値を保持する。 dp[N][C]が答えとなる。 dp の計算は、まず dp[0][0]=1 とし、遷移は dp[i+1][j]= sum {dp[i][j-k]* xi k } (k=0~j) となる。(つまり、変数 xiで次数をいくつ使うかで場合分け) すると計算量は O(NC2 )となり、N=C=400 なので間に合う。 満点解法も同様の DP による。 ΣΣ・・・Σf (上式を簡単のためこう書く) の値を考えるために、まず、xiの次数が ciであ る単項式 Πxi ciに対し Σ をとった値がどうなるかを考えると、ΣΣ・・・Σ (Πxi ci) = Π (Σxi ci) になる(Π は i=1～N)。(例: ΣΣ(x2 y) = (Σx2 ) * (Σy) ) つまり、各変数ごとにわけて足し あわせてから積をとったものと同じになる。これは実際に積をとった式を展開すると 元の単項式の Σ の各項が出てくることからわかる。 すると結局、部分点の DP の式で xiで k 次消費した時にかけるべき係数を、xi kから、 Ai k + (Ai+1)k + ・・・ + Bi k に変えれば満点の場合でも答えが求まる。 事前に、自然 数の 0~C 乗の、Ai.Biの上限(X とおく)である 400 までの累積和を計算しておけばこ の係数は O(1)で得られるので、この前計算が O(CX)で、DP が O(NC2 )で、結局 O(CX + NC2 )で答えが得られる。 F – バイナリハック / Unhappy Hacking 純粋な全探索を行うとしたら、探索中に保持する状態は「現在までにキーを押した 回数」と「現在エディタに表示されている文字列」の組になるでしょう。しかし、「現在 の文字列」を完全に保持する必要はなく、「文字列の長さ」と「そのうち何文字目まで s と一致するか」という 2 つの整数値の組を持てば十分です。この全探索アルゴリズ ムを動的計画法に変換することで時間計算量 O(N3 ) で問題が解け、部分点を得ら れます。 満点を得るには、状態の数をさらに減らす必要があります。s について考えると、s の 中のそれぞれの文字が '0' であるか '1' であるかは問題の答えに関係しないことがわ かります（N 回のキータイピングと最終的な文字列の関係を考えると、文字列の中の それぞれの文字はどれか 1 回のキータイピングと結びついているからです）。すな わち、s の長さを M とおくと、'0', '1' のみからなる長さ M の文字列は 2 M 通り存在し ますが、 N 回キーを押してそれらの文字列のうちどれを得る方法の数も等しいです。 したがって、N 回キーを押して「何らかの」長さ M の文字列を得る方法の数を求め れば、それを 2 M で割ったものが s を得る方法の数、すなわち元の問題の答えとな ります。部分点解法で保持する必要があった「現在の文字列の何文字目まで s と一 致するか」という値が不要になり、時間計算量 O(N2 ) で問題を解くことができます。 なお、「mod 1000000007 の世界で数を 2 で割る」(以下、P = 1000000007 とします) には、2a ≡ 1 (mod P) を満たす整数 a = 500000004（これを P を法とする 2 の逆元と 呼びます）を掛ければよいです。一般に整数 n の逆元を求めるには、例えば n P-2 を繰り返し二乗法で求める方法があります（フェルマーの小定理より、n×nP-2 = nP-1 ≡ 1 (mod P) となります）。 ABC042/ARC058解説 三上和馬 (kyuridenamida)/森田晃平 (yosupo) A問題 和風いろはちゃんイージー 文字列 A, B, C の中に、長さ 5 の文字列が 2 つ、長さ 7 の文字列が 1 つあるときに限 り、五七五を作ることができる。 B問題 文字列大好きいろはちゃんイージー 全ての文字列の長さが全て L であるという条件から、与えられる文字列を辞書順で昇 順に並び替え、その順で結合すれば辞書順最小を達成することができる。 一般に、文字列の長さが異なる場合でも、2 つの文字列 a, b に対し a が b より小さい ことを a + b < b + a と定義し、それらに基づいて文字列をソートしたものを昇順に結合 すれば辞書順最小を達成することができる。証明は省略します。 C問題 こだわり者いろはちゃん {1, 2, 3, 4, 5, 6, 7, 8, 9} ∈ { / D1, D2, ..., DN } であることが保証されているので、0 しか使 えないようなケースは無く、必ず解は存在する。 仮に使える数字の種類が 1 通りだったとしても、それらを N の桁数より 1 つ多い数だけ 並べた数を考えればそれが解の上限となるため、解の上限は 10N である。N,N+1,N+2,... について順に解の条件を満たすか確かめ、条件を満たすと分かった時点でその数を出力す るという解法で間に合う。 全体の時間計算量は O(N log N) である。 D問題 いろはちゃんとマス目 ※逆元の計算方法について誤記があったので修正しました。申し訳ありません。(7/24) 左上の座標が (0, 0)、右下の座標が (H − 1, W − 1) であるとする。 B ≦ i ≦ W を満たす全ての i について、 (0, 0),(H −A−1, i),(H −A, i),(H −1, W −1) を順に通る経路の個数を数え上げ、それらを足し合わせることで、過不足なく求める経路 が数えられる。図 1 はこのことを説明している。 上記の考え方に基づいて考えると、下に y 回、右に x 回移動するような経路の個数を 効率的に求める必要があるが、これは C(x + y, x) に等しい (C(n, r) は n 個のもの中か ら r 個選ぶ組み合わせの数を表す)。 C(n, r) = n! r!(n−r)! であるから、 0 ≦ x ≦ H + W − 2 に対して x!(mod 109 + 7) と (x!)−1 (mod 109 + 7) を予め O(H + W) かけて計算してテーブルにしておくことで、各 1 C(n, r) は O(1) で求めることができる。109 + 7 は素数なので、以下が言える。 • x ≡ 0(mod 109 + 7) でない全ての x に対し x −1 (mod 109 + 7) が存在する。 • フェルマーの小定理より x −1≡ x 109+5(mod 109 + 7) である。 したがって、階乗数の逆元 (x!)−1≡ (x!)109+5(mod 109 + 7) を二分累乗法等の適切な方法 で計算して予め求めておけば良い。二分累乗法のオーダーは O(1) ではあるが定数倍が 30 倍程あることに注意せよ。ちなみに、求めたい階乗数の最大値を M! として、最初にその 逆元 (M!)−1 を二分累乗法で求めた後、その数に M をかけると ((M − 1)!)−1 が求まり、 その数に M − 1 をかけると ((M − 2)!)−1 が求まり、...、というふうに計算していけばよ り高速に逆元テーブルを構築することができるが、今回その必要はない。 E問題 和風いろはちゃん どこにも XYZ を含まない数列の個数を数え上げれば良い。もちろん XYZ を含む数列 の数を数えても問題ないが、以下 XYZ を含まない数列の個数を数える方法を説明する。 左から 1 つずつ数列の値を決定していく全探索をメモ化することを考える。つまり、数 列の今見ているところの値を XYZ が生じないように定め、今見ているところを 1 個右に 移し、また値を決めて…というのを繰り返す。 これはどのようにメモ化出来るだろうか？ まず、XYZ=575 の時の、1, 1, ..., 1(1 が 17 個) の場合が、数列の値を最も使うパターン である。つまり、直前 16 個の値を保存すれば良い。 これで状態数は N ∗ 1016 になる。全探索に比べたらかなりの改善だが、もちろん間に 合わない。 2 もう少し考える。例えば直前に現れた値が 5,5,5,5,7 などであればこれを全部保存する 必要はない。つまり、直前に現れた値を合計が 16 以下でとなる範囲でだけ保存すれば良 いことがわかる。 これにより状態数は減るが、どのぐらい減るのだろうか？ ここで、1=”1”, 2=”10”, 3=”100”, 4=”1000”... と 0/1 文字列に変換して考えてみる。 つまり、直前に現れた値が 1,2,3 だとすると”110100”と変換する。この文字列の長さは値 の sum と等しい。つまり、前の値を合計が 16 以下まで保存するというのは、長さ 16 の 0/1 文字列に対応することがわかる。よって状態数は N ∗ 2 16 。もちろん実際には文字列 で保存するのではなく、16 bit の整数として保存し bit DP を行う。 これにより計算量は O(A ∗ N ∗ 2 X+Y +Z ) となる (A は数列の値の種類、つまり 10 )。こ れで間に合う。 F問題 文字列大好きいろはちゃん dp[i][j] := i 番目以内の文字列を使い、ちょうど長さを j 文字にするときの辞書順最小 の文字列 と定義する。ただし i + 1 文字目以降の文字列を使って埋めても K − j 文字にできな いときは定義されないこととする。K − j 文字にできるかどうかの判定をするための DP テーブルを構築するのは容易である。 文字列をそのまま持つと空間計算量は O(NK2 ) だが、最適な文字列のみをうまく保持 することを考えると、dp[i][0], dp[i][1], ..., dp[i][K] はそれぞれ「定義されない」or「ある共 通の文字列の prefix」のどちらかになる。つまり、各 i に対してある共通文字列 CSi (長 さは高々 K) と、dp[i][j] が定義されているかどうかの判定フラグを持つことで、空間計 算量が O(NK) に抑えられる。 各 i に対する共通文字列について、それ自体が辞書順最小となるような dp[i][j] と判定 フラグを保持することだけを考えれば良い。 dp テーブルの更新時に、dp テーブルの文字列や si、またはそれらを結合したもの同士 の文字列の辞書順比較を高速に行う必要が出てくるが、LCP (Longest Common Prefix) を求めればその処理が高速に行えることが分かる。扱う文字列を全てローリングハッシュ テーブルで管理し部分文字列のハッシュ値を O(1) で求められるようにしておき、それら 対して二分探索を行うことにより、 時間計算量 O(logk) で LCP を求めることができる。 全体の時間計算量は O(NKlogK)、空間計算量は O(NK) となる。128 以下の 2 べき の数を法としたローリングハッシュでは通らないようにテストケースを工夫した。した がって除算を行う必要があるが、除算は重くその定数倍のせいで、ローリングハッシュを 用いた解法を通すのは難しい。 そこで、比較部分のアルゴリズムをさらに改善することを考える。 どのような文字列の比較を行うか考える。すると • CSi のうち先頭何文字か • CSi のうち先頭何文字か + si 3 という文字列同士のみを比較することがわかる。ここで、si + CSi について Z−Algorithm を適用したテーブルを用意しておくと、これらの文字列同士の比較は O(1) で行うことが 出来る。 よって時間計算量は O(NK) となる。これが想定解である。 以下、上記の説明に基づいた dp テーブル更新の一例を示す。定義されている値のみ列 挙している。比較パートについては触れていない。 N = 5, K = 7 のケースで、各 si は以下の通りとなっている。 • s1=”aaaaaa” • s2=”abc” • s3=”xxxx” • s4=”ddd” • s5=”abcd” i = 0, 1, 2, 3, 4, 5 における DP テーブルの更新は次のようになっている。 1. i = 0: dp[0][0]=”” 2. i = 1: dp[1][0]=”” • s1 を使うと以降どう使っても長さ K = 7 の文字列を達成できないことから、 dp[1][6] は定義されない。 3. i=2: dp[2][0]=””, dp[2][3]=”abc” • 共通文字列 CS2 =”abc” 4. i = 3: dp[3][0]=””, dp[3][3]=”abc”, dp[3][7]=”abcxxxx” • 共通文字列 CS3 =”abcxxxx” • dp[1][4]=”xxxx”としても、辞書順最小の共通文字列にはなりえないので dp[1][4] は定義されない。 5. i = 4: dp[4][0]=””, dp[4][3]=”abc”, dp[4][7]=”abcxxxx” 6. i = 5: dp[5][0]=””, dp[5][3]=”abc”, dp[5][7]=”abcabcd” • 共通文字列 CS5 =”abcabcd” 4 ARC057 解説 DEGwer 2016 年 7 月 9 日 A問題 問題概要: 高橋君は最初 A 円を持っている。一日経つごとに所持金が K ∗ ( 現在の所持金) + 1 円だけ増える。所持金が最初に 2 兆円以上になるのは何日 後か。 解説: まず、K = 0 のとき、所持金は毎日 1 円ずつ増えるので、求める日数は 2 × 1012 − A 日です。 そうでない場合、日数を一日ずつすすめて問題文に書かれている通りにシ ミュレーションすることを考えます。このとき、1 日後の高橋君の所持金は 1 円以上であり、かつそれ以降高橋君の所持金は毎日 K + 1 倍以上、特に 2 倍以上になるので、求める日数は高々log2 1012 + 1 日となり、愚直にループ を回しても間に合います。(K = 0 の場合は、所持金が指数的に増えないので 愚直なループでは間に合わず、この場合のみ場合分けをしてやる必要があり ます。) B問題 問題概要: N 日間にわたって、i 日目には ai 回のゲームをする。合計の勝利 回数 K が与えられるので、前日までより勝率が上がった回数の最大値を求め よ。ただし、0 日目の勝率は 0 とする。 解説: まず、a1 + a2 + ... + aN = K のときは、すべての日のすべてのゲームに勝 つことになります。この場合、1 日目以降の勝率はすべて 1 であり、勝率が 上がった回数は 1 です。この場合は特別に処理することにして、以下そうで ない場合のみ考えます。 そうでない場合、勝利回数を K 回ちょうどでなく、K 回以下と言い換えて も答えが変わらないことを証明します。 L(< K < a1 + ... + aN ) 回の勝利回数で t 回、前日までより勝率が上がっ たとします。このとき、勝利回数の列を後ろから順に見て、勝利回数が K 回 に達するまで、その日のゲームの回数より勝利回数が真に少ない日の勝利回 数を増やす操作を考えます。 1 この操作で勝利回数が増えた (前から見て) 最初の日を x 日目とします。x+1 日目以降はすべてのゲームに勝っており、x − 1 日目までに (場合分けの条件 より) 少なくとも 1 敗はしていることから、x + 1 日目以降のすべての日で勝 率が上がっています。また、x 日目にはこの操作のせいで勝率が下がるよう になることはなく、x − 1 日目以前の勝率の上下は、この操作では変わりませ ん。よって、L 回の勝利で t 回勝率が上昇する状況が存在するなら、K 回の 勝利で t 回以上勝率が上昇する状況も存在することが示されました。 ここで、以下のような DP を考えます。DP[i][j] を i 日目までに j 回勝率 が上昇した場合の勝利数の最小値とします。この DP の遷移は、i 日目の勝利 回数として 0 から ai までの ai + 1 通りが考えられますが、勝利数を最小化し たいので、この中の 0 勝の場合と、勝率が上昇するぎりぎりの勝ち数の場合 だけ遷移をすればいいことが分かります。 この DP を計算していき、DP[N][i] が K 以下となる最大の i が求める答 えとなります。 これで時間計算量は O(N2 ) となり、正答を得ることができます。実装に よっては a1 = 1 の場合がコーナーケースとなるので、気を付けましょう。 C問題 問題概要: √ N の上 k 桁が a1a2...ak となるような最小の N を求めよ。 解説: 10 進法での整数 a1a2...ak を A と書くことにします。 √ N の上 k 桁が a1a2...ak ⇔ ある正とは限らない整数 t が存在し、A×10t ≤ √ N < (A + 1) × 10t ⇔ ある正とは限らない整数 t が存在し、A2 × 102t ≤ N < (A + 1)2 × 102t です。この条件を満たす N は、t が大きいほど桁数が大きくなるので、t を 小さいほうから順に試し、A2 × 102t ≤ N < (A + 1)2 × 102t を満たす N が 見つかったらそれを出力して終了するアルゴリズムで、正解を得ることがで きます。 実装では、多倍長整数 A と A + 1 の 2 乗をそれぞれ求め、適切に先頭に 0 を付け加えて偶数桁にしておき、さらに末尾に偶数個の 0 を付け加えたもの を用意し、N の桁数 d を 2 桁ずつ増やしていって、A の 10 進表記の先頭 d 個 の数字を並べてできる整数と、それに 1 を足したものを答えの候補とし、こ れらが条件を満たすかどうか調べます。はじめて見つかった条件を満たすも のが、求める N となります。 増やす桁数が 2 桁ずつであることに気を付けてください。例えば、√ 1 の 上のほうの位は 100... ですが、√ 10 の上のほうの位は 316... になります。 D問題 問題概要: N 頂点で、各辺の重みが 1, 2, ..., N(N − 1)/2 の並び替えである完 全無向グラフであって、最小全域木に使われる辺のコストが小さいほうから 2 順に A1, A2, ..., AN−1 であるようなものの個数を求めよ。頂点同士は互いに 区別する。 解説: 最小全域木は、クラスカル法で求めることができます。条件を満たすグラ フにクラスカル法を適用して最小全域木を求めることを考えると、コストが 小さいほうから順に辺を追加していったとき、連結成分同士がつながる N −1 回のタイミングが、順に A1, A2, ..., AN−1 であるということになります。 いま、条件を満たすグラフを、辺をコストが小さい順に追加していくこと でつくることを考えます。A1, A2, ..., AN−1 回目の操作では、異なる連結成分 の頂点同士をつなぎ、そうでない場合は同じ連結成分の頂点同士をつなぐよ うに辺をはると、このとき、そしてこのときのみ、できるグラフは条件を満 たします。 いま、連結成分同士をつなぐ操作を k 回やったとします。このとき、N −k+1 個の連結成分がありますが、この連結成分のサイズたちの集合が同じなら、 次以降に辺を張れる頂点対の個数は同じになることが分かります。よって、 連結成分のサイズの集合をキーにした DP を考えることができます。 この DP の計算量を評価します。連結成分サイズたちの集合は、N をいく つかの整数の和で書く方法の場合の数と同じです。これは分割数と呼ばれる 値で、N = 30 では 5604 となります。遷移は、異なる連結成分同士を結ぶと きのみ O(N3 logN) の計算量でできるように実装できます。(結ぶ連結成分の 組をすべてためします。) 以上で、O((N の分割数) × N3 log N) でこの問題を解くことができます。 3 AtCoder Regular Contest 056 解説 AtCoder株式会社 代表取締役 高橋 直大 2016/6/24 1 競技プログラミングを始める前に • 競技プログラミングをやったことがない人へ – まずはこっちのスライドを見よう！ – http://www.slideshare.net/chokudai/abc004 • 作題・準備:hogloid 2016/6/24 2 ©AtCoder Inc. All rights reserved. 3 A問題 みんなでワイワイみかん 1. 問題概要 2. アルゴリズム 2016/6/24 3 A問題 問題概要 • みかんを少なくともK個買いたい • みかんは1個A円、またはL個B円で買うことができる • 払うお金の最小値は？ • 制約 – 1 ≦ A, B, K ≦ 109 – 2 ≦ L ≦ 109 – B ≦A*L 2016/6/24 4 A問題 アルゴリズム • B ≦A*L の条件より、1個ずつA円でL個買うならセッ トで買ったほうがお得 • よって、1個ずつ買うのはL個未満 • このことから、考えられるパターンは – K/L(切り捨て)回L個のセットを買う+K mod L回1個ずつ買う – K/L+1回L個のセットを買い L - K mod L 個余らせる • のどちらか 2016/6/24 5 ©AtCoder Inc. All rights reserved. 6 B問題 駐車場 1. 問題概要 2. アルゴリズム 2016/6/24 6 B問題 問題概要 • N頂点M辺の無向グラフが与えられ、ある始点Sが 定まっている • 頂点1からNまで順番に、 – 始点から頂点iまで到達できるとき、頂点iを削除 – 到達できないとき、何もしない • 最終的に削除される頂点の番号を昇順に出力 • 制約 – 1 ≦ N, M ≦ 200000 2016/6/24 7 B問題 アルゴリズム • 部分点: – 毎回問題文通りの操作を実装すれば大丈夫 – 必要な道具は、 • 2頂点が辺でつながっているか判定 – UnionFind/dfsなどを用いましょう • 頂点を削除 – 有効かどうかの状態を頂点ごとに持っておきましょう • O(MN) 2016/6/24 8 B問題 アルゴリズム • 始点からある頂点まで到達できない場合、何もしな い、とあるが、始点から到達できない以上、削除して もそれ以後の答えに影響ない • すなわち、以下のような問題と考えることができる • 頂点1からNまで順番に、 – 始点から頂点iまで到達できるとき、答えにiを追加 – 頂点iを削除 • 頂点iまで到達できるか判定しているとき、番号i以上 の頂点のみ残っている • すなわち、i以上の頂点のみを通り始点から頂点iま で到達できる ことと、 iが答えに含まれることは等価 2016/6/24 9 B問題 アルゴリズム • Sからある頂点iまでのパスのうち、通る頂点番号最 小のものの最大値をcostiとおく – すなわち、costiより大きい番号の頂点のみ使ってiに到達 することはできないような数のうち最小のもの • これは、ダイクストラのようにcostiが大きい頂点から 決めていけばOK – costiはcostj ≦ costiなる頂点jを使ってさらに小さくなること はないため、大きい頂点から決めていくことができる • O(MlogN) 2016/6/24 10 ©AtCoder Inc. All rights reserved. 11 C問題 部門分け 1. 問題概要 2. アルゴリズム 2016/6/24 11 C問題 問題概要 • N*Nの重み付き無向グラフが与えられる • 頂点を彩色する • 使われた色の数*K-異なる色の間の辺の重みの総 和 をスコアとするとき、スコアの最大値はいくらか • 制約 – 1 ≦wi,j ≦ 100000 – 1 ≦ N ≦ 17 – 1 ≦K≦ 100000 2016/6/24 12 C問題 アルゴリズム • 部分点: – 色は1以上N以下としていいので、頂点の彩色を全て試し ていく – 愚直に試すとO(NN)となってしまうので、少し工夫 – 頂点を番号が増える順番で塗っていくことにする – 頂点iを今までに使われていない色で塗るとき、1種類だけ 試せば十分 • それ以後の塗り分けの色を交換することで、同じスコアを達成で きるから – これで、i番目の頂点での分岐が高々i個となり、塗り方は 高々O(N!)通り 2016/6/24 13 C問題 アルゴリズム • dp[S]:=頂点集合Sのみに対する問題の答え、という DPを考えてみよう • Sのうち、ある1つの色で塗られる集合Tを固定すると、 そのスコアは dp[S-T]+K-(S-TとTの間の辺の重みの総和) となる – S-TはSのうちTに含まれない頂点 – Tの頂点たちは他の色と異なる色で塗られることが決まっ たので、残りのS-Tのスコアは独立に決めることができる • この計算量はO(3N) – 全ての頂点集合(S)に対し、その全ての部分集合(T)を試 す、ということは、N個の頂点をT、S-T、残りに分ける方法 を試していることと等価 • 後者はN個の頂点を3つに分けているので、3 N 2016/6/24 14 C問題 アルゴリズム 2016/6/24 15 S-T T S-T T S-T T = - - • DPの遷移のうち、 (S-TとTの間の辺の重みの総和) を定数時 間で求めるのはどうすればいいか？ • Sの間の辺の重みの総和から、S-Tの間の重みの総和とTの 間の重みの総和を引けばOK – ある部分集合の中の重みの総和は予め計算しておく(O(2N)) ©AtCoder Inc. All rights reserved. 16 D問題 サケノミ 1. 問題概要 2. 考察 3. アルゴリズム 2016/6/24 16 D問題 問題概要 • N種類のドリンクとN種類のグラスがある • それぞれのドリンクiは、対応するグラスiにMi回決 まった時間に補充される • ドリンクには美味しさが決まっている • 行える行動は、好きな時刻に注がれているドリンク を全て飲むことのみ • 飲んだ美味しさの総和の最大値を求めよ • 制約 – 1 ≦ N ≦ 500,000 – 0 ≦ ∑Mi ≦ 500,000 2016/6/24 17 D問題 考察 • 部分点解法: – dp[i]:=時刻iで最後にドリンクを飲み干したときの美味しさ の最大値、というDPを考えてみよう – 次にドリンクを飲み干す時刻jを全て試し、次に飲み干す ときの美味しさの総和di,jを求め、 dp[j]:=max(dp[j],dp[i]+di,j)と更新していく • i以後でそれぞれのドリンクが最初に補充される時刻を最初に計 算し、jがその時刻を超えるごとにdi,jに加えていくと上手くいく – O(N*max(t)) D問題 考察 • 満点解法 – 上記のDPが高速にならないか考えてみる – 配るDPだったのを、もらうDPに書き直す – すなわち、iを昇順に、その中でjをj<iの範囲で昇順に走査 し、 dp[i]:=max(dp[i],dp[j]+dj,i) で更新していく – dp[j]+dj,iを1つの項として見てみる(dp2[j]と呼ぼう) – 時刻iで美味しさwkのドリンクkが注がれ、ドリンクkがその 前に注がれた時刻をlと置くと、l<j<iなるjに対し、 dp2[j]:=dp2[j]+wk となる • 最後に飲んだ時刻がjで、次に飲む時刻がi以後のとき、ドリンクk を新たに飲むことになるから – これは単純な区間add D問題 考察 • dp2を使うと、dp[i]=max{dp2[j]|j<i} – 単純な区間max • 実際は、iを昇順に見ていくので、初期値を負の大きな数にしてお けば、全体のmaxを取ってもOK • よって、区間add区間maxの機能をもつセグメント木 などを実装すればいいことが分かる • O((N+∑M)log(max(t)) ARC055 解説 sigma425 A: 数え上げ 10^N + 7 を出力する問題。N が 1 以上なので、1(0 を N-1 個並べる)7 を出力 すれば良い。 B: せんべい 最大のせんべいを食べる確率を最大化する問題。i 枚目を見るとき、そのせ んべいの 1~N の id がどれかを考えなくても、「今何枚食べたか」と、そのせんべい が「現時点での max かどうか」しか食べるかどうかの判断には関係がなく、その確率 は常に 1/i である。従って次のような dp が考えられる。dp[i][j][b] := 既に i 枚みて、j 枚食べていて、b=「現時点での max を食べているか」(bool 値) の時の最終的に条 件を満たせる確率の最大値 遷移は、状態(i,j,b)の時, 「確率(i-1)/i で(max を更新しないので)食べない」と「確率 1/i で max が出てくるので,この時食べる(dp[i+1][j+1][1]) or 食べない(dp[i+1][j][0]) のうち良い方を選ぶ 」のようにすればできる。O(NK) (オマケ) N,K<=100000 でも解けます。(ただし,許容誤差に依存する解法です) C: ABCAC 文字列 S を,非空文字列 A,B,C を使って S=ABCAC と表す方法は何通りか と いう問題。N=|S|とする。まず、A,B,C のうちどれか二つを全探索するなどの解法では、 ちゃんと分割できているかの check に O(N)かけると O(N^3)になって、部分点も通ら ない(check を素早くやると部分点は取れるかもしれない)。そこで、ABC/AC の切れ 目を全探索する。切れ目の左,右の文字列をそれぞれ x,y として、次を考える a := x と y の prefix が何文字まで一致するか c := x と y の suffix が何文字まで一致するか A,C は非空なので、a=0 か c=0 だと ABCAC とは書けない。A,C が合計で|y|文字で その分割を試すのだが、a と c がわかっていると、そのような分割のうち何個が正当 (つまり,x が A の prefix で y が A の suffix になっている)かがわかる。 実際、a,c>0 で a+c >= |y|とすると、a+c- |y| + 1 通りの分け方がある。 (a+c < |y| なら正当な分割はない) 例: x=”abdaaabc”, y=”ababc” とする a=2 (“ab”まで一致) c=3 (“abc”まで一致) この時各 y の分割は a/babc ダメ(a>=1 と c>=4 を要求している) ab/abc OK (a>=2 と c>=3 を要求している) aba/bc ダメ(a>=3 と c>=2 を要求している) abab/c ダメ(a>=4 と c>=1 を要求している) となる.()で書いている条件を考えると OK の個数は a+c-|y|+1 になることがわかる. a,c を愚直に求めることで、全体で O(N^2)なので部分点が得られる。 a は、S と S の suffix たちの先頭何文字が一致しているかがわかっていればすぐ求 められる。c も同様で S を reverse したものを S'とおくと,S'と S'の suffix たちの先頭何 文字が一致しているかがわかればすぐ求まる。 これにはいろいろな求め方があるが、 ・Suffix Array と lcp 配列と segtree を使う ・Suffix Array と ローリングハッシュで二分探索をする ・Z-algorithm というものを使う などがある。 これらを使うことで O(Nlog^2N)から O(N)で解くことが出来る。 D: 隠された等差数列 与えられた数字列を、あるどこかの桁としてもつような等差数列の内で初項の 最小を求める問題。 i)d_i たちが x 桁目に対応しているとする。 まず、{d_(i+1) – d_i}は i によらず高々二種類の値しか取れないことに注意する ( x-1 ∵ 桁目から繰り上がりが来るか、来ないかで二通り以外ありえない。しかも、その 二つの値は mod 10 で差が 1 である。) なので、この条件を満たしていなければ-1 を返せば良い。 また、一通りしか無い場合は A=d_i,B=0 が明らかにベストなので、d_i を返せば良い。 以下、上の条件を満たすとする。 この時、A,B は高々 x 桁として良い(x+1 桁以上は d_i に影響を及ぼさないので、無 駄に大きくする必要はない)ことに注意すると、 a_i = A + B*i (0<=i<N) に対し、L_i :=「a_i の x 桁目より左の部分(a_i を 10^x で 割った商)」が一意に求められる(d_(i+1)-d_(i) >0 の時は繰り上がっていなくて、<0 のときは繰り上がっている。=0 の時だけ判断が難しいが、x 桁目に足されている値 が二通りのうちのどちらかがわかるので、x 桁目で繰り上がってるかどうか分かる) (例: d={1,1,2}なら 1->1 で x 桁目での繰り上がりは起こっていない(15,18,21 みたいに) d={1,1,0}なら、1->1 で x 桁目での繰り上がりは起こっている(11,110,209 のように) ) 以上より、次のような問題になる。 A,B:x 桁の非負整数で次のような条件をみたすうち A の最小を求めよ L_i * 10^x <= A+B*i < (L_i + 1) * 10^x よく考えると、L_i を求める(あるいは求めるのに失敗する)のに x の値は関係がない。 さらに、この不等式全体を 10^x で割ると、同値な次の問題に変形できる。 A',B':高々小数点 x 桁(つまり,(整数)/10^x とかける)の非負実数で次の条件を満た す内 A'の最小を求めよ L_i <= A' + B' * I < L_i + 1 すると、次のように、「線分たちが与えられて、L_i = A' + B' * i という直線がその線分 たちの間を通る」という条件に言い換えられる 例えば,d={3,5,6,8,9,0,2} とすると, このように赤い直線が線分たちの間を通るのと条件をみたすのが同値。 この図は x によらずに書ける。x に関する条件は、「A'も B'も 整数/10^x」すなわち, 「L_0 も傾きも整数/10^x」という条件になる。 B'を整数/10^x で固定すると、A'を最小化するには各線分の黒い点のどれかにぶつ かるまで直線を下に動かせば良い。この時自動的に A'は整数/10^x となるので、A' に関する条件はないものとしてよい。なので、「B'としてありうる値の範囲」を求めて、 x を 1 から順番に調べていき、その範囲に B'が整数/10^x で表せるものがあれば、 そのうちで A'が最小になるものを答えとする(d_0 ≠0 より、10^x <=A <10^(x+1) とな るから,これで A の最小が求まっている)。A'が最小⇔B'が最大 が示せるので、あと は B'の範囲さえわかれば解ける。 B'の範囲を(有理数範囲で)求めるには、次のことをする。 まず上側の点の下向きの凸包を取り,同様に下側の点の上向きの凸包を取る(この 凸包に含まれない点は無駄な条件である) この前処理をしておくと、(以下凸包のサイズを K とする) 直線を下の凸包(緑線)にはわせながらしゃくとりのようなことをすると O(K) 上の凸包上の点と,下の凸包上の点を結んだ直線が valid か試す(これは結んだ点 の高々左右 2 つとの傾きを比べれば O(1)でできる) をすると O(K^2) K は座標幅が N の凸包のサイズなので高々 O(N ^ (2/3))であることが知られており、 全体で O(N^(4/3))もしくは O(N)で解くことが出来る (実際には前者も十分高速) ちなみに答えの最大サイズは N^2 ほどで、d= {9,0,0,.....0,1} などが答えが大きな値 になります。 ARC054 解説 DEGwer 2016 年 5 月 21 日 A問題 問題概要: 長さ L の円形の動く歩道があり、速度 X で回っている。高橋君が 速度 Y で歩けるとき、高橋君が位置 S から位置 D まで行くのにかかる最小 の時間を求めよ。 解説: 位置 S から位置 D まで動く歩道の進む方向に測った距離を K とします。 これは、S ≤ D のときは D − S に等しく、そうでないときは D + L − S に 等しいです。 X と Y の大小で場合分けをします。 X < Y のとき、高橋君は動く歩道を順方向と逆方向のどちらに歩いても、 前に進むことができます。順方向に進んだときにかかる時間は K X+Y 、逆方 向に進んだときにかかる時間は K Y −X です。これらのうち小さいほうが答え です。 そうでないとき、高橋君は順方向に進んだときのみ前に進むことができま す。このとき K X+Y の時間がかかり、これが答えです。 場合分けをしないと、 K Y −X の計算でゼロ除算が発生したり、負の値が出て きたりするので注意してください。 B問題 問題概要: コンピュータは 2 年に 1.5 倍のペースで高速になる。現在 P 年かか る計算を、適切なタイミングで始めて計算が終わるまでの時間を最小化せよ。 解説: x 年後に計算を始めるとき、計算が終わるまでの時間は f(x) = x+2−x/1.5P 年です。これは、凸関数と凸関数の和なので、凸関数です。よって、三分探 索によって最小値を求めることができます。 また、f ′ (x) の零点を求め、そのときの値を出力しても大丈夫です。その場 合、零点が 0 未満のときは f(0) = P を出力する必要があります。 C問題 1 問題概要: 頂点を同じ集合の間に辺がないように 2 つに分けたとき、両側と もに頂点数が N ≤ 200 となる二部グラフが与えられる。(以下この分割によっ てできた頂点集合を A, B と呼ぶ。) 完全マッチングの個数の偶奇を答えよ。 解説: 完全二部マッチングの個数の数え上げは、NP 困難な問題として知られて います。しかし、その偶奇だけなら高速に求めることができます。 完全マッチングにおいて、A の i 番目の要素とマッチングされている要素 を B の σ(i) 番目の要素とすると、σ(i) たちは 1 から N までの順列となりま す。つまり、求めたいのは、すべての順列 σ について、A の i 番目の要素が B の σ(i) 番目の要素にマッチングされているものの個数を合計したものの偶 奇です。 A の i 番目の頂点と B の j 番目の頂点の間の辺の数を (i, j) 成分とする行 列 M(入力で与えられる行列) を考えます。上記の値は、 ∑ σ∈SN M1σ(1) . . . MNσ(N) の偶奇に等しいです。ただし、SN は 1 から N までの順列すべての集合を 表します。 さて、M の行列式は、 ∑ σ∈SN sgn(σ)M1σ(1) . . . MNσ(N) とあらわされます。sgn(σ) は 1 または −1 の値をとりますが、これらは mod2 ではどちらも 1 です。すなわち、これは mod2 では先ほどの式と一致 します。行列式を求めるのは O(N3 ) でできるので、O(N3 ) でこの問題を解 くことができます。 D問題 問題概要: つぎの 3 種類の操作を繰り返してでできる数列のバブルソートの 交換回数を求めよ。 • k のみからなる単項数列を作る • 数列を k 回繰り返す • 2 つの数列をつなげる はじめの二つの操作の回数の和 (以下 N とおく) は 105 以下。 解説: 数列 X のバブルソートの交換回数は、i < j かつ X i > Xj なる組 (i, j) の 個数に等しいので、これを数えることにする。 現在存在する数列 S に対し、以下のデータを持っておきます。 2 • S のバブルソートの交換回数 XS • S にどの数が何回現れたかをすべて列挙したもの DS • S を 2 回繰り返したとき、バブルソートの交換回数が 2XS に比べ何回 多いかを表す YS これを持っておけば、単項数列を作る操作は O(1)、数列を繰り返す操作も O(1)、2 つの数列 S1 と S2 をつなげる操作は O(DS1の要素数 + DS2の要素数 ) ででき、全体で O(N2 ) となり、部分点が得られます。 各 S に対し、DS を適切なデータ構造で管理すれば、以下のようなアルゴ リズムで満点を得ることができます。 • 項 k のみからなる単項数列 S を作る操作において、空の T reeS を作り、 XS = 0, YS = 0 としたうえで、DS に値 k を 1 個追加する。 • 数列S をk 回繰り返す操作において、新しい(XS, YS)をそれぞれ(kXS+ k(k−1) 2 YS, k2YS) とおき、さらに DS に格納されている各要素の個数を すべて k 倍する。 • 数列 S と数列 T をつなげる操作 (この操作でできる数列を L とする) に おいて、DS と DT のサイズを比べ、 – |DS| < |DT | ならば、DS の要素をすべて見る。値 k が t 個あると き、T の値 k 未満の要素の数を数えてそれを t 倍したものたちす べての和と、XS と XT との和が XL となる。さらに、値 k が t 個 あるとき、T の値 k 未満の要素と k より大きい要素の数を数えて それを t 倍したものたちすべての和と、YS と YT との和が YL とな る。その後、DT に DS の要素をすべて加え、それを DL とする。 – |DS| ≥ |DT | ならば、DT の要素をすべて見る。値 k が t 個ある とき、S の値 k より大きい要素の数を数えてそれを t 倍したもの たちすべての和と、XS と XT との和が XL となる。さらに、値 k が t 個あるとき、S の値 k 未満の要素と k より大きい要素の数を 数えてそれを t 倍したものたちすべての和と、YS と YT との和が YL となる。その後、DS に DT の要素をすべて加え、それを DL とする。 • 最後にできた数列 S の XS の値が答えである。 このアルゴリズムの正当性は以下の通りです。XS が S のバブルソートの 交換回数、YS が S を 2 回繰り返した数列において、1 個目の S から 1 個、 2 個目の S から 1 個の要素をとってきたときにそれらの大小関係がひっくり 返っているものの個数を表すことに注意します。 3 単項数列を作る操作において、XS = YS = 0 は明らかです。数列 S を k 回 繰り返した数列 (ここにおけるひとつの S をブロックと呼ぶことにする) を S k とおくと、S k での S k i > Sk j なる i < j の個数は、 • i, j が同じブロックに属する場合、kXS 個 • そうでない場合、k(k−1) 2 YS 個 となるので、この操作も正当です。 数列 S, T をつなげる操作において、S と T をつなげた数列 L での Li > Lj なる i < j の個数は、 • i, j 番目の要素がともに S の要素であった場合 XS 個 • i, j 番目の要素がともに T の要素であった場合 XT 個 • どちらでもない場合、S の要素 Si について、Si > Tj なる j の個数す べての和、もしくは T の要素 Tj について、Si > Tj なる i の個数すべ ての和 (これらは同じ値を表す) であるので、上記のアルゴリズムは正当です。 さらに、数列をつなげる操作において、DS のサイズが小さいほうの数列 を大きいほうの数列にマージしているので、単項数列として作った各数列に おいて、その値が DS に新しく入れられる回数は高々O(log N) 回です。(次 の列に入れられるまでに、自分が属する数列 S の DS のサイズが 2 倍以上に なります。) よって、あとは「数列 S の k 以下の要素の個数を数える」「DS に値を追加 する、すなわちある箇所の値をある値だけ増やす」「DS のすべての要素の個 数を k 倍する」という操作ができればよいことになります。 最初の 2 つの操作は、各数列について segment tree を動的に構築すること で可能になります。最後の操作は、実際に segment tree 上の値を更新はせず、 各 segment tree についてかわりに「segment tree に書かれている値を何倍す ると本当の値になるか」を表す値 PS を持っておくことにします。すると、 • 数列 S の値 k 以下の要素の個数を求めるときは、segment tree 上での 位置 k より前のものの合計に PS をかけたものを求める • 位置 k の値を t だけ増やすときは、segment tree 上での位置 k に tP −1 S を加算する • DS のすべての要素を k 倍するときは、PS を k 倍する という操作を行うことで、全体で O(N log2 N) となり、満点を得ることが できます。 4 ARC 053 解説 A : ドミノ色塗り ✓解法 ✏ 答えは H(W − 1) + (H − 1)W 通り． ✒ ✑ まず，左右に隣り合う 2 マスを塗る方法が何通りか考えます．左右に隣り合う 2 マスを塗ると き，左のマスとしてあり得るものは，図 1 の ☆ のマスです．左右に隣り合う 2 マスを塗る方法は ☆ の個数に等しいので，H(W − 1) 通りです． 同様にして，上下に隣り合う 2 マスを塗る方法は (H − 1)W 通りです．よって，答えは H(W − 1) + (H − 1)W 通りとなります． 図 1 B : 回文分割 ✓解法 ✏ 文字列 S の長さを N とする．また，26 種類のアルファベットのうち，文字列 S に奇数回現 れるものが K 種類であるとする．すると，答えは次式．計算量は O(N)． { N (K = 0) 2⌊ N−K 2K ⌋ + 1 (1 ≤ K ≤ 26) ✒ ✑ 1 K = 0 の場合，すべてのアルファベットが偶数個ずつあります．そのため，同じアルファベッ ト同士のペアを N/2 組作り，それらを左右対称に並べることで，1 個の回文を作ることができま す．よって，答えは N です． K = 1 の場合，1 種類のアルファベットのみが奇数個です．このアルファベットを中央に置くこ とに決めると，残り N − 1 文字はすべてのアルファベットが偶数個ずつあります．そのため，同 じアルファベット同士のペアを (N − 1)/2 組作り，それらを左右対称に並べることで，1 個の回 文を作ることができます． K = 2 の場合，2 種類のアルファベットが奇数個です．この場合，少なくとも 2 個の回文に分 割する必要があります．ここでは 2 個の回文に分割することにして，奇数個である 2 種類のアル ファベットをそれぞれの中央に置くことに決めます．すると，残り N − 2 文字はすべてのアル ファベットが偶数個ずつあり，同じアルファベット同士のペアを (N − 2)/2 組作ることができま す．より短い方の回文の長さ X をできるだけ大きくしようとすると，ペアをできるだけ均等に割 り振るのがよいことがわかります．よって，より短い方の回文には ⌊(N − 1)/4⌋ 組のペアが割り 振られ，答えは X = 2⌊(N − 1)/4⌋ + 1 となります． 一般の 1 ≤ K ≤ 26 の場合も，K = 2 と同様に考えると，答えは 2⌊(N − K)/2K⌋ + 1 となる ことがわかります． C : 魔法使い高橋君 ✓解法 ✏ N 個の魔法を唱える順番を 貪欲法 で決める．ai < bi の魔法をグループ 1 とし，ai ≥ bi の 魔法をグループ 2 とする．まず，グループ 1 の魔法を ai の昇順にソートし，その順番に唱 える．続いて，グループ 2 の魔法を bi の降順にソートし，その順番に唱える．このときの X が答えである．計算量は O(N log N)． ✒ ✑ とりあえず，グループ 1 の要素だけしかない場合を考えてみます．このとき，ai の昇順にソート した順番が最適解であることを示します．ある順番において，ある隣接要素 i，i + 1 が ai ≥ ai+1 であったとします．すると，図 2 からわかるように，X の値を増加させずに i と i + 1 をスワッ プできます．よって，任意の順番は X の値を増加させずに ai の昇順にソートできることがわか ります．以上より，ai の昇順にソートした順番が最適解であることが示せました． 同様にして，グループ 2 の要素だけしかない場合も，bi の降順にソートした順番が最適解であ ることが示せます． では，グループ 1 の要素とグループ 2 の要素が混ざっている場合はどうでしょうか？ ある順番 において，ある隣接要素 i，i + 1 がそれぞれグループ 2，グループ 1 であったとします．すると， 図 3 からわかるように，X の値を増加させずに i と i + 1 をスワップできます．よって，任意の 2 順番は X の値を増加させずに，(グループ 1 の要素たち) → (グループ 2 の要素たち) という順番 に並べ替えられることがわかります．グループ 1 の要素とグループ 2 の要素が完全に分離されて いれば，X の値を増加させずに，グループ 1 を ai の昇順にソートし，グループ 2 を bi の降順に ソートできます．以上より，(グループ 1 を ai の昇順にソートしたもの) → (グループ 2 を bi の 降順にソートしたもの) という順番が最適解であることが示せました． 図 2 図 3 D : 2 つの山札 まずは，問題を視覚的に捉えましょう．例えば，サンプル 3 を視覚的に表すと，「図 4 のグリッ ドグラフにおいて，左上の点から右下の点まで移動するとき，パス上の数列は何通りか？」という 問題になります． グリッドグラフのパスの数え上げは，動的計画法 (DP) の典型問題として有名です．この DP では，dp[i][j] := (点 (i, j) までのパスの個数) と定義して，dp[i][j] = dp[i − 1][j] + dp[i][j − 1] と いう漸化式を計算します．もちろん，この DP ではパス上の数列を正しく数え上げられません．例 えば図 4 では，数列 (3, 3, 3, 3, 5, 5, 5, 5) を 2 重に数えてしまいます．これは，ある数列に対応す る終点が複数個あり得ることが原因です．例えば図 5 では，数列 (3, 3, 3, 3, 5, 5) に対応する終点 が 2 個あります ((2, 4)，(4, 2))． パス上の数列を正しく数え上げるためには，次のような工夫が必要です．ある数列に対応する終 点が複数個あり得ることに対応するため，dp[S] := (あり得る終点の集合が S であるような数列の 3 個数) と定義します．例えば図 5 では，あり得る終点の集合が {(2, 4),(4, 2)} であるような数列は (3, 3, 3, 3, 5, 5)，(3, 3, 4, 4, 4, 4) の 2 通りなので，dp[{(2, 4),(4, 2)}] = 2 となります．このように 定義した dp[S] をすべて計算した後，dp[{ 右下の点 }] を参照すると正しい答えが求まります． しかし，S をそのまま状態として持つと DP の状態数が大きくなりすぎるので，より効率的な 状態の持ち方を考えなければなりません．実は，「数列の長さ」と「数列の末項」がペアで指定さ れると，対応する S は高々 4 通りしかないことがわかります．よって，dp[l][p][S] := (長さが l か つ末項が p の数列であって，あり得る終点の集合が S であるものの個数) と定義すると，DP の状 態数が O(N2 ) に抑えられます．さらに，各状態からの遷移も高々 4 通りしかないことがわかりま す．以上より，全体の計算量が O(N2 ) に抑えられ，DP で問題を解くことができます． 図 4 図 5 4 ARC052 A – 何期生？ @namonakiaccount 問題概要 ● 3文字以上10文字以下の文字列が与えられる ● 1桁か2桁の数字が含まれているのでそれを出力 せよ 解法 ● 文字列の先頭から一文字ずつ見ていき、一番最初 に数字が出てくるところに着目する ● この次の文字も数字なとき、答えは2桁 このとき、この2文字をこの順で出力すればよい ● 違うとき、答えは1桁 このとき、この1文字を出力すればよい 解法 ● また、文字数≦10、桁数≦2より、数字の含まれる 位置の組み合わせは高々19通りしかない ● これらを総当たりして求めてもよい ARC052解説 B:円錐 B-問題概要 ● 3次元空間上に様々な大きさの円錐が底面をyz 平面に平行にして同じ向きに浮かんでいる ● 円錐は互いに重なり合わない ● A≦ x ≦ Bの範囲に含まれる部分の体積を求めよ B-考察 ● 簡単のために円錐ではなくて二等辺三角形で考 えてみる B-考察 ● ある区間[A,B]のなにかしらの総和を求める時に 使えるアイデア A B B-考察 ● ある区間[A,B]のなにかしらの総和を求める時に 使えるアイデア – ある基準点Oをつくって [O,B] – [O,A]をもとめる A B O B-考察 ● ある区間[A,B]のなにかしらの総和を求める時に 使えるアイデア – ある基準点Oをつくって [O,B] – [O,A]をもとめる – 今回なら[0,X]の範囲の 面積(体積)を求めて置く と便利 A B O B-解法 ● 各X(0 ≦ X ≦ 10^5)について[X,X+1]に含まれる 部分の体積をv[X]とする – これは円錐の情報が与えられるたびに、各v[X]の増 加量を計算して加算していけば求まる – O(NH) ● 最後にvの累積和を取れば[0,X]に含まれる部分 の体積を表すsum[X]を計算することが出来る ● クエリに対してはsum[B]-sum[A]を出力すれば 良い。 ● 満点獲得 B-別解 ● クエリが来るたびに各円錐のうちその区間に含 まれる部分の体積を求めて足し合わせれば良い ● O(NQ) ● こちらのほうがシンプルにコードを組めるだろ う。 ARC052 C – 高橋くんと不思議な道 @namonakiaccount 問題概要 ● N個の町があり、M本の双方向に移動可能な道で 結ばれている。 ● 道にはコストが1かかるタイプAと、(今まで通ったタ イプBの道の本数+1)かかるタイプBがある。 ● 町0からすべての町へのコストをそれぞれ求めよ ● 1 N 10000 ≦ ≦ ● 1 M 100000 ≦ ≦ 考察 ● タイプBの道を何本通ったかに着目してみる ● (今いる町,今まで使ったタイプBの道)を頂点にした グラフでのダイクストラ法を考えてみる ● 頂点数O(N^2) → 通らない 考察 ● 町0から町vまで、タイプBの道をa本使って行ける ルート、b本使っていけるルートがあるとする (ただしa<b) ● 町どうしの移動に通る道の本数は高々N-1本なの で、 b(b+1)/2-a(a+1)/2>N-1なら、b本使っていける ルートは無視してもよい 簡単な証明 ● タイプBの道をa本使うルートも、b本使うルートも、 タイプAの道は高々N-1本しか使わない ● よって(タイプBの道をb本使うことによるコスト)-(タ イプAの道をa本使うことによるコスト)>N-1なら、タ イプBの道をb本使うルートが最短路となることはな い。 簡単な証明 ● 他の頂点への伝播についても考えてみる ● 町vから町uまで、タイプBの道をk本使って行けると すると、 b(b+1)/2-a(a+1)/2>N-1のとき (b+k)(b+k+1)/2-(a+k)(a+k+1)/2>N-1 が必ず成り立つ。 ● タイプAについては先ほどと同様に考えるとよい 解法 ● 先に、各頂点への、タイプBの道の最小使用本数 を求めておく ● 先ほどの理由から、考慮に入れる必要があるタイ プBの道の使用本数は各頂点ごとに高々O(√N)通 り(最大で√(2N)通り程度) ● よって、頂点数O(N√N) ● ダイクストラ法などで解くことができる ARC052解説 D:9 D-問題概要 ● 1 ≦ N ≦ M なる整数Nのうち以下の性質を満た すものの個数を求めよ ● NをKで割った余り = Nの各桁の和をKで割った 余り – ただし右辺は10進法表記での和を取るとする D-部分点1(M ≦ 10^5) ● 1 ≦ N ≦ M なる全てのNを試しても間に合う ● あらかじめ整数xの各桁の和sum[x]を計算して おき N%K == sum[N]%K となる物を数え上げ れば良い ● O(M*log(M)) ● 10点獲得 D-考察 ● N%K == sum[N]%K を変形してみる ● (N-sum[N]) % K == 0 ● ここでf(N) = N-sum[N]%Kとする ● f(N) == 0となるNを数えれば良くなった D-考察 ● f(N)の性質を考える ● むやみやたらにAとBを選んでも f(A) + f(B) = f(A+B)とはならない ● sum[A] + sum[B] = sum[A+B]がなりたつなら ばf(A) + f(B) = f(A+B)となる ● sum[A] + sum[B] = sum[A+B]となるのはどの ような時か – 例：Aの下5桁が0　かつ　Bが5桁のとき D-考察 ● f(N)をもとめるとき – N = A*10^5 + Bとする – つまりAはNの上5桁、Bは下5桁 – sum[A*10^5] + sum[B] = sum[N]なので f(N) = f(A*10^5) + f(B)とすることができる – AもBも10^5通りしか無いので予め全通り求めてお くことが出来る D-満点解法 ● 0≦ A,B ≦ 10^5に対してf(A*10^5)とf(B)をあら かじめ求めておき保存しておく ● A*10^5 ≦ MとなるAに対して(f(A*10^5) + f(B)) % K == 0となるBを数え上げる – setやmapを利用すればlog(10^5)で処理できる ● 上記のステップで処理していない整数Nは10^5 個以下しか無いので部分点1と同様に愚直に計 算する ● あわせてO(√M log √M) ● 満点獲得 AtCoder Regular Contest 049 解説 AtCoder株式会社 3/19/15 A: ”強調” 森田　晃平 問題概要 • 文字列と、4つの挿入箇所が与えられる • 4つの箇所に”を挿入して出力する 解法1 • 文字列に対して以下の動作を行えば良い • A文字目の後ろに”を挿入 • B+1文字目の後ろに”を挿入 • C+2文字目の後ろに”を挿入 • D+3文字目の後ろに”を挿入 • 文字列の途中に文字を入れる機能は、大体の言語にあるはずです • 例えばc++なら、stringにはinsertという関数があります 解法2 • 逆から入れていくともう少し簡単になります • D文字目の後ろに”を挿入 • C文字目の後ろに”を挿入 • B文字目の後ろに”を挿入 • A文字目の後ろに”を挿入 B - 高橋ノルム君 三上和馬(@kyuridenamida) 問題概要 • 二次元平面上の点がN個与えられます。各点には係 数ciが定まっています • 適切に点(X,Y)を選んで ci*max(|xi-X|,|yi-Y|)の最大値を最小化 • 1<=N<=1000 誤差はあまり気にしないでよさそうな制約 部分点 • すべてのiに対してci=1という制約の下では (X,Y)=(xの最大値と最小値の平均,yの最大値と最小値の平均) とすれば最適になる • 30点得られます 考察 • 最大値を最小化 ↑二分探索を考えるのが定石 • コスト(=求める最大値,tとする)を固定してみよう! 考察 • コストtを固定すると以下のような判定問題ができる 「点(xi,yi)を中心とした長さ2t/ciの正方形がたくさ んあります．全ての正方形の共通部分はあります か?」 • これはx,y軸独立に区間集合の共通部分を求め，どちらにも共通 部分が存在していれば長方形としての共通部分があると言える 区間集合の共通部分 • 区間[L1,R1],[L2,R2],...,[LN,RN]があったときに • その共通部分は，存在するならば [max(L1,L2,…,LN),min(R1,R2,…,RN)] で表される． • 左の値<=右の値なら共通部分が存在する • 左の値>右の値なら共通部分は存在しない 解法 • 考察で作った判定関数に単調性があり，共通部分が存 在するギリギリのコストtを二分探索で見つければそれ が答え • 判定関数の時間計算量はO(N) • 二分探索は64回くらい反復しとけば安心 C - ぬりまーす 三上和馬(@kyuridenamida) 問題概要 • N頂点のグラフに色を塗る。ただし以下のタイプの 制約がそれぞれA個,B個ずつある。塗れる頂点の最 大数を求めよ。 タイプ1.ある頂点 x に色を塗るとき、既に頂点 y に色が塗られてなければならない。 タイプ2.ある頂点 u に色を塗るとき、既に頂点 v に色が塗られていてはいけない。 • 1㱡N,A㱡100,1㱡B㱡10 考察 • タイプ1の制約のみしかない場合を考え、制約を辺(y→x)として グラフにしてみよう。実はこれが解ければほぼ解けている。 • 有向閉路がない場合なら、適切な順番で塗れば全て塗ることが できる。ある場合はそこから伸びている辺は塗れない。 赤色の部分は塗れた頂点 考察 • タイプ1の制約のみしかない場合でも、どうやって塗るか考え なければならない • 今回は次のうちどちらの方法でも通るので好きな方で良い • 頂点の色変化がなくなる(=収束する)までループを回し続ける 方法 時間計算量はO(N(N+辺の数)) • キューを使って、入次数=(入ってくる頂点で色を塗られている 頂点数)になった瞬間のみ頂点をpushするような幅優先探索 時間計算量はO(N+辺の数) 元の制約に対する解法 • タイプ2の制約「ある頂点 u に色を塗るとき、既に頂点 v に色が 塗られていてはいけない。」を考える • タイプ2の制約は各々以下のように言い換えることができる 「頂点uを決して塗らないか、頂点vを塗るためには頂点uを塗ら ないといけない」 • つまり、各タイプ2の制約について、2通りの可能性を網羅すれば 十分。後者はタイプ1の制約とみなすことができる • 全ての可能性を全列挙しても2^B通りで、Bは小さいので間に合う • 全体の時間計算量はO(2^B * (先ほど述べた塗るための計算量)) 言い換え例 • 青辺はタイプ2の制約の辺(v→u) ❌ D: すわっぷしまーす 森田　晃平 問題概要 • 完全二分木が与えられる、葉には1,2,...と数が書かれ ている • ので、以下のクエリを処理 • 左からk番目の葉の値を求める • swap(a), swap(a+1), …, swap(b)を行う • ただし、swap(x)とは位置xの頂点の左右の子をswap 位置 1 2 3 4 5 6 7 swapクエリ • クエリ2は、範囲swapのようなものだが、そのま まではどうしようも無いので、木の高さごとにバラ す • これで、木の特定の高さの範囲swapを考えればよ くなった 例 1 2 3 4 5 6 7 これにswap(1), swap(2), …, swap(5)を行うとする 例 1 2 3 4 5 6 7 これにswap(1), swap(2), …, swap(5)を行うとする 1 2 3 4 5 6 7 • これを、 • swap(1)(高さ1) • swap(2), swap(3)(高さ2) • swap(4), swap(5)(高さ3) • の3種類に分割する swapクエリ • これで分割したクエリを、さらに分割する • SegmentTreeに対する区間クエリ • 木について、”高さiの頂点を全てswapする”という クエリになるように分割したい • たとえば、RMQ(Range minimum Query)を SegTreeでやるとどうなるか？ • [a, b]の最小値というクエリを、O(logn)個の”木の 全ての葉の値の最小値”というものに分割している • 今回は、i段目の[a,b]のswapというクエリなので、 O(logn)個の”木のi段目の全ての頂点をswap”とい うクエリに分割できる 例 1 2 3 4 5 6 7 これにswap(4), swap(5), swap(6)を行うとする 例 1 2 3 4 5 6 7 これは、位置2, 位置6の頂点に対して、 ”高さ3の頂点を全てswap” というクエリになる i段目を全てswap • “i段目を全てswap”というクエリになると何が嬉し い？ • とりあえず、位置1(木の根)に対して”i段目を全て swap”というクエリだけがくると考える • こうすると、”i段目を全てswap”→”j段目を全て swap”をしても、”j段目を全てswap”→”i段目を全て swap”しても、できる木は変わらないことがわかる 例 1 2 3 4 5 6 7 高さ2をswap → 高さ3をswap 8 例 3 4 1 2 7 8 5 高さ2をswap → 高さ3をswap 6 例 4 3 2 1 8 7 6 高さ2をswap → 高さ3をswap 5 例 1 2 3 4 5 6 7 高さ3をswap → 高さ2をswap 8 例 2 1 4 3 6 5 8 高さ3をswap → 高さ2をswap 7 例 4 3 2 1 8 7 6 高さ3をswap → 高さ2をswap 5 i段目を全てswap • 結局、それぞれの高さごとに”反転しているか”とい うフラグを持てば良い • “高さiを反転”というクエリが来たら、それに対応す るフラグを反転させる i段目を全てswap • 位置1(木の根)以外にもクエリが来るなら? • 先述のflagを各頂点にもたせて、伝搬させていく • 高さiのノードにアクセスするときは、i番目のフラ グが立っていたら左右の子をswapして、i+1番目以 降のフラグを全て子のフラグに伝搬させる i段目を全てswap • これをsegtreeを潜る時に行うと、アクセスする ノードの上の頂点は常に何もフラグが立っていない ようにできるので、うまく動く • 計算量はクエリを分割する個数がO(logn)なので、 クエリあたりO(logn) AtCoder Regular Contest 049 解説 AtCoder株式会社 3/19/15 A: ”強調” 森田　晃平 問題概要 • 文字列と、4つの挿入箇所が与えられる • 4つの箇所に”を挿入して出力する 解法1 • 文字列に対して以下の動作を行えば良い • A文字目の後ろに”を挿入 • B+1文字目の後ろに”を挿入 • C+2文字目の後ろに”を挿入 • D+3文字目の後ろに”を挿入 • 文字列の途中に文字を入れる機能は、大体の言語にあるはずです • 例えばc++なら、stringにはinsertという関数があります 解法2 • 逆から入れていくともう少し簡単になります • D文字目の後ろに”を挿入 • C文字目の後ろに”を挿入 • B文字目の後ろに”を挿入 • A文字目の後ろに”を挿入 B - 高橋ノルム君 三上和馬(@kyuridenamida) 問題概要 • 二次元平面上の点がN個与えられます。各点には係 数ciが定まっています。 • 適切に点(X,Y)を選んで ci*max(|xi-X|,|yi-Y|)の最大値を最小化 • 1<=N<=1000 誤差はあまり気にしないでよさそうな制約 部分点 • すべてのiに対してci=1という制約の下では (X,Y)=(xの最大値と最小値の平均,yの最大値と最小値の平均) とすれば最適になる． • 30点得られます． 考察 • 最大値を最小化 ↑二分探索を考えるのが定石 • コストtの最大値を固定してみよう! 考察 • コストtを固定すると以下のような判定問題ができる 「点(xi,yi)を中心とした長さ2t/ciの正方形がたくさ んあります．全ての正方形の共通部分はあります か?」 • これはx,y軸独立に区間集合の共通部分を求め，どちらにも共通 部分が存在していれば長方形としての共通部分があると言える． 区間集合の共通部分 • 区間[L1,R1],[L2,R2],...,[LN,RN]があったときに • その共通部分は，存在するならば [max(L1,L2,…,LN),min(R1,R2,…,RN)] で表される． • 左の値<=右の値なら共通部分が存在する • 右の値>左の値なら共通部分は存在しない． 解法 • 考察で作った判定関数に単調性があり，共通部分が存 在するギリギリのコストtを二分探索で見つければそれ が答え • 判定関数の時間計算量はO(N) • 二分探索は64回くらい反復しとけば安心． C - ぬりまーす 三上和馬(@kyuridenamida) 問題概要 • N頂点のグラフに色を塗る。ただし以下のタイプの 制約がそれぞれA個,B個ずつある。塗れる頂点の最 大数を求めよ。 タイプ1.ある頂点 x に色を塗るとき、既に頂点 y に色が塗られてなければならない。 タイプ2.ある頂点 u に色を塗るとき、既に頂点 v に色が塗られていてはいけない。 • 1㱡N,A㱡100,1㱡B㱡10 考察 • タイプ1の制約のみしかない場合を考え、制約を辺(y→x)として グラフにしてみよう。実はこれが解ければほぼ解けている。 • 有向閉路がない場合なら、適切な順番で塗れば全て塗ることが できる。ある場合はそこから伸びている辺は塗れない。 赤色の部分は塗れた頂点 考察 • タイプ1の制約のみしかない場合でも、どうやって塗るか考え なければならない • 今回は次のうちどちらの方法でも通るので好きな方で良い • 頂点の色変化がなくなる(=収束する)までループを回し続ける 方法 時間計算量はO(N(N+辺の数)) • キューを使って、入次数=(入ってくる頂点で色を塗られている 頂点数)になった瞬間のみ頂点をpushするような幅優先探索 時間計算量はO(N+辺の数) 元の制約に対する解法 • タイプ2の制約「ある頂点 u に色を塗るとき、既に頂点 v に色が 塗られていてはいけない。」を考える • タイプ2の制約は各々以下のように言い換えることができる 「頂点uを決して塗らないか、頂点vを塗るためには頂点uを塗ら ないといけない」 • つまり、各タイプ2の制約について、2通りの可能性を網羅すれば 十分。後者はタイプ1の制約とみなすことができる • 全ての可能性を全列挙しても2^B通りで、Bは小さいので間に合う • 全体の時間計算量はO(2^B * (先ほど述べた塗るための計算量)) 言い換え例 • 青辺はタイプ2の制約の辺(v→u) ❌ D: すわっぷしまーす 森田　晃平 問題概要 • 完全二分木が与えられる、葉には1,2,...と数が書かれ ている • ので、以下のクエリを処理 • 左からk番目の葉の値を求める • swap(a), swap(a+1), …, swap(b)を行う • ただし、swap(x)とは位置xの頂点の左右の子をswap 位置 1 2 3 4 5 6 7 swapクエリ • クエリ2は、範囲swapのようなものだが、そのま まではどうしようも無いので、木の高さごとにバラ す • これで、木の特定の高さの範囲swapを考えればよ くなった 例 1 2 3 4 5 6 7 これにswap(1), swap(2), …, swap(5)を行うとする 例 1 2 3 4 5 6 7 これにswap(1), swap(2), …, swap(5)を行うとする 1 2 3 4 5 6 7 • これを、 • swap(1)(高さ1) • swap(2), swap(3)(高さ2) • swap(4), swap(5)(高さ3) • の3種類に分割する swapクエリ • これで分割したクエリを、さらに分割する • SegmentTreeに対する区間クエリ • 木について、”高さiの頂点を全てswapする”という クエリになるように分割したい • たとえば、RMQ(Range minimum Query)を SegTreeでやるとどうなるか？ • [a, b]の最小値というクエリを、O(logn)個の”木の 全ての葉の値の最小値”というものに分割している • 今回は、i段目の[a,b]のswapというクエリなので、 O(logn)個の”木のi段目の全ての頂点をswap”とい うクエリに分割できる 例 1 2 3 4 5 6 7 これにswap(4), swap(5), swap(6)を行うとする 例 1 2 3 4 5 6 7 これは、位置2, 位置6の頂点に対して、 ”高さ3の頂点を全てswap” というクエリになる i段目を全てswap • “i段目を全てswap”というクエリになると何が嬉し い？ • とりあえず、位置1(木の根)に対して”i段目を全て swap”というクエリだけがくると考える • こうすると、”i段目を全てswap”→”j段目を全て swap”をしても、”j段目を全てswap”→”i段目を全て swap”しても、できる木は変わらないことがわかる 例 1 2 3 4 5 6 7 高さ2をswap → 高さ3をswap 8 例 3 4 1 2 7 8 5 高さ2をswap → 高さ3をswap 6 例 4 3 2 1 8 7 6 高さ2をswap → 高さ3をswap 5 例 1 2 3 4 5 6 7 高さ3をswap → 高さ2をswap 8 例 2 1 4 3 6 5 8 高さ3をswap → 高さ2をswap 7 例 4 3 2 1 8 7 6 高さ3をswap → 高さ2をswap 5 i段目を全てswap • 結局、それぞれの高さごとに”反転しているか”とい うフラグを持てば良い • “高さiを反転”というクエリが来たら、それに対応す るフラグを反転させる i段目を全てswap • 位置1(木の根)以外にもクエリが来るなら? • 先述のflagを各頂点にもたせて、伝搬させていく • 高さiのノードにアクセスするときは、i番目のフラ グが立っていたら左右の子をswapして、i+1番目以 降のフラグを全て子のフラグに伝搬させる i段目を全てswap • これをsegtreeを潜る時に行うと、アクセスする ノードの上の頂点は常に何もフラグが立っていない ようにできるので、うまく動く • 計算量はクエリを分割する個数がO(logn)なので、 クエリあたりO(logn) ARC048 解説 DEGwer A問題 階段の下 問題概要 • A階からB階まで、何回階段を上る必要がある か? • ただし、x>0に対し、-x階は地下x階を表す • −109≤ 𝐴 < 𝐵 ≤ 109 解法 • 地下1階の上は地上1階 • それ以外に関しては、k階の上はk+1階 場合分け① • AとBの符号が等しい場合 • 「地下1階と1階の間」の階段を使わないので、 B-Aが答え 場合分け② • AとBの符号が異なる場合 • 「地下1階と1階の間」の階段を使うので、①に 比べて使う階段の数が一つ減る • B-A-1が答え • 以上でこの問題が解けた B問題 AtCoderでじゃんけんを 問題概要 • N人の人がいて、レーティングとじゃんけんで 出す手が決まっている • AtCoderじゃんけんでは、二人のレーティング が異なる場合高いほうが勝ち、そうでない場 合はじゃんけんの結果で勝敗を決める • 各人について、ほかのN-1人とAtCoderじゃん けんをした時の対戦成績が何勝何敗何引き 分けか求めよ • N<=100000, レーティング<=100000 解法 • 各レーティングと手ごとに、人のIDを要素とし た配列を持っておく • 変数Kを「今見ているレーティングより低い レーティングの人の人数」として使うことにす る • レーティングが低いほうから見ていく • 最初はK=0 解法 • 各レーティングについて、そのレーティングで グー、チョキ、パーを出した人の人数をそれ ぞれA,B,Cとすると、グーを出した人の対戦成 績は、K+B勝N-K-A-B敗A-1引き分けとなる • チョキ、パーについても同様に計算できるの で、合計O(N+(レーティングの最大値))でこの 問題が解けた C問題 足の長い高橋君 問題概要 • N個の0,1からなる文字列の組であって、以下 の条件を満たすものの個数をmod 10億7で答 えよ(N<=100000) • 条件: – 𝑖番目の文字列の長さは𝐿𝑖 (𝐿𝑖 ≤ 109 ) – 任意の𝑖 ≠ 𝑗に対し、 𝑖番目の文字列の後に𝑗番目 の文字列をひっくり返したものをつなげたものが 回文となる 考察 • 一番短い文字列の長さをDとおくと、すべての 文字列の先頭D文字は等しい – 一番短い文字列の後ろにほかの文字列をひっく り返したものをつなげたものが回文となるため – 逆に、各文字列の先頭D文字に関してはこれ以 上の制約がつくことはない 考察 • 各文字列に対し、その先頭D文字を取り除い た文字列は回文 – その文字列に、一番短い文字列をひっくり返した ものをつなげたものが回文となるため 考察 • 2つの異なる文字列に対し、1つめの文字列 の先頭D文字を取り除いたものの後ろに2つ めの文字列の先頭D文字を取り除いたものを ひっくり返したものをつなげたものは回文 考察 • 2つの異なる文字列に対し、1つめの文字列 の先頭D文字を取り除いたものの後ろに2つ めの文字列の先頭D文字を取り除いたものを ひっくり返したものをつなげたものは回文 • 赤字の2つは前の考察により回文だとわかっ ている • 「回文と回文をつなげて回文をつくっている」 という主張 考察 • 次の補題を考える • 「長さXの回文Aと長さYの回文Bをつなげると 回文になるとき、AもBも周期gcd(X,Y)をもち、さ らにその1周期は回文」 • 以下これを示す 証明 • AとBは回文で、以下のようにAとBをつなげた ものも回文 A B 証明 • Aが回文で全体が回文なので、下の赤い領域 は同じ文字列 A B 証明 • Bが回文なので、ここも等しい A B 証明 • 全体が回文なので、ここも等しい A B 証明 • Bが回文なので、ここも等しい A B 証明 • 全体が回文なので、ここも等しい A B 証明 • この緑色の部分は、同じ回文の先頭と末尾 の共通部分なので回文 A B 証明 • この黄色の部分も、同じ回文の先頭と末尾の 共通部分なので回文 A B 証明 • 赤、黄、緑すべての部分が回文 • これは最初と同じ状況 • 黄色い部分の長さは、AとBをつなげた文字列 の長さをAの長さで割った余り • (黄色の長さ, 赤の長さ)の組は(A+B,B)から Euclidの互除法の1ステップで得られるものと 同じ 証明 • 黄色の長さが0でない限りこの操作は続けら れる • この終了条件もEuclidの互除法と同じ • 結局、この操作でEuclidの互除法と同じことが でき、Euclidの互除法はGCDを正しく求めるの で、結局AもBも周期gcd(X,Y)を持ち、その1周 期は回文であることが分かった 解法 • この補題を元の問題に適用する • 2つの異なる文字列に対し、1つめの文字列 の先頭D文字を取り除いたものの後ろに2つ めの文字列の先頭D文字を取り除いたものを ひっくり返したものをつなげたものは回文 解法 • つまり、1つめの文字列(長さX)の先頭D文字 を取り除いたものと2つめの文字列(長さY)の 先頭D文字を取り除いたものは、どちらも周期 gcd(X,Y)を持ち、その1周期は回文 – 逆にこの条件が満たされていれば大丈夫なこと は明らか 解法 • つまり、𝐿𝑖 − 𝐷たちのGCDをgとおくと、各文字 列は、先頭D文字が等しく、かつそのあとは周 期gの同じ回文が並ぶ文字列となる • このような文字列の総数は2 𝐷+ 𝑔 2 通りである ので、O(N+log (𝐿𝑖たちのmax))でこの問題が 解けた D問題 たこ焼き屋とQ人の高橋 君 問題概要 • N頂点の重みなし無向木があり、いくつかの 頂点にはたこ焼き屋がある • 次のクエリをQ個処理せよ • クエリ: 「始点と終点が与えられるので、たこ 焼き屋による前は速度1/2で進みたこ焼き屋 に寄ったあとは速度1で進む人が始点から終 点まで行く最小の時間を求めよ」 • N,Q<=100000 考察 • 最適な移動経路は次の2つのうちのいずれか • ①: たこ焼き屋を経由せずに始点から終点ま で最短経路で向かう • ②: 始点からあるたこ焼き屋まで最短経路で 向かった後、そのたこ焼き屋から終点まで最 短経路で向かう 考察 • 最適な移動経路は次の2つのうちのいずれか • ①: たこ焼き屋を経由せずに始点から終点ま で最短経路で向かう • ②: 始点からあるたこ焼き屋まで最短経路で 向かった後、そのたこ焼き屋から終点まで最 短経路で向かう 考察 • ①: たこ焼き屋を経由せずに始点から終点ま で最短経路で向かう • このケースは、単に始点と終点のLCAを求め て深さを見ればいい 考察 • 最適な移動経路は次の2つのうちのいずれか • ①: たこ焼き屋を経由せずに始点から終点ま で最短経路で向かう • ②: 始点からあるたこ焼き屋まで最短経路で 向かった後、そのたこ焼き屋から終点まで最 短経路で向かう 考察 • ②: 始点からあるたこ焼き屋まで最短経路で 向かった後、そのたこ焼き屋から終点まで最 短経路で向かう • それは以下のような経路(緑がたこ焼き屋、青 い辺は速度1/2で進むパス、赤い辺は速度1 で進むパスを表す) 考察 • 与えられるグラフは木なので、黄色の点は始 点と終点を結ぶ最短経路上にあり、この経路 を通る時間は • d(始点,終点)+d(始点,黄色)+d(黄色,緑)*3 – ただしd(A,B)でA-B間の最短路長を表す 考察 • つまり、この問題は、始点と終点間のパス上 の頂点を黄色の頂点、たこ焼き屋のある頂点 を緑の頂点としてうまく選び、 • d(始点,終点)+d(始点,黄色)+d(黄色,緑)*3 • を最小化するクエリにこたえる問題 考察 • 黄色の頂点を固定するとd(黄色,緑)を最小化 すればよく、黄色の頂点から一番近いたこ焼 き屋のある頂点を緑の頂点として選べばよい – 各頂点から一番近いたこ焼き屋のある頂点への 距離は、たこ焼き屋のある頂点を最初に全部 queueに入れて幅優先探索をすれば求まる 考察 • 各頂点vから一番近いたこ焼き屋のある頂点 までの距離の3倍をX(v)とおくと、 • d(始点,終点)+d(始点,黄色)+X(黄色) • の最小値を求めればよい • つまり、d(始点,黄色)+X(黄色)を最小化すれ ばよい 解法 • まず、適当な頂点を根とする根つき木にして おく • depth(v)で頂点vの根からの深さを表すことに する • 始点と終点のLCAをLとおく 場合分け • 黄色い頂点をLより始点側にとる場合 • d(始点,黄色)+X(黄色)=depth(始点)-depth(黄 色)+X(黄色) • よって、始点からLまでのパス上の • X(黄色) -depth(黄色) • の最小値を求めればよい 場合分け • 黄色い頂点をLより終点側にとる場合 • d(始点,黄色)+X(黄色)=depth(始点)+depth(黄 色)-2*depth(L)+X(黄色) • よって、Lから終点までのパス上の • X(黄色) +depth(黄色) • の最小値を求めればよい 解法 • どちらの場合も、X(黄色) ±depth(黄色)をあ らかじめ計算しておけば、この最小値はダブ リングを用いて求めることができる • 前処理はLCAの初期化でO(Nlog N) • 各クエリに対してはダブリングのO(log N) • で計算できるので、O((N+Q)log N)でこの問題 が解けた ARC047解説 A:タブの開きすぎ A-問題概要 ● L個以上タブを開くとクラッシュして、タブが1 個に減ってしまうブラウザがある ● 初めタブは1個だとして、そのあとの「タブを 開く」「タブを閉じる」の履歴が与えられるの で、クラッシュの回数をもとめよ。 A-考察 ● タブの個数以外気にしなくて良い。 A-解法 ● タブの個数を変数で管理しておく。 A-解法 ● タブの個数を変数で管理しておく。 ● タブを閉じるとき – 変数の値を1減らす A-解法 ● タブの個数を変数で管理しておく。 ● タブを閉じるとき – 変数の値を1減らす ● タブを開くとき – タブの個数がL個未満ならば、変数の値を1増やす A-解法 ● タブの個数を変数で管理しておく。 ● タブを閉じるとき – 変数の値を1減らす ● タブを開くとき – タブの個数がL個未満ならば、変数の値を1増やす – タブの個数がL個ならば変数の値を1にして、ク ラッシュの回数を1増やす ARC047解説 B:同一円周上 B-問題概要 ● 格子点上の点が N 個与えられる。 ● 全ての点からのマンハッタン距離が等しい格子 点上の点Pを1つもとめよ ● N ≦ 10^5 ● -10^9 ≦ 座標の値 ≦ 10^9 B-考察 ● ある点からマンハッタン距離が等しい点の集合 はどのようなものか？ B-考察 ● ある点からマンハッタン距離が等しい点の集合 はどのようなものか？ 点P B-考察 ● ある点からマンハッタン距離が等しい点の集合 はどのようなものか？ 点Pからマンハッタン距離3の点 B-考察 ● ある点からマンハッタン距離が等しい点の集合 はどのようなものか？ →45度傾いた正方形の外周になる B-考察 ● ある点からマンハッタン距離が等しい点の集合 はどのようなものか？ →45度傾いた正方形の外周になる ● この正方形の大きさがわかれば、点Pのおおよ その見当がつく。 B-45度傾ける ● 45度傾いた状態で扱うのはわかりづらいの で、もとに戻すために、X,YではなくX+Y,X-Y で各点を表してみる。 ● すると軸に平行な正方形がでてくる。 → B-考察 ● (回転後の)X座標の最大値と最小値の差、と （回転後の）Y座標の最大値と最小値の差のう ち大きい方が、正方形の１辺の長さと一致す る。 B-確認 ● 4辺の内全ての辺から1つ以上残っている場合 – Xの最大値と最小値の差も、Yの最大値と最小値の 差も一辺の長さと一致する。 B-確認 ● 4辺の内3つの辺から1つ以上残っている場合 – Xの最大値と最小値の差か、Yの最大値と最小値の 差の大きい方が一辺の長さと一致する。 B-確認 ● 4辺のうち向かい合う2辺について1つ以上残っ ている場合 – Xの最大値と最小値の差か、Yの最大値と最小値の 差の大きい方が一辺の長さと一致する。 B-確認 ● 4辺のうちとなりあう2辺について1つ以上残っ ている場合 – Xの最大値と最小値の差か、Yの最大値と最小値の 差の大きい方が一辺の長さと一致しない？？？ B-確認 ● 4辺のうちとなりあう2辺について1つ以上残っ ている場合 – Xの最大値と最小値の差か、Yの最大値と最小値の 差の大きい方が一辺の長さと一致する点Pがある。 B-考察 ● 1辺の長さについては、X座標の最大値と最小 値の差とY座標の最大値と最小値の差をみて、 大きい方をとればよい。 ● １辺の長さをDとする。与えられたX座標、最 大最小をXmax,Xminで表し、点PのX座標、Y座 標をPx,Pyとすると Xmax-Px, Px -XminのいずれかがD/2と一致す る。 – Y座標も同様 ● よってDの値と全体のX座標、Y座標の最大最小 から点Pの候補が有限個に決まる B-考察 ● さきほどの考察は45度回転した後の世界での 計算である。 ● 回転後のXやYの値は、回転前のX+YやX-Yの値 と対応するので、実装するときはその値でプロ グラムを組まなければならない。 B-解法 ● 与えられた点について(X+Y)の最大値と最小値 の差、（X-Y）座標の最大値と最小値の差を求 め、大きい方をDとする ● 先ほどの考察を使ってPx,Pyの値を有限個にし ぼりこむ ● そのうちすべての点とのマンハッタン距離が等 しい点を挙げれば良い ARC047解説 C:N!÷K番目の単語 C-問題概要 ● [1,2,..,N]を並び替えたものを「単語」という ● 単語のうち辞書順で小さい方から N! / K番目 (1-index)のものを求めよ ● K ≦ N ≦ 10^5 C-考察1 ● 単語の中で辞書順X番目(0-index)のものを求め るにはどうすればいいか？ C-考察1 ● 単語の中で辞書順X番目(0-index)のものを求め るにはどうすればいいか？ → 1文字目から順番に決めていけば良い C-X番目の求め方 ● 1文字目が1であるような単語はいくつある か？ – 2文字目以降の並びを考えると(N-1)!通り ● 1文字目が2であるような単語はいくつある か？ – 同様に(N-1)!通り ● X番目の単語の1文字目は何か？ – 上の考察より、[X / (N-1)!] + 1 – []はガウス記号 C-X番目の求め方 ● 1文字目が求まった！→Aとする ● つぎにもとめるべきものは？ [1,2,..., A-1, A+1,...N]を並び替えたものの中で X % (N-1)!番目の物 ● さきほどと同様の計算で求めることが出来る。 ● 順番に繰り返せばすべての桁の値が決まる。 ● 以降は[X / (N-1)!] + 1ではなくて[X / (N-1)!] + 1番目に小さい値であることに注意 C-部分点 ● いまのような計算方法でN!/K番目の値をもとめ る。 ● N ≦ 20なのでN!/Kは64bit整数に収まるので、 様々な言語で扱える。 C-考察2 ● Nが大きいと N!/Kを陽に持つことは出来な い。 C-考察2 ● Nが大きいと N!/Kを陽に持つことは出来な い。 ● やりたい操作は – (N-1)!で割る – その余りを求める C-考察2 ● Nが大きいと N!/Kを陽に持つことは出来な い。 ● やりたい操作は – (N-1)!で割る – その余りを求める 実際にやってみる C-考察2 ● N!/Kを(N-1)!で割った商は – (N/K)×(N-1)! ÷ (N-1)! の商 – → N÷K の商 ● N!/Kを(N-1)!で割ったあまりは – (N/K)×(N-1)! ÷ (N-1)! のあまり – → 「N÷Kのあまり」÷ K × (N-1)! – これは 整数÷K×(N-1)! の形をしている C-考察2 ● このあと2桁目を求めるときに – 整数÷K×(N-1)! を (N-2)!で割った商と余り を求めることになる。商は先ほど同様に簡単に 求めることができ、あまりは – 整数÷K×(N-2)! になる。 C-考察2まとめ ● 1桁目を求めるときに扱う値が 1÷K×N! ● 2桁目を求めるときに扱う値が 整数÷K×(N-1)! ● 3桁目を求めるときに扱う値が 整数÷K×(N-2)! ● 4桁目を求めるときに扱う値が 整数÷K×(N-3)! : C-考察2まとめ ● 1桁目を求めるときに扱う値が 1÷K×N! ● 2桁目を求めるときに扱う値が 整数÷K×(N-1)! ● 3桁目を求めるときに扱う値が 整数÷K×(N-2)! ● 4桁目を求めるときに扱う値が 整数÷K×(N-3)! : C-考察2まとめ ● 1桁目を求めるときに扱う値が 1÷K×N! ● 2桁目を求めるときに扱う値が 整数÷K×(N-1)! ● 3桁目を求めるときに扱う値が 整数÷K×(N-2)! ● 4桁目を求めるときに扱う値が 整数÷K×(N-3)! : 赤字の整数だけ保存しておくだけで済む C-解法 ● 部分点1と同じ解法を、N!/Kを陽に持たずに計 算する。 ● 保存しておく整数はあまり大きくならないこと が保証される。 – 考察すると 整数÷K ≦ N となることがわかる ● 残っている数字の中でX番目に小さいものをも とめる作業はBIT上の二分探索で実装できる →計算量O(Nlog^2N) 満点獲得 ARC047解説 D:ナナメクエリ D-問題概要 ● 全てのマスが0に初期化されたN×Nの方眼紙上 で以下のクエリをQ個処理せよ。 ● 1:A≦ X+Y ≦ Bとなるマス(X,Y)にCを足す ● 2:A≦ X-Y ≦ Bとなるマス(X,Y)にCを足す ● 3:A≦X≦ B,C≦Y≦Dとなるマス(X,Y)の範囲内の 最大値とその個数を求める ● N,Q≦5,000 D-部分点解法 ● N ≦ 50 ● 指示通りシミュレートする ● 一度のクエリで参照する必要のマスは最大で 2500個程度 ● 充分少ないので間に合う ● O(N^2Q）10点獲得 D-考察 ● sum[i] := 「X+Y=iとなるマス(X,Y)にクエリ1で 足された値の総和」 ● dif[i] := 「X-Y=iとなるマス(X,Y)にクエリ2で足 された値の総和」 という2つの変数を用意する。 ● sum[X+Y]とdif[X-Y]がわかればマス(X,Y)の値も すぐわかる。 D-考察 ● sum[X+Y]とdif[X-Y]がわかればマス(X,Y)の値も すぐわかる ● クエリ1とクエリ2はO(N)で処理できる ● 問題はクエリ3 D-考察 ● クエリ3の範囲のなかでとりうるX-Yの値は連 続している。 ● 右図のような範囲の場合 X-Yは-3～2の値を取る D-考察 ● X-Yの値を決めてやると、X+Yの値の範囲も決 まり、1個飛ばしの値をとる。 ● X-Y = -1とする X+Yは1～５の奇数をとる D-考察 ● X-Yを決めた時に、その中で最大の値を持つマ スは、適切な範囲のsumの最大値 + dif[X-Y]と なる。 ● X-Y=-1ならば max{sum[1],sum[3], sum[5]} +dif[-1] が右線上の最大値である D-偶奇でわける ● さきほどの考察で、X-Yを固定した時のX+Yの 取りうる値の範囲が連続だったら、bitやセグ メントツリーをつかってO(logN)で最大値を求 めることが出来る。 ● X+Yの範囲は連続ではないものの2飛ばしであ るため、2つセグメントツリーを作ってX+Yが 奇数のものと偶数のものを分けて管理すれば、 きっちり連続した区間になってくれる。 D-部分点2まとめ ● sum[i]やdif[i]を使ってマスの値を保存する ● クエリ1,2は愚直にO(N)でsumやdifを更新 ● クエリ3の時はdif[X-Y]を全通り試して、各X-Y に対して対応するX+Yに値の範囲をもとめ、セ グメントツリーで最大値とその個数をもとめ る。 ● O(NlogNQ) 30点獲得 D-考察 ● クエリの範囲が正方形である時を考える ● 偶奇は別々に考えていいので今回は奇数だけ考 える ● 部分点2で注目したX+Yの範囲をよく見てみる D-考察 ● X-Y = -3のときX+Yの範囲は[3] D-考察 ● X-Y = -3のときX+Yの範囲は[3] ● X-Y = -1のときX+Yの範囲は[1,3,5] D-考察 ● X-Y = -3のときX+Yの範囲は[3] ● X-Y = -1のときX+Yの範囲は[1,3,5] ● X-Y = 1のときX+Yの範囲は[1,3,5] D-考察 ● X-Y = -3のときX+Yの範囲は[3] ● X-Y = -1のときX+Yの範囲は[1,3,5] ● X-Y = 1のときX+Yの範囲は[1,3,5] ● X-Y = 3のときX+Yの範囲は[3] D-観察 ● 出てきた範囲の種類は – [3] – [1,3,5] ● これを8×8で実験した場合だと – [7] – [5,7,9] – [3,5,7,9,11] – [1,3,5,7,9,11,13] となる D-考察 ● 良い順番で処理するとX+Yの範囲は増えるだけ になる。 – 値が増えるだけならセグメントツリーをつかわなく ても随時maxをとるだけで最大値がわかる ● 正方形のクエリならば一辺の長さに対する線形 時間で処理することが出来る。 D-考察 ● クエリの範囲が長方形の時は？ – 正方形に分割してやれば良い。 D-考察 ● クエリの範囲が長方形の時は？ – 正方形に分割してやれば良い。 ● どうやって分割する？ – ユークリッドの互助法の要領でできるだけ大きい正 方形を削り取るように分割していく D-考察 ● 例 D-考察 ● 例 D-考察 ● 例 D-考察 ● 例 D-考察 ● 例 D-計算量 ● １辺がXの正方形のクエリを処理するのにO(X) の時間がかかる ● タテとヨコの和がSの長方形から先ほどの方法 で1辺がXの正方形を剥ぎとった時、のこる長 方形のタテとヨコの和はS-X以下になる ● よって、全て正方形に分割し終えたときの総計 算量はO(S)＝O(N)となり無事に線形時間で処 理が終わる。 D-満点まとめ ● 部分点2同様にsumとdifを作る。 ● 正方形のクエリならば線形時間で解ける。 ● 長方形のクエリでも正方形に分割すると線形時 間でとける。 ● O(NQ) 満点 D-満点別解(紹介のみ) ● 部分点2でセグメントツリーを使うかわりにス ライド最小和を使うことで、logを一つ取るこ とが出来る。 ● hashmap(sortされていない代わりにアクセス が定数時間であるmap)を使えば最大値の個数 を数えるのが線形時間でできるようになる AtCoder Regular Contest 046 解説 AtCoder株式会社 3/19/15 問題 A – ゾロ目数 問題概要 • すべての桁の数字が同じであるような正の整数をゾロ目数と呼ぶ。 • 小さい方から 𝑁 番目のゾロ目数を求めよ。 • 1 ≤ 𝑁 ≤ 50 解法 (1) • ゾロ目数を列挙してみる。 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 111, 222, 333, 444, 555, 666, 777, 888, 999, … • 𝑖 行目の 𝑗 番目のゾロ目数は、数字 𝑗 を 𝑖 回繰り返した数である。 • 数字 (N-1)%9+1 を (N-1)/9+1 回出力すればよい。 解法 (2) • サンプル 3 を見ると、𝑁 = 50 のゾロ目数は 555555 と小さい。 • 1 から 555555 まで順にゾロ目数か判定しても、間に合う。 解法 (3) • 𝑁 ≤ 50 と小さい。 • 小さい方から 50 番目までのゾロ目数を、コードに埋め込む。 B: 石取り大作戦 問題概要 • N 個の石を使って石取りゲームを行う– プレイヤーは交互に 1 個以上の石を取る– 最後の石を取ったほうの勝利である • 先手は A 個、後手は B 個まで一度に石を取れる• 2 人が最適に行動したとき勝利するのはどちらか？• 制約 – 1 ≦ N ≦ 109 – 1 ≦ A, B ≦ 109 考察 • N ≦ A のとき – 先手が全ての石を取れば勝利 – 先手必勝 • N > A のとき – A = B のとき • ? – A ≠ B のとき • ? (1) N > A かつ A = B のとき• N = A + 1 のときを考える (サンプル2 参照) – 先手がどのように石を取っても必ず後手が勝つ– 後手必勝 • N を A + 1 で割ったあまりが 0 のとき、後手必勝– 先手がどのように石を取っても、後手は石の数をA +1 で割ったあまりが 0 となるように石を取り続けることが可能– 後手はいずれ最後の石を取り勝利する• N を A + 1 で割ったあまりが 0 以外のときは？ (1) N > A かつ A = B のとき• N を A + 1で割ったあまりが 0 以外のときは？– 石の数を A + 1 で割ったあまりが 0 になるように取ると、後手必勝の状況を相手に押しつけられる– よって先手必勝 (2) N > A かつ A ≠ B のとき• A > B のときを考える – 直感的には先手が有利そう – この直感は正しく先手必勝 • 証明 – N > A のときを考える – 先手が 1 個の石を取ったとき、後手がどのように石を取ったとしても再び先手の手番が訪れる• N – 1 > A – 1 ≧ B より明らか – いずれ N ≦ A の盤面で先手の手番が訪れるので先手必勝 (2) N > A かつ A ≠ B のとき• A < B のときを考える – こちらの場合には後手必勝 • 証明 – 先手がどのように石を取っても後手の手番が訪れる– このとき残りの石の数 N について N ≦ B ならば後手の勝利– N > B のとき、後手が 1 個の石を取ったとき、先手がどのように石を取ったとしても再び後手の手番が訪れる– いずれ N ≦ B の盤面で後手の手番が訪れるので後手必勝 まとめ • N ≦ A のとき – 先手必勝 • N > A のとき – A = B のとき • N を A + 1 で割ったあまりが 0 以外: 先手必勝• それ以外: 後手必勝 – A ≠ B のとき • A > B : 先手必勝 • A < B : 後手必勝 いずれの場合も O(1) で判定可能 C: 合コン大作戦 問題概要 • N 人の男性と M 人の女性がいる • i 番目の男性は整数 Ai , Bi を持つ • j 番目の女性は整数 Cj , Dj を持つ • Dj ≦ Ai かつ Bi ≦ Cj となるペアの数を最大化せよ– ただし，それぞれの人は複数のペアに所属してはならない• 制約 – 1 ≦ N, M ≦ 150,000 – 1 ≦ Ai , Bi , Cj , Dj ≦ 109 考察 • この問題は二部グラフの最大マッチング問題– 最大流を求めるアルゴリズムで解くことができるが…• 今回は頂点数，辺の数ともに大きく間に合わない• 問題で与えられた制約や性質をうまく利用することを考える1 2 3 1 2 3 4 サンプル 2 部分点 (30 点) • 任意の i, j ( 1 ≦ i ≦ N, 1 ≦ j ≦ M) でBi ≦ Cj が成立– 任意の男性の要求を全ての女性が満たす• 各女性について要求を満たす男性がいるか知りたい– Ai , Dj にのみ着目すればよい – Ai , Dj で男女それぞれをソートする 部分点 (30 点) • サンプル 2 についてAi , Djで昇順にソートすると…• Dj が小さい女性から順に、まだペアを組んでいないDj ≦ Ai を満たす Ai が最小の男性とのペアを貪欲に成立させていくのが最適だと分かる2 1 3 2 1 4 3 サンプル 2 部分点解法 (30 点) • Dj が小さい女性から順に、先述の条件を満たす男性と貪欲にマッチングを行えばよい • 愚直に毎回調べると O(NM) となって間に合わないがしゃくとり法を用いるとO(N + M) で実現できる• 計算量はソート部分が最も重く O(N logN + MlogM) 満点 (100 点) • 今度は Bi > Cj であるようなケースが存在する– Ai , Dj に関する単純な貪欲法ではうまくいかない• 突然だが、部分点解法を以下のように言い換える– 集合 S がある。 S ははじめ空集合である– 以下の N + M 個の 2 種類のクエリに答えよ• S に要素を 1 つ追加する • S から要素を 1 つ取り除く。 S が空集合ならば何もしない– 要素の追加はマッチングを待っている女性の追加を、要素の削除は男性とのマッチングを成立させるのに対応– S から要素を取り除くのに成功した回数が求める答え 満点 (100 点) • 満点の状況に対応するようさらに言い換える– 多重集合 S がある。 S ははじめ空集合である– 以下の N + M 個の 2 種類のクエリに答えよ• S に Cj を 1 つ追加する • S から Bi 以上の要素を 1 つ取り除く。 S に条件を満たすものが存在しないならば、何もしない – 要素の追加はマッチングを待っている女性の追加を、要素の削除は男性とのマッチングを成立させるのに対応– S から要素を取り除くのに成功した回数が求める答え– 削除する要素はどのように選ぶのが最適か？• 条件を満たすような最小の要素を選ぶのが最適 満点解法 (100 点) • この問題は最終的に以下の問題に帰着できる– 多重集合 S がある。 S ははじめ空集合である– 以下の N + M 個の 2 種類のクエリに答えよ• S に Cj を 1 つ追加する • S から Bi 以上の最小の要素を 1 つ取り除く。S に条件を満たすものが存在しないならば、何もしない– S から要素を取り除くのに成功した回数が求める答え• 上記のクエリをmultisetを用いて処理してやればよい– multisetが標準ライブラリに存在しない場合でも、セグメント木、Fenwick Tree、平方分割などのデータ構造を用いて解くことが可能 • 全体の計算量は O((N + M)log(N + M)) 問題 D – うさぎとマス目 問題概要 • 𝐻 行、𝑊 列のマス目がある。 • 最初、 0, 0 にうさぎがいる。 • うさぎは 𝑖,𝑗 から ( 𝑖 + 1 %𝐻,𝑗) または (𝑖, 𝑗 + 1 %𝑊) へ移動できる。 • うさぎがすべてのマスをちょうど 1 回ずつ訪れ、 0, 0 へ戻ってくる方法 は何通りか？ 例（サンプル 1） • 𝐻 = 2，𝑊 = 2 → 2 通り 例（サンプル 2） • 𝐻 = 6，𝑊 = 3 → 3 通り 考察 (1) • 仮に、マス ① から → へ移動するとする。 考察 (1) • マス ② を訪れるためには、マス ③ から → へ移動しなければならない。 考察 (1) • 連鎖的に、→ へ移動しなければならないマスが決まっていく。 考察 (1) • 仮に、マス ① から ↓ へ移動するとする。 考察 (1) • マス ② を訪れるためには、マス ③ から ↓ へ移動しなければならない。 考察 (1) • 連鎖的に、↓ へ移動しなければならないマスが決まっていく。 考察 (1) • 結局、青のレーンはすべて同じ向きへ移動しなければならない。 考察 (1) • 同様に、赤や緑のレーンはすべて同じ向きへ移動しなければならない。 • ここで、レーンの本数 𝑑 は 𝑑 = GCD 𝐻, 𝑊 と計算できる。 考察 (1) • 最初の 𝑑 歩の向きを決めると、 考察 (1) • 最初の 𝑑 歩の向きを決めると、全体の向きが一意に決まる。 • しかも、最初の 𝑑 歩の繰り返しになっている！ 考察 (1) • 「すべてのマスをちょうど 1 回ずつ訪れ、 0, 0 へ戻ってくる」ためには、 「最初の 𝑑 歩を繰り返す」ことが必要条件。 考察 (2) • しかし、「最初の 𝑑 歩を繰り返す」ことは必要十分条件ではない。 • 先の例は、すべてのマスを訪れる前に 0, 0 へ戻ってしまっている。 考察 (2) • 最初の 𝑑 歩を全通り試し、すべてのマスを訪れているか個別に チェックする？ → 最初の 𝑑 歩は 2 𝑑 通りもあるので、TLE してしまう。 考察 (2) • 「最初の 𝑑 歩の行き先」は 𝑑 + 1 通りしかないので、全通り試せる。 • 最初の 𝑑 歩をまとめて、紫の矢印で表す。 考察 (2) • 紫の矢印は 𝑑 歩分なので、紫の矢印を 𝐻𝑊 𝑑 回繰り返して 0, 0 へ 戻ってくれば、すべてのマスを訪れたことになる。 考察 (2) • OK の例 考察 (2) • NG の例 考察 (2) • 紫の矢印を何回繰り返すと 0, 0 へ戻ってくるか？ • 紫の矢印が右へ 𝑥 マス、下へ 𝑦 マス移動するとする。 （ただし、𝑥 + 𝑦 = 𝑑） • 紫の矢印の横方向の周期は W GCD 𝑊,𝑥 • 紫の矢印の縦方向の周期は H GCD 𝐻,𝑦 • よって、紫の矢印が 0, 0 へ戻ってくるまでの周期は LCM W GCD 𝑊, 𝑥 , H GCD 𝐻, 𝑦 解法 • 𝑑 = GCD(𝐻, 𝑊) を計算する。 • 𝑥 ≥ 0，𝑦 ≥ 0，𝑥 + 𝑦 = 𝑑 を満たす 𝑥, 𝑦 の組を全探索する。 • 各 𝑥, 𝑦 の組に対して、 LCM W GCD 𝑊, 𝑥 , H GCD 𝐻, 𝑦 = 𝐻𝑊 𝑑 ならば、 𝑥+𝑦 𝑥 を答えに足す。 • 計算量は O 𝑑 log 𝑑 AtCoder Regular Contest 045 解説 AtCoder株式会社 10/10/15 スペース高橋君 解説スライド担当: 森田 晃平(@yosupot) 問題概要 • 文字列が与えられる • Left → < • Right → > • AtCoder → A • と置換して出力 解法(C++) • getline等の関数を使うと1行まるまる読み込めます • cin, scanfで読み込む場合は空白文字に注意してく ださい • 空白後の1文字を見て、Lなら<、Rなら>、AならA を出力し、そのあと次の空白まで進む。などの解法 が考えられます 解法 • 文字列を扱う高級な関数を使うと楽です • たとえばpythonならreplace('AtCoder', 'A')で AtCoderを全部Aにできます • プロコンにおいてC++しか使わない人は多いと思い ますが、他にpython,ruby等の文字列処理のライブ ラリが充実している言語を1個は使えるとよいです ©AtCoder Inc. All rights reserved. B問題 ドキドキデート大作戦高橋君(解説スライド:三上) 1. 問題概要 2. 考察 3. 解法 4. アルゴリズム動作例 1 B問題 問題概要 • Nコの教室があり，全ての教室を掃除したい • 担当すると掃除しなければならない区間(掃除区間)がMコ 与えられる(これは重なることがある) • ある区間iを掃除しなかったとしても，全ての教室が問題 なく掃除されているような区間iを全て列挙せよ． • Mコの区間を全て使った場合に全ての教室が掃除できる ことは保証されている． • 1≦N≦10^6 • 1≦M≦10^5 2 B問題 考察 • まず，各教室がいくつ䛾区間に被覆されているかを求めておくと 見通しがよくなる． • これ䛿imos法(※)を用いて時間計算量 O(N+M) で達成可能 ※ http://www.slideshare.net/chokudai/abc014 (P3参照) • 各教室がいくつ䛾区間に被覆されてるか分かれ䜀， ある教室を除いても全て䛾教室が掃除できる ⇔区間内䛾全て䛾教室が2つ以上䛾区間に被覆されている 3 B問題 部分点解法(30点) • 追加制約 – 任意の教室 i(1≦i≦N) について，その教室を含む掃除区間の数は高々 2 つである • この制約上では，全ての区間について，区間内の全ての教室 の被覆数を繰り返し文で愚直にチェックして，それらの最小値が 2以上ならその区間を解の候補に入れるというアルゴリズムで 正解する． • 理由は，for文で愚直にチェックしたところで，2回より多く同じ教 室を見ることはないので，高々 2N 回しかループしないから • 別解もたくさんある – 各教室について，その教室を被覆している区間の番号の列 を持つ配列を用意する等 4 B問題 満点解法 • 各教室がいくつ䛾区間に被覆されてるか分かれ䜀， ある教室を除いても全て䛾教室が掃除できる ⇔区間内䛾全て䛾教室が2つ以上䛾区間に被覆されている ⇔区間内に，被覆数が1䛾教室が含まれない • 教室i䛾被覆数が1ならX[i]=1，そうでないならX[i]=0を記録した 配列Xに対し累積和配列Sを生成すると，ある区間に含まれる 被覆数1䛾教室䛾個数がO(1)で計算できるようになる • 各区間に対してO(1)でそれが解に含まれるかどうかが判定でき るようになり，判定にかかる計算量䛿O(M)となった． • 全体䛾時間計算量,空間計算量䛿 O(N+M) となり満点 5 B問題 アルゴリズム動作例 6 • いもす法を行う 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] B問題 アルゴリズム動作例 7 • いもす法を行う 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] B問題 アルゴリズム動作例 8 • いもす法を行う 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] B問題 アルゴリズム動作例 9 • いもす法を行う 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] B問題 アルゴリズム動作例 10 • いもす法を行う 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] B問題 アルゴリズム動作例 11 • いもす法を行う 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] B問題 アルゴリズム動作例 12 • いもす法を行う →の方向に累積和を取るとこうなる 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] B問題 アルゴリズム動作例 13 • 被覆数が1の部分だけに着目 • 満点解法で述べた配列Xを生成 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] B問題 アルゴリズム動作例 14 • 被覆数が1の部分だけに着目 再度→方向に累積和を取り 満点解法で述べた配列Sを生成 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] B問題 アルゴリズム動作例 15 • 後は各区間について調べる • 被覆数1の教室を含むかどうか判定 • [1,4] → S[4] – S[0](=0とする) = 4なので× • [5,5] → S[5] – S[4] = 0なので○ • [6,8] → S[8] – S[5] = 2なので× • [9,10] → S[10] – S[8] = 2なので× • [5,6] → S[6] – S[4] = 0なので○ 入力例 N=5,M=10 [1,4] [5,5] [5,6] [6,8] [9,10] ©AtCoder Inc. All rights reserved. C問題 エックスオア多橋君(解説スライド:三上) 1. 問題概要 2. 考察 3. 解法 4. アルゴリズム動作例 1 C問題 問題概要 • 辺に非負整数の重みがついたN頂点の木が与えられる． • 整数Xも与えられる． • aからbの単純パス上の辺の重みのxor和がXになるような (a,b)の組(a<b)の個数を求めよ． • 1≦N≦10^5 • 0≦X,辺のコスト≦10^9 2 C問題 考察 • 適当な頂点xを根に行ったdfsで，根からの経路の総和 xor を持っておくと嬉しい．なぜなら， パスa→bのxor値 = (a→xのxor 値) xor (x→bのxor 値) • が成り立つから． • 理由は a→x→bという経路の中で2回通る辺のコストは打 ち消し合うから 3 C問題 解法 • 適当な頂点からdfsを行い，根からの頂点iまでの単純パス のxor値x[i]が出現した回数をハッシュや平衡二分木(C++の map等)を用いて記録していく． • 各x[i]が出現した回数を加算する前に，X xor x[i] という値 が今までに出現した回数を答えに加算していけば良い． • 時間・空間計算量はハッシュを用いた場合 O(N) [コーナーケース] • X=0のとき，(x,x)を組として数えないように気をつけるこ と(求めるのはa<bとなる組の個数です)． • 32bit整数だとオーバーフローします． 4 C問題 コーナーケース • X=0のとき，(x,x)を組として数えないように気をつけるこ と(a<bとなる組の個数です) • 答えは32bit整数だとオーバーフローします． • 別解はいくつかあります – データ構造をマージする一般的なテク（平衡二分木を マージしていくとO(nlog^2n)の時間計算量等で達成可 能） – オイラーツアーを構築して列の問題に帰着させる（本 質的にはこのスライドで述べた方法と同じ） 5 みんな仲良し高橋君 解説スライド担当: 森田 晃平(@yosupot) 問題概要 • 点が2N+1個与えられる • x座標かy座標が同じ点はマッチング出来る • “この点以外の点で完全マッチングが作れる”かどう かを全ての点について判定 • N 㱡 100,000 考察 • 実は、連結成分のサイズが偶数ならば必ず完全マッ チングが作れる 考察 • マッチングを作っていく • もしどのマッチングにも含まれない点が2個以上存 在するならば、必ずマッチングが増やせることを証 明する 例 • 以下のグラフで考える 例 • まず使ってない点を2点選ぶ 例 • この2点間をつなぐパスを用意する • パスにそってマッチングしていない点を動かしていく 例 • パスにそってマッチングしていない点を動かしてい く 例 • 動かす先の点のマッチングが、矢印と並行な場合 例 • 動かす先の点のマッチングが、矢印と並行な場合 例 • 動かす先の点のマッチングが、矢印と垂直な場合 例 • 動かす先の点のマッチングが、矢印と垂直な場合 例 • 動かす先の点のマッチングが、矢印と並行な場合 例 • 動かす先の点のマッチングが、矢印と並行な場合 例 • これでマッチングしてない点同士を繋げられた 考察 • 連結成分のサイズが偶数ならば必ず完全マッチング が作れることがわかった • この問題は、点を消した時に偶数の連結成分だけが 残るような点を列挙する問題 考察 • 最初の状態で連結成分が1個だけの場合を考えれば よい • 奇数の連結成分が複数あったら全部NG • 偶数の連結成分はなかったものと考えて良い • 点を削除して連結成分が増える、かつ増えた連結成 分のうち点が奇数個のものがある場合のみNG 考察 • 点を削除した結果連結成分が増えるような点を関節 点と呼ぶ。これはO(V + E)で列挙可能(後述) • 消した結果出来た連結成分のサイズが奇数かどうか の判定も実はまとめてできる(後述) • ただ普通にグラフを作るとEは最悪θ(V^2)になる ので、減らさなくてはいけない 考察 • O(V^2)本の辺を全て張る必要はない • もし一つの点からたくさん辺が伸びている場合は、 4方向毎に2番目に近い点までのみに辺を貼ればよ い • これで辺の本数はO(V)、これであとはO(V+E)で関 節点列挙すれば良い 関節点列挙 • lowlinkという方法で列挙できます • dfs木を作り、頂点毎にordとlowというパラメー ターを計算する • ordはdfs木上での行きがけ順序 • lowは木の辺は降りることのみ可能、ただし後退 辺を最後に1度だけ登っても良い　という条件下 での到達可能な頂点の中でのordの最小値 関節点列挙 ord(行きがけ順序) 1 2 4 6 3 7 5 lowとは？？？ 1 2 4 6 3 7 5 lowとは？？？ 1 2 4 6 3 7 5 木の辺は降りることのみ可能 後退辺は最後に1度だけ登れる 到達可能な頂点の中でのordの最小値 lowとは？？？ 1,1 2 4 6 3 7 5 木の辺は降りることのみ可能 後退辺は1度だけ登れる 到達可能な頂点の中でのordの最小値 1から到達可能な頂点は？ • 当然全ての頂点 • 頂点1のlowは1 lowとは？？？ 1,1 2,2 4 6 3 7 5 木の辺は降りることのみ可能 後退辺は1度だけ登れる 到達可能な頂点の中でのordの最小値 2から到達可能な頂点は？ • 2,3,4,5 • 頂点2のlowは2 lowとは？？？ 1,1 2,2 4 6 3,3 7 5 木の辺は降りることのみ可能 後退辺は1度だけ登れる 到達可能な頂点の中でのordの最小値 3から到達可能な頂点は？ • 3 • 頂点3のlowは3 lowとは？？？ 1,1 2,2 4,2 6 3,3 7 5 木の辺は降りることのみ可能 後退辺は1度だけ登れる 到達可能な頂点の中でのordの最小値 4から到達可能な頂点は？ • 4,5,2 • 頂点4のlowは2 lowとは？？？ 1,1 2,2 4,2 6 3,3 7 5,2 木の辺は降りることのみ可能 後退辺は1度だけ登れる 到達可能な頂点の中でのordの最小値 5から到達可能な頂点は？ • 5,2 • 頂点5のlowは2 lowとは？？？ 1,1 2,2 4,2 6,1 3,3 7 5,2 木の辺は降りることのみ可能 後退辺は1度だけ登れる 到達可能な頂点の中でのordの最小値 6から到達可能な頂点は？ • 6,7,1 • 頂点6のlowは1 lowとは？？？ 1,1 2,2 4,2 6,1 3,3 7,1 5,2 木の辺は降りることのみ可能 後退辺は1度だけ登れる 到達可能な頂点の中でのordの最小値 7から到達可能な頂点は？ • 7,1 • 頂点7のlowは1 関節点列挙 • これがわかると何が嬉しいの？ • 実は、関節点であるかは以下の条件を満たすかで判 定できる • (根)次数が2以上 • (根以外, vとする)子uの中にlow[u] 㱢 ord[v]なる 頂点が存在する 関節点列挙 • これがわかると何が嬉しいの？ • 実は、関節点であるかは以下の条件を満たすかで判 定できる • (根)次数が2以上 • (根以外, vとする)子uの中にlow[u] 㱢 ord[v]なる 頂点が存在する これはdfs木の性質から明らか 関節点列挙 • これがわかると何が嬉しいの？ • 実は、関節点であるかは以下の条件を満たすかで判 定できる • (根)次数が2以上 • (根以外, vとする)子uの中にlow[u] 㱢 ord[v]なる 頂点が存在する こっちは？ 関節点列挙 • 関節点はdfs木上でどのような点になるか？ • 頂点が消された時にその頂点の子のなかに、分離し てしまうものがあるならば関節点 関節点列挙 この頂点について考える 関節点列挙 消してみる 関節点列挙 もしこの2つが分離したら関節点 関節点列挙 後退辺があったら分離しない 関節点列挙 こういう後退辺があっても分離しない 関節点列挙 こういう後退辺があっても分離しない 関節点列挙 v p u どういう後退辺があったら分離しないか？ uの部分木のどこかと、 pとpの親のうちどこかをつなぐような 後退辺 関節点列挙 v p u uから木を降りて、 後退辺を1回登ってpかpの親に行ければ よい どういう後退辺があったら分離しないか？ uの部分木のどこかと、 pとpの親のうちどこかをつなぐような 後退辺 関節点列挙 v p u uから木を降り後退辺を1回登っていける 頂点 このなかでもっとも上のものは？ uから木を降りて、 後退辺を1回登ってpかpの親に行ければ よい 関節点列挙 v p u → low(u)! uから木を降り後退辺を1回登っていける 頂点 このなかでもっとも上のものは？ uから木を降りて、 後退辺を1回登ってpかpの親に行ければ よい 関節点列挙 v p u つまり、low(u) < ord(v)か判定すれば良い 逆にlow(u) 㱢 ord(v)なる子があったら関節点 → low(u)! uから木を降り後退辺を1回登っていける 頂点 このなかでもっとも上のものは？ uから木を降りて、 後退辺を1回登ってpかpの親に行ければ よい 関節点列挙 • ordとlowは全頂点まとめてO(V+E)で計算可能 • この条件下で関節点とは以下の条件を満たす頂点 • (根)次数が2以上 • (根以外, vとする)子uの中にlow[u] 㱢 ord[v]なる頂点が存在する • これらもO(V+E)で計算可能 • さらに、これらを満たす子uのなかで(uの部分木のサイズ)が奇数にな るものがあったらNG • まとめてO(V+E) lowを求める方法 • 具体的にlowはどう求めればいいのか？ • 普通にdfsをする • 今頂点uにいて、辺(u, v)に注目してるとする • vをもう通ったならlow(u)=min(low(u), ord(v)) • 通って無いならlow(u)=min(low(u), low(v)) • これだけで求められる ARC044 解説 DEGwer A問題 「素数判定」 問題概要 • 整数N(1≦N≦10^9)が素数っぽいかどうか判 定せよ • Nは以下のいずれかの条件を満たす時素 数っぽい – 素数である – 合成数であり、かつ1の位が2でも5でも割り切れ ず、各桁の和が3で割り切れない 解法1 • 愚直に計算 • 素数判定にO( 𝑁) • 各桁の和を求めるのにO(log N) • あわせてO( 𝑁) 解法2 • 各桁の和とかは求めなくていい – Nの1の位が2でも5でも割り切れず、各桁の和が3 の倍数であることは、Nが2,3,5で割り切れないこ とと同値 • 実は素数判定も要らない – 2,3,5以外のNについて、Nが素数ならNは2,3,5で 割り切れない 解法2 • 以上をまとめると – N=1ならNot Prime(1は素数でも合成数でもない) – それ以外でN=2,3,5ならPrime – それ以外でNが2,3,5で割り切れるならNot Prime – それ以外ならPrime • と出力すればよい • O(1)で解けた B問題 「最短路問題」 問題概要 • 整数Nと整数列𝐴1, 𝐴2,…, 𝐴𝑁が与えられる • 頂点数Nですべての辺のコストが1の単純無 向グラフであって、任意のiに対して頂点1から 頂点iまでの距離が𝐴𝑖であるようなものの個 数をmod 10^9+7で求めよ • N ≦ 10^5 解法 • まず、自明に答えが0になる場合を取り除く – 𝐴1 ≠ 0だとだめ(頂点1から頂点1への距離は0) – 0が複数あってもだめ(頂点1から頂点1以外への 距離は正) 解法 • 2点間に辺を張れる条件は? – その2点の、 𝐴1からの距離の差が1以下 – 距離の差が2以上あると、その辺を使うことで最 短距離の性質に矛盾する • 2点間の距離が0の場合と1の場合に分けて 考える 解法 • 2点間の距離が0のとき辺はどう張ってもいい – 辺があろうがなかろうが最短距離は変わらない • 𝐴𝑖 = 𝐶なるiが𝐾𝑖個あるとき、距離Cの頂点の 間に辺を張る場合の数は2 𝐾𝑖 (𝐾𝑖−1) 2 通り • これは、N乗までの2冪をループで順にもとめ ていき、さらにそれらの掛け算で2の三角数乗 を順に求めていけばあわせてO(N)で求まる – 二分累乗ならO(Nlog N) 解法 • 2点間の距離が1のとき、その𝐴1からの距離を それぞれi, i+1とし、 𝐴1からの距離がiであるよ うな頂点の数をt, i+1であるような頂点の数をs とする • 距離i+1の頂点たちからは、1本以上の辺が 距離iの頂点のいずれかに張られていなけれ ばならない – 逆に、それ以外はどう張ってもよい 解法 • このような場合の数は(2 𝑡 − 1) 𝑠通り • これも2冪のテーブルをO(N)で前計算してお けば、合計O(N)で求まる – 頂点数の和はNよりこの操作にはO(s)かけられる – おなじく二分累乗ならO(Nlog N) • ということでこの問題が解けた C問題 「ビーム」 問題概要 • W*Hのグリッドに高橋君がいる • 1列全体、もしくは1行全体にQ回ビームが飛 んでくる • 高橋君は任意時刻にすきなだけ縦横に移動 できる • 全部よけるとき、高橋君の縦横への移動回数 の最小値は? • W,H,Q,ビームが飛んでくる時刻 ≦ 10^5 部分点解法(30点) • W,H,Q≦ 100 • 1 ≦ ビームが飛んでくる時刻(この最大値をT とする) ≦ 100 • DP[i][j][k]: 時刻iに、マス(j,k)にいるときの最 小の移動回数 として、DP配列を更新していく • 各iごとにdijkstra法などを用いてDP配列を順 次更新していくと、O(WHT log WH) 満点解法 • x座標、y座標は独立に考えられる(重要アイ デア) – ビームは一列、もしくは一行すべてに飛んできて、 高橋君の移動距離の定義もマンハッタン距離 • x座標、y座標独立に問題を解いて、あとで足 し合わせればいい • 以下x座標についてのみ考える 満点解法 • DP[i][j]: 時刻iに座標jにいるときの移動距離 の最小値 とする • これを愚直に計算するとO((W+H)T) • よく考えると、DP[i][j]たちとDP[i+1][j]たちは 「あまりかわらない」 – 具体的には、異なる箇所は時刻i+1に飛んでくる ビームの本数分のみ 満点解法 • 結局、DP配列を使いまわしてこれらが切り替 わる点のみ更新すれば、O(W+H+T)でこの問 題が解ける D問題 「suffix array」 問題概要 • 10^6項以下のpermutationが与えられる • このpermutationをsuffix arrayに持つ辞書順 最小の文字列を求めよ 解法 • 順列𝐴1, 𝐴2,…, 𝐴𝑁が文字列𝑆1𝑆2 … 𝑆𝑁のsuffix arrayである • ⇔すべての1≦i≦N-1に対し、 文字列 𝑆𝐴𝑖 𝑆𝐴𝑖+1 … 𝑆𝑁 < 𝑆𝐴𝑖+1 𝑆𝐴𝑖+1+1 … 𝑆𝑁 • ⇔すべての1≦i≦N-1に対し、 𝑆𝐴𝑖 < 𝑆𝐴𝑖+1ま たは、𝑆𝐴𝑖 = 𝑆𝐴𝑖+1かつ𝑆𝐴𝑖+1 … 𝑆𝑁 < 𝑆𝐴𝑖+1+1 … 𝑆𝑁 解法 • すべての1≦i≦N-1に対し、 𝑆𝐴𝑖 < 𝑆𝐴𝑖+1また は、𝑆𝐴𝑖 = 𝑆𝐴𝑖+1かつ 𝑆𝐴𝑖+1 … 𝑆𝑁 < 𝑆𝐴𝑖+1+1 … 𝑆𝑁 • ⇔すべての1≦i≦N-1に対し、 – 𝑆𝐴𝑖+1 … 𝑆𝑁 < 𝑆𝐴𝑖+1+1 … 𝑆𝑁ならば𝑆𝐴𝑖 ≦ 𝑆𝐴𝑖+1 – そうでないなら、 𝑆𝐴𝑖 < 𝑆𝐴𝑖+1 解法 • 𝑆𝐴𝑖+1 … 𝑆𝑁 < 𝑆𝐴𝑖+1+1 … 𝑆𝑁かどうかは、suffix arrayが持っている情報 • ということは、各iについて、 𝑆𝐴𝑖と𝑆𝐴𝑖+1の満た すべき関係がわかる • 前から順に見ていけば、文字列の各文字が 最も小さくて何であるかがすべてわかる 解法 • 逆に、suffix arrayを前から順に見ていき、この ような方法で各文字を決めていけば、そうし てできた文字列のsuffix arrayは元の順列に 一致することは簡単に示せる • よって、前から貪欲に文字を決めていけば、 O(N)でこの問題が解けた ARC043解説 A:平均点 A-問題概要 ● N個の得点 S[0], S[1], … が与えられる ● 平均が A, 最大と最小の差がBとなるように線形 変換せよ – 線形変換とはある実数P,QにたいしてXをPX+Qに する変換 A-考察 ● すべてをP倍すると – 平均　P倍される – 最大と最小の差　P倍される ● すべてにQ足すと – 平均　Q足される – 最大と最小の差　変わらない A-解法 ● 最大と最小の差がBになるように適切なPを探 す – その後すべてをP倍する ● 平均がAになるように適切なQを探す – その後すべてにQを足す ● すべての得点が適切に変換できている – O(N) A-具体的数式 ● 変換前の得点の平均をE,最大と最小の差をDと すると ● P = B / D ● Q = A – (EP) = A – (EB/D) A-注意点 ● 変換前の得点の平均をE,最大と最小の差をDと すると ● P = B / D ● Q = A – (EP) = A – (EB/D) A-割り算には要注意 ● 変換前の得点の平均をE,最大と最小の差をDと すると ● P = B / D ● Q = A – (EP) = A – (EB/D) ● D = 0のとき、つまり全得点が同じ時、適切なP が存在しない – コーナーケース ARC043解説 B:難易度 B-問題概要 ● 要素数 N の正数列が与えられる ● 次の条件をみたすように 4 つ要素を選ぶ方法の 通り数を求めよ – 2番目に小さい値は1番目に小さい値の 2 倍以上 – 3番目に小さい値は2番目に小さい値の 2 倍以上 – 4番目に小さい値は3番目に小さい値の 2 倍以上 ● MOD 1,000,000,0007 ● N ≦ 10^5 B-考察 ● 4つではなくて2つの場合はどうか？ – 2つのうち小さい方が X である場合の数 A[x] を求 めたい – 大きい方となれるのは 2X 以上の値 – よって A[x] は2X以上の値の数の個数 – 予めソートしていれば容易に求めることが出来る ● 二分探索 (最悪O(logN)) ● しゃくとり法 　(平均O(1)) B-考察 ● 4つではなくて2つの場合はどうか？ – 2つのうち大きい方が X である場合の数 B[x] を求 めたい – A[x]と全く同様の方法で求めることが出来る ● 二分探索 (最悪O(logN)) ● しゃくとり法 　(平均O(1)) B-部分点1 ● 2番目に小さい値 x と3番目に小さい値 y を全 通り試す – この2つが固定されている時、選び方の通り数は 2x ≦ y ならば B[x] × A[y] そうでないならば 0 – xとyの組は全部でO(N^2)ある ● 計算量は O(N^2) ● 部分点 (50点) 獲得 B-考察 ● 部分点解法は何か無駄がありそう – 以下のように言い換えることが出来る ● 2番目に小さい値 xを固定する – 2x ≦ yとなるすべてのyに対して B[x] × A[y] の総和をとる – 2x ≦ yとなるすべてのyに対するA[y]の総和を Asum[2x]とすると B[x] × Asum[2x] B-考察 ● Asum[2x]が高速で求まればO(N)で答えを求め ることが出来る ● Asumはsumの累積和なので、O(N)で全要素を 前計算することが出来る – Asum[max(y)] = sum[max(y)] – Asum[x] = Asum[x + 1] + Asum[x] B-満点解法 ● x ≦ y を満たすyに対する A[y]の総和 Asum[y]を 累積和で前計算する ● 2番目に小さい値 x を固定した時の場合の数は B[x] × Asum[y] ● すべての x に対して計算して総和を取る ARC043解説 C:転倒距離 C-問題概要 ● [1,2,..,N]を並び替えたものを「順列」という ● 2つの順列の「転倒距離」とは2つで順序が入 れ替わっている数字の組の個数である ● 2つの順列A,Bが与えられるので、どちらとも転 倒距離が等しい順列を1つ挙げよ ● N ≦ 10^5 C-考察1 ● A,Bの転倒距離をT(A,B)と書くとする ● T(A,C) = T(B,C)となるCがあるならばT(A,B)は 偶数 ● 数字の組について考えると – A,CでもB,Cでも逆 – A,Cで逆だがB,Cでは同じ – A,Cで同じだがB,Cでは逆 – A,CでもB,Cでも同じ ● それぞれx1, x2, x3, x4組ずつあったとする C-考察1 ● 逆逆:x1組　逆同x2組　同逆 x3組 同同 x4組 ● このとき以下が成り立つ – T(A, C) = x1 + x2 – T(B, C) = x1 + x3 – T(A, B) = x2 + x3 ● よって T(A, B) = T(A, C) + T(B, C) – 2*x1 ● T(A,C) = T(B,C)なのでT(A, B)は偶数 – (Q.E.D) C-考察1 ● T(A,C)=T(B,C)なるCがあるならばT(A,B)は偶数 対偶を取ると ● T(A,B)が奇数ならばT(A,C)＝T(B,C)なるCはな い – 今回の問題で言う-1を出力するパターン C-考察2 ● 数字の大小は転倒距離とは関係ないので、Aが [1,2,…,N]となるように数字を置換しても構わ ない ● 例 – A:[3, 1, 4, 2, 5], B:[2, 5, 1, 3, 4] – 3→1, 1→2, 4→2, 2→3, 5→5というふうに変換 – A:[1, 2, 3, 4, 5], B[3, 5, 2, 1, 2] C-考察2 ● Aが[1, 2, … ,N]になったのでBとの転倒距離が 計算しやすくなった – 各数字について、それ以左にあるそれ以上の数字の 個数を数えれば良い ● これはBの転倒数 – バブルソートにおける交換回数と一致することで有 名 – つまりBをバブルソートしていくと少しずつAとの 転倒距離が縮み、元のBとの転倒距離が伸びる C-部分点 ● あらかじめA,Bの転倒距離を求める – Tとする – Tが奇数なら-1を返す (∵ 考察1) ● A,Bとの転倒距離がおなじになるまでBをバブル ソートしていく – T/2回交換したら停止して出力 ● バブルソートの計算量はO(N^2) – N≦3000なので間に合う　部分点獲得 C-満点解法 ● バブルソートにおける「隣り合う2つの要素の 交換」をいちいちやらずに、いくつかまとめて 処理する ● バブルソートをダイジェストで見ると以下のよ うになる – [6, 1, 4, 2, 3, 5] – [1, 6, 4, 2, 3, 5] – [1, 2, 6, 4, 3, 5] – [1, 2, 3, 6, 4, 5] – [1, 2, 3, 4, 6, 5] – [1, 2, 3, 4, 5, 6] 1回交換 2回交換 2回交換 1回交換 1回交換 ↓これらの値がわかっていれば交換の操作を スキップできる 実はxを正しい位置まで 動かすときの交換回数 は、初めの数列におけ るx以左のxより大きい 値の個数と一致する C-考察 ● ある数列における x 以左のxより大きい値の個 数を高速に求める有名なデータ構造があった – BITやセグメントツリー ● 上記データ構造で以左に現れたかどうかのフラ グを管理しながら左から順番に走査する ● [3, 5, 4, 2, 6, 1]を例に実際に走査してみる C-考察 ● [3, 5, 4, 2, 6, 1] ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 0 0 0 0 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 C-考察 ● [3, 5, 4, 2, 6, 1] ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 0 0 0 0 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 0 確定 総和 = 0 C-考察 ● [3, 5, 4, 2, 6, 1] ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 0 1 0 0 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 0 更新 C-考察 ● [3, 5, 4, 2, 6, 1] 　 ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 0 1 0 0 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 0 0 確定 総和 = 0 C-考察 ● [3, 5, 4, 2, 6, 1] 　 ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 0 1 0 1 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 0 0 更新 C-考察 ● [3, 5, 4, 2, 6, 1] 　 ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 0 1 0 1 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 0 1 0 確定 総和 = 1 C-考察 ● [3, 5, 4, 2, 6, 1] 　 ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 0 1 1 1 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 0 1 0 更新 C-考察 ● [3, 5, 4, 2, 6, 1] 　 ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 0 1 1 1 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 3 0 1 0 確定 総和 = 3 C-考察 ● [3, 5, 4, 2, 6, 1] 　 ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 1 1 1 1 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 3 0 1 0 更新 C-考察 ● [3, 5, 4, 2, 6, 1] 　 ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 1 1 1 1 0 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 3 0 1 0 0 確定 総和 = 0 C-考察 ● [3, 5, 4, 2, 6, 1] 　 ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 1 1 1 1 1 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 3 0 1 0 0 更新 C-考察 ● [3, 5, 4, 2, 6, 1] 　 ↑　　　　 以左に現れたかどうかのフラグ 1 2 3 4 5 6 0 1 1 1 1 1 x以左に現れたxより大きい値の個数 1 2 3 4 5 6 5 3 0 1 0 0 確定 総和 = 5 C-満点解法 ● バブルソートにおける「隣り合う2つの要素の 交換」をいちいちやらずに、いくつかまとめて 処理する ● T/2回を超えないようにスキップしながらバブ ルソートをシミュレート – スキップするための値は先述のデータ構造が実装 ● スキップできなくなったら、交換回数がT/2に 達するまで普通にバブルソートをする – スキップがO(N)回の交換のまとめなので、たかだ かO(N)回で終了する ● 合計でO(NlogN)　満点獲得 ARC043解説 D:引っ越し D-問題概要 ● 数直線上で原点からの距離が1以上N以下の整 数である場所に空き家がある ● M世帯の家族を1つの家に複数の世帯が割り当 てられないように振り分ける – i番目の家族がA[i]に割り振られたとする ● i世帯目の家族の構成人数をP[i]とする ● (1 ≦ i, j ≦ M)を満たすすべての対(i, j)に対する |A[i] – A[j]| * P[i] * P[j]の総和が最大になるよう に割り振った時のその値を求めよ D-部分点解法 ● 全ての振り分けを試せば良い ● N≦10なのでN!通りの全探索が可能 ● 各振り分けの住民の距離の値はO(N^2)で求め ることが出来る ● O(N!×N^2) 10点獲得 D-考察 ● 式が全家族対についての総和なので計算がしづ らい – 式変形をして扱いやすくする D-式変形 ● |A[i] - A[j]| * P[i] * P[j] ● 空き家達を以下のように捉える D-式変形 ● |A[i] - A[j]| * P[i] * P[j] ● 空き家達を以下のように捉える – A[i]とA[j]の間には|A[i] – A[j]|個の「辺」がある D-式変形 ● |A[i] - A[j]| * P[i] * P[j] ● 空き家達を以下のように捉える – A[i]とA[j]の間には|A[i] – A[j]|個の「辺」がある – それぞれにP[i] * P[j] を足すと考えてみる D-式変形 ● 全家族対について、その間のすべての辺に家族 の人数の積を足す – 最後に全部の辺の総和をとれば求めたい値になる D-式変形 ● 一つの辺に注目してみる – それ以左にある全ての家族と、それ以右にあるすべ ての家族について1家族ずつ取ってきて対を作って 積を取ったものの総和である D-式変形 ● 一つの辺に注目してみる – これは「以左の総和」と「以右の総和」の積と一致 する D-式変形 ● 各「辺」について以左の人数の総和と以右の人 数の総和がわかっていれば、「辺」に足される 値が簡単に計算できる ● 「以左の総和」+「以右の総和」= 全人数 ということにも注意 D-式変形　整理 ● 各辺について、以左の総和と以右の総和の積を とる ● さらにその総和をとれば求めるもの ● i番目の家以左にいる人の総和を sum[i]、すべ ての家族を合わせた人数をAllとすると求める値 は – Σ sum[i] * (All - sum[i]) D-考察 ● 空き家の扱いがすこし面倒 – 家族に振り分けられる空き家と、そうでない空き家 がある ● 0人家族が沢山存在するとみなせば、すべての 家に1家族ずつ振り分けることが出来る – 0人家族はいくら追加しても結果にかかわらない – 並び替えの問題として扱うことが出来る D-帰着される問題 ● 正整数列A(1-index)が与えられる。総和はSum である。 ● S[i] = A[1] + A[2] + … + A[i] とする ● Aを並び替えたときの以下の値の最大値を求め よ Σ S[i] * (Sum - S[i]) D-定石 ● 最適な並び替えを求める問題の定石 – 隣り合う二つを交換した時どうなるか考える D-考察 ● 隣り合う二つの家族を交換したときどうなる か？ ● 以下のようにa人家族,b人家族が並んでいる時a とbを入れ替えるとどうなるか？ D-考察 ● 隣り合う二つの家族を交換したときどうなる か？ ● 以下のようにa人家族,b人家族が並んでいる時a とbを入れ替えるとどうなるか？ D-考察 ● aとbの間の辺のみ考えれば良い ● (L+a) × (b+R) が (L+b) × (a+R) ● 整理すると(R - L) × (b – a)だけ増える事がわか る D-考察 ● 以下のように a, b, cが並んでいたとする – さらに a < b, b > c を仮定する ● a,bを交換すると((R-L) +c)× (b - a)増える ● b,cを交換すると((L-R) +a) ×(b - c)増える D-考察 ● 以下のように a, b, cが並んでいたとする – さらに a < b, b > c を仮定する ● a,bを交換すると((R-L) +c)× (b - a)増える ● b,cを交換すると((L-R) +a) ×(b - c)増える ● 以下に注意 – a, c, b-a, b-cはすべて正である – (R-L)もしくは(L-R)の少なくとも一方が負ではない ● どちらかの交換は結果が悪化しない D-考察 ● a < b > c が成立している時、bはどちらか一方 と交換することが出来る – a < b > c となる部分を含まないような最適解が存 在する ● A[1] ≧ A[2] ≧ … ≧ A[i] ≦ A[i+1] ≦ … A[n] となるような最適解が存在する D-考察 ● A[1] ≧ A[2] ≧ … ≧ A[i] ≦ A[i+1] ≦ … A[n] ● このパターンの並び替えを探索する一般的なテ クニックがある ● DP[i][x] = Aの中で大きい方からi番目までを左 右に振り分けて、左側の総和がxのときの何ら かの値の最大(小)値 ● Aの中で大きい物から順番に左もしくは右に振 り分けていくイメージ D-考察 ● A[1] ≧ A[2] ≧ … ≧ A[i] ≦ A[i+1] ≦ … A[n] ● このパターンの並び替えを探索する一般的なテ クニックがある ● DP[i][x] = Aの中で大きい方からi番目までを左 右に振り分けて、左側の総和がxのときの何ら かの値の最大(小)値 ● Aの中で大きい物から順番に左もしくは右に振 り分けていくイメージ D-考察 ● A[1] ≧ A[2] ≧ … ≧ A[i] ≦ A[i+1] ≦ … A[n] ● このパターンの並び替えを探索する一般的なテ クニックがある ● DP[i][x] = Aの中で大きい方からi番目までを左 右に振り分けて、左側の総和がxのときの何ら かの値の最大(小)値 ● Aの中で大きい物から順番に左もしくは右に振 り分けていくイメージ どんな値？ D-帰着される問題（再掲） ● 正整数列A(1-index)が与えられる。総和はSum である。 ● S[i] = A[1] + A[2] + … + A[i] とする ● Aを並び替えたときの以下の値の最大値を求め よ Σ S[i] * (Sum - S[i]) D-帰着される問題（再掲） ● 正整数列A(1-index)が与えられる。総和はSum である。 ● S[i] = A[1] + A[2] + … + A[i] とする ● Aを並び替えたときの以下の値の最大値を求め よ Σ S[i] * (Sum - S[i]) D-満点解法 ● DP[i][x] = Aの大きい方からi番目までを左右に 振り分けて左側の総和がxで在るときのもう定 まってる S[i] * (Sum - S[i])の総和の最大値 D-満点解法 ● DP[i][x] = Aの大きい方からi番目までを左右に 振り分けて左側の総和がxで在るときのもう定 まってる S[i] * (Sum - S[i])の総和の最大値 – DP[i][x]は以下の様な全ての状態の中で「決まって いるS[i] * (Sum – S[i])の総和」の最大値 D-満点解法 ● DP[i][x] = Aの大きい方からi番目までを左右に 振り分けて左側の総和がxで在るときのもう定 まってる S[i] * (Sum - S[i])の総和の最大値 – DP[i][x]は以下の様な全ての状態の中で「決まって いるS[i] * (Sum - S[i])の総和」の最大値 D-満点解法 ● DP[N][0], DP[N][1], … ,DP[N][Sum] の中で最大 の物を探せば良い？ – 残念ながらNのオーダーは10^6なので間に合わな い D-満点解法 ● DP[N][0], DP[N][1], … ,DP[N][Sum] の中で最大 の物を探せば良い？ – 残念ながらNのオーダーは10^6なので間に合わな い ● 実はほとんどが0人家族である – A[1] ≧ A[2] ≧ … ≧ A[i] ≦ A[i+1] ≦ … A[n] この制約のために0人家族は真ん中のあたりに固 まっている – これらだけ別処理すれば良い – NがMまで減る（Mのオーダーは10^3) D-満点解法 ● 0人家族の別処理 D-満点解法 ● 0人家族の別処理 – 以下のように0人家族のあたりの辺には全く同じ値 が足される D-満点解法 ● 0人家族の別処理 – 以下のように0人家族のあたりの辺には全く同じ値 が足される – この値はxから求まるのでDP[m][x]ごとに別々に計 算してやればDP[n][x]に相当するものが求まる D-満点解法まとめ ● DP[i][x] = 大きいほうからi番目までで左の総和 がxになるように置いた時の値が決まっている 辺の総和の最大値 ● DP[m][x]まで求めて、0人家族の辺は別処理 – mのオーダーは10^3, xのオーダーは10^5なので配 列を普通に確保するとMLEしてしまう – I に関しては昇順に操作し、更新時 i – 1しか参照し ないのでメモリをリサイクルできる – 空間計算量はO(10^5) – 時間計算量はO(10^8) AtCoder Regular Contest 042 解説 2015/7/26 1 競技プログラミングを始める前に • 競技プログラミングをやったことがない人へ – まずはこっちのスライドを見よう！ – http://www.slideshare.net/chokudai/abc004 2015/7/26 2 ©AtCoder Inc. All rights reserved. 3 A問題 掲示板 1. 問題概要 2. 解法 2015/7/26 3 A問題 問題概要 • N個のスレッドがある掲示板がある • 書き込みがあるとそのスレッドが一番上になる • 書き込みがM個与えられるので、書き込み後のス レッドの順番を求めよ • 制約 1 ≦ N ≦ 105 , 1 ≦ M ≦ 105 • 部分点 1 ≦ N ≦ 100, 1 ≦ M ≦ 100 2015/7/26 4 A問題 解法 • 部分点解法 – 毎回の書き込みでスレッドの順番がどうなるかシミュレー ションする – O(NM) • 満点解法 – それぞれのスレッドの最後の書き込みの順でソートする – 書き込みがなかったスレッドについてはスレッドの番号が 小さい順にソートする – O(N log N + M) 2015/7/26 5 ©AtCoder Inc. All rights reserved. 6 B問題 アリの高橋くん 1. 問題概要 2. 解法 2015/7/26 6 B問題 問題概要 • 凸多角形とその内部の１点が与えられる • 凸多角形の外周と点との最短距離を求めよ • 制約 – 3 ≦ (凸多角形の頂点数) ≦ 10 – -100≦(座標)≦ 100 2015/7/26 7 B問題 解法 • 各辺と高橋くんとの距離の最小値を求めればよい • 線分と点の距離の求め方 – 線分上に垂線の足があるなら垂線の足との距離 – そうでなければ端点との距離 – 今回は垂線の足だけ考えればよい 2015/7/26 8 B問題 解法 • 直線と点の距離の求め方 – 直線上の1点が原点になるように平行移動 – もう1点がX軸の正の方向になるように回転 – 移動後の点のY座標の絶対値が答え 2015/7/26 9 O O A A A B B C C B C B問題 解法 • 複素平面を用いた方法 – 平行移動 ： 引き算 – 回転移動 ： 割り算して絶対値を掛ける 2015/7/26 10 O O A A A B B C C B C - A ÷B ×|AB| ©AtCoder Inc. All rights reserved. 11 C問題 おやつ 1. 問題概要 2. 解法 2015/7/26 11 C問題 問題概要 • 合計額の上限P,おやつの数N,値段ai ,満足度biの01 ナップサック問題 • ただし、選んだおやつのうち、どの1つのおやつがな かったとしてもP以下になるならOK • 満足度の和の最大値を求めよ • 制約 – 1 ≦ P ≦ 5,000, 1 ≦ N ≦ 5,000 – 1≦ ai≦ 100, 1≦ bi≦ 100 • 部分点 – 1 ≦ P ≦ 100, 1 ≦ N ≦ 100 2015/7/26 12 C問題 解法 • 部分点解法 – 選ぶおやつのなかで値段が一番安いものを決める – その値段以上のおやつでナップサック問題をDPで解く – 一番安いおやつの選び方がN通り、DPがO(PN) – 全体でO(PN2 ) • 満点解法 – 値段が高い順にソート – 部分点解法と同じようにDPをする – DPテーブルを使いまわせるので毎回のDPがO(P)となる – 全体でO(N log N + PN) 2015/7/26 13 ©AtCoder Inc. All rights reserved. 14 D問題 あまり 1. 問題概要 2. 解法 2015/7/26 14 D問題 問題概要 • X i (A≦i≦B) を P で割った余りの最小値を求めよ • 制約 – 1<=X<P<231, Pは素数 – 0<=A <=B<231 2015/7/26 15 D問題 解法 • 前提知識 – X i = Y (mod P)となるiを求める → 離散対数問題 • Baby-step giant-step algorithm – O(√P)で離散対数問題を解く X 0 → X 1 → X 2 → … →X √P Y 2015/7/26 16 X P- √P X √P X 0 : D問題 解法 • X i = 1, X i = 2, X i = 3, … を順番に解けばいい？ →答えが大きいとTLE • 答えが大きくなるのは試すi (= B-A+1)が少ない場合 ランダムなので悪質なケースは来ない B-A+1が小さいとき、答えは平均的にはP/(B-A+1) • B-A+1が小さいときは愚直に計算すればいい • Kで切り替えるとして、min(P/K * √P, K) • K=224くらいで間に合う 2015/7/26 17 ARC #041 解説 解説スライド担当 : @sugim48 問題 A – コインの反転 問題概要 • 表向きのコインが 𝑥 枚、裏向きのコインが 𝑦 枚ある。ちょうど 𝑘 枚の コインを選び、それらすべてをひっくり返す。その結果、表向きのコイ ンは最大で何枚になるか？ • 1 ≤ 𝑥, 𝑦 ≤ 106 ，1 ≤ 𝑘 ≤ 𝑥 + 𝑦 解法 1 • ひっくり返した結果、表向きのコインをできるだけ多くしたい。 • まずは裏向きのコインからひっくり返していき、𝑘 に満たなければ表 向きのコインもひっくり返していく。 • ちょうど 𝑘 = 𝑦 ならば、すべてのコインを表向きにできる。𝑘 ≠ 𝑦 なら ば、ズレの分だけ裏向きのコインが残る。 • 答えは 𝑥 + 𝑦 − |𝑘 − 𝑦| 解法 2 • 今回は 𝑥, 𝑦 ≤ 106 が小さいので、全探索ができる。 • （表向きのコインをひっくり返す枚数）+（裏向きのコインをひっくり返 す枚数）= 𝑘 である組を全通り試し、答えの最大値を求める。 問題 B – アメーバ 問題概要 • 縦 𝑁 マス、横 𝑀 マスの盤面があり、各マスにアメーバが何匹かず ついる。ただし、壁際にはいない。 • 各アメーバが 4 匹に分裂し、上下左右のマスへ 1 匹ずつ移動した。 • 今の盤面が与えられるので、はじめの盤面を 1 つ求めよ。ただし、 解は少なくとも 1 つ存在する。 • 3 ≤ 𝑁, 𝑀 ≤ 500 考察 • 次の例を考える。 0 1 2 0 1 5 5 2 3 5 5 4 0 3 4 0 0 0 0 0 0 ? ? 0 0 ? ? 0 0 0 0 0 考察 • ここに注目すると、このアメーバは下のマスから来たと断定できる。 0 1 2 0 1 5 5 2 3 5 5 4 0 3 4 0 0 0 0 0 0 ? ? 0 0 ? ? 0 0 0 0 0 考察 • よって、ここのアメーバの数が決まる。確定したアメーバの分は左の 盤面から引いておく。 0 0 2 0 0 5 4 2 3 4 5 4 0 3 4 0 0 0 0 0 0 1 ? 0 0 ? ? 0 0 0 0 0 考察 • ここに注目すると、このアメーバは下のマスから来たと断定できる。 0 0 2 0 0 5 4 2 3 4 5 4 0 3 4 0 0 0 0 0 0 1 ? 0 0 ? ? 0 0 0 0 0 考察 • よって、ここのアメーバの数が決まる。確定したアメーバの分は左の 盤面から引いておく。 0 0 0 0 0 3 4 0 3 4 3 4 0 3 4 0 0 0 0 0 0 1 2 0 0 ? ? 0 0 0 0 0 考察 • ここに注目すると、このアメーバは下のマスから来たと断定できる。 （上左右からの影響は差し引いてあるので） 0 0 0 0 0 3 4 0 3 4 3 4 0 3 4 0 0 0 0 0 0 1 2 0 0 ? ? 0 0 0 0 0 考察• 以下同様0 0 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0 0 0 0 1 2 0 0 3 ? 0 0 0 0 0 考察• 以下同様0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 3 4 0 0 0 0 0 解法 • 上の行から順に答えを埋めていく。解の存在が保証されているので、 矛盾なく答えが求まる。 • 計算量は O(𝑁𝑀) 問題 C – ウサギ跳び 問題概要 • 𝐿 個のマスが一列に並んでいて、その上に 𝑁 匹のウサギがいる。各 ウサギは左か右を向いている。 • 各ウサギは、自分の目の前が空きマスならば、ジャンプしてそのマ スへ移動できる。 • ウサギがジャンプする順番を決められるとき、ジャンプの総回数の最 大値を求めよ。 • 1 ≤ 𝑁 ≤ 105 ，𝑁 ≤ 𝐿 ≤ 109 考察 • 背中合わせのウサギたちは互いに影響しない。 • 例えば、次のような区間は別々に考えることができる。 考察 • 次のような区間は終了形が一通りに決まるので、ジャンプの総回数 を計算できる。 考察 • 次のような区間は終了形が複数通り考えられる。 考察 • ぶつかる位置を全通り試し、ジャンプの総回数の最大値を求める？ → 𝐿 ≤ 109 なので、最悪 109 通り試すことになり厳しい。 考察 • ジャンプの総回数を数えてみる。 3 回 4 回 5 回 考察 • ぶつかる位置が右に 1 マス動くと、ジャンプの総回数が 1 増える。 • 左側の 2 匹のジャンプ回数が 1 ずつ増え、右側の 1 匹のジャンプ 回数が 1 減るため。 • この例では、できるだけ右に寄せるのが最適。 考察 • 例から分かる通り、ウサギの少ない側に寄せるのが最適。 • 終了形が決まれば、ジャンプの総回数を計算できる。 解法 • ウサギたちを区間に分ける。 • 区間ごと別々に、ジャンプの総回数の最大値を計算する。 • その総和が答えである。ただし、オーバーフローに注意！ • 計算量は O(𝑁) 問題 D – 辺彩色 問題概要 • 𝑁 頂点 𝑀 辺の連結な無向グラフが与えられる。 • 好きな頂点から始め、好きなだけ辺を辿っていく。 • 辿った辺には 赤 → 青 → 赤 → 青 → … の順に色を塗る。ただし、色 は上書きされる。 • 目標の辺の配色は可能か判定せよ。 • 2 ≤ 𝑁 ≤ 2,000，1 ≤ 𝑀 ≤ 2,000 例 1 • 可能である。 例 2 • 可能である。ただし、上書きされる色は破線で示している。 例 3 • 不可能である。 考察 • まず、色が「上書きされる」というのがややこしい。 考察 • そこで、辺の辿り方を未来から過去へと逆向きに考えてみる。 • すると、「一度塗った色は上書きされない」というルールに変わる。 → この方が考えやすい！ 考察 • 未来から過去へと考え直すことによって、次のように問題を言い換え られる。 • 始点とはじめの色（赤 or 青）を好きに選び、好きなだけ辺を辿っていく。 • 辿った辺には赤青交互に色を塗る。ただし、色は上書きされない。 • 目標の辺の配色は可能か判定せよ。 • 見通しが良くなった！ 考察 • 𝑁, 𝑀 ≤ 2,000 と小さいので、始点とはじめの色は全探索できそう。 • 例えば、ここを始点に、青から始めてみる。 考察 • 次に塗る色と目標の色が一致していれば、その辺を塗ることができ る。 • 色は上書きされないので、一度塗った辺は自由に行き来できる。 考察 • 分かれ道はどう辿ればいいか？ 考察 • 分かれ道はどう辿ればいいか？ → 実は、どれを先に選んでも同じ。 考察 • 分かれ道の選び方が自由なので、深さ優先探索や幅優先探索など で貪欲に辺を塗っていける。 • すべての辺を塗れたら、目標の辺の配色ができたことになる。 想定誤解法 • 始点とはじめの色を全探索する。 • 深さ優先探索や幅優先探索で貪欲に辺を塗っていく。 • すべての辺を塗れたら、すぐ “Yes” と判定する。 • そうでなければ “No” と判定する。 → 重要なポイントを見落としている！ 考察 • 次の例は不可能に見えるが、実は可能である。 考察 • ここを始点に、青から始める。 考察 • 深さ優先探索や幅優先探索で次のように塗れる。 • 三角形の閉路ができたのがポイント。 考察 • 一見詰まったように見えるが、三角形の閉路を回ることで赤 / 青を 反転できる。 考察 • 再び三角形の閉路を回り、すべての辺を塗れた。 考察 • 奇数長の閉路を回るごとに赤 / 青を反転できる。 • よって、奇数長の閉路が完成すれば、あとはどんな塗り方も可能！ 解法 • 始点とはじめの色を全探索する。 • 深さ優先探索や幅優先探索で貪欲に辺を塗っていく。 • すべての辺を塗れたら、すぐ “Yes” と判定する。 • 奇数長の閉路が完成したら、すぐ “Yes” と判定する。 • そうでなければ “No” と判定する。 • 計算量は O(𝑁𝑀) AtCoder Regular Contest 040 解説 AtCoder株式会社 3/19/15 ARC 040 A問題 解説 「床塗り」 snuke 問題概要 N*N のマス⽬が⾚と⻘のインクで塗られている ⾚のマスが多いか、⻘のマスが多いか、同じかを判定せよ 1 ≦ N ≦ 100 解法 ʻRʼ の個数、ʼBʼ の個数をそれぞれ数え、⽐較する ⽂字列の扱いに慣れていると良いでしょう ARC 040 B問題 解説 「直線塗り」 snuke 問題概要 N 個のマスが直線状に並んでいる ⾼橋君は全てのマスを塗りたいと思っている いくつかのマスはすでに塗られている ⾼橋君はマス 1 からスタートする 1 秒の間に、 ・隣のマスに移動する ・右 R マスを塗る（マス i ~ マス i+R-1 までを塗る） 1 ≦ N ≦ 100 解法 まず、移動にかかる時間について考える 最も右にある ʻ.ʼ を塗ることができる場所まで進めば⼗分 で、それ以上進むメリットはない つまり、最も右にある ʻ.ʼ がマス i だとすると、 max(0, i-R) 回進めば⼗分 解法 次に、銃を撃つ回数について考える ・最も左にある ʼ.ʼ を探す（これをマス i だとする） ・マス i 〜 マス i+R-1 までを塗る を繰り返すのが最善となる 解法 移動にかかる時間と、銃を撃つのにかかる時間を⾜し合わせ てあげれば答えになります ARC 040 C問題 解説 「Z塗り」 snuke 問題概要 N*N のマス⽬があり、いくつかのマスは既に塗られている インク発射装置を使うと、Z字型の領域を塗ることができる すべてのマスを塗るためには装置を何回使えばいいか 1 ≦ N ≦ 100 解法 まだ塗られていないマスのうち、最も上にあるもののうち最 も右にあるものに注⽬する 図の◯のようなマス 解法 このとき、 ・◯のマスより上の⾏にあるマスと、 ・◯のマスと同じ⾏で◯のマスの右にあるマス は既に塗られているはず ここで、◯のマスを塗る⽅法について考えると、 Z字の右上の⾓を◯に合わせて塗る塗り⽅が他の塗り⽅より も真に良いことが分かります 解法 解法としては、 ・まだ塗られていないマスのうち右上のものを探す ・そのマスにZ字の右上の⾓を合わせるように塗る を繰り返し、全部のマスが塗られるまでに繰り返した回数を 答えれば良い ARC 040 D問題 解説 「カクカク塗り」 snuke 問題概要 マス⽬があり、いくつかのマスには障害物がある 「今いるマスを塗って隣のマスへ移動する」を繰り返す 移動するたびに90度向きを変えなければならない スタートのマスが決まっているとき、すべてのマスを塗るこ とが可能か判定せよ 1 ≦ N ≦ 50 部分点（40点） 1 ≦ N ≦ 50 マス⽬が少し⼩さい 部分点（40点） スタートの向き、ゴールの位置、ゴールの向きをすべて試す 例えば図のような状態を試す このとき全てのマスが塗れるかを判定したい 部分点（40点） 経路について考えたとき、あるマスに注⽬すると、そこから は上or下と左or右の2本の線が伸びるはず つまり、上下⽅向のどちらかちょうど⼀⽅に線が伸びている はず 上下⽅向の線だけ書いてしまおう 各列に注⽬すると、上下⽅向の線の書き⽅は⼀意に定まる 部分点（40点） そして、左右⽅向も同様に書く すると、経路ができあがる ただし、ここで出来上がった経路が正しいものかを判定しな いといけない（右の図のような例がある） 部分点（40点） 解法をまとめると、 スタートの向き、ゴールの位置、ゴールの向きをすべて試す 経路の線を書いて、それが正しいか判定する ゴールの位置の候補がN^2個、判定がO(N^2)なので、 計算量はO(N^4)となる 満点解法 1 ≦ N ≦ 400 マス⽬が⼤きい ゴール位置の候補を減らす 満点解法 スタート・ゴールの経路上の特徴を考える スタート・ゴールでは、上下⽅向 or 左右⽅向のどちらかに しか線が出ない つまり、上下⽅向 or 左右⽅向のどちらかの⽅向に対しては 障害物と同じような扱いになる 満点解法 上下⽅向（or 左右⽅向）に線を書き⼊れるとき、それぞれ の列には空きマスが偶数個なければいけない 奇数個だと端数が出てしまう ゴールは「上下⽅向 or 左右⽅向のどちらかの⽅向に対して は障害物と同じような扱いになる」マスなので、空きマスが 奇数個の列（or ⾏）になければならない つまり、ゴールの位置としては、空きマスが奇数個のある列 （or ⾏）のうちのどこかしか試さなくていい！ 満点解法 ゴールの位置の候補がN個、判定がO(N^2)なので、 計算量はO(N^3)となる AtCoder Regular Contest 039 解説 AtCoder株式会社 代表取締役 高橋 直大 競技プログラミングを始める前に • 競技プログラミングをやったことがない人へ – まずはこっちのスライドを見よう！ – http://www.slideshare.net/chokudai/abc004 ©AtCoder Inc. All rights reserved. 3 A問題 A - B Problem 解説スライド担当: 森田 晃平 A問題 問題概要 • 3桁の整数A, Bが与えられる • 1桁だけ書き換えることができる • A - Bを最大化せよ • ただし100の位を0に書き換えてはいけない 4 A問題 アルゴリズム • Aはできる限り大きくしたい • Aのどこかを書き換えるなら9にするべき • Bはできる限り小さくしたい • Bのどこかを書き換えるなら？ - 1, 10の位を書き換えるなら0にするべき - 100の位を書き換えるなら1にするべき 5 A問題 アルゴリズム • つまり書き換え方は6パターン - Aの1の位を9に - Aの10の位を9に - Aの100の位を9に - Bの1の位を0に - Bの10の位を0に - Bの100の位を1に 6 A問題 アルゴリズム 7 全部試す！ A問題 アルゴリズム • 文字列(10進数)⇔数字の相互変換が出来ると楽です 8 int a = 123; string a_str = to_string(a); a_str[0] = '9'; int new_a = stoi(a_str); printf("%d %d¥n ", a, new_a); //123 923 C++11による一例を載せておきます ©AtCoder Inc. All rights reserved. ‹#› B問題 高橋幼稚園 1. 問題概要 2. 考察 3. アルゴリズム 9 B問題 問題概要 • N人の児童にK個のキャンディを配る • 全体の幸福度=(各児童に与えられたキャンディの個数の 積) • 全体の幸福度が最大となるような配り方の総数を求めよ • ただし答えは大きいので，10^9+7で余りを取ること • 1≦N≦100, 1≦K≦500 10 B問題 考察 • 最大となるような配り方はどんなものか考える • 結論を言うと，N≦Kのとき，できるだけ均等に分けると最大 • たとえばN=4,K=10のとき順番を無視すれば， 3個 3個 2個 2個 • というふうに配ると最大． • したがって， – (N/Kを切り捨てた値)個は少なくとも全員に配れるので必ず 配る – 残りのN%K個を各児童に高々1つ分配する • という分配方法の総数を求める問題になる 11 B問題 考察 • 12 B問題 考察 • 13 B問題 アルゴリズム • 14 ©AtCoder Inc. All rights reserved. ‹#› C問題 幼稚園児高橋君 1. 問題概要 2. 考察 3. アルゴリズム 4. 参考 15 C問題 問題概要 • 16 C問題 考察 • 一度の直進動作には最悪O(K)かかる (左右に動き続けるケースを想定すると良い) • これだと最悪O(K^2)かかり，とても間に合わない • そこで，各格子のそれぞれ上下左右で最近傍の未訪問格子の 座標を記録しておき，逐次更新することを考える • 更新方法だが，ある格子を訪問したとき，その4近傍の格子の みについて最近傍の情報を書き換えれば良い • その情報に基づいてシミュレーションすれば即座に次の未訪問 格子に辿り着ける 17 C問題 考察 • イメージは以下の通り． • このような情報を全ての格子に持たせる 18 C問題 考察 • 格子を訪問済みにするときは， 訪問済みにした格子の近傍情報を利用して， 以下のように4近傍の格子の情報を張り替えればよい 19 C問題 考察 • 具体的には，訪問済みにする格子をxとすると – xの右格子の左格子=xの左格子 – xの左格子の右格子=xの右格子 – xの上格子の下格子=xの下格子 – xの下格子の上格子=xの上格子 というふうに張り替え (左格子,右格子,…という表記は全て未訪問のものを指す) 20 C問題 考察 • 実際に格子は無限大に広がっているので， 予め全格子について初期化しておくことはできない． • 情報を更新する必要が出てきたときに初めて近傍の情報を生 成する方針を取る(遅延評価) • 実際に訪問する格子はK個しかなく，訪問済み操作時も4近傍し か見ないので，情報が更新される格子はO(K)個 • 格子の近傍情報はハッシュや平衡二分探索木で管理する • これで一度の直進動作はO(1)もしくはO(log K)で行えるようにな った 21 C問題 アルゴリズム • 近傍情報更新の遅延評価の実装方法としては， – 既に更新しようとしている格子の近傍情報が生成されてる なら新しく生成せず，それを更新する – 生成されていないならば近傍情報を生成する • という場合分けを行うと良い． • あとは近傍情報を使ってシミュレーションする • 方向に対してインデックスを時計周りに定義するなどして，実装 を軽くする工夫をしましょう！ • ハッシュマップまたは平衡二分探索木を使えば，全体の計算量 は O(K) もしくは O(K log K) となる 22 C問題 参考 • このような4近傍の情報を持つデータ構造はDancingLinksと呼 ばれています．興味がある人は調べてみてください． 23 ©AtCoder Inc. All rights reserved. D問題 旅行会社高橋君 24 解説スライド担当: 森田 晃平 D問題 問題概要 • N頂点M辺の無向グラフが与えられる • Q個クエリが飛んでくるので処理する - 頂点A, B, Cが与えられる - A -> B -> C と経由するトレイルがあるか判定 • 制約 - 1 <= N <= 100,000 - 1 <= M <= 200,000 - 1 <= Q <= 100,000 25 D問題 アルゴリズム この問題を解くには”二重辺連結成分分解”というアルゴリ ズムを使用する 26 D問題 アルゴリズム 二重辺連結成分分解とは？ 無向グラフを二重辺連結成分に分解するアルゴリズム 二重辺連結成分とは？ 橋を含まない連結な無向グラフの事を二重辺連結成分と呼ぶ 橋とは？ 辺(u, v)について、その辺を取り除くと(u, v)が連結ではなくなってし まう時その辺の事を橋と呼ぶ 27 D問題 アルゴリズム 28 橋と二重辺連結成分の例 D問題 アルゴリズム Gが二重辺連結成分の時、Gの任意の2頂点s, tについて s, tを結ぶ、辺を共有しない2本のパス(辺素パス)が存在する これはGの任意の2頂点s, tについて、s -> t へとフローが2以 上流せるとも考えられる ただし辺は全て容量1の無向辺として考える 29 s t D問題 アルゴリズム Gは連結なので明らかにフローが1は流せる Gに橋がなければフローが2以上流せる事を示したい 30 D問題 アルゴリズム 最大フロー最小カット定理を使う 仮に最大フローが1だとすると、S, T間に辺が1本だけ架かっているs-tカットが存在する 事になる その1本の辺を取り除くと、 SとTが非連結になってしまうため 明らかに橋 よって最大フローが1なら橋が存在する -> Gに橋がなければ必ずフローが2以上流せる -> Gが二重辺連結成分なら必ずフローが2以上流せる 31 D問題 アルゴリズム s, tを結ぶ、辺を共有しない2本のパス(辺素パス)が必ず存在 する事がわかった 更に、任意の3頂点 s, t1, t2 について辺を共有しない s - t1 パ スと s - t2パスが存在する事も言える 32 s t1 t2 D問題 アルゴリズム これは、新しい頂点xを用意して x-t1, x-t2という辺を貼ると 、s - x 間に2本の辺素パスがある事からわかる 33 s t1 t2 s t1 t2 x s t1 t2 x s t1 t2 D問題 アルゴリズム よって、A, B, C が同じ二重辺連結成分にある場合、クエリの 答えは OK じゃあ違う場合はどうする？ 34 D問題 アルゴリズム まず二重辺連結成分分解をして、二重辺連結成分を全部検出 する 二重辺連結成分分解は、グラフの橋を全部検出して取り除け ば残ったものが全て二重連結成分 ここで、元のグラフで二重辺連結成分を縮約して1つの頂点 にしてしまうと、橋だけが辺として残り、グラフは木になる 35 D問題 アルゴリズム 36 D問題 アルゴリズム 37 α β γ D問題 アルゴリズム こうして生まれた木においてA, B, Cを含む頂点をそれぞれX, Y, Zとすると、パス X - Z 上にYが存在するかどうかがクエリ の答えになる 38 X Y Z この辺を2回使ってしまう Y X Z A B C よさそう D問題 アルゴリズム パス X - Z 上にYが存在するかどうかは dist(X, Z) == dist(X, Y) + dist(Y, Z) で判定できる ただしdist(a, b)は木でのパス a - b の長さ distは適当な頂点を根にしておけば、 dist(a, b) = depth(a) + depth(b) - 2*depth(lca(a, b)) で計算できる 39 D問題 橋の列挙法 以上より二重辺連結成分分解ができればこの問題が解ける事 がわかった そして橋の列挙ができれば二重辺連結成分分解が出来る じゃあどうやって橋を列挙するのか？ lowlinkというものを使用するアルゴリズムがあります 今回はimos法でやる方法を紹介します 40 D問題 橋の列挙法 まずはdfs木を構築し、辺を木に使われる辺と後退辺に分類 します 41 D問題 橋の列挙法 後退辺ごとに、対応するパス上の辺を塗る 42 これで塗られなかった辺が橋 D問題 橋の列挙法 塗るのは愚直にやればO(NM)ぐらいだが, imos法でO(N+M)に できる 43 +1 +1 +1 -1 -1 -1 D問題 44 お疲れ様でした！ AtCoder Regular Contest 038 解説 AtCoder株式会社 2015/5/2 1 はじめに 今回の問題は４問とも（２⼈）ゲーム系の問題でした ゲーム系の問題は⼤体、以下いずれかで解くことが出来ます ・後ろから探索する ・Grundy数を求める ・adhoc（≒独特な）な必勝法を⾒つける ARC 038 A問題 解説 「カードと兄妹」 snuke 問題概要 カードが N 枚あり、カード i には整数 A[i] が書かれている ２⼈で交互に１枚ずつ取っていく 取ったカードに書かれた数の和がスコアとなる ２⼈とも⾃分のスコアを最⼤化しようとするとき、 先⼿のスコアはいくらになるか？ 〜制約〜 1 ≦ N ≦ 1000 考察 各ターンではプレイヤーはどのカードを取ればいいか？ → 残っているカードのうち書かれている数が最⼤のもの！ 解法 A[1~N] を降順にソートしておく A[1]+A[3]+A[5]+…を求める タイプ A 問題は、分類するほど複雑なゲームではありませんが、 あえて⾔うならば３つ⽬のタイプでしょうか ・後ろから探索する ・Grundy数を求める ・adhocな必勝法を⾒つける ARC 038 B問題 解説 「マス⽬と駒」 snuke 問題概要 H×Wのマス⽬があり、いくつかのマスには障害物がある 最初、駒を左上のマスにおき、２⼈で交互に動かす 動かす先は、１つ下・１つ右下・１つ右のいずれかのマス 障害物のあるマスや、盤外に駒を動かすことはできない 駒を動かせなくなった⽅の負け 先⼿と後⼿のどちらが勝つか？ 〜制約〜 2 ≦ H,W ≦ 100 部分点（30点）- 制約 2 ≦ H,W ≦ 4 盤がとても⼩さい 部分点（30点）- 解法 全探索をする judge(1,1)が答えとなる （盤外と障害物を2⾏⽬のように処理すると実装が楽になります） judge(i,	j):	#	(i,j)に駒がある状態から開始したときの勝敗 		if	(i,j)	が盤外	or	障害物:	return	勝ち 		if	judge(i+1,j)	==	負け:	return	勝ち 		if	judge(i+1,j+1)	==	負け:	return	勝ち 		if	judge(i,j+1)	==	負け:	return	勝ち 		return	負け 部分点（30点）- 計算量 O(分岐数^再帰の深さ) で抑えられる 再帰の深さは⾼々 6 （盤⾯が4x4以下だから）で、 各ステップでは⾼々 3 通りにしか分岐しないため、 この部分点では間に合う 満点 - 制約 2 ≦ H,W ≦ 100 盤が⼤きい 満点 - 解法 メモ化再帰にする mem[1000][1000]	を「未定」で初期化 judge(i,	j):	#	(i,j)に駒がある状態から開始したときの勝敗 		if	(i,j)	が盤外	or	障害物:	return	勝ち 		if	mem[i][j]	!=	未定:	return	mem[i][j]	 		result	=	負け 		if	judge(i+1,j)	==	負け:	result	=	勝ち 		if	judge(i+1,j+1)	==	負け:	result	=	勝ち 		if	judge(i,j+1)	==	負け:	result	=	勝ち 		return	mem[i][j]	=	result 満点 - 計算量 再帰呼び出しの回数を O(HW) で抑えることができる 計算量も O(HW) となり、間に合う タイプ B 問題は、１つ⽬のタイプでしょうか ・後ろから探索する ・Grundy数を求める ・adhocな必勝法を⾒つける ソースコードの⾒た⽬は前から探索しているように⾒えます が、実際に勝敗が確定していくのは後ろの状態からなので、 「後ろから探索する」ということにしています ARC 038 C問題 解説 「茶碗と⾖」 snuke 問題概要 N 個の茶碗があり、茶碗 i には整数C[i]が書かれている 茶碗 i には A[i] 個の⾖が⼊っている ２⼈で交互に、茶碗 0 以外から⾖を 1 つ選んで移動させていく 茶碗 i から選んだ場合は 茶碗 i-C[i] 〜茶碗 i-1 のどれかに移す ⾖を選べなくなった⽅の負け 先⼿と後⼿のどちらが勝つか？ 〜制約〜 2 ≦ N ≦ 10^5 0 ≦ A[i] ≦ 10^9 部分点１（60点）- 制約 2 ≦ N ≦ 100 0 ≦ A[i] ≦ 10 茶碗も⾖も少ない 部分点１（60点）- 解法 grundy数を求める Grundy数 grundy数とは なにやら複雑そうなので、例を出して計算してみます ある状態から 1 回の遷移で⾏ける状態の grundy数の集合に含まれない最⼩の⾮負整数 Grundy数 ⾖が１つだけのときを考えます 椀 1 2 1 2 4 3 ⾖ grundy数 ？ ？ ？ ？ ？ ？ ？ ０ １ ２ ３ ４ ５ ６ Grundy数 椀０に１つ⾖がある状態のgrundy数を求めます ⾖を移す操作がこれ以上できないため、 遷移先のgrundy数の集合は {}（空集合）となります 集合に含まれない最⼩の０以上の整数は０なので、 この状態のgrundy数は０となります 椀 1 2 1 2 4 3 ⾖ grundy数 ０ ？ ？ ？ ？ ？ ？ ０ １ ２ ３ ４ ５ ６ 椀１に１つ⾖がある状態のgrundy数を求めます 椀１からは椀０に⾖を移せるため、 遷移先のgrundy数の集合は {０} となります 集合に含まれない最⼩の０以上の整数は１なので、 この状態のgrundy数は１となります Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ？ ？ ？ ？ ？ ０ １ ２ ３ ４ ５ ６ 椀２に１つ⾖がある状態のgrundy数を求めます 椀２からは椀０と椀１に⾖を移せるため、 遷移先のgrundy数の集合は {０,１} となります 集合に含まれない最⼩の０以上の整数は２なので、 この状態のgrundy数は２となります Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ２ ？ ？ ？ ？ ０ １ ２ ３ ４ ５ ６ 椀３に１つ⾖がある状態のgrundy数を求めます 椀３からは椀２に⾖を移せるため、 遷移先のgrundy数の集合は {２} となります 集合に含まれない最⼩の０以上の整数は０なので、 この状態のgrundy数は０となります Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ２ ０ ？ ？ ？ ０ １ ２ ３ ４ ５ ６ 椀４に１つ⾖がある状態のgrundy数を求めます 椀４からは椀２と椀３に⾖を移せるため、 遷移先のgrundy数の集合は {２,０} となります 集合に含まれない最⼩の０以上の整数は１なので、 この状態のgrundy数は１となります Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ２ ０ １ ？ ？ ０ １ ２ ３ ４ ５ ６ 椀５に１つ⾖がある状態のgrundy数を求めます 椀５からは椀１と椀２と椀３と椀４に⾖を移せるため、 遷移先のgrundy数の集合は {０,１,２} となります 集合に含まれない最⼩の０以上の整数は３なので、 この状態のgrundy数は３となります Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ２ ０ １ ３ ？ ０ １ ２ ３ ４ ５ ６ 椀６に１つ⾖がある状態のgrundy数を求めます 椀６からは椀３と椀４と椀５に⾖を移せるため、 遷移先のgrundy数の集合は {０,１,３} となります 集合に含まれない最⼩の０以上の整数は２なので、 この状態のgrundy数は２となります Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ２ ０ １ ３ ２ ０ １ ２ ３ ４ ５ ６ このようにしてgrundy数を求めることができます Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ２ ０ １ ３ ２ ０ １ ２ ３ ４ ５ ６ ⾖が２つ以上ある場合はどうすればいいでしょうか Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ２ ０ １ ３ ２ ０ １ ２ ３ ４ ５ ６ 定義どおりに状態の遷移を考えていけば、 grundy数を求めることができます しかし、実はそのようなことをしなくても求められます Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ２ ０ １ ３ ２ ０ １ ２ ３ ４ ５ ６ ・椀１に１つ⾖がある状態のgrundy数：１ ・椀３に１つ⾖がある状態のgrundy数：０ ・椀６に１つ⾖がある状態のgrundy数：２ これらの xor の値がこの状態のgrundy数となっています つまり、１xor０xor２=３がこの状態のgrundy数です Grundy数 椀 1 2 1 2 4 3 ⾖ grundy数 ０ １ ２ ０ １ ３ ２ ０ １ ２ ３ ４ ５ ６ Grundy数 grundy数を求めると何が嬉しいのでしょうか？ ・grundy数が０でない状態からは、  必ずgrundy数が０の状態に遷移できる ・grundy数が０の状態からは、  grundy数が０の状態に遷移できない という性質から、あるゲームの状態のgrundy数が ・０でないならば先⼿の勝ち ・０ならば後⼿の勝ち ということが⾔えるのです 部分点１（60点）- 解法 「椀 i に１つ⾖がある状態のgrundy数」を  i = 0 から順に i = N-1 まで求めて、 各⾖についてのgrundy数のxorを求める この値が１ならば先⼿の勝ちで、０ならば後⼿の勝ち 部分点１（60点）- 解法 「椀 i に１つ⾖がある状態のgrundy数」＝ g[i] とする g[i] を求めるときには、 ・g[i-C[i]]〜g[i-1] に含まれない最⼩の０以上の整数 を求める必要があります → 「０が含まれるか」「１が含まれるか」・・・ を順番に調べていけば O(N^2) で求めることができます 「x が含まれるか」を調べるときに適切なデータ構造（例え ばsetなど）を⽤いることで、O(N log N)やO(N)にできます 部分点１（60点）- 計算量 g[i] を求めるのに O(N^2) かけたとすると、 すべての g[i] を求める計算量は O(N^3) また、⾖の個数は最⼤で max(A[i])*(N-1) 個なので、 grundy数のxorをとる計算量は O(max(A[i])*N) となり、この部分点では間に合います 部分点２（40点）- 制約 2 ≦ N ≦ 100 0 ≦ A[i] ≦ 10^9 茶碗は少ないが、⾖は多い 部分点２（40点）- 解法 部分点解法１の解法だと、 すべての g[i] を求める計算量は O(N^3) なので問題ないですが、 grundy数のxorをとる計算量は O(max(A[i])*N) なので間に合いません 部分点２（40点）- 解法 xorの性質として、 ・同じ数の xor は 0 というものがあります 例えば、3 xor 3 = 0 で、 99 xor 99 = 0 です 部分点２（40点）- 解法 grundy数のxorをとるとき、 同じ数のxorを⼤量にとっています 例えば A[i] = 5 のとき、 ・g[i] xor g[i] xor g[i] xor g[i] xor g[i] という計算をしていますが、これは、 ・g[i] xor g[i] xor g[i] や、 ・g[i] と同じです このように同じ数を２つずつ相殺させることを考えます 部分点２（40点）- 解法 つまり、A[i] がどのような数であろうと、 勝敗には A[i] の偶奇しか関係ないのです 部分点２（40点）- 計算量 grundy数のxorをとる計算量は、 A[i] が奇数であるような所の g[i] のxorをとるだけなので O(N) で良いことになり、 この部分点は間に合います 満点（おまけ）- 制約 2 ≦ N ≦ 10^5 0 ≦ A[i] ≦ 10^9 茶碗も多い 上級者向けのおまけの制約です 満点（おまけ）- 解法 g[i] をもっと⾼速に求めなければなりません g[i] は、 ・g[i-C[i]]〜g[i-1] に含まれない最⼩の０以上の整数 でした 満点（おまけ）- 解法 「g[k]~g[i-1] に l~r がすべて含まれるような最⼩のk」 という情報を持ったsegtreeを更新しつつg[i]を求めていく （各グランディー数について、⼀番最後に現れた位置を持つイメージ） このsegtreeで⼆分探索を⾏うことにより、 O(log N) で g[i] を求めることができます 計算量は O(N log N) となり、間に合います タイプ C 問題は、２つ⽬のタイプでしょうか ・後ろから探索する ・Grundy数を求める ・adhocな必勝法を⾒つける ARC 038 D問題 解説 「有向グラフと数」 snuke 問題概要 N 頂点 M 辺の有向グラフがある 頂点 i には整数 X[i] が書かれている 最初、頂点１に駒を置き、２⼈で交互に辺に沿って動かす 駒を動かす代わりに「終了宣⾔」をすることもできる 終了宣⾔がされるか、後⼿が10^9回駒を動かした時点で ゲームが終了し、そのときに駒のある頂点に書かれている整 数がゲームのスコアとなる 先⼿がスコアを最⼤化しようとし、後⼿がスコアを最⼩化し ようとするとき、ゲームのスコアはいくつになるか？ 部分点（30点）- 制約 2 ≦ N ≦ 1000 1 ≦ M ≦ 2000 グラフが⼩さい 部分点（30点）- 解法 ターン数が 10^9 でも 10^9 - 1 でも結果は変わらない ターン数がいくら⼤きくても、結局堂々巡りになり、 先⼿がどこかで妥協しなければならない もっというと、ターン数は 2N ターンまででも変わらない ゲームの状態は [駒がある頂点] と [⼿番] で決まり、 同じ状態に２回訪れるということは、堂々巡りになるという ことなので意味がない 部分点（30点）- 解法 [ターン][駒がある頂点][⼿番] という状態を考えて、 それぞれの状態からの結果を求める ⼿番が先⼿の時は、遷移先の状態の結果のうち最⼤を選び、 ⼿番が後⼿の時は、遷移先の状態の結果のうち最⼩を選ぶ というメモ化再帰探索をする （min-max法 と呼ばれる⼿法です） 部分点（30点）- 計算量 状態数が O(ターン数 * 頂点数) 遷移数が O(ターン数 * 辺数) となっているため、計算量は O (N*(N+M)) となり、 この部分点では間に合う 満点 - 制約 2 ≦ N ≦ 100,000 1 ≦ M ≦ 200,000 グラフが⼤きい 満点 - 解法 ・スコアを x 以上にすれば先⼿の勝ち ・スコアを x 未満にすれば後⼿の勝ち というゲームの結果を計算できたとする x が⼩さければ⼩さいほど先⼿が勝ちやすく、 x が⼤きければ⼤きいほど先⼿が勝ちにくいため、 x の値で⼆分探索ができる 満点 - 解法 ・スコアを x 以上にすれば先⼿の勝ち ・スコアを x 未満にすれば後⼿の勝ち というゲームは、 書かれている数が x 以上の頂点を⻘く塗り、 書かれている数が x 未満の頂点を⽩く塗ったと思えば、 ・⻘い頂点で終了すれば先⼿の勝ち ・⽩い頂点で終了すれば後⼿の勝ち というゲームになる 満点 - 解法 ・⿊い頂点で終了すれば先⼿の勝ち ・⽩い頂点で終了すれば後⼿の勝ち というゲームの結果を計算できれば良くなった 満点 - 解法 状態が [駒のある頂点][⼿番] の状態遷移図を考える 元のグラフ ２ ３ １ ４ 状態遷移図 １先 ２先 ３先 ４先 ２後 １後 ４後 ３後 満点 - 解法 状態遷移図の頂点の⾊を ⿊：⼿番プレイヤーの勝ち 灰：未定 ⽩：⼿番プレイヤーの負け とします １先 ２先 ３先 ４先 ２後 １後 ４後 ３後 満点 - 解法 最初はこうなっています １先 ２先 ３先 ４先 ２後 １後 ４後 ３後 満点 - 解法 これを、 ・遷移先に⽩があれば⿊にする ・遷移先が全て⿊なら⽩にする というルールにそって、 ⾊付けしていきます １先 ２先 ３先 ４先 ２後 １後 ４後 ３後 満点 - 解法 これを、 ・遷移先に⽩があれば⿊にする ・遷移先が全て⿊なら⽩にする というルールにそって、 ⾊付けしていきます １先 ２先 ３先 ４先 ２後 １後 ４後 ３後 満点 - 解法 これを、 ・遷移先に⽩があれば⿊にする ・遷移先が全て⿊なら⽩にする というルールにそって、 ⾊付けしていきます １先 ２先 ３先 ４先 ２後 １後 ４後 ３後 満点 - 解法 これを、 ・遷移先に⽩があれば⿊にする ・遷移先が全て⿊なら⽩にする というルールにそって、 ⾊付けしていきます １先 ２先 ３先 ４先 ２後 １後 ４後 ３後 満点 - 解法 このルールで塗って⾏ったときに、最終的に ⿊の頂点：勝ち ⽩の頂点：負け 灰の頂点：引き分け となります （灰の頂点の場合は堂々巡りになります） １先 ２先 ３先 ４先 ２後 １後 ４後 ３後 満点 - 解法 灰の頂点は例えば以下のような状況で出てきます 灰の頂点のサイクルができており、 これ以上ルールを適⽤できません １先 ２先 ３先 ４先 ２後 １後 ４後 ３後 満点 - 解法 このような⾊塗りの⼿順は、BFSの要領で⾏えばよいです 「遷移先が全て⿊」というのは、 「遷移先の⿊の個数が出次数と等しい」と考えて実装します このような⼿法で勝敗を判定するアルゴリズムを 後退解析 と呼ぶそうです どうぶつしょうぎの解析などにも使われている⼿法です 満点 - 計算量 計算量は、⼆分探索＋後退解析で O((N+M) log max(X)) となり間に合います タイプ D 問題は、１つ⽬のタイプでしょうか ・後ろから探索する ・Grundy数を求める ・adhocな必勝法を⾒つける AtCoder Regular Contest 037 解説 AtCoder株式会社 代表取締役 高橋 直大 3/19/15 競技プログラミングを始める前に • 競技プログラミングをやったことがない人へ – まずはこっちのスライドを見よう！ – http://www.slideshare.net/chokudai/abc004 3/19/15 ©AtCoder Inc. All rights reserved. A問題　全優 1.問題概要 2.アルゴリズム 3/19/15 A問題　問題概要 • N科目の試験を受ける • 勉強しなければ科目 i では mi 点を取る • 1分間勉強することで1つの科目の得点を • 1点上げられる • 全科目で80点以上を取るには • 何分の勉強が必要？ • (科目数) ≦ 25, 1 ≦ mi ≦ 100 3/19/15 A問題　アルゴリズム • mi が80未満の科目は 80 - mi 分勉強する • 必要がある • mi が80以上の科目の勉強時間は 0 分でよい • 全科目についてこれを合計したものが答え • 各科目の勉強時間を max(0, 80 – mi) と • 書くこともできる 3/19/15 ©AtCoder Inc. All rights reserved. B問題　バウムテスト 1.問題概要 2.アルゴリズム 3/19/15 B問題　問題概要 • N頂点M辺の無向グラフが与えられる • このグラフの連結成分のうち木であるもの • （閉路がないもの）の個数を求めよ • N ≦ 100, M ≦ N(N-1)/2 3/19/15 B問題　アルゴリズム • 複数の異なる方針のうち１つを紹介する • とりあえず連結成分を列挙する必要がある • 「まだ見ていない頂点を選んでそこからDFS • （深さ優先探索）をする」のを繰り返すとよい • こうして連結成分を得るついでに • 閉路がないか判定する 3/19/15 B問題　アルゴリズム • DFSをする上で、無限ループを防ぐために • 「すでに訪れた」頂点をマークしていき、 • 二度訪れないようにするが… • 連結成分に閉路がなければ「すでに訪れた • 頂点にまた訪れようとする」ということが • 起こらないので、これで木の判別が可能 • （DFSで直前に訪れた頂点を覚えて • おかないと、誤検知してしまうので注意） 3/19/15 ©AtCoder Inc. All rights reserved. C問題　壁抜け 1.問題概要 2.アルゴリズム 3/19/15 C問題　問題概要 • N^2 ます計算（掛け算）をする • N^2 個の計算結果を昇順に • ソートしたとき、小さい方から • K番目にくる値は？ • N ≦ 30000 • (行、列の値) ≦ 10^9 3/19/15 C問題　アルゴリズム (部分点) • 5点: N ≦ 10 • １００マス計算 • 全部計算してソートできる 3/19/15 C問題　アルゴリズム (満点) • 100点: N ≦ 30000 • 9億マス計算 • 全部計算するとメモリが足りない、 • もし足りてもソートは確実に間に合わない • なんとかして K 番目の値「だけ」を求めたい 3/19/15 C問題　アルゴリズム (満点) • そもそも「小さい方からK番目の値がXである」 • とはどういうことか？ • ずばり「X-1以下の数はK個未満しかないが、  X以下の数はK個以上ある」ということ  1,1,2,2,2,2,2,4,4  小さい方から7番目は2  1以下の数は ２個 < 7個  2以下の数は 7個 3/19/15 C問題　アルゴリズム (満点) • 「X-1以下の数はK個未満しかないが、  X以下の数はK個以上ある」  別の言い方では  「X以下の数がK個以上あるような最小のX」  が小さい方からK番目の数  二分探索が使える 3/19/15 C問題　アルゴリズム (満点) • 「Xを決めたとき、X以下の数は • K個以上あるか？」という問題を繰り返し • 解くことになる  実際に数えてK個以上か確かめればよい  どうやって数えるか？ 3/19/15 C問題　アルゴリズム (満点) • 各行を一つずつ見ていく • a_i * b_j ≦ K ⇔ b_j ≦ K / a_i (切り捨て) • i行目に含まれるK以下の数の個数は、 • b_1, b_2, …, b_N のうち K / a_i 以下で • あるようなものの個数と一致 • b をソートしておけば（再び）二分探索で • O(log(N)) 時間で求まる 3/19/15 C問題　アルゴリズム (満点) • 総計算量： • O(log(MAX_A * MAX_B) * N * log(N)) • log(10^18) * 3万 * log(3万) = 2700万 • 速い言語でないと厳しいが、ゆるくすると • C++で本当にソートして通ってしまうので • 許してください 3/19/15 ©AtCoder Inc. All rights reserved. 1.問題概要 2.アルゴリズム 3/19/15 D問題　Chaotic Polygons D問題　問題概要 • こういう→ • 多角形の個数を mod 10億7 で • 求めよ • L ≦ 10^5 • (右の図の正三角形の数を • 3^L とする) 3/19/15 D問題　アルゴリズム • 求める答え（レベルLの図形に含まれる • 多角形の個数）を f(L) とおく • 中央の正三角形に注目 • それを含まないような多角形の • 個数は 3 * f(L-1) • 含むような多角形の個数は、 • 図のA地点からB地点までの • 「多角形の一部」の個数をg(L-1) として、 g(L-1)^3 3/19/15 A→ ←B D問題　アルゴリズム • g(L) を求めたい • (地点AからBまで辿る「多角形の一部」 • （右の図はレベルL+1とする）) • やはり中央の正三角形に注目 • それを含まないような「多角形の • 一部」の個数は先ほどと同様に • 再帰で • 含む場合は… 3/19/15 A→ ←B 中央 D問題　アルゴリズム • 含む場合は… • A→C→D→B と辿る C→Dは g(L-1) 通り • A→C と D→Bについては、 単体では g(L-1) 通りだが 両方とも E を通ってはいけない • 右の図形をレベルL+2として、 A→E→Cと辿るような「多角形の一部」の個数を h(L) とおいて、これを求めて両方Eを通るケースを引く 3/19/15 A→ ←B C→ ← D ↑ E 中央 D問題　アルゴリズム 右の図形をレベルL+2として、A→E→Cと辿るような「多角形の 一部」の個数を h(L) とおいた 今回は中央の三角形（FGH）に 対して必ずE側を通る A→F→E→G→C という経路に なるが、さきほどと同じくHを 二度通ってはならない 適当に回転すれば今までと同様に h(L) が g(L-1), h(L-1) で表せる 以上で f(L),g(L),h(L) が f(L-1), g(L-1), h(L-1) によって表されたので O(L) で f(L) が求まる 3/19/15 A→ C→ ↑ E H→ ↑ F G ← D問題　アルゴリズム お疲れ様でした。 3/19/15 AtCoder Regular Contest 036 解説 AtCoder株式会社 2015/4/4 1 ARC036解説 A:ぐっすり A-問題概要 ● 高橋くんの睡眠予定がN日分与えられる。 ● 連続する3日の睡眠量の合計がKを下回ると高 橋くんは睡眠不足になる。 ● 高橋くんが睡眠不足になるかどうか、なるなら 何日目になるか求めよ。 A-数式で表す ● t[i] = i日目の高橋くんの睡眠予定時間 ● 3 ≦ i ≦ N なる i のなかで t[i-2] + t[i-1] + t[i] < K となる最小の i を、存在するなら求めよ A-解法 ● t[i] = i日目の高橋くんの睡眠予定時間 ● 3 ≦ i ≦ N なる i のなかで t[i-2] + t[i-1] + t[i] < K となる最小の i を、存在するなら求めよ ● N ≦ 100,000なので、iを全通り試しても十分 まにあう – 満点解法 A-注意点 ● i = 1, i = 2のときは調べないようにしなければ ならない – t[-1]に参照して実行時エラーになりうる ● 不等号に注意 – t[i-2] + t[i-1] + t[i] ≦ K にすると失敗する – 問題文をよく読みましょう B 問題 山のデータ 概要 • 長さ 𝑁 の数列があります。 • ℎ𝑠 ≦ ℎ𝑠+1 ≦ ⋯ ≦ ℎ𝑡 ≧ ⋯ ≧ ℎ𝑢 となる整数組 (𝑠,𝑡, 𝑢) のうち、 𝑢 − 𝑠 + 1 の最大値を求めてください。 • 1 ≦ 𝑁 ≦ 300,000 • 1 ≦ ℎ𝑖 ≦ 1,000,000,000 部分点解法 • すべての整数組 (𝑠,𝑡, 𝑢) について考えます。 • 整数組 (𝑠,𝑡, 𝑢) が実際に山の条件を満たしているかは、O(𝑁) 回の 判定でできます。 • 考えられる整数組は O(𝑁3 ) 個あるので、全体で O(𝑁4 ) の計算量と なります。 考察 • 𝑠 や 𝑢 に関して、外側に伸ばせるのに伸ばさないのはもったいない です。 • 先に 𝑡 を固定して、 𝑠 と 𝑢 を外側に伸ばせるだけ伸ばすという方針 で O(𝑁2 ) に減らすことができます。 • O(𝑁2 ) よりも高速にするために、さきほどの 𝑡 に関して考えてみます。 満点解法 • 先ほどの 𝑡 としては、データの両端であるか、ℎ𝑡−1 ≦ ℎ𝑡 かつ ℎ𝑡 ≧ ℎ𝑡+1 であるような 𝑡 だけ考慮すれば良いことが分かります (そうでな い場合、 𝑡 − 1 あるいは 𝑡 + 1 の方がより良い結果になることが分 かります)。 • このように限定した場合、どの要素も高々定数回しかアクセスされな いので、全体で O(𝑁) となります。 C 問題 偶然ジェネレータ 概要 • 長さ 𝑁 の 0,1 からなる数列があります。 • ? となっている場所をうまく 0,1 で埋めて、どのように部分列を取って きても 0,1 の個数の差が 𝐾 以下となるようにします。 • 考えられる総数を 1,000,000,007 で割った余りを求めてください。 • 1 ≦ 𝑁 ≦ 300 • 1 ≦ 𝐾 ≦ 𝑁 部分点解法 1 • すべての 0,1 割り当てを考えます。 • すべての配置が定まれば、その配置が条件を満たしているかは O(𝑁3 ) で判定できます。 • 考えられる個数は 2 𝑁 個あるので、全体で O(2 𝑁𝑁3 ) となります。 • 1 つめのデータセットに対して正解できます。 部分点解法 2 • 動的計画法を用いて左から順に調べることを考えます。 • 考えるべき状態数としては、今まで調べた場所と、調べた場所の右 端から左に伸ばしたときに (0 の個数)-(1 の個数) として何が考えら れ、何が考えられないのかという情報です。 • 後者 (0,1 の差) は、(0 の個数)-(1 の個数)として、 <1 が考えられる>、 <2 が考えられる>、…、 < 𝐾 が考えられる>、 <-1 が考えられる>、 <-2 が考えられる>、…、 < −𝐾 が考えられる> という、合計で 2𝐾 ビットの 情報を持っていれば表現できます (差 0 は、長さ 0 の列を考えれば 常に存在します)。 部分点解法 2 • dp[i][j] = (場所 i まで調べていて矛盾 (差が 𝐾 を上回る状態) がなく、 かつ場所 i から左に伸ばしたときに考えられる差がビット列 j となる ような 0,1 割り当ての総数) とします。 • 状態遷移は、今見ている場所に 0,1 のどちらが入るかを決めれば次 は一意に定まるので各状態につき O(1) で判定できます。 • このような動的計画法は O(2 𝐾𝑁) で実行できます。 • 𝐾 が小さいデータセット 2 に関して正解することができます。 考察 • すべての状態を考えていても、指数オーダーの計算量となります。 • (0 の個数)-(1 の個数) の最大値および最小値が一致するもの同士 をまとめて数え上げたいです。 • 実は最大値および最小値が一致するものをまとめても、特に問題は ありません (なぜなら、差が 𝐾 を最初に越えるのは、必ず最大値か 最小値のいずれかであり、かつ状態遷移によってどの状態が考えら れるかは、平行移動 (+ 差が 0) という変化しかないので、最大値と 最小値だけ考慮しておけばよいことになります)。 満点解法 • dp[i][j][k] = (場所 i まで考えて矛盾 (差が 𝐾 を上回る状態) がなく、i から左に伸ばしたときの (0 の個数)-(1 の個数) の最大値が j で最小 値が –k であるようなものの総数) とします。 • このような動的計画法は O(𝑁3 ) で実行できます。 • このアルゴリズムなら満点を得ることができます。 ARC036解説 D:偶数メートル D-問題概要 ● 辺の無いグラフ（頂点数N）がある。 ● 以下の2種類のクエリQ個に答えよ – 頂点x, yの間にdメートルの辺を引く – 頂点xから頂点yへのwalkのなかで偶数メートルのも のがあるか判定せよ ※walkというのは同じ辺を複数回通ることを許 した経路のこと。 D-入力例1 D-考察1 ● 移動距離の総和が偶数かどうかしか気にしてい ないので、辺の長さも偶奇のみを考えれば良い (1,2にそろえた図) D-考察1 ● 距離2の辺は新たな頂点を間に追加して2つの 距離1の辺と考えて良い D-考察1 ● 「偶数メートル」→「偶数本の辺」 ● すこし扱いやすくなった D-考察1 ● クエリの数が高々2倍になるだけなので計算量 にはそこまで影響しない D-考察 ● クエリの数が高々2倍になるだけなので計算量 にはそこまで影響しない D-入力例2 D-考察2 ● 非連結な頂点は行き来できないので、連結成分 ごとに分けて考えて良い D-考察2 ● 非連結な頂点は行き来できないので、連結成分 ごとに分けて考えて良い D-考察3 ● 実験をすると連結成分には2種類に大別できる 事がわかる D-考察3 ● 頂点対によってはちょうど偶数本の辺では行き 来できない連結成分 D-考察3 ● どの2頂点もちょうど偶数本の辺を使って行き 来できる連結成分 D-考察3 ● 違いは？ D-考察3 ● 違いは？ D-考察3 二部グラフ D-考察3 ● 二部グラフとは – 頂点集合をうまく2つにわけると、すべての辺は集 合間を結び、集合内を結ぶ辺がなくなるようなグラ フ D-考察3 ● 二部グラフの性質 – 片方の集合に属す頂点から、もう片方の集合に属す 頂点に移動するwalkは必ず辺の数が奇数 D-考察3 ● 二部グラフの性質 – 片方の集合に属す頂点から、もう片方の集合に属す 頂点に移動するwalkは必ず辺の数が奇数 – 赤から始めるとかならず 赤、青、赤、青・・・ というwalkになるから D-考察3 ● 二部グラフでないグラフの性質 D-考察3 ● 二部グラフでないグラフの性質 – どの2点間も辺の数が偶数のwalkがある D-考察3 ● 二部グラフでないグラフの性質 – どの2点間も辺の数が偶数のwalkがある なぜ？ D-考察3 ● 二部グラフでないグラフの性質 – どの2点間も辺の数が偶数のwalkがある なぜ？ – 無理やり2つの集合に分けることを考える D-考察3 ● 二部グラフでないグラフの性質 – どの2点間も辺の数が偶数のwalkがある なぜ？ – 無理やり2つの集合に分けることを考える – どこかで赤 → 赤もしくは 青 → 青の辺ができる D-考察3 ● 二部グラフでないグラフの性質 – どの2点間も辺の数が偶数のwalkがある なぜ？ – 無理やり2つの集合に分けることを考える – どこかで赤 → 赤もしくは 青 → 青の辺ができる – その辺を経由すれば偶奇を 自由に調整できる D-考察まとめ ● グラフの辺の長さをすべて1にすることができ る ● 連結成分ごとに別々に考えて良い ● 連結成分が二部グラフかどうかが鍵になってい る D-部分点1 ● N,Q ≦ 3,000 ● クエリ毎に毎回質問された頂点が二部グラフか どうか判定しても充分間に合う D-部分点1 ● N,Q ≦ 3,000 ● クエリ毎に毎回質問された頂点が二部グラフか どうか判定しても充分間に合う ● 二部グラフ判定法 – 適当な頂点を赤く塗る – そこから始めて、隣接する頂点の色が異なるように DFSしながら塗っていく – 隣接する頂点の色がおなじになる辺があったら二部 グラフではない。なかったら二部グラフ D-部分点1 ● 二部グラフ判定法 D-部分点1 ● 二部グラフ判定法 D-部分点1 ● 二部グラフ判定法 D-部分点1 ● 二部グラフ判定法 D-部分点1 ● 二部グラフ判定法 D-部分点1 ● 二部グラフ判定法 D-部分点1 ● 二部グラフ判定法 D-部分点1 ● 二部グラフ判定法 D-部分点1 ● 二部グラフ判定法 D-部分点1 ● 二部グラフ判定法 – 判定と同時に塗り分けもできる ● まとめ – 頂点X、頂点Yが連結でない　　 NO – 連結で二部グラフでない　　　 　 YES – 連結で二部グラフで同じ色である　YES – 連結で二部グラフで違う色である　NO ● 30点獲得 D-考察4 ● 辺は増える一方なので、一度でも二部グラフの 異なる色となった2頂点はずっと異なる色のま まである – 毎回DFSして塗り分けするのは無駄が多い D-考察4 ● 辺は増える一方なので、一度でも二部グラフの 異なる色となった2頂点はずっと異なる色のま まである – 毎回DFSして塗り分けするのは無駄が多い ● 辺による連結のパターンを考えてみる D-考察4 ● パターン1 – 連結成分の少なくとも一方が二部グラフでない辺 – 二部グラフでないものになにを追加しても二部グラ フではなくなる D-考察4 ● パターン2 – 同じ連結成分(二部グラフ)内の頂点を結ぶ辺 – 違う色どうしを結ぶなら追加した後も二部グラフ – 同じ色どうしを結ぶなら二部グラフでなくなる D-考察4 ● パターン3 – 異なる連結成分2つ（共に二部グラフ）を結ぶ辺 – 追加後も必ず二部グラフ D-考察4 ● パターン3 – 異なる連結成分2つ（共に二部グラフ）を結ぶ辺 – 追加後も必ず二部グラフ – ときには色を塗り替えなければならなくなる D-考察4 ● パターン3 – 異なる連結成分2つ（共に二部グラフ）を結ぶ辺 – 追加後も必ず二部グラフ – ときには色を塗り替えなければならなくなる D-考察4 ● パターン1, 2の処理は簡単そう ● パターン3をどうするか？ – 具体的には色の塗り直しをどうするか？ D-考察4 ● パターン1, 2の処理は簡単そう ● パターン3をどうするか？ – 具体的には色の塗り直しをどうするか？ 解法1:マージテク 解法2:縮約 D-満点解法1 ● 各頂点について – どの連結成分に属すか？ – 何色に塗られているか？ ● 各連結成分について – 二部グラフか？ D-満点解法1 ● 各頂点について – どの連結成分に属すか？ UnionFindを使用 – 何色に塗られているか？ 配列で管理 ● 各連結成分について – 二部グラフか？ 配列で管理 D-満点解法1 ● パターン1, 2の辺については適当に処理する – 変更する情報は定数個なので、あまり計算量に影響 しない ● パターン3の塗り直しをどうするか – 頂点数が少ない方を塗り直すようにすれば良い – いわゆる「マージテク」 – どの頂点も塗り直されるタイミングで自分が属する 連結成分の大きさが2倍以上になる ● たかだかlogN回しか塗り直さない D-満点解法1 ● 注意 – DFSの計算量はO(頂点数)ではなくてO(辺の数) – それならば頂点数ではなくて辺の数の大小でマージ テクをするべきでは？ ● 結論から言うと問題ない ● 先と同様の論法で各辺がDFSで走査される回数も O(logN)程度 – 二部グラフかどうかわかっているので、全域木の辺 のみを管理するという手もある D-満点解法2 ● 同じ連結成分(二部グラフ)の同じ色どうしを縮 約する D-満点解法2 ● パターン1,2は満点解法1と同様 ● パターン3が問題 – 縮約のおかげで塗り替えが定数回で済む D-満点解法まとめ ● 満点解法1 – マージテクを使っていちいち色を塗り直す – O(Q log N) ● 満点解法2 – 縮約によって塗り直す色を定数個に減らす – O(Q α(N))　※α(N)はアッカーマン関数の逆関数 D-満点解法3 ● もっとシンプルな解法がある ● 各頂点について – 赤く塗ったもの – 青く塗ったもの をあらかじめ用意しておく D-満点解法3 ● もっとシンプルな解法がある ● 各頂点について – 赤く塗ったもの – 青く塗ったもの をあらかじめ用意しておく ● 結ぶ辺の長さが偶数なら同じ色どうしを結ぶ ● 結ぶ辺の長さが奇数なら違う色どうしを結ぶ D-満点解法3 ● 何をやっているのか？ ● 同じ色の頂点どうしは 偶数メートルでのみ行 き来できる 違う色の頂点どうしは 奇数メートルでのみ行 き来できる ● という状態を維持している D-満点解法3 ● 判定法 ● 頂点X, Yが偶数メートルで 移動できるかどうか ● Xの赤とYの赤が同じ連結成 分に含まれる ● この二つが同値 D-満点解法3 ● 実装 – 辺を結ぶことと、同じ連結成分に属するかを判定す るだけ ● ただのUnionFind ● 極めて軽実装 ● 計算量 – O(Qα(N)) AtCoder Regular Contest 035 解説 AtCoder株式会社 代表取締役 高橋 直大 2015/3/7 1 競技プログラミングを始める前に • 競技プログラミングをやったことがない人へ – まずはこっちのスライドを見よう！ – http://www.slideshare.net/chokudai/abc004 2015/3/7 2 ©AtCoder Inc. All rights reserved. 3 A問題 高橋くんと回文 1. 問題概要 2. アルゴリズム 2015/3/7 3 A問題 問題概要 • 文字列 s が与えられる． • *を自由な文字に置き換えて，sを回文にできるか判 定 • *を置き換える文字はそれぞれ異なっていてもOK • 制約 – 1 ≦ |s| ≦ 1000 2015/3/7 4 A問題 アルゴリズム • 解法1 – 前と後ろで対応する文字が同じになりうるか調べる – つまり，i 番目と |s|+1-i 番目の文字で，どちらかが * であ るか，どちらも同じ文字であるか調べる(1 <= i <= |s|) – 1つでも同じになりえない文字の組があればNO，そうでな ければYES • 解法2 – sとsをひっくり返した文字列tの間で，sのi番目とtのi番目 が同じ文字になりうるか調べる． – 結局やっていることは同じ．この方が少し楽かも． 2015/3/7 5 ©AtCoder Inc. All rights reserved. 6 B問題 アットコーダー王国のコンテスト事情 1. 問題概要 2. 考察＆解法 2015/3/7 6 B問題 問題概要 • 問題がN個ある • それぞれの問題を解くのにかかる時間を知っている • 解いた時間に依存するペナルティがある – 問題ペナルティ=コンテスト開始からその問題を正解するまでの時間 – コンテストペナルティ=問題ペナルティの総和 • 全完するときの最小コンテストペナルティと，それを 達成する解き方の数を求めよ • 制約 – 1 ≦ N ≦ 100000 – 1≦(各問題を解くのにかかる時間)≦ 1000 2015/3/7 7 B問題 考察＆解法 • コンテストペナルティ最小を達成するためには， かかる時間の小さい問題から解けば良い →かかる時間順でソートして，シミュレーションする (最大ケースで答えが32bit整数を超えるので注意) • かかる時間が同じ問題は，解く順序を入れ替えても 最小ペナルティが変わらない． →かかる時間が同じ問題がx個あったら，解き方はx!通り • 全体の組み合わせ数としては，それらの積が答え • 計算量 – ソートにO(n log n) ←標準ライブラリを使いましょう – その他 O(n) 2015/3/7 8 ©AtCoder Inc. All rights reserved. 9 C問題 アットコーダー王国の交通事情 1. 問題概要 2. 考察 3. 解法 2015/3/7 9 C問題 問題概要 • N頂点,M本の辺から成る重み付き無向グラフがある • このグラフにK本無向辺を新たに追加する • 追加する度に，全点対間の距離の和を求めよ • 制約 – 1 ≦ N ≦ 400, 1 ≦ M ≦ 1000, 1 ≦ K ≦ 400 – 1≦(各問題を解くのにかかる時間)≦ 1000 2015/3/7 10 C問題 考察 • 全点間最短距離を求めるワーシャルフロイド法を用いる →O(N^3)で全点間距離テーブルが計算可能 →辺が1つ増える毎にテーブルをO(N^3)で更新していて はTLE • ある辺を既存の辺より小さいコストの辺に変更するとき O(N^2)でテーブル更新可能 →コストがcの辺(a,b)を追加時，頂点i,j間の最短距離 cost[i][j]は以下のように更新される cost[i][j] = min( cost[i][j], cost[i][a] + cost[b][j] + c, cost[i][b] + cost[a][j] + c) ※cost[][]は全点間最短距離を記録した二次元テーブル 2015/3/7 11 C問題 解法 • まとめると – 最初にO(N^3)で全点間最短距離テーブルを構築 – 辺の追加時に毎回O(N^2)でテーブル更新 • を行うことで満点を得れる • 計算量: O(N^3 + KN^2) • 余談ですが，ワーシャルフロイドのアルゴリズムは O(N^3)ですが，アルゴリズムが非常に単純なので， 多少頂点数が多くても高速に動作することが多いで す． 2015/3/7 12 ©AtCoder Inc. All rights reserved. 13 D問題 高橋くんとマラソンコース 1. 問題概要 2. アルゴリズム 2015/3/7 13 D問題 問題概要 • 南北・東西方向の道があり，交差点の間を北・東方 向にのみ進める． • 交差点上にN個のチェックポイントがある． • 以下の2つのクエリーを処理 – kj 番目のチェックポイントを (aj ,bj )に設定しなおす – チェックポイントl1jからチェックポイントr1jまでの経路数と， チェックポイントl2jからチェックポイントr2jまでの経路数のう ち，どちらが多いか答える．ただし，多い方は少ない方の 2倍以上． • 制約 – 2<=N<=2*10^5 – 1<=(チェックポイントの座標)<=10^6 2015/3/7 14 D問題 アルゴリズム • 東西方向で東を正にX軸，南北方向に北を正にY軸を取 ります． • 隣り合うチェックポイントのx座標の差がdx，y座標の差 がdyのとき，その2つのチェックポイント間の経路の数は dx+dyCdx =(dx+dy)!/(dx!)/(dy!) (dx個の→，dy個の↑の並べ替えの個数に等しいから) • チェックポイントaからチェックポイントbまでの経路の数 は，(aとa+1間の経路数)*(a+1とa+2間の経路数)* ‥ *(b-1とb間の経路数) • 経路数はメチャクチャでかくなりそう． – (1,1) から (10^6,10^6) への経路数の時点でヤバイ • 経路数の計算では掛け算・割り算しか出てこない． 2015/3/7 15 D問題 アルゴリズム • 普通に計算するのはよくない • logを取ってみよう！！ – 0<a<b のとき log(a)<log(b) なので，大小関係が維持され る． – log(a*b)=log(a)+log(b) , log(a/b)=log(a)-log(b) から，経路 数は楽に計算できそう． – 数がそこまででかくならない • (1,1) から (10^6,10^6) までの経路数をwとおくと，log(w)は10^6ぐ らい． – 大と小で2倍差があれば，logを取った値はlog(2)≒0.69以 上差があるので誤差もOK 2015/3/7 16 D問題 アルゴリズム • 部分点解法では，番号が隣り合う２つのチェックポイ ントの間の経路数にlogを取ったものを毎回計算し， それらの和の大小を比較する． – 予め階乗にlogを取ったものを求めておく必要がある • 満点解法では，セグメント木を使い，区間の和を求 められるようにしておく． – チェックポイントの更新では，その前後の経路数を更新 – 比較では，和の大小を比較 2015/3/7 17 AtCoder Regular Contest 034 解説 AtCoder株式会社 代表取締役 高橋 直大 2015/2/21 1 競技プログラミングを始める前に • 競技プログラミングをやったことがない人へ – まずはこっちのスライドを見よう！ – http://www.slideshare.net/chokudai/abc004 2015/2/21 2 ©AtCoder Inc. All rights reserved. 3 A問題 首席 1. 問題概要 2. アルゴリズム 2015/2/21 3 A問題 問題概要 • 受験生の人数Nと、それぞれの受験生の、「国語」 「数学」「理科」「英語」「塗り絵」の5科目の点数が与 えられる。 • 受験生の最終得点は、以下の式で表せられる – 国語＋数学＋理科＋英語＋（塗り絵*110/900） • 最終得点が最も高い受験生の、最終得点を求めよ • 制約 – 2 ≦ N ≦ 3049 2015/2/21 4 A問題 アルゴリズム • 解法 – 順番に点数を計算する • この時に、（塗り絵）*900/110などを整数演算ではなく、小数とし て計算出来るように工夫することに注意！ – *900.0にするなど – 計算した中で、最も点数の高い点数を出力する • やり方はいろいろ – 配列に入れてソート – 最も高い点数を入れる変数を用意しておき、毎回max関数などで最 大値を格納する。 2015/2/21 5 ©AtCoder Inc. All rights reserved. 6 B問題 方程式 1. 問題概要 2. アルゴリズム 2015/2/21 6 B問題 問題概要 • Nの十進表記における各桁の数の和をf(n)で表す • f(x) + x = Nとなるxを全て出力しなさい • 制約 – 1 ≦ N ≦1018 2015/2/21 7 B問題 アルゴリズム • 考察 – f(x) + xについて考える – 全てのxについて、Nについて調べることが可能か？ • 可能であれば、全部試せば良いので簡単！ 2015/2/21 8 B問題 アルゴリズム • 部分点解法 (N≦1000) – xもf(x)も共に1以上の整数 • つまり、x+f(x)=Nになるには、xはN以下の正整数であることが解 る – よって、1以上N以下の整数を全て試すことで、部分点を 取ることが出来る 2015/2/21 9 B問題 アルゴリズム 部分点解法(N≦1000) • 考察 – xもf(x)も共に1以上の整数 • つまり、x+f(x)=Nになるには、xはN以下の正整数であることが解 る – よって、1以上N以下の整数を全て試すことで、部分点を 取ることが出来る 2015/2/21 10 B問題 アルゴリズム 満点解法 • 考察 – f(x)の最大値はどれくらいか？ • x=99999999999999999の時、f(x) = 9 * 17 = 153 • これよりは大きくならなそう – つまり、調べるべき範囲は、N-153からNの間で十分 • これは全探索可能！ 2015/2/21 11 B問題 アルゴリズム 満点解法 • 注意点 – 数が大きいので、32bit整数型には収まらない • 64bit整数型などの、大きな数が格納可能な整数型を使おう！ 2015/2/21 12 ©AtCoder Inc. All rights reserved. 13 C問題 約数かつ倍数 1. 問題概要 2. アルゴリズム 2015/2/21 13 C問題 問題概要 • A,Bが与えられる • A!の約数であり、B!の倍数である数の個数を出力せ よ • 制約 – 1 ≦ B ＜ A ≦ 1018 – A - 100 ≦ B 2015/2/21 14 C問題 アルゴリズム 部分点1 • A,B≦15のとき – 15! = 1307674368000 • 全通り試すことは出来ない！ • 何か工夫しなければいけない – Aの約数を全て列挙して、そのうちでBの倍数になってい るかどうかを1つ1つチェックすれば間に合う？ • 約数を、O(√A!)くらいで列挙出来れば可能！ 2015/2/21 15 C問題 アルゴリズム 部分点1 • 簡単な約数の列挙方法 – 例えば、A=5の時、A! = 120（これを暫定的にFAとする) – これの約数を列挙することを考える • 1から√FA (11くらい)までのうち、FAの約数であるものをループで探 す – If(FA % I == 0)みたいな感じ • 見つかった約数をiとすると、FA/iもFAの約数である – 1が約数なので、120も約数 – 2が約数なので、60も約数 – 3が約数なので、40も約数 – ・・・・ • これを、√FAまで繰り返すことによって、全ての約数を列挙でき る！ • 各約数に対して、B!の倍数になっているかどうかチェックすれば 良い 2015/2/21 16 C問題 アルゴリズム 部分点2 • 考察 – もっと高速化するには、根本的な部分を見直す必要があ る。 – A!の倍数かつ、B!の約数とは何か？ • (A! / B!)の約数に、B!を掛けたものである！ • 例えば、A=5, B=3であれば、5*4の約数に、3*2*1を掛けたもので ある！ – 20の約数は1,2,4,5,10,20なので、解は6,12,24,30,60,120である • まずはこれを利用する 2015/2/21 17 C問題 アルゴリズム 部分点2 • さらに考察 – A,Bが大きい時、全ての約数を列挙するのは難しい • 約数の個数をもっと上手に数えよう！ – 約数を効率的に数えるには、素因数分解をすると良い！ – 例えば、20の約数の個数を数えたい時、 • 20 = 2 × 2 × 5と表せる。 • この約数は、(2の0,1,2乗のいずれか) × (5の0,1乗のいずれか) であることが解る – 例えば、2の1乗×5の1乗を選ぶと、約数の1つである10が出来る • つまり、この組み合わせの個数を数えてあげれば良い！ – これは、各素因数に対して、その指数が分かれば良い 2015/2/21 18 C問題 アルゴリズム 部分点2 • A,B≦10^6, A-B≦100の時 – A! / B!について、約数の個数を調べたい – 計算式を考えて、10^6以上の素因数は、この数には含ま れない • よって、各素因数について、いくつ存在したかを配列で管理して あげれば良い – A!/B!を素因数分解するのは難しいが、B+1からAまでの整 数1つ1つに対して、素因数分解してあげるのは可能 • であれば、この1つ1つに対して素因数分解を行い、指数の計算を してあげれば良い。1つ1つの計算量は、部分点1の約数全列挙と 同じようなアルゴリズムを用いると、O(√A) – 指数が求まったら、あとは先ほどの公式を用いて、約数 の個数を計算すれば解ける 2015/2/21 19 C問題 アルゴリズム 満点解法 • A,B≦10^9, A-B≦100の時 – 先ほどのように、素因数の最大値が小さくはならない • だが、種類数自体はそこまで多くない！ • よって、配列で管理していた部分を、連想配列に直してあげれば 良い！ – 計算量は、素因数分解がO(√A)、その回数が100回で、1 回の素因数分解で発生する素因数は、O(logA)個程度な ので、十分に間に合う 2015/2/21 20 2015-2-21 AtCoder Regular Contest 034問題D 解説(暫定版) AtCoder株式会社代表取締役高橋直大1 2015-2-21 ©AtCoder Inc. All rights reserved. *D問題 1. 問題概要 2. 解法 2 2015-2-21 D問題 問題概要 •赤 数字 整数 書 A枚•青 数字 整数 書 B枚•何 書 C枚•以上 山札 上 引 行 •赤 数字a 引 +a点 •青 数字b 引 得点 b倍•何 引 •最終得点 期待値 ? •制約 – 1 A,B,C 50 – 1 各数字 100 3 D問題 部分点解法1 (5点) 出題者 都合 超 駆 足 申 訳 by evima •1 A,B,C 3 •合計9枚以下 •山札 全 試 •時間計算量 O((A+B+C)! * poly(A+B)) D問題 部分点解法2 (20点) •1 A,B,C 8 •赤 青 合計16枚以下•dp[今 引 集合] •時間計算量 O(2^(A+B) * poly(A+B)) D問題 部分点解法3 (40点) •1 A, C 50, 1 B 8 • 考 赤 書 数字 平均 R 全 赤 R 書 答 同 → 区別不要 •dp[引 赤 枚数][引 青 集合] •時間計算量 O(2^B * poly(A+B)) D問題 満点解法 •1 A, B, C 50 • 考 青 区別不要•青 i枚引 積 期待値 B[i] 値 計算 使 •dp[引 赤 枚数][引 青 枚数] •時間計算量 O(poly(A+B)) AtCoder Regular Contest 033 解説 AtCoder株式会社 2015/1/31 1 A問題　解説	 隠れた言葉 問題概要	 • 長さ N 䛾文字列䛾部分文字列䛾個数を求め よ。（N <= 1000） • 例え䜀	N	=	3	なら、文字列を“ABC”とすると、 • “A”,	“B”,	“C”,	“AB”,	“BC”,	“ABC”	 • 䛾	6	個䛾部分文字列がある。 解法	 • いろいろな考え方がありますが、いずれも、 • 1+2+3+…+N (= N*(N+1)/2)	 • 䛾ような式を計算すれ䜀良いということがわ かります。 • これをループを使って計算したり、数式で一 発計算をしたりしましょう。 • 考え方䛾例をいくつか紹介します。 考え方１	 • 部分文字列䛾長さごとに場合分けしてみる。 • N	=	3	䛾例だと、 • 長さ	1	䛾部分文字列：	3	個 • 長さ	2	䛾部分文字列：	2	個 • 長さ	3	䛾部分文字列：	1	個 • つまり長さ	N	䛾文字列䛾部分文字列䛿、 • N	+	(N-1)	+	…	+	2	+	1	個 考え方２	 • 取り出す区間䛾左端と右端を全て試してみる。 • N	=	3	䛾例だと、 • [A]BC,	[AB]C,	[ABC],	A[B]C,	A[BC],	AB[C]	 • という６つ䛾取り出し方がある。 • ２重ループで位置を全て試してみて、 • 右端が左端よりも右にあるも䛾を数える。 考え方３	 • N	=	1	:	1	個 • N	=	2	:	3	個 • N	=	3	:	6	個 • N	=	4	:	10	個 • N	が	1	増えるごとに答えが	N	だけ増えるらしい？ →	N-1	が	N	に増えた時に増える部分文字列䛿、最後 䛾文字を含むような部分文字列で、それ䛿	N	個ある から。		 • よって、1	+	2	+	…	+	N という式になります。 B問題　解説	 メタ構文変数	 問題概要	 • ２つの整数の集合A,BのJaccard係数を求めよ。 • Jaccard係数とは、 • AとBの共通部分の要素数	/	AとBの和集合の要素数 （size(A∩B)	⁄	size(A∪B)） • 40点：A,Bの要素数≤1000、A,Bに含まれる整数≤10^5	 • 70点：A,Bの要素数≤10^5、A,Bに含まれる整数≤10^5	 • 満点：A,Bの要素数≤10^5、A,Bに含まれる整数≤10^9	 40点解法	 • A,Bの共通部分の要素数をXとすると、A,Bの 和集合の要素数は、 • Aの要素数(NA)+Bの要素数(NB)-X	 • と計算できる。 • Xは、Aの要素とBの要素をそれぞれ舐める２ 重ループを回し、一致したものの個数を数え ると求まります。 70点解法	 • ２重ループを１重ループにしたい。 • Aの要素を舐めて、その要素がBに含まれる のかどうかを高速に判定したい。 • 要素数が10^5+αの配列を作って、Bに含まれ る数の場所に1を代入しておき、それ以外の 場所に0を代入しておく。 • すると、配列の値を参照するだけで、ある数 がBに含まれるのかどうかを判定できる。 満点解法	 • 数の上限が大きいため、配列が取れない。 • Bをソートしておき、二分探索を用いる。 • set（集合を扱うクラス）を用いる。 • などの方法で、ある数がBに含まれるのかど うかを高速に判定できる。 C問題　解説	 データ構㐀	 問題概要	 • 数䛾集合に対するクエリを	Q	個処理せよ。 • タイプ１：集合に X を追加する。 • タイプ２：集合䛾 X 番目䛾数を答え、削除す る。 • Q	<=	200000,	X	<=	200000	 背景	 • 「えーっと、とりあえず set に突っ込んで・・・」 • Set	に䛿「X 番目䛾数」を 取り出す機能䛿ついていません。 解法	 • 「X 番目䛾数」を言い換えてみる。 • →「それ以下䛾数が	X	個であるような数䛾う ち最も小さい数」 • ということ䛿、 • 「ある数以下䛾数がいくつあるか」が高㏿に 求まるデータ構㐀があれ䜀二分探索で求め ることができそう。 データ構㐀	 • 「ある数以下䛾数がいくつあるか」を高㏿に求め るデータ構㐀？ • 区間䛾和を求める	segment tree	を使う。 • （Fenwick	tree	(BIT)	でも良い。） • こ䛾	segment	tree	で対応するクエリ䛿、 • add(i,	v)：場所	i	に	v	を足す。 • Sum(l,r)：場所	l	から場所	r	まで䛾和を求める。 • タイプ１で䛿、add(X,1)	をする。 • タイプ２で䛿、sum(0,i)	を使って二分探索を行っ て答えを求め、add(答え,-1)	をする。 Segment tree • こ䛾ような二分木を作って区間を管理する データ構㐀です。 • 今回䛾例だと、各ノードに「区間内䛾数䛾和」 を持て䜀良いです。 0~3䛾区間䛾データを持つ	 0~1䛾区間䛾データ	 2~3䛾区間䛾データ	 0~0䛾区間	 1~1䛾区間	 2~2䛾区間	 3~3䛾区間	 Segment tree • 初期状態	 0 0 0 0 0 0 0 Segment tree • Add(2,1)というクエリ（場所2に1を足す）が来 ると・・・ • 赤い色をつけたノードに１を足します。 1 0 1 0 0 1 0 Segment tree • 続けてAdd(0,1)というクエリ（場所0に1を足 す）が来たら、 2 1 1 1 0 1 0 Segment tree • 次に、Sum(0,2)というクエリ（0~2䛾区間䛾和を求 める）が来たら・・・ • 赤い区間䛾和を答えます。 • 1+1	=	2！ 2 1 1 1 0 1 0 Segment tree • 続けて、Sum(1,2)というクエリ（1~2䛾区間䛾和を 求める）が来たら・・・ • 0+1	=	1！ 2 1 1 1 0 1 0 別解	 • 平方分割 • 定数Dを決めて、1..D,D+1..2D,2D+1..3D,…ごと に分割して、N/D個䛾配列やリストを使って愚 直に管理する。 • 例え䜀タイプ１䛾クエリ䛿、kD	<	X	≤	(k+1)D	 だったとすると、k番䛾配列にO(D)で挿入する。 別解	 • タイプ２䛾クエリなら、「1〜k-1番䛾配列䛾要 素数䛾和がX未満」となるような最小䛾kを見 つけます。愚直に前から見て行っても	O(N/D) 䛾計算量で見つかります。 • そして、k番目䛾配列䛾うち	X-「1〜k-1番䛾配 列䛾要素数䛾和」 番目䛾数が答えとなる䛾 でそれを出力し、O(D)で削除します。 別解	 • タイプ１䛾クエリで	O(D)	 • タイプ２䛾クエリで	O(max(N/D,D))	 • max(N/D,D)	を最小化するような	D	䛿√Nであ り、Dに√N	を用いると計算量䛿、O(Q	√N)	とな ります。 • こ䛾ように、タスクを分割して計算量をO(√N) にする手法を平方分割と呼びます。汎用性䛾 高いテクニックな䛾で、覚えておいて損䛿な いでしょう。 D問題　解説	 見たこと䛾ない多項式	 問題概要	 • N	次多項式	P(x)	がある。 • P(0)	〜	P(N)	䛾値が与えられる。 • P(T)	䛾値を求めよ。	(mod	1,000,000,007)	 • T	≤	10^9	 • 40点：N	≤	100	 • 80点：N	≤	3000	 • 満点：N	≤	10^5	 40点解法	 • N=3,	P(0)=1,	P(1)=3,	P(2)=7	䛾場合を考える。 • P(x)=a2x2+a1x+a0として、xに0,1,2を代入する。 • 0×a2+0×a1+1×a0	=	1	 • 1×a2+1×a1+1×a0	=	3	 • 4×a2+2×a1+1×a0	=	7	 • という連立方程式を解け䜀係数が計算できる。 • 連立方程式䛿、掃き出し法を使え䜀解くこと ができる。 80点解法	 • ラグランジュ補間という手法を使う。 • Qi (x)	=	(x-0)*(x-1)*…*(x-N)/(x-i)	 • という式を考える。 • P(x)䛿こ䛾式を使って、 • P(x)	=	C0×Q0(x)+C1×Q1(x)+…+CN×QN(x)	 • という形で表すことができる。 80点解法	 • Qi (x)という式䛾特徴として、 • Qi (0)〜Qi (N)䛾うちQi (i)以外䛾値が	0	です。 • こ䛾特徴䛾ため、 • P(i)	=	C0×Q0(i)+C1×Q1(i)+…+CN×QN(i)	 • =	Ci ×Qi (i)	 • となり、 • Ci 	=	Qi (i)	/	P(i)	 • としてCi を計算することができます。 80点解法	 • 流れとして䛿、 • Ci 	=	Qi (i)	/	P(i) を使ってC0 〜CNを求める。 • P(T)	=	C0Q0(T)+C1Q1(T)+…+CNQN(T)	 • を計算して P(T)	を求める。 • 各 Q(i)	䛿 O(N)	で計算でき、O(N)	回計算する ため、合計で O(N^2)	となります。 満点解法	 • 求めたいQi (i)䛾値䛿、 • Q0(0)〜QN(N)	 • Q0(T)〜QN(T)	 • これら䛾計算をまとめてO(N)で行いたい。 満点解法	 • Q0(0)〜QN(N)	 • Qi (i)とQi+1(i+1)が似ていることを利用する。 • Qi (i)	=	(i-0)*…*(-1)*(1)*…*(i-N)	 • Qi+1(i+1)	=	((i+1)-0)*…*(-1)*(1)*…*((i+1)-N)	 • (i-N)䛾項が減り、((i+1)-0)䛾項が増える。 • そ䛾差分だけを計算してQi (i)からQi+1(i+1)を 計算していけ䜀よい。 満点解法	 • Q0(T)〜QN(T)	 • Qi (T)	=	(T-0)*(T-1)*…*(T-N)/(T-i)	 • N	≤	T	な䛾で	(T-i)	䛿	0	になりません。 • そ䛾ため、あらかじめ(T-0)*(T-1)*…*(T-N)から (T-i)を割れ䜀いい。 • これで、O(N	log	mod)	解けるようになります。 （割り算にO(log	mod)かかります） AtCoder Regular Contest 032 解説 AtCoder株式会社 代表取締役 高橋 直大 2015/1/3 1 競技プログラミングを始める前に • 競技プログラミングをやったことがない人へ – まずはこっちのスライドを見よう！ – http://www.slideshare.net/chokudai/abc004 2015/1/3 2 ©AtCoder Inc. All rights reserved. 3 A問題 ホリドッグ 1. 問題概要 2. アルゴリズム 2015/1/3 3 A問題 問題概要 • Nが与えられる • 1+2+…+Nの素数判定せよ • 制約 – 1 ≦ N ≦ 999 2015/1/3 4 A問題 アルゴリズム • 解法1 – S=1+2+…+Nをforループで計算する • N=1000のとき最大でS=1+2+…+1000 = 500500 – それに対して素数判定をforループで行う • 2～S-1の範囲でSを割り切る数がないか確かめる • 解法2 – S=1+2+…+N=𝑁 𝑁+1 2 (総和の公式) • 式から明らかにNが小さいとき以外は素数にならなさそう – N=1のときは1なので素数ではない – N=2のときは素数 – N>2のとき常に合成数 • N=2のときだけ素数，それ以外のとき非素数なので， その事実にしたがって出力すればよい 2015/1/3 5 ©AtCoder Inc. All rights reserved. 6 B問題 道路工事 1. 問題概要 2. アルゴリズム 2015/1/3 6 B問題 問題概要 • N 頂点 M 辺の無向グラフが与えられる • グラフに最小でいくつ辺を追加すれば、全体がつな がるか調べる • 制約 – 0 ≦ N,M ≦ 100000 2015/1/3 7 B問題 アルゴリズム • 考察 – グラフのつながっている部分がK個あるとき、最小でK-1本 の辺があれば全体をつなげられる。 – 1本つながっていない部分の間に辺を追加すると、Kは1減 るから。 2015/1/3 8 黒がもともとある道路 このとき、K=3 2本の赤の辺を追加すれば全 体がつながる B問題 アルゴリズム • なので、グラフのつながっている部分(連結成分と呼 ばれる)の数を数えればよい。 • 解法1 – Union-Findですべての辺をつないだ後、Union-Find木での root の数を数える(具体的には、頂点 v のrootが v のもの を数えると楽。連結成分ごとに root は共通で、自身が root となるものがちょうど 1 つあるから) • 解法2 – 今まででまだ訪れていない頂点を見つけたら、 DFSを使い そこから行ける頂点をすべて訪れて、連結成分の数を1つ 加える etc… • どちらも(ほぼ)線形時間 2015/1/3 9 ©AtCoder Inc. All rights reserved. 10 C問題 仕事計画 1. 問題概要 2. アルゴリズム 2015/1/3 10 C問題 問題概要 • 時刻の区間がN個与えられます。区間は順に1から Nまで番号付けられています。 • i 番目の区間は a_i から b_i まで。 • 互いに被らない条件の下で、なるべく多くの区間を 選びたい(端点は被ってもOK) • 複数あるときは、区間の早い順に並べた時の辞書 順最小となるものを1つ出力。 • 制約 – 0 ≦ a_i, b_i ≦ 1000000 – 1 ≦ N ≦ 100000 2015/1/3 11 C問題 アルゴリズム • これ蟻本でやったやつだ！(区間スケジューリング問 題, p43) – 蟻本を読もう！ – 具体的には、終了時間が早い順にソートし、貪欲に区間 を選んで行けば、区間数最大の解が1つ得られる • しかし、辞書順最小での構成を1つ出力しなければ ならない • なるべく多く取れる取り方のうち、辞書順最小のもの を求めるときは、最初に取れるものを最小化し続け る必要がある 2015/1/3 12 C問題 アルゴリズム • 時刻 i それぞれに対し、(i 以降で最大でいくつ取れ るか?,最大の取り方のうち、次に取れる最小の仕事 の番号はいくつか?) のペアが更新すればできそう – i から始めるとき、次に取る区間は辞書順最小の条件か ら、(最大の取り方のうち、次に取れる最小の仕事の番号) となるから • このペアを dp[i] とおく 2015/1/3 13 C問題 アルゴリズム • dp[i] を求めるとき、 – 時刻 i から始まる区間を使うとき、時刻 i から始まり、b で終わ る番号idの区間を使う場合、 (b以降で取れる区間の最大数 +1,id) が候補 – 時刻 i から始まる区間を使わないとき、(時刻 i+1 以降で取れる 区間の最大数, そのうちの最小の仕事の番号) が候補 – 以上のペアから、取れる区間の最大数で比較し、多いものを選 ぶ。それが同じなら、次に取る仕事の番号が小さいものを選ぶ。 • 番号が同じ区間はないので、このペアが同じになることは無い • 以上のことから、dp[i] の更新に必要なのは i+1 以降の dpの情報 • よって、dp[i] を後ろから更新していけばよい 2015/1/3 14 C問題 アルゴリズム • dp[0] が求まったら、0 以降で取れる区間の最大数 が1つ目の答え。 • 復元するときは、今の時刻以降で最大の取り方のう ち最小の番号の区間をとり続けていく – dp のペアの2番目の情報にこれがそのまま入っている – 最初に “今の時刻”=0 とし、次に取る区間を答えに追加 し、”今の時刻”を最後に取った区間の終端に更新 – これを、取れる区間が無くなるまで繰り返す • 合計でもO(N)! 2015/1/3 15 ©AtCoder Inc. All rights reserved. 16 D問題 アットコーダーモンスターズ 1. 問題概要 2. 考察 3. アルゴリズム 2015/1/3 16 D問題 問題概要 • N匹のモンスターがいる • 各モンスターには攻撃力と防御力というパラメータがある • ちょうどK匹のモンスターを買いたい • あるモンスターの対について，攻撃力の差と防御力の差の 最大値を不安定度と定義 • K匹からなるチームに含まれるペアの不安定度の最大値 (=チームの不安定度)を最小化し，それを達成する組み合わ せ数 mod 100000007 を出力しろ． • 制約 – 1 ≦ K ≦ N ≦ 100,000 – 0 ≦ 各モンスターの防御力,攻撃力 ≦ 3000 2015/1/3 17 D問題 考察 • まず，チームの不安定度の最小値を求めたい． • モンスターの(攻撃力,防御力)を二次元平面に点とし てプロットしてみる • あるチームの不安定度をxと決めたとき， – 一辺xの正方形領域に含まれる点の数がK以上であるようなところ が存在すれば，不安定度x以下にできることが分かる． • これで二分探索したらよさそう． • 任意の正方形領域に含まれる点の数を高速に計算 するため，予め二次元累積和を計算しておく． D問題 考察 • 次にチームの不安定度の最小値mを達成する組み 合わせ数を求めたい． • 単純に全ての領域に対してKコを選ぶ組み合わせの 数を計算するのは，重複が発生しダメ． • ある点を角(x,y)と決めたときに，その点を角にした 正方形(左上(x,y)右下(x+m,y+m))のときにしか達成 できないような選び方を計算することで重複なく数え られる • そのような選び方は2パターンある(次スライド) D問題 考察 • パターン1 : 選んだ角(x,y)に1つ以上の点がある • パターン2 : 選んだ角(x,y)に点は無いが，(x,?)と(?,y) に1つ以上ずつ点がある． ケース1(3通り) ケース2(1通り) ↑4つの点がある適当な例(K=3とする) D問題 考察 • 説明のために – 正方形領域の全ての点の数をall – 角(x,y)の点をcorner – 左端領域の点と上端領域の点の数をleft,top と表す [パターン1の個数] – nCr(all,K) - nCr(all-corner,K) [パターン2の個数] – nCr(number-corner,K) - nCr(number-corner-top,K) - ncr(number-corner-left,K) + nCr(number-corner-(top+left),K) corner以外でKコ cornerとtop以外でKコ cornerとleft以外でKコ cornerとleftとtop以外でKコ (引きすぎた分を足す,包除原理) D問題 アルゴリズム • モンスターのパラメータの最大値をM(<=3000)とする • Nコの点をプロットする → O(N) • 二次元累積和を計算しておく → O(M^2) • チームの不安定度の最小値mを二分探索で求める → 累積和を用いて O(M^2 log M) • 組み合わせ数を求める → O(M^2) nCrの計算は予め0≦k≦Nについてk!と(k!の逆元)をmod 10^9+7で計算しておく ことでO(1) • 全体として O(M^2 log M) ARC #031 解説 解説スライド：水野尚人（not） 問題A 名前 問題概要 文字列が回文かどうか判定する 文字列の長さ≦１００文字 類題：ARC #019 B - こだわりの名前 解法１ 前と後ろで対応する文字が同じか調べる a w a w a 解法２ ひっくり返した文字列と同じになるか調べる chokudai → iadukohc chokudai ≠ iadukohc 問題B 埋め立て 問題概要 １０×１０のグリッドが与えられる 各マスは陸地または海 1マスだけ海を陸地にすることで、 陸地を全部繋げられるか？ 入力例１ 赤枠のマスを埋め立てると １つの島になる 解法 どこを埋め立てるかを全探索して、 １つの島になっているか調べる １つの島になっているかは、あるマスから すべてのマスにたどり着けるかを幅優先探索や 深さ優先探索で調べれば良い 問題C 積み木 問題概要 N個の積み木が１列に並べられている 隣り合う２個の積み木を並べ替えて、一番高い 積み木から順に左右へ低くなるよう並び替える 最小の交換回数は？ N≦100,000 （部分点：N≦100） 入力例２ まず１番小さい積み木だけ移動させてみる 左右どちらかの端に移動させないといけない 残った部分は同じ形をしている 近い方に移動させれば良い 解法 ２番目、３番目、…と同じ操作をしていくと 最小の交換回数が求められる 愚直にやると𝑂 𝑁 2 → ３０点 解法 各積み木を移動させる回数 ＝それより大きい積み木が左側と右側に何個ずつ あるか調べて、その小さい方 Binary Indexed Treeなどを用いると𝑂(𝑙𝑜𝑔𝑁)で 計算できる 解法 解法 2 4 1 3 5 ２回 ２回 １はどちらに動かしても２回交換が必要 解法 2 4 1 3 5 ０回 ３回 ２はすでに左側にあるので動かさなくて良い 解法 2 4 1 3 5 １回 １回 ３はどちらに動かしても交換回数は１回 解法 2 4 1 3 5 ０回 １回 ４はそのままで良い 解法 ・最初に全要素１としてBinary Indexed Treeを 構築し、小さい方から順に見ていく ・左側と右側の和を計算する ・各積み木を調べたら、Binary Indexed Treeの 対応する要素を０に変更する ・計算量は全体で𝑂(𝑁𝑙𝑜𝑔𝑁) 問題D 買い物上手 問題概要 アイテムの組み合わせると経験値が得られる 「得られた経験値÷使ったお金」を最大化 経験値をもらえる組み合わせの数≦１００ アイテムの種類数≦１００ 入力例１ アイテム１・２・３を買うと、経験値７、使ったお金７ となり答えは１ 解法 「平均」を最大化/最小化 →答えについて二分法 類題）ARC #026 D -道を直すお仕事 得られた経験値÷使ったお金＝𝑥と思って 得られた経験値－使ったお金× 𝑥 の正負で 二分法をする 解法 経験値をもらうかどうかをexp(𝑖)とし、 アイテムを買うかどうかをitem(𝑖)とすると 𝑆 𝑖 exp(𝑖) − 𝑥 𝑇 𝑖 𝑖𝑡𝑒𝑚(𝑖) を最大化すれば良い。ただし、 exp 𝑖 = 0,1、𝑖𝑡𝑒𝑚 𝑖 = 0,1 と、𝑖番目の経験値に𝑗番目のアイテムが必要なら 𝑒𝑥𝑝 𝑖 = 1 → 𝑖𝑡𝑒𝑚 𝑗 = 1 が成り立たなければならない。 解法 𝑆 𝑖 > 0、𝑇 𝑖 > 0なので条件は以下のように 書き直すことができる exp 𝑖 ≦ 1 𝑖𝑡𝑒𝑚 𝑖 ≧ 0 𝑒𝑥𝑝 𝑖 ≦ 𝑖𝑡𝑒𝑚 𝑗 これは線形計画法になっているのでsimplex法 などで解くことができる ただし、このままではTLEを回避するのが困難 解法 双対問題を考えると以下のように書き換えられる 条件： 𝑗 𝑥𝑖𝑗 ≦ 𝑆𝑖 𝑖 𝑥𝑖𝑗 ≦ 𝑥𝑇𝑖 𝑥𝑖𝑗 ≧ 0 (経験値𝑖にアイテム𝑗が必要な場合) 最大化： 𝑖,𝑗 𝑥𝑖𝑗 − 𝑖 𝑆𝑖 これは二部グラフの最大流になっている 解法 入力例１ source 経験値１ 経験値２ 経験値３ アイテム１ アイテム２ アイテム３ アイテム４ sink 3 解法 このグラフで、sourceから出ている辺を 流し切れるなら𝑥が小さい 流しきれないなら𝑥が大きい グラフをよく眺めると値段あたりの経験値を 𝑥として求める形になっている 参考文献： 二部グラフにおける最大重み閉包問題（古林 他） ARC030 解説 解説スライド担当: 三上 和馬 (@kyuridenamida) 問題A – 閉路グラフ 問題概要 • n = 6 k = 2 の例　答えは「YES」 解法＆考察 • 取り出せる最大の連結成分の数を求めたい • とりあえず頂点を1つ取り除いてみると直線グラフになる ● この状態でサイズ1の連結成分を作りまくるのが最適そう したがって端から偶数番目の頂点を取り除いていけばよい ● 奇数番目の頂点の数=((n-1)/2を切り上げたもの)が作れる連結成分の最 大数であり，kがこれ以下であればYES，そうでなければNOを出力 • 1 2 3 4 5 備考 • 閉路グラフはよく列を扱う問題の派生として出題されます． • 「頂点を1つ○○したら列の問題に帰着できる」等の発想は，方針を 考える上で手助けになるかと思われます． 問題B – ツリーグラフ 問題概要 • x=1のケース 考察＆解法 ● 与えられたグラフから出発地点を根とした根付き木を構築する ● ある辺をたどるべきかどうかだが，「辺を辿った先の部分木の頂点が 1つでも宝石を含んでいるときに限り通り，それ以外のとき通らなくて 良い」ということが分かる．部分木が宝石を含んでいるかを判定する 関数を作っておく ● ある辺を使うときは行きと帰りで必ず2回通る ● なので，判定関数で，行く必要のない頂点に遷移しないような再帰関 数を書き，辺をたどる毎に答えに2を加算するプログラムを書けば良 い ● 任意のケースで同じ辺を3回以上辿る必要はなく，上記の戦略が最 適． 問題C – 有向グラフ 問題概要 1 a 2 b 4 a 3 b ①a回収 ②移動 ⑤移動 ④a回収 ③移動 ⑥b回収 頂点４からスタート k=3のケース aabを出力 強連結成分分解 ● 有向グラフにおいて，相互に行き来できる頂点同士の集合 (強連結成分)を検出し，グループ分けするアルゴリズム ● 適当な未訪問の頂点を始点とし，深さ優先探索を行い，帰り がけ順で頂点を列挙することを，未訪問頂点がなくなるまで 繰り返す(トポロジカルソート)． ● 次に，元のグラフの逆辺グラフを考え，上記で得られた頂点 の順番に，未訪問の頂点を始点とし再度深さ優先探索を繰 り返し行う．このとき，この一度の深さ優先探索でたどり着け る頂点集合が1つの強連結成分となっている 考察＆解法 • どこの頂点のアルファベットを回収したかを覚えて探索は無理． • なので，与えられたグラフに対して強連結成分分解を行う • 同じ強連結成分に属する頂点の文字は，自由な順番で取ることがで きる→ある強連結成分にある文字をhoge個使うことを考えたとき，強 連結成分に含まれる文字群をソートした文字列の先頭hoge個を使え ば良いということが分かる • こういった遷移を考えればDAGになり，回収した頂点を覚えなくて良 いDPに帰着できる • DPは「どの強連結成分か」「今何文字か」をキーに辞書順最小の文 字列を格納するものを行う • 強連結成分分解の計算量はO(N+M)，文字列比較に最悪O(K)かか るので，動的計画法の計算量はO((NK+M)K) 問題D – グラフではない 問題概要 • 長さNの数列Xが与えられ，その後Q個のクエリが飛んでくる．種類は • 1 a b v ― Xの区間 [a,b] に一様に値 v を加える． • 2 a b c d ― Xの区間 [a,b] を，クエリが呼ばれた時点での区間 [c,d] の値に書き換える(b−a=d−c)． • 3 a b ― Xの区間 [a,b] の総和を出力． • 1 N 200,000 ≦ ≦ • 1 Q 200,000 ≦ ≦ 方針 今回のクエリはタイプ2が曲者なので，そのため 区間に対する操作は平衡二分木等を使うと万能なのでそれを使う．遅 延評価が使えると良い． 　　segtreeは使えるか…?　→　今回はタイプ2があり，使いづらい． ● タイプ2のクエリ([c,d]→[a,b])がやっかい このクエリは，区間[c,d]のコピーを区間[a,b]に上書きするクエリ 平衡二分木のある区間のコピーを作成するには，永続データ構造が 必要そう． 遅延評価機能付き永続型平衡二分木をつくろう． 永続化のための平衡二分木選び • ✖ treap (同じ乱数値を持つノードがたくさん発生するため木が偏る) • ○ 赤黒木 (いける...けど実装重い) • ◎ RandomizedBinarySearchTree (マージ/スプリットするときに乱数を 用いるのでtreapみたいなことは起きない) ↑計算量解析は難しいらしいが実際偏らず各操作O(log n)．実装も 比較的軽くおすすめ！今回はこれを実装する． まずは普通の平衡二分木 • 今回はキーに順序関係が全くないので，「平衡二分探索木」ではなく 「平衡二分木」と呼ぶが，対数計算量実現のためにやってる操作は 一緒． • 区間の問題に対処するためには， – ある位置の頂点を追加する/削除するというinsert/eraseベース の実装 • よりも – ある位置で木を2つに分割する/2つの木を順番を保って併合す るsplit/mergeベースの実装 のほうが都合が良いのでそれを実装していく 各ノードが持つべき情報 ● 左の子へのポインタ/右の子へのポインタ ● そのノードの持つ値 ● そのノードを根とした部分木のすべてのノードの値の総和 ● そのノードを根とした部分木のすべてのノードの数 ● そのノードが持つ評価遅延中の値 が持つべき情報 struct T{ T *l,*r; long long v; long long sum; long long lazy; int c; }; 作っておくと便利な関数 ● 子の情報に基づきノードの情報を更新し，自身のポインタを返す関数 T *update(T *c){ if( c == NULL ) return c; if( c->lazy ){ // 評価遅延しているものを評価し子に伝搬する c->v += c->lazy; if(c->l){ c->l->lazy += c->lazy; c->l->sum += count(c->l) * c->lazy; } if(c->r){ c->r->lazy += c->lazy; c->r->sum += count(c->r) * c->lazy; } c->lazy = 0; } c->c = count(c->l) + count(c->r) + 1; c->sum = sum(c->l) + sum(c->r) + c->v; return c; } int count(T *c){ if( !c ) return 0; else return c->c; } long long sum(T *c){ if( !c ) return 0; else return c->sum; } マージ関数の実装 ● T *merge(T *a,T *b) := aの右の子にbを結合するか，bの左の子にa を結合するかを乱数で決める関数 「aの部分木サイズ>bの部分木のサイズ」のときはだいたいの確率 でaの右の子にbをくっつける」などを繰り返すイメージ ● つなげたあとは，つなげたときに取り除いた子を考慮して再帰 T *merge(T *a,T *b){ if(a == NULL) return b; if(b == NULL ) return a; if( rand() % ( count(a) + count(b) ) < count(a) ){ a = update(a); //　たどったノードはとりあえず更新しておく a->r = merge(a->r,b); return update(a); }else{ b = update(b); //　たどったノードはとりあえず更新しておく b->l = merge(a,b->l); return update(b); } } スプリット関数の実装 ● pair<T*,T*> split(T *c,int k) := cの部分木を[0,k) [k,n)に分割したもの のそれぞれの根をpairで返す pair<T*,T*> split(T *c,int k){ if(!c) return make_pair(c,c); c = update(c); //たどったノードはとりあえず更新しておく if(k <= count(c->l)){ pair<T*,T*> s = split(c->l,k); c->l = s.second; return make_pair(s.first,update(c)); }else{ pair<T*,T*> s = split(c->r,k - count(c->l) - 1); c->r = s.first; return make_pair(update(c),s.second); } } これらの関数を永続化に対応させるには ● 基本的に全てのノードがconstなものであると考え，子を書き換えた り，遅延情報を伝搬したり，ありとあらゆる変更する際はコピーノー ドを作成し，それを書き換えるという発想に基づく．書き換わってい ないノードは既存のものを使うようにする． ● ここで自身を返す実装が初めて生きてくる ● すると，一度の操作で増えるノードの数はたかだかO(log N)個 これらの関数をこの問題に適用していく ● 基本的に，区間に対する操作は， – 区間だけを切り取った木をsplitで作り，根を操作し，そのあとそれをmergeする で対処する． ● たとえば区間[a,b)に対するタイプ1(一様加算)クエリは今の列の[a, b)を取り出して根の遅延評価情報にvを加算し，くっつける ● タイプ2(コピー)クエリに関しては，[0,a) [b,n) そして[c,d) をコピーし た木を作り，[0,a) [c,d) [b,n)の順番でマージする(実際の問題は閉 区間で与えられるので注意) ● タイプ3のクエリは，同様に区間を切り出し根のsumを出力するだけ メモリが溢れることに対する対処 ● 実際は，一回クエリを処理するたびに，ノードが結構生成される ● 適当にやっているとMLEしかねないが，メモリーがやばくなったら一 回列の情報を全てどこかに出力し，永続情報を破棄し再構築する という方法で簡単にごまかすことができる． 計算量 ● 時間計算量 – 一回の操作でO(log N) なので O( (Q+N) log N) – ただし定数倍は重い ● 空間計算量 – O( (N+Q) log N)個のノードがクエリ処理の過程で生成される – 遅延評価するときに，たどったノードに隣接している子ノードの分もコピーするので，こちら も定数倍は重い．前スライドのような方法で対処． ARC029 解説 解説スライド担当: 城下 慎也(@phidnight) 問題A – 高橋君とお肉 問題概要 • 2 つの肉焼き器を用いてお肉を焼く。 • 𝑁 個のお肉を肉焼き器を使って焼く。 • うまく割り当てて、すべてのお肉が焼けるまでの時間を最小化せよ。 • 1 ≦ 𝑁 ≦ 4 解法 • 全探索をすることで答えることができます。 • お肉をどちらの肉焼き器に割り当てるかという、全部で 2 𝑁 ある組み 合わせを試します。 • 割り当てた後、それぞれの肉焼き器が肉を焼くのにかかる時間は、 割り当てられた肉が要求する焼き時間の合計値と同じになります。 • 2 つある合計値のうち大きいほうがその割り当てにおける焼き時間 となります。 • 計算量は O(𝑁 ∗ 2 𝑁) となります。 • 𝑁 ≦ 4 なので、満点をとることができます。 備考 • 指数全探索は競技プログラミングでは頻出です。 • 特に、部分点として出やすいので、ぜひとも習得してください！ • ちなみに、この問題は、すべてのお肉の焼き時間の合計値を𝑀とお いたときに、𝑀/2 以上で最小の部分和を求める問題に帰着すること ができます。 • 上記の帰着により動的計画法で O(𝑁𝑀) で解くことができます。 問題B – 高橋君と禁断の書 問題概要 • ノートと箱 (ともに長方形で考える) が与えられる。 • それぞれの箱について、ノートが入るか否かを判定せよ。 • 1 ≦ 𝑁 ≦ 5,000 • 1 ≦ 辺の長さ ≦ 100,000 幾何の問題 • 幾何の問題は競技プログラミングで出てくることがあります。 • 実数計算とか特有の問題もあるので、慣れておくと良いと思います。 • 角度やベクトル計算 (外積、内積) などを知っておくと役立つことがあ ります。 実行できない解法 • すべての角度を試します。 • 「すべての角度」は、数え上げることができません。 • この方針だと、計算が終了しません。 実行できない解法 • すべての角度を試します。 • 「すべての角度」は、数え上げることができません。 • この方針だと、計算が終了しません。 • そのため、計算可能なように探索候補をしぼる必要があります。 危険な解法 • ランダムに角度を決めて置く、という動作を一定回数繰り返し、何回 やってもダメなら NO とし、うまく置けたら YES とします。 • 下図のような配置の場合、うまくいく確率がとても低く、NO と行ってし まう確率が高くなります。 考察 • 最初に、すべてを横向きに合わせます。 • 少しずつ回転させていくと、高さが増えていくので、高さが一致したと きのみを試すと斜めのケースも対応できる。 解法 • 縦横に平行なケースを試し、斜めを、高さが一致した場合に限定す ることでそれぞれ O(1) で計算することができます。 • 高さが一致する瞬間は、最大値になる角度まで範囲で角度の二分 探索で計算することができます。 問題C – 高橋君と国家 問題概要 • グラフが与えられます。 • 頂点に交易所、辺に舗装道を設置して、交易所へ舗装されていない 道路を経由して移動できるようにします。 • 設置と舗装のコストが与えられるので、コストの合計を最小にしてく ださい。 • 1 ≦ 𝑁(頂点数) ≦ 100,000 • 1 ≦ 𝑀(辺数) ≦ 200,000 部分点解法 1 (10点) • すべての都市、道に対して、操作をするかしないかを決めて、その 決め方でうまくいっているかを試します。 • うまく行っているかの判定は、各都市に対して、その都市の連結成 分に交易所のある都市が入っているかを判定すれば良いです。 • 幅優先探索などを用います。 • 計算量はO(𝑁 ∗ 𝑀 ∗ 2 𝑁+𝑀) などになります。 • Union – find を用いると手早く連結判定はできます。 部分点解法 2 (10 + 20点) • すべての都市に対して、操作をするかしないかを決めます。 • 辺を効率的に選択します。 部分点解法 2 (10 + 20点) • アイデアとして、交易所のある頂点を 1 つにまとめてみる。 部分点解法 2 (10 + 20点) • アイデアとして、交易所のある頂点を 1 つにまとめてみる。 • すると、全体が 1 つの連結成分になることがわかる。 部分点解法 2 (10 + 20点) • アイデアとして、交易所のある頂点を 1 つにまとめてみる。 • すると、全体が 1 つの連結成分になることがわかる。 部分点解法 2 (10 + 20点) • 「辺にコストがあって、辺の集合を選び全体を 1 つの連結成分にす る選び方のうち、費用の合計値が最小となる選び方を求める問題」 に帰着することができました。 • 上記の問題は、「最小全域木問題」として知られています。 • クラスカル法やプリム法で効率的に計算することができます。 • 交易所の設置方法は全部で 2 𝑁 通りあり、すべてについて求めるこ とで答えを求めることができます。 • 注意点として、交易所の設置方法によっては解が存在するとは限り ません(元のグラフで、全体が連結でない場合など)。 部分点解法 3 (10 + 20 + 30点) • 最初に、交易所の頂点集合を選ぶ代わりに、仮想的な都市 X を用 意します。 • 都市 X と都市 𝑖 1 ≦ 𝑖 ≦ 𝑁 の間には、コスト𝑐𝑖 (交易所の設置コスト と一緒) の辺を張ります。 • 都市 1 から都市 𝑁 に関しては、交易所を置く代わりに、都市 X との 辺を選ぶという操作だと考えます。 X 1 2 3 … 𝑁 𝑐1 𝑐2 𝑐3 𝑐𝑁 部分点解法 3 (10 + 20 + 30点) • この処理をしたあと、良い状態であることと、都市 X を含めて全体で 連結であることが同値となります。 • このグラフで最小全域木問題を解けば解が得られます。 • 有効な候補は毎回 O(N + 𝑀) 本で、最大 O(𝑁) 回試すので、全体で O(𝑁(𝑁 + 𝑀)) となります。 X 1 2 3 … 𝑁 𝑐1 𝑐2 𝑐3 𝑐𝑁 満点解法 • 先ほどの部分点解法 3 で、プリム法やクラスカル法を用いて高速化 すれば満点となります。 問題D – 高橋君と木のおもちゃ 問題概要 • 有向木(のおもちゃ)が与えられます。 • 𝑀個ある各整数を、置くか置かないかをします。 • 木の頂点に置いたら、頂点は親に古い数字を送ります。 • 最終的に残る整数の合計を最大化してください。 • 1 ≦ 𝑁(頂点数) ≦ 5,000 • 1 ≦ 𝑀(候補数) ≦ 5,000 部分点解法 1 • すべての置き方(置かないを含め)を試します。 • (𝑁 + 1) 𝑀 通りを試すと答えが得られます。 考察 • 元からある数字について考えます。 • ある数字について、その数字が追い出されるなら、その数字を持っ ていた頂点の先祖となる頂点にあった数字もすべて追い出されてい ます。 • すると、追い出される数字を持っていた頂点の集合は、頂点 1 を含 む部分木となっているはずです。 • 逆に部分木(頂点数を𝑋とする)が決まると、部分木の深いところから 順に 𝑋 回おくだけで部分木のすべての整数を追い出すことができま す。 考察 • この場合、残せる数字は𝑋個だけです。 • 先ほどの方法だと、おいた数字すべてを残すことができるので、奥 候補の数字から、大きいのを𝑋個取り出せばよいです。 • すると、頂点 1 を根とする部分木の中で頂点数が𝑋であるものを0 ≦ 𝑋 ≦ 𝑁 ですべて求めることで計算できます。 考察+ 満点解法 • この計算は、各頂点 x に対して、その頂点 x を根する部分木で i 個 選ぶ方法を dp[x][i] とする動的計画法で計算できます。 • この計算は各頂点に対して、子の頂点数が s1,s2,s3, … ,sk である場 合に、O(s1s2 + (s1+s2)s3 + … + (s1+s2+…+s(k-1))sk)となります。 • これは一見 N の 2 乗に見えますが、 (s1+s2+…+sk)^2 より小さいこと がわかるので、頂点 1 で考えるとN の 2 乗で済みます。 A問題	 小石を取るゲーム	 問題概要	 • 袋にN個䛾小石が入っている。 • Antさん、Bugくん、Antさん...䛾順に交互に取っていく。 • Antさん䛿A個ずつ、Bugさん䛿B個ずつ小石を取る。 • どちら䛾ターン䛾後に袋が空になるかを求めよ。 • 制約	 • 1	≤	N,	A,	B	≤	1000	 解法	 • シミュレーションしましょう。 • カウンタ䛾変数を用意し、そこからAとBを交互に引 いていく。 • カウンタが0以下になったときにどちら䛾ターンだっ たかを出力する。 B問題	 特別賞	 問題概要	 • コンテストが行われ、N人䛾人が参加した。 • i位䛾人が全参加者䛾うち何番目に若いかが入力さ れる。 • 1位〜j位䛾人䛾うちK番目に若い人䛾順位を、K~N 䛾jに対して出力せよ。 • 制約 • 1	≤	N	≤	10^5	 40点解法	(N≤1000) • それぞれ䛾答えを毎回求める。 • 1位からj位まで䛾人䛾若さをソートして、K番目䛾要 素を見る。 満点解法	 • jを小さい方から順番に増やしていき、答えを更新し ていく。 • ある時点でK+1番目以降になった人䛿、それ以降K 番目になる事䛿ない。 • １人追加する度に、 – K+1番目以降だったらなにもしない。 – K番目以内だったら候補に加え、候補䛾中から一番老け ている人を候補から削除する。 • で、候補䛾うち最も老けている人䛾順位を出力する。 満点解法	 • それを実現するために䛿データ構造が必要。必要 な操作䛿、 – 要素を追加する – 要素䛾うち最も大きい値を取り出す • priority	queue（優先順位つきqueue） • 各操作をO(log	要素数)で行うことが出来ます。 • 言語によって標準ライブラリがあったりする䛾で調 べてみましょう。 C問題	 高橋王国䛾分割統治	 問題概要	 • 頂点数N䛾木が与えられる。 • 頂点vが取り除かれた時にできる連結成分䛾うち、 最も大きいも䛾を、各vについて求めよ。 • 制約 • 1	≤	N	≤	10^5	 30点解法	(N≤1000) • それぞれ䛾答えを毎回求める。 • 木䛾問題になれていれ䜀簡単。 • DFSなどをすれ䜀よい。 満点解法	 • とりあえず根付き木として考える。 • DFSしながら木DPをすれ䜀、子方向䛾部分木䛾サイ ズを求めることが出来る。 • しかし、親方向䛾部分木䛾サイズ䛿どうしたも䛾だ ろうか。 • →N-1-(子方向䛾部分木䛾サイズ䛾和)	 で求められる！ おまけ	 • 詳細について䛿省きますが、 • 部分木䛾サイズ䛾最大値を求める問題䛿、木䛾分 割統治を行う時に使ったりします。 D問題	 注文䛾多い高橋商店	 問題概要	 • N種類䛾商品がそれぞれA[i]個ある。 • 「k種類目䛾商品をx個選ぶとき、合計M個䛾商品を 選ぶ方法䛿何通りあるか」というクエリにQ回答えよ。 • 制約 • 1	≤	N	≤	2000	 • 1	≤	M	≤	2000	 • 1	≤	Q	≤	500000	 10点解法	(N,M,Q≤100) • 各クエリそれぞれでDPをする。 • DP[i][j]=i種類目まででj個選ぶ方法䛾個数 • 漸化式䛿 • DP[i][j]	=	ΣDP[i-1][j-a[i]]~DP[i-1][j]	 • 累積和を取っておけ䜀O(1)で更新できる。 30点解法	(N,M≤100) • 商品䛾順番を入れ替えても答え䛿変わらない • 商品i以外だけを使ったとき䛾DPテーブルという䛾を あらかじめ全て䛾iについて求めておく。 • 前処理：O(N^2M)	 • 各クエリ：O(M)	 • となり、30点を得ることが出来る。 80点解法(N,M≤2000,Q≤1000) • 各iごとに最初からDPをやり直している䛾が無駄っぽ い • 0~jまでを使ったとき䛾DPテーブルと • j~Nまでを使ったとき䛾DPテーブル • を持っておく。(要するに左側と右側䛾DPテーブル)	 • 各クエリにつき、２つ䛾DPテーブルを参照することで、 O(M)で答えを求めることが出来る。 満点解法	 • 各クエリにO(1)で答えなけれ䜀ならない。 • 商品i以外だけを使ったとき䛾DPテーブルという䛾を あらかじめ全て䛾iについて求めておきたい。 • 考察 • 商品䛾順番䛿関係がない • DP䛾漸化式䛿DP[i-1]における(部分)和䛾形式	 戻すDP • DP[i]からDP[i-1]を復元する。 • DP[i][j]	=	ΣDP[i-1][j-a[i]]~DP[i-1][j]	 • →	 • DP[i-1][j]	=	DP[i][j]-ΣDP[i-1][j-a[i]]~DP[i-1][j-1]	 • O(M)で復元できる！ • 商品䛾順番䛿変えても答え䛿変わらない䛾で、 DP[N]から、「商品i以外だけを使ったとき䛾DPテーブ ル」が各iについて復元できます。 AtCoder Regular Contest 027 解説 2014/8/2 1 A 問題 – 門限 問題概要 • 現在の時間 ℎ と分 𝑚 が与えられる。 • 後何分で 18 時 0 分かを求める。 • 0 ≦ ℎ ≦ 17 , 0 ≦ 𝑚 ≦ 59 ※標準的な入出力については、ABC004 の解説等を参照してください。 解法その 1 • 18 時まであと何時間何分かを求めて、その後分に変換する。 • 現在時刻が ℎ 時 𝑚 分なら、 ・ 𝑚 = 0 ⇒ あと 18 − ℎ 時間 ・ 𝑚 ≠ 0 ⇒ あと 17 − ℎ 時間と 60 − 𝑚 分 • 計算結果を 𝑎 時間 𝑏 分とすると、 a × 60 + 𝑏 分が答え。 • 最初に、現在時刻を 0 時ちょうどからの経過分数に変換して、1080 から引いても良い。 解法その 2 • 現在時刻から、1 分後、2 分後、…と 1 分ずつ加算して、18 時ちょうど になるまでに合計何回足したかを数える。 • どちらの方針にするかは、実装時間やバグの入りやすさなどを考慮 して選択 (個人差あり)。 B 問題 – 大事な数なのでZ 回書きまLた。 問題概要 • 0 から 9 までと、大文字アルファベットのみで構成された長さ 𝑁 の文 字列が 2 個与えられる。 • 大文字アルファベットを 0 から 9 までの整数に変換する処理を行っ た結果、両者が表す整数が一致した。 • 一致した整数として全部で何通り考えられるかを求めよ。 • 1 ≦ 𝑁 ≦ 18 部分点解法 • 答えとなる数字を全探索する。 • この場合、答えとして考えられないものは、 ・同じアルファベットに複数の数字が割り当てられている。 ・先頭に 0 が来ている。 となる場合なので、その場合を判定して、残ったものの総数が答えと なる。 満点解法 • 部分点解法では、計算量が O(10𝑁) となるので、𝑁が大きい場合に は時間が掛かり過ぎる。 • 一致しているという条件をうまく言い換えたい。 • ここでは、「グラフ」の概念を導入すると理解しやすくなる。 • それぞれの文字を頂点としたグラフを考える。 • 同じ数字でなければならない文字同士を辺で結ぶ。 • 同じ数字でなければならない文字同士というのは、同じ桁 (同じ位) にある文字同士のことである。(例えば、2 つの文字列がABCDとEFEH だった場合は、AE,BF,CE,DH 間に辺を結ぶ。) 満点解法 • 数字と文字が同じ桁にある場合は、その文字に、「その数字でなければな らない」という条件を付加する。 • 最上位にある文字については、さらに「0以外」という条件も。 • なお、この条件は衝突しない(衝突したら答えがなくなるため)。 • その後、各連結成分(辺同士で行き来できる頂点たち)について、 ・数字が割り当てられている⇒1 通り ・数字が割り当てられていない、かつ最上位⇒9 通り ・数字が割り当てられていない、かつ最上位でない⇒10 通り をそれぞれ掛け合わせると答え。 例(入力例 3 – PRBLMB と ARC027) • 文字を頂点としたグラフを考える。 P R A C B L M 例(入力例 3 – PRBLMB と ARC027) • 文字を頂点としたグラフを考える。 • 同じ数字になるもの同士を辺で結ぶ(PA,BC)。 P R A C B L M 例(入力例 3 – PRBLMB と ARC027) • 文字を頂点としたグラフを考える。 • 同じ数字になるもの同士を辺で結ぶ(PA,BC)。 • 文字と数字の割り当てを反映させる(L=0,M=2,B=7)。 P R A C B L M 0 2 7 例(入力例 3 – PRBLMB と ARC027) • 文字を頂点としたグラフを考える。 • 同じ数字になるもの同士を辺で結ぶ(PA,BC)。 • 文字と数字の割り当てを反映させる(L=0,M=2,B=7)。 • 最上位の情報も付ける。 P R A C B L M 0 2 最上位 7 例(入力例 3 – PRBLMB と ARC027) • 文字を頂点としたグラフを考える。 • 同じ数字になるもの同士を辺で結ぶ(PA,BC)。 • 文字と数字の割り当てを反映させる(L=0,M=2,B=7)。 • 最上位の情報も付ける。 P R A C B L M 0 2 最上位 7 9 通り × 10通り × 1 通り× 1 通り× 1 通り = 90 通り 補足 • グラフの連結判定には、union-find を利用すると効率的 & 実装しや すい。 • サイズが小さいので探索をしても良いが、union-find を知っていると 色々と便利なので、ぜひとも覚えておこう！ • 前回(ARC026)の解説にも載っているので、参考にしてください。 • http://www.slideshare.net/chokudai/arc026 C 問題 – 最高のトッピングにしような 問題概要 • スペシャルチケット 𝑋 枚と通常のチケット 𝑌 枚を持っている。 • 𝑁 個のトッピングがあり、トッピング 𝑖 は 𝑡𝑖 枚のチケット(うち 1 枚以 上はスペシャルチケット) と交換でき、嬉しさは ℎ𝑖 である。 • 同じトッピングは複数回入手できない。 • 嬉しさの合計値として最大なものを求めよ。 • 1 ≦ 𝑋 ≦ 300 , 0 ≦ 𝑌 ≦ 300, 1 ≦ 𝑁 ≦ 300 • 1 ≦ 𝑡𝑖 ≦ 600, 1 ≦ ℎ𝑖 ≦ 5,000,000 部分点解法 • この問題はナップサック問題の一種。 • 動的計画法を用いると効率的に解答することができる。 • dp[i][j][k] = (現在トッピング i まで処理しており、すでにスペシャルチ ケットを j 枚、通常のチケットを k 枚消費している場合での嬉しさの 合計値の最大値) とすると、 dp[i][j][k] = max{dp[i-1][j][k] , dp[i-1][j-m][k- t_i +m] + h_i (1 ≦ m ≦ t_i)} (細かい境界条件は割愛) • O(𝑋𝑌𝑁(𝑋 + 𝑌)) となる。 満点解法 • 先ほどの場合、交換可能なすべての組み合わせを試していたが、出 来る限りスペシャルチケットの消費数を抑えられるものを選んだほう がいいのでは? • 実際、消費枚数が最も少ない (m が最小) となるもののみを考慮して も最適解を得られる。 • 実はこの問題は、「チケットを 𝑋 + 𝑌 枚持っており、トッピングは最大 𝑋 個しか選べない場合の最大化」と同じ問題。 • dp[i][j][k] = (現在トッピング i まで処理しており、トッピングを j 個採用 しており、チケットを k 枚消費している場合での嬉しさの合計値の最 大値) とおく動的計画法なら O(𝑋𝑁(𝑋 + 𝑌)) となる。 D 問題 – ぴょんぴょんトレーニング 問題概要 • 𝑁 個の石があり、石 𝑖 からは ℎ𝑖 個先まで跳べる。 • 石 𝑠𝑖 から石 𝑡𝑖 までジャンプで移動する組み合わせが何個あるか、と いうクエリを 𝐷 個解け。 • 同じトッピングは複数回入手できない。 • 嬉しさの合計値として最大なものを求めよ。 • 1 ≦ 𝑁 ≦ 300,000 , 1 ≦ 𝐷 ≦ 5,000, 1 ≦ ℎ𝑖 ≦ 10 • 1 ≦ 𝑠𝑖 ＜𝑡𝑖 ≦ 𝑁 部分点解法 • この問題も動的計画法によって計算できる。 • dp[i]=(石 i までの行き方) とおくと、 dp[i] = (dp[i − j] ∗ 𝑓(i − j, i) 10 j=1 ) ここで、𝑓 𝑥, 𝑦 は𝑥 + ℎ𝑥 ≧ 𝑦なら 1 、そうでないなら 0 を取る関数とす る。 • 手前 10 項 (dp[i-1],dp[i-2],…,dp[i-10])を覚えておけば良い。 • 毎回 O(𝑁) で計算すれば O(𝑁𝐷) となる。 満点解法 • 毎回計算する際に、同じ部分を何回も使用していることに気がつく。 • 同じ部分を「平方分割」によって処理することを考える。 • 手前 10 項を覚えておけば次の項を計算することができることを利用 する。 • func(s,t,dp[s-1],dp[s-2],…,dp[s-10]) = dp[t],dp[t-1], … , dp[t-9] のそれ ぞれの値を、dp[s-1], dp[s-2], … , dp[s-10] を用いて変換する関数。 • func の返り値は 10 個ある。 どゆこと? • 例として dp[99] の値を知りたいときに、 dp[20],dp[19],dp[18], … ,dp[11] の値さえわかっていれば、 dp[99]=c(20,99,21) * dp[20] + c(19,99,21) * dp[19] + … + c(11,99,21) * dp[11] と表記できる。 ここで、c(x,y,z)=(x から y まで移動するものの中で、最初のジャンプで z 以上の石に移動するものの総数) となる。 • dp[98] から dp[90] までについても同様に計算すれば func(21,99, ,dp[20],dp[19],...,dp[11]) の完成となる。 func の計算について • c (s,t,u)は部分点解法と同じ方針で O(t-s) で計算できる。 • 「1 回目のジャンプで u 以上に移動する組み合わせ」としなければな らないことに注意 (同じジャンプ重複して数えてしまう)。 • c (s,t,u) は、各 func に対して最大 100 種類計算すれば OK。 • func の計算は、1 つの func につき O( 𝑁) (100* 𝑁) となる。 満点解法 • func(𝑘 𝑁, (𝑘 + 1) 𝑁) (0 ≦ 𝑘 ≦ 𝑁) を計算しておき、各トレーニン グについて、𝑠𝑖 から 𝑁 の倍数になるまで部分点解法と同じ DP(1)→func で 𝑁 個ずつ飛ばせるだけ飛ばす(2)→ 𝑡𝑖になるまで部 分点解法と同じDP(3) • func の計算は、1 つの func につき O( 𝑁) なので、全体で O(𝑁) とな る。 • この方針でfunc を求めた後は O(𝐷 𝑁) となる。 𝑠𝑖 𝑡 𝑝 𝑁 (𝑝 + 1) 𝑁 𝑞 𝑁 𝑖 (1) (3) (2) (2) (2) (2) (中略) … 補足 • func は 10 × 10 行列として表現できる。 • (𝑛 × 𝑛行列)* (𝑛 × 𝑛行列)*…* (𝑛 × 𝑛行列)* (𝑛 要素ベクトル) の計算 において、* の個数を 𝑚 とする。このとき、 ・* を左から処理→行列*行列=行列を繰り返し、O(𝑛 3𝑚) ・* を右から処理→行列*ベクトル=ベクトルを繰り返し、O(𝑛 2𝑚) となり、この問題でも速度に 10 倍もの差が出る。このため、ベクトル を利用した計算をしたほうが速くなる。func を利用した計算の際には 注意。 AtCoder Regular Contest 026 解説 AtCoder株式会社 2014/6/28 1 A問題 ダイナミックなポーズ 問題概要 • 高橋君は１問の問題を解くのに ・普段：A分かかる ・ダイナミックなポーズをとりながら：B分かかる • 体力の消耗が激しいので、ダイナミックなポーズを とりながら解ける問題は５問まで。 • N問の問題を解くのにかかる最短時間は？ • 1 㱡 N 㱡 10, 1 㱡 B < A 㱡 60 1/4 解法 • B < Aなので、可能な限りダイナミックなポーズを とりながら解いたほうが良い。 • じゃあ答えは、5*B+(N-5)*A？ （５問をダイナミックなポーズをとりながら解き、 残りの問題を普段通りに解く） →　それは間違い 2/4 解法 • 5*B+(N-5)*A はダメ。 • Nが5より小さい時はダイナミックなポーズはN回し かしなくて良い。 • というようにNが５より大きいか小さいか、 つまり、５回の上限までダイナミックなポーズをと るかどうかで場合分けをしてあげればいい。 if(N < 5) answer = N*B; else answer = 5*B+(N-5)*A; 3/4 別のやり方 • のようにダイナミックなポーズをとる回数を計算し てから答えを計算するというような方法も考えられ ます。 num_dynamic = min(N,5); answer = num_dynamic*B + (N-num_dynamic)*A; 4/4 ARC026解説 B:完全数 B-問題概要 ● 与えられた整数　が完全数か、不足数か、過剰 数か、判定せよ ● 部分点1 ● 部分点2 N 1≤N≤105 1≤N≤1010 B-基本的発想 ● 約数を全て調べて、総和を求めて、元の数字と の大小を調べたい ● 約数を出来るだけ速く全列挙するのが目標 ● 「自分以外の約数」というのが少し厄介 ● 自分を含めた約数の総和を求めて自分の2倍と の大小を比べれば面倒な処理はしなくて良い B-約数の全列挙1 ● 整数 の約数は 以下なので、 以下の全ての整 数について、それが の約数かどうかを調べれ ば良い ● 計算量は – 部分点1が得られる N N N N O(N) B-約数の全列挙2 ● が の約数ならば、 も の約数 ● か の片方がわかれば、もう片方もすぐに 分かる。 – 小さい方だけを調べれば良い ● となる条件は ● √ 以下の約数を調べるだけで良い ● 計算量は (√ ) – 満点が得られる A A A≤N / A A N N / A N N / A A 2≤N N O N B-注意点 ● が平方数の時 となる が存在する – 誤って を2回足さないように気をつけなければな らない ● 小課題2の入力が明らかにint型に収まらないの で、C等の言語を使っている方は気をつけま しょう N A=N / A A A ARC024解説 C:蛍光灯 C-問題概要 ● 長さがLの廊下にN個の蛍光灯がある ● i番目の蛍光灯はc_iの費用で点ける事ができる ● i番目の蛍光灯をつけると西からの距離がl_i以上 r_i以下の範囲が照らされる ● 廊下全体を照らすための最小費用を求めよ ● 1 ≦ N ≦ 100,000 ● 1 ≦ L ≦ 100,000 ● 1 ≦ c_i ≦ 100,000 C-部分点1 ● 蛍光灯をl_iが小さい順にソートする – 以降iにはこのソート後のインデックスを採用する ● dp[i][j] = i番目以前の蛍光灯を使って西から距離 ｊのところまでの全体を照らす費用の最小値 – という値を動的計画法で求める ● もしjがl_iとr_iの間にあるならば dp[i][j] = min{dp[i-1][k] + c_i (kはl_iとr_iの間)} ないならば dp[i][j] = dp[i – 1][j] という漸化式が成り立つ C-DPの更新の仕方 ● l_iとr_iの間のjに対して dp[i][j] = min{dp[i-1][k] + c_i (kはl_iとr_iの間)} ● kをl_iからr_iまで順番に動かすときに、今まで 通過したdp[i-1][k]の最小値を更新していく – dp[i][k] = その最小値 + c_iとなる ● dp[i]を全て求めるのにO(L) ● iはN種類なので、合計でO(NL) – 部分点1(N,L≦3,000)が得られる C-DP擬似コード for(int i = 0;i < n;i++){ //dp[i-1][k]の最小値を保存する変数tmpmin int tmpmin = 99999999; for(int j = 0;j <= L;j++){ if(j < l[i] || k > r[j]){ dp[i][j] = dp[i - 1][j]; } } for(int k = l[i];k <= r[i];k++){ dp[i][k] = min(dp[i][k], tmpmin + c[i]); tmpmin = min(tmpmin, dp[i][k]); } } C-考察 ● 先ほどのDPは2次元配列を使っているが、dp[i] はdp[i – 1]しか参照しない – 1次元配列で管理することができる ● 新しいdp配列 – dp[i] = 西端から距離iのところまでの全体を照らす のに必要な費用の最小値 C-考察 ● 実際に費用が最小になる蛍光灯の置き方を考え てみる ● 必ずr_iがとなりの蛍光灯の区間（両端含む）と 重なる – dpではr_iの位置のみ更新すれば良い C-擬似コード2 for(int i = 0;i < n;i++){ //dp[i]の最小値を保存する変数tmpmin int tmpmin = 99999999; for(int k = l[i];k <= r[i];k++){ tmpmin = min(tmpmin, dp[i][k]); } dp[r[i]] = min(dp[r[i]], tmpmin + c[i]); } C-高速化 ● 操作の種類は – dp[r[i]]の更新 – dp[l[i] ～ r[i]]のなかの最小値を求める ● これはRMQなのでセグメントツリーがうまく 利用できる C-擬似コード3 for(int i = 0;i < n;i++){ int tmp = getmin(l[i], r[i]) //dp[l[i]～r[i]]の最小値をsegtree等で求める setnum(r[i], min(r[i], tmp + c[i])); //dp[r[i]]の値を更新 } C-入出力例3図解 C-入出力例3図解 C-入出力例3図解 C-入出力例3図解 C-入出力例3図解 C-入出力例3図解 C-入出力例3図解 C-入出力例3図解 C-入出力例3図解 C-入出力例3図解 C-高速化 ● 各蛍光灯についてO(logL)でdp[r[i]]を更新する ● 計算量はO(NlogL) – 満点が得られる C-参考 ● セグメントツリーに似たデータ構造でBITとい うものがある – 比較的楽に実装できる ● BITは基本的にRMQはできないが、いくつかの 制約のもとで処理できる 1.値の更新は、もとより値が小さくなるもののみ 2.求める範囲の左端は0でなければならない ● 今回1つめの条件は満たしている ● 2つめの条件を満たすようにすればBITを使うこ とができる C-参考 ● 実はmin(l[i], r[i]) は　min(l[i], L)としてもよい – 予めソートしてあるので、i番目の蛍光灯を見てい る時、l[j] > l[i]となる蛍光灯jはまだ処理されてい ない – l[i] ～ Lと重なっている蛍光灯は、l[i] ～ r[i] と重 なっている蛍光灯のみであり、その他余計な蛍光灯 は重なっていない ● よってL側を片端とするBITでACすることがで きる ● 計算量はセグメントツリーと同様 D問題 道を直すお仕事 問題概要 • N頂点M辺のグラフが与えられる • 各辺はC,Tの二つの値を持っている • グラフが連結になるように辺を選ぶとき、 Cの総和/Tの総和 の最小値は？ • 1 㱡 N,M 㱡 10^4, 1 㱡 Ci,Ti 㱡 10^6 1/13 20点解法 (M 㱡 16) • それぞれの辺を修理するかどうかを全て試す • 各辺につき、する/しないの２通りがあるので全部 で2^M通りのパターンがあり得る • グラフが連結になるような辺の選び方のうち、 Cの和/Tの和が最小となるものが答え 2/13 連結判定 方法１ • 適当な頂点を選び、その頂点を含む連結成分の大き さをDFSなどで計算し、それがNであれば連結 bool used[N]; // falseで初期化 int dfs(int v){ if(used[v]) return 0; used[v] = true; int count = 1; for(Edge e : vから出ている辺){ count += dfs(e.to); } return count; } 連結成分の大きさを求める例： 3/13 連結判定 方法２ • 以下のアルゴリズムのように、連結成分を集合とし て管理する • これを実現するためのデータ構造として、 Union Find 木を使う 各頂点に対し、その頂点のみを含む集合を作る for(Edge e : 修理することにした辺){ e.fromが属する集合とe.toが属する集合を合併する } 全ての頂点が同じ集合に属しているかをチェックする 4/13 Union Find 木 • 以下の２つの操作が出来るデータ構造 ・ある要素がどの集合に属しているかを調べる ・２つの集合を合併する • 要素を頂点とした木構造で集合を管理する • 各頂点は親への辺を持っておく • 根の要素をその集合の代表と考える • 詳細は以下のスライドが分かりやすいと思います http://www.slideshare.net/iwiwi/ss-3578491 5/13 Union Find 木 • 実装例 (ならし計算量O(α(N))) int parent[N]; void init(){ for(int i = 0; i < N; ++i) parent[i] = -1; } int root(int x){ if(parent[x] == -1) return x; return parent[x] = root(parent[x]); } void unite(int x, int y){ x = root(x); y = root(y); if(parent[x] < parent[y]) swap(x,y); if(parent[x] == parent[y]) parent[x]--; parent[y] = x; } 6/13 20点解法 (M 㱡 16) • 辺の選び方を全て試すためにはビット演算を利用す ると書きやすい • あわせて計算量はO(2^M * N)となり、この部分点 を得ることが出来ます for(int i = 0; i < 1<<M; ++i){ // 選び方を全て試す for(int j = 0; j < M; ++j){ if((i>>j&1) == 1) j本目の辺は今選ばれている } } 7/13 満点解法 (M 㱡 10000) • 答えで二分探索 • ΣCi / ΣTi 㱡 x となるような最小のxが答え • 小数の二分探索は収束判定が難しいので、 50回だけ探索するというようにすると良い。 8/13 二分探索 • ΣCi / ΣTi 㱡 x を式変形をすると・・・ • ΣCi / ΣxTi 㱡 1 → ΣCi 㱡 ΣxTi → ΣCi-xTi 㱡 0 • 辺ごとに独立して計算できるようになる！ 9/13 二分探索 • ΣCi-xTi 㱡 0 を満たすような辺の選び方があるかど うかを判定したい • Ci-xTi 㱡 0となる辺は全て選んで良い • グラフが連結になるように、残ったCi-xTi > 0の辺 からいくつかの辺を選ぶ。 → 最小全域木問題のアルゴリズムが使えそう 10/13 クラスカル法 • クラスカル法：最小全域木を求めるアルゴリズム 連結成分の管理にはUnion Find 木を使うと良い answer = 0 for(Edge e : 辺をコストの昇順に){ if(e.fromとe.toが違う連結成分に属している){ answer += e.cost e.fromの連結成分とe.toの連結成分を合併する } } 11/13 最小コストを求める • 今回の問題は最小全域木問題とは少しだけ違います が、似たようなアルゴリズムで解くことが出来ます answer = 0 for(Edge e : 辺をコストの昇順に){ // コスト = c-xt if(e.fromとe.toが違う連結成分に属している または e.cost < 0){ answer += e.cost e.fromの連結成分とe.toの連結成分を合併する } } 12/13 満点解法 (M 㱡 10000) • 二分探索で探索する回数をKとすると、 • 計算量はO(K M log M)となり、Kが100程度でも 満点を得ることが出来る。 13/13 ARC #025 解説 解説:城下 慎也 (@phidnight) A 問題 – ゴールドラッシュ 問題概要 • 7 日間かけて stove 君が鉱山採掘をする。 • それぞれの日に砂漠にある鉱山かジャング ルにある鉱山から採掘を行う。 • 各日ごとにどちらの鉱山でどれだけ採掘でき るのかが異なる。 • 得られる金の合計値を最大化せよ。 解法 その1 • 砂漠かジャングルをそれぞれの日に選ぶ組 み合わせは全部で 2 7 = 128 通りなので、す べての組み合わせについて全探索して最大 値を求めることで解を得ることができる。 解法 その2 • すべての組み合わせを見なくても、それぞれ の日についてより多くの金を得られる鉱山を 貪欲に選び続ける方針でも最適解を得ること ができる。 • この解法だと O(採掘日数) の答えになるので、 もっと採掘日数が多い場合でも高速に解を求 めることができる。 • 今回はどちらの解法でも解けるので、実装の しやすい方とかを選ぶと良い? B 問題 – チョコレート 問題概要 • 縦 𝐻× 横 𝑊 のマス目が与えられる。 • ブラックチョコとホワイトチョコが市松模様を構 成している。 • 各マスごとに濃度が定まっている。 • ブラックチョコのみの濃度合計とホワイトチョ コのみの濃度合計が一致しているような長方 形の面積最大を求めよ。 • 1 ≦ 𝐻 ≦ 100 , 1 ≦ 𝑊 ≦ 100 方針 • 純粋に、すべての長方形について検討してみ ると、O( 𝐻𝑊 3 )となり、かなり時間がかかっ てしまう。 • うまくまとめて計算することで、高速に計算し たい。 • 白と黒を同時に考えるのをやめて、白と黒を 分離してみよう！ 方針 3 1 4 1 5 9 2 6 5 3 5 8 • 例えば、上のようなチョコレートの配置におい て、 方針 3 1 4 1 5 9 2 6 5 3 5 8 • 例えば、上のようなチョコレートの配置におい て、次のように黒のみと白のみ(相方の色の 場所は 0 にする)分解する。 3 0 4 0 0 9 0 6 5 0 5 0 0 1 0 1 5 0 2 0 0 3 0 8 解法 • すると、長方形が条件を満たすことと、長方 形が指定する領域内の黒合計(長方形になっ ている)と白合計(長方形になっている)が一致 することが同値であるようになった。 • 長方形領域にある数字の合計を高速に計算 する方法である、累積和が使用できる！ • 累積和を用いることで、 O( 𝐻𝑊 2 )になる。 おまけ • ホワイトチョコの場所を符号反転させると、条 件を満たす長方形領域では濃度合計値が 0 になる。 • この方法だと累積和 1 個で済む。 • どちらかお好きな方で！ 解法 • すると、長方形が条件を満たすことと、長方 形が指定する領域内の黒合計(長方形になっ ている)と白合計(長方形になっている)が一致 することが同値であるようになった。 • 長方形領域にある数字の合計を高速に計算 する方法である、累積和が使用できる！ • 累積和を用いることで、 O( 𝐻𝑊 2 )になる。 C 問題 – ウサギとカメ 問題概要 • 頂点数 𝑁 で辺数が 𝑀 のグラフが与えられる。 • (目的地, ウサギのスタート地点, カメのスター ト地点) を頂点から互いに異なるように選ぶと き、カメがウサギより真に先に到着する組み 合わせの総数を計算せよ。 • 3 ≦ 𝑁 ≦ 2,500 , 2 ≦ 𝑀 ≦ 3,000 ウサギとカメの戦略 • ウサギもカメも、できるだけ早く目的地につけ ばいいので、どちらも最短経路を通ることにな る。 • 目的地を固定しておけば、目的地からそれぞ れの点への最短経路長を 1 回計算して知っ ておくことで、ウサギとカメの割り当てごとに 最短経路を計算する必要がなくなる。 全探索 • 上記の方針を実装しても、そもそも 3 つの組 の選び方が O(𝑁 3 ) あるので間に合わない。 • うまくまとめて計算したい。 • 2 つの手順を施すことで実現してみよう！ 手順 1 • それぞれの点について考慮するときに、調べ る順番を長さの短い順に調べる方針にしても 問題ない。 • あらかじめ最短経路長のリストをソートしてお く。 手順 2 • ウサギにとっての最短経路長を X, カメに取っ ての最短経路長を Y とすると、カメが真にウ サギより先に到着するためには、 X/R > Y/T が成立しなければならない。 • 両辺に RT をかけることで、XT > YR が得られ る。 • カメの最短経路長を固定すれば、X がいくつ 以上である必要があるかがわかる。 解法 • 目的地ごとに最短経路長のリストを求めて、 ソートしておく。 • カメの位置を固定すると、ウサギは特定の最 短経路長以上である必要が出てくる。 • その領域は必ずリスト上で連続した領域にな るので、二分探索やしゃくとり法で計算できる。 備考 • 同時についた場合に注意。 • 組に同じ地点を選べないことに注意。 • カメがウサギより速い場合があることに注意。 特に同じ地点を選べないことに絡むケースが ある。 • 答えは 32 bit 整数に収まるとは限りません。 D 問題 – コンセント 問題概要 • 縦 𝐻 ×横 𝑊 の細長いコンセントが与えられ る。 • 1 × 1 のコンセントキャップを着脱する。 • 1 × 2 あるいは 2 × 1 のコンセントプラグを 0 個以上差し込む方法の総数を 10^9+7 で割っ た余りを計算せよ。 • 1 ≦ 𝐻 ≦ 2 , 1 ≦ 𝑊 ≦ 10^11 満点解法(別解) • 出現回数から算出したハッシュ関数を使用す ることでも高速に計算できる。 • ただし、ハッシュの衝突に注意。 • 複数キー用意するとより安全。 部分点解法 その1 • それぞれの操作後の盤面において、端から 順に置く方針とする。 • X 列目を検討する際、 X-1 列目の埋まり方さ え見ればそれ以前の置き方を参照する必要 はない。 • Bit DP で計算することができる。 • O(𝑊𝑁2 2𝐻) などになる。(実装による) 部分点解法 その2 • Bit DP で計算できるという方針は崩さずに考 える。 • 毎回 1 箇所しか更新しないのにいつも幅𝑊を 見るのは勿体ない。 更新 部分点解法 その2 • Bit DP で計算できるという方針は崩さずに考 える。 • 毎回 1 箇所しか更新しないのにいつも幅𝑊を 見るのは勿体ない。 • 幾つかのバケットに分けて計算すると効率よ い。 更新 部分点解法 その2 • バケットが保存するべき状態: ・左端の使用状況 ・右端の使用状況 を満たした場合での組み合わせ数。 • 全体の計算においては、各バケットの使用状況 の組み合わせと接合部のコンセントプラグの組 み合わせと参照してマージする。 • 平方分割だと O( 𝑊𝑁2 4𝐻) (実際は実装による) の計算量になる。 補足 • 平方分割の方針の代わりに segment-tree の 方針でも計算することができる。 • 後述の満点解法では、segment-tree を用い た場合を設定してある。 満点解法 • 𝑊 がとんでもなく大きい場合、メモリとして確 保することすらできなくなる。 • しかしながら、そのほとんどは何も操作を施さ れていない区間で構成されている。 • この性質をうまく用いることはできないだろう か? 満点解法 • segment tree のノードをすべて生成する方針 だときつそう。 満点解法 • segment tree のノードをすべて生成する方針 だときつそう。 • キャップの生成したことのない場所を打ち切 る segment tree だとサイズは OK になる。 満点解法 • segment tree のノードが存在する場所は通常 通り計算すれば良い。 • そうではない場所の場合の計算結果を知りた い。 • それぞれの長さについて予め計算しておくか、 2 の累乗の長さのみを前計算しておいて使い まわす方針で対策できる。 • O(𝑁 log 𝑊 2 4𝐻) 等の計算量になる。 ARC024解説 A:くつがくっつく A-問題概要 ● 左足の靴がL足、右足の靴がR足あり、それぞれ のサイズが与えられる ● 両足のサイズが同じになるようペアを作ると き、最大で何組のペアを作成できるか？ ● 1 ≦ L, R ≦ 100 ● 10 ≦ 靴のサイズ ≦ 40 A-問題の分割 ● あるサイズの靴が、違うサイズの靴のペアを作 成できるかどうかに影響しないので、同じサイ ズどうしに分けて独立の問題として解いて良い ● サイズ に対して、左足が 足、右足が 足あ るとき、最大で何組のペアを作成できるか？ – 明らかに と の最小値を取れば良い S LS RS LS RS A-分割の仕方 ● あるサイズの靴がいくつあるか数える – L[i] := サイズ i の左足の靴がいくつあるか – R[i] := サイズ i の左足の靴がいくつあるか – 入力のたびにインクリメントする事によって求まる A-まとめ ● 各サイズについて左右いくつずつあるか数える ● 各サイズについていくつペアが作れるかを調べ る – L[i]とR[i]の最小値を取ることによって求まる ● それらの総和が答えとなる ARC024解説 B:赤と黒の木 B-問題概要 ● 環状に並んだ赤もしくは黒の木がN個ある ● 1日ごとに隣の状況をみて色が変化する – 自分と両隣の色が同じなら異なる色に変化 ● 変化がなくなるまでの日数を求めよ ● 3 ≦ N ≦ 100,000 B-実験 ● 見慣れないややこしい設定なので、いくつか実 験して様子を観察してみる – 異なる色が隣り合うところ 　…　　　　　　　　… 　…　　　　　　　　… 　…　　　　　　　　… B-実験 ● 見慣れないややこしい設定なので、いくつか実 験して様子を観察してみる – 同じ色が長く連続するところ 　…　　　　　　　　… 　…　　　　　　　　… 　…　　　　　　　　… B-実験 ● 隣に異なる色がいる木はそれ以降ずっと変わら ない – 連続する同じ色の塊にわけて考えて良い ● X個連続して同じ色が並ぶと ［(X-1) / 2］日後 に止まる – ただし［x］はxを超えない最大の整数を表す ということがわかる B-環状 ● どうやら、連続する部分を数えて適当な演算を し、最大値を取れば答えが出るらしい ● しかし、木が環状に並んでいるので少しややこ しい ● 環状ではなくしたい – 適切な場所で切り、1列に変換する ● 適切な場所とは？ – 異なる色が隣り合っているところ B-コーナーケース ● 「違う色が隣り合っているところ」が無いケー スがありうる – 全部赤、もしくは全部黒 ● この場合は永久に終わらない(入出力例3） ● 他とは別に処理しなければならない B-まとめ ● 全部同じ色かどうか調べる – 全部同じだったら出力は -1 ● 異なる色が隣り合う場所で切り1列にする ● 同じ色が連続する塊に分け、それらの色が変わ らなくなるまでの日数を求める – 長さがXならば［(X-1) / 2］日後 ● それらの最大値が答えとなる ARC #024 C 問題解説 解説:城下 慎也 (@phidnight) 問題概要 • 長さ 𝑁 の文字列が与えられる。 • ある長さ 𝐾 の(連続)部分文字列を 2 箇所で 取る。 • 両者が共通部分を持たず、かつ一方が他方 のアナグラムとなっているものがあるか。 • 例: abcdbcae だと、 abcdbcae という 2 箇所 abc と bca は共通部分を持たず、かつ一方が 他方のアナグラムとなっている。 • 1 ≦ 𝐾 ≦ 𝑁 ≦ 100,000 部分点解法 その1 • アナグラムかどうか判定する 2 箇所の候補す べてを考えてみる。 • 開始点は左から 1 番目～ 𝑁 − 𝐾 + 1 番目ま でが選べるので、 𝑂(𝑁 2 ) 通りの組み合わせ がある。 • 各組み合わせで 𝐾! 通りのアナグラムの割り 当てがあるので、全て試す方針で𝑂(𝑁 2𝐾!) 。 これで 15 点が得られる。 部分点解法 その2,3 • アナグラムであることと、各文字の出現回数 が一致していることが同値であることを利用 する。 • 1 文字ずつ数えて出現回数を見る方針だと全 体で𝑂 𝑁 2𝐾 で計算できる。30 点が得られ る。 • 上記の計算で、文字種ごとの累積和を用いる と𝑂 𝑁 2 になり、 45 点が得られる。 満点解法に向けて • 部分点解法で行っていたことは、 𝑁 − 𝐾 + 1 通りの始点候補のうち、始点から 𝐾 文字所 得した際の各文字の出現回数が一致する 2 箇所が存在するか判定することであった。 • 各文字(26通り)の出現回数は、これを大きい 整数と思うことで、次の問題に帰着することが できる。 帰着した問題 • 入力: 整数 𝑁 と 𝑁 個の整数。 • 出力: 𝑁 個の整数のうち 2 回以上出てくる整 数が存在するか(YES or NO)。 • この問題は、すべてのペアを試すと𝑂 𝑁 2 の 計算量となるが、ソートして隣り合うペアのみ を見る/二分探索木を使用することで 𝑂 𝑁 log 𝑁 で計算できる。 満点解法 • 累積和などで、 𝑁 − 𝐾 + 1 通りの始点候補に 対する、そこから 𝐾 文字とったときの各文字 の出現回数をO 𝑁 で計算しておく。 • 求めた値をキーとしてソートをするか、二分探 索木を用いることで𝑂 𝑁 log 𝑁 で判定する。 • 全体で𝑂 𝑁 log 𝑁 となり、100点が得られる。 満点解法(別解) • 出現回数から算出したハッシュ関数を使用す ることでも高速に計算できる。 • ただし、ハッシュの衝突に注意。 • 複数キー用意するとより安全。 ARC024解説 D:バス停 D-問題概要 ● 1,000×1,000の座標上にN個バス停が置かれる ● 1つのバスはx軸かy軸のどちらかに平行な移動 しかできない – バス停で乗り換えればいろいろなところに行ける ● どのバス停間も乗り換えのみで総移動距離がマ ンハッタン距離と等しくなるような移動ができ るようにする ● 合計が10,000個を超えないように新たなバス 停を追加せよ ● 1 ≦ N ≦ 1,000 D-入力例2図解 ● 入力例2 before after D-入力例3図解 ● 入力例3 before after D-考察 ● 全ての格子点にバス停を置けば明らかに条件を 満たす – 格子点は1,000×1,000個あり、全て埋めると制約 を軽く超えてしまう ● 追加前に1つもバス停がない列や行はないもの として考えて良い – 座標圧縮ができる D-座標圧縮 ● 座標圧縮とは – 必要のない座標を無視して、位置関係を変えないよ うに、新たに小さな座標に置き換えること before after D-座標圧縮 ● 圧縮の仕方 – 圧縮前後で頂点の位置関係が変わっていなければ良 い – 位置関係というのはxやyの大小関係 – 出てくるxの種類について小さい順に1から番号を 振っていく、それを圧縮後の座標とすればよい ● 例: {3, 5, 10, 23} → {1, 2, 3, 4} – yについても同様 D-座標圧縮 ● 圧縮後の性質 – xの値とyの値が全て違ったとしても、それぞれたか だかN種類しかない – 圧縮後はN*Nより以下のサイズになる D-部分点1 ● 座標圧縮した後に、すべての格子点をバス停で 埋める ● 合計で最大N*N個のバス停を置くことになる ● 部分点1(N ≦ 100) 分の点数を獲得できる D-考察2 ● さすがに格子点を全部埋めるのは無駄が多すぎ る ● 1列だけというのはどうだろう？ ● ある1列を選んでその列すべての格子点にバス 停をおいたときどうなるか考える D-1列を埋める ● 入力例2の真ん中の列を埋めてみる D-1列を埋める ● 入力例2の真ん中の列を埋めてみる ● 列の左右に注目 D-1列を埋める ● 入力例2の真ん中の列を埋めてみる ● 列の左右に注目 ● 真ん中の列は完全に埋ま っているので右図のよう な黄色い線が引ける D-1列を埋める ● 入力例2の真ん中の列を埋めてみる ● 列の左右に注目 ● 真ん中の列は完全に埋ま っているので右図のよう な黄色い線が引ける ● 列をまたぐ移動はすべて 条件をみたすことになる D-1列を埋める ● 入力例2の真ん中の列を埋めてみる ● 列の左右に注目 ● 真ん中の列は完全に埋ま っているので右図のよう な黄色い線が引ける ● 列をまたぐ移動はすべて 条件をみたすことになる ● 左と右を別々に考えて良 くなる D-1列を埋める ● 入力例2の真ん中の列を埋めてみる ● 列の左右に注目 ● 真ん中の列は完全に埋ま っているので右図のよう な黄色い線が引ける ● 列をまたぐ移動はすべて 条件をみたすことになる ● 左と右を別々に考えて良 くなる – 良いアルゴリズムがある D-1列を埋める 分割統治 D-分割統治 ● ある問題のサイズNのバージョンを解くのに必 要な計算の回数をf(N)とする – f(1) = O(1)が成り立つとする ● サイズNの問題はO(N)の計算でサイズがN/2の 問題2つに分割することができるとする – f(N) = O(N) + 2 * f(N/2)　となる ● これを解くとf(N) = O(N log N)となる D-分割統治 ● イメージ図 ● 横に見ると、どの段も総和がN ● サイズ1になると分割が終わるので高さはlogN D-分割統治 ● 分割統治は計算量を減らすテクニックだが、今 回は置くバス停の量を減らすテクニックとして 応用できる D-想定解 ● 左右で個数が2等分されるような列を選ぶ – N個のバス停を設置 ● N/2個のバス停の処理を2回する ● 同様に分割統治の要領で再帰していく ● サイズが半分になっても座標は大きいままなの で、毎回座標圧縮することを忘れないように ● 合計でNlogN個のバス停を置くことになる ● NlogN ＜ 10,000なので満点が得られる D-参考 ● 次のような処理をしても、条件に合うバス停の 置き方ができる ● 登場するxの値を管理する二分探索木を作る ● yの値が小さい順に予め設置してあるバス停を 見ていき、その二分探索木でその点のxの値を 探索する ● 探索の過程で通過した頂点の値を[a1, a2...]とす る ● (a1, y) (a2, y)... を追加していく D-図解(入力例3) D-図解(入力例3) D-図解(入力例3) D-図解(入力例3) D-図解(入力例3) D-図解(入力例3) D-図解(入力例3) D-図解(入力例3) D-参考 ● 先の例のように完全二分探索木を使えば探索時 に触れる点の個数がたかだかlogN個なので個数 制限にもひっかからない – AC – よく考えると分割統治の解と同値であることがわか る ● 実は使う二分探索木は現れるxの値だけでな く、1～1000のすべての値を持っていても大丈 夫 – 座標圧縮や再帰がなくなるので、実装が分割統治よ り楽になる D-参考（発展） ● 完全二分探索木ではない二分探索木を使うこと も可能 ● 実は、「回転」と呼ばれる操作が許されるので 平衡二分探索木でも可能 – ただし定数倍が重く、個数制限に引っかかりWA ● なぜ可能かの証明は難しいので割愛 – Geometry of binary search treesなどのキーワード で検索すると詳細な情報が出てくる AtCoder Regular Contest 023 解説 AtCoder株式会社 2014/5/17 1 A問題 経過日数 問題概要 • y年m月d日から2014年5月17日までの経過日数を計算せよ • ただし以下の公式は使ってよい 西暦1年1月1日からy年m月d日までの経過日数は、1月2月の 場合はそれぞれを前年の13月14月と扱った上で、以下の通り 解法 • 適当な日付からある日付までの経過日数を計算できれば、 それらの引き算で任意の2つの日付間の経過日数が計算できる • したがって、それを計算する • 𝑥 はxが正なら、小数点切捨てと等価なことに注意 (intにキャストするなり何なりで実現できる) B問題 謎の人物X 問題概要 • R×Cのマス目の左上のマスから、ちょうどD回「隣 のマスに移動」することで行けるマスに書いてある 数字のうち、最も大きいものを求めよ。 • 部分点（60点）：R,C 㱡 100, D 㱡 200 • 満点：R,C 㱡 1000, D 㱡 2000 部分点（60点）R,C 㱡 100, D 㱡 200 • 「i 回移動した時に行けるマス」をシミュレーショ ンしてみる。 • 「i 回移動した時に行けるマス」は、「i-1 回移動し た時に行けるマス」が隣にあるようなマス。 シミュレーション o 0回移動 o o 1回移動 o o o o 2回移動 o o o o o 3回移動 o o o o o o 4回移動 o o o o o o 5回移動 部分点（60点）R,C 㱡 100, D 㱡 200 • あとは、「D回移動した時に行けるマス」のうち、 書いてある数字が最大のものを求めれば良い。 • 計算量はO(マスの個数×D)くらいなので、この部分 点では時間内に答えを求めることが出来ます。 満点 R,C 㱡 1000, D 㱡 2000 • 「D回移動した時に行けるマス」について考察して みる。 • マス(i,j)に行くことが出来る条件は、 ・i+j 㱡 D (遠すぎると行けない) ・i+jとDの偶奇が一致している • の２つとなっています。 • ２つめの条件について少し説明します。 o o o o o 3回移動 • 図のようにマスを市松模様に塗ってみます。 • 一回の移動では、 ・白いマスからは黒いマスにしか ・黒いマスからは白いマスにしか 移動することが出来ません。 • この構造から、偶奇性が生み出されていて、先ほどの ような条件が成り立ちます。 i+jとDの偶奇について o o o o o 満点 R,C 㱡 1000, D 㱡 2000 • 各マスについて条件をチェックし、条件を満たすマ スのうち、書かれている数字が最大であるものを求 めれば良い。 • 計算量はO(マスの個数)くらいなので満点を取るこ とが出来ます。 C問題 タコヤ木 問題概要 • (広義)単調増加な数列の一部が与えられるので、元 の数列としてありうるものは何通りか求めよ。 • 部分点（50点）：N 㱡 100, Ai 㱡 100 • 部分点（80点）：N 㱡 2000, Ai 㱡 2000 • 満点：N 㱡 2000, Ai 㱡 10^9 部分点（50点）N 㱡 100, Ai 㱡 100 • DP[i][j] = i番目の数字がjである場合の数 • というDPをします。 • 直前の数字が今の数字以下であればいいので、漸化 式は以下のようになります。 • DP[i+1][j] = sum(DP[i][0]~DP[i][j]) • Aiが-1でないときは、DP[i][Ai]だけを残して、それ 以外を全て0にします。 部分点（50点）N 㱡 100, Ai 㱡 100 • 状態数：O(N max(Ai)) • 遷移数：O(max(Ai)) • 計算量：O(N max(Ai)^2) • となり、この部分点を取ることが出来ます。 部分点（80点）N 㱡 2000, Ai 㱡 2000 • ２通りの方針があります。 • まずは先ほどのDPを高速化する方針から。。 DPの高速化 • 先ほどのDPの遷移の式は、 • DP[i+1][j] = sum(DP[i][0]~DP[i][j]) • でした。 • 区間の和を高速に求められれば良さそうです。 • 累積和を使いましょう。 • sum[i] = 0~iまでの和 • というものを全てのiに関してあらかじめ求めておく ことで、l~rの区間の和を「sum[r]-sum[l-1]」とい うようにしてO(1)で求めることが出来ます。 • 今回の問題では左端が常に0なので、sum[i]がその まま求めたいものになっています。 部分点（80点）N 㱡 2000, Ai 㱡 2000 • 状態数：O(N max(Ai)) • 遷移数：O(1) • 計算量：O(N max(Ai)) • となり、この部分点を取ることが出来ます。 部分点（80点）N 㱡 2000, Ai 㱡 2000 • その２の解法です。 • 少し数学的な考察をします。 • -1が連続している部分ごとに分けると、それぞれを 独立に計算しても良くなります。 • 例えば「2 -1 -1 9 -1 9」なら「2 -1 -1 9」と 「9 -1 9」に分けて考えます。 部分点（80点）N 㱡 2000, Ai 㱡 2000 • X,(-1がY個並ぶ),Z • となっている部分を計算する方法を考えます。 • 各項間での増加量に注目します。 • 項の間はY+1箇所あり、それらに合計Z-Xの非負の 整数を割り振っていると言い換えることが出来ま す。 • もう少し簡潔に言い換えると・・・ 部分点（80点）N 㱡 2000, Ai 㱡 2000 • 長さLの非負整数からなる数列であって、 合計がSとなるものの個数 • を求めることが出来れば良いです。 • 「1 -1 3」を例にして言い換えると、 • 「長さ2で合計が2の数列」の個数を求める問題 • （答えは「0 2」「1 1」「2 0」の３通り） 部分点（80点）N 㱡 2000, Ai 㱡 2000 • 長さLの非負整数からなる数列であって、 合計がSとなるものの個数 • →数学とかでよくある、重複組み合わせの問題 • 「S個のʼoʼとL-1個のʼ|ʼを並べる方法の個数」と同じ • LHS = S+L-1CS 部分点（80点）N 㱡 2000, Ai 㱡 2000 • ここまでくれば、あとは組み合わせを計算できれば 良い。 • パスカルの三角形を作ろう。 • i段目のj番目の数字が iCj になっています。 部分点（80点）N 㱡 2000, Ai 㱡 2000 1 11 121 1331 14641 パスカルの三角形 • まとめると、 • X -1 -1 ... -1 Y という部分に分割する • それぞれの部分に対し、重複組み合わせを求める • 重複組み合わせをパスカルの三角形を用いて求める • パスカルの三角形を構成するところに最も時間がか かり、O(max(Ai)^2)くらいなので、この部分点を 得ることが出来ます。 部分点（80点）N 㱡 2000, Ai 㱡 2000 満点 N 㱡 2000, Ai 㱡 10^9 • 組み合わせを高速に求めたい。 • 組み合わせは、以下のように求められます。 • nCr = (n-r+1~nの積)/(1~rの積) • これをどのように計算すれば良いでしょうか。 満点 N 㱡 2000, Ai 㱡 10^9 • nCr = (n-r+1~nの積)/(1~rの積) • (n-r+1~nの積)と(1~rの積)は素直にかけ算をすれば 良いだけです。 • しかし、割り算はそうは行きません。 • X/Y (mod p) (pは素数) の求め方が問題です。 X/Y (mod p) (pは素数) の求め方 • mod pのpが素数の場合は、逆元が存在します。 • 「Yの逆元」とは「Yをかけると1になる数」のこと で、「1/Y」や「Y^-1」などと表します。 • フェルマーの定理「X^(p-1) 㲇 1 (mod p)」を用い ると、Yの逆元は「Y^p-2」として計算することが 出来ます。（(Y^(p-2)) * Y 㲇 1 (mod p)なので） • つまり、X/Y 㲇 X*(Y^(p-2)) と計算できます。 X/Y (mod p) (pは素数) の求め方 • あとは、Y^(p-2)を高速に計算できれば解決です。 • 冪乗法を用います。(繰り返し二乗法とも) • A^B = A^(B/2)*A^(B%2) という漸化式を使ってべ き乗を計算する手法です。 • 肩に乗っている数字が半分ずつに減っていくので、 計算量はO(log p)となります。 • 再帰関数として実装すると良いでしょう。 満点 N 㱡 2000, Ai 㱡 10^9 • 80点の２つめの部分点解法を、mod pでの割り算 をO(log p)くらいで計算するテクニックを用いて高 速化することによって、満点を得られるようになり ました！ D問題 GCD区間 問題概要 • 数列A={a1,a2,…,an}がある (n≦10万) • クエリが与えられる。クエリの内容は、 「xが与えられるから、GCD(As,As+1,…,At)=xとなる区間[s,t] の数を求める」 • クエリはたくさん与えられる(≦10万回) 考察 • 区間を決めることを考える tを固定してsをt→1と動かすとき、[s,t]のGCDは単調減少 • 単調減少の仕方は、因数が1つずつ除かれる感じ • 10^9以下で、因数が一番多いのは2^29で29個 • tを固定してsをt→1と動かす方法において、現れるGCDの数 はlog(At)以下 解法 • クエリを考えず、全てのGCDとそれを含む区間数を予め計算する • 左から順番にtを決めていく。今まで現れたGCDの値とその出現回 数を保持した配列をMとすると、考察からMの大きさは常に30個 (GCD=1を含める)以下 • Mを利用して[?,t]をまとめて計算して答え用の配列に格納しとく • 後処理として、Mの各要素に対してtとのGCDを取り、配列M’を 計算し、M=M’として処理を続けていく • Mと答えの保持に平衡二分木の連想配列を用いると、 O(N log max(Ai) log N + |X| log N) 他の解法 • 区間のGCDを予め高速に計算できるようにしておく (*) • 今度はsを固定してtを伸ばすことを考える • GCDは単調減少かつ、変化はO(logAs)回 • 変化点見つけるのまで二分探索するとうれしくない • 1個の変化点を見つけるためにO(log N)回反復 • O( N log max(Ai) log N×{(*)の方法の計算量} ) ←とても重い • (*)の部分にセグメントツリーを用いるとおそらくTLE • 二分探索ではなく、平方分割を用いて、「進めてみて変化がないな ら√Nずつtを進めていく」方法も間に合うはず • その他、スパーステーブルを用いて平方分割と同様できるだけ大き な2^k(1,2,4,…)ずつ進めていく方法もある AtCoder Regular Contest 022 解説 AtCoder株式会社 2014/5/3 1 A問題 スーパーICT高校生 A-問題概要 ● 文字列Sが与えられる ● Sからいくつか文字を省いて”ICT”を作れるか 判定せよ ● 大文字小文字は区別しない 1≦∣S∣≦100 A-想定解 ● 残す'I'はSの中で一番最初の'I'でよい。 ● 残す'C'はその'I'以降で一番最初の'C'でよい。 ● 残す'T'はその'C'以降で一番最初の'T'でよい。 ● 順番に貪欲的に文字を取っていく。 ● O(|S|) – 想定解 A-想定解2 ● 今回は探索する'ICT'が3文字なので、さまざまなその 場しのぎのアルゴリズムが考えられる。 ● 3文字を全通り試す – O(|S|^3) ● 'C'を決めてその左右に'I'や'T'があるか判定 – O(|S|^2) ● 最初の'I'と最後の'T'の間に'C'があるかどうか判定 – O(|S|) A-大文字小文字 ● この問題では大文字小文字を区別しない ● 知るかぎり、どのプログラミング言語でも大文 字と小文字は別物と判断されるので、何とかし なければならない – 自前の比較関数を作る – あらかじめ全て大文字か小文字に揃える B問題 細長いお菓子 問題概要 • お菓子がうんぬんと言っていますが要するに、 • 長さNの数列Aが与えられるので、同じ数字を２つ 以上含まない最長の区間の長さを求めよ。 • 部分点（50点）： N 㱡 100、Ai 㱡 100 • 部分点（99点）： N 㱡 1000、Ai 㱡 1000 • 満点：N 㱡 10^5、Ai 㱡 10^5 部分点（50点）N 㱡 100 • 区間の左端と右端を全て試し、その区間の中に同じ 数字が２つ以上含まるかどうかを調べる。 →「同じ数字が２つ以上含まれるかどうか」を高速 に判定したい。 • 方法１：頻度を計算しておく • 「それぞれの数字がいくつ含まれるか」を、配列を 使って求めておき、２つ以上含まれる数字がないか を調べる。 for (int i = L; i <= R; i++) freq[A[i]]++; 頻度の計算の例 判定のやり方 • 方法２：集合を扱うデータ構造を使う • 例えばsetやDictionaryなど。 • 集合に数字をどんどん追加していき、すでに追加さ れている数字があれば、ダメ。 判定のやり方 部分点（99点）N 㱡 1000 • 区間の左端だけを全部試し、それぞれに対してどれ だけ区間をのばすことが出来るかを調べる。 • ひとつずつ数字を見ていき、その数字がすでに区間 の中に入っていたらその時点でストップ、とする。 • 判定の方法は50点の部分点の方法と同様の方法を 使えば良い。（方法１でも方法２でも良い） 満点 N 㱡 10^5 • 尺取法を使う。 • 判定の部分に”方法２”を使う場合は、データ構造が 削除クエリに対応している必要があります。 l = 0; for (r = 0; r < N; r++) { while ([l,r]に同じ数字が２つ以上含まれている) l++; answer = max(answer, r - l + 1); } 尺取法の例 C問題 ロミオとジュリエット 問題概要 • 要するに、 • 頂点数Nの木が与えられるので、距離が最長となる 頂点のペアを１つ見つけよ。 • 部分点(40点)：N 㱡 1000 • 満点：N 㱡 10^5 部分点（40点）N 㱡 1000 • 片方の頂点を全て試し、その頂点から最も遠い頂点 を探す。 • 最も遠い頂点を探すためにはBFSを使えば良い。木 なのでDFSを使ってもOK。 • 木の上ではDFSをすることが多いので、DFSで書け るようになっておくのがオススメです。 満点 N 㱡 10^5 • ２頂点間の最大の距離＝直径と言います。 • すなわちこの問題は、木の直径を求める問題です。 • 木の直径を求めるアルゴリズムを２通りほど紹介し ます。 木の直径の求め方その１ • 簡単な木DPをする。 • とりあえず根を適当に決めて根付き木にします。 • 任意の２頂点間の移動は「まず根の方向にいくつか 辿り、根から離れる方向にいくつか辿る」となって います。 • LCA(Lowest Common Ancestor) に注目します。 （移動で通る頂点のうち最も根に近い頂点がLCAです。） 4 5 1 6 2 3 7 8 木の直径の求め方その１ • ある頂点(Vとする)をLCAとする頂点のペアのう ち、最も距離が離れているものは、 • 「あるVの子の子孫のうち最もVから遠い頂点」（V の子の数だけある）と「V」のうち、 Vから遠い順に２つ選んだ時の頂点のペア になります。 • これをボトムアップに（葉から順に） 計算して行けば良い。 4 5 1 6 2 3 7 8 木の直径の求め方その２ • こちらは、方法としてはとても単純です。 • まず、頂点を適当に選んでWとします。 • Wから最も遠い頂点を探してVとします。 • Vから最も遠い頂点を探してUとします。 • すると、VとUが答えになっています。 木の直径の求め方その２(仕組みについて) • 木には中心というものがあります。 • 木の中心とは、直径の中心のことです。 → 中心は辺上の点になることもあります。 • 全ての直径は木の中心を通ります。 → 中心から各頂点への距離は直径/2以下で 　・・・と考えたりすると証明できます。 V U W 木の直径の求め方その２(仕組みについて) • Vは中心をまたいでWと反対側にある最も遠い頂点 であるため、直径の端点となる。 • Uは中心をまたいでVと反対側にある最も遠い頂点 であるため、直径のもう片方の端点となる。 • というからくりになっています。 V U W まとめ • １つ目の方法は汎用性が高いテクニックなので、書 けるようになっておいた方が良いでしょう。 • ２つ目の方法は、直径を求める際には楽な方法なの で、覚えておいて損は無いでしょう。 D問題 スプリンクラー D-問題概要 ● 直交座標上にN個の格子点(x, y)が与えられる ● 各格子点に対して、それを中心として原点を通 る円を考える ● いずれかの円に含まれる格子点の個数を求めよ ● N ≦ 10^5 ● -10^5 ≦ x, y ≦ 10^5 D-部分点1 ● N ≦ 100 ● -100 ≦ x, y ≦ 100 ● 頂点と円の組み合わせを全て調べても間に合う ● O(N |x| |y|) – 10点が得られる D-部分点2 ● N ≦ 1,000 ● -1,000 ≦ x, y ≦ 1,000 ● 全頂点の走査なら可能そう ● いろいろな図形を重ねた時に、何枚重なってい るか数える都合のいいアルゴリズムがあった気 がする・・・ D-部分点2 累積和 D-部分点2 ● 長方形ではないのでいつもの二次元累積和は使 えない – 一次元に分けたらできる ● 円周の左側を+1 右側を-1する D-部分点2 ● +1や-1する点は円1つあたり、たかだかO(半 径)個くらい – 今回なら 1000 * √2 ● 総計算量はO(N max(|x|, |y|)) – 計30点が得られる D-考察 ● 累積和をすると、そこにいくつの円が重なって いるかという余計な情報も求めることになる – 無駄 ● 1個以上重なっているかどうかさえわかればい い – 無駄な+1, -1をしないように削る D-考察 ● 無駄な+1, -1の例 D-考察 ● どうやら完全に外側に接している部分付近だけ の+1, -1で充分 ● 外周さえ求まれば なんとかなりそう ● どうすれば 求まるのか・・・ D-部分点2 凸包 D-考察 ● 点A,点Bと三角形OAB内の点C ● Cを中心とする円はAもしくはBを中心とする円 に完全に覆われる ● Cは考えなくて良い D-考察 部分点3 ● どの三角形の内側にも入らない点だけを考えれ ば良い – つまり凸包上にある頂点だけを考える ● 頂点は全て格子点にあるので凸包上にある点は たかだか√|x|個くらい ● 凸包で頂点を減らしてimos法をすれば良い – O(x log x + x√|x|) 計60点が得られる D-さらに処理を少なく ● 凸包上の点を中心とする円でも、その円周が全 て外側に触れている(外周)わけではない – 外周のところだけで計算してよい ● 円どうしの交点、つまり円弧の両端が求まれば 良い ● 交差する円は、凸包の多角形における隣り合う 頂点に対応する円だけ – 幾何の計算をいくらかすれば交点はもとまる D-外周だけを考える ● 各円弧の両端が求まれば、その間に含まれる範 囲だけ考えれば良い。 – ある点がある円弧に含まれるかどうかは凸包と同様 に外積を使えば良い ● 外周だけ考えるのは何とかなりそうだけれども はたしてそれで満点の制約において間に合うの か？ D-計算量 ● 累積和において別々に考えるときに、y=k(k は整数)となる直線で輪切りにして考えるとす る。 ● そのとき、各直線上には左端と右端がいくつか 乗る。それを計算すれば各直線上の条件に合う 花の数が求まる。 D-計算量 ● 右端や左端は外周がy=k(kは整数)と交わる点 の数だけある。 ● 外周を一周りするときにy=k(kは整数)と何回 交わるかを求めれば、計算量が求まる。 D-計算量 ● 各円弧の両端と原点を結んだ三角形の原点の部 分の内角は、その円弧の円周角に当たる。 – 全外周の円周角の総和はたかだか360° – よって中心角の総和はたかだか720° ● 円の半径は|x|*√2以下なので、外周の上限は |x|*4√2 * (円周率) ● 今回の問題ではおおよそ2,000,000くらい D-計算量 ● 外周をたどって一回りする時、いろいろなy=k と交わる。 ● いまy=aと交わったとする。その次に交わるの はy=a+1, y=a-1, y=aのいずれかである D-計算量 ● 次にy=a+1,y=a-1と交わることは、外周を1 以上進んでいるので2,000,000回しか起こらな い ● 次にy=aと交わることは、下図のような場合の み。共にO(N)回 接線がx軸と平行になる付近　違う円弧と変わる付近 D-計算量 ● よって、外周とy=k(kは整数)との交点はたか だか2,000,000個くらいしかないので全列挙し ても十分間に合う – 想定解 D-想定解まとめ ● スプリンクラーと世界一の花で凸包を取る。 ● 凸包上の点とそれに対応する円を順番に見てい き、隣の円との交点を求め、外周となる範囲を 得る ● 外周上を順番に走査してy=k(kは整数)との交 点を全て列挙する ● 左端と右端が全て求まるので適当に各yについ て引き算をして、総和を取ると答えになる D-計算量まとめ ● 凸包でO(N log N) – バケツソートによる基数ソートをすればO(N) – 凸包上の点の数をMとする M = O(√|x|) ● 円どうしの交点を求めるのにO(M) ● y=k(kは整数)との交点を全列挙するのにO(|x| *4√2 * 円周率) ● おおよそ10^6オーダー AtCoder Regular Contest 021 解説 AtCoder株式会社 2014/4/19 1 A問題 DEAD END A - 問題概要 問題 タイルを滑らせることで同じ数をぶつけて 大きい数にしていくゲームの盤面が与えられる。 ゲームオーバーの状態かどうかを判定せよ。 A - 重要なポイント 与えられる盤面では空いているマスはない！ ↓ 同じ数をぶつけるような操作が必要 しかも、隣り合う数をぶつけるしかない A - 解き方 整理すると…… 上下左右に隣り合う同じ数が ある　→　CONTINUE 　　　　　　　　　　　　　 ない　→　GAMEOVER 実装 ・2 重ループを回す（添字に注意） ・if 文を書きまくって全部調べる（列挙漏れに注意） (きちんとループで書けるようになっておいた方がいい) ARC #021 B 問題解説 解説:城下 慎也 (@phidnight) 問題概要 • 𝑁 個の非負整数 𝐵1, 𝐵2, … , 𝐵𝑁 が与えられる。 • 𝐵𝑖 = 𝐴𝑖 ＾𝐴𝑖+1(ただし 𝐴𝑁+1 = 𝐴1) である。 (以降、＾ を排他的論理和(xor) の記号として表す。) • 𝐵1, 𝐵2, … , 𝐵𝑁 として考えられるものが存在するな ら辞書順最小を求めよ。ないならないことを指摘 せよ。 • 2 ≦ 𝑁 ≦ 100,000 排他的論理和の性質(例) • 𝐴, 𝐵, 𝐶 を非負整数とすると • 結合則(𝐴＾𝐵)＾𝐶= 𝐴＾(𝐵＾𝐶) が成立する。 • 交換則𝐴＾𝐵= 𝐵＾𝐴 が成立する。 • 𝐴＾0= 𝐴 (零元) • 𝐴＾𝐴= 0 (それ自身と xor すると零元になる。) • これらの性質を利用してこの問題を考える。 考察 • 𝐴1を固定して考えてみる。 • 𝐵1 =𝐴1 ＾ 𝐴2より𝐴2=𝐴1 ＾ 𝐵1 (∵ 𝐴2=0＾𝐴2=(𝐴1 ＾𝐴1)＾𝐴2=𝐴1 ＾(𝐴1 ＾𝐴2)=𝐴1 ＾ 𝐵1) • 同様に、 𝐵2 =𝐴2 ＾ 𝐴3より𝐴3=(𝐴1 ＾𝐵1)＾𝐵2 (∵ 𝐴3=𝐴2 ＾𝐵2=前述の𝐴2を代入) • 一般に 𝐴𝑖=𝐴1 ＾𝐵1 ＾𝐵2 ＾…＾𝐵𝑖−1 (𝑖 ≧ 2)が成立 することを示す。 考察 • 𝐴𝑖=𝐴1 ＾𝐵1 ＾𝐵2 ＾…＾𝐵𝑖−1 (𝑖 ≧ 2)が成立する。 (∵𝐴𝑖=(𝐴1 ＾𝐴1)＾(𝐴2 ＾𝐴2)＾…＾(𝐴𝑖−1 ＾𝐴𝑖−1)＾𝐴𝑖 =𝐴1 ＾(𝐴1 ＾𝐴2)＾ (𝐴2 ＾𝐴3) ＾…＾(𝐴𝑖−1 ＾𝐴𝑖 ) =𝐴1 ＾𝐵1 ＾𝐵2 ＾…＾𝐵𝑖−1) • 以上のことより、𝐴1が定まれば、𝐴2から𝐴𝑁ま でのすべての値が𝐵1から𝐵𝑁−1までの値を用 いて、一意に定まることがわかる。 解の存在判定について • 使用されなかった𝐵𝑁については、先ほどの計 算で出てきた値と𝐵𝑁= 𝐴𝑁 ＾ 𝐴1が矛盾する場 合がある。 • 𝐴𝑁 ＾ 𝐴1= 𝐵1 ＾ 𝐵2 ＾…＾ 𝐵𝑁−1となるので𝐵𝑁は𝐴1 に依存せずこの値に一致するはずである。 • 矛盾したならば解が存在しない。 • 矛盾しないなら、 𝐴1を任意に指定した後、解 が一意に定まる。 辞書順最小 • 解が存在した場合に、辞書順最小なものを求 める必要がある。 • 先頭の値 (𝐴1) ができるだけ小さいほうが良 い。 • 今回の場合では、𝐴1=0のケースがただ 1 通 りだけ存在するので、その1 通りが辞書順最 小の値となる。(𝐴2以降を比較する必要はな い。) • これを計算して答えが得られる。 まとめ • 𝐵𝑁=𝐵1 ＾ 𝐵2 ＾…＾ 𝐵𝑁−1が成立しないなら解なし、 成立するなら𝐴1= 0と置いて順に解を計算す る。 • 排他的論理和の性質を利用した問題は様々 なものがあるので、排他的論理和の問題に は慣れておこう! ARC #021 C 問題解説 解説:城下 慎也 (@phidnight) 問題概要 • 高橋君は建物を 𝐾 回増築したい。 • 高橋君は 𝑁 軒の建物を所有している。 • 増築には、増築する建物について、現在の価格 だけ費用がかかり、増築で一定値値上がりする。 • 合計費用として考えられるものの最小値はいくら か。 • 1 ≦ 𝐾 ≦ 100,000,000 • 1 ≦ 𝑁 ≦ 100,000 部分点解法 その1 • 毎回どの建物を増築するかを𝑁 通りから選ぶ解 法だと O(𝑁 𝐾) 通りになってしまう。 • 考えてみると、異なる建物同士の増築の順番を 考慮しなくてもよいことが分かる。 • つまり、「建物1 を増築しまくる」→ 「建物2 を増築 しまくる」→… という順番を付けてもOK。 • すると、dp[i][j]=(i 番目の建物までの増築が完了 したときに、今まで j 回増築している場合の最小 費用) とする DP を組めば O(𝐾 2𝑁) で計算するこ とができる。これで 30 点が得られる。 部分点解法 その2,3 • 実は、毎回「現在の費用が最小なものを増築 し続ける」という貪欲法で正解を得ることがで きる。 • 以降の数枚でそのことを示す。 • この貪欲法を毎回すべて見る方針で実装す れば O(𝐾𝑁) で解ける。計40点が得られる。 • priority_queue を使用すればO(𝐾 log 𝑁) とな り、通算55点が得られる。 貪欲法が適用可能なことの証明 • 建物の増築回数と価格を照らしあわせた表 は例えば次のようになる。 ID A D 0 回増築 1 回増築 2 回増築 3 回増築 1 50 40 50 90 130 170 2 40 80 40 120 200 240 3 70 50 70 120 170 220 4 60 60 60 120 180 240 貪欲法が適用可能なことの証明 • 建物の増築回数と価格を照らしあわせた表 は例えば次のようになる。 • ここから 𝐾 個良いものを (途中が飛んでも良 い) 選ぶアルゴリズムは貪欲法で実装できる。 ID A D 0 回増築 1 回増築 2 回増築 3 回増築 1 50 40 50 90 130 170 2 40 80 40 120 200 240 3 70 50 70 120 170 220 4 60 60 60 120 180 240 貪欲法が適用可能なことの証明 • 先ほどの貪欲アルゴリズムは左詰め。という のも、同じ ID 内で、X 回増築の部分を採用し ないで X+1 回増築の部分を採用しているなら、 代わりに X 回増築の部分を採用すればより 費用が下がる。 • 左詰めに採用されているのであれば、これは 今回の問題で実行可能。 • この値より下回る解は存在しないので、これ が最適解となる。 満点解法に向けて • この方針では 1 ≦ 𝐾 ≦ 100,000,000 という制 約に対して充分高速でない。 • 今までの手順をどうにかして高速化したい。 • 更に考察してみよう! アプローチを変えてみる • 貪欲法で最後に選んだ増築の費用を𝑉として みる。 • 費用が𝑈の増築に対して、 • 𝑉 > 𝑈なら、その増築は必ず行われる。 • 𝑉 < 𝑈なら、その増築は決して行われない。 • 𝑉 = 𝑈なら、合計が𝐾回となる分だけ増築が 行われる。 満点解法 • 先ほどの𝑉を考えてみると、適当に𝑉′を定めたと き、 𝑉′未満、 𝑉′より大きい、 𝑉′に等しい費用の増 築がそれぞれ何個あるかを計算すれば、𝑉と𝑉′ の大小関係が分かる。 • よって、 𝑉を二分探索することで計算することが できる。 • 𝑉が分かれば、 𝑉未満の増築(𝑀個とする)をすべ て採用し、 𝑉と等しい増築を𝐾 − 𝑀個採用すれ ば最適解を計算できる。 • O(𝑁 log 𝐿) (𝐿は𝑉の上限) で計算できる。 • 100点が得られる。 D問題 だいたい最小全域木 D - 問題概要 問題 200 次元空間に 5 000 個の点がある。 2 点を結ぶコストを (1 - コサイン類似度) とするとき できるだけコストの小さい全域木を求めよ。 最適なものの 1.01 倍のコストに収まれば OK。 D - 方針 普通にやると…… 問題自体は最小全域木だが、 全点間のコストを計算するのは時間がかかりすぎる。 最小じゃなくてもいい！ 「最適なものの 1.01 倍のコストに収まれば OK。」 だった！ → 必要そうな 2 点間だけ計算するようにしたい D - 2次元の場合 この問題が 2 次元空間の場合は…… ←こんな感じで グループ分けして 同じか、近いグループの 点たちだけ見る D - 200 次元でも同じことを ・ランダムなベクトルを K 個用意する ・各点とランダムベクトルの内積が正か負かで K ビットのハッシュのようなものが計算できる ・このハッシュで近いものだけを考えることにする ハッシュ同士はハミング距離(異なるビットの個数) で距離を測れば爆速！！！！！ D - K の選び方 今回の場合は点がランダムに分布しているので ・点の i 番目の座標の値が正か負か で 200 ビットのハッシュを作ると、 均等にグループ分けできて良いです。 AtCoder Regular Contest 020 解説 AtCoder株式会社 2014/3/29 1 A問題 石を滑らせるゲーム A - 問題概要 問題 整数が２つ与えられる。 どちらがより0に近いかを判定せよ。 制限 -1000 㱡 (与えられる整数) 㱡 1000 A - 解き方 1. ２つの整数を入力する。 2. それぞれの整数について絶対値を求める。 3. それらを比較して適切に条件分岐をする。 4. 結果に対応する文字列を出力する。 A - 絶対値の求め方 (方法１) 言語が用意している関数を使う。 　　　　 →　使っている言語について調べてみよう。 (方法２) 条件分岐を使って自分で書く。 　　　　例： if (A < 0) A = -A; Problem B 縞模様 B問題概要 問題 • 数列が与えられる。任意の2種類の数字を使ってそれが交互に繰り返さ れるように数列を書き換えたい(与えられる数字は10種類) • 最小で何箇所書き換えなければならないか B問題解法 解法 • 1番目と2番目に使う数字を決め打ちすれば目標の数列は一意に 定まる →そうしてできた数列と与えられる数列の不一致数を数える • たとえば数列={2,3,2,1}のとき、 1番目の数字=「2」と2番目の数字=「1」とすると、 目標の数列={2,1,2,1} → この場合の不一致数は1 • それらを全て計算した上で最小値を出力 Problem C A mod B Problem C問題概要 問題 • 部分的に周期性のある整数A ( 一兆桁以上 ) ←周期の数は1万以下 • 整数B(ほとんどの場合 10^9+7) が与えられるので、AをBで割った余りを出力せよ Aの与えられ方の例: 123が2回 4が2回 56が1回繰り返された整数A→1231234456 C問題 部分点解法(20点) • L1+L2+….+LN ≦ 10^5 • Aiの桁数は10以下 • 展開してもAの長さは10^6以下 したがって、実際に与えられる数を展開し、うまく mod を取ればよい。 (次スライド) • 計算量は、桁数をNとしてO(N) うまいmodの取り方 ある整数を読み込むときに、上の桁から今の整数を10倍して1桁 読み込むことを繰り返すと、逐次modが取れてオーバーフローしない。 動作例: 4321 % 11を求めるとき 4321 余り: 4 4321 余り: (4*10+3)%11 = 10 4321 余り: (10*10+2)%11 = 3 4321 余り: (3*10+1)%11 = 9 よって、4321を11で割った余りは9 C問題 ほぼ満点解法(99点) • 各周期毎に高速に余りを計算する • 「10^(周期の長さ)倍して周期の余りを足す」を繰り返せばよい • 繰り返された数は等比数列の和で表されることに着目する↓ 121212 𝑛回 … = 12 + 12 × 100 + 12 × 1002 + … + 12 × 100𝑛−1 一般に公比r(r≠1,r≠0)のとき、 𝑟 0 + 𝑟 1 + 𝑟 2 + ⋯ + r n = r n+1 − 1 r − 1 したがって 12 1 + 100 + ⋯ + 100n−1 = 12 × 100n − 1 100 − 1 の余りを計算すればよい C問題 ほぼ満点解法(99点) • 1/xをする操作が問題(ふつうに割ってmodを取るのはNG) →1/xと等価な整数(掛けてmodを取ったら1になる数=逆元)を求め、そ れを掛け算すればよい • フェルマーの小定理に基づくと、 pが素数であり、xとpが互いに素であれば、x^(p-2)はxの逆元 • 10^9+7は素数 • 今回、xは9,99,999,….,10^10-1の値しかとらない →xとp=10^9+7は常に互いに素 • 逆元は二分累乗法によって、log(p)で計算可能 C問題 満点解法(100点) • Bの値によっては逆元が求まらないことがある • ダブリング • 例えば123123123…を求めるとき 123(1回) 123123(2回) 123123123123(4回) 123123123123123123123123(8回) … のように123が2^k回繰り返されたパーツがあれば繋ぎ合せるだけでよい (modは逐次とっておく) C問題 満点解法(100点) • 123が「2^n回繰り返されたもの」から「2^n+1回繰り返されたもの」を作る • 例えば「123123」から「123123123123」をつくる → 「123123」を1000^2+1倍すればよい • これはn=1の例だが、他のnでも同様 • これらのパーツが作れたら、パーツを適当な順番で繋ぎ合せる • 例えば「123123123123123(5回)」なら、 5=(101)2なので「123」と「123123123123」を繋ぎ合せる • もともとこれが想定解法でしたが緩和しました D問題 お菓子の国の旅行 D - 問題概要 問題 N個の町が一直線上に並んでおり、町iと町jの距離(i<j)はa[i]+a[i+1]+... +a[j-1]である。それぞれの町には砂糖屋が１つずつある。ちょうどK個の 異なる砂糖屋に一度ずつ訪れる方法のうち移動距離の和がMの倍数である ものは何通りか。 制限 N 㱡 100, M 㱡 30, K 㱡 10 部分点(30点)：N 㱡 12 D - 部分点解法 巡回セールスマン問題にとても似ている。 ・ DP[今までに訪れた町の集合][今いる町][移動距離の和 mod M] というDPテーブルを更新して行けば良い。 「今までに訪れた町の集合」は二進数で表現すると処理しやすい。 状態数：2^N * N * M 遷移数：O(N) 計算量：O(2^N * N^2 * M) 各道ごとに独立に計算したい。 → 各道に関して、通る回数はどうなっているだろうか？ D - 満点解法 1 2 3 4 5 6 7 ４回通る 2 4 3 7 5 1の順で辿ったとき 町3と町4の間にある道を通るのは、 「2 → 4」「4 → 3」「3 → 7」「5 → 1」の移動をするとき。 つまり「３以下から４以上」または「４以上から３以下」に移動するとき。 ここで、「３以下」を1、「４以上」を0と表してみると、 1 0 1 0 0 1 となる。 この二進数において「隣り合うbitが異なる場所の個数」が「道を通る回数」 となっており、この情報さえあれば事足りることが分かる。 D - 考察 1 2 3 4 5 6 7 ４回通る 2 4 3 7 5 1の順で辿ったとき DP[今注目している道][さっきのような二進数][移動距離の和 mod M] というDPを考える。 「さっきのような二進数」は ・iビット目が1のとき、i番目に訪れる町が注目している道の左にある ・iビット目が0のとき、i番目に訪れる町が注目している道の右にある ということを表している。 DPの遷移で行うことは、 ・今見ている道の左の端点の町にi番目に訪れることにする(i = 1~k) ・なにもしない の２通りである。 D - DP 状態数：N * 2^K * M 遷移数：O(K) 計算量：O(N * 2^K * M * K) D - DP D - 補足 実は状態数はもう少し減らせる。 もう少し考察をすると、計算に関わってくる情報は「0が繋がっている部分 の長さのリスト」だけであり、それらの順番は関係がないことが分かる。 例えば、「10110011001」と「10011101001」はいずれも、 「0と00と00が1によって区切られている」という同じ状態として見なせる。 状態数はKの分割数のようなオーダーになるため、Kが20近くても解ける ようになる。 （より細かく言うと「接頭辞/接尾辞に何個の0が連続しているか」という情報も持つ必要がある。） AtCoder Regular Contest 019 解説 A問題 お買い物クライシス A - 問題概要 問題 数字の一部がアルファベットに置き換わった 文字列 S が与えられる。 元の数を復元せよ。 制限 1 ≦ (S の文字数) ≦ 8 アルファ ベット 数字 O 0 D 0 I 1 Z 2 S 5 B 8 A - 解き方 1. 文字列 S を入力する 2. S を 1 文字目から順に見ていく 3. 各文字について、 ・数字ならばそのまま出力し ・アルファベットならば対応する数字を出力する A - チェックポイント 1. 文字列 S を入力する 2. S を 1 文字目から順に見ていく 3. 各文字について、 ・数字ならばそのまま出力し ・アルファベットならば対応する数字を出力する 文字列の入出力や扱い方については 使っている言語ごとに調べよう if 文などでそのつど調べてもよし あらかじめ文字変換のハッシュテーブルを用意するもよし B問題 こだわりの名前 B - 問題概要 問題 英大文字からなる名前 A が与えられる。 これを 1 文字だけ別のアルファベットに変換して 作れる回文でない文字列は何個あるか？ 制限 1 ≦ (A の文字数) ≦ 3×105 B - 考えよう まずはじめに 書かれていることをそのまま計算することはできる 　→1文字の変更を全部試して、回文かどうか判定する 計算量は？ ・変更候補が 25 × N ≦ 7,500,000 通り ・回文かを試すのに O(N) 時間 　→ 25 × N × N ≦ 2,250,000,000,000 ≒ 2 × 1012 　　はとうてい 2 秒では無理…… B - そもそも回文とは？ 「前から読んでも後ろから読んでも同じ」とは 結局どういうことなのか？ R A C E C A R 「線で結ばれた文字(以降ではペアと呼ぶ)が同じ」 なら回文！ B - 解き方(1/2) 文字数が奇数のとき 真ん中の文字は何でも良い ・元の文字列が回文なら、真ん中の文字を変えても回文 ・元の文字列が回文でないなら、真ん中の文字を変えても回文でない →真ん中の文字は後で考える(文字数が偶数の場合に帰着) 文字数が偶数のとき すべてのペアの文字が一致していれば回文 　→文字が一致しているペアの数に注目しよう B - 解き方(2/2) 重要な考察 1 文字の変更では「文字が一致するペアの数」は 1 増えるか、1 減るか、そのままか のいずれかである。 　(1 文字しか変えてないのだから、当たり前) これにより、1 文字変更した後の回文の判定が O(1) の計算量でできるようになる！ 　→これなら時間制限にも間に合う C 問題 最後の森 解説担当:城下 慎也 (@phidnight) はじめに • この問題において入力に不備が見つかった ため、ノーコンテストとなってしまい、誠に申し 訳ありませんでした。 • このようなことが再び起こらないように今後も 気をつけていきたいと思います。 概要 • R*C のマス目が与えられる。 • 村→ほこら→城 の経路で長さ最小なものを考 えたい。 • 途中にいる敵は K 体まで倒すことができる。 • 一度倒した敵は復活しない。 倒す敵が決まると? • 最短経路問題を 2 回解くことで解が得られる ようになる。 • ただ、敵の総数を E としたとき、𝐸𝐶𝐾だけ組み 合わせを試さなければならないので指数オー ダー。 • DP を使おうにも、倒した敵が復活しないとこ ろを情報としてうまく保存するのが難しい。 • まずは多項式解法を求めよう！ 指数を回避するために • 倒した敵を情報として持たないようにしたい。 • すべての経路ではなく、最適性を維持したま ま、うまく状態を持てるような経路だけを考え たい。 • 必要な経路を厳選しよう！ 考察1 • 中継地点に行った後に、来た道を直接戻らず に途中で合流する経路は考えなくても良い。 • 次のどちらかが、敵の数、長さを増やさない、 別の経路であるといえる。 or 考察2 • 来た道を戻る操作を止めた後は、同じ道を通 らないとしてもよい。 • 次のどちらかが、敵の数、長さを増やさない 経路といえる。 or 考察まとめ • 以上より、経路として、 村→三叉路点X→ほこら→三叉路点X →城 だけを考えれえば良い。 • 村→三叉路、三叉路↔ほこら、三叉路→城と わけて、それぞれを足し合わせれば良い。 （この方針で多項式解法） X 多項式解法その1 • X の場所を固定する。 • dp[i][j]=(X からマス i に、合計戦闘回数が j 回以下で 移動するのに必要な最小移動回数) というdpを計算する。 • BFSを用いて、それぞれのマスに対し O(RCK) で計算す ることができる。 • a+b+c≦K (a,b,c≧0)に対して、 Xに敵がいない:dp[村][a]+2*dp[ほこら][b]+dp[城][c] Xに敵がいる:dp[村][a]+2*dp[ほこら][b-1]+dp[城][c-1] (b,c≧1) で解が計算できる。 多項式解法その1 • dpの計算に O(RCK) かかり、 • すべての a,b,c の組を試すのに O(𝐾 3 )かかる ので、各 X に対し全体で O(RCK+𝐾 3 ) • 全体でO(𝑅 2𝐶 2𝐾 + 𝑅𝐶𝐾 3 ) • この解法だとTLEしてしまう。 多項式解法その2 • 発想を逆にして、 • dp1[i][j]=(村 からマス i に、合計戦闘回数が j 回以下で移 動するのに必要な最小移動回数) • dp2[i][j]=(ほこらからマス i に、合計戦闘回数が j 回以下で 移動するのに必要な最小移動回数) • dp3[i][j]=(城からマス i に、合計戦闘回数が j 回以下で移 動するのに必要な最小移動回数) • とすれば、 各Xおよびa+b+c≦K (a,b,c≧0)に対して、 • 敵がいない場合:dp1[X][a]+2*dp2[X][b]+dp3[X][c] 敵がいる場合:dp1[X][a]+2*dp2[X][b-1] +dp3[X][c-1](b,c≧1) で最適解が計算できる。 多項式解法その2 • すべての a,b,c に対して動かすのではなく、 • v[x]:(x=a+bとなる場合のdp1+2*dp2の最小 値) • w[y]=(y=x+cとなる場合のv+dp3の最小値) と 2 段階に分けて計算すれば、O(𝐾 2 )で最適 解を計算できる。 • 全体で O(𝑅𝐶𝐾2 ) となって満点が得られる。 D 問題 ほんとうのたたかい 解説担当:城下 慎也 (@phidnight) 概要 • N*N のフィールドの上にいくつか O を置く。 • 4 つの隅が軸に平行な長方形とならないよう に配置する。 • できるだけ多く O を配置したい。 • 2≦N≦150 部分点1 • 5 点解法 (“．”を”X”に置き換えています) OOO…O OXX…X OXX…X ： ： OXX…X 部分点2 • 10 点解法 (“．”を”X”に置き換えています) XOO…O OOX…X OXO…X ： ： OXX…O 部分点3 • それ以上を得たい場合 • ランダムに置くと強い • うまく貪欲にすると強い • 焼きなますと強い • etc… • 満点を得たい場合は? 考察 • そもそも理論的にはどれくらい置けるだろう? • 長方形が成立する条件を考えると、 • 長方形が成立する⇔ (i,j), (i,l), (k,j), (k,l) のい ずれにも O があるような i<k , j<l が存在する • 各行 p ごとに、(p,q) と (p,r) (q<r) のいずれに も O があるなら、(q,r) というペアを保存する、 という処理を行うと、上記の条件が成立する 場合に、i 行目と k 行目でペア (j,l) が保存さ れることになる。 考察 • このように考えると、実は 長方形が成立する⇔同じペアが複数出てくる • という式が成立することになる。 • 裏を返すと、同じペアは高々 1 回しか出ないこと になる。 • ペアの総数は N(N-1)/2 個であり、ある行に m 個 あればペアの数が m(m-1)/2 だけ減るので、 • N(N-1)/2 ≦ 𝑚𝑖(𝑚𝑖 − 1)/2 𝑁 𝑖=1 が成立する。ただし𝑚𝑖は 𝑖 行目の O の総数。 考察 • 右辺の式は𝑚𝑖のばらつきが少ないほど 𝑚𝑖 𝑁 𝑖=1 が一定の場合に小さくなる。 • 置ける O の最大数はおよそ𝑁 𝑁 個となる。 • このこと (できるだけまばらに置く) を踏まえる と良い解が得られる。 N=p*p (p:素数) のとき • このときに p*p*p 個の O を置く配置を発見す る。 ※素数のほうが作りやすいので、素数にしてい ます。 • 例: 第 p*(i-1)+j (1≦i,j≦p) 行目の、 p*(k-1)+1 から p*k 列(1≦k≦p)までの範囲には、 i*k+j を p で割った余りを q としたとき、 (p*(i-1)+j, p*(k-1)+1+q) にのみ O を置く。 p=3 の場合の例 OXXOXXOXX XOXXOXXOX XXOXXOXXO OXXXOXXXO XOXXXOOXX このようになります。 XXOOXXXOX OXXXXOXOX XOXOXXXXO XXOXOXOXX 100点解法例 • さっきの p を p=11 とすれば S=1331 が得られ る。 • しかしながら 150 に対しては未使用な部分が 存在する。 • そこで p=13 として、左上の 150*150 の領域 を取り出すことにすれば良い。 • 結果、S=1700超となり、100点が得られる。 AtCoder Regular Contest #018 解説資料 2014年 3月 1日 ©AtCoder Inc. All rights reserved. 1 ©AtCoder Inc. All rights reserved. 2 A問題 BMI (解説: kyuridenamida) ©AtCoder Inc. All rights reserved. 3 1. 身長[𝑐𝑚]とBMI [𝑘𝑔/𝑚2 ]が与えられる。 2. 以下の関係式が成り立つので体重[kg]を逆算せよ。 𝐵𝑀𝐼[𝑘𝑔/𝑚2 ] = (体重 𝑘𝑔 ) 身長 𝑚 2 A問題 問題概要 ©AtCoder Inc. All rights reserved. 4 1. 与えられる式を体重[kg]について解く。↓ 体重[𝑘𝑔] = (𝐵𝑀𝐼[𝑘𝑔/𝑚2 ]) × 身長 𝑚 2 2. これを出力する。ただし、与えられる身長の単位は cmなので、100で割りメートルに直さなければなら ないことに気をつける。 また、出力精度に気をつける。 A問題 解法 ©AtCoder Inc. All rights reserved. 5 A問題 補足(出力精度について) • 今回の問題は、必要精度(絶対誤差0.01が以下)がそれほどでな いため、多くの言語で、特に意識しなくても正答が得れるかもし れない。 • 言語によっては、勝手に丸められて出力されることがあるため、 実数を出力する問題では出力桁数に関する書式指定を明示的 に行い、必要精度以上の出力をすることを強く推奨する。 (C言語の例) printf(“%.10f”,1.23); //出力は”1.2300000000” ©AtCoder Inc. All rights reserved. 6 B問題 格子点と整数 (解説: catupper) ©AtCoder Inc. All rights reserved. 7 1. N個の格子点が与えられる 2. それらのうち3つを使って三角形を作る 3. 面積が正の整数であるものの数を求めよ 1 ≦ N ≦100 1 ≦ 𝑥, 𝑦 ≦ 1,000,000,000 B問題 問題概要 ©AtCoder Inc. All rights reserved. 8 • 0,0 , 𝑥1,𝑦1 , 𝑥2,𝑦2 からなる三角形の面積Sは以下の式 で求めることができる • 原点を含まなくてもいずれか一点が原点になるよう三角形 を平行移動すればよい • 三角形の頂点から面積を求める方法は頻出  ABC002 C 「直訴」等でも出ています。 B問題 想定解 𝑆 = ∣ 𝑥1𝑦2– 𝑦1𝑥2 ∣ 2 ©AtCoder Inc. All rights reserved. 9 • Nが小さいので全ての三角形の面積を調べても良さそう → 全探索 • 同じ三角形を重複してカウントしないように気をつけましょう • 計算量： B問題 想定解 𝑂 𝑁 3 ©AtCoder Inc. All rights reserved. 10 1 ≦ 𝑥, 𝑦 ≦ 1,000,000,000 • 面積はこの２乗くらいの大きさになりうるのでC言語などでは int型だとオーバーフローしてしまう  long long int型にしないとWrong Answer?  案外int型でも大丈夫。だけど絶対大丈夫ではない  double(倍精度浮動小数点数)型←かなりまずい B問題 注意点 ©AtCoder Inc. All rights reserved. 11 • 面積: 𝑆 = ∣ 𝑥1𝑦2– 𝑦1𝑥2 ∣ 2 • Sが整数になるかどうかの判定  𝑥1𝑦2 − 𝑦1𝑥2 が偶数かどうか  intならオーバーフローしても変わらない • Sが0かどうかの判定  intなら 𝑥1𝑦2 − 𝑦1𝑥2 が2 32(int型の扱える範囲の大きさ) の倍数の時のみ判定に失敗する B問題 注意点 ©AtCoder Inc. All rights reserved. 12 • 多くの言語の浮動小数点数型はIEEE 754 に基づいている。 例えばC言語のdoubleは、符号部1bit・指数部11bit・仮数部 52bitで構成されている。指数部が全て0で無い限り、暗黙の 整数ビットとして1bit追加され、53bitが仮数部の幅となる。 • その性質上、2^53を超える整数値は、2の倍数刻みでしか 表現できなくなり、2^54を超える整数値は4の倍数刻みでし か…以下同様。 B問題 doubleがまずい理由(1) ©AtCoder Inc. All rights reserved. 13 • 以下のC言語コードを実行してみると、 実際にa==bがTrueになっていることが確認できる。 B問題 doubleがまずい理由(2) #include <stdio.h> int main(){ double a = 9007199254740992.0; // 2^53 double b = 9007199254740993.0; // 2^53+1 if( a == b ){ puts("a==b"); } } ©AtCoder Inc. All rights reserved. 14 • doubleは64bitだが、64bit整数を表現できるわけではない！ • 今回、10^9≒2^30だから、座標の掛け算で、 2^30*2^30 = 2^60 >> 2^53となってしまうことがあり、 そうなった場合、偶奇が正しく判定できなくなる。 ↑intの場合よりWAが増えてしまう… B問題 doubleがまずい理由(3) ©AtCoder Inc. All rights reserved. 15 • Nがもう少し大きくても解けます • 面積が整数かどうかは頂点のxの偶奇,yの偶奇にしかよら ないので各格子点を4通りにグループ分けして、適当に掛け 算をする • 面積が０のものを除かなければならないが、これは一直線 上に並ぶ3点を数えればできる B問題 ちなみに ©AtCoder Inc. All rights reserved. 16 • 全点対の直線を挙げて、同じ直線が何個ずつでてくるか調 べれば良い。直線を適当なパラメータで表して、ソートする などすればO(N^2 log N)で処理することができる。 • このときは直線を管理するときにオーバーフローに気をつけ なければならない B問題 ちなみに ©AtCoder Inc. All rights reserved. 17 C問題 席替え (解説: catupper) ©AtCoder Inc. All rights reserved. 18 1. サイズがN×Mの２次元配列Xが与えられる 2. a＜cならX[a][b]≦ X[c][d]となるように並び替える 3. 総移動マンハッタン距離の最小値を求めよ C問題 問題概要 ©AtCoder Inc. All rights reserved. 19 • 𝑥0,𝑎, 𝑝が与えられる • 𝑥𝑖+1 = 𝑥𝑖 + 𝑎 𝑚𝑜𝑑 𝑝で生成した値が各席の成績  これを並び替える • a mod p = 0のとき → 𝑥0以外は全て同じ値になる • a mod p ≠0のとき → 成績は全て異なる値を取る C問題 入力の乱数 ©AtCoder Inc. All rights reserved. 20 • 𝑥0が動く必要かあるかどうかで場合分け  動かなくていいなら誰も動かなくて良い  総移動距離は0  動く必要があるなら一番後ろの誰かと交換  総移動距離は2×(N-1) C問題 𝑥0以外同じ場合 ©AtCoder Inc. All rights reserved. 21 • 各生徒の移動先の行が一意に定まる  x番目に成績が悪い人は第 𝑥 𝑀 行に移動する  各行について別々に考えて良い • 行成分の移動距離は確定するので列成分だけを考えれば 良い C問題 値がすべて異なるとき ©AtCoder Inc. All rights reserved. 22 • 以下の例を考える C問題 値がすべて異なるとき 0 1 2 3 4 5 0 1 2 3 4 5 6 ©AtCoder Inc. All rights reserved. 23 • 3行目に行くべき生徒だけ考える C問題 値がすべて異なるとき 0 1 2 3 4 5 0 1 2 3 4 5 6 ©AtCoder Inc. All rights reserved. 24 • 動き方はいろいろ考えられる C問題 値がすべて異なるとき ©AtCoder Inc. All rights reserved. 25 • 左図のように交差の多い移動は、改善の余地がありそう C問題 考察 ©AtCoder Inc. All rights reserved. 26 • 移動前と移動後で列の大小が入れ替わっているならば、 それらの目的地を逆にしても損はしない • 左図と右図では1,2列目を入れえて改善されている • 5,6列目も入れ替えているが損も得もしていない C問題 考察 ©AtCoder Inc. All rights reserved. 27 • 移動前の列の大小関係を保ったまま移動したら最適解の一 つになる  前スライドより、入れ替えをしても得をしないから C問題 考察 最適でない 最適 ©AtCoder Inc. All rights reserved. 28 • 移動後の行ごとに問題を分ける  あらかじめ全体でソートして自分が何行目に行くか調べて おく → O(NMlog(NM)) • 列の大小関係を保つように移動先を決定する  今度は列についてソートする → O(MlogM)をN行分 • 各席について移動前と移動後のマンハッタン距離を計算し て総和を求める → O(NM) C問題 解法 ©AtCoder Inc. All rights reserved. 29 • 合計でO(NMlog(NM))  満点解法 C問題 解法 ©AtCoder Inc. All rights reserved. 30 D問題 僕は友達が少ない (解説: kyuridenamida) ©AtCoder Inc. All rights reserved. 31 1. N(≦10^4)個の頂点とM (≦10^5)本の正の重み付 きの辺から成る連結な無向グラフが与えられる。た だし、同じコストの辺は100本以下。 2. 最小全域木のコストと個数を求めたい。 D問題 問題概要 ©AtCoder Inc. All rights reserved. 32 1. グラフが含む辺から構成される、全ての頂点を繋ぐ木 (閉路のない連結なグラフ)のことを全域木と呼びます。 2. 最小全域木とは、辺の重みの合計が最小であるよう な全域木のことを言います。 D問題 最小全域木とは ©AtCoder Inc. All rights reserved. 33 代表的な２つのアルゴリズムの名前を紹介しておきます。これらに ついてはネットで検索するとすぐに資料が見つかると思います。 難しいアルゴリズムではないので、是非調べてみてください。 1. クラスカル法 2. プリム法 D問題 最小全域木を求めるアルゴリズム ©AtCoder Inc. All rights reserved. 34 1. 高橋君(頂点1)が全ての新入生と友達になる(連結になる)を 最小費用で達成する⇔最小全域木 (費用が全て正なので必ず全域木になる) 2. 自分もしくは自分の友達から伸びてる辺のみしか使えない →適切にやれば任意の全域木が作れる。無視していい制約。 3. 同じコストの辺が100本以下 →満点解法において重要 D問題 問題の考察 ©AtCoder Inc. All rights reserved. 35 1. 辺のコストが全て異なる → 最小全域木が一意に定まる(クラスカル法が貪欲的解法だっ たことを考えると明らか) 2. 最小全域木のコストは普通に求め、選び方の数としては、”1”を 出力すれば良い。 D問題 部分点(10点)解法 ©AtCoder Inc. All rights reserved. 36 1. グラフの(ラベル付き)全域木の個数は、 ラプラシアン行列と呼ばれる以下のような行列の、任意の小行 列の行列式の値に等しいことが知られている (行列木定理)。 [ラプラシアン行列L] 1. 対角成分𝐿𝑖𝑖は、グラフの頂点iに繋がってる辺の数 2. 非対角成分𝐿𝑖𝑗は、(-1)×(頂点iとjを直接繋ぐ辺の数) D問題 満点(100点)解法への予備知識(1) ©AtCoder Inc. All rights reserved. 37 2. 具体例として、以下のようなグラフについて考える。 3. 適当な小行列の行列式を計算(今回は1行1列のものを使う) D問題 満点(100点)解法への予備知識(2) L = 2 −1 −1 3 −1 0 −1 −1 −1 −1 0 −1 4 −2 −2 3 L = 2 −1 −1 3 −1 0 −1 −1 −1 −1 0 −1 4 −2 −2 3 3 −1 −1 −1 4 −2 −1 −2 3 = 13 ∴全域木の数は13通り ©AtCoder Inc. All rights reserved. 38 1. クラスカル法は、小さいものから貪欲に、ある辺の追加によっ てグラフに閉路が生じなければその辺を採用していくアルゴリ ズムであった。どの最小全域木についても、あるコストを持つ 辺の本数は変化せず、あるコストを持つ辺のみに着目したとき、 それらによる連結関係は変化しない。 2. この考察を踏まえた上で最小全域木の個数を求める方法を 次スライドに記載する。 D問題 満点(100点)への考察 ©AtCoder Inc. All rights reserved. 39 1. 辺をコストでグループ分けし、小さいコストの辺のグループから 順番に以下の処理を繰り返し行う。最初(全体の答え)=1 1. 同じコストの辺だけを考えたグラフを考え、そのグラフの全 域森の数を数え、それを(全体の答え)に掛け合わせる。 2. そのコストの辺が作る連結成分を、それぞれ１つの頂点に 圧縮する(この処理により生じる自己辺は削除する)。 2. 以上を連結成分が1つになるまで繰り返し、答えを出力する。 D問題 満点(100点) 想定解 ©AtCoder Inc. All rights reserved. 40 D問題 動作例(入出力例3) 1 2 3 5 4 6 1 1 2 1 1 2 2 2 1 2 3 5 6 1 1 1 1 1,2,3 4 2 2 5,6 2 2 1,2,3 4,5,6 ↑ コスト1の辺だけ考えたグラフ 全域森の数は3個 ↓ 圧縮後のグラフで コスト2の辺だけを考えたグラフ 全域森(木)の数は5個 ∴最小全域木の数は3*5=15通り ©AtCoder Inc. All rights reserved. 41 1. 一般にN×N行列の行列式は、行列を三角化したあと、対角成 分の積を計算すれば求まる。これはO(N^3)で計算できる。  三角化は加減乗除が出来れば可能である。  Pが素数なら、Pを法として加減乗除が可能なので、 逆元を求める操作を加味しても、O(N^2*(logP+N)) で 三角化が可能である。 ( ほぼO(N^3) ) D問題 行列式の計算に掛かる計算量 ©AtCoder Inc. All rights reserved. 42 1. 辺のソート O(M log M) 2. 同じ辺の数がlim(=100)本以下 → 連結成分の頂点数はO(lim)→ 行列式の計算O(lim^3) 3. それがO(N/lim)回繰り返される。 → O(N/lim) * O(lim^3) = O( N * lim^2 ) D問題 全体の計算量(概算) AtCoder Regular Contest 017 解説 A問題 素数、コンテスト、素数 A - 問題概要 問題 整数 N が与えられる。 N が素数かどうかを判定せよ。 制限 17 ≦ N ≦ 1,000,000 A - 正解に必要な要素 アルゴリズム ・素数の定義 ・素数の判定法 実装 ・標準入出力 ・ループ →実装で分からないことがある場合は 　　「標準入出力」などで調べてみよう 1 とその数自身でしか割り切れない 2 以上の正の整数 ※問題文に書かれています N を割り切るような数を探してみて、 それが 1 と N だけなら素数！ A - 解き方 1. N を標準入力から入力する。 2. 2 から N-1 までのすべての整数について、 N を割り切ることができるかを調べる。 →多くの言語では % 演算子で調べることができる 3. いちども割り切れなければ N は素数 → YES そうでなければ N は素数ではない → NO をそれぞれ標準出力に出力する。 B問題 解像度が低い。 B - 問題概要 問題 業績を表す N 要素の整数列 A が与えられる。 そのうちの連続した K 個で、常に上昇しているもの は何個あるか？ 制限 1 ≦ K ≦ N ≦ 300,000 1 ≦ Ai ≦ 300,000 (1 ≦ i ≦ N) B - 注意点(1/2) K = 1 のとき、「常に上昇している」とは？ →問題文の記述からは、あまり明らかではない…… 直感的には たとえば (100) は上昇しているようには見えないが…… ありうる解釈(今回正しいのはこっち) 常に上昇とは “1 ≦ i < (Xの長さ) について Xi < Xi+1 ” と考えれば、(100) も「常に上昇している」ととれる →そもそも i がとれないから OK B - 注意点(2/2) プログラミングコンテストの問題文では、こういった 「数学的な」解釈をすることが多い （特に今回のように K = 1 などの端っこのケース） 少しでも「あれ？」と題意に疑問を持ったら…… 質問しましょう。積極的に質問すると良いです。 (求めている返答が返ってくればよいですし、仮に「問題文をよく読んでくださ い」なんて返されてしまったとしても損することはありません。ジャッジ側の仕 事が増えるだけですが、そんなことを参加者は気にしなくてもよいので、疑問が あればためらわずにガンガン質問を送りましょう。) B - 解き方(1/3) 素直にループを書いて数えると？ 　→もちろん答えは出るけど、時間は大丈夫？ 今回は N が 300,000 まであって、間に合わない！ ・具体的には約 N(N-K) 個ぐらいの要素を見る ・最大で 200 億を超える個数になる！ ・とてもじゃないけど 2 秒では難しい B - 解き方(2/3) 入出力例についていた図を観察してみよう (N = 10, K = 3) 最初の 5 要素が常に上昇していて、K = 3 なので その部分が 3 回分カウントされている！ 後半についても、4 要素の上昇部分が 2 回分カウントされている B - 解き方(3/3) 元の A を、常に上昇している列たちに分解する！ 次に、分解したそれぞれの部分について その部分が K 以上の長さであれば答えにカウント！ 10 40 50 80 90 30 20 40 90 95 10 40 50 80 90 30 20 40 90 95 長さ 5 → 3 回分カウント 長さ 1 → カウントしない 長さ 4 → 2 回分カウント C問題 無駄なものが嫌いな人 C - 問題概要 問題 N 個の荷物と、それぞれの大きさ w が与えられる。 大きさ X のナップサックに、ぴったり荷物を詰める 方法は何通りあるか？ 制限 1 ≦ N ≦ 32 1 ≦ wi ≦ 50,000,000 (1 ≦ i ≦ N) 1 ≦ X ≦ 1,000,000,000 C - ナップサック？ ナップサック問題(有名な動的計画法の問題、詳細は調べてね) にそっくり！同じ方法で解けるかな？ 今回の制限だと、同じ方法ではダメです。 ・ナップサックの大きさぐらいメモリが必要 ・今回はナップサックがとても大きい C - 制限に注目 今回の制限では ・ナップサックや荷物がとても大きい が、そのかわりに ・荷物の個数(N)がとても小さい（重要） とはいえ、全探索は間に合わない (232 通りの詰め方はとても時間内に探索しきれない) C - 解き方(1/3) N が半分(16ぐらい)なら全探索できるのに…… つまり、 荷物を前半グループと後半グループの半々に分けて、 それぞれのグループ内の組み合わせで作れる大きさな ら全探索ができる！ その後で、ふたつのグループの結果を うまくまとめられないだろうか？ C - 解き方(2/3) 前半の荷物を組み合わせて、大きさ p にする方法 が A 通りあるとすると…… 後半の荷物を組み合わせて、大きさ X-p にする方法 が B 通りあったとしたら →ちょうど大きさを X にする方法が A×B 通り見つかったことになる C - 解き方(3/3) 前半でつくる大きさ p を全部試すとして このとき対応する 「後半で大きさ X-p を作る方法」が何通りあるか がすぐに分かればよい。 → 後半の全探索の結果を作れる大きさの順にソート しておけば二分探索で大きさ X-p を作る方法が何通り あるか高速に求められる！ これは「半分全列挙」等の名前で言及されることの多いアルゴリズム D 問題 解説 城下 慎也 (phidnight) 問題概要 • 𝑁 個の数列が与えられる。 • 次のクエリを 𝑀 個処理する。 ・連続する区間の数字の GCD を出す。 ・連続する区間の数字を増減させる ※ここでは、GCD は最大公約数のこと • 30 点分の部分点では増減クエリの幅が1 部分点解法 • 普通に 1 個ずつ区間を取って GCD を計算し ていると間に合わない。 • 実は、いくつかの数の GCD はどのような順番 で部分の GCD を計算しても必ず同じ最終結 果が返ってくる。 • あらかじめ広い区間の GCD を知っておけば 効率的に計算できる。 • segment-tree を用いると効果的。 部分点解法(例) • 例えば下のように区間を決めた場合について 考えてみる。 • 左から 3 つ目を起点として右に進んだ 5 つの 数 16,32,120,84,54 の GCD を計算してみる。 2 4 6 4 16 12 18 8 20 16 32 120 84 54 36 部分点解法(例) • 矢印で示した 3 つの数 16,12,54 の GCD は元 の 5 つの数の GCD と一致する。 • GCD(16,32,120,84,54)=GCD(16,12,54)=2 2 4 6 4 16 12 18 8 20 16 32 120 84 54 36 部分点解法 • segment-tree に、その区間に含まれる要素の GCD を保存しておけば、連続する区間の GCD を O(log 𝑁) で計算することができる。 • 増減クエリは幅 1 なので、この更新によって GCD が更新される場所も O(log 𝑁) →全体で O(𝑀 log 𝑁) で計算でき、30 点が得 られる。 満点解法に向けて • segment-tree が管理している区間全体に数 字が増減された場合、増減の前後で GCD が 変わることがある。 • 例: 区間が [36,43,1,71] を管理している時に、 区間全体が 7 増えると GCD(42,49,7,77)=7 と なって 1 ではなくなっている。 • 増減クエリに対して不変な要素がないか考え る。 満点解法に向けて • 全体に数が加算されても、それぞれの数の 差は一定である。(36 と 43 の両方に 6 を足し ても差は 7 のままである) • よって区間内の隣り合う 2 項の差は不変。 • 実は、区間に含まれる要素のうち、隣り合うも のの差すべてと代表元 1 個の GCD は区間の GCD と等しくなる。 GCD(𝐴𝑙 , 𝐴𝑙+1, … , 𝐴𝑟 ) =GCD(𝐴𝑙 , 𝐴𝑙+1 − 𝐴𝑙 , … , 𝐴𝑟 − 𝐴𝑟−1) ということ。 両者が一致することの証明 𝑔=GCD(𝐴𝑙 , 𝐴𝑙+1, … , 𝐴𝑟 ) ℎ=GCD(𝐴𝑙 , 𝐴𝑙+1 − 𝐴𝑙 , … , 𝐴𝑟 − 𝐴𝑟−1) とする。 • 𝑙 ≤ 𝑖 ≤ 𝑟 となるどの 𝑖 についても 𝐴𝑖 = 𝑘𝑔と 表すことができる。(𝑘 は正整数) • 𝐴𝑖 が 𝑔 の倍数なのでそれらの差も 𝑔 の倍数 である。よって ℎ は 𝑔 の倍数である。 • 𝑔 ≤ ℎ であることはこのことより分かる。 両者が一致することの証明 • ℎ の性質より 𝑙 ≤ 𝑖 ≤ 𝑟 − 1 となるどの 𝑖 につ いても、 𝐴𝑖+1 − 𝐴𝑖 = 𝐵𝑖ℎ となる正の整数 𝐵𝑖 が存在する。 • また、𝐴𝑙 = 𝐶ℎ (𝐶 は正の整数) も成立する。 • このとき、 𝑙 ≤ 𝑗 ≤ 𝑟 となるどの 𝑗 についても、 𝐴𝑗 = 𝐴𝑙 + (𝐴𝑘+1 − 𝐴𝑘) 𝑗−1 𝑘=𝑙 = ℎ(𝐶 + 𝐵𝑘 𝑗−1 𝑘=𝑙 ) となるから、 𝑔 は ℎ の 倍数である。 • よって 𝑔 ≥ ℎ も成立し、 𝑔 = ℎ が成立する。 満点解法 • よって、segment-tree に、管理する区間に含 まれる、隣り合う差の GCD と左端の要素を保 存しておき、質問クエリに対して、それぞれの 区間ごとに区間内の隣り合う差の GCD をまと め、それらの隙間の部分と左端の要素をまと めれば質問に答えることができる。これは O(log 𝑁) である。 • 増減クエリに対して、隣り合う差の GCD は、 区間に一部またがる場合のみ更新される。 • この方法だと O(log 𝑁) で更新できる。 満点解法 • 左端の要素 𝐴𝑙 に関する情報について、増減 クエリそのまま個々の要素に実行すると時間 がかかる。 • 区間和として、質問クエリに対し遅延評価を するとこの問題を解決できる。 • 全体で O(𝑀 log 𝑁) となり満点が得られる。 補足 • 今回の問題に、「初期状態およびクエリ実施 後にすべての数が 1 以上 109 以下となる」と ありますが、遅延評価用にとっている区間の 中身が 32 bit 整数に収まるとは限りません。 • 初期状態で 𝐴1 = 𝐴2 = 1 として • 9 × 108 1 2→ −9 × 108 1 1→ −9 × 108 2 2 というのが 3 回以上繰り返された場合など。 • 2 の補数表記の性質上、実は考慮しなくても うまくいく場合があるみたいです。 AtCoder Regular Contest 016 解説 AtCoder株式会社 代表取締役 高橋直大 A問題 問題概要 • クイズゲームの選択肢の種類と、正解番号が 与えられる • 不正解のものを１つ消したいので、１つ選ん で出力しなさい。 A問題 解説 • 与えられた整数を2つ、標準入力から読み取 る – わからない場合は標準入力について勉強！ • その整数2つから、不正解の番号を１つピック アップする – やり方は色々！ • 出てきた答えを出力する – わからない場合は標準出力について勉強！ A問題 解説 • 数字の選び方いろいろ – 1つ上の数字を選択する • 1なら2,2なら3のような感じ • 最大の数の時は1を出力する – 答えが1の時だけ2,それ以外は1を出力する – Forループなどで、全てのパターンを確認する – 正解でない数字になるまでランダムで選び続ける B問題 問題概要 • 音楽ゲームの譜面が与えられる • ボタンを押す回数を求めなさい B問題 解き方 • １行ずつ文字列を読み込む – 配列に入れておくと良い • １行目は、oまたはxの数をカウントする。 • ２行目以降は、 – xがあった場合、1つカウントする。 – oがあった場合、1つ上の行を確認し、oでなけれ ば1つカウントする • カウントした答えを出力する B問題 ちょっと特殊な解き方 • 縦横を入れ替えて、文字列”oo”を”o”に置換 できなくなるまで置換した後、oとxを数える。 – 普通に解いた方が多分楽です。 C問題 問題概要 • くじが複数与えられる。 • 事前に出現するカードとその確率、及び値段 が与えられている。 – 外れは存在しない。 • 全てのカードを集めるのに必要な金額の期待 値を出力せよ。 • カードNは10種類以下。くじMは4種類以下 C問題 部分点 • 部分点A N=1かつM=1 – カード１枚、くじも１つ • 部分点B N=1 – カード１枚、くじは複数 • 部分点C C_i = 1 – カードもくじは複数だが、1つのくじから出るカードは1種類 だけ。 • 部分点D N<=2 – カードが２種類まで • 部分点E M=1 – くじが１種類だけ C問題 解説 部分点A • くじを１回引けば必ず目的のカードが引ける。 • くじの金額を出力すれば良いだけ。 C問題 解説 部分点B • くじは複数与えられるが、カードは1枚しか存 在しない。 • 一番安いくじを引けば良い。 C問題 解説 部分点C • 1つのくじから1種類のカードしか出現しない。 • それぞれのカードについて、一番安いくじを引 けば良い。 C問題 解説 部分点D • 2種類のカードが与えられる。 • カードAを引くために必要な金額の期待値と、 カードBを引くために必要な金額の期待値をあら かじめ求めておく。 – c円のくじで、カードAが確率pで現れる時、引く回数の 期待値は1/p個。 • よって、C/p円が期待値となる。 • これの最小値を求めれば良い。 • それぞれのくじについて、カードAを引いた場合と、 カードBを引いた場合のそれぞれについて、期待 値を求めてあげれば良い。 C問題 解説 部分点E • いわゆる「コンプガチャ問題」 • 部分点Dと同じように、「この先からいくらかか るか」をメモしてあげれば良い。 • 持っているカードの状態ごとに、それぞれ bitDPで期待値を求めてあげれば良い。 C問題 解説 部分点E • 具体例 – 全てのカードが揃っている場合 • 期待値は0 – カードが4枚あり、カードAだけ存在しない場合 • 期待値は、「カードAを引くまでに必要な回数の期待値」＊ 「カードの枚数」 – カードが4枚あり、カードA,Bが存在しない場合 • カードAが引ける確率をa,カードbを引ける確率をbとする。 • 期待値は、(金額/(1-a-b)) + [カードAだけ存在しない場合の 期待値]*a/(a+b)+[カードBだけ存在しない場合の期待 値]*b/(a+b) • このような感じでbitDPをしてあげれば良い。 bitDPって？ • 持っているカードの種類を、2進数で表す。 • 3枚のカードがあるなら、0～7で表せる。 – A,B,Cのカードがあるなら、7 (２進数で111) – A,Bのカードがあるなら、3(２進数で011) – B,Cのカードがあるなら、6(２進数で110) • これを利用して、状態ごとの期待値を簡単に 配列に収めることが出来る。 C問題 満点解法 • 部分点Eに対し、各カードの状態に対して、く じを全て試し、最小値を求めてあげれば良い。 – 直前のあたりはずれに関係なく、揃えているカー ドの状態にのみしか、引くべきくじに影響を与えな いことに注意 D問題 問題概要 • DAGが与えられる • 体力が設定されており、各頂点対して、減少する体力 が設定されている。 • 頂点1からスタートし、体力1以上で頂点Nに移動する までの期待値を求める。 • プレイヤーは、以下の２つの行動をとることが出来る。 – 今まで受けたダメージ分だけ時間を消費し、頂点1に戻る。 – 時間1を消費し、次の頂点に移動する。なお、この際に選 択される頂点は、接続されている頂点の中から等確率で ランダムに選ばれる。 • 体力0になる可能性が少しでもあるような選択肢は選 ぶことが出来ない。 DAGって何？ • Directed acyclic graphの略 • 閉路のない有向グラフのこと。 D問題 問題解説 • 今いる場所、今まで受けたダメージの2つで DPを行う。 • 始点に戻る、という選択肢があるため、それ だけを除くとDAGとなる。 – よって、「始点からの期待値」を固定できれば、 DAG上のDPとなる。 – 始点からの期待値を二分探索してしまえば良い。 AtCoder Regular Contest 015 解説 AtCoder 株式会社 代表取締役 高橋直大 A問題 問題概要 • 問題概要 – 摂氏での温度nが与えられるので、華氏に変換せ よ。 – 計算式は、(9÷5×n)+32である A問題 解法 • 整数を読み込み、前述の計算式で計算する • 結果は小数になり得ることに注意 • 解けない人は、「標準入力」「標準出力」あた りを勉強してみよう！ B問題 問題概要 • ある期間の、最低気温および最高気温が与 えられる • 猛暑日・真夏日・夏日・熱帯夜・冬日・真冬日 が、それぞれ何回あったかを出力せよ B問題 解法 • 順番に最低気温・最高気温を読み込み、それ ぞれ各条件を満たしているか調べていく • 解けない場合は、「繰り返し(for)」「場合分け (if)」などを勉強してみよう！ C問題 問題概要 • いくつかの単位と、それに対する換算表を与 えられる – 例: 1m = 100cm, 1km = 1000m • 最大の単位を、最小の単位で表しなさい – 例: 1km = 100000cm – これは、10^9以下の整数のみで表現可能 • 最小・最大は換算表から確定出来る C問題 解説 • １つの単位で全部の単位を表してあげれば 良い – 幅優先探索・深さ優先探索・ワーシャルフロイド 等 C問題 落とし穴 • 全ての単位が最小単位によって整数で表現 可能とは限らない！ – 例:B=5A B=3C D=30C – このとき、C=1.6666….A • 分数で表すのにも、膨大な桁数が必要 – N=200なので、結構大変 – 誤差が多少出ても問題ないので、小数で計算し た方が安全 D問題 概要 • クッキーを毎秒１個作る • 毎秒確率pで出現する金色クッキーをクリック すると、t_i秒の間、生産量がx_i倍になる。i番 目の効果が発生する確率はp_i • T秒間クッキーを作った時のクッキーの数の 期待値を出力せよ D問題 解説 • 出来次第再アップロードします！ AtCoder Regular Contest 002 解説 AtCoder株式会社 代表取締役 高橋 直大 A問題 問題概要 • 西暦の年数が与えられる • その年がうるう年かどうかを判定しなさい。 A問題 解説 • 規則3,2,1,4の順で実装を行う。 • If文を並べればＯＫ！ B問題 問題概要 • Y/M/Dの形式で日付が与えられる。 • y/m/dが整数となるような次の日付を出力せ よ。 B問題 解説 • １日ずつ進めていく！ – 日付ライブラリとかある言語を使おう！ – 存在しない場合は、A問題のうるう年判定を合わ せて、１２月までの日数を予め配列に入れておく などして対応しよう！ C問題 問題概要 • ABXYの4種類で書かれた文字列が存在する。 • L,Rの2文字に、2文字分の意味を持たせるこ とで、この文字列を圧縮したい • 圧縮後の最小文字数を答えなさい C問題 間違った解き方 • 全通り置換するだけ • 例えば、ABABBABAのようなケースがダメに なってしまう。 – L = AB、R= BAでLLRRが正解 – Lを出来るだけ置換すると、LLBLAになってしまい、 Rに置換することが出来ない。 • テストが弱い影響で、これで通っちゃう場合があるみ たいです。申し訳ありません。 C問題 解説 • L,Rを全通り試す。 • それぞれに対し、何文字目までいくつの文字 で表せたかをDPで計算する。 – ただの置換ではだめ！ C問題 解説 • S = ABABBABA, X = AB, Y = BAのとき – まずは普通にABで表した時の数字を入れる A B A B B A B A 0 1 2 3 4 5 6 7 8 C問題 解説 • S = ABABBABA, X = AB, Y = BAのとき – Xを適用。ABに対して+1の更新を行う。 A B A B B A B A 0 1 2 3 4 5 6 7 8 0 1 1 2 2 3 4 4 5 C問題 解説 • S = ABABBABA, X = AB, Y = BAのとき – Yを適用。XYに対して+1の更新を行う。 • こうしたDPを全通り行う A B A B B A B A 0 1 2 3 4 5 6 7 8 0 1 1 2 2 3 3 4 4 D問題 問題概要 • 以下のように、将棋の歩の動きをする駒が大 量にあるボードゲームがある – 持ち駒は存在しない。初期配置で取れる駒は存 在しない。どちらが勝つかを求める – 相手の陣地（端）に到達したら勝ち D問題 解説 • 問題サイズは、2000*2000 – 探索等の処理は無理 • 何か規則性を見つけよう！ D問題 解説 • 基本的な処理 – 自分の目の前に敵がいないような駒が存在する 場合 • 片方にいる場合は、そちらの勝ち • 両方にいる場合は、先に辿り着ける方が勝ち – そうでない場合 • 自分から取られに行くような操作は不利 – 取られた瞬間取り返す、みたいなのは別だが、考える必要は ない。理由は後述。 • 取られないような操作だけを考えれば良い D問題 問題解説 • 先手が動かした後、後手はどの駒を動かして も取られる状態になってしまう。 • このような状態の時、取られた直後にまた同 じ状態になる。つまり負けが確定してしまう。 D問題 問題解説 • つまり、先に取られる様な動きをしてしまった 方が負け – 相手に取られない動きを何手打てるかが重要 • この手数だけに注目し、相手との手数の差を 最大化するような手だけを打てば良い。 – これは、向かい合っている駒の数だけで判定が 可能なので、ソートして貪欲。 AtCoder Regular Contest 001 解説 AtCoder株式会社 代表取締役 高橋直大 A問題 問題概要 • 1,2,3,4の４種類の文字で書かれた文字列が 与えられる。 • 一番多い数字の個数と、一番少ない数字の 個数を出力しなさい。 A問題 解説 • プログラムの一例は以下の通り – 標準入力から文字数を読み込む – 標準入力から文字列を読み込む – 要素数４の配列を用意する – 全ての文字に対しループで判定を行う • 文字に対応した配列をインクリメントする – 配列の中で、最小値と最大値を出力する • 適切な関数が存在しない場合はループで取り出す B問題 問題概要 • エアコンの設定温度をA度からB度に変更した い • １回ボタンを押すことで変更可能な温度は、１ 度、５度、１０度の３種類。上にも下にも変更 できる • ボタンを押す必要のある最小回数を出力 B問題 解説 • 解き方は複数存在する – 幅優先探索を用いる – 差が10度以下になるまで、10度の変更をする。 10度以下は埋め込み – 全部の温度に対して最短距離をワーシャルフロ イドなどで計算してしまう • どれを書いても良い C問題 問題概要 • 8-queen問題の、3つのクイーンを置いた状態 が与えられる • 残りの5つを配置せよ。もし不可能な場合は No Answerと出力せよ。 C問題 解説 • 全通り試すのが簡単に出来るため、深さ優先 探索で良い。 – 同じ列や行にすでに２つ置かれていたら失敗 – 置かれていないのであれば、残った５行に残った ５列を割り当てる。この割り当て方は5!通り • それぞれのパターンに対して、8-queenの条件を満た しているか確認する D問題 問題解説 • 右図のような道が与えられる • 道の上しか通ることが出来ない • 最短経路を求めなさい – 幅は1,000,000以下 – 高さは200,000以下 D問題 解説 • 最短経路ならダイクストラ法？ – 頂点Vに対して、O(V^2)かO(ElogV)程度かかって しまう。 – V=400,000, E=V^2なので、どちらも間に合わない • 実際は交差しないかどうかを判定しないといけないの でさらに計算量がかかる。愚直実装でO(V^3) • グラフの特徴を利用して、なんか工夫しない とだめ！ D問題 解説 • 考察してみよう！ – 頂点と赤・青の点以外は考える必要がない – 後ろに戻ることは絶対にない • ってことは動的計画法でいけそう？ D問題 解説 • 各頂点に対して、距離をDPで求める – 高さ0は距離1 – 高さjはdp[j] = min(dp[j], dp[i] + dist(point[i], point[j])) • 実際は左右の頂点が存在するので、両側について考 えなければならない • もちろんdist関数は単純な距離だけではなく、交差判 定を行わなければならない。 – 更新回数はV^2 / 2程度？ D問題 解説 • 範囲を絞って枝刈り？ – これ以上先に絶対行けない場合は更新を止める • ステップを更新するごとに、行ける角度などが狭まって行く • 交差判定もこれだけで十分 – 余計な頂点は無視 • 明らかに窪んでいる点や、直線になっている点など • 最悪ケースはそれでもO(V^2) – これでは通らない » データセットが弱かったようで、かなり高速化すると通ってし まうケースもあるようです。ごめんなさい＞＜ D問題 解説 • 基本的なアイデア – 凹んでる場所に行く必要は絶対にない D問題 解説 • 基本的なアイデア – 凹んでる場所に行く必要は絶対にない – であれば、持つべき情報は、以下のような形の データ • 現在位置から、凹まずに行ける経路を左右独立に持 つ D問題 解説 • 更新方法 – 以下のような頂点が与えられた場合 D問題 解説 • 更新方法 – 以下のような頂点が与えられた場合 – 角度が浅いものを消してしまい、更新していく D問題 解説 • 更新方法２ – 以下のような頂点が与えられた場合 D問題 解説 • 更新方法 – 以下のような頂点が与えられた場合 – 交差してしまう？ D問題 解説 • 更新方法 – 以下のような頂点が与えられた場合 – 交差した時は、交差してしまった方を確定させ、 現在位置を変更する D問題 解説 • 先ほどの様な更新方法をした場合 • どちらが内側にあるかを調査するごとに、考 えている頂点が１つ減る – よって、この回数はO(V)で良い。 • これで十分な証明は各自考えてください！ 