I might come back wrap this up later today or tomorrow 2023-03-08 go back and correct my Wrong errors in the scraping of the .pdf file Full Editorials from the underlying URLs and transcribe every single Editorial in to this .txt file recommit the entire folder en masse with the underlying .pdfs and also maybe store my local Project Leonhard Euler .txts in a better way for review along with the CSES Solutions Notes and Editorials. ---------- A - Swap Odd and Even Editorial by en_translator Swap S 2i−1 ​ and S 2i ​ actually for each i=1,2,…, 2 ∣S∣ ​ and print the resulting S. Depending on the language you use, the index may differ by one from the problem statement, because many languages adopt 0-based indexing. B - Call the ID Number Editorial by en_translator Write a program that memorizes whether each of the N people were called out, while simulating the actions of person 1, person 2, …, and person N in this order, and your program will be accepted. A sample code in C++ language follows. C - Make Takahashi Happy Editorial by en_translator When a path is fixed, one can determine if the integers on the path are distinct by actually traversing the path. Here, one can use a balanced binary tree for example to determine fast enough if each integer coincides with those visited so far. One can solve the problem by checking as described above for all the possible Takahashi’s paths. Now we consider how to enumerate all the possible paths. A possible path is a sequence of moves that contains exactly (W−1) moves to the left and (H−1) moves to the down. Such a sequence can be enumerated with a recursive function. Using a recursive function: “a path from (i,j) to (H,W)” consists of those starting with a move to the left from (i,j), succeeded by paths from (i,j+1) to (H,W), and those starting with a move to the down from (i,j), succeeded by paths from (i+1,j) to (H,W). Alternatively, when the move to the left is denoted by 0 and down by 1, each possible path corresponds one-by-one to a string of length (H+W−2) consisting of exactly (W−1) 0s and exactly (H−1) 1s, so one can enumerate such sequences by, for example: using bit burteforcing: enumerate integers between 0 and 2 H+W−2 −1, i.e. (H+W−2)-digit integers from 000…0 through 111…1 base 2, with a for loop, and then take those which has (H−1) ones in the base-two representation. use the function next_permutation D - Tying Rope Editorial by en_translator Consider the N ropes as N vertices of a graph, and connecting ropes a and b as an edge connecting vertices a and b; then the problem is rephrased as follows. You are given a graph with N vertices and M edges. The i-th edge connects vertices A i ​ and C i ​ . Every vertex has a degree at most two. Each component is either a cycle or a path; how many cycles and paths are there? A connected component is a cycle if and only if the degree of every vertex is two, so one can store the degree of each vertex and check if each connected component forms a cycle with BFS (Breadth-First Search) for example; this way, the problem has been solved in a total of O(N+M) time. E - Geometric Progression Editorial by en_translator The sequence (a n ​ ) defined by a n ​ = i=0 ∑ n−1 ​ A i satisfies a 0 ​ =0 and a n+1 ​ =Aa n ​ +1. What we want is a X ​ modM. By the equation above, ( a n+1 ​ 1 ​ )=( A 0 ​ 1 1 ​ )( a n ​ 1 ​ ). Since a 0 ​ =0, we have ( a X ​ 1 ​ )=( A 0 ​ 1 1 ​ ) X ( 0 1 ​ ). The components of ( A 0 ​ 1 1 ​ ) X , modulo M, can be found in an O(logX) time with the fast exponentiation (just as we find the X-th power of X modulo M). Thus, the problem has been solved in a total of O(logX) time. Note that, if you use i=0 ∑ X−1 ​ A i = A−1 A X −1 ​ , (A−1) may not have an inverse in mod M. F - Zero or One Editorial by en_translator The base- b representation of N may have d=2,3,…,⌊log 2 ​ N⌋+1 digits. For each d, we want to find fast enough the number of integers b such that the base- N representation of N has d digits, each of which is 0 or 1. Now we fix d and count the number of integers b (which we call good integers) such that the base- N representation of N has d digits. If d=2, b=N−1 (if N≥3) and b=N are the good integers. Next, we assume d≥3. b is a good integers only if N is between 1000…0 and 111…1, base b; in other words, only if N is contained in the segment [l b ​ ,r b ​ ]:=[b d−1 ,b d−1 +b d−2 +⋯+b+1]. Here, if b  =b ′ , then two segments [l b ​ ,r b ​ ] and [l b ′ ​ ,r b ′ ​ ] are disjoint; indeed we have r b ​ = i=0 ∑ d−1 ​ b i < i=0 ∑ d−1 ​ ( i d−1 ​ )b i =(b+1) d−1 =l b+1 ​ (whose inequality is due to d≥3). Therefore, the only candidate of a good integer b is the maximum integer b ^ such that b ^ d−1 ≤N. Hence, all that left is actually representing N in base b ^ and check if every digit is 0 or 1. One can find fast enough the maximum integer b ^ such that b ^ d−1 ≤N with a binary search. G - Triple Index Editorial by en_translator When we know the number of occurrences of each integer, and the number of triples (i,j,k) that satisfies the conditions in the problem statement within a segment [l,r] of the sequence A, we can obtain the two numbers for a new segment whose left or right end is different by one in an O(1) time by delta update. Thus, we can use Mo’s algorithm to solve this problem. What is Mo’s algorithm? We will briefly explain Mo’s algorithm. Let N be the length of sequence A we are interested in, with the 0-based indexing like (A 0 ​ ,A 1 ​ ,…,A N−1 ​ ). Also, we assume the following property. When the answer to a query against a segment [l,r] (which we simply call query [l,r]) is known, we can obtain the answer to a query against a new segment whose left or right end is different by one fast enough (here, for simplicity, assumed O(1) time). After answering a query [l,r], we can repeatedly increment or decrement l or r to change the left end l→l ′ and right end r→r ′ in order to find the answer to the next query [l ′ ,r ′ ] in an O(∣l ′ −l∣+∣r ′ −r∣) time. If we naively adopt this way to answer the queries [l 1 ​ ,r 1 ​ ],[l 2 ​ ,r 2 ​ ],…,[l Q ​ ,r Q ​ ] in the given order, each transformation [l i ​ ,r i ​ ]→[l i+1 ​ ,r i+1 ​ ] costs a total of Θ(QN) time over all queries at worst; Mo’s query tries to optimize the process by cleverly rearranging the queries. (Thus, all queries have to be given beforehand.) Specifically, we define the order of answering Q queries [l,r] as follows: For a fixed integer B, queries with smaller ⌊l/B⌋ are answered earlier; if ⌊l/B⌋ are the same, those with smaller r are answered earlier. We evaluate the time complexity of this algorithm as follows. First, we count how many times l is shifted. Transformations such that ⌊l i ​ /B⌋=⌊l i+1 ​ /B⌋ occurs O(Q) times in total, each of which shifts the left end by O(B) amount. Transformations such that ⌊l i ​ /B⌋<⌊l i+1 ​ /B⌋ occurs O(N/B) times in total, each of which shifts the right end by O(N) amount. Then we consider how many times r is shifted. Among the transformations [l i ​ ,r i ​ ]→[l i+1 ​ ,r i+1 ​ ], we first consider those such that ⌊l i ​ /B⌋=⌊l i+1 ​ /B⌋. Within the queries with the same ⌊l/B⌋, they are sorted in ascending order of r; that is, while the group of queries with the same ⌊l/B⌋ is processed, r increases monotonically. Thus, the right end shifts O(N) times for each group of queries with the same ⌊l/B⌋. Since there are O(N/B) distinct possible values for ⌊l/B⌋, i.e. there are O(N/B) groups, so the right end shifts O(N 2 /B) times in total. those such that ⌊l i ​ /B⌋<⌊l i+1 ​ /B⌋ occurs O(N/B) times, each of which costs O(N) times to shift them. Therefore, the algorithm runs in a total of O(QB+N 2 /B) time. By taking B around N/ Q ​ , the problem can be solved in a total of O(N Q ​ ) time. Ex - Optimal Path Decomposition Editorial by en_translator We do binary search for the answer. Hereinafter, we consider whether the answer can be at most K. Take an arbitrary root to consider it as a rooted tree; we do tree DP (Dynamic Programming) on it. Let dp v ​ be the minimum possible maximum number of distinct colors of the vertices in a path from v to its ancestor. Also, let us define f v ​ by f v ​ =1 if, when the minimum is achieved, there are two children of v painted in the same color as v (i.e. if v’s parent cannot be painted in the same color as v), and f 0 ​ otherwise. It does not decrease the maximum distinct colors on a simple path to increase the maximum distinct colors of the vertices in a simple path from v to its ancestor so that v’s parent is painted in the same color as v. Thus, we only have to consider the state where the maximum distinct colors of the vertices in a simple path from v to its parents is dp v ​ and where v’s parent can be painted in the same color as v if f v ​ =0 and cannot be if f v ​ =1. Now we consider the transitions of the DP. Let X be the descending sequence consisting of dp w ​ for all children w of v such that f w ​ =0, and Y be the descending sequence consisting of dp w ​ for all children w of v such that f w ​ =1. Also, let x be the length of the sequence X, and y be the length of Y. For each vertex v, there are at most two children of v that are painted in the same color as v, so we can divide into the following three cases: Case 1: no children of v is painted in the same color as v. Case 2: one children of v is painted in the same color as v. Case 3: two children of v is painted in the same color as v. Now we consider the optimal solution provided that the answer is at most K. First of all, if x=0, then the only possible case is case 1, while if x  =0, we can choose case 2 instead of case 1 without worsening the situation, so all we have to do is to compare cases 2 and 3. It is optimal to choose children w of v with the smallest dp w ​ , so dp v ​ =max(X 1 ​ ,X 2 ​ +1,Y 1 ​ +1) for case 2 and dp v ​ =max(X 1 ​ ,X 2 ​ ,X 3 ​ +1,Y 1 ​ +1) for case 3. ( X or Y may not have enough number of elements, in which case we can exclude them from max.) We now consider when to adopt case 3. Obviously, x≥2 is necessary, so we assume x≥2. Let sequence C be (X 1 ​ −1,X 2 ​ ,…,X x ​ ,Y 1 ​ ,…,Y y ​ ) sorted in descending order, and sequence D be (X 1 ​ −1,X 2 ​ −1,…,X x ​ ,Y 1 ​ ,…,Y y ​ ) sorted in descending order. If case 2 is adopted, the answer turns out to be at least C 1 ​ +C 2 ​ +1; if case 3 adopted, the answer turns out to be at least D 1 ​ +D 2 ​ +1. Here, since C 1 ​ +C 2 ​ +1≥D 1 ​ +D 2 ​ +1, we can determine that we choose case 3 if and only if max(X 1 ​ ,X 2 ​ +1,Y 1 ​ +1)>max(X 1 ​ ,X 2 ​ ,X 3 ​ +1,Y 1 ​ +1) or C 1 ​ +C 2 ​ +1>K. Therefore, the decision problem has been solved. In the discussion above, we sorted the sequence, but actually it need not be sorted, but we just have to take a constant number of largest elements, so the decision problem can be solved in an O(N) time. Considering the HL (Heavy-Light) decomposition, the answer is bounded by O(logN), so the problem has been solved in a total of O(NloglogN) time. A - CAPS LOCK Editorial by en_translator If you are new to learning programming and do not know where to start, please try Problem A “Welcome to AtCoder” from practice contest. There you can find a sample code for each language. Also, if you are not familiar with problems in programming contests, we recommend you to try some problems in “AtCoder Beginners Selection” (https://atcoder.jp/contests/abs). 「競プロ典型 90 問」(Typical 90 Problems of Competitive Programming) (https://atcoder.jp/contests/typical90) is a collection of typical 90 competitive programming problems; unfortunately, currently the problem statements are all Japanese. 「C++入門 AtCoder Programming Guide for beginners (APG4b)」(https://atcoder.jp/contests/APG4b) is a C++ tutorial for competitive programmers. Sadly, this is only in Japanese too. One can convert a lowercase English character c to uppercase with, for example in C++, toupper function: // Let C be uppercased c char C = toupper(c); Thus, it is sufficient to uppercase each character of S with a for statement. Sample code (C++) #include <bits/stdc++.h> using namespace std; int main() { 	string S; 	cin>>S; 	 	string T = ""; 	 	for(int i=0;i<S.size();i++)T += toupper(S[i]); 	 	cout<<T<<endl; 	 	return 0; } B - Yellow and Red Card Editorial by en_translator This problem has several approaches. Since the constraints are small enough, any solution that obeys the rules in the problem statement will be accepted. For example, we can come up with the following simple algorithm: Prepare a list v that stores the past events, which is initially empty. For each i=1,2,…,N: receive the i-th event (c i ​ ,x i ​ ). Depending on c i ​ , do nothing if c i ​ =1,2; if c i ​ =3, inspect all the events up to the (i−1) one by scanning v to count the number of yellow and red cards that person x i ​ received. If the number of cards satisfies the condition for the removal, print Yes; otherwise, print No. Then, add (c i ​ ,x i ​ ) to v. This algorithm scans (i−1) events in the i-th query, so the scan may cost be up to ∑ i=1 Q ​ (i−1)= 2 Q 2 −Q ​ steps. Thus, the complexity is O(Q 2 ). The algorithm above is fast enough to get AC (accepted), but we may improve the complexity to O(N+Q) with a little tweak. In order to reduce the complexity, we use arrays to record the number of yellow card that each person received, and whether each person was removed, and update them for every event. This way, we do no longer need to scan all the event for each question, leading to a speed up. Specifically, implement the following procedure. Prepare a length- N array y that records “how many yellow cards did person x received?” and another length- N array r that records “was person r removed?”. y is initialized with 0, and r with false. For each i=1,2,…,N: receive the i-th event (c i ​ ,x i ​ ). Depending on c i ​ , if c i ​ =1, increment y[x] by 1. If y[x] reaches by 2, person x is removed so let r[x] be true. If c i ​ =2, person x is removed, so let r[x] be true. If c i ​ =3, print Yes if r[x] is true and No otherwise. The complexity is O(N+Q). This algorithm enables us to write a code that works even with N,Q≤10 5 . Sample code (C++) #include <iostream> #include <vector> using namespace std; int main() { int N, Q; cin >> N >> Q; vector<int> r(N + 1), y(N + 1); while (Q--) { int cmd, x; cin >> cmd >> x; if (cmd == 1) { y[x]++; if (y[x] == 2) r[x] = 1; } else if (cmd == 2) { r[x] = 1; } else { cout << (r[x] ? "Yes" : "No") << endl; } } } Bonus (worth problem C): how can we support N=10^18 and Q=10^5 fast enough? C - Four Variables Editorial by en_translator O(N N ​ ) Solution We can exhaustively enumerate all (A,B,C,D) and check if AB+CD=N to find the answer in a total of O(N 4 ) time, but it is too slow for the execution time limit. For a fixed (A,B,C), there is at most one D such that AB+CD=N, which can be determined by checking if N−AB is non-negative and is a multiple of C, so we can find the answer by exhaustively enumerating (A,B,C) in a total of O(N 3 ) time, but this is too slow as well. When the value AB is fixed to X, the value CD, which we denote by Y, is determined to be N−X. As we described above, fixing A determines B, and C determines D. By exhaustively searching all values for X, A, and C, the cost is still O(N 3 ); however, we can find the number of (A,B) such that X=AB and (C,D) such that Y=CD independently, so it can be reduced to O(N 2 ). Moreover, if we assume A≤B, the value A such that X=AB satisfies A≤ X ​ , and same holds for C and D. Thus, the problem can be solved in a total of O(N N ​ ) time. Sample code (C++) #include <bits/stdc++.h> using namespace std; int main() { 	int N; 	cin>>N; 	 	long long ans = 0; 	 	for(int i=1;i<N;i++){ 		int X = i,Y = N-i; 		long long x = 0,y = 0; 		for(int j=1;j*j<=X;j++){ 			if(X%j==0){ 				x++; 				if(X!=j*j)x++; 			} 		} 		for(int j=1;j*j<=Y;j++){ 			if(Y%j==0){ 				y++; 				if(Y!=j*j)y++; 			} 		} 		ans += x * y; 	} 	 	cout<<ans<<endl; 	 	return 0; } O(NlogN) solution The number of pairs of positive integers (A,B) such that AB=X equals the number of positive divisors of X. Also, for a positive integer x, the integers whose positive divisors contain x are x,2x,3x,…. Thus, one can count the number of divisors of each value by preparing a length- N array and increment the elements whose indices are multiples of x. The increment happens about x N ​ times for each x, for a total of about ( 1 N ​ + 2 N ​ +…+ N N ​ ) times. It is known that we can evaluate it as O(NlogN) (which is called the harmonic series), so this solution is faster than the O(N N ​ ) solution above. D - Unicyclic Components Editorial by en_translator One can manage the connectivity of an undirected graph easily with a data structure called Union-Find or DSU (Disjoint Set Union). In this editorial, we describe a solution that uses dsu of AtCoder Library. In order to solve this problem, we have to determine which connected component each vertex belongs to. AtCoder Library dsu enables us to find the index of representative vertex of the connected component that vertex x belongs to, as follows: // Use atcoder::dsu D to assign to l the index of the representative vertex of the connected component containing x l = D.leader(x); It is sufficient to check if every connected component has the same number of edges and vertices. Sample code (C++) #include <bits/stdc++.h> #include <atcoder/dsu> using namespace std; using namespace atcoder; int main() { 	int N,M; 	cin>>N>>M; 	vector<int> u(M),v(M); 	for(int i=0;i<M;i++){ 		cin>>u[i]>>v[i]; 		u[i]--,v[i]--; 	} 	 	dsu D(N); 	for(int i=0;i<M;i++){ 		D.merge(u[i],v[i]); 	} 	 	vector<int> vs(N),es(N); 	for(int i=0;i<N;i++){ 		vs[D.leader(i)]++; 	} 	 	for(int i=0;i<M;i++){ 		es[D.leader(u[i])]++; 	} 	 	if(vs==es)cout<<"Yes"<<endl; 	else cout<<"No"<<endl; 	 	return 0; } E - Transitivity Editorial by en_translator The optimal strategy is to repeatedly find distinct vertices a, b and c such that a directed edge from vertex a to vertex b and another from vertex b to vertex c exist but one from vertex a to vertex c doesn’t, and add a directed edge from vertex a to vertex c; however, it is a bit difficult to finish it within the execution time limit. In fact, a directed edge from vertex x exists in the final graph if and only if it goes to a vertex reachable from vertex x in the original graph (except for x itself). Proof The simulation described above adds a directed edge from x to y while there is a vertex y whose distance from a vertex x is two. This operation does not change the vertices reachable from x. Also, when the operation is no longer possible, there is no vertex whose distance from x is two, so the edges going out from x in the final state all go to the vertices reachable from x in the original state. Therefore, it is sufficient to count the reachable vertices from each vertex in the original graph with BFS (Breadth-First Search) or DFS (Depth-First Search). Since one can perform BFS or DFS from a vertex in an O(M) time, the total complexity is O(NM). Sample code (C++, with BFS) #include <bits/stdc++.h> using namespace std; int main() { 	int N,M; 	cin>>N>>M; 	vector<vector<int>> E(N); 	 	for(int i=0;i<M;i++){ 		int u,v; 		cin>>u>>v; 		E[u-1].push_back(v-1); 	} 	 	int ans = 0; 	 	for(int i=0;i<N;i++){ 		vector<bool> f(N,false); 		f[i] = true; 		queue<int> Q; 		Q.push(i); 		 		while(Q.size()>0){ 			int x = Q.front(); 			Q.pop(); 			for(int j=0;j<E[x].size();j++){ 				int y = E[x][j]; 				if(f[y])continue; 				f[y] = true; 				Q.push(y); 				ans++; 			} 		} 	} 	 	ans -= M; 	cout<<ans<<endl; 	 	return 0; } F - Regular Triangle Inside a Rectangle Editorial by en_translator In the optimal fit, we may assume that the regular triangle and the rectangle shares at least one vertex. Proof Consider the topmost, bottommost, rightmost, and leftmost point on the regular triangle; in fact, there is at least one such vertex each. Also, a vertex cannot be simultaneously be the topmost and bottommost, or rightmost and leftmost, so the triangle always satisfies at least one of the following statements: There exists a vertex that is the topmost and rightmost point on the triangle. There exists a vertex that is the topmost and leftmost point on the triangle. There exists a vertex that is the bottommost and rightmost point on the triangle. There exists a vertex that is the bottommost and leftmost point on the triangle. For example, if the first statement hold, then we can shift the triangle so that that vertex coincides with at least one of the vertices of the rectangle, so we can assume that the optimal fit satisfies this assumption. How can we determine if a regular triangle of side l can be drawn in the interior of the rectangle? (If we can do so, we can solve this problem by doing binary search for the maximum side length l that can be drawn in the rectangle.) With appropriate rotation and inversion, we assume that the bottom-left vertex of the rectangle coincide with a vertex of the triangle. Let θ be the angle between the lower edges of the rectangle and the triangle. Then the angle between the lower edge of the rectangle and the upper edge of the triangle is θ+60 ∘ . Also, since θ≥0 ∘ and θ+60 ∘ ≤90 ∘ , we have 0 ∘ ≤θ≤30 ∘ . Here, the width of the triangle is lcosθ and the height is lsinθ, so we need to find if there is a θ such that cosθ≤ l B ​ ,sinθ≤ l A ​ ,0 ∘ ≤θ≤30 ∘ . (within 0 ∘ ≤θ≤30 ∘ , ) cosθ decreases and sinθ increases as θ increases. Thus, we may find the minimum θ such that cosθ≤ l B ​ within the range value (using binary search or by evaluating cos −1 θ depending on whether l B ​ is between 0 and 2 3 ​ ​ ), and check if this satisfies sinθ≤ l A ​ . G - Count Strictly Increasing Sequences Editorial by en_translator Let dp i,j,k ​ be “the number of ways to determine the (k+1)-th and later digits of S i ​ ,S i+1 ​ ,…,S j−1 ​ such that S i ​ <S i+1 ​ <…<S j−1 ​ within those digits.” (DP stands for Dynamic Programming.) Here, within the specified segment, the (k+1)-th digits are weakly increasing; additionally, within a segment with the same (k+1)-th digits, the (k+2)-th and later digits must form weakly increasing integers. Thus, the DP can be evaluated by considering the ways to split S i ​ ,S i+1 ​ ,…,S j−1 ​ into segments where the (k+1)-th segments are 0, 1, …, and 9. Specifically, we evaluate dp i,j,k,l ​ = “the number of ways to determine the (k+1)-th and later digits of S i ​ <S i+1 ​ <…<S j−1 ​ such that S i ​ <S i+1 ​ <…<S j−1 ​ within those digits and zero or more first (k+1)-th digits are l,” which can be evaluated in a total of O(N 3 Mb) time (where b is the number of kinds of digits). Ex - Rating Estimator Editorial by en_translator First of all, let’s simplify what we evaluate. Let p i ​ be the estimated performance of contest i at some point. Here, let s be the minimum n such that n 1 ​ ( i=1 ∑ n ​ p i ​ )≥B. (If there is no such n, let s=N.) Then the last change of the rating occurs at contest s. Thus, the original problem is solved by finding s above and ∑ i=1 s ​ p i ​ . A deformation yields ​ n 1 ​ ( i=1 ∑ n ​ p i ​ )≥B ⟺ i=1 ∑ n ​ p i ​ ≥nB ⟺ i=1 ∑ n ​ (p i ​ −B)≥0. ​ Using q i ​ =p i ​ −B, we can thus say that s equals the minimum n such that the n-element prefix sum of the sequence (q 1 ​ ,q 2 ​ ,q 3 ​ ,…,q N ​ ) is 0 or greater (or s=N if there is no such n). Therefore, we can solve the problem with a data structure supporting the following three queries fast enough: Set q c ​ to x. Find s defined above. Evaluate ∑ i=1 n ​ q n ​ . There are several ways to process these queries. Here we explain how to put the maximum prefix sum on a segment tree. Here is the detail. For a sequence B=(b 1 ​ ,b 2 ​ ,…,b n ​ ), we define functions f(B) and g(B) by: f(B) g(B) ​ =b 1 ​ +b 2 ​ +⋯+b n ​ , =max{b 1 ​ ,b 1 ​ +b 2 ​ ,…,b 1 ​ +b 2 ​ +⋯+b n ​ }. ​ Then, for two non-empty sequences S and T and their concatenation S+T, we have: f(S+T) g(S+T) ​ =f(S)+f(T), =max{g(S),f(S)+g(T).} ​ Thus, the segment tree which stores tuples (f(B),g(B)) for each segment containing sequences B works well (if the identity element is defined appropriately). The queries of second type can be processed by performing binary search on the segment tree. Hence, the problem can be solved in a total of O(N+QlogN) time, which is fast enough. Sample code (C++) #include <iomanip> #include <iostream> #include <utility> #include <vector> using namespace std; #include "atcoder/segtree.hpp" using T = pair<long long, long long>; T f(T a, T b) { return {a.first + b.first, max(a.second, a.first + b.second)}; } T ti() { return {0, -1e18}; } using Seg = atcoder::segtree<T, f, ti>; int main() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); long long N, B, Q; cin >> N >> B >> Q; vector<long long> a(N); for (auto& x : a) cin >> x; vector<T> init(N); for (int i = 0; i < N; i++) init[i] = {a[i] - B, a[i] - B}; Seg seg{init}; while (Q--) { long long c, x; cin >> c >> x; --c; a[c] = x; seg.set(c, {x - B, x - B}); auto i = seg.max_right(0, [](T v) { return v.second < 0; }); if (i != N) i++; auto s = seg.prod(0, i).first; cout << 1.0 * (s + B * i) / i << "\n"; } }