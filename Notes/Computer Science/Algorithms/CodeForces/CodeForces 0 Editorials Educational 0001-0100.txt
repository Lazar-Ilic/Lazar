Educational Codeforces Round 100 Editorial

By awoo, history, 2 years ago, translation, In English1463A - Dungeon

Idea: adedalic

Tutorial1463A - DungeonNote that for every 7 shots, we deal a total of 9 units of damage. Since we want to kill all the monsters with a shot which index is divisible by 7, let's denote the number of shots as 7k. In this case, a total of a+b+c units of damage must be dealt, hence k=a+b+c9 (if the result of the division is not an integer, then there is no answer). Since each monster will receive at least k units of damage (with enhanced shots), the health of each monster must be at least k. If the two conditions described above are met, then the remaining shots can always be distributed in the desired way.

Solution (Ne0n25)1463B - Find The Array

Idea: BledDest

Tutorial1463B - Find The ArrayIt is enough to consider two possible arrays b: (a1,1,a3,1,a5,…) and (1,a2,1,a4,1,…). It is not difficult to notice that in these arrays, the condition is met that among two neighboring elements, one divides the other. It remains to show that at least one of these two arrays satisfies the condition 2∑i=1n|ai−bi|≤S. Let's consider Sodd — the sum of elements at odd positions and Seven — the sum of elements at even positions. Since S=Sodd+Seven, at least one of the values of Sodd and Seven does not exceed S2 (because otherwise their sum will be strictly greater than S). Without losing generality, assume that Sodd≤S2. Note that for the second variant of the array b, the condition ∑i=1n|ai−bi|≤Sodd holds, so 2∑i=1n|ai−bi|≤S.

Solution (Ne0n25)1463C - Busy Robot

Idea: KAN

Tutorial1463C - Busy RobotThe main idea in the problem is not how to solve it but how to code it neatly. I've come up with the following way.

Let's store three variables: where is the robot now, what direction does it move (−1, 0 or 1) and how much time is left until it stops moving.

The processing of the commands looks becomes pretty easy. If there is no time left to move then the command is executed, and we tell the robot the direction and the time left for the current command. Then there are two cases: either the robot stops before the next command or after it. However, they can be processed simultaneously.

Let T be the minimum of the time left before the robot stops moving and the time before the next command. We sure know that before the next command the robot will visit exactly the segment of positions between the current position and the current position plus direction multiplied by T. If the destination for the current command is in this segment, then that command is successful.

After the command is processed subtract T from the time left and increase the position by direction multiplied by T.

Overall complexity: O(n) per testcase.

Solution (pikmike)1463D - Pairs

Idea: adedalic

Tutorial1463D - PairsLet's prove that in the set b x minimum elements will be from x pairs where we'll take minimums and analogically n−x maximums will be from n−x pairs where we'll take maximums. By contradiction, let's look at two pairs (a,b) (a<b) and (c,d) (c<d), where we will take maximum from (a,b) and minimum from (c,d) and b<c, if we swap elements b and c and get pair (a,c), (b,d), the result won't change, but now minimum from pair (b,d) will be less than maximum from (a,c). So we can always make pairs in such a way that the chosen minimum from any pair will be less than the chosen maximum from any other pair.

Let's make set nb as all elements which are not in b. In the same way, we can prove that n−x minimums of nb are from pairs where we took maximums and x maximums are from pairs where we took minimums.

Let's say b and nb are sorted. Now we've proven that for a fixed x we should pair b1,b2,…,bx with nbn−x+1,nbn−x+2,…,nbn and bx+1,…,bn with nb1,…,nbn−x. It's not hard to prove that it's optimal to pair (b1,nbn−x+1), (b2,nbn−x+2), ..., (bx,nbn) and in the same way (nb1,bx+1), (nb2,bx+2), ..., (nbn−x,bn).

For a fixed x we can just check that constructed pairs are valid. But what happens if we move from x to x+1? If for 1≤i≤n−x all (nbi,bx+i) was valid then for x+1 all pairs (nbi,bx+1+i) will be valid as well. And on contrary, if at least one pair (bi,nbn−x+i) wasn't valid then for x+1 the pair (bi,nbn−x−1+i) won't be valid as well.

Due to monotony we can find the maximum valid x just checking only pairs (bi,nbn−x+i) and in the same way we can find maximum n−x (minimum x) such that all pairs (nbi,bx+i) are valid. That's why all valid x-s form a segment, and we need to find its borders.

We can find a maximum x (maximum n−x) with either binary search or with two pointers and print the length of the segment. Time complexity is either O(n) or O(nlogn).

Solution 1 (adedalic)Solution 2 (adedalic)1463E - Plan of Lectures

Idea: BledDest

Tutorial1463E - Plan of LecturesThe prerequisites for each lecture form a rooted tree, so let's forget about the legend and learn how to find such an order of vertices of a tree that all conditions work.

Let's introduce some algorithm that produces an ordering of vertices for every possible case. If any valid ordering exists, it should produce a valid one. So we will only have to check if the resulting ordering is fine and output it if it is.

If there were no special pairs, the task would be perfectly solvable with an algorithm of topological sorting. Thus, let's come up with a way to modify the graph, so that topsort could still be a solution.

We know that the vertices that are in the special pairs should follow each other in the ordering. Look at these special pairs as edges as well. Let's first imagine they are undirected. These edges connect some vertices in the tree into components. Each component should be a segment of vertices in a valid answer. So how about we compress them into one vertex first each, find some answer for a compressed version and decompress them back?

Let each of these connected components be a vertex in the new graph. Two components are connected by an edge if there is a edge in the tree between vertices of the corresponding components. Topsort in this graph will tell us the order the components should go.

However, we should also find the order the vertices should go inside each component. Let's topsort the graph of all directed special pairs and sort the vertices in that order in every component. We can sort the entire graph instead of sorting each component separately because the components are totally independent.

Finally, write down the answer: iterate over the compressed vertices of the first new graph in the order of its topsort, for each one write down all the actual vertices inside it in the order of the topsort of the second new graph. Check if each vertex has its parent earlier than itself in the answer. If all the graphs were topologically sortable and that holds, then the answer exists, and we found it. Otherwise, the answer doesn't exist.

Overall complexity: O(nlogn).

Solution (pikmike)1463F - Max Correct Set

Idea: Neon

Tutorial1463F - Max Correct SetThe key idea of the task is to prove that there is an optimal answer where the chosen elements in S has a period equal to p=x+y. Let's work with 0,1,…,n−1 instead of 1,2,…,n.

Firstly, let's prove that if we've chosen correct set a1,…,ak in interval [l,l+p) then if we take all ai+p then set {a1,…,ak,a1+p,…ak+p} will be corect as well. By contradiction: suppose we have ai+p−aj=x (y), then ai−aj=x−p=x−x−y=−y (−x) or |ai−aj|=y (x) — contradiction.

It means that if we take the correct set in interval [l,l+p) we can create a periodic answer by copying this interval several times.

Next, let's prove that there is an optimal periodic answer. Let's look at any optimal answer and its indicator vector (binary vector of length n where idi=1 iff i is in the set). Let r=nmodp.

Let's split the vector in 2⌊np⌋+1 intervals: [0,r),[r,p),[p,p+r),[p+r,2p),…,[n−r,n). The 1-st, 3-rd, 5-th... segments have length r and 2-nd, 4-th,... segments have length p−r. If we choose any two consecutive segments its total length will be equal to p and we can use it to make periodic answer by replacing all length r segments with the chosen one and p−r segments with the other one.

We can prove that we can always find such two consecutive segments that the induced answer will be greater or equal to the initial one. If we create vector where vi is equal to the sum of idj in the i-th segment, then the task is equivalent to finding vi and vi+1 such that replacing all vi±2z by vi and all vi+1±2z by vi+1 won't decrease array v sum. The proof is down below.

Now, since the answer is periodical, taking element c (0≤c<p) is equivalent to taking all elements d≡cmodp, so for each c we can calc valc — the number of integers with the same remainder. And for each c we either take it or not.

So we can write dp[p][2max(x,y)], where dp[i][msk] is the maximum sum if we processed i elements and last max(x,y) elements are described by mask msk. We start with dp[0][0] and, when look at the i-th element, either take it (if we can) or skip it.

Time complexity is O((x+y)2max(x,y)).

==========

Let's prove that for any array v1,v2,…,v2n+1 we can find pair vp,vp+1 such that replacing all vp±2z with vp and all vp+1±2z with vp+1 won't decrease the total sum.

Let's define So=∑i=1n+1v2i−1 and Se=∑i=1nv2i. Let's make array b1,…,b2n+1, where b2i−1=(n+1)v2i−1−So and b2i=n⋅v2i−Se. The meaning behind bi is how changes the total sum if we replace corresponding elements by vi.

Note, that finding a good pair vp,vp+1 is equivalent to finding bp+bp+1≥0. Also, note that ∑i=1n+1b2i−1=(n+1)So−(n+1)So=0 and analogically, ∑i=1nb2i=n⋅Se−n⋅Se=0.

Let's prove by contradiction: suppose that for any i bi+bi+1<0. Let's look at ∑i=12n+1bi=∑i=1n+1b2i−1+∑i=1nb2i=0. But from the other side, we know that b2+b3<0, b4+b5<0, ..., b2n+b2n+1<0, so b1>0, otherwise ∑i=12n+1bi will be negative.

In the same way, since b1+b2<0, b4+b5<0, ..., b2n+b2n+1<0, then b3>0. Analogically we can prove that each b2i−1>0, but ∑i=1n+1b2i−1=0 — contradiction. So, there is always a pair bp+bp+1≥0, i. e. a pair vp,vp+1.

Educational Codeforces Round 99 Editorial

By awoo, history, 2 years ago, translation, In English1455A - Strange Functions

Idea: BledDest

Tutorial1455A - Strange FunctionsLet's analyze which values can the function g(x) have. It can be proven that the value of g(x) is equal to 10k, where k is the number of zero-digits at the end of the number x, because f(f(x)) is the same number as x except for the fact that it doesn't have any trailing zeroes.

Okay, now let's analyze when we reach the new value of g(x). 1 is the first value of x such that g(x)=1, 10 is the first value of x such that g(x)=10, 100 is the first value of x such that g(x)=100, and so on. We have to calculate the maximum number that has the form 10k and is not greater than n, and the answer is exactly k+1.

It can be done with a mathematical solution, but the most simple way to do it is read n as a string instead, and calculate its length.

Solution (Ne0n25)1455B - Jumps

Idea: adedalic

Tutorial1455B - JumpsAt first, let's jump with +k while x is still greater than the current position. Now we finished in some position pos=1+2+⋯+steps=steps(steps+1)2≥x. Note that 0≤pos−x<steps otherwise, we wouldn't make the last step.

If pos=x then we are lucky to finish right in point x. Otherwise, let's look at what happens if we replace one +k with −1. Basically, we'll finish in pos′=pos−(k+1). And since k∈[1,steps] then pos′∈[pos−steps−1,pos−2].

We know that pos−step<x so if x<pos−1 then we can choose the corresponding k=pos−x−1 and replace +k with −1 and get straight to the point x. But if x+1=pos then we need one extra operation −1.

To calculate steps fast we can note we need at least steps=2⋅x−−−−√−1 since steps(steps+1)≤(steps+1)2≤2x and then we can increase steps while steps(steps+1)<2x.

Solution (adedalic)1455C - Ping-pong

Idea: Neon

Tutorial1455C - Ping-pongLet's find an answer for a little different version of the game. Let's say that f(x,y) is the final score if the first player has x stamina and the second has y stamina. The first player can either hit the ball or can give up and lose the play.

How to calculate f(x,y)? Obviously, f(0,x)=(0,x) and f(x,0)=(x,0). Otherwise, the first player can

either hit the ball: then the player spent 1 stamina and now it's to the second player to decide — hit or lose. So basically, we moved to the state f(y,x−1) and the answer in this case is rev(f(y,x−1)) where rev(a,b)=(b,a);or lose the play: then the player doesn't spend any stamina, but the opponent has to serve the ball. He serves the ball, spend 1 stamina and return to the state, where the first player decides — hit or lose. Formally, the answer in this case is f(x,y−1)+(0,1).Looking at f(0,x)=(0,x), f(x,0)=(x,0) and one of transitions f(x,y−1)+(0,1) we can guess that f(x,y)=(x,y) and prove it by induction: f(x,y) is either rev(f(y,x−1)) or f(x,y−1)+(0,1), but rev(f(y,x−1))=rev(y,x−1)=(x−1,y) and f(x,y−1)+(0,1)=(x,y−1)+(0,1)=(x,y) and (x,y) is better than (x−1,y), so f(x,y)=(x,y).

The final step is to note that since Alice starts the first play and has to serve ball — the answer is rev(f(y,x−1))=rev(y,x−1)=(x−1,y).

Solution (Ne0n25)1455D - Sequence and Swaps

Idea: BledDest

Tutorial1455D - Sequence and SwapsThe main fact that allows us to solve this problem is that the value of x always increases after swaps, and since the resulting sequence should be sorted, the indices of elements we swap with x also increase.

This observation is actually enough for us to implement a dynamic programming solution of the form "dp_{i, j} is the minimum number of actions we have to perform to reach the following situation: the last integer we swapped with x was ai, and the current value of ai is j". Depending on your implementation, it works either in O(n3) or in O(n2).

But there exists a much simpler to code greedy solution: scan the array from left to right until it is sorted, and find the first element such that we can apply the operation to it (and apply that operation to it). Implementing it in O(n2) or even in O(n) is easy, but proving it is a bit harder. The key fact that is required to prove it is that if we can apply an operation to some position, but don't do it and instead apply this operation to some position to the right of that one, the elements on these two positions are no longer sorted (if we can apply the operation to some position i, then ai>x, but if we apply the operation to position j instead, then after it ai>aj). Since we can't go backward, the resulting array cannot be sorted by any means — that's why we can't skip elements in this greedy solution.

Solution 1 (BledDest)Solution 2 (adedalic)1455E - Four Points

Idea: adedalic

Tutorial1455E - Four PointsLet's discuss two approaches to this problem. Firstly, let's think that we choose not four destination points but four lines on which sides of the square lie. It's two vertical lines with coordinates x1 and x2 and two horizontal lines y1 and y2 (of course, |x1−x2|=|y1−y2|).

The first approach is to note that

either both x1 and x2 coincide with some (pi.x)-s and y1 coincide with one of (pi.y)or both y1 and y2 coincide with some (pi.y)-s and x1 coincide with one (pi.x).Since we know the side of the square (from |x1−x2| or |y1−y2|) and one point (x1,y1) It's easy to construct other points of the square and find the minimum total distance by iterating all permutations. This approach needs around2(two cases)⋅(42)⋅4⋅2y2=y1±|x1−x2|⋅4!⋅4≈104operations and work around one second if written accurately.The second approach is more clever and faster. Let's assign a role for each point pi — which vertex of the final square this pi will be: left-bottom, left-top, right-bottom or right-top. There will be 4! such assignments. For simplicity let's say that the left-bottom vertex is a, left-top is b, right-bottom is c and right-top is d.

If we rewrite our total distance formulas, we can note that instead of summing the distance between points, we can sum the distance from lines to the points which should lie on it. In other words, we can calculate the answer as(|ax−x1|+|bx−x1|)+(|cx−x2|+|dx−x2|)++(|ay−y1|+|cy−y1|)+(|by−y2|+|dy−y2|).Let's look at the left side x1. If min(ax,bx)≤x1≤max(ax,bx) then the total distance is always max(ax,bx)−min(ax,bx) and x1 has it's optimal segment of values. Analogically, x2 also has it's optimal segment of values min(cx,dx)≤x2≤max(cx,dx).

Since we can choose x1 as any value in its segment and x2 as any value in its segment then the possible distance |x1−x2| (the side of the square) also forms a segment of possible values (let's name it as [xSeg.l,xSeg.r]) and can be calculated with pretty easy formula.

On the other hand, we can do the same with horizontal sides and compute the segment of optimal side length [ySeg.l,ySeg.r] in the same manner.

Now, if xSeg and ySeg intersects then we can choose such side length k that lies in both xSeg and ySeg and optimal for both vertical sides and horizontal sides.

Otherwise, without loss of generality, xSeg.r<ySeg.l and if we choose k=ySeg.l we need to pay extra "fee" since we out of xSeg — it means that the chosen k is greater than optimal xSeg.r, so we need to choose, for example, x1 outside [min(ax,bx),max(ax,bx)]. And we need to pay +2 for each step outside of this segment.

In other words, the answer for a fixed permutation is(max(ax,bx)−min(ax,bx))+(max(cx,dx)−min(cx,dx))++(max(ax,cx)−min(ax,cx))+(max(bx,dx)−min(bx,dx))++2⋅max(0,max(xSeg.l,ySeg.l)−min(xSeg.r,ySeg.r)).Solution 1 (adedalic)Solution 2 (adedalic)1455F - String and Operations

Idea: Neon

Tutorial1455F - String and OperationsThe crucial observation that we have to make is that the character that initially occupied the position i cannot occupy the positions to the left of i−2: we can shift some character two positions to the left using a combination of operations RL, but we can't go any further. So, the prefix of the first i characters of the resulting string can only be affected by the prefix of the first i+2 characters of the initial string.

Let's use the following dynamic programming to solve the problem: let dpi be the lexicographically minimum string that we can obtain by applying operations to the first i characters (that is, dpi is the answer to the problem if we consider only i first characters of the original string).

The transitions here are a bit tricky. If we apply the operation U or D to the character i+1, then dpi+1=dpi+c′, where c′ is the character we get when we apply the aforementioned operation to that character. L is a bit more complicated: we have to insert the character si+1 just before the last character of dpi.

Modeling that we can apply the operation R is likely the most complex transition in our dynamic programming. First of all, we can't just make an update to dpi+1 or dpi+2, since it leads us to a situation where we can still apply some operations to the prefix we have built. Instead, we have to consider the operation we will be able to do with the character si+2. Using another operation R is useless since the result is like performing no operations with those two characters at all, so we have to consider two options for operation with the (i+2)-th character — D or U (whichever is better), or L. In the first case, we update dpi+2 by appending the resulting two characters to dpi (the one that we get when we change si+2, and the one that initially was si+1). In the second case, things are a bit trickier, but still not very complicated: the character that was si+2 moves two positions backward, so it is inserted right before the last character of dpi, and then we append si+1 to the string we get.

So, there are four transitions we have to make:

a transition from dpi to dpi+1 that models the case when we apply U or D to the (i+1)-th character;a transition from dpi to dpi+1 that models the case when we apply L to the (i+1)-th character;a transition from dpi to dpi+2 to model the operations RD or RU;a transition from dpi to dpi+2 to model the operations RL.Overall complexity is O(n2) but it can be improved to O(nlogn) with some complicated data structures like persistent segment tree with hashes to compare strings and append characters to them in O(logn).

Solution (Ne0n25)1455G - Forbidden Value

Idea: MrPaul_TUser и BledDest

Tutorial1455G - Forbidden ValueConsider the following dynamic programming. dpij — the minimum cost to make x have value j after the i-th line. The transitions here are pretty easy: on set you just consider two options of skipping or not skipping the instructions and on if you either go to the next line or to the end of the block depending on the value.

There are a lot of possible values, so that dp works in O(n2). First, let's notice that all the values that don't appear in the input won't matter, so you can keep only the existing values in the dp.

Next, let's consider the following modification to it. What happens when you enter an if block? It's actually the same dp but the only starting value is not 0 with cost 0 as in the beginning of the whole program but some value y with some cost c. So let's calculate this dp separately from the outer one and just merge the values together. Notice that if some value doesn't appear inside the if block then its cost can not decrease exiting out of it. Thus, it's enough to calculate the inner dp only for values that appear inside the if block.

Okay, the transitions for if became easier. The set transitions are still slow, though. Examine the nature of them. All the values besides the y written on the set instruction increase their cost by v. As for the y, its cost becomes equal to the cost of the cheapest value before the instruction.

Thus, let's maintain the dp in some data structure that allows to add the same integer to all elements and take the minimum of its elements. That can be done with a set and a single integer that stores the current shift that should be applied to all elements. Surely, you'll also need a map to retrieve the current cost of particular values.

The final part is fast merging of the if block dp and the outer one. It might not appear obvious but if you do that in a straightforward manner of adding all the costs from if one by one it can become O(n2) in total. So we can apply small-to-large and swap these dp's based on their sizes.

Overall complexity: O(nlog2n).

Educational Codeforces Round 98 Editorial

By awoo, history, 2 years ago, translation, In English1452A - Robot Program

Idea: BledDest

Tutorial1452A - Robot ProgramObviously, you can always obtain the optimal answer without using west or south moves. So the shortest path consists of x east moves and y north moves.

Let's estimate the lower bound of the answer. Take a look at these constructions: "E?E?E?E?E" and "N?N?N?N?N" (let question mark be any command different from the used one). That's the tightest you can put east or north moves in.

So the answer is at least 2⋅max(x,y)−1. For x≠y you can put them just as in the construction and fill the rest of question marks with a stay in place move. x=y case works differently, though. You can do it only in x+y moves by taking alternating moves.

Overall complexity: O(1) per testcase.

Solution (BledDest)1452B - Toy Blocks

Idea: adedalic

Tutorial1452B - Toy BlocksSince nephew emptying the box i he's chosen and wants to make all other n−1 box equal then it means that at least the sum of all array a should be divisible by (n−1) and the number of blocks in each other box should be at least ⌈sumn−1⌉ (ceiling function).

On the other side, since nephew chooses i (not you), then he can choose a box which is not a maximum max, and since he makes empty the only box i, then the final number in each other block should be at least max.

In total, the resulting number of blocks in each of n−1 other boxes should be at least k=max(⌈sumn−1⌉,max) and we need to add at least (n−1)⋅k−sum elements to the initial array.

We can always reach this lower bound if we will put each block in the box with the current minimum number of blocks.

Solution (adedalic)1452C - Two Brackets

Idea: BledDest

Tutorial1452C - Two BracketsNotice that it's never optimal to erase a subsequence of length greater than 2 because every RBS of length above 2 contains an RBS of length 2 inside and removing it won't break the regular property of the outside one.

So the task can be solved for the round and the square brackets independently, the answer will be the sum of both. Let's solve the version for brackets '(' and ')'. In general, you just want to remove consecutive substring "()" until there is no more left in the string. That can be done by processing the string from left and right and maintaining a stack of current brackets. If the top bracket in it is '(' and the current bracket is ')', then you can increment the answer and remove that bracket from the stack. Otherwise, you push the current bracket to the stack.

Overall complexity: O(|s|) per testcase.

Solution (pikmike)1452D - Radio Towers

Idea: BledDest

Tutorial1452D - Radio TowersThe crucial observation is that when the positions of towers are fixed, the way to set their signal powers is unique if it exists. That's because the first tower should have its signal power exactly equal to the required to cover all towns before it, the second tower should have signal power exactly equal to the required to cover all towns before it that weren't covered by the first one, and so on. So let's count the number of ways to cover all towns, and then divide it by 2n.

Covering all towns can be expressed as splitting n into the sum of several positive odd integers. It can be calculated with dynamic programming with prefix sums, but we can also prove that the number of ways to split n is exactly the n-th integer in the Fibonacci sequence as follows (this proof uses mathematical induction):

for n≤2, it's quite obvious;for n>2 and nmod2=0, let's iterate on the length of the last segment. We have to sum F1+F3+⋯+Fn−1; F1+F3=1+2=F4; F4+F5=F6; F6+F7=F8, and so on, until we get Fn−2+Fn−1=Fn;for n>2 and nmod2=1, let's iterate on the length of the last segment, and add 1 to result since we can cover everything with a single segment. So, this is 1+F2+F4+F6+⋯+Fn−1. 1+F2=F3, F3+F4=F5, and so on.So, the answer to the problem is Fn2n.

The last thing we have to consider is that we have to print a fraction modulo 998244353. Since 998244353 is a prime, using Fermat little theorem, we can calculate y−1 as y998244351mod998244353. Exponentiation must be done with some fast algorithm (for example, binary exponentiation).

Note: it's common in problems requiring to calculate something modulo some prime number to have problems with overflow in intermediate calculations or some other issues when we forget to take the result of some expression modulo 998244353. I recommend using either special addition/multiplication/exponentiation functions that always take the result modulo 998244353 (an example how to write and use them can be viewed in the model solution), or a special modular integer data structure with overloaded operators that you have to implement by yourself.

Solution (BledDest)1452E - Two Editorials

Idea: BledDest

Tutorial1452E - Two EditorialsConsider some participant's segment [l;r] and one of the author's segment [i;i+k−1]. How does the length of intersection change when you move i from left to right? It first increases until the centers of both segments coincide (that's the easiest to notice on the segments of the same length) and then decreases. The increase is totally symmetrical to the decrease.

With that idea you can conclude that the author's segment, whose center is the closest to the center of participant's segment, has the larger intersection length.

Let's sort the participants' segments by their center. You can see that the first author will be optimal for the prefix of the segments and the second author — for the remaining suffix.

So you can just iterate over the length of the prefix and update the answer with all options.

Overall complexity: O(nlogn+nm).

Solution (pikmike)1452F - Divide Powers

Idea: adedalic

Tutorial1452F - Divide PowersSeveral observations:

Generally, we have two types of operations: divide 2l and either l≤x or l>x. If 2l≤2x then in one division we'll get +1 element ≤2x, so we can just keep track of the total possible number of these operations as small.

If 2l>2x then if we decide to split whole 2l to 2x-s then we get +2l−x elements ≤2x but in 2l−x−1 operations, i. e. in one division we'll get +2l−x2l−x−1>1 elements. So it's preferably to fully split 2l>2x than 2l≤2x. Also, the less l>x — the more profitable each division.

As a result, let's act greedy: let's say, we need k more elements ≤2x. Let's iterate over 2l>2x in the increasing order.

If 2l−x≤k then let's fully split 2l in 2x in 2l−x−1 operations, decrease k, increase a counter of operations cur and increase small accordingly.If 2l−x>k then the situation becomes complicated. We can either don't touch 2l and try to use preserved operations with small 2j if small≥k, or split 2l in two 2l−1-s. Now we spent one operation and get two 2l−1.If 2l−1−x>k then we don't need one of 2l−1 and can split further only one 2l−1.If 2l−1−x≤k then it's optimal to fully split one of 2l−1 and proceed further with only one 2l−1 and recalculated k, cur and small.In both cases we can solve optimal splitting of 2l−1 recursively in the same manner as 2l. Since in each step we lower l then we need to check only O(n) cases per each query.Note, that we can treat situation 1 (2l−x≤k) in packs for several 2l with equal l, so the first part also works in O(n).

The resulting complexity is O(n) per query.

Solution (adedalic)1452G - Game On Tree

Idea: adedalic

Tutorial1452G - Game On TreeThis task was inspired by an older edu task and another task proposed by RockyB.

Let's learn to solve the problem for at least one starting vertex for Alice. Let this vertex be v. In general, Alice's strategy is basically this: run to some vertex u as fast as possible and stay in it until Bob reaches u. Hesitation on a way to this vertex won't be optimal. Visiting the same vertex multiple times won't as well. I guess that can be proven more formally by analyzing the set of possible solutions after each move.

What properties should vertex u have for Alice to be able to escape to it? There shouldn't be a way for Bob to catch her midway. However, it's not necessary to check any midway intersections. If Bob can catch her anywhere on a path, she can also follow her to the end (by moving the same path) and catch her at the destination. Thus, this vertex u should be further from any Bob's chips than from v.

So you can precalculate the distance to the closest Bob's chip dw to each vertex w. Just push all chips to a queue and run a bfs.

We've learned to solve the problem in O(n) for each vertex v. Just iterate over all vertices u and take the maximum of du over such of them that have du greater than the distance from v to u.

Now the solution can go two ways. You can stop thinking here and obtain an O(nlog2n) one or think more and get an O(nlogn).

The first one goes like that. Notice that the function f(v,x) if the Alice can make at least x moves from vertex v is monotonous in regard to x. So we can binary search the answer. The check query transforms to the following. Consider all vertices with distance less or equal to x from v. There should exist at least one vertex u with value du>x for the check to return true. So at least the maximum value of them should be greater than x.

That is basically a centroid exercise. Let each centroid store such an array val that vali is the maximum value of du over all such u that belong to this centroid's subgraph and are no further than i distance from the centroid. That array can be constructed in O(nlogn) for all centroids in total. You can easily see that the length of this array doesn't exceed the number of vertices in the subgraph of the corresponding centroid that is O(nlogn) be definition.

For the query iterate over all centroids v belongs to and check the value from some cell of each one's val array.

For the second solution let's reverse the problem. Consider the vertex u Alice escapes to. If there is a starting vertex v no further than du−1 from it, then the answer for v can be updated with du. So we can update the subgraph of vertices with distance no more than du−1 with the maximum of their current answer and du.

The solution will be almost the same centroid. Iterate over all centroids u belongs to and write du into the cell i of each one's array val, where i is the distance from u to this centroid. Then build an array of prefix maximums over this array. Finally, for each v collect the best answer over all centroids v belongs to.

Overall complexity: O(nlog2n) or O(nlogn).

Educational Codeforces Round 97 Editorial

By awoo, history, 2 years ago, translation, In English1437A - Marketing Scheme

Idea: adedalic

Tutorial1437A - Marketing SchemeNote that if ⌊la⌋<⌊ra⌋ then exists such k⋅a that l≤ka≤r and, obviously, a customer, who wants to buy ka cans won't buy more than he wants.

That's why ⌊la⌋=⌊ra⌋ and we can rephrase our task as finding such a that a2≤(lmoda)≤(rmoda)<a. The longer the segment [a2,a) is the better and the maximum we can take is a=2l.

As a result, we need to check that r<a↔r<2l.

Solution (adedalic)1437B - Reverse Binary Strings

Idea: adedalic

Tutorial1437B - Reverse Binary StringsWe need to make our string alternating, i. e. si≠si+1. When we reverse substring sl…sr, we change no more than two pairs sl−1,sl and sr,sr+1. Moreover, one pair should be a consecutive pair 00 and other — 11. So, we can find lower bound to our answer as maximum between number of pairs of 00 and number of pairs of 11. And we can always reach this lower bound, by pairing 00 with 11 or with left/right border of s.

Another way to count the answer is next: suppose we want to make string 0101..., then let's transform s to 1 + s + 0. For example, if s= 0110, we will get 101100. We claim that after this transformation, we will have equal number of 00 and 11, so the answer is the number of consecutive pairs of the same character divided by two. The answer is the minimum between answers for 1 + s + 0 and 0 + s + 1.

Solution (adedalic)1437C - Chef Monocarp

Idea: BledDest

Tutorial1437C - Chef MonocarpThere are a lot of solutions for the problem. Let's start with the easiest one.

Sort the dishes in the non-decreasing order of their optimal time. I claim that there is an optimal answer such that the times T for each dish go in the increasing order. That's not too hard to prove (something along the lines of if there are two dishes i and j such that ti<tj and Ti>Tj, then |ti−Ti|+|tj−Tj| is always greater than |ti−Tj|+|tj−Ti|).

So we can use dynamic programming to solve the task. Let dp[i][T] be the minimum total unpleasant value if i dishes are processed and the current minute is T. For the transitions you can either put out the current dish i at the current minute T or wait one more minute. Notice that you'll never need more time than 2n minutes (the actual constraint is even smaller, just consider the case with all dishes times equal to n).

So that dp works in O(n2).

The other possible solution is matching. Let's build the following graph. The left partition is n vertices corresponding to dishes. The right partition is 2n vertices corresponding to minutes (as we saw in previous solution 2n is always enough). Now add the edges between all dishes and all minutes with the cost of their absolute different. Finally, find the minimum cost maximum matching. That can be done with MCMF or Hungarian algorithm.

Both should pass pretty easily.

There's also a solution in O(nlogn) involving the slope trick.

Solution 1 (pikmike)Solution 2 (pikmike)1437D - Minimal Height Tree

Idea: adedalic

Tutorial1437D - Minimal Height TreeDue to the nature of BFS, the visiting order consists of several segments: first goes root (has depth 0), then all vertices with depth 1, then all vertices with depth 2 and so on. Since any vertex of depth d is a child of vertex of depth d−1, then it's optimal to make the number of vertices with depth 1 as many as possible, then make the number of vertices with depth 2 as many as possible and so on.

Since children of a vertex are viewed in ascending order and form a segment in visiting order then an arbitrary segment of visiting order can be children of the same vertex iff elements in the segments are in ascending order.

These two observations lead us to a greedy strategy: a1=1, then let's find the maximum r1 that segment a2,…,ar1 is in ascending order — they will be the children of a1 and the only vertices of depth 1. Next search the maximum r2 such that segment ar1+1,…,ar2 is in ascending order — they will be the children of a2, and so on. It's easy to see that this strategy maximizes the number of vertices of each depth level, so minimize the height of the tree.

Solution (adedalic)1437E - Make It Increasing

Idea: Neon

Tutorial1437E - Make It IncreasingFirst, let's solve the problem without blocked positions.

Let's look at the array bi=ai−i. Obviously, if a strictly increases, then b does not decrease, and vice versa. Now we have to find the maximum number of positions in the b array that can be left unchanged. And you can always choose an integer that will not break the non-decreasing array b for the rest of positions. This problem can be solved in O(nlogn) by analogy with the largest increasing subsequence, but now you can take equal elements.

Now you can realize that the segments between two blocked positions do not depend on each other, and the initial problem can be solved as the problem described above. All that remains is to check that all blocked positions do not break the strict array increment.

Solution (Ne0n25)1437F - Emotional Fishermen

Idea: BledDest

Tutorial1437F - Emotional FishermenFirst of all, sort the fishermen so it is easier to consider them in ascending order.

The key observation that allows us to solve the problem is the following: there will be an increasing sequence of happy fishermen, and all other fishermen will be unhappy.

Consider the fisherman i which belongs to the increasing sequence. Let's analyze which fisherman will be next to it in the order. It is either a fisherman that will be happy, or a fisherman that will be sad. In the first case, the fish caught by this fisherman must have a size of at least 2ai, in the second case — at most ai2.

The first case will be considered later. For the second case, if we know the number of fishermen that were already placed in the order, we know that all of them (except the i-th one) belong to the "sad" category (that is, the fish of every already placed fisherman, except for the i-th one, is at least two times smaller than the fish of the i-th fisherman). So, if we have already placed j fishermen, the last happy fisherman was the i-th one, and we want to place a sad fisherman, then the number of ways to choose this sad fisherman is exactly cntLess(i)−j+1, where cntLess(i) is the number of fishermen k such that 2ak≤ai.

If we can handle the first case, this observation will allow us to solve the problem with dynamic programming. Let dpi,j be the number of ways to choose j first fishermen in the order so that the i-th fisherman is the last happy one. The case when the next fisherman is sad can be handled with a transition to the state dpi,j+1 (don't forget to multiply by the number of ways to choose the next sad fisherman, as described earlier).

What about the case when the next fisherman is happy? We should iterate on the fisherman k such that ak≥2ai and transition from dpi,j to dpk,j+1, but this part works in O(n3). To get an O(n2) solution, we have to speed it up with prefix sums or something like that.

Solution (BledDest)1437G - Death DBMS

Idea: BledDest

Tutorial1437G - Death DBMSI'm feeling extremely amused by the power of Aho-Corasick lately, so I will describe two solutions of this problem with it. Feel free to point out how cool you are solving the task with hashes or some suffix structure but Aho solutions will still be cooler. I also want to mention I'm quite proud of the name I came up with for that task :)

First, let's assume that the words in the dictionary are unique.

Build an Aho-Corasick automaton on the dictionary. Then build the tree of its suffix links.

For the first solution you can use the fact that there are not a lot of words in the dictionary that can end in each position. To be exact, at most one word per unique word length. Thus, that's bounded by the square root of the total length.

For that reason you can iterate over all the words that end in all positions of the queries in O(qn−−√). How to do that fast? For each vertex of the automaton precalculate the closest vertex up the suffix link tree that's a terminal. Feed the query word into the automaton and from each vertex you stay at just jump up the tree until you reach the root. Take the maximum value over all the visited terminals.

The second solution actually involves an extra data structure on top of that. No, it's not HLD. You are boring for using it.

Let's abuse the fact that you are allowed to solve the problem fully offline. For each word you can save the list of pairs (time, value) of the times the value of the word changed. For each vertex of the automaton you can save all the times that vertex has been queried from.

Now traverse the tree with dfs. When you enter the vertex, you want to apply all the updates that are saved for the words that are terminals here. What are the updates? From the list we obtained for a word you can generate such triples (l,r,x) that this word had value x from query l to query r. Don't forget the 0 value from 0 to the first update to this word. Then ask all the queries. Then go to children. When you exit the vertex, you want all the updates to be gone. Well, there is a trick for these kinds of operations, it's called rollbacks.

Maintain a segment tree over the query times, the i-th leaf should store the maximum value during the i-th query. The update operation updates the range with the new possible maximum. How to avoid using lazy propagation with such updates? Well, on point query you can collect all the values from the segtree nodes you visit on your way down. That way you don't have to push the updates all the way to the leaves. Not that it matters that much but the number of values to be saved for future rollbacks is decreased dramatically.

That solution works in O((n+q)logq).

Educational Codeforces Round 96 — Editorial

By BledDest, 2 years ago, In English1430A - Number of Apartments

Idea: fcspartakm

Tutorial1430A - Number of ApartmentsThere are many possible solutions to this problem. The simplest one is to notice that, using several flats of size 3 and one flat of some size (possibly also 3, possibly not), we can get any n equal to [3,6,9,…], [5,8,11,…] or [7,10,13,…]. The only numbers that don't belong to these lists are 1, 2 and 4, and it's easy to see that there is no answer for that numbers. So the solution is to try all possible sizes of one flat, and if the remaining number of windows is non-negative and divisible by 3, then take the required number of three-room flats.

Solution (fcspartakm)1430B - Barrels

Idea: fcspartakm

Tutorial1430B - BarrelsA greedy strategy always works: take k+1 largest barrels, choose one barrel among them and pour all water from those barrels to the chosen barrel. That way, we make the minimum amount equal to 0 (it's quite obvious that we can't do anything better here), and the maximum amount as large as possible, so the difference between them will be as large as possible.

Solution (fcspartakm)1430C - Numbers on Whiteboard

Idea: BledDest

Tutorial1430C - Numbers on WhiteboardIt's easy to see that we can't get the result less than 2, because, if we merge two positive numbers, and at least one of them is 2 or greater, the new number is always greater than 1. So we can't get rid of all numbers greater than 1.

To always achieve 2, we can use a greedy algorithm: always merge two maximum numbers. During the first step, we merge n and n−1, get n; then we merge n and n−2, get n−1; then we merge n−1 and n−3, get n−2; and it's easy to see that the last operation is merging 3 and 1, so the result is 2.

Solution (fcspartakm)1430D - String Deletion

Idea: BledDest

Tutorial1430D - String DeletionSuppose the string consists of n characters, and each character is different from the adjacent ones (so the string looks like 01010... or 10101...). It's easy to see that we can't make more than ⌈n2⌉ operations (each operation deletes at least two characters, except for the case when the string consists of only one character). And there is an easy way to perform exactly ⌈n2⌉ operations: always choose the last character and delete it.

Okay, what about the case when some adjacent characters in the string are equal? It's never optimal to delete a character that's different from both adjacent characters: since the second part of each operation always deletes the left block of equal characters, this action merges two blocks, so they will be deleted in one second part of the operation (which decreases the total number of operations).

So, we should always delete a character from a block with at least two equal characters. From which of the blocks, if there are more than one? It's easy to see that we should choose a character from the leftmost such block, since that block is the earliest to be deleted (and if we want to make the same action later, we might be unable to do it).

So, the solution is greedy: during each action, we have to find the leftmost block consisting of at least 2 equal characters, and delete a character from it (or the last character of the string, if there are no such blocks). Since the length of the string is up to 2⋅105 and the number of operations is up to 105, we should do it efficiently, for example, by storing the eligible blocks in some data structure.

Solution (BledDest)1430E - String Reversal

Idea: fcspartakm

Tutorial1430E - String ReversalFirst of all, let's find the resulting position for each character of the string. It's easy to see that we don't need to swap equal adjacent characters (it changes nothing), so the first character a in the original string is the first character a in the resulting string, the second character a in the original string is the second character a in the resulting string, and so on.

Now, let's build a permutation p of n elements, where pi is the resulting position of the element that was on position i in the original string. For example, for the string abcad this permutation will be p=[2,4,3,5,1]. In one operation, we may swap two elements in this permutation, and our goal is to sort it (since each character of the string has its own required position, and when for every i the condition pi=i holds, each character is on the position it should be). The required number of swaps of adjacent elements to sort a permutation is exactly the number of inversions in it (since each swap changes the number of inversions by 1), and this number can be calculated using many different techniques, for example, mergesort tree or Fenwick tree.

Solution (fcspartakm)1430F - Realistic Gameplay

Idea: BledDest

Tutorial1430F - Realistic GameplayNote some observations: if we meet a new wave and start shooting it's optimal to shoot monsters in the wave using full magazines while we can and there are no reasons to take breaks between shooting monsters from one wave. That's why we can track only moments when waves start and the number of remaining bullets in magazine we have at these moments.

Moreover, since the next wave starts not earlier than the previous ends, we can think that when we start dealing with one wave we've already dealt with the previous one. Also, instead of keeping track of the remaining bullets, let's just look only at such indices of waves when we reloaded and threw remaining bullets before reaching them.

So, we can write the next dp: d[i] is the minimum number of bullets we spend dealing with the first i waves and now we standing at the moment li with full magazine. Obviously, dp[0]=0.

Now, with fixed i we can iterate over the index j of a wave before which we'll reload throwing away remaining bullets. And for waves [i,j) we need to check that we are able to exterminate all these waves without throwing away any bullets. We can check it with several formulas.

If it's possible for segment [i,j) then the possibility for the segment [i,j+1) is just checking that we can exterminate the j-th wave having rem≥0 bullets in the start in no more than rj−lj reloads plus checking that we have at least one unit before lj+1 for a reload.

As a result, the time complexity of the solution is O(n2).

Solution (adedalic)1430G - Yet Another DAG Problem

Idea: BledDest

Tutorial1430G - Yet Another DAG ProblemThe key observation in this problem is that the values of av should form a contiguous segment of integers. For example, suppose there exists a value k such that there is at least one av<k, there is at least one av>k, but no av=k. We can decrease all values of av that are greater than k by 1, so the answer will still be valid, but the value of ∑i=1mwibi will decrease. So, the values of av form a contiguous segment of integers. We can always assume that this segment is [0,n−1], since subtracting the same value from each av does not change anything.

The other observation we need is that we can rewrite the expression we have to minimize as follows: ∑i=1mwibi=∑v=1navcv, where cv is the signed sum of weights of all arcs incident to the vertex v (the weights of all arcs leading from v are taken with positive sign, and the weights of all arcs leading to v are taken with negative sign). These two observations lead us to a bitmask dynamic programming solution: let dpi,mask be the minimum value of ∑v=1navcv, if we assigned the values from [0,i−1] to the vertices from mask. A naive way to calculate this dynamic programming is to iterate on the submask of mask, check that choosing the integer i−1 for each vertex from that submask doesn't ruin anything (for each vertex that belongs to this submask, all vertices that are reachable from it should have av<i−1, so they should belong to mask, but not to the submask we iterate on), and update the dynamic programming value. But this solution is O(n3n), and, depending on your implementation, this might be too slow.

It's possible to speed this up to O(n22n) in a way similar to how profile dp can be optimized from O(3n) to O(n2n): we won't iterate on the submask; instead, we will try to add the vertices one by one, and we should be able to add a vertex to the mask only if all vertices that are reachable from it already belong to the mask. There is a possibility that we add two vertices connected by an arc with the same value of av, so, for a fixed value of av, we should consider assigning it to vertices in topological sorting order (that way, if one vertex is reachable from another, it will be considered later, so we won't add both of those with the same value of av).

Educational Codeforces Round 95 Editorial

By awoo, history, 2 years ago, translation, In English1418A - Buying Torches

Idea: vovuh

Tutorial1418A - Buying TorchesYou need s=yk+k−1 additional sticks to get k torches (yk sticks for y units of coal and also k sticks required to craft torches) and you get x−1 sticks per one trade. To buy this number of sticks, you need ⌈sx−1⌉ trades. And also, you need k additional trades to turn some sticks into coals. And the final answer is ⌈sx−1⌉+k.

Solution (vovuh)1418B - Negative Prefixes

Idea: BledDest

Tutorial1418B - Negative PrefixesLet's collect the prefix sums of the initial array a. How do they change if you swap two values in the array? Let's swap values on positions l and r (l<r). Prefix sums from 1 to l−1 aren't changed. Prefix sums from l to r−1 are increased by ar−al (note that if al>ar then these sums become smaller). Finally, prefix sums from r to n aren't changed as well.

Thus, swapping two values al<ar will only increase some prefix sums but never decrease any of them.

That helps us see that the array such that all values on the unlocked positions are sorted in a non-increasing order is the most optimal one.

Overall complexity: O(nlogn) per testcase.

Solution (Ne0n25)1418C - Mortal Kombat Tower

Idea: vovuh

Tutorial1418C - Mortal Kombat TowerIf a1=1 then our friend always needs one skip point because he always has to kill the first boss. Let's just remove this boss from our consideration and increase the answer if needed.

What about other skip points? Firstly, let's understand that we can always do our moves in such a way that the first hard boss will always be killed by us (except the first one). So, if it's our friend turn now and there is only one easy boss before the hard, our friend just kills this easy boss. If there are two easy bosses, he kills both. If there are three, friend kills the first, we kill the second, and he kills the third. And so on. So we can always assume that each segment of hard bosses starts with our move.

We can kill each such segment greedily: we kill two bosses and our friend kills one. If there are less than three bosses in the segment, we just kill remaining and proceed. So if the length of the current segment of hard bosses is k then we need ⌊k3⌋ skip points. Summing up these values over all segments we get the answer (and don't forget that the first boss should be handled separately). Segments of ones can be extracted using two pointers.

There are also dynamic programming solution but I found this one more clever.

Solution (vovuh)1418D - Trash Problem

Idea: vovuh

Tutorial1418D - Trash ProblemFirst, let's understand that if we choose some subset of points x1,x2,…,xk, then it does not matter to which point we move it (inside the segment [min(x1,x2,…,xk);max(x1,x2,…,xk)]) because the minimum number of moves will always be the same and it is equal to max(x1,x2,…,xk)−min(x1,x2,…,xk).

Okay, we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset. What can we notice? If we sort the points, it's always optimal to choose these subsets as segments. I.e. if the maximum point of the first subset is xr, the minimum point of the second subset is xl and xl<xr, we can swap them and decrease answers for both subsets.

So, we need to cover all the points with two segments with the minimum total length. What is this length? It is xn−x1−maxGap. MaxGap is the maximum distance between two consecutive points (i.e. max(x2−x1,x3−x2,…,xn−xn−1). So, we can solve the problem in O(nlogn) without queries. But how to deal with queries?

Let's maintain the set which contains all points xi and the multiset (set with repetitions) that maintains all gaps between two adjacent points. So, the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths. How do we recalculate these sets between queries?

If some point x is removed, let's find the maximum point less than x (let it be xl) and the minimum point greater than x (let it be xr) in the current set of points. Both these points can be found in a logarithmic time. Then we need to remove x−xl with xr−x from the multiset and add xr−xl to the multiset (and, of course, remove x from the set). If some point x is added, then we need to remove xr−xl from the multiset and add x−xl with xr−x to the multiset (and add x to the set).

So, we can process every query in O(logn+q) time and the total time complexity is O((n+q)log(n+q)).

Solution (vovuh)1418E - Expected Damage

Idea: Roms

Tutorial1418E - Expected DamageFirst of all, let's find a solution in O(nm). We will use the lineriality of expectation: the answer for some shield j is equal to ∑i=1ndiP(i,j), where P(i,j) is the probability that the monster i will deal damage if we use the j-th shield. Let's see how to calculate P(i,j).

Consider a monster i such that di≥bj. To deal damage, he should be preceded by at least aj other monsters having di≥bj. We can write a complicated formula with binomial coefficients to calculate the probability of this happening, and then simplify it, but a much easier solution is to consider the order of these "strong" monsters. Suppose there are k of them, then there are max(k−aj,0) strong monsters that will deal damage. Since all orderings are equiprobable, the probability that our fixed monster will deal damage is max(k−aj,0)k — since it is the probability that it will take one of the last places in the order.

Okay, what about "weak" monsters? It turns out that we can use the same approach: to deal damage, a weak monster should be preceded by at least aj strong monsters. Consider the relative order of k strong monsters and that weak monster we are analyzing. There are max(k+1−aj,0) positions where the weak monster will deal damage, so the probability of weak monster dealing damage is max(k+1−aj,0)k+1.

Okay, we got a solution in O(nm). How to make it faster? Whenever we consider a shield, all monsters are split into two types: strong and weak, and we may sort the monsters beforehand, so the number of strong monsters (and their total strength) can be found with binary search. Since the probabilities for all strong monsters are the same, we can multiply their total strength by the probability that one fixed strong monster will deal damage (we already described how to calculate it). The same applies for the weak monsters, so the total complexity is O(nlogn+m(logn+logMOD)).

Solution (Roms)1418F - Equal Product

Idea: adedalic

Tutorial1418F - Equal ProductLet's look at x1y1=x2y2 where x1<x2. It can be proven that there always exists such pair (a,b) (a∣x1, b∣y1 and a<b) that x2=x1ab and y2=y1ba.

Brief proof is following: calculate g=gcd(x1,x2), then let a=x1g and b=x2g. Obviously, such (a,b) will make x2 from x1 and y2 from y1 (if b∣y1). And since b=x2g⇒ b∣x2y2g⇒ b∣x1y1g⇒ b∣x1gy1 and since gcd(b,x1g)=1⇒ b∣y1.

As we can see a divides x1, so if we will iterate over all pairs (x1,a) where 1≤x1≤n there will be O(nlogn) pairs in total.

Let's fix value of x1. Then, from one side, y1≤m but, from the other side, since l≤x1y1≤r, then ⌈lx1⌉≤y1≤⌊rx1⌋. Anyway, all valid y1 form a segment (possibly, empty segment). And we need to find any b>a that divides any y1 from the segment and x2=x1ab doesn't exceed n. Obviously, it's optimally to find the minimum possible such b and just check inequality x1ab≤n.

We can find such b for a fixed (x1,a) using, for example, built-in upper_bound in a set with all divisors for all valid y1. To maintain this set we can note that lx1+1≤lx1 (simillary, rx1+1≤rx1). So we can move valid segment's ends as two pointers.

Each pair (y1,b) will be added and erased from the segment exactly once. That's why the total complexity of maintaining the set of divisors (as well as the total complexity of queries for each (x1,a)) will be equal to O((n+m)log2(n+m)).

All pairs (x1,a) (and (y1,b)) can be precalculated in O((n+m)log(n+m)) using the sieve-like algorithm.

Solution (adedalic)1418G - Three Occurrences

Idea: BledDest and Roms

Tutorial1418G - Three OccurrencesLet's consider two solutions: a non-deterministic and a deterministic one.

The random solution goes like that.

Let's assign a random integer to each value from 1 to n (to value, not to a position). Let the value of the subarray be the trit-wise sum of the assigned integers of all values on it. Trit-wise is the analogue of bit-wise sum (xor) but in ternary system. So adding up the same integer three times trit-wise is always equal to zero. Thus, if the value on a subarray is zero then each value appears on it a multiple of three times. How to count the number of such subarrays? Process the array from left to right and store the prefix trit-wise sums in a map. The number of the valid subarrays that end in the current position is the number of occurrences of the current prefix trit-wise sum in a map. The current sum should be added to the map afterwards.

However, that's not what the problem asks us to find. Let's consider another problem: count the number of subarray such that each number appears no more than three times. This can be done with two pointers. Process the array from left to right and for each number store the positions it occurred on. If some number appears at least four times than the left pointer should be moved to the next position after the fourth-to-last position. The number of valid subarrays the end in the current position is the distance to the left pointer.

Let's combine these problems: maintain the pointer to only the valid positions and remove the prefix trit-wise sums from the map as you increase the pointer. That way the map will only store the valid sums, and they can be added to answer as they are.

Assume you use K trits. I guess the probability of the collision is the same as two vectors (out of n) colliding in a K-dimensional space with their coordinates being from 0 to 2. That will be about 12 when n≈3K−−−√ (according to birthday paradox) — and way less if we increase K.

Overall complexity: O(nKlogn).

The deterministic solution (a.k.a. the boring one) goes like that.

Let's again process the array from left to right. Let the current position be the right border of the segment. Each number makes some constraints on where the left border might be. More specifically, it's two possible segments: between its last occurrence and the current position and between its fourth-to-last occurrence and its third-to-last one. Let's actually invert these segments. Bad segments are from the beginning of the array to the fourth-to-last occurrence, then from the second-to-last occurrence to the last one. So the valid left borders are in such positions that are covered by zero bad segments.

Let's keep track of them in a segment tree. Add 1 on the bad subarrays. Now you have to count the number of 0 values in a segtree. That's a pretty common problem. As we know that no values can go below 0, 0 should be a minimum element on the segment. So we can store a pair of (minimum on segment, number of minimums on segment). At the end the second value is the number of zeros if the first value is zero.

Overall complexity: O(nlogn).

Educational Codeforces Round 94 Editorial

By awoo, history, 2 years ago, translation, In English1400A - String Similarity

Idea: BledDest

Tutorial1400A - String SimilarityThere are many ways to solve this problem:

let the answer be s1s3s5…s2n−1, so it coincides with s[1..n] in the first character, with s[2..n+1] in the second character, and so on;copy the character sn n times, since it appears in every substring we are interested in;find the character that occurs at least n times in s, and build the answer by copying it n times;and many others.Solution (adedalic)1400B - RPG Protagonist

Idea: adedalic

Tutorial1400B - RPG ProtagonistLet's say (without loss of generality) that s≤w (a sword is lighter than a war axe). If not, then we can swap swords and axes.

Now, let's iterate over the number of swords s1 we will take ourselves. We can take at least 0 and at most min(cnts,ps) swords.

If we have taken s1 swords, then we can fill the remaining capacity with axes, i. e. we can take w1=min(cntw,p−s1⋅sw) axes.

The last thing is to decide, what the follower will take: since swords are lighter, it's optimal to take as many swords as possible, i. e. to take s2=min(cnts−s1,fs) swords and fill the remaining space with war axes, i. e. to take w2=min(cntw−w1,f−s2⋅sw) axes.

In other words, if we fix the number of swords s1 we'll take s1+s2+w1+w2 weapons in total.

The result complexity is O(cnts).

Solution (adedalic)1400C - Binary String Reconstruction

Idea: Roms

Tutorial1400C - Binary String ReconstructionAt first, let's replace all elements of string w by 1.

Now, let's consider all indices i such that si=0. If si=0, then wi−x must be equal to 0 (if it exists) and wi+x must be equal to 0 (if it exists), so let's replace all such elements by 0.

And after let's perform the process described in statement on string w. If we get the string s, then we can print w as the answer, otherwise the answer is −1.

Solution (Roms)1400D - Zigzags

Idea: adedalic

Tutorial1400D - ZigzagsLet's iterate indices j and k. For simplicity, for each j we'll iterate k in descending order.

To calculate the number of tuples for a fixed (j,k) we just need the number of i<j such that ai=ak and the number of l>k with al=aj. We can maintain both values in two frequency arrays cntLeft and cntRight, where cntLeft[x] (cntRight[x]) is the number of ai=x for i<j (i>k). It's easy to update cntLeft (cntRight) when moving j to j+1 (k to k−1).

The time complexity is O(n2).

Solution (adedalic)1400E - Clear the Multiset

Idea: Roms

Tutorial1400E - Clear the MultisetLet's solve the problem by dynamic programing. Let dpi,j be the minimum number of operations to delete all elements from 1 to i, if we have j "unclosed" operations of the first type. In each transition, we either advance to the right (and possibly "close" some operations of the second type, so we go from dpi,j to dpi+1,min(ai+1,j), adding 1 to the answer if j<ai+1), or "open" a new operation of the second type (so we go from dpi,j to dpi,j+1, adding 1 to the answer). This solution runs in O(nA), which is too slow.

The observation that helps us to speed this up is that we have to use only values from the array a as the second state of our dynamic programming. Let's prove it.

The proof begins here

Let's call an integer i saturated if all occurrences of i were deleted by operations of the first type. Also, let's denote ci as the number of elements equal to i deleted by the operations of the first type (so, i is saturated iff ai=ci).

Suppose k is the minimum integer such that ck is not a value from the array a. Obviously, k is not saturated. Since the number of operations of the first type covering some integer decreases only when we have to close them, it always decreases to some number in a, so it is impossible that ck−1>ck. It is also impossible that ck−1=ck, since k is the minimum integer such that ck does not belong to array a. So, ck−1<ck, it means that some number of operations of the first type started in integer k. We can either get rid of them altogether (if they end in k as well), or shift them to k+1, so ck belongs to the array a. That way, if in the optimal answer some value ck does not belong to a, we can reconstruct it so it is no longer the case.

The proof ends here

Overall, since we have only up n disctict values of j, the solution runs in O(n2) (though it is possible to solve the problem faster).

Solution (Roms)1400F - x-prime Substrings

Idea: BledDest and Roms

Tutorial1400F - x-prime SubstringsThe number of x-prime strings is relatively small, so is their total length (you may bruteforce all of them and check that the total length of x-prime strings never exceeds 5000, we will need that bruteforce in the solution). Now we have the following problem: given a set of strings with total length up to 5000 and a string with length up to 1000, erase the minimum number of characters from that string so no string from the set appears there as a substring.

You may have already encountered the similar problem in some previous contests. The solution to this problem is dynamic programming — let dp[x][y] be the minimum number of characters to erase, if we considered first x characters, there were no occurrences of strings from the set in the resulting string... and the second state of dynamic programming (y) is a bit more complicated. We want to make sure that no string appears in the result as a substring, so y should somehow handle that. Let y be the longest suffix of the current string that coincides with some prefix of a string from the set. If some string from the set is a suffix of y, then the state is clearly bad — we have an occurrence of an x-prime string. Otherwise, there is no occurrence ending in the last character, since we considered the longest possible suffix that matches some prefix from the set. The transitions in dp are the following — we either take the next character and recalculate y, or skip the next character and add 1 to the number of removed characters.

If we maintain and recalculate y naively, as a string, the solution will be too slow. There are only up to 5000 different values of y, but their total length may be much greater, so we don't even have enough memory to store our dynamic programming values. Let's enumerate all strings that are prefixes of some x-prime string and map each of these strings to some integer, so the second state in dynamic programming can be an integer instead of a string. Then we have to mark the bad integers (which correspond to strings having some x-prime string as a suffix) and calculate the two-dimensional transition matrix T, where T[x][a] is the integer corresponding to a string that we get, if we append the x-th string with character a, so the transitions in dynamic programming can be done in O(1). There are many ways to precalculate this matrix and mark all of the bad integers, but the most efficient one is to use Aho-Corasick algorithm (the transition matrix T is exactly the automaton that the Aho-Corasick algorithm builds). If you are not familiar with it, I recommend you to read about it here: https://cp-algorithms.com/string/aho_corasick.html

Solution (pikmike)1400G - Mercenaries

Idea: BledDest and Roms

Tutorial1400G - MercenariesWe will use inclusion-exclusion formula to solve this problem (you may read about it here: https://cp-algorithms.com/combinatorics/inclusion-exclusion.html). To put it simply, we are going to count the number of subsets that meet the restrictions on [li,ri], ignoring the edges (I'll call the pairs of mercenaries that hate each other "edges" for simplicity). This number is not the answer, since we counted some subsets that violate the conditions for the edges — so, for each edge, we count the number of subsets that violate the condition on that edge, and subtract it from the answer. But it means that if a subset violates the conditions on multiple edges, we subtracted it multiple times, so, for each pair of edges, we count the subsets that violate both edges in that pair and add them back, then remove the subsets violating the triples, and so on. The mathematical formula for the answer is ∑E∈Sf(E), where S is the set containing all 2m subsets of edges, and f(E) is the number of subsets that meet the constraints on [li,ri], and violate the constraints for every edge e∈E.

Now we have to calculate f(E) efficiently, since the outer loop already runs in O(2m). If we have to violate a set of edges, then we have a set of mercenaries that we should take (the "endpoints" of the edges), and the number of those mercenaries (let's denote it as k) is up to 40. The size of the subset should meet the constraints on [li,ri] for each of those mercenaries, so let's intersect the segments [li,ri] for them (and if the intersection is empty, then there are no subsets that violate all of those edges). Let the intersection of those segments be [L,R]. The naive solution would be to iterate on the size of the subset and calculate the number of ways to compose a subset that contains some fixed mercenaries of given size (if the size is s, and cs is the number of mercenaries that are willing to be in a subset of size s, then we have to add (cs−ks−k) to the answer). So, for each subset E, f(E)=∑s=LR(cs−ks−k). This sum can be calculated in O(1) as follows: note that k is up to 40, so for every possible value of k, precalculate the array of prefix sums of those binomial coefficients. This precalculation runs in O(nm+nlogMOD), and each f(E) can be calculated in O(mlogm), so overall the complexity is O(nm+nlogMOD+2mmlogm).

Educational Codeforces Round 93 Editorial

By awoo, history, 3 years ago, translation, In English1398A - Bad Triangle

Idea: Roms

Tutorial1398A - Bad TriangleThe triangle with side a≥b≥c is degenerate if a≥b+c. So we have to maximize the length of the longest side (a) and minimize the total length of other sides (b+c).

Thus, if an≥a1+a2 then we answer if 1,2,n, otherwise the answer is -1.

Solution (Roms)1398B - Substring Removal Game

Idea: BledDest

Tutorial1398B - Substring Removal GameThe following greedy strategy works: during each turn, delete the largest possible substring consisting of 1-characters. So we have to find all blocks of 1-characters, sort them according to their length and model which blocks are taken by Alice, and which — by Bob.

Why does the greedy strategy work? It's never optimal to delete some part of the block of ones — because we either have to spend an additional turn to delete the remaining part, or allow our opponent to take it (which is never good). Why don't we need to delete zeroes? If we delete a whole block of zeroes, our opponent can take the newly formed block of 1's during their turn, and it is obviously worse than taking a part of that block. And deleting some part of a block of zeroes doesn't do anything — our opponent will never delete the remaining part because it's suboptimal.

Solution (Ne0n25)1398C - Good Subarrays

Idea: Roms

Tutorial1398C - Good SubarraysWe use zero indexing in this solution. We also use half-closed interval (so subarray [l,r] is al,al+1,…,ar−1).

Let's precalculate the array p, where pi=∑j=0i−1aj (so px if sum of first x elements of a).

Then subarray [l,r] is good if pr−pl=r−l, so pr−r=pl−l.

Thus, we have to group all prefix by value pi−i for i from 0 to n. And if the have x prefix with same value of pi−i then we have to add x(x−1)2 to the answer.

Solution (Roms)1398D - Colored Rectangles

Idea: BledDest

Tutorial1398D - Colored RectanglesLet's build some rectangles and take a look at the resulting pairings. For example, consider only red/green rectangles. Let the rectangles be (ri1,gi1), (ri2,gi2), .... Sort them in a non-decreasing order of rij. I claim that in the most optimal set gij are also sorted in a non-decreasing order. It's easy to prove with some induction.

Moreover, if there are some green or red sticks that are not taken and that are longer than the smallest taken corresponding sticks, then it's always optimal to take those instead.

These facts helps us to conclude that from each set only some suffix of the largest sticks are taken. And they also give us the idea of the solution: sort the sticks in each set and pick the largest from any of the two sets into a pair until no pairs can be taken.

However, the greedy approach of "take from any two of the three sets" is incorrect. We need to choose these two sets smartly. Let dp[r][g][b] store the maximum total area that can be obtained by taking r largest red sticks, g largest green sticks and b largest blue sticks. Each transition chooses a pair of colors and takes the next pairs in both of them.

The answer is the maximum value in all the dp.

Overall complexity: O(RGB+RlogR+GlogG+BlogB).

Solution (pikmike)1398E - Two Types of Spells

Idea: Roms and BledDest

Tutorial1398E - Two Types of SpellsLet's solve this problem for fixed set of spells. For example, we have a fireball spells with powers f1,f2,…,fm and lighting spells with powers l1,l2,…,lk. We reach the maximum total damage if we can double all k spells with maximum damage. It's possibly iff the set of k largest by power spell (let's denote this set as s) contains at least one fireball spell. Otherwise (if set s contains only lightning spells) the maximum damage reach when we double k−1 largest spells in set s and one largest spell not from set s (if such spell exist).

Now how do you solve the original problem when spells are added and removed? All we have to do it maintain the set of x largest by power spells (where x is current number of lightning spells), and change this set by adding or removing one spell. Also you have to maintain the sum of spells power in set this set and the number of fireball spells in this set. You can do it by set in C++ or TreeSet on Java.

Solution (Roms)1398F - Controversial Rounds

Idea: Roms

Tutorial1398F - Controversial RoundsLet's consider the following function f(pos,x): minimum index npos such that there is a substring of string spos,spos+1,…,snpos−1 of length x consisting of only characters 1 and ? or 0 and ?. If this function has asymptotic O(1) then we can solve problem for O(nlogn).

Now, let's precalculate two array nxt0 and nxt1; nxt0[i] is equal the maximum integer len such that substring si,si+1,…,si+len−1 consist only characters 1 and ?. nxt1[i] is equal the maximum integer len such that substring si,si+1,…,si+len−1 consist only characters 0 and ?.

Also let's precalculate the arrays p0 and p1 of size n; p0[len] contain all positions pos such that substring spos,spos+1,…,spos+len−1 consist only characters 1 and ? and pos=0 or spos−1=0; p1[len] contain all positions pos such that substring spos,spos+1,…,spos+len−1 consist only characters 0 and ? and pos=0 or spos−1=1.

After that let's solve problem for some x. Suppose, that now we already processed first pos elements of s. If nxt0[pos]≥x or nxt1[pos]≥x then we increase the answer and change pos=pos+x. Otherwise we have to find the minimum element (denote this element as npos) in p0[x] or p1[x] such that npos≥pos. If there is no such element then we found the final answer . Otherwise let's increase answer and change pos=npos+x and continue this algorithm.

Solution (Roms)1398G - Running Competition

Idea: BledDest

Tutorial1398G - Running CompetitionFirst of all, let's find all possible lengths of the laps (after doing that, we can just check every divisor of li to find the maximum possible length of a lap for a given query). A lap is always a rectangle — you can't construct a lap without using any vertical segments or using an odd number of vertical segments, and if you try to use 4 or more vertical segments, you can't go back to the point where you started because both horizontal segments are already partially visited. So, a lap is a rectangle bounded by two vertical segments; and if we use vertical segments i and j, the perimeter of this rectangle is 2(ai−aj+y).

Let's find all values that can be represented as ai−aj. A naive O(n2) approach will be too slow, we have to speed it up somehow. Let's build an array b of n+1 numbers where bj=K−aj (K is some integer greater than 200000). Each number that can be represented as ai−aj can also be represented as ai+bj−K, so we have to find all possible sums of two elements belonging to different arrays.

The key observation here is that, if ai and bj are small, we can treat each array as a polynomial: let A(x)=∑i=0nxai, and similarly, B(x)=∑j=0nxbj. Let's look at the product of that polynomials. The coefficient for xk is non-zero if and only if there exist i and j such that ai+bj=k, so finding all possible sums (and all possible differences) can be reduced to multiplying two polynomials, which can be done faster than O(n2) using Karatsuba's algorithm or FFT.

Educational Codeforces Round 92 Editorial

By awoo, history, 3 years ago, translation, In English1389A - LCM Problem

Idea: BledDest

Tutorial1389A - LCM ProblemSuppose we have chosen x and y as the answer, and x is not a divisor of y. Since LCM(x,y) belongs to [l,r], we could have chosen x and LCM(x,y) instead. So if the answer exists, there also exists an answer where x is a divisor of y.

If 2l>r, then there is no pair (x,y) such that l≤x<y≤r and x|y. Otherwise, x=l and y=2l is the answer.

Solution (BledDest)1389B - Array Walk

Idea: Roms

Tutorial1389B - Array WalkNotice that your final position is determined by the number of moves to the left you make. Let there be exactly t moves to the left, that leaves us with k−t moves to the right. However, let's interpret this the other way. You have t pairs of moves (right, left) to insert somewhere inside the sequence of k−2t moves to the right.

Easy to see that all the positions from 1 to k−2t+1 will always be visited. And the extra pairs can also increase the score by visiting some positions (i+1, i) for some i from 1 to k−2t+1.

Notice that it's always optimal to choose exactly the same i for all the pairs (right, left). And that i should be such that ai+1+ai is maximum possible.

You can implement this idea in a straightforward manner: iterate over t and calculate the sum of values from 1 to k−2t+1 and the maximum value of ai+1+ai over i from 1 to k−2t+1.

That will lead to a O(zn) solution per testcase.

You can optimize it to O(n) with prefix sums or with some clever order to iterate over t. It's also possible to iterate over the final position and restore the number of left moves required to achieve it.

Overall complexity: O(zn) or O(n) per testcase.

Solution 1 (pikmike)Solution 2 (pikmike)1389C - Good String

Idea: BledDest

Tutorial1389C - Good StringLet's analyze when the string is good. Suppose it is t1t2…tk.

The cyclic shifts of this string are tkt1t2…tk−1 and t2t3…tkt1. We get the following constraints for a good string: tk=t2, t1=t3, t2=t4, ..., tk−2=tk, tk−1=t1. If the string has odd length, then all characters should be equal to each other; otherwise, all characters on odd positions should be equal, and all characters on even positions should be equal.

Now, since there are only 10 different types of characters, we can brute force all possible combinations of the first and the second character of the string we want to obtain (there are only 100 of them) and, for each combination, greedily construct the longest possible subsequence of s beginning with those characters in O(n).

Solution (Ne0n25)1389D - Segment Intersections

Idea: adedalic

Tutorial1389D - Segment IntersectionsAt first, note that intersection_length of segments [l1,r1] and [l2,r2] can be calculated as min(r1,r2)−max(l1,l2). If it's negative then segments don't intersect, otherwise it's exactly length of intersection.

Now we have two major cases: do segments [l1,r1] and [l2,r2] already intersect or not.

If segments intersect then we already have n⋅(min(r1,r2)−max(l1,l2)) as the total intersection. Note, that making both segments equal to [min(l1,l2),max(r1,r2)] in each pair are always optimal since in each step we will increase the total intersection by 1.

After making all segments equal to [min(l1,l2),max(r1,r2)] we can increase total intersection by 1 only in two steps: we need to extend both segments in one pair.

In result, we can find not a hard formula to calculate the minimum number of steps: we already have n⋅(min(r1,r2)−max(l1,l2)) of the total intersection, then we can increase it by at most n⋅((max(r1,r2)−min(l1,l2))−(min(r1,r2)−max(l1,l2))) using one step per increase, and then to any number using two steps per increase.

In the case of non-intersecting [l1,l2] and [r1,r2], we should at first "invest" some number of steps in each pair to make them intersect. So let's iterate over the number of segments to "invest" cntInv. We should make cntInv⋅(max(l1,l2)−min(r1,r2)) steps to make segments touch. Now, cntInv segments touch so we can use almost the same formulas for them as in the previous case.

The total complexity is O(n) per test case.

Solution (adedalic)1389E - Calendar Ambiguity

Idea: BledDest

Tutorial1389E - Calendar AmbiguityLet the month, the days in them and the days of the week be numbered 0-based.

Translate the x-th day of the y-th month to the index of that day in a year; that would be yd+x. Thus, the corresponding day of the week is (yd+x) mod w.

So we can rewrite the condition for a pair as xd+y≡yd+x (mod w). That's also (xd+y)−(yd+x)≡0 (mod w). Continue with (x−y)(d−1)≡0 (mod w). So (x−y)(d−1) should be divisible by w. d−1 is fixed and some prime divisors of w might have appeared in it already. If we remove them from w then (x−y) should just be divisible by the resulting number. So we can divide w by gcd(w,d−1) and obtain that w′.

Now we should just count the number of pairs (x,y) such that x−y is divisible by w′. We know that the difference x−y should be from 1 to min(d,m). So we can fix the difference and add the number of pairs for that difference. That would be mn−k for a difference k. Finally, the answer is ∑i=1min(d,m)/w′mn−i⋅w′. Use the formula for the sum of arithmetic progression to solve that in O(1).

Overall complexity: O(log(w+d)) per testcase.

Solution (pikmike)1389F - Bicolored Segments

Idea: Roms

Tutorial1389F - Bicolored SegmentsThere are two approaches to this problem. Most of the participants of the round got AC by implementing dynamic programming with data structures such as segment tree, but I will describe another solution which is much easier to code.

Let's consider a graph where each vertex represents a segment, and two vertices are connected by an edge if the corresponding segments compose a bad pair.

Since each bad pair is formed by two segments of different colors, the graph is bipartite. The problem asks us to find the maximum independent set, and in bipartite graphs, the size of the independent set is equal to V−M, where V is the number of vertices, and M is the size of the maximum matching.

The only thing that's left is finding the maximum matching. Let's use event processing approach to do it: for each segment, create two events "the segment begins" and "the segment ends". While processing the events, maintain the currently existing segments in two sets (grouped by their colors and sorted by the time they end). When a segment ends, let's try to match it with some segment of the opposite color — and it's quite obvious that we should choose a segment with the minimum ri to form a pair.

Overall, this solution runs in O(nlogn).

Solution 1 (Ne0n25)Solution 2 (Ne0n25)1389G - Directing Edges

Idea: BledDest

Tutorial1389G - Directing EdgesSuppose we want to calculate the maximum profit for some vertex in O(n). Let's try to find out how it can be done, and then optimize this process so we don't have to run it n times.

First of all, we have to find the bridges and biconnected components in our graph. Why do we need them? Edges in each biconnected component can be directed in such a way that it becomes a strongly connected component, so we don't have to leave these edges undirected (it is never optimal). Furthermore, for each such component, either all vertices are saturated or no vertex is saturated. Let's build a tree where each vertex represents a biconnected component of the original graph, and each edge represents a bridge. We can solve the problem for this tree, and then the answer for some vertex of the original graph is equal to the answer for the biconnected component this vertex belongs to.

Okay, now we have a problem on tree. Let's implement the following dynamic programming solution: root the tree at the vertex we want to find the answer for, and for each vertex, calculate the value of dpv — the maximum profit we can get for the subtree of vertex v, if it should be reachable by all special vertices from its subtree.

Let's analyze how we can calculate these dp values. Suppose we have a vertex v with children v1, v2, ..., vd, we have already calculated the dp values for the children, and we want to calculate dpv. First of all, since the vertex v is going to be saturated, we will get the profit from it, so we initialize dpv with cv. Then we should decide whether we want to get the profit from the children of vertex v. Suppose the edge leading from v to vi has weight wi. If we want to take the profit from the subtree of vi, we (usually) have to make this edge undirected, so both vertices are saturated, thus we get dpvi−wi as profit — or we could leave this edge directed from vi to v, so the vertex v is saturated, and vi is not, and get 0 as the profit. But sometimes we can gain the profit from the vertex vi and its subtree without leaving the edge undirected: if all special vertices belong to the subtree of vi, we can just direct this edge from vi to v, and there is no reason to choose the opposite direction or leave the edge undirected. Similarly, if all special vertices are outside of this subtree, there's no reason to direct the edge from vi to v. So, if one of this conditions is met, we can get the full profit from the subtree of vi without leaving the edge undirected.

Okay, let's summarize it. We can calculate dpv as dpv=cv+∑i=1df(vi), where f(vi) is either dpvi if one of the aforementioned conditions is met (we don't have to leave the edge undirected if we want to saturate both vertices), or f(vi)=max(0,dpvi−wi) otherwise. Now we have an O(n2) solution.

Let's optimize it to O(n). Root the tree at vertex 1 and calculate the dynamic programming as if 1 is the root. Then, we shall use rerooting technique to recalculate the dynamic programming for all other vertices: we will try each vertex as the root of the tree, and dpv is the answer for the vertex v if it is the root. The rerooting technique works as follows: let's run DFS from the initial root of the tree, and when we traverse an edge by starting or finishing a recursive call of DFS, we move the root along the edge; so, if we call DFS(x), x is the current root; if it has some child y, we move the root to y the same moment when we call DFS(y), and when the call of DFS(y) ends, the root moves back to x.

Okay, the only thing that's left is to describe how we move the root. If the current root is x, and we want to move it to y (a vertex adjacent to x), then we have to change only the values of dpx and dpy: first of all, since y is no longer a child of x, we have to subtract the value that was added to dpx while we considered vertex y; then, we have to make x the child of vertex y, so we add the profit we can get from the vertex x to dpy. It can be done in O(1), so our solution runs in O(n), though with a very heavy constant factor.

Educational Codeforces Round 91 Editorial

By awoo, history, 3 years ago, translation, In English1380A - Three Indices

Idea: BledDest

Tutorial1380A - Three IndicesA solution in O(n2): iterate on j, check that there exists an element lower than aj to the left of it, and check that there exists an element lower than aj to the right of it. Can be optimized to O(n) with prefix/suffix minima.

A solution in O(n): note that if there is some answer, we can find an index j such that aj−1<aj and aj>aj+1 (if there is no such triple, the array descends to some point and ascends after that, so there is no answer). So we only have to check n−2 consecutive triples.

Solution (Ne0n25)1380B - Universal Solution

Idea: adedalic

Tutorial1380B - Universal SolutionLet's look at the contribution of each choice ci to the total number of wins win(1)+win(2)+⋯+win(n) (we can look at "total" instead of "average", since "average" is equal to "total" divided by n). For example, let's look at the first choice c1: in win(1) we compare c1 with s1, in win(2) — c1 with s2, in win(3) — c1 with s3 and so on.

In the result, we compare c1 with all si once. So, to maximize the total sum, we need to choose c1 that beats the maximum number of si or, in other words, let's find the most frequent character in s and choose c1 that beats it.

Okay, we found the optimal c1. But if we look at the contribution of any other ci we can note that we compare any ci with all si once. So we can choose all ci equal to c1 which is equal to the choice that beats the most frequent choice in s.

Solution (adedalic)1380C - Create The Teams

Idea: Roms

Tutorial1380C - Create The TeamsAt first, notice that if only k<n programmers are taken, then the same or even better answer can be achieved if k strongest programmers are taken.

Now let's sort the programmers in a non-increasing order and choose some assignment into the teams. For each team only the rightmost taken programmer of that team matters (the sorted sequence implies that the rightmost is the weakest).

Take a look at the team with the strongest weakest member. If the number of programmers in it is less than the position of the weakest member, then you can safely rearrange the programmers before him in such a way that none of parameters of later teams change and the weakest member in the first one only becomes stronger. After that you can get rid of the first team (as it takes exactly the prefix of all the programmers) and proceed to fix the later teams.

Thus, we can see that there is an optimal solution such that each team is a segment and all the teams together take some prefix of the programmers. So we can finally run a greedy solution that takes programmers from left to right and increases the answer if the conditions for the latest team hold.

Overall complexity: O(nlogn).

Solution (Roms)1380D - Berserk And Fireball

Idea: Roms

Tutorial1380D - Berserk And FireballThe first thing we need to do is to find the occurrences of bi in the sequence [a1,a2,…,an] — these are the monsters that have to remain. Since both spells (Fireball and Berserk) affect consecutive monsters, we should treat each subsegment of monsters we have to delete separately.

Consider a segment with x monsters we have to delete such that the last monster before it has power l, the first monster after the segment has power r, and the strongest monster on the segment has power p.

If xmodk≠0, then we have to use Berserk at least xmodk times. Let's make the strongest monster on segment kill some other monster. If x<k, then the strongest monster should also be killed by one of the monsters bounding the segment, so if l<p and r<p, there is no solution.

Okay, now the number of monsters is divisible by k. If it is more profitable to use Fireball, we use the required number of Fireballs to kill all of them. Otherwise, we have to kill the maximum possible number of monsters with Berserk and finish the remaining ones with Fireball. If l>p or r>p, then one of the monsters just outside the segment can kill all the monsters inside the segment; otherwise, the strongest monster should kill adjacent monsters until exactly k remain, and those k monsters are finished with a single Fireball.

Now we know what we need to consider when processing a single segment; all that's left is to sum the minimum required mana over all such segments. Since the total length of these segments is at most n−1 and we can process each segment in linear time, we have a solution with complexity O(n).

Solution (Roms)1380E - Merging Towers

Idea: Roms and BledDest

Tutorial1380E - Merging TowersFirst of all, let's try to find a simple way to evaluate the difficulty of a given set of towers. I claim that the difficulty is equal to the number of pairs of discs (i,i+1) that belong to different towers.

The beginning of the proof

during each operation we can "merge" at most one such pair: if we move discs to the tower with disk i on top of it, only the pair (i−1,i) can be affected;we can always take the first several k discs belonging to the same tower and move them to the tower containing disc k+1, thus merging exactly one pair in exactly one operation.The end of the proof

After that, there are two main approaches: LCA and small-to-large merging. The model solution uses LCA, so I'll describe it.

For each pair (i,i+1), we have to find the first moment these discs belong to the same tower. To do so, let's build a rooted tree on 2m−1 vertices. The vertices 1 to m will be the leaves of the tree and will represent the original towers. The vertex m+i will represent the tower created during the i-th query and will have two children — the vertices representing the towers we merge during the i-th query. The vertex 2m−1 is the root.

Now, if some vertex x is an ancestor of vertex y, it means that the tower represented by vertex x contains all the discs from the tower represented by vertex y. So, to find the first tower containing two discs i and i+1, we have to find the lowest common ancestor of the vertices representing the towers ti and ti+1. The easiest way to do it is to implement something like binary lifting, which allows us to solve the problem in O(nlogm).

Solution 1 (BledDest)Solution 2 (pikmike)1380F - Strange Addition

Idea: Roms

Tutorial1380F - Strange AdditionLet's solve the task as if there are no updates. This can be done with a pretty straightforward dp.

dpi is the number of pairs (a,b) such that the result of the strange addition of a and b is the prefix of c of length i. dp0=1. From each state you can add a single digit to a and to b at the same time. You can either go to dpi+1 and multiply the answer by the number of pairs of digits than sum up to ci. Or go to dpi+2 and multiply the answer by the number of pairs of digits than sum up to cici+1. Note that no pair of digits can sum up to a three-digit value, so it makes no sense to go further.

Let's optimize this dp with some data structure. Segment tree will work well. Let the node store the number of ways to split the segment [l;r) into blocks of size 1 or 2 so that:

both the leftmost character and the rightmost character are not taken into any block;the leftmost character is taken into some block and the rightmost character is not taken into any block;the leftmost character is not taken into any block and the rightmost character is taken into some block;both the leftmost and the rightmost characters are taken into some blocks.This structure makes the merge pretty manageable. You should glue up the segments in such a way that all the middle characters are taken into some block: either in separate blocks in their own segments or into the same block of length 2.

The answer will be in the root of the tree in a value such that both characters are taken.

The update in the segment tree will still work in O(logn).

Overall complexity: O(n+mlogn).

Solution 1 (pikmike)Solution 2 (Roms)1380G - Circular Dungeon

Idea: BledDest

TutorialAt first, let's say that the expected value is equal to the average of total earnings over all positions and is equal to the sum of earnings over all positions divided by n. So we can trasition to minimizing the sum.

Let's learn how to solve the task for some fixed k. Fix some arrangement and rotate the rooms so that the last room contains a mimic. So now you have cnt1 regular chests, then a single mimic, cnt2 regular chests, single mimic, …, cntk regular chests, single mimic. All cnti≥0 and ∑i=1kcnti=n−k.

Take a look at some of these intervals of length cnti. The last chest in the interval is taken from cnti starting positions, the second-to-last is taken cnti−1 times and so on.

Now let's find the optimal way to choose cnti. Fix some values of cnti. Take a look at the smallest of these values and the largest of them. Let the values be x and y. If they differ by at least 2 (x≤y−2), then the smaller result can always be achieved by moving a regular chest from the larger one to the smaller one.

ProofNow we have all cnti set now. The only thing left is to assign chests optimally. Write down the union of all the coefficient sequences from all the intervals ⋃i=1n−k[1,…,cnti−1,cnti] and sort them in the non-decreasing order. It's easy to show that the chests should be sorted in the non-increasing order (really classical thing, you can try proving that by showing that any other arrangement can easily be improved once again).

That allows us to write a solution in O(n2). Sort all the chests in the beginning, after that for some k multiply the value of the i-th chest by ⌊ik⌋ and sum up the results.

Finally, let's speed this up with prefix sums. Notice that the first k values are multiplied by 0, the second k values — by 1 and so on. If n is not divisible by k, then the last block just has length smaller than k. Thus, we can calculate the answer for some k in O(nk). And that's equal to O(∑k=1nnk) = O(nlogn).

Overall complexity: O(nlogn).

Educational Codeforces Round 90 Editorial

By awoo, history, 3 years ago, translation, In English1373A - Donut Shops

Idea: Roms

Tutorial1373A - Donut ShopsAt first notice that if there exists a value for the second shop, then the value divisible by b also exists. For any x you can round it up to the nearest multiple of b. That won't change the price for the second shop and only increase the price for the first shop.

You can also guess that if there exists a value for the first shop, then the value with 1 modulo b also exists (exactly 1 donut on top of some number of full boxes). Following the same logic — the second shop needs an entire new box and the first shop needs only an extra donut.

So let's take a look at the smallest values of two kinds:

x=b: this value is valid for the second shop if one box is cheaper than b donuts in the first shop. Otherwise, no matter how many boxes will you take, they will never be cheaper than the corresponding number of donuts.x=1: this value is valid for the first shop if one donut is cheaper than one box in the second shop. Apply the same idea — otherwise no value for the first shop is valid.Overall complexity: O(1) per testcase.

Solution (pikmike)1373B - 01 Game

Idea: Roms

Tutorial1373B - 01 GameIf there is at least one character 0 and at least one character 1, then current player can always make a move. After the move the number of character 0 decreases by one, and the number of character 1 decreases by one too. So the number of moves is always min(c0,c1), where c0 is the number of characters 0 in string s, and c1 is the number of characters 1 in string s.

So if min(c0,c1) is odd then Alice wins, otherwise Bob wins.

Solution (Roms)1373C - Pluses and Minuses

Idea: Roms

Tutorial1373C - Pluses and MinusesLet's replace all + with 1, and all - with -1. After that let's create a preffix-sum array p (pi=∑j=1isj). Also lets create array f such that fi is equal minimum index j such that pj=−i (if there is no such index pi=−1).

Let's consider the first iteration of loop for init = 0 to inf. If f1=−1 then process ends and res=|s|. Otherwise the condition if cur < 0 fulfilled then the value of i will be equal to f1. So, the value of res is equal to f1 after first iteration.

Now, let's consider the second iteration of loop for init = 0 to inf. If f2=−1 then process ends and res=f1+|s|. Otherwise the condition if cur < 0 fulfilled then the value of i will be equal to f2. So, the value of res is equal to f1+f2 after second iteration.

In this way we can calculate the value of res after the process ends.

Solution (Roms)1373D - Maximum Sum on Even Positions

Idea: vovuh

Tutorial1373D - Maximum Sum on Even PositionsFirstly, we can notice that the reverse of of odd length subarray does nothing because it doesn't change parities of indices of affected elements. Secondly, we can consider the reverse of the subarray of length 2x as x reverses of subarrays of length 2 (i.e. it doesn't matter for us how exactly the subarray will be reversed, we can only consider changing parities).

Now, there are two ways: the first one is smart and the second one is dynamic programming.

Consider the first way. Calculate the initial sum of elements on even positions sum. Then let's create two arrays v1 and v2. There v1[i] is a[2i+1]−a[2i] for all i from 0 to ⌊n2⌋−1 and v2[i] is a[2i]−a[2i+1] for all i from 0 to ⌊n2⌋−1. Elements of the first array deonte the profit if we reverse the subarray tarting from the even position, and elemnts of the second array denote the profit if we reverse the subarray starting from the odd position. Now we need to find the subarray with the maximum sum in both arrays (this will maximize overall profit) and add this value to sum to get the answer. This problem can be solved easily: consider the sum of the subarray [l;r] as the difference of two prefix sums prefr−prefl−1. To maximize it, consider all right borders and minimize the value prefl−1. Iterate over all positions of the array, maintaining the current prefix sum csum and the minimum prefix sum we meet msum. Update csum:=csum+ai, then update msum:=min(msum,csum) and then update the answer with the value csum−msum.

And the second way is author's solution and it is dynamic programming. This idea can be transformed to solve such problems in which you need to apply some function to some small number of subsegments (of course, under some constraints on functions). State of our dynamic programming is dpi,j where i∈[0;n] and j∈[0;2]. dpi,0 denotes the answer on the prefix of length i if we didn't start reversing the subarray, dpi,1 denotes the answer if we started reversing the subarray but didn't end it and dpi,2 denotes the answer if we ended reversing the subarray. Transitions are pretty easy:

dpi+1,0=max(dpi+1,0,dpi,0+[i%2==0?ai:0]);dpi+2,1=max(dpi+2,1,max(dpi,0,dpi,1)+[i%2==0?ai+1:ai]);dpi+1,2=max(dpi+1,2,max(dpi,0,dpi,1,dpi,2)+[i%2==0?ai:0]).The value x?y:z is just a ternary if statement. If x is true then return y otherwise return z.

The answer is max(dpn,0,dpn,1,dpn,2).

Time complexity with both approaches is O(n).

Solution (vovuh)1373E - Sum of Digits

Idea: BledDest

Tutorial1373E - Sum of DigitsThere are many ways to solve this problem (including precalculating all answers), but the model solution is based on the following:

In most cases, f(x+1)=f(x)+1. It is not true only when the last digit of x is 9 (and if we know the number of 9-digits at the end of x, we can easily derive the formula for f(x+1)). And since k≤9, there will be at most one number with last digit equal to 9 in [x,x+1,…,x+k].

Let's iterate on the last digit of x and the number of 9-digits before it. Suppose the fixed x has no other digits other than the last one and several 9-digits before it. Let's calculate s=f(x)+f(x+1)+f(x+2)⋯+f(x+k).

Here goes the trick. If we prepend x with several digits such that the last of them is not 9, and the sum of those digits is d, then f(x)+f(x+1)+f(x+2)⋯+f(x+k)=s+d(k+1). So we can easily derive the value of d we need and construct the smallest number with sum of digits equal to d (don't forget that the last digit should not be 9).

Solution 1 (BledDest)Solution 2 (pikmike)1373F - Network Coverage

Idea: adedalic

Tutorial1373F - Network CoverageThere are plenty of different solutions to this problem. Here is one that doesn't use Hall's theorem.

Let's look at pair (ai,bi) as fuction fi(in)=out: how many connections out will be left for the (i+1)-th city if we take in connections from the (i−1)-th station. This function has the following structure: there is a minimum required in (let's name it minxi) to meet the needs of the i-th city and with minxi borrowed connections there will be fi(minxi)=minki free connections to the (i+1)-th city. Increasing minxi by some x we can get fi(minxi+x)=minki+x free connections, but there is upper bound to number of free connections maxki. In other words, the function fi(minxi+x)=min(minki+x,maxki) where x≥0.

For example, let's calculate the corresponding coefficients for the i-th function:

if ai≤bi then minxi=0, minki=bi−ai and maxki=bi;if ai>bi then minxi=ai−bi, minki=0 and maxki=bi.Why did we define such functions? If we can calculate result function f[1,n](in)=fn(fn−1(…f2(f1(in))…)) then we can check the possibility of meeting all needs by checking that this fuction exists and minx[1,n]≤mink[1,n], i. e. the minimum free mink[1,n] can be used as borrowed minx[1,n].

Fortunately, it turns out that the superposition fi+1(fi(in)) is either don't exists (if, for example, maxki<minxi+1) or it has the same structure as any function fi. So we can calculate f[1,n] in one pass and find the answer.

We will skip the detailed formulas to calculate fi+1(fi(in)): you can either find them by yourself or look at function merge() in author's solution.

The resulting complexity is O(n).

Solution 1 (adedalic)Solution 2 (Ne0n25)1373G - Pawns

Idea: Roms and BledDest

Tutorial1373G - PawnsFor each pawn with initial position (x,y) there exists a minimum index of row i such that the pawn can reach the cell (k,i), but cannot reach the cell (k,i−1). It's easy to see that i=|k−x|+y. In the resulting configuration, this pawn can occupy the cell (k,i), (k,i+1), (k,i+2) or any other cell (k,j) having j≥i.

Suppose the board consists of r rows. For each row, the number of rows above it should be not less than the number of pawns that occupy the cells above it (that is, having i greater than the index of that row) — because, if this condition is not fulfilled, we can't assign each pawn a unique cell. If we denote the number of pawns that should go strictly above the j-th row as f(j), then for every row, the condition f(j)≤r−j must be met.

To prove that this condition is sufficient, we may, for example, use Hall's theorem. Okay, now what about finding the minimum r satisfying it? Let's initially set r to n, and for each row maintain the value of j+f(j)−n — the minimum number of rows we have to add to our board so that the condition for the row j is met (we also have to maintain this value for n−1 auxiliary rows from n+1 to 2n−1, since some pawns cannot fit in the initial board at all). Finding the minimum value we have to add to r equals finding the maximum of all these values on some prefix (we don't need to look at the values on some rows with large indices, if there are no pawns after them, so we need a maximum query on the segment [1,maxi], where maxi is the maximum index i among all pawns); and when a pawn is added or removed, we should add +1 or −1 to all values on some suffix. A segment tree with lazy propagation will do the trick, solving the problem for us in O(mlogn).

Educational Codeforces Round 89 Editorial

By awoo, history, 3 years ago, translation, In English1366A - Shovels and Swords

Idea: Roms

Tutorial1366A - Shovels and SwordsThere are three constraints on the number of emeralds:

the number of emeralds can't be greater than a;the number of emeralds can't be greater than b;the number of emeralds can't be greater than a+b3.So the answer is min(a,b,a+b3).

Solution (Roms)1366B - Shuffle

Idea: Roms

Tutorial1366B - ShuffleLet's consider how the set of possible indices where the 1 can be changes. Initially, only one index is correct — x. After performing an operation l,r such that x<l or x>r this set does not change. But after performing an operation l,r such that l≤x≤r we should insert the elements {l,l+1,l+2,…,r−1,r} into this set, if they are not present.

Now consider how the set {L,L+1,L+2,…,R−1,R} changes. If segments [l,r] and [L,R] do not share any indices, there are no changes — but if they do, the set turns into {min(l,L),min(l,L)+1,min(l,L)+2,…,max(r,R)−1,max(r,R)}.

So the set of reachable indices is always a segment of numbers, and to process an operation, we should check whether the segment from operation intersects with the segment of indices we have — and if it is true, unite them.

Solution (Roms)1366C - Palindromic Paths

Idea: BledDest

Tutorial1366C - Palindromic PathsLet's group the cells by their distance from the starting point: the group 0 consists of a single cell (1,1); the group 1 consists of the cells (1,2) and (2,1), and so on. In total, there are n+m−1 groups.

Let's analyze the groups k and n+m−2−k. There are two cases:

if k=0 or n+m−2−k=0, then we are looking at the starting cell and the ending cell, and their contents should be equal;otherwise, suppose two cells (x,y) and (x+1,y−1) belong to the same group. We can easily prove that the contents of these two cells should be equal (for example, by analyzing two paths that go through cell (x+1,y) and coincide after this cell, but one goes to (x+1,y) from (x,y), and another — from (x+1,y−1)) — and, using induction, we can prove that the contents of all cells in a group should be equal. And since the paths should be palindromic, the contents of the group k should be equal to the contents of the group n+m−2−k.So, in each pair of groups, we should calculate the number of 1's and 0's, and choose which of them to change. Note that if n+m is even, the central group has no pair, so it should not be modified.

Solution (BledDest)1366D - Two Divisors

Idea: adedalic

Tutorial1366D - Two DivisorsFirstly, for the fast factorization of given ai, let's use Sieve of Eratosthenes: let's for each value val≤107 calculate its minimum prime divisor minDiv[val] in the same manner as the sieve do. Now we can factorize each ai in O(logai) time by separating its prime divisors one by one using precalculated array minDiv.

Suppose, we have a factorization ai=ps11ps22⋅…⋅pskk. If k=1 then any divisor of ai is divisible by p1 so do the sum of divisors. Obviously, the answer is −1 −1.

Otherwise, we can divide all prime divisors pi into two non-empty groups {p1,p2,…,px} and {px+1,…,pk} and take d1=p1⋅p2⋅…⋅px and d2=px+1⋅…⋅pk. Any division is valid (proof is below), so, for example, we can take d1=p1 and d2=p2⋅…⋅pk.

Let's prove that if d1=p1⋅p2⋅…⋅px and d2=px+1⋅…⋅pk then gcd(d1+d2,ai)=1. Let's look at any pi. We can assume that ai≡0modpi and (without loss of generality) d1≡0modpi. But it means that d2≢0modpi, then d1+d2≡0+d2≡d2≢0modpi. In other words, there are no prime divisor of ai which divides d1+d2, so the gcd(d1+d2,ai)=1.

Time complexity is O(AloglogA+nlogA) for the sieve and finding answers (A≤107).

Solution (adedalic)1366E - Two Arrays

Idea: Roms

Tutorial1366E - Two ArraysAt first, let's reverse arrays a and b. Now array b is sorted in descending order.

Now let's find minimum index x such that ax=b1. If there is no such index or if min1≤i≤xai<b1 then the answer is 0 (because minimum on any prefix of array a will never be equal to b1).

Otherwise, let's find the minimum index y>x such that ay=b2. If there is no such index or if minx≤i≤yai<b2 then the answer is 0. Also let's find the minimum index mid>x such that amid<b1 (it can't be greater than y). The first subarray starts in position 1 and ends in any position x,x+1,x+2,…,mid−1 (because if it ends in position mid or further, then the minimum in the first subarray is greater than b1). So there are mid−x ways to split subarrays 1 and 2.

A similar approach can be used to calculate the number of ways to split the second and third subarrays and, so on.

After all, you have to check that minimum in the last subarray is equal to bm (otherwise the answer is 0).

Solution (Roms)1366F - Jog Around The Graph

Idea: Neon

Tutorial1366F - Jog Around The GraphLet's observe what does the maximum weight of some fixed length path look like. Among the edges on that path the last one has the maximum weight. If it wasn't then the better total weight could be achieved by choosing a bigger weight edge earlier and going back and forth on it for the same number of steps. It actually helps us arrive to a conclusion that all optimal paths look like that: some simple path to an edge and then back and forth movement on it.

Any simple path in the graph has its length at most m. Let's separate the queries into two parts.

k<m will be handled in a straightforward manner. Let dp[v][k] be the maximum weight of a path that ends in v and has exactly k edges in it. That's pretty easy to calculate in (n+m)⋅m.

You can also think of this dp as some kind of Ford-Bellman algorithm — let dv on the k-th step be the maximum weight of the path to v of length k. Iterate over all edges and try to update dv and du for each edge (v,u) (that's what I do in my solution if you refer to it).

Now for k≥m. There was a very common assumption that after a bit more steps some edge will become the most optimal and will stay the most optimal until the end of time. However, that "a bit" cut-off is in fact too high to rely on (it must be somewhere around n⋅maxw).

So the best path of length exactly m ending in each vertex v is dp[v][m]. Let the maximum weight adjacent edge to vertex v be mxv. So the path of length k will have weight mxv⋅(k−m)+dp[v][m]. Treat it like a line kx+b with coefficients mxv and dp[v][m].

How do determine which line is the best for some k? Sure, experienced participants will immediately answer "convex hull". Build a lower envelope of the convex hull of these lines. If q was a little smaller than we could query with binary search for each k, the same how convex hull is usually used.

We have to examine the hull further. Each line in it becomes the best in some point, then stays the best for some interval and then never appears the best again. What are these line changing points? Well, it's just the intersection point of the adjacent lines in the hull. So having these points and the parameters of the line we can calculate its contribution to the answer with a sum of arithmetic progression formula.

There were just n lines in the hull so you can build the hull in any complexity, I think I saw up to O(n2logn) performances in the participants codes.

There is a cool solution that involves some kind of Divide&Conquer on these lines. I personally thought of it in a sense of traversing a Li-Chao tree without actually building it. If anyone wants to explain this solution, feel free to do it in comments.

Overall complexity: O((n+m)⋅m+nlogn).

Solution (pikmike)1366G - Construct the String

Idea: Neon

Tutorial1366G - Construct the StringThe core idea of the solution is the following dynamic programming: dpi,j is the minimum number of characters we have to delete if we considered a subsequence of i first characters of s, and it maps to j first characters of t.

There are three obvious transitions in this dynamic programming:

we can go from dpi,j to dpi+1,j by skipping si;if si=tj, we can go from dpi,j to dpi+1,j+1;if si is a dot, we can go from dpi,j to dpi+1,j−1.Unfortunately, these transitions cannot fully handle the case when we want to put some character and then delete it (these transitions don't allow us to do it for any character, only for some specific ones in specific situations). To handle it, suppose we want to take the character si and then delete it, and we model it as follows: there exists the fourth transition from dpi,j to dpi+leni,j without deleting anything, where leni is the length of the shortest substring of s starting from i that becomes empty if we apply the function f to it. This substring can be described as a regular bracket sequence, where opening brackets correspond to letters, and closing brackets — to dots. We can precalculate this substring for each i in O(n).

Why is this transition enough? Suppose we don't want to take some letter from this shortest substring in the optimal answer; since it is the shortest substring meeting these constraints, the number of letters on each prefix of it (excluding the substring itself) is greater than the number of dots, so we can instead skip the first letter and try applying this transition from dpi+1,j, so this case is handled. And skipping any dots from this shortest substring is also suboptimal since we have to get rid of the character si.

Educational Codeforces Round 88 Editorial

By awoo, history, 3 years ago, translation, In English1359A - Berland Poker

Idea: BledDest

Tutorial1359A - Berland PokerThere are many different ways to solve this problem. The easiest one, in my opinion, is to iterate on the number of jokers the winner has (let it be a1) and the number of jokers the runner-up has (let it be a2). Then the following conditions should be met:

a1≥a2 (the winner doesn't have less jokers than the runner-up);a1≤nk (the number of jokers in the winner's hand does not exceed the number of cards in his hand);a1+a2≤m (the number of jokers for these two players does not exceed the total number of jokers);a1+(k−1)a2≥m (it is possible to redistribute remaining jokers among other players so that they have at most a2 jokers).Iterating on a1 and a2, then checking these constraints gives us a O(n2) solution. It is possible to get a constant-time solution using some greedy assumptions and math (the first player should get as many jokers as possible, while the remaining jokers should be evenly distributed among other players).

Solution 1 (BledDest)Solution 2 (BledDest)1359B - New Theatre Square

Idea: BledDest

Tutorial1359B - New Theatre SquareNotice that rows can be solved completely separately of each other. Each tile takes either one or two squares but it's always in the same row.

So let's take a look at a single row. There are sequences of dot characters separated by some asterisks. Once again each of these sequences can be solved independently of the others.

Thus, we have these empty strips of empty squares 1×k which, when solved, can be summed up into the whole answer.

There are two cases, depending on if a 1×2 is cheaper than two 1×1 tiles.

If it is then we want to use of many 1×2 tiles as possible. So given k, we can place ⌊k2⌋ 1×2 tiles and cover the rest k−2⋅⌊k2⌋=k mod 2 squares with 1×1 tiles.

If it isn't cheaper then we want to cover everything with 1×1 tiles and never use 1×2 ones. So all k should be 1×1.

The easier way to implement this might be the following. Let's update the price of the 1×2 tile with the minimum of y and 2⋅x. This way the first algorithm will produce exactly the same result of the second one in the case when a 1×2 tile isn't cheaper than two 1×1 ones.

Overall complexity: O(nm) per testcase.

Solution (pikmike)1359C - Mixing Water

Idea: adedalic

TutorialSo there are two kinds of stops to consider: k hot and k cold cup and (k+1) hot and k cold cups.

The first case is trivial: the temperature is always h+c2. In the second case the temperature is always strictly greater than h+c2. Thus, if t≤h+c2, then the answer is 2.

Let's show that otherwise the answer is always achieved through the second case.

The temperature after (k+1) hot cups and k cold cups is tk=(k+1)⋅h+k⋅c2k+1. The claim is that t0>t1>…. Let's prove that by induction.

Proof 1We can also show that this series converges to h+c2:

Proof 2So that claim makes us see that for any t greater than h+c2 the answer is always achieved from the second case.

That allows us to find such k, that the value of tk is exactly t. However, such k might not be integer. (k+1)⋅h+k⋅c2k+1=t↔ k⋅(h+c)+h2k+1=t↔ k⋅(h+c)+h=2kt+t↔ k⋅(h+c−2t)=t−h↔ k=t−hh+c−2t.

The only thing left is to compare which side is better to round k to. It seems some implementations with float numbers might fail due to precision errors. However, it's possible to do these calculations completely in integers.

Let's actually rewrite that so that the denominator is always positive k=h−t2t−h−c. Now we can round this value down and compare k and k+1.

So the optimal value is k if |k⋅(h+c)+h2k+1−t|≤|(k+1)⋅(h+c)+h2k+3−t|. So |(k⋅(h+c)+h)−t⋅(2k+1)|⋅(2k+3)≤|((k+1)⋅(h+c)+h)−t⋅(2k+3)|⋅(2k+1). Otherwise, the answer is k+1.

You can also find the optimal k with binary search but the formulas are exactly the same and you have to rely on monotonosity as well. Also, these formulas can get you the better understanding for the upper bound of the answer.

Overall complexity: O(1) or O(logh) per testcase.

Solution (pikmike)1359D - Yet Another Yet Another Task

Idea: BledDest

Tutorial1359D - Yet Another Yet Another TaskAlice wants to choose such a segment [l;r] that ∑l≤i≤rai−maxl≤i≤rai is maximum possible.

There is a well-known problem where you have to find a segment with maximum ∑l≤i≤rai. That problem is solved with Kadane algorithm. Let's learn how to reduce our problem to that one.

Notice that the values in the array are unusually small. Let's iterate over the maximum value on segment. Let mx be the current value. If we make all ai such that ai>mx equal to −∞, then it will never be optimal to take them in a segment. Find the maximum sum subarray in that modified array and update the answer with its sum−mx.

Notice that you can ignore the fact if there is a value exactly equal to mx on the maximum sum segment. If there isn't then you'll update the answer with a smaller value than the actual one. Let the actual maximum on the maximum sum segment be some y. You can see that for any value between y and mx the maximum sum segment will always be that chosen one. Thus, when you reach y, you'll update the answer with the correct value.

Overall complexity: O(maxai⋅n).

Solution (pikmike)1359E - Modular Stability

Idea: BledDest

Tutorial1359E - Modular StabilityWe claim that the array is stable if and only if all elements are divisible by its minimum. The proof of this fact will be at the end of the editorial.

To calculate the number of stable arrays now, we need to iterate on the minimum in the array and choose the remaining elements so that they are multiples of it. If the minimum is i, then the resulting elements should be divisible by i. There are d=⌊ni⌋ such numbers between 1 and n, and we have to choose k−1 elements out of d−1 (since i is already chosen). The number of ways to do it can be calculated by precomputing factorials modulo 998244353, since it is a binomial coefficient.

Proof of the claim at the beginning of the editorial:

On the one hand, since (xmoda)mod(ba)=(xmod(ba))moda=xmoda, if all elements in the array are divisible by some element, nothing depends on the order of these elements.

On the other hand, suppose there exists an element ai such that it is not divisible by a1. Let's take x=ai and two following reorders of the array a: [a1,a2,…,ak] and [ai,a1,a2,…,ai−1,ai+1,…,ak]. For the first array, we get xmoda1=aimoda1, which is non-zero; and for the second array, aimodai=0, so the result is zero.

Solution (BledDest)1359F - RC Kaboom Show

Idea: BledDest

Tutorial1359F - RC Kaboom ShowLet f(t) be true if it's possible to have a collision before time t. That function is monotonous, thus let's binary search for t.

For some fixed t car i can end up in any point from (xi,yi) to si⋅t units along the ray ((xi,yi),(xi+dxi,yi+dyi)). That makes it a segment.

So the collision can happen if some pair of segments intersects. Let's learn how to find that out.

The general idea is to use sweep line. So let's add the events that the i-th segment (x1i,y1i,x2i,y2i) such that x1i<x2i opens at x1i and closes at x2i. There were no vertical segments, so x1i and x2i are always different.

At every moment of time T we want to maintain the segments ordered by their intersection with the line x=T. Note that if two segments change their order moving along the sweep line, then they intersect.

So we can maintain a set with a custom comparator that returns if one segment intersects the current line lower than the other one.

When adding a segment to set, you want to check it's intersections with the next segment in the order and the previous one. When removing a segment, you want to check the intersection between the next and the previous segment in the order. If any check triggers, then return true immediately. It's easy to show that if the intersection happens between some pair of segments, then the intersection between only these pairs of segment also happens.

Now for the implementation details. Precision errors play a huge role here since we use binary search and also store some stuff dependant on floats in the set.

The solution I want to tell requires no epsilon comparisons, thus it calculates the answer only with the precision of binary search.

So the first issue rises when we have to erase elements from the set. Notice that we can make a mistake when we are adding the segment and there is a segment with almost the same intersection point. That will not make the answer incorrect (that's not trivial to show but it's possible if you consider some cases). If you can find it later to remove, then it's not an issue at all. However, that will probably mess up the lower_bound in the set.

Thus, let's save the pointer to each element in the set and remove it later by that pointer.

The second issue comes when you have to check the intersection of two segments. The error might appear when one segment ((xi,yi),(nxi,nyi)) (let the first point be the original (xi,yi) and the second point be calculated depending on t) has it's intersection point with segment ((xj,yj),(nxj,nyj)) at exactly (xi,yi). So the slightest miscalculations could matter a lot.

Let's learn to intersect in such a way that no epsilon comparisons are required. Firstly, we can store lines in the set instead of segments. Second, we can check the intersection of rays first and only then proceed to check the intersection of segments.

So two rays intersect if:

their lines intersect — easy to check in integers;the intersection point lies in the correct direction of both rays — the intersection point is always a pair of fractions (DxD,DyD) and you want to compare the signs of dxi and DxD−xi.Finally, if all the checks hold, then you can compare maximum of distances from (xi,yi) and (xj,yj) to the intersection point and t. If t is greater or equal then they intersect in time. There is no way to make that comparison in integers. However, it's precision only depends on the precision of t as in the error here can't affect the answer greatly.

Overall complexity: O(nlognlogmaxt).

Educational Codeforces Round 87 Editorial

By awoo, history, 3 years ago, translation, In English1354A - Alarm Clock

Idea: BledDest

Tutorial1354A - Alarm ClockLet's handle some cases. Firstly, if b≥a then Polycarp wakes up rested enough immediately, so b is the answer.

Otherwise, what does Polycarp do? He sets alarm to go off in c minutes and falls asleep in d minutes. Thus, he spends c−d minutes sleeping. Notice that if c−d is non-positive, then Polycarp always resets his alarm without sleeping. So for that case the answer is -1.

Finally, if Polycarp resets his alarm x times then he ends up with b+x⋅(c−d) minutes of sleep in total and ends up spending b+x⋅c minutes of time. We know that b+x⋅(c−d) should be greater or equal to a and x should be the smallest possible.

b+x⋅(c−d)≥a↔x⋅(c−d)≥a−b↔x≥a−bc−dThus, the smallest possible integer x is equal to ⌈a−bc−d⌉. And the answer is b+x⋅c.

Overall complexity: O(1) per testcase.

Solution (pikmike)1354B - Ternary String

Idea: BledDest

Tutorial1354B - Ternary StringThere are multiple solutions involving advanced methods such as binary search or two pointers, but I'll try to describe a simpler one.

The main idea of my solution is that the answer should look like abb...bbbbbc: one character of type a, a block of characters of type b, and one character of type c. If we find all blocks of consecutive equal characters in our string, each candidate for the answer can be obtained by expanding a block to the left and to the right by exactly one character. So the total length of all candidates is O(n), and we can check them all.

Why does the answer look like abb...bbbbbc? If the first character of the substring appears somewhere else in it, it can be deleted. The same applies for the last character. So, the first and the last characters should be different, and should not appear anywhere else within the string. Since there are only three types of characters, the answer always looks like abb...bbbbbc.

Solution (BledDest)1354C1 - Simple Polygon Embedding

Idea: adedalic

Tutorial1354C1 - Simple Polygon EmbeddingIt's not hard to come up with a solution if you just imagine how 2n-gon looks when n is even. The solution is to rotate 2n-gon in such way that several its sides are parallel to sides of the square.

And the answer is equal to the distance from center to any side multiplied by two, or:ans=1tanπ2⋅n1354C2 - Not So Simple Polygon Embedding

Idea: adedalic

Tutorial1354C2 - Not So Simple Polygon EmbeddingAt first, lets place 2n-gon in such way that the lowest side of 2n-gon is horizontal. Now we can, without loss of generality, think that the square has horizontal and vertical sides and we just rotate 2n-gon around its center.

If we rotate the 2n-gon at angle πn then it will move on itself. Moreover, after rotating at angle π2n we'll get left and right sides vertical and the following rotation is meaningless since it's the same as if we just swap x and y coordinates. So we don't we to rotate more than π2n.

Also, we can see that while rotating the difference between max x and min x decreasing while the distance between max y and min y increasing. The answer is, obviously, the maximum among these differences. So, for example, we can just ternary search the optimal answer.

Or we can note that the behavior of differences is symmetrical (just swap x and y coordinates) so the answer is in the middle angle, i.e. we just need to rotate 2n-gon at angle π4n.

Finally, observing several right triangles we can come up with quite an easy answer:

ans=cos(π4n)sin(π2n)Solution (adedalic)1354D - Multiset

Idea: BledDest

Tutorial1354D - MultisetFirst solution: write some data structure that would simulate the operations as they are given, for example, a segment tree or a Fenwick tree. Probably will require optimization since the limits are strict.

Second solution: notice that we have to find only one number belonging to the multiset. For example, let's find the minimum element. We can do it with binary search as follows: let's write a function that, for a given element x, tells the number of elements not greater than x in the resulting multiset. To implement it, use the fact that all elements ≤x are indistinguishable, and all elements >x are indistinguishable too, so the multiset can be maintained with just two counters.

Okay, how does this function help? The minimum in the resulting multiset is the minimum x such that this function returns non-zero for it, and since the function is monotonous, we can find the answer with binary search.

Solution (BledDest)1354E - Graph Coloring

Idea: BledDest

Tutorial1354E - Graph ColoringLet's rephrase the fifth condition. Each edge should connect two vertices with the numbers of different parity (either 1 to 2 or 3 to 2). So the graph should actually be bipartite and the first partition should have only the odd numbers (1 or 3) and the second partition should have only the even numbers (only 2).

Notice how 1 and 3 are completely interchangeable in the sense that if you have exactly n1+n3 vertices which should be assigned odd numbers then you can assign whichever n1 of them to 1 and the rest to 3 you want.

So you can guess that the first step is to check if the given graph is bipartite. If it isn't then the answer doesn't exist. It can be done with a single dfs. Actually the algorithm for that extracts the exact partitions, which comes pretty handy.

If the graph was a single connected component then the problem would be easy. Just check if either the first partition or the second one has size n2 and assigned its vertices color 2. If neither of them are of size n2 then the answer obviously doesn't exist.

However, the issue is that there might be multiple connected components and for each of them you can choose the partition to assign 2 to independently. Still, each of the connected components should be bipartite for the answer to exist.

This can be done with a knapsack-like dp. Let the i-th connected component have partitions of sizes (li,ri). Then the state can be dp[i][j] is true if i connected components are processed and it's possible to assign 2 to exactly j vertices of these components. As for transitions, for the i-th component you can either take the partition with li vertices or with ri vertices. Thus, if dp[i][j] is true then both of dp[i+1][j+li] and dp[i+1][j+ri] are also true.

If dp[number_of_connected_components][n2] is false then there is no answer. Otherwise, you can always restore the answer through the dp. The easiest way is probably to store not true/false in dp[i][j] but three values: −1 for false, 0 for the case the state is reached by taking the first partition of the (i−1)-th component and 1 for the second partition. Also, you should store not only the sizes of the partitions but the vertices in each of them as well. This way you can recover the answer by backtracking from the final state.

Overall complexity: O(n2).

Solution (pikmike)1354F - Summoning Minions

Idea: BledDest

Tutorial1354F - Summoning MinionsFirst of all, let's try to find the best strategy to play minions. All minions should be summoned (if someone is not summoned, summoning and deleting it won't make the answer worse), the resulting number of minions should be exactly k (if it is less, then we didn't need to delete the last deleted minion). Furthermore, if some minion should be deleted, we can delete it just after it is summoned. All these greedy ideas lead to the following structure of the answer:

we choose k−1 minions and summon them in some order;we choose n−k minions which will be summoned and instantly deleted;we summon the remaining minion.Let's analyze how these minions affect the answer. The first minion has power ai and does not give bonus to anyone, the second one has power ai and gives bonus to one minion, and so on — the j-th minion from the first group adds ai+(j−1)bi to the answer. Minions from the second group buff k−1 minions each, so they add bi(k−1) to the answer; and the last minion adds ai+bi(k−1). Let's unite the first group and the last minion; then we will have two groups of minions — those which are destroyed (the second group) and those which are not destroyed (the first group).

From there, we will have two possible ways to finish the solution:

there are n minions and n positions for them, and for each pair (minion, position) we may calculate the value this pair adds to the answer. After that, we should assign each monster a position in such a way that each position is chosen exactly once, and the sum of values is maximized. It can be done with mincost flows or Hungarian algorithm;the minions from the first group should be played in non-descending order of their bi. Let's sort all minions by bi and write the following dynamic programming: dpx,y is the maximum answer if we considered x first minions, and y of them were assigned to the first group. Since the minions are sorted by bi, whenever we add a minion to the first group, it should add exactly ai+ybi to the answer (and increase y by 1); and if a minion is added to the second group, the answer is increased by (k−1)bi.Solution 1 (BledDest)Solution 2 (neal)Solution 3 (pikmike)1354G - Find a Gift

Idea: adedalic

Tutorial1354G - Find a GiftThe solution consists of several steps.

The first step. Let's find out "does the first box contain stone or valuable gift" using random. Let's make 30 queries to compare the weight of the first box with the weight of another random box. If the first box is lighter than we found an answer, otherwise the probability of the first box having stones is at least 1−2−30.

The second step. Let's compare the weights of the first box and the second one. If they are equal then let's compare the weights of boxes [1,2] and [3,4]. If they are equal then let's compare the boxes [1…4] and [5…8] and so on. In other words, let's find the minimum k≥0 such that [1,2k] contains only boxes with stones but [2k+1,2k+1] contain at least one box with a valuable gift. It's easy to see that we'd spend no more than 10 queries.

The third step. We have segment [1,2k] with only stones and [2k+1,2k+1] with at least one gift. Let's just binary search the leftmost gift in the segment [2k+1,2k+1] using boxes from [1,2k] as reference: if we need to know "does segment of boxes [l,mid) have at least one gift", let's just compare it with segment [0,mid−l) which have only stones. if [l,mid) is lighter then it has, otherwise doesn't have. This part also requires no more than 10 queries.

Educational Codeforces Round 86 Editorial

By awoo, history, 3 years ago, translation, In English1342A - Road To Zero

Idea: BledDest and adedalic

Tutorial1342A - Road To ZeroLet's presume that x≥y. Then there are two cases in the problem:

If a+a≤b then we have to x+y times perform the first operation. So the answer is (x+y)⋅a;If a+a>b then we have to y times perform the second operation and pass the remaining distance by performing the first operation. So the answer is y⋅b+(x−y)⋅a.Solution (Roms)1342B - Binary Period

Idea: adedalic

Tutorial1342B - Binary PeriodLet's see how strings with periods k=1 and k=2 look. There are two types of strings with a period equal to 1: 0000... and 1111.... And there are two types of strings with a period equal to 2: 01010... and 10101....

It's easy to see if t consists only of 0's (1's) then the string itself is an answer since it has period equal to 1. Otherwise, it's also quite obvious that any string t is a subsequence of 0101...01 (1010...10) of 2|t| length.

Solution (adedalic)1342C - Yet Another Counting Problem

Idea: BledDest and adedalic

Tutorial1342C - Yet Another Counting ProblemIt's quite easy to see that ((ab+x)moda)modb=(xmoda)modb. What does it mean? The property given in the statement holds for x if and only if it holds for xmodab. It allows us to answer each testcase in O(ab+q) as follows: for each number from 0 to ab−1, we may check the given property before processing the queries, and build an array of prefix sums on it to efficiently count the number of integers satisfying the property from the segment [0,y], where y<ab. Then each query [l,r] can be divided into two prefix-queries [0,l−1] and [0,r]. To answer a prefix query [0,p] in O(1), we can calculate the number of "full segments" of length ab inside this prefix (that is ⌊pab⌋) and the length of the last segment of numbers that don't belong into a full segment (that is pmodab). To handle full segments, we multiply the number of integers satisfying the property on one segment by the number of such segments, and to handle the last part of segment, we use prefix sums.

Solution (BledDest)1342D - Multiple Testcases

Idea: BledDest

Tutorial1342D - Multiple TestcasesLet's estimate the smallest possible achievable answer. Let the number of the arrays of size greater than or equal to i be gi. The answer is maximum ⌈gici⌉ over all i from 1 to k. You can prove that you can't fit gi arrays in less than ⌈gici⌉ testcases with the pigeonhole principle. Let that be called ans.

Ok, let's now construct the solution for that estimate. Sort arrays in the increasing or decreasing order and assign the i-th array (0-indexed) in that order to the i mod ans testcase. It's easy to see that for any i the number of arrays of size greater than or equal to i is always restricted by ⌈gici⌉.

Overall complexity: O(nlogn+k) or O(n+k) if you care enough to do counting sort.

Solution (pikmike)1342E - Placing Rooks

Idea: BledDest

Tutorial1342E - Placing RooksIf we want to place n rooks on an n×n chessboard so all empty cells are under attack, then either each row or each column should contain at least one rook. Let's suppose that each row contains at least one rook, and multiply the answer by 2 in the end.

How to ensure that there are exactly k pairs of rooks attacking each other? Since each row contains exactly one rook, only the rooks in the same column attack each other — moreover, if there are x rooks in a non-empty column, they create (x−1) pairs. So our goal is to distribute n rooks to n−k columns so that each column contains at least one rook.

How to calculate the number of ways to distribute the rooks into c columns? One of the options is to choose the columns we use (the number of ways to do this is (nc)), and then use inclusion-exclusion to ensure that we are counting only the ways where each column contains at least one rook. The formula we will get is something like ∑i=0c(−1)i(ci)(c−i)n: we want to fix the number of columns that will not contain rooks (that is i), which are these columns (that is (ci)), and how many are there ways to distribute the rooks among remaining columns (that is (c−i)n).

Are we done? Almost. We wanted to multiply the answer by 2 to count the ways where each column contains at least one rook, but we should not do it if k=0, because in this case each placement of the rooks has exactly one rook in each row and exactly one rook in each column.

Solution (BledDest)1342F - Make It Ascending

Idea: Neon

Tutorial1342F - Make It AscendingSuppose we don't have any constraints on the order of elements, the resulting array just should not contain any duplicates. Let's build the result one element after another in ascending order, so each element we create is strictly greater than the previous. To create an element, just use some subset of elements and merge them into new element. This process can be efficiently modeled with the following dynamic programming: dpcnt,mask is the minimum value of the last element, if we merged all the elements from mask into cnt ascending numbers. To model transitions, we simply iterate on the mask of elements that will be merged into a new one, and check if its sum is greater than the last element we created. This runs in O(n3n), if we use an efficient way to iterate on all masks that don't intersect with the given mask.

Okay, how about maintaining the order? When we create an element by merging some elements of the original array, let's choose some position of an element we use in merging and state that all other elements are added to it. Then, to ensure that the result is ascending, the position of this element should be greater than the position of the element we chose while building the previous number. We can add the position we have chosen for the last element to the states of our dynamic programming, so it becomes dpcnt,mask,pos — the minimum value of the last element, if we merged the mask of elements into cnt numbers, and the last element originally had index pos in the array.

Using some greedy optimizations (for example, we should not iterate on the position we are choosing to merge — it can be chosen greedily as the leftmost position after the position of previous element we are taking into consideration), we can make it O(n23n), yet with a small constant factor. To restore the answer, we can maintain the previous values of mask and pos in each state, since cnt just increases by 1 with each transition.

Educational Codeforces Round 85 Editorial

By awoo, history, 3 years ago, translation, In English1334A - Статистика по уровню

Idea: awoo

Tutorial1334A - Level StatisticsLet's use the fact that initially the level has 0 plays and 0 clears. Call the differences before the previous stats and the current ones Δp and Δc.

The stats are given in chronological order, so neither the number of plays, nor the number of clears should decrease (i.e. Δp≥0 and Δc≥0).

Finally, Δp should be greater or equal to Δc. It's easy to show that if Δc players pass the level successfully and Δp−Δc players just try the level then such deltas are achieved.

So in implementation it's enough to check these three conditions between the consecutive pieces of data (including the initial (0,0)).

Overall complexity: O(n).

Solution (pikmike)1334B - Средний класс

Idea: adedalic

Tutorial1334B - Middle ClassIn fact, to carry out only one reform is always enough. And it's easy to prove if you make only one reform it's always optimal to take the maximum such k that the average of k maximums in the array a is at least x (i.e. sum greater or equal to kx). So the solution is next: sort array a and find the suffix with maximum length k such that the sum on the suffix is at least kx.

===

To prove the fact about one reform we can prove another fact: after each reform, the sum of k maximums doesn't increase for each k. We'll prove it in two steps.

The first step. Let's look at some reform and form an array b from the chosen elements in a in descending order. After the reform we'll get array b′ where all b′[i]=1|b|∑|b|i=1b[i]. Let's just skip the proof and say it's obvious enough that ∑yi=1b[i]≥∑yi=1b′[i] for any y.

The second step. Let fix k and divide array a on two parts: k maximums as a1 and other n−k elements as a2. And let's make the same division of a′ (the array after performing the reform) on a′1 and a′2. So, we need to prove that sum(a′1)≤sum(a1).

Suppose m elements were chosen in the reform: cnt of them were in a1 and cnt′ now in a′1. If cnt≥cnt′ then we can think like maximum cnt′ elements from cnt elements in a were replaced by the average and other cnt−cnt′ were replaced by elements from a2. Since ∑cnt′i=1b[i]≥∑cnt′i=1b′[i] and any element from a1 is greater or equal to any element from a2 then we proved that sum(a′1)≤sum(a1) when cnt≥cnt′.

If cnt<cnt′ then let's look at a2 and a′2. The a2 has m−cnt chosen elements and a′2 has m−cnt′, so m−cnt>m−cnt′ and we can prove that sum(a′2)≥sum(a2) practically in the same way as before. Obviously, if sum(a′)=sum(a) and sum(a′2)≥sum(a2) then sum(a′1)≤sum(a1). Q.E.D.

The last step is easy, let's prove that the only reform is enough. The answer after several reforms is clearly equal to k maximums which are at least x. But it means that the sum of k maximums is at least kx, therefore the sum of k maximums in the initial array is at least kx. So we can make them all at least k by only one reform.

Solution (adedalic)1334C - Круг монстров

Idea: BledDest

Tutorial1334C - Circle of MonstersWe cannot utilize the explosion of the last monster we kill. So the naive approach is to iterate on the monster we kill the last, break the circle between this monster and the next one, and then shoot the first monster in the broken circle until it's dead, then the second one, and so on.

Let's calculate the number of bullets we will fire this way. If the circle is broken after the monster i, then the first monster gets ai+1 bullets, the second one — max(0,ai+2−bi+1), and so on; all monsters except the first one get exactly max(0,ai−bi−1) bullets.

So we should choose an index i such that ai+1−max(0,ai+1−bi) is minimum possible, since this is the number of bullets we have to spend additionally since we cannot utilize the explosion of the i-th monster. After breaking the circle between the monsters i and i+1, you may use a formula to calculate the required number of bullets, or just model the shooting.

Solution (Ne0n25)1334D - Минимальный эйлеров цикл

Idea: adedalic

Tutorial1334D - Minimum Euler CycleThe solution of the problem can be found clearly in constructive way. An example for n=5: (1 2 1 3 1 4 1 5 (2 3 2 4 2 5 (3 4 3 5 (4 5 ()))) 1) where brackets mean that we call here some recursive function calc.

Since on each level of recursion we have only O(n) elements and there O(n) levels then the generation of the certificate is quite easy: if on the currect level of recursion we can skip the whole part — let's just skip it. Otherwise let's build this part. Anyway, the built part of the cycle will have only O(n+(r−l)) length so the whole algorithm has O(n+(r−l)) complexity.

The answer is lexicographically minimum by the construction, since on each level of recursion there is no way to build lexicographically smaller sequence.

Solution (adedalic)1334E - Пути по делителям

Idea: BledDest

Tutorial1334E - Divisor PathsLet's define the semantics of moving along the graph. On each step the current number is either multiplied by some prime or divided by it.

I claim that the all shortest paths from x to y always go through gcd(x,y). Moreover, the vertex numbers on the path first only decrease until gcd(x,y) and only increase after it.

Let's watch what happens to the divisors list on these paths. At first, all the divisors of x that are not divisors of y are removed from the list. Now we reach gcd and we start adding the divisors of y that are missing from the list. The length of the path is this total number of changes to the list. That shows us that these paths are the shortest by definition.

If we ever take a turn off that path, we either will add some divisor that we will need to remove later or remove some divisor that we will need to add later. That makes the length of the path not optimal.

Now let's learn to calculate the number of paths. The parts before gcd and after it will be calculated separately, the answer is the product of answers for both parts.

How many paths are there to gcd? Well, let's divide x by gcd, that will give us the primes that should be removed from x. You can remove them in any order because the length of the path is always the same. That is just the number of their permutations with repetitions (you might also know that formula as multinomial coefficient).

The number of paths from gcd to y is calculated the same way.

To find the primes in xgcd(x,y) you can factorize D beforehand and only iterate over the primes of D.

Overall complexity: O(D−−√+qlogD).

Solution (pikmike)1334F - Странная функция

Idea: Roms и BledDest

Tutorial1334F - Strange FunctionThe "naive" version of the solution is just dynamic programming: let dpi,j be the minimum cost of removed elements (or the maximum cost of remaining elements) if we considered first i elements of a, and the resulting sequence maps to the first j elements of b. There are two versions of this solution, both working in O(n2):

calculate this dp "as it is", so there are O(nm) states and O(1) transitions from each state;ensure that the i-th element is taken into f(a), so there are O(n) states (since each element appears in b exactly once, the second state can be deduces from the first one), but up to O(n) transitions from each state.It turns out that we can optimize the second approach. Let's calculate the values of dpi in ascending order of ai: first of all, we calculate the values of dpi such that ai=b1, then transition into states such that ai=b2, and so on.

Calculating dpi for ai=b1 is easy: since the first element of a is always the first element of f(a), we should delete all elements before the i-th if we want it to be the first element in f(a). So, if dpi is the maximum possible sum of costs of remaining elements, if we considered the first i elements of a (and the i-th element gets included in f(a)), then dpi=ci for indices i such that ai=b1.

Okay, now let's consider advancing from bk to bk+1. If we want to go from dpi to dpj such that ai=bk and aj=bk+1, we should leave the element aj in the array and delete some elements between indices i and j. Which ones should be deleted? First of all, they are all elements with negative deletion cost; but we should also get rid of all elements which could replace aj in f(a) — that is, all elements that are greater than ai. So the remaining elements are x which have i<x<j, cx>0 and ax≤ai, and we should be able to compute the sum of such elements.

Even if we manage to do it in O(logn), which is possible, there may be up to O(n2) possible pairs of dpi and dpj to consider. The easiest way to get rid of that is to sort all occurences of bk and bk+1, and process them in ascending order, maintaining the best dpi that was already met. That way, each of the elements of a will be considered at most twice, so this solution runs in O(nlogn).

We know how to calculate the dp values now, but how to determine the answer? We should consider all values of dpi such that ai=bm and delete all elements with negative costs and all elements that are greater than ai from the suffix [i+1,n] — so this is another query of the form "compute the sum of cx over x which have i<x<j, cx>0 and ax≤ai". The most straightforward way to process them in O(logn) is to use a persistent segment tree, but since ai does not decrease in these queries as we process them, we may maintain the elements we are interested in with a much simpler data structure, for example, Fenwick tree.

Solution (BledDest)1334G - Поиск подстроки

Idea: BledDest

Tutorial1334G - Substring SearchWe will run two tests for each substring of t we are interested in. If at least one of them shows that the substring is not an occurence of s, we print 0, otherwise we print 1.

The first test is fairly easy. The given permutation can be decomposed into cycles. Let's replace each character with the index of its cycle (in both strings) and check if each substring of t is equal to s after this replacement (for example, using regular KMP algorithm). If some substring is not equal to s after the replacement, then it is definitely not an occurence.

The second test will help us distinguish the characters belonging to the same cycle. Let [c1,c2,…,ck] be some cycle in our permutation (elements are listed in the order they appear in the cycle, so pci=ci+1). We will replace each character with a complex number in such a way that the case when they match are easily distinguishable from the case when they don't match. One of the ways to do this is to replace ci with a complex number having magnitude equal to 1 and argument equal to 2πik (if this character belongs to s) or to π−2πik (if this character belongs to t).

How does this replacement help us checking the occurence? If we multiply the numbers for two matching characters, we get a complex number with argument equal to πk or to −πk, and its real part will be cosπk. In any other case, the real part of the resulting number will be strictly less than cosπk, and the difference will be at least 0.06. So, if we compute the value of ∑i=1|s|f(si)⋅f(tj+i−1) for the j-th substring of t (where f(c) is the number that replaced the character c), we can check if the real part of the result is close to the value we would get if we matched s with itself (and if the difference is big enough, at least one pair of characters didn't match). The only case when this method fails is if we try to match characters from different cycles of the permutation, that's why we needed the first test.

Overall, the first test can be done in O(|s|+|t|) using prefix function (or any other linear substring search algorithm), and the second test can be done in O((|s|+|t|)log(|s|+|t|)), if we compute the aforementioned values for each substring using FFT.

Educational Codeforces Round 84 Editorial

By awoo, history, 3 years ago, translation, In English1327A - Sum of Odd Integers

Idea: vovuh

Tutorial1327A - Sum of Odd IntegersFirst of all, notice that the sum of the first k odd integers is k2. If k2>n then the answer obviously "NO". And if n%2≠k%2 then the answer is "NO" also (% is modulo operation). Otherwise, the answer is always "YES" and it seems like this: [1,3,5,…,2(k−1)−1,rem], where rem=n−∑i=1k−1(2i−1). It is obviously greater than 2(k−1)−1 because k2≤n and it is obviously odd because the parity of n and k is the same.

Solution (vovuh)1327B - Princesses and Princes

Idea: BledDest

Tutorial1327B - Princesses and PrincesSimulate the process without adding the new entry. For this you can just maintain an array taken, i-th value of which is true if the i-th prince is married and false otherwise.

Now observe that there are two possible outcomes:

Every daughter is married — the answer is optimal.There is a daughter who isn't married. That means that there is a free prince as well. Marry them to each other because doing that won't affect any other marriages and add a new one to the answer.Overall complexity: O(n+m).

Solution (pikmike)1327C - Game with Chips

Idea: Neon

Tutorial1327C - Game with ChipsNote that 2nm is a fairly large number of operations. Therefore, we can first collect all the chips in one cell, and then go around the entire board.

Let's calculate the required number of operations.

First, let's collect all the chips in the (1,1) cell. To do this, let's do n−1 operations U so that all the chips are in the first row, then do m−1 operations L. After such operations, wherever the chip is initially located, it will end up in the (1,1) cell.

After that, we need to go around the entire board. Let's do it in such a way that the rows with odd numbers are be bypassed from left to right, and the even ones — from right to left. We also need n−1 operations D to move from one row to the next one.

In total, we got (n−1)+(m−1)+n∗(m−1)+(n−1)=nm+n+m−3 operations, which is completely suitable for us.

Solution (Ne0n25)1327D - Infinite Path

Idea: adedalic

Tutorial1327D - Infinite PathLet's look at the permutation as at a graph with n vertices and edges (i,pi). It's not hard to prove that the graph consists of several cycles (self-loops are also considered as cycles). So, the sequence i,p[i],p[p[i]],… is just a walking on the corresponding cycle.

Let's consider one cycle c1,c2,…,cm. In permutation p we have p[ci]=c(i+1)modm. But since p2=p×p or p2[i]=p[p[i]], so p2[ci]=c(i+2)modm and in general case, pk[ci]=c(i+k)modm.

Now, walking with step k we can note, that the initial cycle c split up on GCD(k,m) cycles of length mGCD(k,m). Looking at the definition of infinite path we can understand that all we need to do is to check that at least one of GCD(k,m) cycles have all vertices of the same color. We can check it in O(m) time for the cycle c and fixed k.

The final observation is next: for k1 and k2 such that GCD(k1,m)=GCD(k2,m) the produced cycles will have the same sets of vertices and differ only in the order of walking, so we can check only one representative for each GCD(k,m), i.e. we can take only such k which divide m.

We can handle each cycle of p separately. So, using the approximation that the number of divisors of n is O(n13), we get O(n43) time complexity.

Solution (adedalic)1327E - Count The Blocks

Idea: adedalic

Tutorial1327E - Count The BlocksPresume that we want to calculate the number of blocks of length len. Let's divide this blocks into two types:

blocks which first element is a first element of integer, or blocks which last element is a last element of integer (for example blocks 111 and 0 in integer 11173220);other blocks.At first let's calculate the number of blocks of first type. We can choose 2 positions of this block (at the start of end of the integer). Now we can choose 10 digit for this block. After that we can chose 9 digits of adjacent block (if these blocks contain the same digit then we length of blocks which we want calculate greater than len, so we have only 9 variations of digit in adjacent block). Finally, the can chose the remaining digit 10n−len−1 ways.

So, the total number of block of first type is 2⋅10⋅9⋅10n−len−1.

Now let's calculate the number of blocks of second type. We can choose n−len−1 positions of this block (all position except the start and end of integer). Now we can choose 10 digit for this block. After that we can chose 92 digits of adjacent block (9 for block to the left and 9 for block to the right). Finally, the can chose the remaining digit 10n−len−2 ways.

So, the total number of block of second type is (n−len−1)⋅10⋅92⋅10n−len−2.

That's almost all. We have one corner case. If len=n, then we number of blocks is always 10.

Solution (Roms)1327F - AND Segments

Idea: Neon

Tutorial1327F - AND SegmentsWe will solve the problem for each bit separately, and then multiply the results.

Obviously, if the position is covered by a segment with the value 1, then we have no choice, and we must put 1 there. For segments with the value 0, there must be at least one position that they cover and its value is 0.

So we can write the following dynamic programming: dpi — the number of arrays such that the last 0 was exactly at the position i, and all 0-segments to the left of it contain at least one zero.

It remains to determine which states j we can update from. The only restriction we have is that there should not be any segment (l,r) with the value 0, such that j<l and r<i. Since in this case, this segment will not contain any zero values. For each position i, we may precalculate the rightmost position fi where some segment ending before i begins, and while calculating dpi, we should sum up only the values starting from position fi. This can be done with prefix sums.

Solution (Ne0n25)1327G - Letters and Question Marks

Idea: BledDest

Tutorial1327G - Letters and Question MarksSuppose we want to calculate the value of some already fixed string (we should be able to do so at least to solve the test cases without question marks). How can we do it? We can use some substring searching algorithms to calculate F(S,ti), but a better solution is to build an Aho-Corasick automaton over the array [t1,tk], and then for each node calculate the sum of costs of all strings ending in that node (these are the strings represented by that node and the strings represented by other nodes reachable by suffix links). After that, process S by the automaton and calculate the sum of the aforementioned values over all states that were reached. Building an Aho-Corasick automaton can be done in O(∑i=1k|ti|), and processing the string S — in O(|S|).

Okay, what if we've got some question marks in our string? The first solution that comes to mind is to calculate dp[i][mask][c] — we processed i first positions in S, used a mask of characters for question marks, and the current state of the automaton is c; then dp[i][mask][c] denotes the maximum value of first i characters of S we could have got. But it's O(L|S|2KK), where L=∑i=1k|ti| and K is the size of the alphabet, which is too slow.

To speed it up, we can see that there are only 14 positions in our string where we actually choose something in our dynamic programming. All substrings not containing question marks can be skipped in O(1) as follows: for each substring of S bounded by two question marks (or bounded by one question mark and one of the ends of S) and each state of the automaton x, we may precalculate the resulting state of the automaton and the change to the value of the string, if we process this substring by the automaton with the initial state x. This precalculation is done in O(L|S|) overall, and using this, we may skip the states of dynamic programming such that i is not a position with a question mark, so our complexity becomes O(L2KK+L|S|).

A note about the model solution: it's a bit more complicated because we wanted to increase the constraints to |S|≤8⋅106, but then we decided that it would be too complicated to code, so the main function still contains some parts of the code that were used to improve its complexity. We will post a clearer version of the model solution soon.

Educational Codeforces Round 83 Editorial

By awoo, history, 3 years ago, translation, In English1312A - Two Regular Polygons

Idea: BledDest

Tutorial1312A - Two Regular PolygonsThe answer is "YES" if and only if n is divisible by m because if you number all vertices of the initial polygon from 0 to n−1 clockwise then you need to take every vertex divisible by nm (and this number obviously should be integer) and there is no other way to construct the other polygon.

Solution (vovuh)1312B - Bogosort

Idea: Roms

Tutorial1312B - BogosortLet's sort array a in non-ascending order (a1≥a2≥⋯≥an).

In this case for each pair of indexes i<j the condition j−aj≠i−ai holds.

Solution (Roms)1312C - Adding Powers

Idea: adedalic

Tutorial1312C - Adding PowersThis is the solution that doesn't involve masks. Let's reverse the process and try to get all zeroes from the array a: since all ai≤1016 we can start from maximum ks≤1016.

The key idea: since ks>∑s−1x=0kx then there should be no more than one position pos such that apos≥ks and we should decrease it by ks. Now we can decrease s by 1 and repeat the same process.

If at any step there are at least two apos≥ks or as result, we won't get array filled with 0 then there is no way to build the array a.

Solution 1 (adedalic)Solution 2 (adedalic)1312D - Count the Arrays

Idea: BledDest

Tutorial1312D - Count the ArraysFirst of all, there will be exactly n−1 distinct elements in our array. Let's choose them, there are (mn−1) ways to do that.

After that, there should be exactly one element that appears twice. There are n−1 elements to choose from, but are all of them eligible? If we duplicate the maximum element, there will be no way to meet the fourth condition. So we should multiply the current answer by n−2, not n−1.

And finally, some elements will appear earlier than the maximum in our array, and some — later. The duplicated element will appear on both sides, but all other elements should appear either to the left or to the right, so there are 2n−3 ways to choose their positions.

Thus the answer is (mn−1)(n−2)2n−3. Note that you have to precompute all factorials and use their inverse elements to calculate (mn−1).

Note that there is a tricky case when n=2: some binpow implementations go into infinite loop trying to compute 2−1, so you may have to handle it specifically.

Solution (BledDest)1312E - Array Shrinking

Idea: MikeMirzayanov

Tutorial1312E - Array ShrinkingLet's look at the answer: by construction, each element in the final answer was the result of replace series of elements on the corresponding segment. So all we need to find is the minimal (by size) partition of the array a on segments where each segment can be transformed in one element by series of replaces.

We can calculate it using standard prefix dynamic programming, or dp2[len] is the size of such minimal partition of a prefix of length len. The transitions are standard: let's check all segments [len,nxt) and if it can be replaced by one element let's relax dp2[nxt].

Now we need to check for all segments of a — can it be replaced by one element. Let's calculate another dp[l][r] using the following fact: if there is a way to replace all segment as one element so the segment either has the length 1 or it can be divided into two parts where the prefix can be replaced by one element, the suffix also can be replaced by one element and these elements are equal. It's exactly the transitions we need to check to calculate dp[l][r].

The resulting complexity is O(n3).

Solution (adedalic)1312F - Attack on Red Kingdom

Idea: BledDest

Tutorial1312F - Attack on Red KingdomThis problem seems like a version of Nim with some forbidden moves, so let's try to apply Sprague-Grundy theory to it.

First of all, we may treat each castle as a separate game, compute its Grundy value, and then XOR them to determine who is the winner of the game. When analyzing the state of a castle, we have to know two things: the number of remaining soldiers in it and the type of the last attack performed on it. So, the state of the game can be treated as a pair.

We can compute Grundy values for each state in a straightforward way, but the constraints are too large to do it. Instead, we should try to search for a period: five consecutive rows (by row we mean a vector of Grundy values for the same number of remaining soldiers, but different types of last attacks) of Grundy values determine all of the values after them, so as soon as we get the same five rows of Grundy values that we already met, we can determine the period.

There are 15 values stored in these five rows, so the period can be up to 415 — but that's a really generous upper bound. Some intuition can help us to prove something like 105 or 106 as an upper bound, but it is better to check all cases with brute force and find out that the period is at most 36.

After we've found the period of Grundy values, it's easy to get them in O(1) for any castle. To count the number of winning moves for the first player, we can compute the XOR-sum of all castles, and for each castle check what happens if we make some type of attack on it: if the XOR-sum becomes 0, then this move is winning.

Solution (BledDest)1312G - Autocompletion

Idea: adedalic and BledDest

Tutorial1312G - AutocompletionFirst of all, the information given in the input is the structure of a trie built on S and some other strings — so we can store this information in the same way as we store a trie.

Okay, now let's calculate the number of seconds required to type each string with dynamic programming: let dpi be the number of seconds required to arrive to the i-th vertex of the trie. For regular vertices, dpi=dppi+1, where pi is the parent of vertex i; for vertices corresponding to strings from S, dp values should be updated with the time required to autocomplete some of the parents to the current vertex.

To do these updates, let's calculate the answers for all strings in lexicographical order. We will run DFS on the trie and maintain a segment tree on the path from the root to the current vertex. In the segment tree, we will store the values of dpi+costi, where costi is the number of seconds required to autocomplete from i to the current vertex. Obviously, if we are currently in a vertex representing a word from S, then we have to find the minimum in this segment tree — and that will be the cost to get to current vertex using autocompletion.

How to maintain dpi+costi? Recall that we are running DFS on trie in lexicographical order. When we want to compute the answer for the first string, the value of costi for all vertices is 1, since our string will be the first in all autocompletion lists. And here's a trick to maintain these values for other strings: whenever we compute the answer for some string, add 1 on the whole tree. For vertices that are ancestors of both current string and some next string, this +1 will stay and increase the cost to autocomplete the next string accordingly; but for vertices which are not on the path to some next string, the values of dpi+costi will be already deleted from the segment tree and replaced by new values — so this addition does not affect them.

Overall, this works in O(nlogn), but it can be written in O(n) with a vector instead of a segment tree (since all additions and minimum queries affect the whole structure).

Educational Codeforces Round 82 Editorial

By awoo, history, 3 years ago, translation, In English1303A - Erasing Zeroes

Idea: Roms

Tutorial1303A - Erasing ZeroesLet's find the first and the last position of 1-characters (denote them as l and r respectively). Since the can't delete 1-characters, all 1-characters between sl and sr will remain. So, we have to delete all 0-characters between sl and sr.

Solution (Roms)1303B - National Project

Idea: adedalic

Tutorial1303B - National ProjectThere are two conditions that should be met according to the statement. On the one hand, we should repair the whole highway, so we must spend at least n days to do it. On the other hand, at least half of it should have high-quality pavement or at least needG=⌈n2⌉ units should be laid at good days.

How to calculate the minimum number of days (name it as totalG) for the second condition to meet? Note that the first totalG days can be represented as several (maybe zero) blocks of g+b days, where exactly g days in each block are good and some remaining days 1≤rem≤g. The rem>0 because totalG will not be minimum otherwise.

There are plenty of ways to calculate totalG. One of them is the following: Firstly, let's calculate the number of g+b cycles we need: totatG=⌊needGg⌋⋅(g+b). Now, if needGmodg>0 we just add it (since it's exactly the rem) or totalG=totalG+(needGmodg). But if needGmodg=0 we added to totalG last b block and should subtract it or totalG=totalG−b.

The answer is max(n,totalG).

Solution (adedalic)1303C - Perfect Keyboard

Idea: Roms

Tutorial1303C - Perfect KeyboardThe problem can be solved using a greedy algorithm. We will maintain the current layout of the keyboard with letters that have already been encountered in the string, and the current position on the layout.

If the next letter of the string is already on the layout, it must be adjacent to the current one, otherwise there is no answer.

If there was no such letter yet, we can add it to the adjacent free position, if both of them is occupied, then there is no answer.

At the end, you have to add letters that were not in the string s.

Solution (Ne0n25)1303D - Fill The Bag

Idea: Roms

Tutorial1303D - Fill The BagIf ∑i=1nai≥n, then the answer is YES, because the just can divide all boxes to size 1 and then fill the bag. Otherwise the answer is NO.

If the answer is YES, let's calculate the minimum number of divisions. Let's consider all boxes from small to large. Presume that now we consider boxes of size 2i. Then there are three cases:

if in binary representation of n the i-th bit is equal to 0, then we don't need boxes of size 2i and we can merge it into boxes of size 2i+1;if in binary representation of n the i-th bit is equal to 1 and we have at most one box of size 2i, then we have to put it box in the bag and then merge the remaining boxes of size 2i into boxes of size 2i+1;if in binary representation of n the i-th bit is equal to 1 and we have not boxes of size 2i, then we have to divide the large box into box of size 2i (let's presume that it's box of size 2x). After that we just continue this algorithm with box of size 2x.Solution (Roms)1303E - Erase Subsequences

Idea: adedalic

Tutorial1303E - Erase SubsequencesLet's look at string t. Since we should get it using no more than two subsequences, then t=a+b where a is the first subsequence and b is the second one. In the general case, a can be empty. Let iterate all possible lengths of a (0≤|a|<|s|), so we can check the existence of solution for each pair a and b.

If we'd fix a and b we need to check the following: is it true that s contains a and b as subsequences and these subsequences don't intersect. Initially, we can invent the following dp: let dp[lens][lena][lenb] be 1 if the prefix of s of length lens contains prefixes of a and b of length lena and lenb as non-intersecting subsequences. The transitions are straingforward: if dp[lens][lena][lenb]=1 we can either skip s[lens] (0-indexed) and update dp[lens+1][lena][lenb]. If s[lens]=a[lena] (0-indexed) then we can update dp[lens+1][lena+1][lenb] and if s[lens]=b[lenb] then we can update dp[lens+1][lena][lenb+1]. But this dp has complexity O(|s|3) in general case.

But we can transform it in the next way: instead of the boolean value, we will make lens as a value of dp. In other words, we will maintain dp[lena][lenb] as minimal appropriate prefix lens. But the problem now is to define transitions.

Let's note the next fact: suppose we have lens=dp[lena][lenb] and we'd like to add next character to a which is equal to a[lena]. The idea is next: it's always optimal to choose the first occurrence of a[lena] in s[lens…|s|). It can be proved by contradiction: if the first occurrence is free then it's better to take it, or if the first occurrence will be occupied by b then this will be handled by the other state dp[lena][len′b] with len′b>lenb.

The logic for increasing lenb is analogical. In result, we need to precalculate array nxt[pos][c] with the next occurrence of character c in suffix pos of s one time before choosing a and b and use it each time to acquire O(|s|2) complexity.

The total complexity if O(|s|3) for each test case.

Solution (adedalic)1303F - Number of Components

Idea: Neon

Tutorial1303F - Number of ComponentsNote that because of the low constraints on the number of colors, the problem can be solved independently for each color. Now you can divide the queries into two types: add a cell to the field and delete it. You have to maintain the number of components formed by added cells. Cell deletions will occur after all additions because of the condition ci≤ci+1.

The first part of the solution will be to calculate the number of components while adding new cells. This is a standard problem that can be solved using the DSU.

After that, we should note that if we consider the process of removing cells from the end, this process is similar to the process of adding. Therefore, we have to process delete requests from the end in the same way as add requests, only their contribution to the number of components will be opposite in sign.

Solution (Ne0n25)1303G - Sum of Prefix Sums

Idea: Neon

Tutorial1303G - Sum of Prefix SumsLet's use centroid decomposition to solve the problem. We need to process all the paths going through each centroid somehow.

Consider a path from vertex u to vertex v going through vertex c, which is an ancestor of both u and v in the centroid decomposition tree. Suppose the sequence of numbers on path from u to c (including both these vertices) is [a1,a2,…,ak], and the sequence of numbers on path from c to v (including v, but excluding c) is [b1,b2,…,bm]. Let suma=∑i=1kai, psuma=∑i=1k(k−i+1)ai, and psumb=∑i=1m(m−i+1)bi. We can show that the sum of prefix sums of [a1,a2,…,ak,b1,b2,…,bm] is equal to psuma+psumb+suma⋅m.

Now, suppose we fix the second part of the path (psumb and m are fixed), and we want to find the best first part for this second part. Each possible first part is represented by a linear function, and our goal is to find the maximum over all these linear functions in the point m, and add psumb to this maximum. This can be done with the help of convex hull or Li Chao tree.

The most difficult part of implementation is how to process each centroid's subtree. It's easy to obtain all "first parts" and "second parts" of paths going through the centroid, but pairing them up can be complicated — for each second part, we have to build a convex hull or Li Chao tree on all first parts going to this centroid, excluding those which go through the same child of the centroid as the "second part" we are considering. One of the best ways to implement this is the following. Suppose our centroid has m children, fpi is the set of "first parts" going from the i-th child of the centroid, and spi is the set of "second parts" going to the i-th child. We will create a new data structure (initially empty), process all second parts from sp1, add all first parts from fp1, process all second parts from sp2, add all first parts from fp2, and so on. After that, we will clear our data structure, process all second parts from spm, add all first parts from fpm, process all second parts from spm−1, add all first parts from fpm−1, and so on, until we add all first parts from fp1. That way we will consider all possible first parts for each second part we are trying to use.

Educational Codeforces Round 81 Editorial

By awoo, history, 3 years ago, translation, In English1295A - Display The Number

Idea: adedalic

Tutorial1295A - Display The NumberFirst of all, we don't need to use any digits other than 1 and 7. If we use any other digit, it consists of 4 or more segments, so it can be replaced by two 1's and the number will become greater. For the same reason we don't need to use more than one 7: if we have two, we can replace them with three 1's.

Obviously, it is always optimal to place 7 before 1. So our number is either a sequence of 1's, or a 7 and a sequence of 1's. We should use 7 only if n is odd, because if n is even, it will decrease the number of digits in the result.

Solution (BledDest)1295B - Infinite Prefixes

Idea: Roms

Tutorial1295B - Infinite PrefixesLet's denote a prefix of length i as pref(i). We can note that each pref(i)=k⋅pref(n)+pref(imodn) where k=⌊in⌋ and + is a concatenation. Then balance bal(i) of prefix of length i is equal to k⋅bal(n)+bal(imodn).

Now there two cases: bal(n) is equal to 0 or not. If bal(n)=0 then if exist such j (0≤j<n) that bal(j)=x then for each k≥0 bal(j+kn)=x and answer is −1.

Otherwise, for each such j there will no more than one possible k: since there are zero or one solution to the equation bal(j)+k⋅bal(n)=x. The solution exists if and only if x−bal(j)≡0modbal(n) and k=x−bal(j)bal(n)≥0. So, just precalc bal(n) and for each 0≤j<n check the equation.

Solution (adedalic)1295C - Obtain The String

Idea: Roms

Tutorial1295C - Obtain The StringThe answer is −1 when in string t there is a character that is not in string s.

Otherwise let's precalculate the following array nxti,j = minimum index x from i to |s| such that sx=j (if there is no such index then nxti,j=inf).

Now we can solve this problem by simple greed. Presume that now z=t0t1…ti−1, and last taken symbol in s is spos. Then there are two options:

if nxtpos,i≠inf, then i=i+1, pos=nxtpos+1,i;if nxtpos,i=inf, then pos=0 and ans=ans+1 (ans is equal to 0 initially);Solution (Roms)1295D - Same GCDs

Idea: adedalic

Tutorial1295D - Same GCDsThe Euclidean algorithm is based on the next fact: if a≥b then gcd(a,b)=gcd(a−b,b). So, if (a+x)≥m then gcd(a+x,m)=gcd(a+x−m,m). So we can declare that we are looking at m different integers x′=(a+x)modm with 0≤x′<m, so all x′ forms a segment [0,m−1]. So, we need to find the number of x′ (0≤x′<m) such that gcd(x′,m)=gcd(a,m).

Let's denote g=gcd(a,m), then a=ga′ and m=gm′. So, gcd(a,m)=gcd(ga′,gm′)=g⋅gcd(a′,m′)=g or gcd(a′,m′)=1. Since gcd(x′,m)=gcd(a,m)=g so we also can represent x′=x′′g and, therefore gcd(x′′,m′)=1.

Since 0≤x′<m, then 0≤x′′<m′ or we need to calaculate the number of x′′ (0≤x′′<m′) such that gcd(x′′,m′)=1. Since gcd(0,m′)=m′>1 so we can consider x′′∈[1,m′−1] and this is the definition of Euler's totient function φ(m′) which is the answer.

Euler's totient function φ(m′) can be calculated using factorization of m′=∏i=1lpaii. Then φ(m′)=m′∏i=1l(1−1pi).

Solution (adedalic)1295E - Permutation Separation

Idea: adedalic

Tutorial1295E - Permutation Separation"All elements in the left set smaller than all elements in the right set" means that there is such value val that all elements from the first set less than val and all elements from the second set are more or equal to val. So let's make a sweep line on val from 1 to n+1 while trying to maintain all answers for each prefix pos.

Let's maintain for each pos the total cost t[pos] to make sets "good" if we split the permutation p on sets [p1,…,ppos] and [ppos+1,…,pn] in such way that after transformations all elements in the first set less than val. It's easy to see that the total cost is equal to sum of weights ai where i≤pos and pi≥val and ai where i>pos and pi<val.

So what will happen if we increase val by 1? Let's define the position of pk=val as k. For each pos≥k we don't need to move pk to the second set anymore, so we should make t[pos]−=ak. On the other hand, for each pos<k we need to move pk from the second set to the first one now, so we should make t[pos]+=ak.

The answer will be equal to the min1≤pos<n(t[pos]). It means that we should handle two operations: add some value on the segment and ask minimum on the segment. So we can store all t[pos] in pretty standart Segment Tree with "add on segment" and "minimum on segment" while iterating over val. So the total complexity is O(nlogn).

Solution (adedalic)1295F - Good Contest

Idea: Roms

Tutorial1295F - Good ContestModel solution (slow, complicated and not cool):

The naive solution is dynamic programming: let dpi,x be the probability that the first i problems don't have any inversions, and the i-th one got x accepted solutions. Let's somehow speed it up. For convenience, I will modify the variable denoting the maximum number of accepted solutions for each problem: Li=li, Ri=ri+1; and I will also reverse the problem order, so that we don't want the number of solutions to decrease from problem to problem.

We know that dpi,x=1Ri−Li∑j=0xdpi−1,j, if x∈[Li,Ri), and dpi,x=0 otherwise. Let's divide the whole segment between 0 and 998244351 into O(n) segments with the values of Li and Ri and analyse the behavior of dp values on each such segment.

Let fi(x)=dpi,x. If we consider the behavior of fi(x) on some segment we got, we can prove by induction that it is a polynomial of degree not exceeding i.

All that is left is to carefully calculate and maintain these polynomials on segments. The main thing we will use to calculate the polynomials is interpolation. To transition from fi to fi+1, we will consider each segment separately, calculate the first several values of fi+1 on each segment (we need to calculate the sum ∑x=LRP(x) fast, if P(x) is a polynomial, this can also be done with interpolation), and then interpolate it on the whole segment.

This is actually slow (we have to interpolate at least O(n2) polynomials) and not easy to write. Let's consider a better solution.

Participants' solution (much faster and easier to code):

We will use combinatoric approach: instead of calculating probabilities, we will count all the non-descending sequences (a1,a2,…,an) such that i∈[Li,Ri), and divide it by the number of all sequences without the non-descending condition (that is just ∏ni=1Ri−Li).

Let's again divide [0,998244353] into O(n) segments using the points Li, Ri, and enumerate these segments from left to right. If there are two neighboring values ai and ai+1, they either belong to the same segment, or the segment ai+1 belongs to is to the right of the segment ai belongs to.

We could try to write the following dynamic programming solution: cnti,j is the number of non-descending prefixes of the sequence such that there are i elements in the prefix, and the last one belongs to segment j. It's easy to model transitions from cnti,j to cnti+1,k where k>j, but we don't know how to model the transition to cnti+1,j.

Let's get rid of them altogether! We will introduce an additional constraint in our dynamic programming: cnti,j is the number of prefixes of the sequence of length i such that all elements on prefix belong to one of the first j segments, but next element should not belong to it. The transitions in this dynamic programming are different: we iterate on the number of elements k belonging to the next segment and transition into cnti+k,j+1 (if possible). Calculating the number of ways to take k elements from an interval [L,R) in sorted order can be reduced to calculating the number of ways to compose k as the sum of R−L non-negative summands (order matters). We should be able to calculate binomial coefficients with fairly large n and not so large k, but that's not really hard if we use the formula (nk)=(nk−1)⋅n−k+1k.

Educational Codeforces Round 80 Editorial

By awoo, history, 3 years ago, translation, In English1288A - Deadline

Idea: adedalic

Tutorial1288A - DeadlineAt first, let's note that if x is integer and x and y are non-negative then x+⌈y⌉=⌈x+y⌉. So, instead of looking at x+⌈dx+1⌉ we can consider ⌈x+dx+1⌉.

It's easier since the function x+dx+1=(x+1)+d(x+1)−1 is more common function and it can be proven that it's concave upward. It means that this function has a unique minimum and, moreover, we can calculate it: f(x)=x+dx+1 has minimum value in x0=d−−√−1 and f(x0)=2d−−√−1.

Since the ceiling function is monotonically increasing so we can assume that ⌈f(x)⌉≤⌈f(x+1)⌉ for all x≥d−−√.

So we can just iterate x from 0 to ⌊d−−√⌋ and check the unequation ⌈f(x)⌉≤n. The total complexity is equal to O(Td−−√).

There is a simple optimization: because of the monotone ceiling we can prove that we need to check only ⌊d−−√−1⌋ and ⌈d−−√−1⌉.

Solution (adedalic)1288B - Yet Another Meme Problem

Idea: Roms

Tutorial1288B - Yet Another Meme ProblemLet's perform some conversions:

a⋅b+a+b=conc(a,b)a⋅b+a+b=a⋅10|b|+b, where |b| is the length of decimal representation of b.

a⋅b+a=a⋅10|b|b+1=10|b|Thus, b always look like 99…99. So, the answer is a∗(|b+1|−1).

Solution (Roms)1288C - Two Arrays

Idea: BledDest

Tutorial1288C - Two ArraysLet's consider the following sequence:

a1,a2,…,am,bm,bm−1,…,b1.

It's sequence of length 2m sorted in non-descending order, where each element of each sequence is an integer between 1 and n.

We can find the number of such sequences by simple combinatorics — it's combination with repetitions. So the answer is (n+2m−12m)=(n+2m−1)!(2m)!(n−1)!.

Solution (Roms)1288D - Minimax Problem

Idea: BledDest

Tutorial1288D - Minimax ProblemWe will use binary search to solve the problem. Suppose we want to know if the answer is not less than x.

Each array can be represented by a m-bit mask, where the i-th bit is 1 if the i-th element of the array is not less than x, or 0 if the i-th element is less than x. If we want to verify that the answer is not less than x, we have to choose two arrays such that bitwise OR of their masks is 2m−1.

Checking all pairs of arrays is too slow. Instead, we can treat the arrays represented by the same masks as equal — so we will have no more than 2m distinct arrays, and we can iterate over 4m pairs. Overall, the solution works in O(logA(4m+nm)).

Solution (BledDest)1288E - Messenger Simulator

Idea: Neon

Tutorial1288E - Messenger SimulatorSo I have two slightly different approaches to the problem. There is a straightforward (no brain) one and a bit smarter one.

The minimum place is the same in both solutions. For the i-th friend it's just i if he never moves and 1 otherwise.

Obtaining the maximum place is trickier.

For the first approach, take a look what happens with some friend i after he gets moved to the first position. Or what's more useful — what happens after he gets moved to the first position and before he gets moved again afterwards (or the queries end). Notice how every other friend is to the right of him initially. Thus, if anyone sends a message, then the position of the friend i increases by one. However, if that friend moves again, nothing changes. That should remind of a well-known problem already. You are just required to count the number of distinct values on some segments. The constraints allow you to do whatever you want: segtree with vectors in nodes, Mo, persistent segtree (I hope ML is not too tight for that).

Unfortunately, for each friend we have missed the part before his first move. In that case for each i you need to count the number of distinct values greater than i, as only friends with greater index will matter. Luckily, you can do it in a single BIT. Let j-th its value be set to zero if the friend j hasn't sent messages and one otherwise. Let's process messages from left to right. If the friend sends a message for the first time, then update the BIT with 1 in his index and update his answer with the suffix sum of values greater than his index.

Finally, there are also friends, who haven't sent messages at all. As we have built the BIT already, the only thing left is to iterate over these friends and update the answers for them with a suffix sum.

Overall complexity: O((n+m)log2m)/O((n+m)m−−√)/O((n+m)logm). The attached solutions are O((n+m)m−−√) and O((n+m)log2m).

The second solution requires a small observation to be made. Notice that for each friend you can only check his position right before his moves and at the end of the messages. That works because the position can decrease only by his move, so it's either increases or stays the same between the moves.

So let's learn to simulate the process quickly. The process we are given requires us to move someone to the first position and then shift some friends. Let's not shift! And let's also reverse the list, it's more convenient to append instead of prepending. So initially the list is n,n−1,…,1 and the message moves a friend to the end of the list.

Allocate n+m positions in a BIT, for example. Initially the first n positions are taken, the rest m are free (mark them with ones and zeroes, respectively). For each friend his position in this BIT is known (initially they are posi=n−i+1, because we reversed the list). On the j-th message sent count the number of taken positions to the right of posa[j], set 0 in posa[j], update posa[j]:=j+n and set 1 in posa[j].

And don't forget to update each friend's maximum after all the messages are sent, that is the number of taken positions to the right of his final one as well.

Overall complexity O((n+m)log(n+m)).

Solution 1 (pikmike)Solution 2 (pikmike)Solution 3 (pikmike)1288F - Red-Blue Graph

Idea: BledDest

Tutorial1288F - Red-Blue GraphA lot of things in this problem may tell us that we should try thinking about a flow solution. Okay, let's try to model the problem as a flow network.

First of all, our network will consist of vertices and edges of the original graph. We somehow have to denote "red", "blue" and "colorless" edges; we will do it as follows: each edge of the original graph corresponds to a bidirectional edge with capacity 1 in the network; if the flow goes from the left part to the right part along the edge, it is red; if the flow goes from right to left, it is a blue edge; and if there is no flow along the edge, it is colorless.

Okay, we need to impose some constraints on the vertices. Consider some vertex v from the left part. Each red edge incident to it transfers one unit of flow from it to some other vertex, and each blue edge incident to it does the opposite. So, the difference between the number of blue and red edges incident to v is the amount of excess flow that has to be transfered somewhere else. If v is colorless, there are no constraints on the colors of edges, so this amount of excess flow does not matter — to model it, we can add a directed edge from source to v with infinite capacity, and a directed edge from v to sink with infinite capacity. What if v is red? At least one unit of flow should be transfered to it; so we add a directed edge from the source to v with infinite capacity such that there should be at least one unit of flow along it. And if v is blue, we need to transfer at least one unit of excess flow from it — so we add a directed edge from v to the sink with infinite capacity such that there is at least one unit of flow along it. The colors of the vertices in the right part can be modeled symmetrically.

How to deal with edges such that there should be some flow along them? You may use classic "flows with demands" approach from here: https://cp-algorithms.com/graph/flow_with_demands.html. Or you can model it with the help of the costs: if the flow along the edge should be between l and r, we can add two edges: one with capacity l and cost k (where k is a negative number with sufficiently large absolute value, for example, −109), and another with capacity r−l and cost 0.

Okay, now we know how to find at least one painting. How about finding the cheapest painting that meets all the constraints? One of the simplest ways to do it is to impose costs on the edges of the original graph: we can treat each edge of the original graph as a pair of directed edges, one going from left to right with capacity 1 and cost r, and another going from right to left with capacity 1 and cost b.

Educational Codeforces Round 79 Editorial

By awoo, history, 3 years ago, translation, In English1279A - New Year Garland

Idea: BledDest

Tutorial1279A - New Year GarlandLet r≤g≤b (if it is not the case, do some swaps). If b>r+g+1, then at least two blue lamps will be adjacent — so there is no solution.

Otherwise the answer can be easily constucted. Place all blue lamps in a row. Then place red lamps: one between the first and the second blue lamp, one between the second and the third, and so on. Then place all green lamps: one between the (b−1)-th blue lamp and the b-th, one between the blue lamps with numbers (b−2) and (b−1), and so on. Since r+g≥b−1, there is at least one non-blue lamp between each pair of blue lamps. If g=b, we didn't place all green lamps, we can place the remaining one before all other lamps (the same with r=b).

So, if we swap l, g and b in such a way that r≤g≤b, we only have to check that b≤r+g+1.

Solution (Roms)1279B - Verse For Santa

Idea: Roms

Tutorial1279B - Verse For SantaIf ∑i=1nai≤s then answer is 0.

Otherwise let's find we minimum index x such that ∑i=1xai>s. It's useless to skip a part i>x, because Vasya just has not time to recite previous part (it's change nothing). So he has to skip a part i≤x. And among such parts it's beneficial to skip part with maximum value of ai.

Solution (Roms)1279C - Stack of Presents

Idea: Roms

Tutorial1279C - Stack of PresentsAt first let's precalculate array pos such that posai=i.

Now presume that we have to calculate answer for bi. Then there are two cases (let's denote lst=max1≤j<iposbj, initially lst=−1):

if posbi>lst then we have to spend 1+2⋅(posbi−(i−1)) seconds on it (1 second on the gift bi, posbi−(i−1) seconds on removing gifts above and posbi−(i−1) seconds on pushing these gifts);if posbi<lst then we can reorder gifts by previous actions such that gift bi be on the top of stack. So we spend only 1 second on it.Solution (Roms)1279D - Santa's Bot

Idea: BledDest

Tutorial1279D - Santa's BotFirst of all, how to deal with the fractions modulo 998244353? According to Fermat's little theorem, xϕ(m)≡1(modm) if x is coprime with m. So, the inverse element for the denominator y is yϕ(998244353)−1=y998244351, taken modulo 998244353.

A cool property of fractions taken modulo 998244353 (or any other number such that denominator is coprime with it) is that if we want to add two fractions together and calculate the result modulo some number, we can convert these fractions beforehand and then just add them as integer numbers. The same works with subtracting, multiplying, dividing and exponentiating fractions.

Okay, now for the solution itself. We know that there are at most 106 possible pairs of (x,y); we can iterate on these pairs, calculate the probability that the fixed pair is included in the robot's decision (that probability is 1x⋅kx), and calculate the probability that (x,y) extends to a valid triple (it is equal to cntyz, where cnty is the number of kids who want item y). Multiplying these two probabilities, we get the probability that (x,y) is chosen and produces a valid decision (since these events are independent), and we sum up these values over all possible pairs (x,y).

Solution (Ne0n25)1279E - New Year Permutations

Idea: Neon

Tutorial1279E - New Year PermutationsLet's calculate cyclen — the number of permutations of length n, which have a maximum at the position 1 and consist of exactly one cycle. Each good permutation can be divided into such blocks, so we'll need this value later.

It is easy to notice that cyclen=(n−2)!.

Let's calculate the following dynamic programming dpi — the number of good permutations consisting of elements [i,n].

To calculate dpi, let's iterate over j — the maximum element of the first block, it determines the length of this block (j−i+1).

dpi=∑nj=i(dpj+1⋅cyclej−i−1).

Now let's use the standard method of lexicographic recovery.

We will iterate over which element to put next, it immediately determines the size of the new block and all the elements in it. If the number of permutations starting with such block is at least k, then you need to restore this block entirely and reduce the task to the one without this block. Otherwise, you need to subtract the number of permutations starting on such block from k and proceed to the next option for the block.

We will also use lexicographic recovery to restore the block. You must carefully maintain the current block so that it consists of exactly one cycle. To do this, you can use DSU or explicitly check for a cycle.

Solution (Ne0n25)1279F - New Year and Handle Change

Idea: vovuh

Tutorial1279F - Новый год и смена хендлаLet's simplify the problem a bit: we need either to minimize the number of lowercase letters or to minimize the number of uppercase letters. Both variants can be described by the following model: we have a binary array a where a[i]=0 if s[i] is in the correct case and a[i]=1 otherwise. We can do at most k operations "set 0 on the segment [i,i+l−1]" and we'd like to minimize the total sum of a.

At first, let's start with a solution which is pretty slow but correct. Let dp[len][c] be the minimum sum of the prefix a[0]…a[len−1] such that c operations was already applied on it.

In order to calculate this dp somehow efficiently, we need to understand that it's optimal to avoid intersections of segments of applied operations so we can further specify the state of dp with the following: all c applied operations have their right borders ≤len−1. It's easy to specify the transitions: we either apply set operation on [len,len+l−1] and relax dp[len+l][c+1] with dp[len][c] or not and relax d[len+1][c] with dp[len][c]+a[len].

It still O(nk) so we'd like to optimize it more — and we can do it using the "lambda-optimization" i. e. "aliens trick". Here we will try to describe what "aliens trick" is and the "features" of its application on the discrete calculations.

In general, "aliens trick" allows you to get rid of the restriction on the total number of operations applied to the array (sometimes it's the number of segments in the partition of the array) by replacing it with the binary search of the value λ connected to it. The λ is the cost of using the operation (or the cost to use one more segment in the partition). In other words, we can use as many operations as we want but we need to pay for each of them. Often, we can calculate the answer without the restriction faster.

The main restriction of the using this dp-optimization is the following (in case of the discrete model): consider the answer ans(c) for the fixed c, or dp[n][c]. If we look at the function ans(c) it should be "somewhat convex", i.e ans(c−1)−ans(c)≥ans(c)−ans(c+1) (or, sometimes, ans(c)−ans(c−1)≥ans(c+1)−ans(c)) for all possible c.

Let's look at the answers of the modified version of the problem (with cost λ for each used operation) as function res(λ,c). It's easy to prove that res(λ,c)=ans(c)+λc and it's also "somewhat convex" for a fixed λ (as a sum of convex functions). But, more important, it has the following property: let cλ be the position where the res(λ,c) is the minimum possible. It can be proven (from the convex property) that cλ≥cλ+1.

This property leads to the solution: binary search λ while keeping track of the cλ, i. e. find the minimum λ that cλ≤k. But there are several problems related to the discrete origin of the problem:

The cλ is not unique. In general case, there is a segment [clλ,crλ] where the minimum res(λ,c) can be achieved. But there is still a property that clλ≥clλ+1 and crλ≥crλ+1. So we need to ensure that we will always find either minimum such cλ or maximum such cλ.The second problem comes from the first one. There are situations when cλ−cλ+eps>1. It creates a problem in the next situation: suppose the binary search finished with λopt; the cλopt−1>k and cλopt<k. But we need to use exactly k operations, what to do?Using float values will not help, so we don't need them (so we'll use usual integer bs). Suppose we minimized the cλopt then we can show that k∈[clλopt,crλopt] or, in other words, res(λopt,k)=res(λopt,cλopt). So we can claim that we calculated the value not only for cλopt but also for k.

In the end, if we can efficiently calculate cλ and res(λ,cλ) for the fixed λ, then we can binary search λopt, extract res(λopt,cλopt) and claim that the dp[n][k]=res(λopt,cλopt)−λoptk.

Finally, let's discuss, how to calculate cλ and res(λ,cλ) for a fixed λ. Since res(λ,cλ) is just a minimum cost and the cλ is the minimum number of operations with such cost. We can calculate it by simplifying our starting dp. (Remember, the cost is calculated in a next way: for each remaining 1 in a we pay 1 and for each used operation we pay λ).

Let d[len]={costlen,cntlen}, where costlen is minimum cost on the prefix of length len and cntlen is minimum number of operations costlen can be achieved. Then the transitions are almost the same: we either let a[len] be and relax d[pos+1] with {costlen+a[len],cntlen} or start new operation and relax d[pos+len] with {costlen+λ,cntlen+1}. The result is pair d[n].

Some additional information: we should carefully choose the borders of the binary search: we should choose the left border so it's optimal to use operation whenever we can (usually, 0 or −1). And we should choose the right border so it's never optimal to use even one operation (usually more than the maximum possible answer).

The total complexity is O(nlogn).

P. S.: We don't have the strict proof that the ans(c) is convex, but we have faith and stress. We'd appreciate it if someone would share the proof in the comment section.

Educational Codeforces Round 78 Editorial

By awoo, history, 3 years ago, translation, In English1278A - Shuffle Hashing

Idea: Neon

Tutorial1278A - Shuffle HashingThe general idea of the solution is to check that string h contains some substring which is a permutation of p. The constraints were so low you could do it with any algorithm, even O(n3logn) per test case could pass.

The most straightforward way was to iterate over the substring of h, sort it and check if it's equal to p sorted. That's O(n3logn).

Next you could notice than only substrings of length |p| matter and shave another n off the complexity to get O(n2logn).

After that you might remember that the size of the alphabet is pretty low. And one string is a permutation of another one if the amounts of letters 'a', letters 'b' and so on in them are equal. So you can precalculate array cntp, where cntp[i] is equal to the amount of the i-th letter of the alphabet in p. Calculating this array for O(n) substrings will be O(n) each, so that makes it O(n2).

Then notice how easy it is to recalculate the letter counts going from some substring [i;i+|p|−1] to [i+1;i+|p|]. Just subtract 1 from the amount of the i-th letter and add 1 to the amount of the (i+|p|)-th letter. Comparing two array every time will still lead to O(n⋅|AL|), though.

The final optimization is to maintain the boolean array eq such that eqi means that cntp[i] is equal to the current value of cnt of the substring. You are updating just two values of cnt on each step, thus only two values of eq might change. You want all the |AL| values to be true, so keep the number of values true in that array and say "YES" if that number is equal to |AL|. That finally makes the solution O(n) per test case.

Solution 1 (pikmike)Solution 2 (pikmike)1278B - A and B

Idea: Roms

Tutorial1278B - A and BAssume that a>b. Let's denote the minimum number of operations required to make a and b equal as x.

There are two restrictions on x:

At first, x(x+1)2 ≥a−b, because if x(x+1)2 <a−b then a will be greater than b (after applying all operations);Secondly, integers x(x+1)2  and a−b must have the same parity, because if they have different parity, then a and b will have different parity (after applying all operations).It turns out that we always can make integers a and b equal after applying x operations. It's true because we have to add x(x+1)2 −a+b2 +a−b to b and the rest to a. And we can get any integer from 0 to z(z+1)2  as a sum of subset of set {1,2,…,z}.

Solution (Roms)1278C - Berry Jam

Idea: MikeMirzayanov

Tutorial1278C - Berry JamLet's transit from counting strawberry and blueberry jam jars separately to their difference. Let dif be equal to #of_strawberry_jars−#of_blueberry_jars. Then eating one strawberry jar decreases dif by 1 and eating one blueberry jar increases dif by 1. The goal is to make dif equal to 0.

Let there be some initial difference difinit. Let's eat first l jars from the left and first r jars from the right. Difference of the jars on the left is difl, on the right it's difr. So the goal becomes to find such l and r that difinit−difll−difrr=0. Rewrite that as difinit−difll=difrr. Now for each unique value of difrr save the smallest r to reach that value in a map. Finally, iterate over the l and find the minimum answer.

Overall complexity: O(nlogn).

Solution (pikmike)1278D - Segment Tree

Idea: Neon

Tutorial1278D - Segment TreeThe main idea of the solution is to find a linear number of intersections of segments.

Intersections can be found with sweep line approach. We will maintain a set for the endpoints open segments. When we add a segment, we find all segments which intersect with it — that is, all segments that end earlier than it.

Obviously, if the number of intersections are greater than n−1, then the answer is "NO". So as soon as we find n intersections, we stop our algorithm.

After that, it is necessary to check the connectivity of the resulting graph. You can use DFS or DSU to do this.

Solution (Ne0n25)1278E - Tests for problem D

Idea: Neon

Tutorial1278E - Tests for problem DFor each vertex, we will build the following structure for its children: the segment for the second child is nested in the segment for the first child, the nested for the third child is nested in the segment for the second child, and so on; and the children of different vertices do not intersect at all.

Let's solve the problem recursively: for each of the children, create a set of segments with endpoints from 1 to 2k, where k is the size of the subtree. After that, combine them. To do this, you can use small-to-large technique and change the coordinates of the segments or use the necessary offset in the function call for the next child.

After that, it remains to cross children's segments with the segment of the vertex itself. To do this, you can move the right ends of all segments of the children by 1 to the right, and add a segment that starts before the first one and ends immediately after the last one.

Solution (Ne0n25)1278F - Cards

Idea: BledDest

Tutorial1278F - CardsFirst of all, I would like to thank Errichto for his awesome lecture on expected value: part 1, part 2. This problem was invented after I learned the concept of estimating the square of expected value from that lecture — and the editorial uses some ideas that were introduced there.

Okay, now for the editorial itself. We call a number a as good if 1≤a≤n, and the a-th shuffle of the deck resulted in a joker on top. x from our problem is the number of such good numbers a. We can represent x2 as the number of pairs (a1,a2) such that every element of the pair is a good number, x3 as the number of triples, and so on — xk is the number of k-tuples (a1,a2,…,ak) such that each element of a tuple is a good number.

So we can rewrite the expected value of xk as the expected number of such tuples, or the sum of P(t) over all tuples t, where P(t) is the probability that t consists of good numbers. How to calculate the probability that t is a good tuple? Since all shuffles of the deck result in a joker with probability 1m, P(t) should be equal to 1mk — but that is true only if all elements in t are unique. How to deal with tuples with repeating elements? Since all occurences of the same element are either good or bad (with probability 1m of being good), the correct formula for P(t) is P(t)=1md, where d is the number of distinct elements in the tuple.

Okay, then for each d∈[1,k] we have to calculate the number of k-tuples with exactly d distinct elements. To do that, we use dynamic programming: let dpi,j be the number of i-tuples with exactly j distinct elements. Each transition in this dynamic programming solution models adding an element to the tuple; if we want to compute the transitions leading from dpi,j, we either add a new element to the tuple (there are n−j ways to choose it, and we enter the state dpi+1,j+1), or we add an already existing element (there are j ways to choose it, and we enter the state dpi+1,j).

Overall complexity is O(k2logMOD) or O(k2+logMOD), depending on your implementation.

Educational Codeforces Round 77 Editorial

By awoo, history, 3 years ago, translation, In English1260A - Heating

Idea: adedalic

Tutorial1260A - HeatingLet's denote the number of sections in the i-th radiator as xi. Let's prove that in the optimal answer max(xi)−min(xi)<2. Proof by contradiction: suppose we have x and y≥x+2 in the answer, let's move 1 from y to x and check:(x+1)2+(y−1)2=x2+2x+1+y2−2y+1=(x2+y2)+2(x−y+1)<x2+y2The answer is not optimal — contradiction.

Finally, there is the only way to take x1+x2+⋯+xc=sum with max(xi)−min(xi)≤1. And it's to take (summodc) elements with value ⌊sumc⌋+1 and c−(summodc) elements with ⌊sumc⌋.

Solution (adedalic)1260B - Obtain Two Zeroes

Idea: Roms

Tutorial1260B - Obtain Two ZeroesLet's assume a≤b. Then the answer is YES if two following conditions holds:

(a+b)≡0mod3, because after each operation the value (a+b)mod3 does not change;a⋅2≥b.Solution (Roms)1260C - Infinite Fence

Idea: adedalic

Tutorial1260C - Infinite FenceAt first, suppose that r≤b (if not — swap them). Let's look at the case, where gcd(r,b)=1. We can be sure that there will be a situation where the pos-th plank is painted in blue and pos+1 plank is painted in red. It's true because it's equivalent to the solution of equation r⋅x−b⋅y=1.

And all we need to check that interval (pos,pos+b) contains less than k red planks. Or, in formulas, (k−1)⋅r+1≥b.

The situation with gcd(r,b)>1 is almost the same if we look only at positions, which are divisible by gcd(r,b) — in other words we can just divide r on gcd and b on gcd and check the same condition.

Solution (adedalic)1260D - A Game with Traps

Idea: BledDest

Tutorial1260D - A Game with TrapsWhen we fix a set of soldiers, we can determine a set of traps that may affect our squad: these are the traps with danger level greater than the lowest agility value. So we can use binary search on minimum possible agility of a soldier that we can choose.

How should we actually bring our soldiers to the boss? Each trap that can affect our squad can be actually treated as a segment [li,ri] such that our squad cannot move to li until we move to ri and disarm this trap. We should walk through such segments for three times: the first time we walk forwards without our squad to disarm the trap, the second time we walk backwards to return to our squad, and the third time we walk forwards with our squad. So the total time we have to spend can be calculated as n+1+2T, where T is the number of unit segments belonging to at least one trap-segment — and it can be calculated with event processing algorithms or with segment union.

Time complexity is O(nlogn) or O(nlog2n), but it is possible to write a solution in O(nα(n)) without binary search.

Solution (BledDest)1260E - Tournament

Idea: Roms

Tutorial1260E - TournamentIf our friend is the strongest boxer, he wins without any bribing. Otherwise, we have to bribe the strongest boxer — and he can defeat some n2−1 other boxers (directly or indirectly). Suppose we chose the boxers he will defeat, then there is another strongest boxer. If our friend is the strongest now, we don't need to bribe anyone; otherwise we will bribe the strongest remaining boxer again, and he can defeat n4−1 other boxers, and so on.

The only thing that's unclear is which boxers should be defeated by the ones we bribe. We may use dynamic programming to bribe them: dpi,j is the minimum cost to bribe i boxers so that all boxers among j strongest ones are either bribed or defeated by some bribed boxer. For each value of i we know the maximum amount of boxers that are defeated by i bribed boxers, so the transitions in this dynamic programming are the following: if we can't defeat the next boxer "for free" (our bribed boxers have already defeated as many opponents as they could), we have to bribe him; otherwise, we either bribe him or consider him defeated by some other boxer.

Overall complexity is O(nlogn).

Solution (Roms)1260F - Colored Tree

Idea: RDDCCD

Tutorial1260F - Colored TreeLet's set the root as 1. Define lca(u,v) as the lowest common ancestor of vertices u and v, dep(u) as the depth of vertex u (dep(u)=dis(1,u)). Obviously dis(u,v)=dep(u)+dep(v)−2×dep(lca(u,v)).

The answer we want to calculate is ∑G∑hi=hj,i<jdis(i,j) where G represent all possible colorings of the tree.

We can enumerate the color c. For a fixed color c, we need to calculate ∑li≤c≤ri,lj≤c≤rj[dis(i,j)×∏k≠i,j(rk−lk+1)]Let P=∏1≤i≤n(ri−li+1),gi=ri−li+1. Also denote V(i) as a predicate which is true iff li≤c≤ri.

==∑li≤c≤ri,lj≤c≤rj[dis(i,j)×∏k≠i,j(rk−lk+1)]∑V(i)∧V(j)dep(i)×Pgi×gj+∑V(i)∧V(j)dep(j)×Pgi×gj−2×∑V(i)∧V(j)dep(lca(i,j))×Pgi×gjP×(∑V(i)dep(i)gi)×(∑V(i)1gi)−P×∑V(i)dep(i)g2i−2P×∑V(i)∧V(j)dep(lca(i,j))×1gi×gjNow our problem is how to maintain this formula while enumerating the color c.

P×(∑V(i)dep(i)gi)×(∑V(i)1gi) can be easily maintained. For ∑V(i)∧V(j)dep(lca(i,j))×1gi×gj, we can add 1gi to all vertices in path i to 1 (for each existing vertex i), and when new vertex is added, just calculate the sum of vertices on path from i to 1, minus the contribution of vertex 1 (because there are dep(u)+1 vertices in the path u to 1), and multiply it 1gi. Similar operation can be used to handle the situation when some vertex disappears. All of this can be done with HLD.

Overall it's O(cmax+nlog2(n)).

Educational Codeforces Round 76 Editorial

By awoo, history, 3 years ago, translation, In English1257A - Two Rival Students

Idea: Roms

Tutorial1257A - Two Rival StudentsTo solve the problem you need to understand two facts:

The answer can't be greater than n−1;If current distance between rivaling student if less then n−1 we always can increment this distance by one swap;In means that answer is equal to min(n−1,|a−b|+x).

Solution (adedalic)1257B - Magic Stick

Idea: BledDest

Tutorial1257B - Magic Stick1 cannot be transformed into any other number. 2 can be transformed into 3 or 1, and 3 can be transformed only into 2. It means that if x=1, then only y=1 is reachable; and if x=2 or x=3, then y should be less than 4.

Otherwise, we can make x as large as we want, so if x>3, any y is reachable.

Solution (Ne0n25)1257C - Dominated Subarray

Idea: adedalic

Tutorial1257C - Dominated SubarrayAt first, let's prove that the shortest dominated subarray has pattern like v,c1,c2,…,ck,v with k≥0 and dominated by value v. Otherwise, we can decrease its length by erasing an element from one of its ends which isn't equal to v and it'd still be dominated.

Now we should go over all pairs of the same numbers and check its subarrays... Or not? Let's look closely at the pattern: if v and all ci are pairwise distinct then the pattern is dominated subarray itself. Otherwise, we can find in our pattern other shorter pattern and either the found pattern is dominated or it has the pattern inside it and so on.

What does it mean? It means that the answer is just the shortest pattern we can find. And all we need to find is the shortest subarray with the same first and last elements or just distance between two consecutive occurrences of each number. We can do it by iterating over current position i and keeping track of the last occurrence of each number in some array lst[v]. Then the current distance is i−lst[a[i]]+1.

The total complexity is O(n).

Solution (adedalic)1257D - Yet Another Monster Killing Problem

Idea: Roms

Tutorial1257D - Yet Another Monster Killing ProblemAt first, lets precalc array bst; bsti is equal to maximum hero power whose endurance is greater than or equal to i.

Now let's notice that every day it's profitable for as to kill as many monster as possible. Remains to understand how to calculate it.

Suppose that we already killed cnt monsters. If acnt+1>bst1 then answer is -1, because we can't kill the cnt+1-th monster. Otherwise we can kill at least x=1 monsters. All we have to do it increase the value x until conditions maxcnt<i≤cnt+xai≤bstx holds. After calculating the value x we just move to the next day with cnt+x killed monsters.

Solution (Roms)1257E - The Contest

Idea: vovuh

Tutorial1257E - The ContestSuppose we want to divide r first problems of the contest between the first contestant and the second contestant (the first contestant will get l first problems, and the second contestant will get r−l problems in the middle), and then give all the remaining problems to the third contestant. We are going to iterate on r from 0 to n and, for each possible r, find the best value of l.

Okay. Now suppose we fixed l and r, and now we want to calculate the number of problems that should be redistributed. Let's denote cntl,i as the number of problems among l first ones given to the i-th contestant, cntr,i as the number of problems among r last ones given to the i-th contestant, and cntm,i as the number of problems in the middle given to the i-th contestant.

Obviously, the answer for fixed l and r is cntl,2+cntl,3+cntm,1+cntm,3+cntr,1+cntr,2, but we don't like this expression because we don't know how to minimize it for fixed r. We know that, for fixed r, the values of cntl,i+cntm,i and cntr,i are constant. Using that, we may arrive at the fact that minimizing cntl,2+cntl,3+cntm,1+cntm,3+cntr,1+cntr,2 is the same as minimizing cntl,2−cntl,1 for fixed r — and now we have a way to quickly find best possible l for fixed r.

Solution (BledDest)1257F - Make Them Similar

Idea: vovuh

Tutorial1257F - Make Them SimilarIterating over all possible values of x and checking them may be too slow (though heavily optimized brute force is difficult to eliminate in this problem), so we need to speed this approach up.

The resulting number consists of 30 bits. Let's use the classical meet-in-the-middle trick: try all 215 combinations of 15 lowest bits, try all 215 combinations of 15 highest bits, and somehow "merge" the results.

When we fix a combination of 15 lowest bits, we fix 15 lowest bits in every bi. Suppose that there are cnt0,i ones among 15 lowest bits of bi.

Analogically, when we fix a combination of 15 highest bits, we fix 15 highest bits in every bi. Suppose that there are cnt1,i ones among 15 highest bits of bi.

We want to find a combination of lowest and highest bits such that cnt0,i+cnt1,i is the same for each i. Let's represent each combination of 15 lowest bits with an (n−1)-dimensional vector with coordinates (cnt0,1−cnt0,2,cnt0,1−cnt0,3,…,cnt0,1−cnt0,n). Let's also represent each combination of 15 highest bits with an (n−1)-dimensional vector with coordinates (cnt1,1−cnt1,2,cnt1,1−cnt1,3,…,cnt1,1−cnt1,n). We want to find a combination of lowest bits and a combination of highest bits such that their vectors are opposite. We can do so, for example, by precalculating all vectors for all combinations of 15 lowest bits, storing them in a map or a trie, iterating on a combination of 15 highest bits and searching for the opposite vector in the map/trie.

Solution (BledDest)1257G - Divisor Set

Idea: adedalic

Tutorial1257G - Divisor SetThe problem consists of two parts: what do we want to calculate and how to calculate it?

What do we want to calculate? There are several ways to figure it out. At first, you could have met this problem before and all you need is to remember a solution.

At second, you can come up with the solution in a purely theoretical way — Hasse diagram can help with it greatly. Let's define deg(x) as the number of primes in prime factorization of x. For example, deg(2⋅3⋅2)=3 and deg(1)=0. If you look at Hasse diagram of p1⋅…⋅pn you can see that all divisors with deg(d)=i lies on level i. If x is divisible by y then deg(x)>deg(y) so all divisors on the same level don't divide each other. Moreover, the diagram somehow symmetrical about its middle level and sizes of levels are increasing while moving to the middle. It gives us an idea that the answer is the size of the middle level, i.e. the number of divisors with deg(d)=n2.

The final way is just to brute force the answers for small x-s and find the sequence in OEIS with name A096825, where the needed formulas are described.

The second step is to calculate the number of divisors with deg(d)=n2. Suppose we have m distinct primes pj and the number of occurences of pj is equal to cntj. Then we need to calculate pretty standard knapsack problem where you need to calculate number of ways to choose subset of size n2 where you can take each pj up to cntj times. Or, formally, number of vectors (x1,x2,…xm) with ∑j=0j=mxj=n2 and 0≤xj≤cntj.

Calculating the answer using dp[pos][sum] will lead to time limit, so we need to make the following transformation. Let's build for each pj a polynomial fj(x)=1+x+x2+⋯+xcntj. Now the answer is just a coefficient before xn2 in product f1(x)⋅f2(x)⋅…⋅fm(x). Note, that the product has degree n, so we can multiply polynomials efficiently with integer FFT in the special order to acquire O(nlog2(n)) time complexity.

There several ways to choose the order of multiplications. At first, you can, at each step, choose two polynomials with the lowest degree and multiply them. At second, you can use the divide-and-conquer technique by dividing the current segment in two with pretty same total degrees. At third, you can also use D-n-C but divide the segment at halves and, it seems still to be O(nlog2(n)) in total.

What about the proof of the solution? Thanks to tyrion__ for the link at the article: https://pure.tue.nl/ws/files/4373475/597494.pdf.

The result complexity is O(nlog2(n)) time and O(n) space (if carefully written). Note, that the hidden constant in integer FFT is pretty high and highly depends on the implementation, so it's possible for poor implementations not to pass the time limit.

Educational Codeforces Round 75 Editorial

By awoo, history, 3 years ago, translation, In English1251A - Broken Keyboard

Idea: BledDest

Tutorial1251A - Broken KeyboardIf a key malfunctions, each sequence of presses of this key gives a string with even number of characters. So, if there is a substring consisting of odd number of equal characters c, such that it cannot be extended to the left or to the right without adding other characters, then it could not be produced by presses of button c if c was malfunctioning.

The only thing that's left is to find all maximal by inclusion substrings consisting of the same character.

Solution (Ne0n25)1251B - Binary Palindromes

Idea: adedalic

Tutorial1251B - Binary PalindromesLet's make several observations. At first, note that the lengths of the strings doesn't change.

At second, note that if the string has even length then being palindromic is the same as having even number of zeroes and even number of ones. But if the string has odd length, then it always is palindromic.

So the question is how to fix "bad" strings with even length but with odd number of zeroes and ones. If we have at least one string with odd length, then you can trade between "bad" string and "odd" string either zero to one or one to zero, fixing the "bad" string.

Otherwise you can fix two "bad" strings swapping appropriate characters. In result, we can either make all strings palindromic or all strings except one in case of absence of "odd" strings and having odd number of "bad" strings.

Solution (adedalic)1251C - Minimize The Integer

Idea: Roms

Tutorial1251C - Minimize The IntegerLet's consider two sequences of digits: e1,e2,…,ek and o1,o2,…,om, there e1 is the first even digit in a, e2 is the second even digit and so on and o1 is the first odd digit in a, o2 is the second odd digit and so on.

Since you can't swap digits of same parity, the sequence e of even digits of a never changed. Sequence o of odd digits of a also never changed. So the first digit in the answer will be equal to e1 or to o1. And since we have to minimize the answer, we have to chose the min(e1,o1) as the first digit in answer and them delete it from the corresponding sequence (in this way sequence e turn into e2,e3,…,ek or sequence o turn into o2,o3,…,om). Second, third and followings digits need to choose in the same way.

Solution (Roms)1251D - Salary Changing

Idea: Roms

Tutorial1251D - Salary ChangingLet f(mid) be equal minimum amount of money to obtain the median salary at least mid. We'll solve this problem by binary search by mid.

Suppose the have to calculate the minimum amount of money for obtaining median salary at least mid. Let's divide all salaries into three groups:

ri<mid;mid≤li;li<mid≤ri.In order to the median salary be at least mid there must be at least n+12 salaries greater than or equal to mid. Let's denote the number of such salaries as cnt.

Note that salaries of the first group can't increment the value of cnt, so it's beneficial for us to pay the minimum salary for this group. Salaries if second group always increment the value of cnt, so it's also beneficial for us to pay the minimum salary.

The salaries from the third group are more interesting. For each salary [li,ri] in this group we can pay mid and increment cnt, or we can pay li and don't increase cnt. The value of cnt should be increased by rem=max(0,n+12−cnt). So, if the size of the third group is less than rem than we can't obtain the median salary mid. Otherwise, we can define how many salaries we can take with value li and chose the minimal ones.

Solution (Roms)1251E1 - Voting (Easy Version)

1251E2 - Voting (Hard Version)

Idea: Roms

Tutorial1251E2 - Voting (Hard Version)Denote the number of voters with mi=x as cx. Also denote prefx=∑i=0x−1cx, i.e. prefx is equal to number of voters with mi<x.

Let's group all voters by value mi. We'll consider all these group in decreasing value of mi. Assume that now we consider group with mi=x. Then there are two cases:

if prefx+cnt≥x then all these voters will vote for you for free. cnt is equal to the number of votes bought in previous steps;if prefx+cnt<x then we have to buy x−prefs−cnt additional votes. Moreover the value mi of this "bought" voter must be greater than or equal to x. Since these voters indistinguishable we have to buy x−prefs−cnt cheapest voter (with a minimal value of pi).So, all we have to do it maintain values pi not yet bought voters in some data structure (for example multiset in C++).

Solution (Roms)1251F - Red-White Fence

Idea: Neon and BledDest

Tutorial1251F - Red-White FenceLet's analyze how the perimeter of the fence can be calculated, if we know its array of lengths. Suppose there are m boards in the fence. The perimeter of the fence can be composed of the three following values:

the lower border of the fence (with length m);m horizontal segments in the upper border of the fence (with total length m);m+1 vertical segment of the border.The total length of all vertical segments before the red board (including its left border) is l1+(l2−l1)+⋯+(lj−lj−1)=lj. The total length of all vertical segments after the red board (including its right border) is lj too. So, the perimeter of the fence is 2(m+lj), where m is the number of boards used in constructing the fence, and lj is the length of the red board.

So, for example, if we want to create a fence that contains a red board with length L and has perimeter P, it should contain exactly P2−L−1 white boards. Now let's solve the problem as follows: iterate on the length of the red board that will be used, and for each Qi calculate the number of ways to construct a fence with a red board of length L and exactly Qi2−L−1 white boards (which are shorter than L).

Suppose all white boards shorter than L have distinct lengths. Then for each board, there are three options: not place it at all, place it in the left part (to the left of the red board) or place it in the right part. So, if there are n different white boards shorter than L, the number of ways to build a fence with k white boards is (nk) 2k.

Okay, now let's consider the opposite situation: there is no unique white board; that is, for each length, we have either 0 boards or at least 2 boards. Suppose the number of different lengths is m. For each length, we can choose whether we place a board of such length in the left side and in the right side. So, the number of ways to build a fence with k white boards is (2mk).

And now let's consider the general case. Divide all boards into two categories: "unique" and "non-unique". If we want to build a fence with exactly k white boards, there are ∑i=0k (2mk−i) (ni) 2i ways to do it. Since we should calculate these values for many different values of k, we have to use FFT: we should form two polynomials ∑i=0n (ni) 2ixi and ∑i=02m (2mi) xi, and then multiply them. Since the modulo is special, it's better to use NTT.

Educational Codeforces Round 74 Editorial

By awoo, history, 3 years ago, translation, In English1238A - Prime Subtraction

Idea: BledDest

Tutorial1238A - Prime SubtractionLet's denote the difference between x and y as z (z=x−y). Then, if z has a prime divisor p, we can subtract p from x zp times.

The only positive integer that doesn't have any prime divisors is 1. So, the answer is NO if and only if x−y=1.

Solution (BledDest)1238B - Kill `Em All

Idea: Neon

Tutorial1238B - Kill `Em AllNotice the following fact: it's never optimal to fire a missile at such a position that there are monsters to the right of it. That suggests the next solution: sort the positions, leave only the unique ones and process to shoot at the rightmost alive monster until every monster is dead. Position of some monster after s shots are made is the original position minus r⋅s, because the monster could only be pushed to the left.

Overall complexity: O(nlogn).

Solution (Ne0n25)1238C - Standard Free2play

Idea: adedalic

Tutorial1238C - Standard Free2playYou are given the input data in compressed format, let's decompress it in binary string, where the i-th character is 0 if the i-th platform is hidden and 1 otherwise. For, example, the third query is 101110011.

Let's look how our string changes: if we had ...01... then after pulling the lever it becomes ...10... and if we had ...111... then we'd get ...100... (The underlined index is the platform we are currently on). So it looks like we are standing on 1 and move it to the left until it clashes with the next one. So we can determine that we should look only at subsegments on 1-s.

Now we can note, that the "good" string should have all subsegments of ones with even length except two cases: the subsegment that starts from h should have odd length and subsegment, which ends in 1 can have any length.

Now we can say, that the answer is equal to number of subsegments which doesn't match the pattern of the "good string", since we can fix each subsegment with one crystal. And we can prove that it's optimal since the only way to fix two subsegments with one crystal is to merge them but it does not help.

Finally, we can understand that we have no need in decompressing the input and can determine subsegments of ones straightforwardly.

Solution (adedalic)1238D - AB-string

Idea: Roms

Tutorial1238D - AB-stringInstead of counting the number of good substrings, let's count the number of bad substrings cntBad, then number of good substrings is equal to n(n+1)2−cntBad.

Let's call a character ti in string t1t2…tk is bad if there is no such palindrome tltl+1…tr that l≤i≤r. Any character in substring t2t3…tk−1 is good. It can be proven as follows. If ti=ti+1 or ti=ti−1 then ti belong to a palindrome of length 2. If ti≠ti+1 and ti≠ti−1 then ti belong to a palindrome ti−1…ti+1.

So only characters t1 and tk can be bad. But at the same time character t1 is bad if there is no character ti such that i>1 and ti=t1. It is true because substring t1t2…ti is palindrome (index i is minimum index such that ti=t1).

So, there are only 4 patterns of bad strings:

ABB…BB;BAA…AA;AA…AAB;BB…BBA;All that remains is to count the number of substrings of this kind.

Solution (Roms)1238E - Keyboard Purchase

Idea: Roms

Tutorial1238E - Keyboard PurchaseLet's solve this problem by subset dynamic programming.

Let's denote cntx,y as the number of adjacent characters (si and si+1) in s such that si=x,si+1=y or si=y,si+1=x.

Let's dpmsk be some intermediate result (further it will be explained what kind of intermediate result) if we already added letters corresponding to subset msk to the keyboard (and we don't care about the order of these letters).

Now let's consider how to recalculate values of this dynamic programming using some dpmsk. Let's iterate over a new letter x on keyboard (and we know the position of this letter on the keyboard: it's equal to the number of elements in msk). After adding this new letter, we want to calculate what it added to the dpmsk∪x. Let consider some letter y≠x and calculate how much time will be spent on moving x→y and y→x. There are two cases. If letter y is already on current keyboard, then we should add to answer cntx,y(posx−posy), and cntx,y(posy−posx) otherwise (where poxa is the position of character a on the keyboard). But we don't know the position of the letter y. Let's fix it as follows. We will add the contribution of some letter when it will be added to the keyboard. So, when we added letter x, we should add the value ∑y∈msk(cntx,yposx)−∑y∉msk(cntx,yposx).

So, the total complexity is O(a22a+n).

Solution (Roms)1238F - The Maximum Subtree

Idea: Roms

Tutorial1238F - The Maximum SubtreeAt first let's understand which trees are good. For this, let's consider some vertex v (we denote its segment as [lv,rv]) which is not a leaf. Also let's consider some adjacent vertex u (we denote its segment as [lu,ru]) which also is not leaf. It is claimed that segment [lv,rv] can't be inside segment [lu,ru] (it's means lu≤lv≤rv≤ru) and vice versa. It's true because if segment [lv,rv] is inside the segment [lu,ru] then some vertex t adjacent with v also will be adjacent with u. So any non-leaf vertex can be adjacent with at most 2 non-leaf vertexes. Therefore good tree is a path with a leafs adjacent to this path.

So all the have to do it's find the such subtree of maximum size. We can do it by subtree dynamic programming.

At first, let chose the root of the tree — some not leaf vertex.

Let dpv,0 be the answer for the subtree with root in v and dp_{v, 1} be the answer for the subtree with root in v if we already took v and its parent to the answer.

It can be calculated as follows:

dpv,0=maxtodpto,0;dpv,0=max(dpv,0,degv+1+firstMax+secondMax), there firstMax is a first maximum of all dpto,1, and secondMax is a second maximum, and degv is a degree of vertex v;dpv,1=degv−1+maxtodpto,1.Solution (Roms)1238G - Adilbek and the Watering System

Idea: Neon

Tutorial1238G - Adilbek and the Watering SystemDespite the fact that statement sounds like some dp or flow, the actual solution is pretty greedy.

Let's iterate over all minutes Adilbek has to water at and maintain the cheapest C liters he can obtain to this minute. Let this be some structure which stores data in form (price for 1 liter, total volume Adilbek can buy for this price). Pairs will be sorted by the price of a liter. The most convenient structure for that might be a C++ map, for example.

When moving to the next minute, pop the cheapest liter out of this structure and add it to the answer.

If that minute some friend comes, then push his water to the structure: if the total updated volume in the structure is greater than C, then pop the most expensive left-overs out of it so that the structure holds no more than C liters total. That prevents out solution to fill the watering system over its capacity.

The main idea for why this greedy strategy works is that it's never optimal to take not the cheapest liter because a liter of that price or cheaper will still be available in the future minutes.

Note that between each pairs of adjacent coming friends basically nothing happens. Thus you can find the time between them and pop that number of cheapest liters right away instead of iterating minute by minute.

Overall complexity: O(nlogn) per query.

Educational Codeforces Round 73 Editorial

By awoo, history, 3 years ago, translation, In English1221A - 2048 Game

Idea: Roms

Tutorial1221A - 2048 GameIt's obvious that we don't need elements that are larger than 2048.

If the sum of the remaining elements is greater than or equal to 2048, then the answer is YES, and NO otherwise.

It's true because for getting a integer x that wasn't in the multiset initially, we first need to get integer x2.

Solution (Roms)1221B - Knights

Idea: BledDest

Tutorial1221B - KnightsLet's denote a cell (i, j) as black if i+j is even, otherwise the cell is white. It's easy to see that if a knight is occupying a black cell, then all cells attacked by it are white, and vice versa.

Using this fact, we can construct a solution where every pair of knights that attack each other have different colors — put black knights into black cells, and white knights into white cells, so every pair of knights that can possibly form a duel actually form it.

Solution (PikMike)1221C - Perfect Team

Idea: Roms

Tutorial1221C - Perfect TeamNotice that if c≠m, then you can equalize them to the min and re-qualify the rest into students without specialization. That won't change the answer.

Now analyze the possible team formations: 1 of each kind, 2 coders and 1 mathematician or 1 coder and 2 mathematicians. Each of these squads have 1 coder and 1 mathematician, so you can only choose the type of the third member.

The students without specialization can only be used in the first kind of teams, so let's use them first. After that you might have been left with a nonzero count of coders and mathematicians. These are equal however, so ⌊c+m3⌋ can be added to the answer.

This solves each query in O(1).

You can also run a binary search and solve each query in O(logMAX).

Solution 1 (BledDest)Solution 2 (PikMike)1221D - Make The Fence Great Again

Idea: Roms

Tutorial1221D - Make The Fence Great AgainLet's notice that in optimal answer all boards will be increased by no more than two. It is true because if it is beneficial to increase the length of some board by three or more (denote its length as len) then increasing to the length len−1, len−2 or len−3 is cheaper and one of these boards is not equal to any of its adjacent boards.

Noticing this, we can write a solution based on dynamic programming. Let's dppos,add is minimum amount of money for making fence a1,a2,…,apos great, moreover the last board(with index pos) we increase by add.

Then value dppos,add can be calculated as follows:

dppos,add=add⋅bpos+minx=0…2,apos−1+x≠apos+adddppos−1,xSolution (Roms)1221E - Game With String

Idea: Roms

Tutorial1221E - Game With StringAt first, let's transform input to a more convenient form. We consider only such subsegments that consist of the symbols . and which cannot be expanded to the right or left. For example, for s=XX...X.X...X.. we consider segments of length 3, 1, 3, and 2.

Let's divide all such segments into four groups by their length len:

len<b;b≤len<a;a≤len<2b;len≥2b.In such a division, each segment belongs to exactly one type.

Suppose that the Bob takes the first turn. If there is a segment of second type, then Bob wins, because he always have a spare turn that Alice cannot make. If there is a segment of fourth type then the Bob also wins because he can make the segment of second type by taking turn in this segment of four type. If there are no segments of second and four types, then victory depends on the parity of the number of segments of the third type.

But it is true if the Bob takes first turn. If Alice takes first turn then she doesn't want, after her move, there are segments of the second and fourth types. So if initially there is a segment of second type then Alice loses because she can't take turns into segment of second type. If there are two or more segments of four type then Alice also loses, because after her turn at least one such segments remains. If there are only one segment of four type then Alice have to take turn into this segment. Since the length of this segment doesn't exceed n, we can iterate over all possible Alice moves. After Alice's move segment of fourth type can be divided into no more than two new segments, let's denote their types as t1 and t2. If at least one of these segments of second or fourth type, then it's bad turn for Alice. Otherwise Alice win if remaining number of segment of third type is even (note that t1 or t2 also can be the third type). And finally, if initially there are only segments of first or third type, then victory depends on the parity of the number of segments of the third type.

Solution (Roms)1221F - Choose a Square

Idea: Neon

Tutorial1221F - Choose a SquareNotice that the square (l,l) (r,r) covers the point (x,y) if and only if l≤min(x,y)≤max(x,y)≤r.

Using this fact, let's reformulate the problem the following way: we have to find the segment (l,r), such that the sum of the segments fully covered by it is maximal.

Let's build a segment tree, the r-th of its leaves stores f(l,r) — the sum of the segments covered by the segment (l,r) . Initially, it's built for some l such that it is to the right of all segments. Other nodes store the maximum in them.

Now let's iterate over the values ​​of l in descending order. Let there be some segment starting in l (l,x) with the cost c. All the answers f(l,r) for r<x won't change because they don't cover that new segment. And the values on the suffix from the position x (r≥x) will increase by c.

The only thing left is to learn how to handle the subtraction of the length of the side. That term is (r−l) and the thing we are looking for is maxrf(l,r)−(r−l). Rewrite it in form l+maxrf(l,r)−r and you'll see that you can just subtract r from the value of the r-th leaf of the segment tree at the beginning to get the correct result. Surely, you'll need to add that l after you ask the maximum of all the segtree to obtain the answer.

You'll probably need to compress the coordinates — leave only such positions i that there is at least one x=i or y=i. Implicit segtree might work but neither ML, nor TL are not friendly to it. Also be careful with the case with all points being negative.

Solution (Ne0n25)1221G - Graph And Numbers

Idea: BledDest

Tutorial1221G - Graph And NumbersLet F(S) be the number of ways to paint the graph so that all numbers on edges belong to the set S. Using inclusion-exclusion we may get that the answer is F({0,1,2})−F({1,2})−F({0,2})+F({2})−F({0,1})+F({1})+F({0})−F({}).

Okay, let's analyze everything separatedly.

F({0,1,2}) is 2n, because every number is allowed;F({1,2}) will be analyzed later;F({0,2}) is 2C, where C is the number of connected components — in each component we have to use the same number;F({2}) is 2I, where I is the number of isolated vertices — every non-isolated vertex should have number 1 on it, and all isolated vertices may have any numbers;F({0,1})=F({1,2}), since these cases are symmetric;F({1}) is the number of bipartite colorings of the graph. It is 0 if the graph contains an odd cycle, or 2C if it is bipartite;F({0})=F({2}), since these cases are symmetric;F({}) is 2n if there are no edges in the graph, otherwise it is 0.So, the only thing left to consider is F({1,2}). Actually, it is easier to calculate F({0,1}) — it is the number of independent sets of this graph. This problem is NP-complete, but when n=40, we may apply meet-in-the-middle technique as follows:

divide all vertices into two sets S1 and S2 of roughly equal size;for S1, find all its independent subsets, and for each such subset, find which vertices from S2 can be added to it without breaking its independency;for each subset of S2, find the number of independent subsets of S1 such that no vertex from chosen subset of S2 is adjacent to any vertex from chosen subset of S1 (you may use subset DP and OR-convolution here);find all independent subsets of S2, and for every such subset, add the number of subsets of S1 that can be merged with it so the resulting set is independent.The most time-consuming part is counting all independent sets, so the time complexity is (O(n2n/2)).

Educational Codeforces Round 72 Editorial

By awoo, history, 3 years ago, translation, In English1217A - Creating a Character

Tutorial1217A - Creating a CharacterLet addS and addI be number of free points that we invest in the strength and intelligence respectively. It's obvious that addS+addI=exp since we must spend all free points. From the other side we must make str+addS>int+addI.

Now we can expess addI=exp−addS and put it in the inequality:str+addS>int+(exp−addS)2addS>exp+int−str2addS≥exp+int−str+1addS≥⌈exp+int−str+12⌉Since addS must be non negative we can getaddS≥max(0,⌈exp+int−str+12⌉)We can use or write the correct ceiling function that works with negative numerator or use one hack and magic and getaddS≥max(0,exp+int−str+22)with usual integer division. Let's denote this value as minAddS.

Since all integer values addS from [minAddS,exp] are good for us, so the number of pairs is equal to max(0,exp−minAddS+1).

P.S.: Let me explain how to prove that k⋅x>y is equal to x≥⌊y+kk⌋.

k⋅x>y⇔k⋅x≥y+1⇔x≥⌈y+1k⌉⇔x≥⌊y+1+k−1k⌋⇔x≥⌊y+kk⌋P.P.S.: Interesting fact: the formula above works for all positive k and y∈[−k,+∞) thats why it works in our case even though exp+int−str can be negative.

Solution (adedalic)1217B - Zmei Gorynich

Idea: Roms

Tutorial1217B - Zmei GorynichLets divide all dealing blows into two parts: the last blow and others blows.

The last hit should be with maximum value of d.

The others blows should be with the maximum value of d−h.

So, lets denote max1≤i≤ndi as maxD and max1≤i≤n(di−hi) as maxDH.

Then if x≤maxD the we can beat Zmei Gorynich with one blow. Otherwise, if maxDH≤0, then we cannot defeat Zmei Gorynich.

Otherwise (if x>maxD and maxDH>0) the answer is ⌈x−maxDmaxDH⌉.

Solution (Roms)1217C - The Number Of Good Substrings

Idea: Roms

Tutorial1217C - The Number Of Good SubstringsAt first, lets precalc the array nxt1,nxt2,…,nxtn. The value of nxti if equal the maximum position j in range 1…i such that sj=1.

After that lets iterate over the right boundary of substring and high 1-bit position (denote it as r and l respectively).

Note that if r−l>18 then f(l,r)>2⋅105.

So we iterate over such pair (l,r) that 1≤l≤r≤n and r−l≤18.

Lets look at value f(l,r). If f(l,r)>r−l+1, then we have to increase the length of substring without increasing the value of f(l,r). So we need to check if there exists a position nl such that f(nl,r)=f(l,r) and r−nl+1=f(nl,r). This position exists if the condition f(l,r)≤r−nxtl−1 is met (nxt0 is equal to -1).

Solution (Roms)1217D - Coloring Edges

Idea: BledDest

Tutorial1217D - Coloring EdgesLet's run dfs on the graph and color all "back edges" ((u,v) is back edge if there is a path from v to u by edges from dfs tree) in black and all other edges in white.

It can be proven that any cycle will have at least one white edge and at least black edge. Moreover each back edge connected with at least one cycle (path from v to u and (u,v) back edge). So the coloring we got is exactly the answer.

How to prove that any cycle have at least one edge of both colors? Let's look only at edges from dfs trees. We can always renumerate vertices in such way that index of parent id(p) is bigger than the index of any its child id(c). We can process and assign id(p) with minimal free number after we processed all its children.

Now we can note that for any white edge (u,v) (not only tree edge) condition id(u)>id(v) holds (because of properties of dfs: forward edges are obvious; cross edge (u,v) becomes cross because dfs at first processed vertex v and u after that, so id(v)<id(u)). And for each back edge (u,v) it's true that id(u)<id(v).

Since any cycle have both id(u)>id(v) and id(u)<id(v) situations, profit!

Solution (Roms)1217E - Sum Queries?

Idea: BledDest

Tutorial1217E - Sum Queries?We are given the definition of the balanced multiset but let's instead fix the criteria to determine if the multiset is unbalanced.

Take an empty multiset and start adding numbers to it until it becomes unbalanced. Empty set to the set of one number is trivial. Now for the second number. If there is some position such that both numbers have non-zero digits in it, then the multiset becomes unbalanced (let these be non-zero digits d1 and d2, then d1+d2 can be neither d1, nor d2).

After that let's prove that you can never make an unbalanced multiset balanced again by adding numbers to it. Let there be such multisets a and b such a is unbalanced, b is balanced and a⊂b. Take a look at the lowest position which has non-zero digits in several numbers from b. The sum of these digits should be equal to at least one of them modulo 10 (to satisfy the condition of balance). That can only mean their sum is greater or equal to 10, thus is make a carry to the next position. The sum of digits on the next position plus carry should also be equal to some digit of them, thus pushing some other carry value to the next one. And so on until the carry makes it to the position greater than any position in any of the numbers. But the carry is non-zero and there is no number with any non-zero digit in this position. That makes our assumption incorrect.

After all, it implies that any unbalanced multiset of size greater than two has an unbalanced multiset of size two.

The problem now got reduced to: find a pair of numbers ai and aj such that l≤i<j≤r, there is at least one position such that both ai and aj have non-zero digits on it and ai+aj is minimal possible.

That can be easily maintained in a segment tree. Let a node corresponding to the interval [l;r) keep the best answer on an interval (the sum of such a pair) and an array min_by_digit[i] — the smallest number on an interval [l;r) which has a non-zero digit at position i or ∞ if none exists.

The update is easy. Iterate over the digits of a new number and update the values in the array min_by_digit in the corresponding nodes.

The merge is done the following way: push the best answers from children to the parent and then iterate over the positions and try to combine the smallest numbers at each one from the left child and the right child.

Idea-wise this is the same as storing a segtree and calculating the answer by each position separately.

However, these approaches differ by a huge constant factor performance-wise. The former one accesses the memory in a much more cache-friendly way. You might want to take that as a general advice on implementing multiple segtrees.

Overall complexity: O((n+m)⋅logn⋅log10MAXN).

Solution (PikMike)1217F - Forced Online Queries Problem

Idea: BledDest

Tutorial1217F - Forced Online Queries ProblemThe problem directly tells you do solve some kind of Dynamic Connectivity Problem.

You could use the online approach with Link-Cut Tree if you'd had its implementation beforehand. There is also a nice modification to the log2 solution of the offline version of DCP (check out the comment).

I'd tell the solution which is probably the easiest to come up with and to code.

Let's recall the sqrt-optimization method of solving DCP. Process blocks of queries of size P one at a time. Split the edges into two groups:

The edges which were added on queries before the block and aren't touched by the queries in the block;the edges modified by the queries in the block.The first type of edges can be added to the graph before the block processing starts. You can use DSU for that. The second type contains no more than P edges. Maintain the list of those of them which exist in the graph. On each ask query add them to graph, then delete them. This can be done explicitly by doing DFS only over these edges and the vertices which correspond to the connected components on the edges of the first type. Implicitly doing DSU merges for these edges and rolling them back is a viable option as well (costs extra log factor but has lower constant).

It's easy to see that it isn't hard to modify this solution to our problem. Let's define the edges of the first type more generally: the edges which were added on queries before the block and could not be touched by the queries in the block. So neither (v,u) from the add query, nor (v mod n+1,u mod n+1) could be of the first type. Now there might be 2P edges of the second type in the list. However, that doesn't make the complexity any worse.

Process block the same way, rebuild the DSU with the edges of the first type every P queries.

The overall complexity can be O((n+m)m−−√) if you use DFS or O((n+m)mlogn−−−−−−√) if you use DSU (notice how the rebuild is P⋅O(n+m) and the query is m⋅O(mP⋅logn) and set the size of the block so that these parts are about the same).

Educational Codeforces Round 71 Editorial

By awoo, history, 3 years ago, translation, In English1207A - There Are Two Types Of Burgers

Idea: BledDest

Tutorial1207A - There Are Two Types Of BurgersIn this task you just can iterate over the numbers of hamburgers and chicken burgers you want to assemble, check that you have enough ingredients and update the answer.

If you want to sell x hamburgers and y chicken burgers then you need x beef patties, y chicken cutlets and 2(x+y) buns.

Solution (Roms)1207B - Square Filling

Idea: BledDest

Tutorial1207B - Square FillingIt is quite obvious that we can't choose any submatrix that contains at least one zero in A. The contrary is also true — if a submatrix of A consists of only ones, then there's no reason not to choose it (suppose there is an answer that does not choose it — then choosing this submatrix won't affect it).

So we may perform an operation on every submatrix of B such that the corresponding submatrix in A is filled with 1's, and check if our answer is correct.

Solution (BledDest)1207C - Gas Pipeline

Idea: adedalic

Tutorial1207C - Gas PipelineThis task was designed as a simple dynamic programming problem, but it also can be solved greedily.

The dp solution is following: when we have already built some prefix of the pipeline all we need to know is the length of the prefix the height of the pipeline's endpoint (1 or 2). So we can calculate the following dynamic programming: d[pos][add] is the minimal answer for prefix of length pos with pipeline at height 1+add. Transitions are quite straightforward: if s[pos]=0 then we can either leave the pipeline on the same level, or change it. If s[pos]=1 then we have to stay on the height 2. Look at the source code for the formal transitions. The answer is d[n][0].

The greedy solution is based on the following fact: let's look at some subsegment consisting of 0's. It's always optimal either to leave this subsegment on height 1 or raise it to height 2. We can calculate the amount we have to pay in both cases and choose the optimal one.

Solution (adedalic)1207D - Number Of Permutations

Idea: Roms

Tutorial1207D - Number Of PermutationsLet's suppose that all n! permutation are good. We counted the permutations giving the sequences where the first elements are sorted (we denote the number of such permutations as cnt1) and the permutations giving the sequences where the second elements are sorted (we denote the number of such permutations as cnt2). Then the answer is n!−cnt1−cnt2, right? No, because we subtracted the number of sequences where first and second elements are sorted simultaneously (we denote this number as cnt12) twice. So, the answer is n!−cnt1−cnt2+cnt12.

How can we calculate the value of cnt1? It's easy to understand that the elements having equal ai can be arranged in any order. So, cnt1=c1! c2! … cn!, where cx is the number of elements equal to x among ai. cnt2 can be calculated the same way.

How can we calculate the value of cnt12? First of all, there is a case where it is impossible to arrange the elements of the sequence so that the first elements and the second elements are sorted. To check that, we may sort the given sequence comparing two elements by ai, and if ai are equal — by bi. If the sequence of second elements in the resulting sequence is not sorted, then cnt12=0. Otherwise, equal elements of the given sequence can be arranged in any order. So cnt12=cs1! cs2! csk!, where s1, s2, ..., sk are the elements that appear in the given sequence of pairs at least once.

Solution (Roms)1207E - XOR Guessing

Idea: adedalic, Neon, BledDest

Tutorial1207E - XOR GuessingSuppose all integers we input in some query have the same value in the k-th bit. Then no matter which i is chosen by the jury, we can always deduce whether the k-th bit in x is 0 or 1.

This leads us to a simple solution: divide 14 bits of x into two groups of size 7. In the first query, submit 100 integers having the same values in the bits from the first group, and deduce the values of these bits in x. In the second query, do the same for the second group. Be careful to avoid submitting the same integer twice.

Solution (BledDest)1207F - Remainder Problem

Idea: BledDest

Tutorial1207F - Remainder ProblemLet's notice that if we process the queries of type 2 naively, then each such query consumes O(Nx) time (where N is the size of the array). So queries with large x can be processed naively.

For queries with small x (x≤K), we may notice two things:

there are only O(K2) possible queries;each number in the array affects only K possible queries.So, for small x, we may maintain the exact answer for each query and modify it each time we modify an element in the array.

If we process naively all queries with x>N−−√ and maintain the answers for all queries with x≤N−−√, we will obtain a solution having time complexity O(qN−−√). Note that, as in most problems related to sqrt-heuristics, it may be optimal to choose the constant that is not exactly N−−√, but something similar to it (but most solutions should pass without tuning the constant).

Solution (BledDest)1207G - Indie Album

Idea: adedalic

Tutorial1207G - Indie AlbumThere is a common approach for the problem "you are given a lot of strings and texts, count the number of occurences of the strings in the texts" — build an Aho-Corasick automaton on the given strings and somehow process the texts with it. Let's see if it can handle this problem.

The names of the songs can be represented as a tree. We may build an Aho-Corasick on the strings given in the queries, then try to input the names of the album into the automaton character-by-character with DFS on the aforementioned tree (feeding a character to the automaton when we enter a node, and reverting the automaton to the previous state when we leave that node). Suppose that when we are in the vertex corresponding to the v-th song, the automaton is in state c. If c is a terminal state corresponding to some string from the queries, it means that the string from the query is a suffix of the v-th song. But some other strings can also be the suffixes of the same song — to find all such strings, we can start ascending from the state c to the root of Aho-Corasick automaton using suffix links or dictionary links. Since suffix links can be represented as the edges of some rooted tree, then we can build some data structure on this tree that allows adding an integer to all vertices on the path from the root to the given vertex (for example, we can use Fenwick tree over Euler tour of the tree). Then, to check whether some string t from the query is a suffix of the song v, we may add 1 to all vertices on the path to state c, and then check the value in the state corresponding to t.

Okay, what about counting the occurences of t in v? Let's consider the path from the root to v in the "song tree". Every vertex on this path corresponds to some prefix of the song v, so we can add 1 on the path to every state corresponding to some prefix, and then extract the answer from the state corresponding to t.

In fact, that's all we have to do to obtain a solution. Build an automaton on strings from queries, a tree of suffix links over this automaton, and a data structure on this tree; for each vertex of the song tree, store all queries to it. Then run a DFS on the song tree. When we enter some vertex, input the corresponding character into the automaton and add 1 to all states from the root of suffix link tree to the current state; when we have to process queries to the current vertex, extract the values from the data structure; and when we leave a vertex, subtract 1 from all states from the root of suffix link tree to the current state, and revert to the previous state.

This solution has complexity of O(TlogT), where T is the total length of all strings in the input.

Educational Codeforces Round 70 Editorial

By awoo, history, 4 years ago, translation, In English1202A - You Are Given Two Binary Strings...

Idea: adedalic

Tutorial1202A - You Are Given Two Binary Strings...Multiplying by power of 2 is "shift left" binary operation (you, probably, should know it). Reverse x and y for the simplicity and look at leftmost 1 in y (let's denote its position as posy).

If you move it to 0 in x then you make the revk lexicographically bigger than the reverse of x. So you should move it to 1 in x too. You can choose any 1 with position ≥posy.

Let posx be the minimum position of 1 in x, such that posx≥posy. You must move posy to posx, otherwise the 1 in posx still be present in revk and it will be not optimal.

So, the solution is next: reverse x and y, find posy, find posx≥posy, print posx−posy.

Solution (adedalic)1202B - You Are Given a Decimal String...

Idea: adedalic

Tutorial1202B - You Are Given a Decimal String...All you need to know to solve this task is the minimal number of steps to move from any digit a to any digit b for fixed x and y (let's denote it as ds[a][b]). Shortest path? BFS? Floyd? Of course, you can use it, but you can think a little harder and save nerves and time.

Since order of choosing operations x and y doesn't matter for transferring from a to b, so only number of x-s and y-s are matter. Let's denote them as cntx and cnty. Since adding any fixed value 10 times are meaningless, so cntx,cnty<10.

Now you can, for each x<10, for each y<10, for each a<10 iterate over all possible cntx<10 and cnty<10. Digit b you'd move to is equal to (a+cntx⋅x+cnty⋅y)mod10. Just relax value of ds[a][b] by cntx+cnty.

Now you can, for each x and y, calculate the answer by iterating over string s by summing ds[s[i]][s[i+1]]−1 (number of inserted values is less by one than number of steps).

But, it will work only in C++, since the language is fast and 2⋅108 basic operations are executed in less than 0.5 second.

But the model solution is written in Kotlin. How is it? The string s can be long, but there are only 10×10 different neighbouring digits, so you can just one time precalculate cf[a][b] — the number of such i that s[i]=a and s[i+1]=b. And calculate the answer not by iterating over s but by multiplying ds[a][b] by cf[a][b].

The result complexity is O(|s|+A5), where A=10. But O(A2(n+A3)) will pass on fast languages like C++.

P.S.: There are no real problem with I/O — both Python and Kotlin read one string up to 2⋅106 in less than 0.5 seconds.

Solution (adedalic)1202C - You Are Given a WASD-string...

Idea: adedalic

Tutorial1202C - You Are Given a WASD-string...The problem asks us to maintain the bounding box while inserting the character of one of 4 types between every adjacent characters in s. Of course, we can do it, but do we really need to do it in such cumbersome way?

Let's think a little. Inserting 'W' or 'S' doesn't affect the width of the bounding box, and 'A' or 'D' doesn't affect the height. So, they are absolutely independent! And we can divide our WASD-string on WS-string and AD-string. Moreover, inserting 'W' or 'S' in WS-string and 'A' or 'D' in AD-string is almost same thing, so we don't even need to write different code for different string!

How to handle only WS-string? Let's replace 'W' as +1 and 'S' as −1 and suppose that we started in position 0. Then the position, where we go after i commands, is just prefix sum of first i elements (i≥0). Then the length of the bounding box is (maximum position - minimum position + 1). The maximum (minimum) position is a maximum (minimum) element in array of prefix sums pSum.

What the inserted value do? It add ±1 to suffix of pSum. Let's choose, for example, +1. The +1 can't decrease the maximum, but can increase the minimum, so we need to place it somewhere before all minimums in pSum (or before the first minimum). But, if we place it before any of maximum elements then we will increase it and prevent decreasing the length of bounding box. So we need to place +1 somewhere after all maximums on pSum (or after the last maximum). And here goes the solution: find position firstMin of the first minimum in pSum and position lastMax of the last maximum. If lastMax<firstMin then we can insert +1 and decrease the length of bounding box (but, since, we insert command that move robot, we can't achieve bounding box of length <2).

What to do with −1? Just multiply pSum by −1 and now we can insert +1 instead of −1 in absolutely same manner.

What to do with AD-string? Denote 'A' as +1 and 'D' as −1 and everything is absolutely the same.

Solution (adedalic)1202D - Print a 1337-string...

Idea: Roms

Tutorial1202D - Print a 1337-string...Let's consider the following string 1333…3337. If digit 3 occurs x times in it, then string have x(x−1)2 subsequences 1337.

Let's increase the number of digits 3 in this string while condition x(x−1)2≤n holds (x is the number of digits 3 in this string). The length of this string will not exceed 45000 because 45000(45000−1)2>109. The value rem=n−x(x−1)2 will not exceed 45000 as well.

All we have to do is increase the number of subsequences 1337 in the current string by rem. So if we add rem digits 7 after the first two digits 3 we increase the number of subsequences 1337 by rem. The string s will look like this: 13377…7733…337, where sequence 77…77 consists of exactly rem digits 7 and sequence 33…33 consists of exactly x−2 digits 3.

Solution (Roms)1202E - You Are Given Some Strings...

Idea: Roms

Tutorial1202E - You Are Given Some Strings...Let's look at any occurrence of arbitrary pair si+sj. There is exactly one special split position, where the si ends and sj starts. So, instead of counting occurrences for each pair, we can iterate over the position of split and count the number of pairs. This transformation is convenient, since any si, which ends in split position can be paired with any sj which starts here.

So, all we need is to calculate for each suffix the number of strings si, which starts here, and for each prefix — the number of strings si, which ends here. But calculating the prefixes can be transformed to calculating suffixes by reversing both t and all si.

Now we need, for each position pos, calculate the number of strings si which occur from pos. It can be done by Aho-Corasick, Suffix Array, Suffix Automaton, Suffix Tree, but do we really need them since constrains are pretty low? The answer is NO. We can use sqrt-heuristic!

Let's divide all si in two groups: short and long. The si is short if |si|≤MAG. There are no more than ∑|si|MAG long strings and, for each such string, we can find all its occurrences with z-function (or prefix-function). It will cost as O(∑|si|MAG⋅|t|+∑|si|).

What to do with short strings? Let's add them to trie! The trie will have O(∑|si|) vertices, but only MAG depth. So we can, for each pos, move down through the trie, while counting the occurrences, using only s[pos..(pos+MAG)] substring. It will cost us O(|t|⋅MAG).

So, if we choose MAG=∑|si|−−−−−√ we can acquire O(∑|si|+|t|∑|si|−−−−−√) complexity, using only basic string structures.

Solution (adedalic)1202F - You Are Given Some Letters...

Idea: adedalic

Tutorial1202F - You Are Given Some Letters...Let's introduce the slightly naive solution. Iterate over all values for periods and check the possibility of each one being correct.

The conditions for some period k can be formulated the following way. g=n/k (n=a+b is the total length of the string) is the number of full periods of length k. Let's find at least one such pair cnta and cntb such that cnta+cntb=x and the remainder part of the string can be filled with a−cnta⋅g letters 'A' and b−cntb⋅g letters 'B'. By easy construction one can deduce that the conditions of a−cnta⋅g≤cnta and b−cntb⋅g≤cntb are enough. Thus cnta should be greater or equal to ag+1 and cntb≥bg+1.

In order to move to the faster solution one should also remember that both remainder parts a−cnta⋅g and b−cntb⋅g should be non-negative.

Let's learn how to solve the problem for the whole range of lengths which all have the number of full periods equal to the same value g. Let this range be [l;r]. From the aforementioned formulas one can notice that the restrictions on both cnta and cntb don't depend on the length itself but only on value of g. To be more specific:

ag+1≤cnta≤agbg+1≤cntb≤bgThe lowest and the highest values for cnta and cntb will be the following:

alow=⌈ag+1⌉ahigh=⌊ag⌋blow=⌈bg+1⌉bhigh=⌊bg⌋It is claimed that every value between alow+blow and ahigh+bhigh exists if the values are valid (alow≤ahigh and blow≤bhigh).

The full proof about the given conditions being sufficient and the existence of every value on that range is left to the reader. Some kind of a hint might be the suggestion to check how the inequalities change on the transition from some period k to k+1.

Restrict the values by l and r to count each answer on exactly one range of lengths. Finally, the value of min(r,ahigh+bhigh)−max(l,alow+blow)+1 is added to the answer.

The number of ranges with the same g is O(n−−√).

Overall complexity: O(n−−√).

Educational Codeforces Round 69 Editorial

By awoo, history, 4 years ago, translation, In English1197A - DIY Wooden Ladder

Idea: adedalic

Tutorial1197A - DIY Wooden LadderSince all planks have length at least 1 so we can take any n−2 planks as steps. So, all we need is to maximize the length of base planks. We can take the first and second maximum as base, then the answer is minimum among second maximum - 1 and n−2.

Solution (adedalic)1197B - Pillars

Idea: BledDest

Tutorial1197B - PillarsSuppose we have a disk that is smaller than both of its neighbours. Then it's impossible to collect all the disks on the same pillar: eventually we will put this disk on the same pillar with one of its neighbours, and then we can't put the other neighbouring disk on the same pillar since it is greater than the middle disk.

Okay, and what if there is no disk that is strictly smaller than both of its neighbours? Let k be the index of the largest disk. ak−1<ak, that implies ak−2<ak−1, and so on. ak+1<ak, ak+2<ak+1, and so on. It means that the array a is sorted in ascending until the index k, and after that it is sorted in descending order. If this condition is met, then we can collect all the disks on the pillar k one by one, starting with the disk having radius n−1 and ending with the disk having radius 1.

So the only thing that we need to check is the following condition: array a is sorted in ascending order until ak=n, and then it is sorted in descending order.

Solution (BledDest)1197C - Array Splitting

Idea: Roms

Tutorial1197C - Array SplittingLet's carefully look at the coefficients with which the elements of the array will be included in the answer.

If pair of adjacent elements ai and ai+1 belong to different subarrays then element ai will be included in the answer with coefficient 1, and element ai+1 with coefficient −1. So they add value ai−ai+1 to the answer.

If element belongs to subarray with length 1 then it will be included in the sum with coefficient 0 (because it will be included with coefficient 1 and −1 simultaneously). Elements at positions 1 and n will be included with coefficients −1 and 1 respectively.

So initially our answer is an−a1. All we have to do is consider n−1 values a1−a2,a2−a3,…,an−1−an and add up the k−1 minimal ones to the answer.

Solution (Roms)1197D - Yet Another Subarray Problem

Idea: BledDest

Tutorial1197D - Yet Another Subarray ProblemAt first let's solve this problem when m=1 and k=0 (it is the problem of finding subarray with maximum sum). For each position from 1 to n we want to know the value of maxli=max1≤j≤i+1sum(j,i), where sum(l,r)=∑k=lk≤rak, and sum(x+1,x)=0.

We will calculate it the following way. maxli will be the maximum of two values:

0 (because we can take segments of length 0);ai+maxli−1.The maximum sum of some subarray is equal to max1≤i≤nmaxli.

So, now we can calculate the values of besti=max0≤len,i−len⋅m≥0(sum(i−len⋅m+1,i)−len∗k) the same way.

besti is the maximum of two values:

0;sum(i−m+1,i)−k+besti−m.After calculating all values besti we can easily solve this problem. At first, let's iterate over the elements besti. When we fix some element besti, lets iterate over the value len=1,2,…,m and update the answer with value besti+sum(i−len,i−1)−k.

Solution (Roms)1197E - Culture Code

Idea: adedalic

Tutorial1197E - Culture CodeLet's, at first, sort all matryoshkas by increasing its inner volume ini. Then each nested subset will appear as subsequence in its "canonical" order. Now we'll write the DP with d[i]=(x,y) — the minimum extra space x and number of such subsequences y among all nested subsets, where the i-th doll is minimal. Why minimal (not maximal, for example)? It's just easier transitions (and easier proof).

There are two main cases. If there isn't j, such that outi≤inj then we can't put the i-th doll inside any other. So, d[i]=(ini,1).

Otherwise, we must put the i-th doll inside other doll (otherwise, the subset won't be a big enough). If we put the i-th doll inside the j-th doll then we extra space of such subset is equal to d[j].first−(outi−ini). Since we minimize the extra space, thend[i].first=minouti≤inj(d[j].first−(outi−ini))=minouti≤inj(d[j].first)−(outi−ini).Since we sorted all matryoshkas, so there is a position pos such that ∀j≥pos:outi≤inj and d[i].first=minj=posn(d[j].first)−(outi−ini). The d[i].second is just a sum from all minimums.

As you can see: we can store d[i] in Segment Tree with minimum + number of minimums. Why in the second transition we will build only big enough subsets? It's because not big enough subsets are not optimal in terms of minimality of extra space.

The result complexity is O(nlog(n)).

Solution (adedalic)1197F - Coloring Game

Idea: BledDest

Tutorial1197F - Coloring GameSuppose there is only one strip and we want to count the number of ways to paint it. We can do it with some dynamic programming: let dpi,r1,r2,r3 be the number of ways to paint first i cells of the strip so that r1 denotes the result of the game if it starts in the last cell (r1=0 if the player that makes a turn from this state loses, or r1=1 if he wins), r2 — the result if the game starts in the second-to-last, and so on. Then, if we paint the next cell, we can easily determine the result of the game starting in it, using the values of ri and the set of possible moves: if there is a value ri=0 such that we can move the chip i cells backwards from the cell we just painted, then that cell is a winning one (if the game starts in it, the first player wins), otherwise it is a losing one.

This dynamic programming works too slow since the strip can be very long, but we can skip long uncolored segments converting the transitions of this dp into matrix-vector multiplication: each possible combination of values of (r1, r2, r3) can be encoded as a number from 0 to 7, and we may construct a 8×8 transition matrix T: Ti,j will be equal to the number of ways to color one cell so that the previous values of (r1, r2, r3) have code i, and the next values have code j. To model painting k consecutive uncolored segments, we may compute Tk with fast exponentiation method. Now we can solve the problem for one strip.

What changes if we try to apply the same method to solve the problem with many strips? Unfortunately, we can't analyze each cell as "winning" or "losing" now, we need more information. When solving a problem related to a combination of acyclic games, we may use Sprague-Grundy theory (you can read about it here: https://cp-algorithms.com/game_theory/sprague-grundy-nim.html). Instead of marking each cell as "winning" or "losing", we can analyze the Grundy value of each cell. When considering a strip, we should count the number of ways to color it so that its Grundy is exactly x (we should do it for every possible value of x), which can help us to solve the initial problem with the following dynamic programming: zi,j is the number of ways to color i first strips so that the Grundy value of their combination is exactly j.

The only thing that's left to consider is how do we count the number of ways to color a single strip so that its Grundy value is fixed. We can to it by modifying the method described in the first paragraph: let dpi,r1,r2,r3 be the number of ways to paint i first cells so that the Grundy value of the last cell is r1, the value of the previous-to-last cell is r2, and so on. Since we have only 3 possible moves, the Grundy values are limited to 3, and each possible combination of values of (r1, r2, r3) can be encoded as a number from 0 to 63. The transition matrix T that allows us to skip long uncolored segments will be a 64×64 one, so if we will just exponentiate it every time we want to skip a segment, we'll get TL — but we can optimize it by precalculating T, T2, T4, ..., T230 and using matrix-vector multiplication instead of matrix-matrix multiplication every time we skip an uncolored segment.

Educational Codeforces Round 68 Editorial

By awoo, history, 4 years ago, translation, In English1194A - Remove a Progression

Idea: adedalic

Tutorial1194A - Remove a ProgressionAfter some simulation of the given algorithm (in your head, on paper or on a computer) we can realize that exactly all odd numbers are erased. So, all even numbers remain, and the answer is 2x.

Solution (adedalic)1194B - Yet Another Crosses Problem

Idea: MikeMirzayanov

Tutorial1194B - Yet Another Crosses ProblemLet's consider each cell as a center of a cross and take the fastest one to paint. Calculating each time naively will take O(nm(n+m)) overall, which is too slow. Notice how the answer for some cell (x,y) can be represented as cntrow[x]+cntcolumn[y]− (1 if a[x][y] is white else 0), where cntrow[i] is the number of white cells in row i and cntcolumn[i] is the same for column i. The first two terms can be precalculated beforehand.

Overall complexity: O(nm) per query.

Solution (PikMike)1194C - From S To T

Idea: Roms

Tutorial1194C - From S To TIf the answer exists then each element of string s matches with some element of string t. Thereby string s must be a subsequence of string t.

Let f(str,a) equal to the number of occurrences of the letter a in the string str. Then for any letter a condition f(s,a)+f(p,a)≥f(t,a) must be hold.

So the answer to the query is YES if following conditions hold:

string s is subsequence of string t;f(s,a)+f(p,a)≥f(t,a) for any Latin latter a.Solution (Roms)1194D - 1-2-K Game

Idea: adedalic

Tutorial1194D - 1-2-K GameLet's determine for each cell whether it's winning or losing position (we can do it since the game is symmetric and doesn't depend on a player). The 0-th cell is obviously losing, the 1-st and 2-nd ones is both winning, since we can move to the 0-th cell and put our opponent in the losing position (here comes criterion: the position is winning if and only if there is a move to the losing position).

If k is large enough, then the 0-th, 3-rd, 6-th, 9-th... are losing. So here comes divisibility by 3. If  then this move doesn't change anything, since if  then  so it's not the move to the losing position, so x doesn't become the winning one.

Otherwise, if  then the k-th positions becomes winning, but the (k + 1)-th cell is losing (all moves are to (k - 1)-th, k-th or 1-st cells and all of them are winning). The (k + 2)-th and (k + 3)-th cells are winning and so on. In the end, we came up with cycle of length k + 1 where position divisible by 3 except k are losing.

All we need to do is small case work.

Solution (adedalic)1194E - Count The Rectangles

Idea: adedalic

Tutorial1194E - Count The RectanglesLet's iterate over the lower horizontal segment. Denote its coordinates as (xl,yh) and (xr,yh), where xl<xr.

We call vertical segment (xi,1, yi,1), (xi,2, yi,2) good, if followings conditions holds:

xl≤xi,1=xi,2≤xr;min(yi,1,yi,2)≤yh.Now let's use the scanline method. At first, for each good vertical segment i we increment the value of element in position xi,1 in some data structure (for example, Fenwick Tree). Next we will process two types of queries in order of increasing their y-coordinate:

horizontal segments with coordinates (xi,1, yi,1), (xi,2, yi,2);upper point of some vertical segment with coordinates (xi,yi).And if two events of different types have the same y-coordinate then the event of first type must be processed first.

For event of first type we need to find sum on range [xi,1,xi,2] (xi,1<xi,2) in our data structure. Let's denote this sum as s. Then we need to add s(s−1)2 to the answer (because we have s vertical segments which intersect with both fixed horizontal segments and we can choose two of them in so many ways).

For event of second type we just need decrement the value of element in position xi in our data structure.

Solution (Roms)1194F - Crossword Expert

Idea: adedalic

Tutorial1194F - Crossword ExpertLet's use (as usual) linearity of an expected value. E=∑i=1nE(I(i)) where I(i) is an indicator function and equal to 1 iff Adilbek will be able to solve the i-th crossword.

How to calculate I(i)? If ∑j=1iti>T then I(i) is always 0. On the other hand, if ∑j=1i(ti+1)=∑j=1iti+i≤T — I(i) is always 1. Otherwise, we need to calculate E(I(i))=P(i) — the needed probability.

To calculate P(i) we can iterate over k — the number of crosswords among first i ones which will require extra time. Obviously, if k>T−∑j=1iti then we don't have enough time to solve the i-th crossword, also k≤i. Let's denote mi=min(T−∑j=1iti,i). There are (ik) ways to choose crosswords with extra time among all 2i variants. So the final formula is following:P(i)=12i∑k=0mi(ik).The only problem is the efficiency. But we can find out several interesting properties. At first, mi+1≤mi+1. The other one: since (nk)+(nk+1)=(n+1k+1), then 2⋅∑k=0x(nk)+(nx+1)=∑k=0x+1(n+1k). And this exactly the efficient way to transform P(i)⋅2i to P(i+1)⋅2i+1: by multiplying and adding one coefficient we can transform the prefix sum of the i-th row to the prefix sum of the i+1 row. And to reduce the length of the prefix sum we can just subtract unnecessary coefficients.

In result, the total complexity is O(n) (maybe with extra log factor because of modular arithmetic).

Solution (adedalic)1194G - Another Meme Problem

Idea: vovuh

Tutorial1194G - Another Meme ProblemLet's fix an irreducible fraction XY such that 1≤X,Y≤9. Obviously, each good fraction is equal to exactly one of such irreducible fractions. So if we iterate on X and Y, check that gcd(X,Y)=1 and find the number of good fractions that are equal to XY, we will solve the problem.

Okay, suppose we fixed X and Y. Any good fraction can be represented as zXzY, where z is some positive integer. Let's try all possible values of z, and for them check whether they correspond to a good fraction.

How do we try all values of z without iterating on them? Let's construct the decimal representation of z from the least significant digit to the most. As soon as we fix k least significant digits of z, we know k least significant digits of zX and zY. So let's try to use digit DP to try all possible values of z.

Which states do we have to consider? Of course, we need to know the number of digits we already placed, so that will be the first state. After we placed k digits, we know first k digits of the numerator of the fraction; but to get the value of digit k+1, knowing only the value of the corresponding digit in z is not enough: there could be some value carried over after multiplying already placed digits by X. For example, if X=3, and we placed the first digit of z and it is 7, we know that the first (least significant) digit of zX is 1, and we know that after fixing the second digit of z we should add 2 to it to get the value of this digit in zX, since 2 is carried over from the first digit. So, the second state of DP should represent the number that is carried over from the previous digit in the numerator, and the third state should do the same for the denominator.

Okay, in order to know whether the fraction is good, we have to keep track of some digits in the numerator and denominator. If x′y′=XY, 1≤x′≤9 and 1≤y′≤9, then we have to keep track of the digit representing x′ in the numerator and the digit representing y′ in the denominator. So we have two additional states that represent the masks of "interesting" digits we met in the numerator and in the denominator.

The only thing that's left to check is that both zX and zY are not greater than n. Let's construct the decimal representation of n and prepend it with some leading zeroes; and keep constructing the numerator and the denominator until they have the same number of digits as the decimal representation as n. Then we can compare the representation of, for example, numerator with the representation of n as strings. Comparing can be done with the following technique: let's keep a flag denoting whether the number represented by the least significant digits of the numerator is less or equal than the number represented by the same digits from n. When we place another digit of the numerator, we can get the new value of this flag as follows: if new digit of the numerator is not equal to the corresponding digit of n, then the value of the flag is defined by comparing this pair of digits; otherwise the value of the flag is the same as it was without this new digit. Of course, we should do the same for the denominator.

Okay, now we can actually start coding this DP: dp[k][carry1][carry2][comp1][comp2][mask1][mask2] is the number of possible ways to put k least significant digits in z in such a way that:

the value carried over to the next digit of the numerator is carry1 (and carry2 for the denominator);comp1 denotes whether the current numerator is less or equal to the number represented by k least significant digits of n (comp2 does the same for the denominator);mask1 denotes which "interesting" digits we already met in the numerator (of course, mask2 does the same for the denominator).If you are feeling confident in your programming abilities, you can just start implementing this DP on a seven-dimensional array. I was too afraid to do it (but, looking at participants' solutions, I realize that it sounds much more scary than it looks in the code), so I decided to write the model solution using a structure representing each state, and a map to store all these structures. This is a common technique: when a dynamic programming solution you come up with has some really complex states and transitions, it is sometimes better to use some self-implemented structures to define these states and store them in a map or a hashmap. Some advantages of this technique are:

it's sometimes much easier to code (the code may be longer than the same solution with regular DP stored in a multi-dimensional array, but it's easier to write and understand this code);if most states are unreachable, they won't even appear in our map, so we skip them altogether;it is easy to add some optimizations related to reducing the number of states. For example, the number of different values for mask1 and mask2 may be too much, so we can use the following optimization: as soon as we find some pair of numbers in mask1 and mask2 that can represent x′ and y′, we can change these masks to some values that will mark that they are "finished" and stop updating them at all.

Educational Codeforces Round 67 Editorial

By awoo, history, 4 years ago, translation, In English1187A - Stickers and Toys

Idea: MikeMirzayanov

Tutorial1187A - Stickers and ToysNote, that there are exactly n−t eggs with only a sticker and, analogically, exactly n−s with only a toy. So we need to buy more than max(n−t,n−s) eggs, or exactly max(n−t,n−s)+1.

Solution (adedalic)1187B - Letters Shop

Idea: MikeMirzayanov

Tutorial1187B - Letters ShopLet's construct the answer letter by letter.

How to get enough letters 'a' for the name? Surely, the taken letters will be the first 'a', the second 'a', up to cnta-th 'a' in string s, where cnta is the amount of letters 'a' in the name. It's never profitable to skip the letter you need.

Do the same for all letters presented in the name. The answer will the maximum position of these last taken letters.

How to obtain the cnta-th letter fast? Well, just precalculate the list of positions for each letter and take the needed one from it.

Overall complexity: O(n+m).

Solution (PikMike)1187C - Vasya And Array

Idea: Roms

Tutorial1187C - Vasya And ArrayLet's consider array b1,b2,…,bn−1, such that bi=ai+1−ai.

Then subarray al,al+1,…,ar is sorted in non-decreasing order if and only if all elements bl,bl+1,…,br−1 are greater or equal to zero.

So if we have fact ti=1,li,ri, then all elements bli,bli+1,…,bri−1 must be greater or equal to zero.

Let's create the following array b: bi=0 if there is such a fact tj,lj,rj that tj=1,lj≤i<rj, and bi=−1 otherwise.

After that we create the following array a: a1=n, and for all other indexes ai=ai−1+bi−1.

This array a satisfies all facts ti,li,ri such that ti=1. So all we have to do is check that all remaining facts are satisfied.

Solution (Roms)1187D - Subarray Sorting

Idea: Roms

Tutorial1187D - Subarray SortingLet's reformulate this problem in next form: we can sort only subarray of length 2 (swap two consecutive elements i and i+1 if ai>ai+1). It is simular tasks because we can sort any array by sorting subbarray of length 2 (for example bubble sort does exactly that).

Now lets look at elements a1 and b1. If a1=b1 then we will solve this task for arrays a2,a3,…,an and b2,b3,…,bn.

Otherwise lets look at minimum position pos such that apos=b1 (if there is no such position then answer to the problem is NO). We can move element apos to the beginning of array only if all elements a1,a2,…,apos−1 greater then apos. In other words any index i such that ai<apos must be greater then pos. And if this condition holds, then we just delete element apos and solve task for arrays a1,a2,…,apos−2,apos−1,apos+1,apos+2,…,an and b2,b3,…,bn.

But instead of deleting this element apos we will change information about minimum index i such that b1=ai. This index will be the minimum index i such that i>pos and apos=ai.

For do this we will maintain n stacks s1,s2,…,sn such that for any element x of stack si condition ax=i holds and moreover all elements in stacks are sorted in ascending order (the top element of stack is minimal). For example if a=[1,2,3,1,2,2], then s1=[1,4], s2=[2,5,6], s3=[3], s4,s5,s6=[]. For finding minimum element on top of stacks s1,s2,…,si we can use some data structure (for example segment tree).

Solution (Roms)1187E - Tree Painting

Idea: BledDest

Tutorial1187E - Tree PaintingI should notice that there is much simpler idea and solution for this problem without rerooting technique but I will try to explain rerooting as the main solution of this problem (it can be applied in many problems and this is just very simple example).

What if the root of the tree is fixed? Then we can notice that the answer for a subtree can be calculated as dpv=sv+∑to∈ch(v)dpto, where ch(v) is the set of children of the vertex v. The answer on the problem for the fixed root will be dproot.

How can we calculate all possible values of dproot for each root from 1 to n fast enough? We can apply rerooting! When we change the root of tree from the vertex v to the vertex to, we can notice that only four values will change: sv,sto,dpv and dpto. Firstly, we need to cut the subtree of to from the tree rooted at v. Let's subtract dpto and sto from dpv, then let's change the size of the subtree of v (subtract sto from it). Now we have the tree without the subtree of to. Then we need to append v as a child of to. Add sv to sto and add sv and dpv to dpto. Now we have to as a root of the tree and can update the answer with dpto. When we changes the root of the tree back from to to v, we just need to rollback all changes we made.

So, overall idea is the following: calculate sizes of subtrees for some fixed root, calculate dynamic programming for this root, run dfs which will reroot the tree with any possible vertex and update the answer with the value of dynamic programming for each possible root.

The code of function that reroots the tree seems like this:

void dfs(int v, int p = -1) {	ans = max(ans, dp[v]);	for (auto to : g[v]) {		if (to == p) continue;				dp[v] -= dp[to];		dp[v] -= siz[to];		siz[v] -= siz[to];		siz[to] += siz[v];		dp[to] += siz[v];		dp[to] += dp[v];				dfs(to, v);				dp[to] -= dp[v];		dp[to] -= siz[v];		siz[to] -= siz[v];		siz[v] += siz[to];		dp[v] += siz[to];		dp[v] += dp[to];	}}Solution (Vovuh)Alternative solution (PikMike)1187F - Expected Square Beauty

Idea: Roms and adedalic

Tutorial1187F - Expected Square BeautyAs usual with tasks on an expected value, let's denote Ii(x) as indicator function: Ii(x)=1 if xi≠xi−1 and 0 otherwise; I1(x)=1. Then we can note that B(x)=∑i=1nIi(x). Now we can make some transformations: E(B2(x))=E((∑i=1nIi(x))2)=E(∑i=1n∑j=1nIi(x)Ij(x))=∑i=1n∑j=1nE(Ii(x)Ij(x)).

Now we'd like to make some casework:

if |i−j|>1 (i and j aren't consecutive) then Ii(x) and Ij(x) are independent, that's why E(Ii(x)Ij(x))=E(Ii(x))E(Ij(x));if i=j then E(Ii(x)Ii(x))=E(Ii(x));|i−j|=1 need further investigation.For the simplicity let's transform segment [li,ri] to [li,ri) by increasing ri=ri+1.

Let's denote qi as the probability that xi−1=xi: qi=max(0,min(ri−1,ri)−max(li−1,li)(ri−1−li−1)(ri−li)) and q1=0. Let's denote pi=1−qi. In result, E(Ii(x))=pi.

The final observation is the following: E(Ii(x)Ii+1(x)) is equal to the probability that xi−1≠xi and xi≠xi+1 and can be calculated by inclusion-exclusion principle: E(Ii(x)Ii+1(x))=1−qi−qi+1+P(xi−1=xi & xi=xi+1), where P(xi−1=xi & xi=xi+1)=max(0,min(ri−1,ri,ri+1)−max(li−1,li,li+1)(ri−1−li−1)(ri−li)(ri+1−li+1)).

In result, E(B2(x))=∑i=1n(pi+pi∑|j−i|>1pj+E(Ii−1(x)Ii(x))+E(Ii(x)Ii+1(x))) and can be calculated in O(nlogMOD) time.

Solution (adedalic)1187G - Gang Up

Idea: BledDest

Tutorial1187G - Gang UpFirst of all, one crucial observation is that no person should come to the meeting later than 100 minutes after receiving the message: the length of any simple path in the graph won't exceed 49, and even if all organization members should choose the same path, we can easily make them walk alone if the first person starts as soon as he receives the message, the second person waits one minute, the third person waits two minutes, and so on.

Let's model the problem using mincost flows. First of all, we need to expand our graph: let's create 101 "time layer" of the graph, where i-th layer represents the state of the graph after i minutes have passed. The members of the organization represent the flow in this graph. We should add a directed edge from the source to every crossroad where some person lives, with capacity equal to the number of persons living near that crossroad (of course, this edge should lead into 0-th time layer, since everyone starts moving immediately). To model that some person can wait without moving, we can connect consecutive time layers: for every vertex representing some crossroad x in time layer i, let's add a directed edge with infinite capacity to the vertex representing the same crossroad in the layer i+1. To model that people can walk along the street, for every street (x,y) and every layer i let's add several edges going from crossroad x in the layer i to crossroad y in the layer i+1 (the costs and the capacities of these edges will be discussed later). And to model that people can attend the meeting, for each layer i let's add a directed edge from the vertex representing crossroad 1 in that layer to the sink (the capacity should be infinite, the cost should be equal to ci).

Okay, if we find a way to model the increase of discontent from the companies of people going along the same street at the same moment, then the minimum cost of the maximum flow in this network is the answer: maximization of the flow ensures that all people attend the meeting, and minimization of the cost ensures that the discontent is minimized. To model the increase of discontent from the companies of people, let's convert each edge (x,y) of the original graph into a large set of edges: for each layer i, let's add k edges with capacity 1 from the crossroad x in the layer i to the crossroad y in the layer i+1. The first edge should have the cost equal to d, the second edge — equal to 3d, the third — 5d and so on, so if we choose z minimum cost edges between this pair of nodes, their total cost will be equal to dz2. Don't forget that each edge in the original graph is undirected, so we should do the same for the node representing y in layer i and the node representing x in layer i+1.

Okay, now we have a network with ≈5000 vertices and ≈500000 edges, and we have to find the minimum cost flow in it (and the total flow does not exceed 50). Strangely enough, we could not construct a test where the basic implementation of Ford-Bellman algorithm with a queue runs for a long time (but perhaps it's possible to fail it). But if you are not sure about its complexity, you can improve it with the following two optimizations:

use Dijkstra with potentials instead of Ford-Bellman with queue;compress all edges that connect the same nodes of the network into one edge with varying cost.

Educational Codeforces Round 66 Editorial

By awoo, history, 4 years ago, translation, In English1175A - From Hero to Zero

Idea: Roms

Tutorial1175A - From Hero to ZeroIt's always optimal to divide by k whenever it's possible, since dividing by k equivalent to decreasing n by nk (k−1)≥1.

The only problem is that it's too slow to just subtract 1 from n each time, since in the worst case we can make O(n) operations (Consider case n=1018 and k=n2 +1).

But if we'd look closer then we can just replace x times of subtract 1 with one subtraction of x. And to make n is divisible by k we should make x=(nmodk) subtractions.

Solution (Roms)1175B - Catch Overflow!

Idea: awoo

Tutorial1175B - Catch Overflow!One can notice (or actually derive using some maths) that the answer is the sum of products of nested for loops iterations for every "add" command.

Let's learn to simulate that in linear complexity. Maintain the stack of multipliers: on "for n" push the top of stack multiplied by n to the stack, on "end" pop the last value, on "add" add the top of the stack to the answer.

The problem, however, is the values are really large. Notice that once you add the value greater or equal to 232 to the answer, it immediately becomes "OVERFLOW!!!". Thus let's push not the real multiplier to the stack but min(multiplier, 232). That way the maximum value you can achieve is about 232⋅50000, which fits into the 64-bit integer.

Overall complexity: O(n).

Solution (PikMike)1175C - Electrification

Idea: adedalic

Tutorial1175C - ElectrificationFirst observation: k closest points to any point x form a contiguous subsegment ai,…,ai+k−1, so fk(x)=min(|ai−1−x|,|ai+k−x|).

Second observation: for any contiguous subsegment ai,…,ai+k−1 all points x this subsegment closest to, also form a contiguous segment [li,ri]. And, because of the nature of fk(x), value of fk(x) is minimal in borders li and ri.

So, all we need is to check all li and ri. But what is a value of ri? It's such point, that |ai−ri|≤|ai+k−ri|, but |ai−(ri+1)|>|ai+k−(ri+1)|. So, it's just in the middle of segment [ai,ai+k]. Note, that ri+1=li+1 and fk(li+1)≥fk(ri), so it's enough to check only ri-s.

In result, all we need is to find minimal possible value |ai+k−ai| and resulting x=ai+ai+k−ai2 .

Solution (adedalic)1175D - Array Splitting

Idea: adedalic

Tutorial1175D - Array SplittingLet's denote S(k) as  n∑i=k ai (just a suffix sum). And let pi be the position where starts the i-th subarray (obviously, p1=1 and pi<pi+1). Then we can make an interesting transformation:n∑i=1 ai⋅f(i)=1⋅(S(p1)−S(p2))+2⋅(S(p2)−S(p3))+⋯+k⋅(S(pk)−0)==S(p1)+(2−1)S(p2)+(3−2)S(p3)+⋯+(k−(k−1)))S(pk)==S(p1)+S(p2)+S(p3)+⋯+S(pk).So, our task is equivalent to choosing sum of all array S(1) and k−1 different suffix sums. And we want to maximize their total sum.

That's why we can just greedily take k−1 maximum suffix sums along with sum of all array.

Solution (Roms)1175E - Minimal Segment Cover

Idea: adedalic

Tutorial1175E - Minimal Segment CoverLet's take a look at a naive approach at first.

That approach is greedy. Let's find such an interval which starts to the left or at x and ends as much to the right as possible. Set x to its right border. Continue until either no interval can be found or y is reached.

The proof basically goes like this. Let there be some smaller set of intervals which cover the query, these can be sorted by left border (obviously their left borders are pairwise distinct). Compare that set to the greedy one, take a look at the first position where best set's interval has his r less than the greedy set's r. You can see that choosing interval greedily will still allow to have the rest of best set intervals, making the greedy choice optimal.

Let's implement it in O(nlogn+nm). For each position from 0 to 5⋅105 you can precalculate the index of such an interval that it starts to the left or at this position and ends as much to the right as possible. To do this sort all intervals by their left border, then iterate over positions, while maintaining the maximum right border achieved by intervals starting to the left or at the current position. The query is now straightforward.

Now there are two main ways to optimize it.

You can do it binary lifting style: for each interval (or position) precalculate the index of the interval taken last after taking 2k intervals greedily and use this data to answer queries in O(logn).

You can also do it path compression style. Let's process the queries in the increasing order of their right borders. Now do greedy algorithm but for each interval you use remember the index of the last reached interval. Now the part with answering queries is O(n+m) in total because each interval will be jumped from no more than once.

Overall complexity: O((n+m)logn) / O(nlogn+mlogm).

Solution 1 (PikMike)Solution 2 (PikMike)1175F - The Number of Subpermutations

Idea: Roms

Tutorial1175F - The Number of SubpermutationsAt first, let's represent permutations in the next form. We assign to all numbers from 1 to n random 128-bit strings, so the i-th number gets the string hi. Then the permutation of length len can be hashed as h1⊕h2⊕⋯⊕hlen, where ⊕ is bitwise exclusive OR (for example, 0110⊕1010=1100). This representation is convenient because if we have two sets of numbers with a total number of elements equal to len (let's represent them as s1,s2,…sm and t1,t2,…tk, k+m=len), we can easily check whether their union is a permutation of length len (condition hs1⊕hs2⊕⋯⊕hsm⊕ht1⊕ht2⊕…htk=h1⊕h2⊕⋯⊕hlen must be hold).

Let's denote f(l,r) as hal⊕hal+1⊕⋯⊕har.

Now let's iterate over position i such that ai=1 and calculate the number of permutations that contain this element. To do it, let's iterate over the right boundary r and suppose, that maximum element of permutation len (and its length at the same time) is one of positions i+1,i+2,…,r. If it's true, then the subpermutation should be on the positions r−len+1,r−len+2,…,r. And to check that this segment is a subpermutation we should just compare f(r−len+1,r) and h1⊕h2⊕⋯⊕hlen.

Thus, we will calculate all permutations in which the position of the maximum is to the right of the position of the 1. To calculate all permutations we need to reverse array a and repeat this algorithm, and then add the number of ones in the array a.

Solution (Roms)1175G - Yet Another Partiton Problem

Idea: adedalic

Tutorial1175G - Yet Another Partiton ProblemImportant note: the author solution is using both linear Convex hull trick and persistent Li Chao tree. As mentioned in commentaries, applying the Divide-and-Conquer technique can help get rid of Li Chao tree. More about both structures you can read in this article.

Let's try to write standard dp we can come up with (arrays will be 0-indexed). Let dp[k][i] be the minimal weight if we splitted prefix of length i in k subsegments. Then we can calculate it as: dp[k][i]= min0≤j<i (dp[k−1][j]+(i−j)⋅ maxj≤k<i (a[k])) [1]. Maximums on segments are inconvenient, let's try to group segments [j,i) by the value of max.

So, we can find such sequence of borders j0=i−1>j1>j2>…, where for each j∈(jl+1,jl]  maxj≤k<i (a[k])=a[jl]. In other words, j0=i−1 and jl+1 is the closest from the left position, where a[jl+1]≥a[jl]. Note, that we can maintain this sequence with stack of maximums.

Ok, then for each interval (jl+1,jl] equation [1] transforms to:minjl+1<j≤jl (dp[k−1][j]+(i−j)⋅a[jl])=a[jl]⋅i+ minjl+1<j≤jl (−j⋅a[jl]+dp[k−1][j])==a[jl]⋅y+ minjl+1<j≤jl (−j⋅x+dp[k−1][j])|y=i,x=a[jl].Why did we use variables x and y? Because there are two problems: y is needed because we iterate over i and can't recalculate everything; x is needed because sequence jl is changing over time, so do the a[jl]. But what we can already see: we can maintain for each segment Convex hull with linear functions — so we can take fl= minjl+1<j≤jl (…) in logarithmic time. Moreover, we can store values a[jl]⋅y+fl in other Convex hull to take minimum over all segments in logarithmic time.

The problems arise when we try modificate structures while iterating i. Fortunately, segments jl change not at random, but according to stack of maximums. So all we should handle are:

to merge segment on top of the stack (j1,j0] with current segment (j0,i] (in case when a[i]>a[j0]);to erase segment on top of the stack along with its value a[j0]⋅y+f0;to insert new segment on top of the stack along with its value a[j0]⋅y+f0.To handle the third type is easy, since all Convex hulls can insert elements. There will be at most O(n) such operations on a single layer k and we can ask value f0 in O(logn) and insert a line with O(logA).

To handle the second type is harder, but possible, since we can make Convex hull persistent and store its versions in the stack. Persistent Convex hull — persistent Li Chao tree. There will be also O(nk) operations in total and they cost us O(1).

To handle the first type is trickiest part. Note, that all line coefficients of one convex hull are strictly lower than all line coefficients of the other. So, we can use linear Convex hulls to make insertions to back in amortized O(1). But to merge efficiently, we should use Small-to-Large technique, that's why we should be able also push front in O(1), and, moreover, still be able to ask minimum in O(logn). And here comes the hack — deque in C++, which can push/pop front/back in amortized O(1) and also have random access iterator to make binary search possible. So, each element of every segment will be transfered O(logn) times with cost of amortized O(1) on a single layer k.

In the end, result complexity is O(nk(logC+logn)). Space complexity is O(nlogA).

Educational Codeforces Round 65 Editorial

By awoo, history, 4 years ago, translation, In English1167A - Telephone Number

Idea: Roms

Tutorial1167A - Telephone NumberTo solve this problem, we just need to find the first occurrence of the digit 8, let's denote it as x.

Now if n−x≥10 then answer is YES, otherwise NO.

Solution (Roms)1167B - Lost Numbers

Idea: vovuh

Tutorial1167B - Lost NumbersThe key fact that allows us to solve this problem is that if we analyze the pairwise products of special numbers, we will see that all of them (considering that we always multiply two different numbers) are unique. So, if we, for example, know that ai⋅aj=x, then there are only two possibilities for the values of ai and aj: x is uniquely expressed as the product of two distinct special numbers A and B, and either ai=A, aj=B, or ai=B, aj=A. This allows us to guess three numbers using two queries: we ask ai⋅aj and aj⋅ak, we uniquely determine aj as the only number that is suitable for the both pairs, and then we express ai=ai⋅ajaj and ak=aj⋅akaj.

Of course, there are easier ways to solve this problem, considering there are only 6 special numbers. For example, you could use four queries ai⋅ai+1 (for all i∈[1,4]) and try all 6! permutations, and the model solution uses exactly this approach.

Solution (BledDest)1167C - News Distribution

Idea: MikeMirzayanov

Tutorial1167C - News DistributionThe first intention after reading the problem is to reformulate it in graph theory terms. Let people be vertices, edge between two vertices x and y exists if x and y have some group in common. Basically, if person x starts distributing the news, everyone in his connectivity component recieves it. Thus, the task is to calculate the number of vertices of each vertex component.

As of now, the graph can have up to O(n2) edges (consider the case where everyone is in the same group). Let's reduce the number of edges without changing connectivity components. For each group you know for sure that people in it are in the same component. Let's connect not just every pair of vertices in it, but every pair of neighbouring ones in each group. It's easy to see that they are still in the same component.

This graph will have O(∑i=1mki) edges which is a much smaller number. You can use dfs or dsu to find the components and their sizes.

Overall complexity: O(n+∑i=1mki).

Solution (BledDest)Solution (PikMike)1167D - Bicolored RBS

Idea: adedalic

Tutorial1167D - Bicolored RBSLet d(s) be nested depth of RBS s. There is an interesting fact that max(d(r),d(b))≥⌈d(s)2⌉. From the other side we can always reach equation max(d(r),d(b))=⌈d(s)2⌉ using some approaches.

Let's look at prefix of length i of string s. Let os(i) be number of opening bracket in the prefix, cs(i) — number of closing brackets. Then we can define balance of the i-th prefix of s as bals(i)=os(i)−cs(i).

The author's approach is next:

Let's define level of pair of brackets (matched in natural way) as bals(i−1), where i is position of opening bracket of this pair. Then we will color in red all pairs with even level and in blue — with odd level.

—— Proof of max(d(r),d(b))≥⌈d(s)2⌉:

It can be shown that d(s)=max1≤i≤n(bals(i)) and exists such pos that d(s)=bals(pos).

After any coloring of s we can define number of opening/closing red (blue) brackets of pos-th prefix of s as or(pos) (ob(pos)) and cr(pos) (cb(pos)) respectively. Since os(pos)=or(pos)+ob(pos) and cs(pos)=cr(pos)+cb(pos), thenmax(balr(pos),balb(pos))=max(or(pos)−cr(pos),balb(pos))=max((os(pos)−ob(pos))−(cs(pos)−cb(pos)),balb(pos))=max((os(pos)−cs(pos))−(ob(pos)−cb(pos)),balb(pos))=max(bals(pos)−balb(pos),balb(pos))≥⌈bals(pos)2⌉=⌈d(s)2⌉.Finally,max(d(a),d(b))=max(max1≤i≤n(balr(i)),max1≤i≤n(balb(i)))=max1≤i,j≤n(max(balr(i),balb(j)))≥max(balr(pos),balb(pos))≥⌈d(s)2⌉Solution (adedalic)1167E - Range Deleting

Idea: Roms

Tutorial1167E - Range DeletingLets find the maximum number pref such that all values 1,2,…,pref form the non-descending order array. It can be done the following way. Let values 1,2,…,x form the non-descending order array. Then values 1,2,…,x,x+1 will form the non-descending order array if the first occurrence of x+1 in array a is after the last occurrence of x. In similar manner we can find the minimum number suf such that all values suf,suf+1,…,x form the non-descending order array.

Now let's find out how to get the minimum number s such that all values 1,2,…,p,s,s+1,…,x form the non-descending order array if we fixed the value p. We denote this value s for some fixed value p as f(p). Firstly, conditions s>p, suf≤s and p≤pre should hold. Secondly, there should be no such a pair (m,r) that conditions 1≤m<r≤n, 1≤ar,≤p and s≤am≤x hold. Since the condition p≤pre is satisfied, it means that s must be greater than max1≤i≤lstai, where lst is the last occurrence of p in array a.

In this way the answer is ∑i=1pref(x−f(i)+1).

Solution (Roms)1167F - Scalar Queries

Idea: adedalic

Tutorial1167F - Scalar QueriesLet's define some functions at first: indicator function I(x)=1 if x is true and 0 otherwise. lower(l,r,x) is a number of aj that l≤j≤r and aj<x. Good observation: lower(l,r,x)=∑j=rj=lI(aj<x).

Another observation: f(l,r)=∑i=li=rai⋅(lower(l,r,ai)+1).

Now, it's time to transform what we'd like to calculate:∑1≤l≤r≤nf(l,r)=∑1≤l≤r≤n∑i=li=rai⋅(lower(l,r,ai)+1)=∑1≤l≤r≤n(∑i=li=rai⋅lower(l,r,ai)+∑i=li=rai)==∑1≤l≤r≤n∑i=li=rai⋅lower(l,r,ai)+∑i=1i=nai⋅i⋅(n−i+1)Since transformation of the second sum was standard, we'll look at the first sum:∑1≤l≤r≤n∑i=li=rai⋅lower(l,r,ai)=∑i=1i=n∑1≤l≤i≤r≤nai⋅lower(l,r,ai)=∑i=1i=nai∑1≤l≤i≤r≤nlower(l,i,ai)+lower(i,r,ai)==∑i=1i=nai∑1≤l≤i∑i≤r≤nlower(l,i,ai)+lower(i,r,ai)=∑i=1i=nai((n−i+1)∑1≤l≤ilower(l,i,ai)+i∑i≤r≤nlower(i,r,ai))So, we can iterate over i and we'd like to calculate this two sums fast enough. So, more transformations:∑1≤l≤ilower(l,i,ai)=∑1≤l≤i∑j=lj=iI(aj<ai)=∑j=1j=i∑l=1l=jI(aj<ai)=∑j=1j=iI(aj<ai)⋅jSo, while iterating over i we need to make queries of two types: set value i in position ai and calculate ∑aj<aij. It can be done by BIT with coordinate compression.

∑i≤r≤nlower(i,r,ai) can be calculated in the same way iterating over i in reverse order.

Result complexity is O(nlogn).

Solution (adedalic)1167G - Low Budget Inception

Idea: adedalic

Tutorial1167G - Low Budget InceptionLet's solve the problem for a single query at first. There are two possible types of collisions: between two buildings and between a building and a ray.

Obviously, if the collision of the second type happens, then it's the building which is the closest to the bend point (from either left or right).

The less obvious claim is that among all buildings collisions, the closest is the biggest angle one. Let's boil down some possibilities of colliding buildings. Let two buildings be the same distance D from the bend point x. Then they will collide and the collision point will (x−D,1). Two buildings also collide if the left one is D+1 from x and the right one is D. Then the point of collision is (x−D+1,1). And for the opposite case the point of collision is also (x−D+1,1). These points can be easily proven by checking the distances to upper corners of each building. No other two buildings will collide.

Now that we know this, we can transition to solving a problem of checking if there exists such a pair that the distances to x from them differ by at most one. Finding such a pair with minimal D is enough. Obviously, this can be done with some sort of two pointers. However, that's not the intended solution.

Let's constuct bitset of 7000 positions to the left of the bend and to the right of the bend. AND of these bitsets will give you the pairs such that the distance D is the same for them. However, you can put 1 in points y−1 and y for each building to the left and y and y+1 for each building to the right. This way AND will give you the exact pairs you need. Use _Find_first to find the closest one.

Let collision happen on distance D. Then the collision of the first type will have angle 2⋅arctanD and the collision of the second type will have angle arctanD. The answer is the maximum of these two values. Be careful with cases where D=0.

How to process lots of queries. Let's just move the bitsets to the right while going through queries in ascending order. Bitsets can be updated in (d/32) for each query and only n buildings will be added to them in total.

Overall complexity: O(md/32+n).

Educational Codeforces Round 64 Editorial

By awoo, history, 4 years ago, translation, In English1156A - Inscribed Figures

Tutorial1156A - Inscribed FiguresFirstly, let's find out when the answer is infinite.

Obviously, any point of intersection is produced by at least a pair of consecutive figures. Take a look at every possible pair and you'll see that only square inscribed in triangle and vice verse produce infinite number of points in intersection. The other cases are finite.

From now we assume that initial sequence has no 2 and 3 next to each other. Basically, it's all triangles and squares separated by circles.

If the task was to count all pairs of intersecting figures, the solution will be the following. Square next to circle gives 4 points, triangle next to circle gives 3 points.

Unfortunately, the task asked for distinct points. Notice that there is a single subsegment which can produce coinciding points (square → circle → triangle). So you have to find each triplet (3 1 2) and subtract their count from the sum.

Overall complexity: O(n).

Solution (PikMike)1156B - Ugly Pairs

Tutorial1156B - Ugly PairsTo be honest, the solution to this problem is easier to code than to prove.

Let's follow the next strategy. Write down all the letters of the string which have odd positions in alphabet ("aceg…") and even positions in alphabet ("bdfi…"). Sort both of these lists in non-decreasing order. The answer is either concatenation of the lists (odd + even or even + odd) or "No answer".

Now for the proof part. Let's establish that we don't care about equal letters and leave just a single copy of each letter of the string. Let's check some cases:

There is just a single letter. That's trivial.There are two letters of the same parity. There is no incorrect arrangement for this.There are two letters of different parity. If they differ by one then no answer exists. Otherwise any arrangement works.There are three letters and they are consecutive in alphabet. No answer exists.There are other types of three letters. Then the one of the different parity can put on the side (e.g. "acd" and "dac"). As the difference between at least one of these letters and that one isn't 1, that arrangement will be ok.Finally, there are at least 4 letters. It means that the difference between either the smallest odd and the largest even or between the smallest even and the largest odd isn't 1.The only thing you need to do is to implement the check function the most straightforward way possible and check both arrangements.

Overall complexity: O(nlogn).

Solution (PikMike)1156C - Match Points

Tutorial1156C - Match PointsLet's denote the points that have greater coordinates in their matched pairs as R-points, and the points that have smaller coordinates as L-points.

Suppose we have an R-point that has smaller coordinate than some L-point. Then we can "swap" them, and the answer won't become worse. Also, if some R-point has smaller coordinate than some point that doesn't belong to any pair, or some L-point has greater coordinate than some point that doesn't belong to any pair, we can swap them too. So, if the answer is k, we choose k leftmost points as L-points, and k rightmost ones as R-points.

For a fixed value of k, it's easy to see that we should match the leftmost L-point with the leftmost R-point, the second L-point with the second R-point, and so on, in order to maximize the minimum distance in a pair. This fact allows us to check whether it is possible to construct at least k pairs, and we can use binary search to compute the answer to the problem.

Solution (BledDest)1156D - 0-1-Tree

Tutorial1156D - 0-1-TreeLet's divide all valid pairs into three categories: the ones containing only 0-edges on the path, the ones containing only 1-edges, and the ones containing both types of edges.

To calculate the number of pairs containing only 0-edges, we may build a forest on the vertices of the original graph and 0-edges, and choose all pairs of vertices belonging to the same connected components of this forest (we can find all connected components with DSU or any graph traversal algorithm). The same can be done for the pairs containing only 1-edges.

If a path from x to y is valid and contains both types of edges, then there exists a vertex v such that the simple path from x to v goes only through 0-edges, and the simple path from v to y goes only through 1-edges. So, let's iterate on this vertex v, and choose some other vertex from its component in 0-graph as x, and some other vertex from its component in 1-graph as y, and add the number of ways to choose them to the answer.

Solution (BledDest)1156E - Special Segments of Permutation

Tutorial1156E - Special Segments of PermutationLet's fix the maximum element on segment and iterate on either the elements to the left of it or to the right of it, and if the current maximum is x, and the element we found is y, check whether the element x−y can form a special subsegment with y (that is, x is the maximum value on the segment between y and x−y). That obviously works in O(n2), yes?

Well, not exactly. If we can precompute the borders of the segment where x is the maximum element (this can be done with some logarithmic data structure, or just by processing the array with a stack forwards and backwards) and always choose to iterate on the smaller part of the segment, it's O(nlogn). Why is it so? Every element will be processed no more than logn times because, if we process it in a segment of size m, the smaller part of it contains no more than m2 elements (which we will process later, and the smaller part of this segment contains no more than m4 elements, and so on). Checking whether the element belongs to the segment we are interested in can be done in O(1) if we precompute inverse permutation for p.

Solution (BledDest)1156F - Card Bag

Tutorial1156F - Card BagLet's solve the problem by dynamic programming.

Let dpi,j be the probability of winning if the last taken card has number i on it and the number of taken cards is j.

We win immediately next turn if we take card with number i on it. The probability of this is cnti−1n−j, where cnti is number of cards with i.

Also we can win if we take a greater card next turn.

We take a card with number i+1 with probability cnti+1n−j, with number i+2 — with probability cnti+2n−j, and so on. The probability of winning in this case will be cnti+1n−j⋅dpi+1,j+1 and cnti+2n−j⋅dpi+2,j+1 respectively.

So the probability of winning for dpi,j is cnti−1n−j+∑k=i+1n(cntkn−j⋅dpk,j+1) = cnti−1n−j+1n−j⋅∑k=i+1n(cntk⋅dpk,j+1).

Therefore, all we need is to maintain the sum ∑i=xn(cnti⋅dpi,j) while calculating our dynamic programming.

Solution (Roms)1156G - Optimizer

Tutorial1156G - OptimizerI could've explained the jury solution, however, after the contest I found a much easier and more understandable solution by one of the participants. I put one of jury's solutions under the spoiler along with a link to the solution I'm explaining.

Let's restate the problem in a more convinient way. Initially we are given some directed acyclic graph. Let there be nodes of two kinds:

For a direct set operation. These will have a single outgoing edge to another node.For a binary operation. These will have two outgoing edges to other nodes. However, it's important which edge is the "left" one and which is the "right" one.We also have to make dummy vertices for the variables which only appeared at the right side of some operation.

We are allowed to remove any direct set operations, we will simulate this by compressing the edges of the graph. Instead of doing (b=a,c=b), we'll do (b=a,c=a). Value-wise this is the same but variable c don't rely on b anymore, so b might be deleted.

We'll build the entire graph line by line. Let's maintain array var2node which will keep the current value of each variable. It will store the node itself. It's probably better to store both kinds of nodes in a separate array so that var2node and the pointers to the ends of the edges could be integers.

If we encountered no "res" variable getting set, then the answer is 0.

Otherwise let's traverse from the node representing the current value of "res" to every reachable node. While building the graph we were compressing every unoptimal operation, thus all reachable nodes matter.

Finally, the last operation on "res" might have been just a direct set. That's unoptimal, so we'll handle that case separately.

Educational Codeforces Round 63 Editorial

By awoo, history, 4 years ago, translation, In English1155A - Reverse a Substring

Tutorial1155A - Reverse a SubstringIf the answer is "YES" then we always can reverse a substring of length 2. So we need to check only pairs of adjacent characters in s. If there is no such pair of characters si>si+1 for all i from 1 to n−1 then the answer is "NO".

Why is it so? Consider the substring s[l;r]=slsl+1…sr we have to reverse. It is obvious that sl>sr, otherwise it is pointless to reverse this substring. Then consider two cases: sl≤sl+1 then sl+1>sr (by transitivity) and then we can go to a smaller substring (s[l+1;r]); otherwise sl>sl+1 and it means that we can take the substring s[l;l+1].

Solution (Vovuh)1155B - Game with Telephone Numbers

Tutorial1155B - Game with Telephone NumbersLet's understand how players should act.

Vasya needs to delete the first digit that is not equal to 8, because the first digit of telephone number should be 8, and the first digit not equal to 8 is preventing it.

Petya needs to delete the first digit equal to 8, for the same reasons.

So, all that we need to do is delete first n−112 digits not equal to 8 (if they exist), and first n−112 digits equal to 8 (again if they exist). It's enough to stop when there is either no 8's left or no non-8's because the latter moves won't change the result of the game anyway. Finally, if first digit of resulting string is 8, then Vasya wins, otherwise Petya.

Overall complexity: O(n).

Solution (Roms)1155C - Alarm Clocks Everywhere

Tutorial1155C - Alarm Clocks EverywhereIt is obvious that we can always take x1 as y. But we don't know which value of p we can take. Let di be xi+1−xi for all i from 1 to n−1. The value of p should be divisor of each value of di. The maximum possible divisor of each di is g=gcd(d1,d2,…,dn−1) (greatest common divisor). And then it is obvious that the value of p should be the divisor of g. So we have to find any divisor of g among all values pj. If there is no such value then the answer is "NO".

Time complexity: O(nlogn).

Solution (Vovuh)1155D - Beautiful Array

Tutorial1155D - Beautiful ArrayThe first intuitive guess one's probably made is multiplying the segment of maximum sum for positive x. That thing is correct. Unfortunately, there is no similar strategy for non-positive x, simple greedy won't work there.

Thus, dynamic programming is our new friend. Let's introduce the following state: dp[pos][statemax][statemul], where pos is the length of the currently processed prefix, statemax is the state of maximum sum segment (0 is not reached, it'll appear later, 1 is open, current elements are added to it, 2 is passed, the segment appeared earlier) and statemul is the state of segment multiplied by x with the same values. This dp will store the maximum segment sum we can achieve.

The only base state is dp[0][0][0]=0 — the prefix of length 0 is processed and both segments are not open yet. The rest of values in dp are −∞.

There are two main transitions. At any moment we can change the state of each segment to the next one without moving to the next position. From state 0 (not reached) we can go to state 1 (opened) and from state 1 we can go to state 2 (passed). Note that this easily covers the case where optimal segment is empty. We can also move to the next position updating the value of dp with correspondance to the current states of segments.

The answer will be stored in dp[n][2][2] — the state where all the array is processed and both segments are closed.

Overall complexity: O(n).

Solution (PikMike)1155E - Guess the Root

Tutorial1155E - Guess the RootSince 106+3 is a prime and degree k of the polynomial is small enough, we can get this polynomial in our hands asking k+1 queries in different points. Knowing values f(xi) for x1,x2,…,xk+1, we can interpolate f by various ways.

For example, we can construct a system of linear equations thinking of ai as variables. In other words, we know, that a0⋅x0i+a1⋅x1i+⋯+ak⋅xki=f(xi) for i=1…(k+1), also we know xli and f(xi). So we can solve this system using Gaussian elimination in O(k3).

Now, knowing the polynomial f(x) we can locally brute force all possible candidates for x0, since there is only 106+3 such candidates, and print the one we found.

Solution (adedalic)1155F - Delivery Oligopoly

Tutorial1155F - Delivery OligopolyLet's use dynamic programming to solve this problem. We will start with a single biconnected component consisting of vertex 0, and connect other vertices to it. So, the state of our dynamic programming will be a mask of vertices that are in the same biconnected component with 0.

How can we extend a biconnected component in such a way that some other vertices are added into it, but it is still biconnected? We will add a path (possibly cyclic) that starts in some vertex x belonging to the mask, goes through some vertices not belonging to the mask, and ends in some vertex y belonging to the mask (possibly x=y). If for every triple (x, y, addmask) we precalculate some path that starts in x, goes through vertices from addmask and ends in y (and addmask does not contain neither x nor y), then we can solve the problem in O(3nn2): there will be 2n states, for every state we will iterate on two vertices x and y belonging to the mask, and the number of possible pairs of non-intersecting masks mask and addmask is O(3n).

The only thing that's left is precalculating the paths for triples (x, y, addmask). That can be done with auxiliary dynamic programming dp2[x][y][addmask] which will denote whether such a path exists. For every edge (u,v) of the original graph, dp2[u][v][0] is true, and we can go from dp2[x][y][addmask] to some state dp2[x][z][addmask′], where addmask′ will contain all vertices from addmask and vertex y (and we should ensure that there is an edge (y,z) in the graph and the addmask didn't contain vertex y earlier). We should also somehow be able to restore the paths from this dp, and we also should be careful not to choose the same edge twice (for example, if we start a path by edge (x,y), we should not use the same edge to return to x) — both these things can be done, for example, by storing next-to-last vertex in the path.

Educational Codeforces Round 62 Editorial

By awoo, history, 4 years ago, translation, In English1140A - Detective Book

Tutorial1140A - Detective BookSolution is just some implementation: simulate algorithm given in the legend, maintaining maximum over all ai on prefix and breaking when the maximum becomes smaller than index of the next page.

Solution (adedalic)1140B - Good String

Tutorial1140B - Good StringA string is good when either its first character is > or the last is <. Strings of type < … > are not good, as their first and last characters will never change and they will eventually come to the form < >.

So, the answer is the minimum number of characters from the beginning of the string, which must be removed so that the first symbol becomes >, or minimum number of characters from the end of the string, which must be removed so that the last symbol becomes <.

Solution (Roms)1140C - Playlist

Tutorial1140C - PlaylistIf we fix a song with minimum beauty in the answer, then we need to take the remaining k−1 songs (or less) among those having beauty greater than or equal to the beauty of the fixed song — and the longer they are, the better.

So, we will iterate on the songs in the order of decreasing their beauty, and for the current song we will maintain k longest songs having greater or similar beauty. This can be done using some standard containers: set in C++ or TreeSet in Java.

Solution (Roms)1140D - Minimum Triangulation

Tutorial1140D - Minimum TriangulationYou can use straightforward way and calculate answer with "l-r-dp" with O(n3).

But there is a easier claim: it's optimal to split n-gon with diagonals coming from 1, so answer is ∑i=2n−1i⋅(i+1).

Proof: let's look at the triange which contains edge 1−n. Let's name it 1−n−x. If x=n−1, we can delete this triangle and go to (n−1)-gon.

Otherwise, 1<x<n−1. Let's look at triangle n−x−k. It always exists and x<k<n. Finally, if we change pair of triangles (1−n−x, n−x−k) to (1−n−k, 1−k−x), answer will decrease since nx>kx and nxk>nk, that's why nx+nxk>nk+kx.

Note, that triangle 1−n−x changes to 1−n−k and k>x, so repeating this step will eventually lead us to situation x=n−1.

As a result, we can morph any triangulation into one mentioned above and its weight won't increase.

Solution (adedalic)1140E - Palindrome-less Arrays

Tutorial1140E - Palindrome-less ArraysAt first, "array contains a palindromic subarray of length ≥3" is equivalent to "array contains a palindromic subarray of length =3". So we need to calculate number of arrays without palindromes of length 3. It's equivalent to finding arrays where a[i]≠a[i+2] for all appropriate i.

Note, that i and i+2 have same parity, so all odd and all even positions in array are independent, and answer is the product of the number of ways to choose numbers for odd positions, and the number of ways to choose numbers for even positions.

In terms of same parity our condition morphs to a[i]≠a[i+1] and we need to calculate all ways to replace (−1)-s in such way that all pairs of consecutive elements are different.

To calculate it let's look at sequences of consecutive (−1)-s. They will look like a,−1,−1,…,−1,b with l (−1)-s, where a and b are positive (case where a is empty can be considered as k⋅(a,−1,…,−1,b with l−1 (−1)-s), case with empty b is solved the same way).

In the end we need to find a way to calculate the number of those sequences. There are only two fundamental types of sequences: a,−1,…,−1,a (same value from both ends) and a,−1,…,−1,b (a≠b). Exact values of a and b don't really matter.

Let's find a way to calculate both values (name them cntSame and cntDiff) for l consecutive (−1)-s in O(logl) time. Base values: cntSame(0)=0,cntDiff(0)=1.

Let's try to choose value of −1 in the middle of sequence: if lmod2=1, then we can split sequence in two sequences of length ⌊l/2⌋ and cntSame(l)=cntSame(l/2)2+(k−1)⋅cntDiff(l/2)2 and cntDiff(l)=2⋅cntSame(l/2)⋅cntDiff(l/2)+(k−2)⋅cntDiff(l/2)2.

If lmod2=0 then just iterate over value of last −1, then cntSame(l)=(k−1)⋅cntDiff(l−1) and cntDiff(l)=cntSame(l−1)+(k−2)⋅cntDiff(l−1).

Resulting complexity is O(n).

Solution (adedalic)1140F - Extending Set of Points

Tutorial1140F - Extending Set of PointsLet's try to analyze how the size of E(S) can be calculated. Let's connect points having same x-coordinates to each other, and do the same for points having same y-coordinates. Then we can solve the problem for each component separatedly: after the algorithm is run, the component will contain the points (X,Y) such that at least one point in the component has x-coordinate equal to X, and at least one point in the component (maybe same, maybe another one) has y-coordinate equal to Y. So the answer for each component is the product of the number of distinct x-coordinates and the number of distinct y-coordinates in the component.

Now we can process insertion queries: there are many ways to do it, but, in my opinion, the easiest way to handle them is to create a separate vertex for every x-coordinate and y-coordinate, and process each point as an edge connecting vertices corresponding to its coordinates (edges can be easily added by using DSU with rank heuristics).

To handle removals, we will get rid of them completely. Transform the input into a set of O(q) events "some point exists from query l to query r". Then build a segment tree over queries, and break each event into O(logq) segments with this segment tree. Then we can initialize a DSU, and run DFS on the vertices of the segment tree to get answers for all queries. When we enter some node, we add all edges that exist on the corresponding segment into DSU. If we are in a leaf node, we may compute the E(S) for the corresponding query. And when we leave a vertex, we can rollback all changes we made when we entered it. One important moment is that using path compression in DSU here is meaningless since it doesn't work with rollbacks well.

This solution works in O(qlog2q).

Solution (BledDest)1140G - Double Tree

Tutorial1140G - Double TreeSuppose we want to minimize the number of traversed edges of the second type (edges that connect odd vertices to each other or even vertices to each other), and minimizing the length of the path has lower priority. Then we exactly know the number of edges of the second type we will use to get from one vertex to another; and when building a path, we each time either jump from one "tree" to another using an edge of the first type, or use the only edge of the second type that brings us closer to the vertex we want to reach. So, in this case problem can be solved either by binary lifting or by centroid decomposition. The model solution uses the latter: merge the graph into one tree (vertices 2i−1 and 2i of the original graph merge into vertex i in the tree), build its centroid decomposition, and for each centroid c and vertex v of its centroid-subtree calculate the length of the shortest path from 2c−1 and 2c to 2v−1 and 2v using dynamic programming. Then the answer for each pair of vertices u and v may be calculated as follows: find the deepest centroid c controlling the both vertices, and try either shortest path u→2c−1→v or shortest path u→2c→v.

But this solution won't work in the original problem because sometimes we want to choose an edge of the second type that leads us further from the vertex we want to reach in the merged tree, but allows us to use a cheaper edge of the first type to jump from one tree to another. Let's make this situation impossible! We may change the weights of all edges of the second type so that the weight of edge between 2i−1 and 2i becomes the length of the shortest path between 2i−1 and 2i. This can be done by solving a SSSP problem: build a graph of n+1 vertices, where each vertex i from 1 to n represents the path between from 2i−1 and 2i. Add a directed edge with weight equal to w2i−1,2i going from vertex 0 to vertex i. And finally, for every pair i,j such that 2i−1 and 2j−1 are connected by edge of weight w1, and 2i and 2j are connected by edge of weight w2, add an undirected edge connecting i and j in the new graph (its weight should be w1+w2). Then the distance from 0 to i in this graph will be equal to the length of the shortest path from 2i−1 to 2i in the original graph.

Educational Codeforces Round 61 Editorial

By awoo, history, 4 years ago, translation, In English1132A - Regular Bracket Sequence

Tutorial1132A - Regular Bracket SequenceFor bracket sequence to be regular, it should have equal number of opening and closing brackets. So, if cnt1≠cnt4, then it's impossible to construct any regular bracket sequence.

cnt2 is completely irrelevant to us, since inserting or removing a () substring doesn't change the status of the string we get. Almost the same applies to cnt3, but we should have at least one (( substring before it. So, if cnt3>0, but cnt1=0, there is no solution.

In all other cases it is possible to order all strings as follows: all strings ((, then all strings (), then all strings )(, then all strings )).

Solution (BledDest)1132B - Discounts

Tutorial1132B - DiscountsWhen using i-th coupon, the bar we get for free should have at least xi−1 bars not cheaper than it. So, if we consider a sorted in non-decreasing order, then we cannot get discount greater than an−xi+1.

On the other hand, we can always get such a discount if we pick xi most expensive bars to buy using the i-th coupon.

Solution (Roms)1132C - Painting the Fence

Tutorial1132C - Painting the FenceLet ci be the number of painters that are painting the i-th section.

Let's fix the first painter (denote his index as x) we won't take and decrease the numbers of array c in the range which he paints.

Then we may new array d, such that di is equal to 1 if and only if ci=1, and 0 otherwise. This array corresponds to segments that are painted by only one painter

After that we build prefix sum array p on array d: pi=∑j=1idj. This should be done in O(n).

Now, for each remaining painter we can count the number of sections that are painted only by him. For painter i it will be equal to pri−pli−1. Let's denote it as resi.

Finally, find an painter with the minimum value of resi, denote it as MinRes. The answer (if we choose painter x as one of two that won't be hired) will be equal to cnt−MinRes, where cnt is the number of elements greater than 0 in the array c after removing the painter x.

And, of course, we should do the same for all painters.

Solution (BledDest)1132D - Stressful Training

Tutorial1132D - Stressful TrainingThe easiest part of the solution is to notice that if the charger of power x works then the charger of power x+1 also works. Thus, binary search is applicable to the problem.

k is really small and only one laptop can be charged during some minute. It implies that check function can work in something polynomial on k by searching for the right laptop to charge during every minute.

I claim that the greedy algorithm works. Find the laptop that gets his charge below zero the first. Charge it for one minute as early as possible. Repeat until you either don't have time to charge the laptop (check returns false) or the contest is over (check returns true).

Why greedy works? Well, check any case where check returns false. If some laptop runs out of power then all the minutes up to the current one are used to charge something. Moreover, you can free no minute of these as by doing greedy we charged all laptops as late as possible. Freeing some minute will lead to other laptop dying earlier.

One way to implement this is the following. Keep a heap of events (time_i−th_laptop_dies), pop its head, add x to it if the time is greater than the number of charges already made and push it back to heap. That will simulate the entire process in O((n+k)logn). Unfortunately, this may be too slow on some implementations.

Let's try the following linear approach. Maintain not the heap but such an array that i-th its cell contains all indices of all the laptops to run out of charge on the beginning of minute i. Keep an iterator to the first non-empty position. Pop a single index out of this vector, charge it and push it to the new position. You'll still make k steps and on each step you'll make O(1) instant operations. That will make it O(n+k) for this simulation.

I'm not really sure how to build the maximal answer case, however, I can estimate the upper bound of binary search. You can set x in such a way that it charges every laptop in one minute so that it won't run out of power until the end of the contest. Choose the smallest ai, the greatest bi, the greatest k and you'll end up with 1−2⋅105⋅107 total usage. Thus, 2⋅1012 will always be enough.

Overall complexity: O((n+k)⋅logANS). (or O((n+k)⋅logANSlogn) if you are skillful enough to squeeze it :D).

Solution (PikMike)1132E - Knapsack

Tutorial1132E - KnapsackLet's consider the optimal answer. Suppose we take ci items of weight i.

Let L be the least common multiple of all weights (that is 840). Then we may represent ci as ci=Lipi+qi, where 0≤q<Li. Let's do the following trick: we will take qi items of weight i, and all the remaining items of this weight can be merged into some items of weight L.

Then we can write a brute force solution that picks less than Li items of each weight, transforms the remaining ones into items of weight L as much as possible, and when we fix the whole subset, adds maximum possible number of items of weight L to the answer. This works in something like ∏i=18Li=L88! operations, which is too much.

How can we speed it up? Rewrite it using dynamic programming! When we have fixed the number of items we take from x first sets, the only two things that matter now are the current total weight of taken items and the number of items of weight L we can use; and it's obvious that the more items of weight L we can use, the better. So let's write the following dynamic programming solution: dp[x][y] — maximum number of items of weight L we can have, if we processed first x types of items, and current total weight is y. Note that the second dimension should have size 8L.

Solution (BledDest)1132F - Clear the String

Tutorial1132F - Clear the StringWe will solve the problem by dynamic programming.

Let dpl,r be the answer for substring sl,l+1,…,r. Then we have two cases:

The first letter of the substring is deleted separately from the rest, then dpl,r=1+dpl+1,r;The first letter of the substring is deleted alongside with some other letter (both letters must be equal), then dpl,r=minl<i≤r,si=srdpl+1,i−1+dpi,r.Solution (Roms)1132G - Greedy Subsequences

Tutorial1132G - Greedy SubsequencesLet's calculate for each position i position nxti — "the closest greater from the right" element to i and add directed edge from i to nxti. Then we will get oriented forest (or tree if we'd add fictive vertex) where all edges are directed to some root.

So, we can look at current subsegment we need to calculate the answer for as at a number of marked vertices in the tree. Then, the answer itself is a longest path up to the tree consisting only from marked vertices. Key observation is next: if u and v are marked and u is an ancestor of v then any vertex y on path from v to u is also marked.

So, "the longest path up to the tree consisting only from marked vertices" has length equal to a number of marked vertices on path to the root. And we have three types of queries: mark a vertex, unmark a vertex and calculate maximum number of marked vertices among all paths to the root.

It can be done with Segment Tree on Euler Tour of the tree: if we calculate Tin and Tout for each vertex in dfs order, then marking/unmarking is just adding ±1 to a segment [Tin,Tout), and maximum among all paths is a maximum on the whole tree.

Result time complexity is O(nlogn) and space complexity is O(n).

Educational Codeforces Round 60 Editorial

By awoo, history, 4 years ago, In English1117A - Best Subsegment

Tutorial1117A - Best SubsegmentThere is a property of arithmetic mean: 1k∑i=1kci≤max1≤i≤kci and the equality holds when c1=c2=⋯=ck.

Obviously, we can always gain maximum arithmetic mean equal to max1≤i≤nai by taking single maximum element from a. Considering the property above, we need to take only maximum elements in our subsegment, that's why we need to find the longest subsegment consisting only of maximum elements.

Solution (adedalic)1117B - Emotes

Tutorial1117B - EmotesIt is obvious that we always can use only two emotes with maximum ai. Let their values be x and y (x≥y).

We have to solve the problem by some formula. The best way to use emotes — use the emote with the value x k times, then use the emotion with the value y, then again use the emote with value x k times, and so on.

So the "cycle" has length k+1, and we can use the emote with the value x the remaining number of times. So the answer is ⌊mk+1⌋⋅(x⋅k+y)+(m%(k+1))⋅x, where x is the first maximum of a, y is the second maximum of a, ⌊pq⌋ is p divided by q rounded down, and p%q is p modulo q.

Solution (Vovuh)1117C - Magic Ship

Tutorial1117C - Magic ShipNote, that if we can reach the destination in x days, so we can reach it in y≥x days, since we can stay in the destination point by moving to the opposite to the wind direction. So, we can binary search the answer.

To check the possibility to reach the destination point (x2,y2) in k days we should at first look at the position (x3,y3) the wind moves ship to. Now we can calculate where we can go: since each day we can move in one of four directions or not move at all, we can reach any point (x,y) with Manhattan distance |x−x3|+|y−y3|≤k. So we need to check that |x2−x3|+|y2−y3|≤k.

To calculate (x3,y3) we can note, that there were ⌊kn⌋ full cycles and kmodn extra days. So it can be calculated with O(1) time using prefix sums.

Finally, about borders of binary search: to reach the destination point we need to move closer at least by one (it terms of Manhattan distance) from the full cycle of the wind. So, if answer exists then it doesn't exceed (|x1−x2|+|y1−y2|)⋅n≤2⋅1014.

Solution (Roms)1117D - Magic Gems

Tutorial1117D - Magic GemsLet's reformulate the solution to the form of dynamic programming.

dpn — the number of ways to split the gems so that the total amount of space taken is n.

Then there are obvious transitions of either splitting the last gem or not. dpn=dpn−m+dpn−1.

And that can be easily rewritten in such a way that matrix exponentiation becomes the solution.

Overall complexity: O(m3⋅logn).

Solution (Reziba)1117E - Decypher the String

Tutorial1117E - Decypher the StringSince a sequence of swaps denotes some permutation, let's try to restore the permutation p that was used to transform s into t, and then get s by applying inverse permutation.

If n was 26 or less, then we could get p just by asking one query: send a string where no character occurs twice, and the resulting positions of characters uniquely determine the permutation. Unfortunately, n may be greater than 26 — but we can ask more than one query.

The main idea is the following: for each index i∈[1,n], we may choose a triple of characters, so all triples are distinct. There are 263 different triples, and that's greater than 104, so each index can be uniquely determined. Then, after we choose a triple for each index, ask three queries as follows: in the first query, the i-th character of the string is the first character in the triple representing index i; in the second query we use the second characters from all triples, and in the third query — the third characters. Let s1, s2 and s3 be the strings we sent, and t1, t2 and t3 be the strings we received as answers. The permutation maps index i to index j if and only if s1[i]=t1[j], s2[i]=t2[j] and s3[i]=t3[j] — because if some other index is mapped to j, then at least one of the aforementioned equalities is false since all triples of characters are distinct. Using this fact, we may recover the permutation p.

Solution (BledDest)1117F - Crisp String

Tutorial1117F - Crisp StringEach state of the string can be denoted as the set of characters we deleted from it, and each such set can be represented as a p-bit binary mask, where i-th bit is equal to 0 if i-th character of the alphabet is already deleted, and 1 otherwise.

Let's call a mask bad if the string formed by this mask is not crisp. Let's also say that a pair of characters a,b forbids mask m if a,b is a pair of characters that should not be adjacent, but they are adjacent in the string formed by mask m.

If we somehow find all bad masks, then the solution would be writing simple bitmask dp to find the best mask that is not bad and reachable from the initial mask (the one having all bits set to 1). So let's focus on finding all bad masks. Obviously, if some pair of characters forbids a mask, then it's bad, and vice versa.

Let's pick some pair of characters a,b and find all masks forbidden by it (we will do the same for every pair of characters that cannot be adjacent). Let's check every occurence of a in the initial string. For each occurence, we will find the closest occurence of b to the right of it. If there's no any, or if there's another a between them, let's ignore the occurence of a we have chosen and move to the next one. Otherwise, let's find all characters that occur at least once between the fixed occurences of a and b. If all those characters are deleted, then these occurences of a and b will be adjacent — so pair a,b forbids any mask that has bits representing a and b set to 1, bits representing every character occuring in between to 0, and all other bits to any values. Let's mark all these masks as forbidden as follows: we will write a recursive function mark(m,a,b) that marks mask m and every its submask that has bits a and b set to 1 as forbidden. This function should check if m is not forbidden; if not, then mark it as forbidden, iterate on the bit i we may remove from m, and call mark(m⊕2i,a,b) recursively (but only if i is set to 1 in mask m, and if i≠a and i≠b). If we implement it in such a way, then for each pair a,b, it will take O(n+p2p) operations to mark all masks forbidden by this pair of characters, so overall complexity will be O(np2+p32p) or O(np+p32p), depending on your implementation.

Solution (PikMike)1117G - Recursive Queries

Tutorial1117G - Recursive QueriesLet's denote fl(l,r)=(ml,r−l)+fl(l,ml,r−1)+fl(ml,r+1,r) and, analogically, fr(l,r)=(r−ml,r)+fr(l,ml,r−1)+fr(ml,r+1,r). Then, we can note that f(l,r)=(r−l+1)+fl(l,r)+fr(l,r). So we can switch to calculating fl (and fr).

Let's lf[i] be the closest from the left to i element such that a[lf[i]]>a[i].

To calculate fl(l,r) we will look from the other side: we will look at it as the sum of lengths of segments induced by each element from [l,r]. Each element ai (l≤i≤r) will add to fl(l,r) value equal to min(i−lf[i]−1,i−l), or a piecewise linear function if we look at l as a variable. And fl(l,r) is a value of a sum of linear functions induced by a[i] in a point x=l.

To process it efficiently we can one by one add induced linear functions to the corresponding subsegments using BIT or Segment Tree and if we've added functions induced by a[k] we can calculate answer for all queries which looks like (li,k).

To calculate fr(l,r) we can just reverse array and all queries.

Result time complexity is O((n+q)logn). Note, that it's still works quite slow, so you should use fast data structures like BIT of iterative segment tree.

Educational Codeforces Round 59 Editorial

By awoo, history, 4 years ago, translation, In English1107A - Digits Sequence Dividing

Tutorial1107A - Digits Sequence DividingThe only case when the answer is "NO" — n=2 and s1≥s2. Then you cannot divide the initial sequence as needed in the problem. Otherwise you always can divide it into two parts: the first digit of the sequence and the remaining sequence.

Solution (Vovuh)1107B - Digital root

Tutorial1107B - Digital rootLet's derive the formula S(x)=(x−1) mod 9+1 from the digital root properties (that's a known fact but I could only find a link to some russian blog about it). Using that formula, you can easily get that k-th number with the digital root of x is (k−1)⋅9+x.

Solution (Ne0n25)1107C - Brutality

Tutorial1107C - BrutalityAll you need in this problem is two simple technique: two pointers and sorting. Let's consider maximum by inclusion segments of equal letters in the initial string. Let the current segment be [l;r] and its length is len=r−l+1. If len<k then we can press all buttons and deal all damage corresponding to them. Otherwise it is obviously more profitable to press k best (by damage) buttons. So let's create the array val, push all values ai such that l≤i≤r in this array, sort them, take min(|val|,k) best by damage (|val| is the size of the array val) and go to the next segment.

Solution (Vovuh)1107D - Compression

Tutorial1107D - CompressionIt is very easy to decompress the input (the input was given in the compressed form to make the constraints bigger but less dependent of the time to read the data).

The authors solution is the following:

Let x be the answer to the problem and initially it equals to n. Let's iterate over all rows of the matrix and calculate lengths of maximum by inclusion segments consisting only of zeros or only of ones. Let the length of the current segment be len. Then let's set x:=gcd(x,len), where gcd is the function calculating the greatest common divisor. Then let's do the same for columns of the matrix and print the answer.

How to prove that this solution works?

On the one hand, if some segment of kind [1+lx,1+(l+1)x], where l is the value from the range [0;nx−1], contains different digits then we cannot compress the given matrix.

On the other hand, if the previous condition is true, then we can compress each string by the following algorithm: cut off the first x characters of the string and compress the remaining string recursively. After such compression we obtain the matrix of size n×nx. And because of the first condition we can compress the remaining matrix again by this algorithm if we apply it to columns instead of rows.

Solution (Vovuh)1107E - Vasya and Binary String

Tutorial1107E - Vasya and Binary StringWe will solve the problem with dynamic programming.

Let ansl,r be the answer for substring sl,l+1,…r.

If sequence is empty (l>r) then ansl,r=0.

Let dpdig,l,r,cnt be the maximum score that we can get if we reduce the substring sl,l+r,…r into cnt digits equal to dig with some operations.

If substring sl,l+r,…r does not contain cnt digit dig, then dpdig,l,r,cnt=−1018.

If cnt=0, then dpdig,l,r,cnt=ansl,r.

To calculate ansl,r just fix the sequence of digits that will be deleted last:

ansl,r=max1≤cnt≤r−l+1,0≤dig≤1acnt+dpdig,l,r,cnt.

To calculate dpdig,l,r,cnt just fix the first element mid that is left after working with the substring. Note that smid must be equal to dig.

dpdig,l,r,cnt=max1≤mid≤r,smid=digansl,mid−1+dpdig,mid+1,r,cnt−1.

All that's left is to transform these formulas into code. Complexity of this solution is O(n4).

Solution (Roms)1107F - Vasya and Endless Credits

Tutorial1107F - Vasya and Endless CreditsLet create the following matrix (zero-indexed):

mati,j=aj−min(i,kj)⋅bj.

i-th row of this matrix contains Vasya's profits for credit offers as if they were taken i months before the purchase.

We need to choose elements from this matrix so that there is no more than one element taken in each row and each column. The sum of the chosen elements should be maximum possible.

And that is exactly the problem Hungarian algorithm solves.

Solution (Roms)1107G - Vasya and Maximum Profit

Tutorial1107G - Vasya and Maximum ProfitIt is clear that gap(l,r)≤gap(l,r+1) and gap(l,r)≤gap(l−1,r).

Sort all indices 2,3,…,n with comparator based on the value of di−di−1.

Let's consider all indices in the order discussed above and for fixed index i find the best answer among such segments (l,r) that gap(l,r)≤di, gap(l−1,r)>di and gap(l,r+1)>di. Initially, when we consider gap=0, there are n such segments, each containing only one task.

When we consider new index j, we need to merge segments (l,j−1) and (j,r) and update the answer with best(l,r)−(dj−dj−1)2, where best(l,r) is the maximum subsegment in array a−cl,a−cl+1,…,a−cr (that array represents the profit we get for each task).

We can store and merge such segments with set in C++ or TreeSet in Java.

We can answer queries best(l,r) using the segment tree (we need to process queries of the form "find a subsegment having maximum sum"). Read more about it here.

Educational Codeforces Round 58 Editorial

By awoo, history, 4 years ago, In English1101A - Minimum Integer

Tutorial1101A - Minimum IntegerThere are two basic cases we have to consider: either the element we want to find is less than li, or it is greater than ri.

In the first case, we are interested in di itself: it is the minimum positive number divisible by di, and if it is less than li, then it is the answer.

In the second case, we have to find minimum element that is greater than ri and is divisible by di. This can be done as follows: we calculate the number of elements divisible by di that are not greater than ri as c=⌊ridi⌋, and then we take (c+1)-th element, which is di(c+1).

Solution (BledDest)1101B - Accordion

Tutorial1101B - AccordionNo cases. No any special thoughts. Just greedy.

The solution consists of six steps:

Remove the prefix of the string until the position of leftmost '[' character. If there is no such character, print -1;Remove the prefix of the string until the position of leftmost ':' character. If there is no such character, print -1;Reverse the string;Remove the prefix of the string until the position of leftmost ']' character. If there is no such character, print -1;Remove the prefix of the string until the position of leftmost ':' character. If there is no such character, print -1;Print the number of '|' characters in the remaining string plus four.Solution (Vovuh)1101C - Division and Union

Tutorial1101C - Division and UnionLet's prove that division possible if and only if union of all segments has two and more segments.

If the union have at least two segments, then we can choose one of them and put all segments it contains in one group and other segments to another group. On the other hand, if we can divide all segments in two groups in such way that there are no pair from different group which intersects, then union of segments from the first group doesn't intersect union of segments from another and union of unions consists of several non-intersecting components.

How can it help? If union of segments consits of several segments then exists x such that for any segment [li,ri] either li≤ri≤x or x<li≤ri and both parts are non-empty. Moreover, x equals to one of ri.

It leads us straight to one of possible solutions: sort all segments by ri in increasing order and for each ri we should check that ri<mini<j≤nlj (suffix minimum). If we've found such ri then all prefix goes to one group and suffix — to another.

Solution (adedalic)1101D - GCD Counting

Tutorial1101D - GCD CountingI know there exists O(nlogMAXN) solution and author of the problem promises to tell it to you (here he explained it). I'd love to tell easier to code and about the same time to work O(nlog2MAXN) solution.

At first, notice that it is only enough to check the paths such that all vertices on it is divisible by some prime.

Let's for each v calculate the path of the maximum length to pass through it. That means that one part of this path goes down to one child of it and another part goes down to another child.

For each vertex we will store the lengths of maximum paths through vertices with values divisible by each prime in av. That is O(nlogMAXN) memory. To recalc the answer we will store all values of children nodes, sort them and update the answer with two pointers technique.

Don't forget about the case of n=1!

Overall complexity: O(nlog2MAXN).

Solution (PikMike)1101E - Polycarp's New Job

Tutorial1101E - Polycarp's New JobLet's find the smallest wallet to fit all bills. One its side is the maximum side of any bill. Now we orient the bills in such a way that their longer side is put against this side of the wallet. The second side of the wallet is the maximum of the other sides. More formally, for set of bills (a1,b1), (a2,b2), ... (ai≤bi for each i), the minimum wallet is (max ai, max bi).

The minimum wallet fits all sufficient wallets.

So the solution is maintaining the maximum of all ai and bi and checking if h≥ai and w≥bi (h≤w).

Choose your i/o functions wisely.

Overall complexity: O(n).

Solution (PikMike)1101F - Trucks and Cities

Tutorial1101F - Trucks and CitiesFirst (bonus) solution: implement idea from Blogewoosh #6. Time complexity will be somewhat O((q+logqlogMAX)n) and space complexity is O(n+q).

Honest solution: Note, that for each truck lower bound on the answer is max(ci⋅(a[pj+1]−a[pj]))=ci⋅max(a[pj+1]−a[pj]), where p0=si,p1,p2,…,pri+1=fi is optimal partition of [a[si],a[fi]] on ri+1 segments (partition which minimize maximum length of segment) and doesn't depend on ci of truck.

So, it enough to calculate d[l][r][k] — optimal partition of segment [a[l],a[r]] on k segments.

Let opt[l][r][k] be position, where last segment starts in partition with value d[l][r][k]. Note, that opt[l][r][k]≤opt[l][r+1][k].

On the other hand, d[l][r][k]=minl≤j≤r(max(d[l][j][k−1],a[r]−a[j])). But d[l][j][k−1]≤d[l][j+1][k−1] and a[r]−a[j]>a[r]−a[j+1], then max(d[l][j][k−1],a[r]−a[j]) is somewhat "convex".

Finally, best j is no more than opt[l][r][k], And we can look at j as second pointer (along with r as first pointer). So we can for each r move j while answer "relaxes" (while answer is decreasing or staying same). In result, for each l and k there will be O(n) operations in total.

Optimizing memory consumption is easy, if we notice that we can iterate over l but not save it as state of dp.

In the end, time complexity is O(n3+q) and space complexity is O(n2+q).

Solution 1 (adedalic)Solution 2 (adedalic)1101G - (Zero XOR Subset)-less

Tutorial1101G - (Zero XOR Subset)-lessLet's consider some division [0,i1), [i1,i2), ..., [ik,n). Represent the XOR sum of the subset via prefix-XOR. Those are pr[i1]⊕pr[0], pr[i2]⊕pr[i1], ..., pr[n]⊕pr[ik].

I claim that you can collect any subset that is a XOR of an even number of pr[x] for pairwise distinct values of x. Let's take a look on some prefix of processed segments, where the last segment is taken into subset. The previous taken pr[x]'s can't be changed, the last taken pr[x] can either be eliminated if we also take the current segment (and that segment erases one value and adds one) or added to the answer if we don't take it (but the next taken segment will add two values). You can see that the parity doesn't change.

Moreover, you can collect any subset that is a XOR of an odd number of pr[x] for pairwise distinct values of x. Just forget about pr[0] taken into the answer, as its value is 0. Then all the even subsets which included it will become odd.

This way we can collect all subsets of pr[x] for some division. Now you just want find the division that produces the maximum number of linearly independent numbers (binary vectors). That is — the size of the basis of the space of chosen numbers (binary vectors).

Now it's time to abuse the fact that adding a number into the set can only increase the size of basis of the space. Thus, adding anything to the maximum set won't change the answer (otherwise the result would be greater than the "maximum").

Finally, you say that the maximum basis size is equal to the basis size of all the prefix-XOR and easily calculate in O(nlogMAXN).

The only corner case is pr[n] being 0 itself. Then for any division the full subset will also give 0 result. That is the only case with answer −1.

Overall complexity: O(nlogMAXN).

Educational Codeforces Round 57 Editorial

By awoo, history, 4 years ago, translation, In English1096A - Find Divisible

Tutorial1096A - Find DivisiblePrint l and 2l.

Firstly, the smallest value of yx you can have is 2 and if any greater value fits then 2 fits as well. Secondly, the absolute difference between x and 2x increases when you increase x, thus lessening the possibility of both numbers fitting into the range.

Overall complexity: O(1).

Solution (PikMike)1096B - Substring Removal

Tutorial1096B - Substring RemovalFirstly, let's calculate the length of the prefix of equal letters (let it be l) and the length of the suffix of equal letters (let it be r). It can be done with two cycles with breaks. It is obvious that this prefix and suffix wouldn't overlap.

Then let's consider two cases: the first one is when s1≠sn and the second one is when s1=sn.

In the first case we can only remain either prefix or suffix of s consisting only of equal letters. Then the answer is l+r+1 (because we can remain from 1 to l letters on the prefix, from 1 to r on the suffix or empty string).

In the second case we can remain from 0 to l letters on the prefix and from 0 to r letters on the suffix. But now because s1=sn we can combine these ways, so the answer is (l+1)⋅(r+1).

And the bonus (this case is not belong to the given problem): if all letters in the string are equal then then answer is n(n−1)2+n because we can choose any substring of s of length at least 2 and any substring of length 1.

Solution (Vovuh)1096C - Polygon for the Angle

Tutorial1096C - Polygon for the AngleAt first, let prove that all possible angles in the regular n-gon equal to 180kn, where 1≤k≤n−2.

To prove it we can build circumscribed circle around n-gon. Then the circle will be divided on n equal arcs with lengths 360n. Any possible angle in the n-gon is a inscribed angle in the circle and equal to half of central angle. Any central angle, in turn, equals to sum of some consecitive k arcs. In result, any angle equal to 12k360n=180kn. The maximal possible angle is reached from three consecutive vertices and equal (by properties of regular polygons) to 180(n−2)n.

So, we need to find minimal integer n such that 180kn=ang, where k is integer and 1≤k≤n−2. Its equivalent to find minimal integer solution of 180k=ang⋅n. Let g=GCD(180,ang), then we can divide both parts on g.

In result, 180gk=anggn. Since GCD(180g,angg)=1, then 180g must divide n. Analogically, angg must divide k. Then, solution is next: n=x⋅180g and k=x⋅angg.

We are finding the minimal solution, so x is almost always 1, except cases where k=n−1 — here we must take x=2, since we have restricition on k≤n−2.

The picture for the futher visibility:

Solution (adedalic)1096D - Easy Problem

Tutorial1096D - Easy ProblemDenote string t as hard.

We will solve this problem with dynamic programming.

Denote dpcnt,len — the minimum possible ambiguity if we considered first cnt letters of statement and got prefix t having length len as a subsequence of the string.

If cnt-th letter of the statement is not equal to tlen, then dpcnt,len=dpcnt−1,len — we don't have to change it.

Otherwise we either change the letter, or let it stay as it is (and the length of the prefix we found so far increases): dpcnt,len=min(dpcnt−1,len−1,dpcnt−1,len+acnt−1).

Solution (PikMike)1096E - The Top Scorer

Tutorial1096E - The Top ScorerAn straightforward dp solution is to calculate dps,p,m= {number of states at the end of the game in which no one has scored more than m goals} where s is the number of total goals to be scored and p is the number players in the game. Fix the score of Hasan in the game and by using this dp the rest is easy (also described below). But as long as the time needed to calculate dps,p,m is O(s⋅r⋅p) this solution won't fit in the constraints.

With a little help from combinatorics, we can calculate the value of mentioned dp function without using recursions.

Defineg(s,p,m)=∑i=0p(−1)i(pi)(s+p−1−i(m+1)p−1)by inclusion-exclusion principle it can be easily seen that the value of g equals to the above dps,p,m. And the complexity of calculation for g is O(p) with a O(s) preprocess for calculating binomial coefficients.

This formula is a well-known modification of "Star and Bars" problem but with the upper limit on terms.

Now we can calculate the answer, firstly fix Hasan's score and number of top-scorers, then use g to calculate each state:f(s,r,p)=∑st=r∑pq=1(p−1q−1)⋅1q⋅g(s−qt,p−q,t−1)(s−r+p−1p−1)By using modulus arithmetic, the answer can be reported in the requested form.

Overall complexity: O(s⋅p2).

Solution (PikMike)1096F - Inversion Expectation

Tutorial1096F - Inversion ExpectationLet's break the problem into four general cases.

Case 1. Inversions between two unknown numbers. Each pair of numbers can either be or inversion or not and the number of permutations for both cases is the same. Thus, the expected value of that is cnt(−1)⋅(cnt(−1)−1)2⋅12.Case 2 and 3. Inversions between the known and unknown number. Let's check the case with left number being unknown and right being known. The opposite will be done similarly. For each known number calculate the number of unknowns to the left of it lftx and the total number of unknowns greater than it gtx. Then you'll need to put a greater number out of all possible to make an inversion. Add lftx⋅gtxcnt(−1) to the answer.Case 4. Inversions between two known numbers. Just calculate that number ignoring all −1 and add it to answer.Overall complexity: O(nlogn) (for the lase case, all others are done in O(n)).

Solution (PikMike)1096G - Lucky Tickets

Tutorial1096G - Lucky TicketsThe naive solution would be dpx,y — the number of sequences of allowed digits with length x and sum y. We compute it for x=n2 and for every possible y, and the answer is ∑ydp2n2,y.

Let's speed this up. Let's denote the following polynomial: f(x)=∑9i=0cixi, where ci=1 if i is an allowed digit, otherwise ci=0.

It's easy to see that the coefficients of f(x) are equal to the values of dp1,y. Using mathematical induction we may prove that the coefficients of (f(x))a are equal to dpa,y.

So now we need to compute (f(x))n2. There are two possible ways to do this that result in O(nlogn) complexity. The first option is to apply binary exponentiation with NTT polynomial multiplication. The second option is to use the fact that if we apply NTT to a polynomial, we get a set of its values in some points. So, if we exponentiate these values, we get a set of values of exponentiated polynomial in the same points. So we may apply NTT to f(x) treating it as a polynomial of degree 5n, raise each resulting value to the power of n2 and apply inverse transformation.

Educational Codeforces Round 56 Editorial

By awoo, history, 4 years ago, translation, In English1093A - Dice Rolling

Tutorial1093A - Dice RollingIt is enough to print ⌊xi2⌋ for each query, where ⌊xy⌋ is x divided by y rounded down.

Solution (Vovuh)1093B - Letters Rearranging

Tutorial1093B - Letters RearrangingThe only case when the answer is -1 is when all letters of the string are equal. Why is it so? Because if we have at least two different letters we can place the first one at the first position of the string and the second one at the last position of the string. Then it is clearly that the obtained string is good. We can implement this solution by the following way: sort si and if si,1=si,|si| (the first letter equals to the last one) then the answer is -1 otherwise the answer is si.

Solution (Vovuh)1093C - Mishka and the Last Exam

Tutorial1093C - Mishka and the Last ExamLet's present the following greedy approach. The numbers will be restored in pairs (a1,an), (a2,an−1) and so on. Thus, we can have some limits on the values of the current pair (satisfying the criteria about sort). Initially, l=0,r=1018 and they are updated with l=ai,r=an−i+1. Let l be minimal possible in the answer. Take ai=max(l,bi−r) and r=bi−l. That way l was chosen in such a way that both l and r are within the restrictions and l is also minimal possible. If l was any greater than we would move both l limit up and r limit down leaving less freedom for later choices.

Overall complexity: O(n).

Funnily enough, I coded some naive solution just to test main correct and with restriction of 109 on numbers it passed all tests in 300 ms at max. After I saw that I guessed why it worked in O(MAXVAL) but it looked fun nonetheless.

Solution (PikMike)Naive (PikMike)1093D - Beautiful Graph

Tutorial1093D - Beautiful GraphLet's denote a way to distribute numbers as a painting. Let's also call the paintings that meet the constraints good paintings (and all other paintings are bad).

We can solve the problem for each connected component of the graph independently and multiply the answers. Let's analyze a painting of some connected component. If some vertex has an odd number written on it, then we should write even numbers on all adjacent vertices, and vice versa. So in fact we need to check if the component is bipartite, and if it is, divide it into two parts. The number of good paintings is 2a+2b, where a is the size of the first part, and b is the size of the second part, because we write 2's into all vertices of one part, and 1's or 3's into all vertices of another part.

Solution (Ajosteen)1093E - Intersection of Permutations

Tutorial1093E - Intersection of PermutationsAt first, time limit was not that tight for the problem. We didn't want any sqrt, bitset or straight up nm solution to pass (and it's close to none to pass). Jury solution works faster than twice the time limit so we decided 6 seconds is alright.

The task is purely about implementation. You renumerate numbers in permutations so that the queries are (segment of values, segment of positions) and then have the structure to make update in point and sum on rectangle.

Renumeration in my case was making the first permutation into identity one and changing the numbers in second appropriately.

You can choose the structure you want, I'll tell about the one I use when the queries are offline. For online the common technique is having n BITs, each with treap in it (ordered_set template from pbds is usually enough). For offline you can precalculate the values to fall into each BIT beforehand and do BIT on these values inside. Preprocess all the update and get queries (x,y), adding y into all the BITs x will fall into. Then sort them and leave only unique occurrences.

Overall complexity: O((n+m)⋅log2n).

Solution (PikMike)1093F - Vasya and Array

Tutorial1093F - Vasya and ArrayLet's try dynamic programming approach to this problem. Let dpcnt,lst be the number of ways to replace all −1 with numbers from 1 to k in such a way that array a1…cnt is good and the last number of that array is lst.

Let sdpcnt=∑i=1kdpcnt,i.

Then initially it's dpcnt,lst=sdpcnt−1 if acnt equals to −1 or lst. However, we could include incorrect states — such that segment [acnt−len+1…acnt] consist of the same value. It happens when:

cnt≥len, as we should have at least len elements;segment [acnt−len+1…acnt] has all its elements either equal to −1 or lst.If both of these conditions hold then you should subtract all the bad states from dpcnt,lst. The number of them is sdpcnt−len−dpcnt−len,lst.

Solution (Ajosteen)1093G - Multidimensional Queries

Tutorial1093G - Multidimensional QueriesLet's rewrite the formula of distance between two points as follows:

∑i=1k|ax,i−ay,i|=∑i=1kci(ax,i−ay,i)=∑i=1kciax,i−∑i=1kciay,i, where ci=1 if ax,i≥ay,i, otherwise ci=−1.

Consider what will happen if we change some ci to the opposite value. The result of this formula obviously won't increase, so we may try all possible values of ci and pick maximum result.

This allows us to consider every option to set values of ci (there are 2k such options) separately, and when we fix a set of values of ci, find two points that maximize the distance if it is expressed with fixed ci. To do so, we have to find the point having maximum ∑i=1kciax,i and having minimum ∑i=1kciax,i.

So actually our problem is reduced to the following: we have 2k arrays, we want to process some queries in the form "change an element of some array" and "find maximum and minimum on some segment of some array". This can be done simply by building a segment tree over each array, and then we will get the solution having O((n+q)2klogn) time complexity.

Educational Codeforces Round 55 Editorial

By awoo, history, 4 years ago, translation, In English1082A - Vasya and Book

Tutorial1082A - Vasya and BookIt is easy to understand that the optimal answer is achieved in one of three cases:

Vasya is trying to visit page y without visiting pages 1 and n;Vasya first goes to the page 1, and then to the page y;Vasya first goes to the n page, and then to the y page.In the first case, Vasya can go directly to the y page from the x page if |x−y| is divided by d.

In the second case, Vasya can get to page y through page 1, if y−1 is divided by d. The required number of actions will be equal to ⌈x−1d⌉+y−1d.

Similarly, in the third case, Vasya can go to the page y through the page n if n−y is divided by d. The required number of actions will be equal to ⌈n−xd⌉+n−yd.

If none of the three options described above is appropriate, then there is no answer.

Solution (Ajosteen)1082B - Vova and Trophies

Tutorial1082B - Vova and TrophiesLet ri be the maximal segment of gold cups that begins in the cup i. Let li be the maximum segment of gold cups that ends in the cup i. Also, let the total number of gold cups be cntG.

Note that it makes no sense to change the cups of the same color. Then let's consider the silver cup, which will change with the gold cup, let its number be i. Then if ri+1+li−1<cntG, then we will update the answer with the value ri+1+li−1+1, and otherwise with the value ri+1+li−1. This will not work if all the cups are golden. In this case, the answer is n.

Solution (Ajosteen)1082C - Multi-Subject Competition

Tutorial1082C - Multi-Subject CompetitionAt first, it's optimal to take candidates with maximal levels for a fixed subject.

At second, if we fix number of participants in each subject for some delegation, then it's always optimal to choose all subjects with positive sum of levels.

It leads us to a following solution. Let's divide all candidates by it's si and sort each group in non-increasing order.

In result we can just iterate over all prefix sums for each group and update global answer of current length with current sum if it has a positive value.

Solution (adedalic)1082D - Maximum Diameter Graph

Tutorial1082D - Maximum Diameter GraphLet's construct the graph the following manner. Take all the vertices with ai>1 and build a bamboo out of them. Surely, all but the end ones will have degree 2, the diameter now is the number of vertices minus 1.

One can show that building the graph any other way won't make the diameter greater.

How should we distribute the other vertices? Two of them can be used to increase diameter. And all the others won't matter, they can be paired with any of the vertices with degrees to spare. If no loops are added then the diameter won't change — the path that was the longest won't become any shorter.

All those facts imply that the graph should be a tree and the sum of ai should be at least 2n−2.

Overall complexity: O(n).

Solution (PikMike)1082E - Increasing Frequency

Tutorial1082E - Increasing FrequencyLet cnt(l,r,x) be a number of occurrences of number x in subsegment [l,r].

The given task is equivalent to choosing [l,r] and value d such that ans=cnt(1,l−1,c)+cnt(l,r,d)+cnt(r+1,n,c) is maximum possible. But with some transformations ans=cnt(1,n,c)+(cnt(l,r,d)−cnt(l,r,c)) so we need to maximize cnt(l,r,d)−cnt(l,r,c).

Key observation is the next: if we fix some value d then we can shrink each segment between consecutive occurrences of d in one element with weight equal to −cnt(li,ri,c). Then we need just to find subsegment with maximal sum — the standard task which can be solved in O(cnt(1,n,d)).

Finally, total complexity is ∑dO(cnt(1,n,d))=O(n).

Solution (adedalic)1082F - Speed Dial

Tutorial1082F - Speed DialThe first thing to come to one's mind is dynamic programming on a trie. The most naive of the solutions take O(S⋅n2⋅k2), where S is the total length of strings.

I'll introduce the faster approach.

Let dp[x][rem][k] be the solution for subtree of the vertex x with rem buttons remaining and k is the closest ancestor vertex with the button used in it.

This dp will be recalced via the other dp.

Let dp2[x][rem][k][m] be the same thing as dp[x][rem][k] but only m first children of x is taken into consideration and x doesn't have a button in it.

Give z buttons to the current child, then update dp2[x][rem][k][m] with dp[m−thchildofx][z][k][m] + dp2[x][rem−z][k][m+1].

dp[x][rem][k] will then have two options: dp[x][rem−1][x] for x having button in it and dp2[x][rem][k][0] for x not having button in it.

dp[x][rem][k] has O(1) transitions and O(len2⋅p) states.

dp2[x][rem][k][m] has O(k) total transitions and also O(len2⋅p) states.

Solution (PikMike)1082G - Petya and Graph

Tutorial1082G - Petya and GraphThis problem can be reduced to one of well-known flow problems: "Projects and Instruments". In this problem, we have a set of projects we can do, each with its cost, and a set of instruments (each also having some cost). Each project depends on some instruments, and each instrument can be used any number of times. We have to choose a subset of projects and a subset of instruments so that if a project is chosen, all instruments that this project depends on are also chosen, and we have to maximize the difference between the sum of costs of chosen projects and the sum of costs of chosen instruments.

The problem about projects and instruments can be solved with the following flow network:

for each project, create a vertex and add a directed edge from the source to this vertex with capacity equal to the cost of this project;for each instrument, create a vertex and add a directed edge from this vertex to the sink with capacity equal to the cost of this instrument;for each project, create edges with infinite capacity from the vertex denoting this project to all vertices denoting the required instruments for this project.Let's analyze an (S,T) cut between the source and the sink in this vertex, and construct some answer based on this cut as follows: if a project-vertex belongs to S, then we take this project; if an instrument-vertex belongs to S, then we take this instrument; all other projects and instruments are discarded. If an edge between some project and some instrument is cut, then it means that the answer is incorrect (we try to take a project requiring some instrument we don't take), and the cut value is infinite. Otherwise, the value of the cut is equal to the total cost of taken instruments and discarded projects, and we need to minimize it. So the minimum cut in this network denotes the best answer.

Reducing the given problem to this problem is easy: edges of the given graph are "projects", vertices of the given graph are "instruments".

Regarding implementation, any flow algorithm using capacity scaling should be sufficient. It seems that Dinic also passes, even though its complexity is O(n2m).

Educational Codeforces Round 54 Editorial

By awoo, history, 4 years ago, translation, In English1076A - Minimizing the String

Tutorial1076A - Minimizing the StringBy the definition of lexicographical comparing we can see that if we can remove one character we always have to do it. Besides, we have to remove the character from the leftmost position i such that i<n and si>si+1 or from the position n if there is no such i.

Solution (Vovuh)1076B - Divisor Subtraction

Tutorial1076B - Divisor SubtractionNotice that once the number becomes even, it never stops being even as subtracting 2 doesn't change parity. Thus, the task is to find the smallest divisor, subtract it and print 1+n−d2.

Overall complexity: O(n−−√).

Solution (PikMike)1076C - Meme Problem

Tutorial1076C - Meme ProblemTo solve this problem we need to use some math and solve the equation on the paper. If a+b=d then a=d−b and a⋅b=d transforms to b(d−b)=d or db−b2−d=0. Then a,b=(d±D−−√)/2 where D=d2−4d. So if d=0 then a=b=0, or if 0<d<4 there is no answer.

Since values are small, calculating answer in double was enough, all we need to do is just output answer with sufficient number of digits after the decimal point.

Solution (adedalic)1076D - Edge Deletion

Tutorial1076D - Edge DeletionLet's understand how many good vertices we may get if only k edges remain. This value is not greater than k+1, since an edge an add only one good vertex, and for k=0 we have a good vertex with index 1. This is an upper bound; let's try to find a solution getting exactly k+1 good vertices (or, if k+1>n, all vertices of the graph will be good). Let's run Dijkstra's algorithm from vertex 1 and stop it as soon as we know the shortest paths to k+1 vertices (including vertex 1). The answer should contain the edges belonging to the shortest path tree built on these k+1 vertices.

Solution (BledDest)1076E - Vasya and a Tree

Tutorial1076E - Vasya and a TreeTo solve this problem we can use a data structure which allows to add some value on segment and get a value from some point (Fenwick tree, segment tree or anything you are familliar with).

Let's run DFS from the root while maintaining current depth. When entering a vertex u on depth h, let's consider all queries having vi=u, and for each such query add xi on segment [h,h+di]. Then for current vertex u the answer is the value in point h.

When leaving vertex u we need to rollback everything we have done: for all queries having vi=u subtract xi on segment [h,h+di].

Solution (Ajosteen)1076F - Summer Practice Report

Tutorial1076F - Summer Practice ReportLet's intruduce the following dynamic programming approach. dp[N][2], dp[i][j] is the smallest number of elements of type j page i can end with. If we learn to recalculate it, the answer will be "YES" if dp[n][0]≤k or dp[n][1]≤k. I will try to prove it on the fly.

Let's look into the constructing of each page from the following perspective. I'll consider the cases when the current page ends with tables and the previous page ends with either tables or formulas. Let's write down all the tables and then put formulas as separators to them. I will call number of tables on the end of the previous page pa, the number of formulas on the end of the previous page pb, the number on tables on the current page a and the number of formulas on the current page b.

In the case with tables on the end of the previous page the smallest number of separators you can have is cnt=⌈pa+ak⌉−1. Moreover, if you have b>cnt, you can put one of the formulas right before the end of the page, ending it with 1 table. The only case is when there are too many separators. b should be less or equal to a⋅k (you can put up to k separators before each table).

The case with formulas on the end of the previous page isn't that different. The smallest number of separators is cnt=⌈ak⌉−1 and the limit to the number of separators is (a−1)⋅k+(k−pb) (you can't put k separators before the first table as in the first case, the maximum number to that position is determined by the previous page).

Now let's take a look at resulting expressions. You can notice that lowering pa can only decrease the lower bound on the number of separators and lowering pb can only increase the upper bound on the number of separators. That shows that minimizing the values in dp[i][j] is always profitable.

Overall complexity: O(n).

Solution (PikMike)1076G - Array Game

Tutorial1076G - Array GameSuppose there is only one query, i. e. we are given some array and we want to know who is the winner if the game is played on this array. One of the obvious solutions is dp[i][x] — will the current player win if the chip is currently in the cell i and the number in cell i is x. We can already see that we don't need to know the exact value of x, we only want to know whether it's odd: if there is a cell j≠i such that we can go from i to j and dp[j][aj−1] is a state where current player will lose, then we should go to this cell since our opponent will enter a losing state of the game. Otherwise, we want to force our opponent to move out of cell i, and we can do so only if x is odd. So we found a dynamic programming solution with O(n) states, but what is more important is that we can take all the elements in our array modulo 2.

Okay, now let's solve the problem when there are only queries of type 2 (no modifications). Since when calculating the dp values we are interested only in m next cells, and there are only 2m variants of whether these cells are "winning" or "losing", we may consider each element of the array as a function that maps a mask of m next states into a new mask of m states if we pushed our new element into the front. For example, if the i-th element is even and states i+1, i+2, i+3, i+4, i+5 are winning, losing, losing, winning and losing respectively, and m=5, then we may consider a mask of next states as 10010; and then we can check if i-th state is winning and push a bit to the front of this mask, discarding the last bit; since new state is winning, we will get a mask of 11001. It allows us to denote two functions f0(x) and f1(x) — what will be the resulting mask of next m states, if current mask is x and we push an even or odd element to the front.

Okay, what about pushing more than one element? We can just take the composition of their functions! Since a function can be stored as an array of 2m integers and the composition needs only O(2m) time to be calculated, then we can build a segment tree over the elements of the array, and store a composition of all functions on the segment in each node. This allows us to answer queries of type 2 in O(2mlogn).

The only thing that's left is additions on segment. Adding an even number is easy: just ignore this query. To be able an odd number, let's store another function in each node of the segment tree which would be the composition of all functions on the segment if we would add 1 to all elements on the segment (so the elements which were odd become even, and vice versa). This allows us to use lazy propagation: if the query affects the whole node, we may just swap two functions in it and push the query to the children of this node.

Overall complexity is O(2m(n+q)logn). It turns out (we didn't think about it before the contest, but some contestants submitted such solutions) that it can be reduced to O(m(n+q)logn) if we will use the distance to closest losing state instead of a mask of winning and losing states.

Educational Codeforces Round 53 Editorial

By awoo, history, 4 years ago, translation, In English1073A - Diverse Substring

Tutorial1073A - Diverse SubstringNotice that the string of two distinct letter is already diverse. That implies that the answer is "NO" if and only if all the letters in the string are the same. Otherwise you can check all pairs of adjacent letters in O(n).

Overall complexity: O(n).

Solution (PikMike)1073B - Vasya and Books

Tutorial1073B - Vasya and BooksLet's maintain the pointer pos to the topmost non-deleted book and whether each book whether is removed from the stack or not. Initially, all books are in a stack, and pos is 0 (if we store the array 0-indexed). We will process the array B in the order b1,b2,…bn. If the current book bi is removed from the stack, then the answer for it is zero. Otherwise, we will increment the pointer pos until the equality apos=bi is satisfied, while marking all the intermediate books in the array u. After that, the answer for the book bi will be the number of marked books in the u array (including itself).

Since the pointer pos shifts n times at total, we get a solution with an O(n) complexity.

Solution (Ajosteen)1073C - Vasya and Robot

Tutorial1073C - Vasya and RobotDenote d=|x|+|y​|. If d>n, then the answer is -1, since the robot will not have the time to reach (x,y) cell in n steps. Also, if d and n have different parity, then the answer is also -1, as in one move the robot changes the parity of the sum of its coordinates.

In all other cases, the answer exists. Let's use binary search to solve this problem. Consider all segments of length len. For a fixed length of the segment len, let's iterate over the position of the beginning of the segment l. At the same time, we will maintain the cell that the robot will stop at if it execute all commands, except commands with indices l,l+1,…,l+len−1. We denote this position as (x0,y0). We also calculate the distances from the cell (x0,y0) to the cell (x,y) — the value d0=|x−x0|+|y​​−y0|. If there is at least one position of the beginning of the segment for which d0≤len, then we can change the segment of length len so that the robot comes to the (x,y) cell, otherwise it can't.

Solution (Ajosteen)1073D - Berland Fair

Tutorial1073D - Berland FairLet's code the following process. Go one circle across the booths, calculate the total cost C of sweets bought and the number S of sweets bought. Now you can decrease you money down to T=T mod C and add S⋅(T div C) to answer. It represents that you went maximum number of such circles. The later circles will have smaller cost. Let's continue this process until T becomes smaller than the minimum priced sweet.

The number of operations made is O(logT). Let Tcur be the amount of money before some operation, Ccur be the total cost of sweets bought on that operation and Tnew=Tcur mod Ccur. Tnew is actually smaller than Ccur (that's how modulo works) and smaller than Tcur−Ccur (that's also how modulo works). And these inequalities imply that Tnew<Tcur2. That leads to about O(logT) steps to reach the minimal price.

Overall complexity: O(nlogT).

Solution (PikMike)1073E - Segment Sum

Tutorial1073E - Segment SumLet's calculate the answer as the sum of suitable numbers in range [1;r] minus the sum of suitable numbers in range [1;l−1]. Now our problem is to calculate the sum of suitable numbers in range [1;n].

The main approach for this problem is digit DP. Let's calculate two dynamic programmings dppos,mask,f and dpspos,mask,f. pos means that now we are at the pos-th digit of the number n (at the digit corresponding to 10len−pos−1, where len is the decimal length of a number), mask is a binary mask describing digits we already use and f equals 1 if the current prefix of number we trying to obtain is the same as the prefix of number n (otherwise f equals 0).

So what means dppos,mask,f? It means the count of numbers (in general, not numbers but their prefixes) in range [1;n] of length exactly |n| without leading zeroes corresponding to this state. So what the point of this DP? Its point is helping us to calculate the main DP, dpspos,mask,f, which means the sum of numbers (in general, not numbers but their prefixes) in range [1;n] of length exactly |n| without leading zeroes corresponding to this state.

How do we calculate the answer? Firstly, let len be the length of n. Let calc(n) be the function calculating the sum of numbers from 1 to n containing at most k different digits. How to calculate it? Let calcdp(x) be the sum of numbers from 1 to x containing at most k different digits and having length exactly |x|. Then calc(n) seems to be pretty easy: for each length i from 1 to len−1 add to the answer calcdp(10i−1). And the last step is to add to the answer calcdp(n).

How to calculate dynamic programmings? Initially, all states are zeroes (excluding dp0,0,1, which is 1).

Firstly, let's calculate dp. After calculating it we can calculate dps in almost the same way. Let's iterate over all possible lengths and over all possible masks. Let the current state is dppos,mask,0. Then let's iterate over next digit we will place in this number and place it. If pos=0 then dig=1…9 otherwise dig=0…9. The transition is pretty easy: dppos+1,mask|2dig,0+=dppos,mask,0. There | is the bitwise OR operation. For f=1 transitions are almost the same expect the restrictions on digit we place and the state we update. If we now at the position pos with mask mask and f=1 then the current digit of n is npos. Then let's iterate over next digit: dig=1…npos if pos=0 otherwise dig=0…npos. The transition is also easy: dppos+1,mask|2dig,dig=npos+=dppos,mask,f.

After calculating the previous DP we can calculate dps. All the process is the same as in the previous dynamic programming expect the value we will add in transitions. In the previous DP this value was equal dppos,mask,f, in the current DP this value equals to val=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,f. Don't forget to calculate it modulo 998244353!

So after calculating all the values of DPs, what is the answer for calcdp(n)? It is ∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1 for all masks with at most k bits.

I'm pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight-forward and simple.

Solution (Vovuh)1073F - Choosing Two Paths

Tutorial1073F - Choosing Two PathsFirstly, let's call a path from u to v good, if u is a leaf, v is a vertex of degree at least 3 (the number of their neighbors is at least 3) and there are no other vertices of degree at least 3 on this path expect the vertex v.

The first step of the solution is to remove all the good paths from u to v (but we should not remove the vertex v) and remember for each vertex v the sum of two maximum lengths of good paths which end in the vertex v. Let this value for the vertex v be valv. For example, if for some vertex v there are 3 good paths with end in it of lengths 2, 3 and 5 correspondingly, then valv will be 5+3=8.

Okay, it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree. But we can not take any diameter of this tree and call it the answer because of the second constraint: we need to find some diameter from x to y such that the sum valx+valy is maximum possible. How do we do that?

There is such an awesome (and well-known) fact that the center of a tree belongs to all diameters of this tree. Let's root the tree by the center of a tree (if the length of the diameter is odd (the center of a tree is an edge) then let's root the tree by any end of this edge, it does not matter).

There is one case when the length of the diameter is 1 but it is pretty trivial to handle it.

Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible. Let's calculate the vertex with the maximum distance from a root (and with the maximum possible valv for equals distances) by simple DFS for each neighbor of a root. It can be done in O(n) and the last part is to find two maximums of this list, it also can be done in O(n) or O(nlogn), depends on implementation.

Solution (Vovuh)1073G - Yet Another LCP Problem

Tutorial1073G - Yet Another LCP ProblemAt first, implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough. For example, it's a Suffix Array + linear LCP + Sparse Table. Now we can compare two suffixes i and j by finding l=lcp(i,j) and comparing s[i+l] with s[j+l].

We will process queries online. Let current query be a pair of arrays a (|a|=k) and b (|b|=l). We will calculate answer in two parts:∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).To calculate the first sum we can sort all c=a+b suffixes in lexicographical order and maintain some information for prefixes of c. What information we need to maintain? We need some Data Structure which will hold lcp of suffixes from a. When we process some ci=bj we need just a total sum of all lcp in the DS. If ci=aj, we should add to the DS length of aj-th suffix. And when we move from ci to ci+1 we must recalculate some lcp. Since c is sorted, all we need is to set lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n])).

In fact, this Data Structure is just a map. In this map we will hold for each length l number of suffixes with lcp=l (we will hold only non-zero values). When we should add some suffix aj, we manually increase some value by one. Setting min with v=lcp(s[ci…n],s[ci+1…n]) can be done with decreasing maximum in map while its more than v. It can be proven, that there will be O(|a|+|b|) operations with map for one query. The total sum can be maintained in some global variable, which will be recalculated each time map changes.

To calculate the second sum we can just reverse c and run the same algorithm. So total complexity is O(nlog2n+(∑i=1i=qki+∑i=1i=qli)logn).

Educational Codeforces Round 52 Editorial

By awoo, history, 4 years ago, In English1065A - Vasya and Chocolate

Tutorial1065A - Vasya and ChocolateNumber of chocolate bars Vasya can buy without offer is cnt=⌊sc⌋.

Number of "bundles" with a bars x=⌊cnta⌋.

Then number of additional bars add=x⋅b.

In result, total number of bars is add+cnt.

Solution (Ajosteen)1065B - Vasya and Isolated Vertices

Tutorial1065B - Vasya and Isolated VerticesVasya can decrease number of isolated vertices up to 2 using one edge and pairing them. So minimum number of isolated vertices is max(0,n−2m).

To calculate maximum number of isolated vertices let's keep number of non-isolated vertices knowing that each pair connected by edge (i.e. size of clique). Let we have size of clique cur and rem edges remained unassigned at current step. If rem=0 then answer is n−cur. Otherwise we need to increase clique with one vertex. Maximum number of edges we can add to connect this vertex is add=min (rem,cur). So, subtract it from rem and increase cur by one. Repeat this step while rem greater than zero. Answer is n−cur.

One corner case is next: if cur=1, then answer is n, not n−cur.

Solution (Ajosteen)1065C - Make It Equal

Tutorial1065C - Make It EqualLet's iterate over height pos of slice in decreasing order. All we need to know is a number of towers with height more than pos (name it c) and sum of its heights sum.

Current slice on height pos is good if k≥sum−c⋅pos. Let's greedily decrease value pos while slice on pos is good keeping correct values c and sum. When we found minimal good slice we can perform it increasing answer by one and "changing tower heights" just by setting new value to sum equal to c⋅pos.

Finish algorithm when pos becomes equal to minimal height of towers and make final slice.

Solution (Ajosteen)1065D - Three Pieces

Tutorial1065D - Three PiecesThere are a lot of different solutions for the problem. Most of them have the similar structure.

The first part is to find the shortest distance between the states (x1,y1,p1) and (x2,y2,p2), where x and y are the coordinates of the square and p is the current piece. This can be done with 0-1 bfs, Floyd or Dijkstra. Just represent the triple as a single integer by transforming it to (x⋅n⋅3+y⋅3+p) and do everything on that graph.

The second part is to write some dp to go from i-th square with piece p1 to (i+1)-th square with piece p2. The value of this dp[n][3] is a pair (moves, replacements). It is easy to see that you can always choose the minimum of two such pairs while updating.

Overall complexity may vary. We believe, O(n4) is achievable. However, the particular solution I coded works in O(n6).

Solution (PikMike)1065E - Side Transmutations

Tutorial1065E - Side TransmutationsLet's take a look at any operation. You can notice that each letter can only go from position i to n−i−1 (0-indexed). Then, doing some operation twice is the same as doing that operation zero times.

Now consider some set of operations l1,l2,…,lk, sorted in increasing order. Actually, they do the following altogether. Replace segment [lk−1..lk) with the reversed segment ((n−lk−1)..(n−lk−1−1)] and vice versa. Then replace segment [lk−3..lk−2) with the reversed segment ((n−lk−2−1)..(n−lk−3−1)] and vice versa. And continue until you reach the first pair. Segment [0..l1) might also be included in the answer when the parity is right.

Moreover, every subset of segments [0..l1),[l1,l2),…[lk−1,lk) is achievable. So for each segment you can either swap it or not. Let's translate it to math language.

Let cnti be the number of such pairs of strings x and y that x≤y. Why is there such an order? You want to consider only unique strings, thus, you need to pick exactly one of equal strings from each component. Let it be the smallest one.

Then for each segment of the set you have cntlen pairs to choose from, where len is the length of that segment.

And that part of the formula is:

cntb1⋅∏i=1mcntbi−bi−1.

However, the part covered by zero segments is left. There are ALn−2bm possible strings up there.

cnti is actually a number of all pairs of strings of length i plus the number of all pairs of equal strings of length i divided by 2. cnti=AL2i+ALi2.

Overall complexity: O(mlogn).

Solution (PikMike)1065F - Up and Down the Tree

Tutorial1065F - Up and Down the TreeLet's calculate answer in two steps. At first, let's calculate for each vertex v drev(v) — what we can gain if we must return from subtree of v in the end. We need only pair of values: minimal possible depth we can acquire to move up from subtree of v and maximal number of different leaves we can visit.

Note, that this two values are independent since we must return from v and if for some child to of v we can return from it, it's profitable to visit to and return. But if we can't return from to so we are prohibited to descent to to. So, drev(v).second (number of visited leaves) is just a sum of all drev(to).second if drev(to).first≤hv. Also note that we can always reorder all children in such way that last visited vertex to will have minimal drev(to).first. So drev(to).first (minimal possible depth) is a minimum over all drev(to).first.

At second, let's calculate d(v) — maximal number of different leaves we can visit if we don't need to return from subtree of v. It can be calculated quite easy using array drev(v). We just need to choose child to we will not return from, so from vertex to we will take value d(to) and from other childen (which we can return from) value drev(v).second.

Result complexity is O(n).

Solution (adedalic)1065G - Fibonacci Suffix

Tutorial1065G - Fibonacci SuffixSuppose we added all the suffixes of F(n) into a trie. Then we can find k-th suffix by descending the trie, checking the sizes of subtrees to choose where to go on each iteration.

The model solution actually does that, but computes the sizes of subtrees without building the whole trie. Recall that if we insert all suffixes of a string into the trie, then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string.

Since in our problem the strings are recurrent, we may use prefix automaton to count the number of occurences. To calculate the number of occurences of string s in F(x), let's build prefix function for s, and an automaton Ap,c which tells the value of prefix function, if the previous value was p, and we appended c to the string (the same approach is used in KMP substring search algorithm). Then, let's build another automaton that will help us work with Fibonacci string: Fp,x — what will be the value of prefix function, if we append F(x) to the string? For x=0 and x=1, this automaton can be easily built using Ap,0 and Ap,1; and for x>1, we may build Fp,x using the automatons for x−2 and x−1. We also have to keep track of the number of occurences, that can be done with another automaton on fibonacci strings.

There is a corner case when we need to stop descending the trie; to handle it, we need to check whether some string is a suffix of F(n), but that can be easily made by checking if F0,n=|s|.

Each step in trie forces us to do up to three (depending on your implementation) queries like "count the number of occurences of some string in F(n)", so overall the solution works in O(nm2).

Educational Codeforces Round 51 Editorial

By BledDest, 4 years ago, translation, In English1051A - Vasya And Password

Tutorial1051A - Vasya And PasswordThere are just a few general cases in the task to consider:

If the password s is already valid, nothing has to be changed, just print s.Try to change exactly one character, iterate over all positions in s and all three options for character (any digit, any lowercase or uppercase Latin letter). After the replacement the string is checked for the validity and printed if it turned out to be valid.We weren't able to replace a substring of length 0 or 1, then the answer is at least 2. We can obtain it in a following manner: replace the first two characters to "a1" if the third character is an uppercase Latin letter, to "A1" if the third character is a lowercase Latin letter and to "aA" if the third character is a digit.Solution (Ajosteen)1051B - Relatively Prime Pairs

Tutorial1051B - Relatively Prime PairsNumbers with the difference of 1 are always relatively prime. That's the only thing I should mention for this editorial.

Overall complexity: O(r−l).

Solution (PikMike)1051C - Vasya and Multisets

Tutorial1051C - Vasya and MultisetsWrite down all the numbers, which appear exactly once, let there be k of them. If k is even, put the first k2 of them into the first multiset and put the other k2 into the second multiset. All the other numbers (which appear more than once) also go into the first multiset. The only nice numbers will be the initial k, thus the answer is valid.

If k is odd and there is no number to appear more than twice, then the answer is "NO", as all the numbers to appear exactly twice don't change the difference of the amounts of the nice numbers at all. If there is a number to appear more than twice (let it be x), then let's firstly add ⌈k2⌉ of the numbers to appear exactly once to the first multiset, add ⌊k2⌋ others of them to the second multiset. Then the first occurrence of x goes to the second multiset and all the other numbers go to the first multiset. It's easy to notice that multisets will contain equal number of the nice numbers after all the partitioning.

Solution (Ajosteen)1051D - Bicolorings

Tutorial1051D - BicoloringsThe problem is about counting the number of some combinatoric objects. Thus, dynamic programming is always the answer.

Let dp[i][j][mask] be the number of beautiful bicolorings of the first i columns such that j components are already created and can't be modified and the colors of the i-th column are determined by mask (its first bit is the color of the lower cell and its second bit the color of the upper cell). Component can be modified if the cell from the i-th column belongs to it.

The initial states are dp[0][0][mask]=1 for each mask=0..3 and dp[i][j][mask]=0 for any other state.

You should iterate over the possible nmask for the next column and recalculate the number of components. You can easily show that the current number of components and the last column is actually enough to get the new number of components.

In my code I have some function get(mask,nmask) to determine the added number of components while transitioning from mask to nmask. These are just the couple of cases to handle carefully.

Then all the transitions are:

dp[i+1][j+get(mask,nmask)][nmask] += dp[i][j][mask].

However, the last column won't contain the answer as it is, the number of components will be incorrect. Let's add some dummy column n+1 equal to mask⊕3 for each mask. This will add all the real component to the total number. So the answer is the sum of dp[n][k−get(mask,mask⊕3)][mask] over all mask=0..3.

Overall complexity: O(n2⋅4m), where m is the number of rows (2 for this problem).

Solution (PikMike)1051E - Vasya and Big Integers

Tutorial1051E - Vasya and Big IntegersLet's use dynamic programming to solve the problem. Let dpx be the number of correct partitions for the long integer axax+1…an.

It's easy to see that if we have two big integers without leading zeroes, we know the lengths of these integers, and these lengths are not equal, then we can determine which integer is greater in O(1).

We will calculate the answers in the following order: dp|a|,dp|a|−1…dp1. Suppose we want to calculate dpx.

Let L be the minimum position such that the number axax+1…aL meets the following condition: l≤axax+1…aL≤r.

Let R be the maximum position such that the number axax+1…aR meets the following condition l≤axax+1…aR≤r.

Initially let's consider L=x+|l| и R=x+|r|. L will be less if axax+1...ax+|l|<l. R will be less if axax+1...ax+|r|>r.

To determine which of the numbers axax+1...ax+|l| and l is greater let's calculate z-function for the string l+#+a, where # is any character that doesn't occur in a and l. After calculating z-function we can easily find the first non-equal character in axax+1...ax+|l| and l, and this character will determine which number is greater. To compare axax+1...ax+|r| and r we can act the same.

All that's left is to set dpx to the sum of dp values from L to R. This can be done by maintaining suffix sums.

There is a corner case, which applies when ax=0. If l>0, then dpx=0 because we cannot afford any leading zeroes. Otherwise dpx=dpx+1.

Solution (Ajosteen)1051F - The Shortest Statement

Tutorial1051F - The Shortest StatementFirstly let's find any spanning tree and root it at any vertex. For each vertex we calculate the distance to the root (let it be hv for vertex v). There are no more than 21 edges that don't belong to the tree. For each of these edges, let's run Dijkstra's algorithm from some vertex incident to this edge.

Suppose we are answering a query u v. If the shortest path between these vertices passes only along the edges of the tree, then it can be calculated by the formula hv+hu−2hlca(u,v), where lca(u,v) is the lowest common ancestor of vertices u and v. You may use any fast enough algorithm you know to calculate lca(u,v).

Otherwise there exists at least one vertex such that we ran Dijkstra's algorithm from it, and it belongs to the shortest path. Just iterate on every vertex for which we ran Dijkstra and update the answer with the value of du+dv, where dx is the shortest path to the vertex x from the fixed vertex.

Solution (Ajosteen)1051G - Distinctification

Tutorial1051G - DistinctificationLet's firstly try to come up with some naive solution.

Suppose we have a list S and want to calculate f(S) for it. Let's sort this list, comparing the pairs by their values of ai, and then process them one-by-one. We will divide this list into some parts (we will call them components) with the following process: when processing the first pair in the sorted order, let's iterate on the next pairs (also in the sorted order) and add them to the first pair's component until the following condition is met: ay−ax>y−x, where x is the index of the first pair we added, and y is the index of the pair we are currently trying to add to x's component (remember that we consider all these pairs in the sorted order).

What is the meaning of this condition? ay−ax≤y−x means that the number of pairs between x and y (including these two) is not less that the number of integers in [ax,ay] — and while this condition is met, we can use the first operation in order to make a pair having ai=z for every z∈[x,y]. And the first time when the condition ay−ax>y−x is met, we obviously cannot "expand" the segment in such a way. It means that the a-value of y will always be greater than a-value of x, and y won't belong to the same component with x (and will start creating its own component instead).

These components we form have one special property. Suppose we "expanded" the component so that there are no two equal values of ai in it. Then we may reorder the pairs in this component as we wish (to do so, we may "contract" the component using the second operation, and then "expand" it again). Of course, the best course of action is to sort the pairs in the component by their values of bi in descending order. After doing this for every component, we will obtain an optimal configuration such that all values of ai are distinct, and it's easy to calculate the answer.

Okay, now we need to do it fast. The following will help us:

DSU;Some implicit logarithmic data structure (the operations we need are "count the sum of elements less than x" and "count the number of elements greater than y"; your implementation might use other operations);Small-to-large merging.DSU will help us maintain the components. A data structre will be built for each component containing the values of bi in it; it will help us to maintain the sum of opt(i)bi, where opt(i) is the optimal index of bi in this component. Depending on your implementation, you may or may not need to store the minimum value of ai in the component. When inserting some element having bi=b into some component, the elements having bi>b don't change their position, the new element will be added right after them, and the remaining elements will be shifted to the right; so the sum of opt(i)bi can be maintained if we query the number of elements greater than b and the sum of elements less than b.

Okay, but we still don't know how we create the components and how we determine if two components are to merge. We will keep these components in "expanded" form; that is, when processing a pair (ai,bi), let's find the leftmost unoccupied position after ai (or ai, if it is not occupied) and occupy it with the new pair, creating a new component for it. If the newly occupied index is pos, let's try to merge new component with components occupying pos−1 and pos+1 (if there are any); to merge two components, do the required operations in DSU and unite the data structures built in these components with small-to-large method.

All this works in O(nlog2n), the most time-consuming part is merging the data structures.

Educational Codeforces Round 50 Editorial

By awoo, history, 4 years ago, translation, In English1036A - Function Height

Tutorial1036A - Function HeightIt is easy to see that the area of the plot is the sum of areas of all triangles in this plot. Each move increases area by one. We cannot obtain the answer less than ⌈kn⌉ but we always can obtain such an answer.

Solution (Vovuh)1036B - Diagonal Walking v.2

Tutorial1036B - Diagonal Walking v.2There are several cases in this problem. If n<m then let's swap them. Let % be the modulo operator. Firstly, if n%2≠m%2 then let's decrease k and n by one. Otherwise if n%2≠k%2 let's decrease n, m by one and k by two. Now if k<n then the answer is -1, otherwise the answer is k. You can get more clear description of these cases if you will draw some cases on the paper.

Solution (Vovuh)1036C - Classy Numbers

Tutorial1036C - Classy NumbersThere are quite a few approaches to the problem. I'll describe the two of them which I actually implemented.

First approach - combinatoric one:

Problems of the form "count the number of beautiful numbers from L to R" usually require counting the numbers on [1;R] and [1;L−1] (or not inclusively [1;R+1) and [1;L)) and subtracting one from another. Let's try this thing here, counting calc(R+1)−calc(L) not inclusively.

Let's fix some prefix of the upper border number. We want to calculate the amount of numbers having the same prefix but being smaller in the next digit. If we count it for all prefixes (including the empty one), we will get the answer.

And that is pretty easy. Let the prefix include k non-zero digits, the length of the suffix be x and the digit after the chosen prefix is d. If d is zero then there the result is obviously zero. Otherwise we can either put 0 or any of the (d−1) non-zero digits. Then the formula is:

∑i=03−k(x−1i)⋅9i + (d−1)⋅∑i=03−k−1(x−1i)⋅9i.

We choose i positions from the suffix to put non-zero digits in them (any digit from 1 to 9) and fill the rest with zeros.

Overall complexity: O(T⋅logn).

Second approach - precalc one:

This is a bit easier to implement. Actually, there are just about 700000 valid numbers, you can generate them all, put them into the array in sorted order and binary search for the given queries.

Overall complexity: O(T⋅logANSCNT).

Solution with combinatorics (PikMike)Solution with precalc (PikMike)1036D - Vasya and Arrays

Tutorial1036D - Vasya and ArraysLet's prove that next greedy solution works: each step we will find prefixes of minimal length of arrays A и B such that its sums are equal and we will cut them forming next block. If we will get valid partition in result so it is an optimal solution, otherwise there is no solution. Since length of prefix proportional to its sum, so prefixes are minimal since its sums are minimal.

Let's prove this algorithm: let optimal solution have alternative partition. Since our solution cuts minimal possible prefixes, so (at some step) optimal solution cuts prefix with greater sum (and greater length). But this prefixes in optimal solutions contain smaller prefixes, found by greedy solution, so it can be divided on two parts — contradiction.

So we can keep prefixes and increase one which have smaller sum.

Result complexity is O(n).

Solution (Ajosteen)1036E - Covered Points

Tutorial1036E - Covered PointsI won't tell all the small geometric details, just cover some major points.

The problem asks you the following thing. Sum up the total number of points covered by each segment and for each unique point subtract the number of segments covering it minus one. Let's reformulate it. For each segment add the number of points covered by it and subtract the number of points covered by it and by some already processed segment.

The first part is easy. Segment covers exactly GCD(|x1−x2|,|y1−y2|)+1 points with integer coordinates. The proof left to the reader as an exercise.

The second part can be done in the following manner. Intersect the segment i with all segments j<i, insert all the points of intersection into set and take its size. You can consider only integer points of intersection and use no floating-point numbers in your program.

Overall complexity: O(n2logn).

Solution (PikMike)1036F - Relatively Prime Powers

Tutorial1036F - Relatively Prime PowersWhoops, it seems, this problem can be done in a similar manner as in problem C.

Firstly, is some number x has GCD of the prime powers not equal to 1, then you can take root GCD'th power from it. That is the same as dividing all powers by GCD.

Now it turned out, there are really a small amount of these numbers up to 1018 (if you take the squares out).

Actually, our solution wasn't that. Let's count the answer using inclusion-exclusion principle. For this Mobius function can be used. The answer is:

∑i=1∞(⌊n1i⌋−1)⋅μi.

The power part is the amount of numbers, which raised to the i-th power becomes less ot equal to n. This turns zero for like 60 iterations on i for any n up to 1018. However, calculating each log as it is will lead to a O(T⋅log2n) solution, which might be too slow.

Let's process the queries in the decreasing order of n. n−−√ will be calculated naively each time (in O(1) (or however complexity has the built-in function, O(loglogn) maybe) or O(logn)). The rest powers will be initialized with their upper limits in the start (like 106 for 3, 103 for 6 and so on). Now proceeding to the next number will only decrease the current maximum number for each power. Subtract one until you reach the needed number and check in logn.

Overall complexity: O(T⋅(logn+logT)).

Solution (PikMike)1036G - Sources and Sinks

Tutorial1036G - Sources and SinksSince the graph is acyclic, then for every vertex there exists a path to some sink, and to every vertex there exists a path from some source. So our problem can be reduced to the following: check that after running our algorithm, all vertices from the initial set of sources and sinks belong to the same strongly connected component. Let C be the number of sources (or sinks) in the initial graph.

First of all, let's run DFS (or any other graph traversal) from every source to form a set of reachable sinks for every source. This part of solution has complexity of O(C(n+m)).

If X is some set of sources of the original graph, let f(X) be the set of sinks such that every sink from f(X) is reachable from at least one source from X. It's easy to see that there exists some set X such that |X|≠0, |X|≠C and |X|≥|f(X)|, then the answer is NO — if we connected the sinks from f(X) with the sources from X, then any sink not belonging to f(X) would be unreachable from any sink belonging to f(X). Checking every possible set X can be done in O(C22C) or in O(C2C).

Let's prove that there is no such set X, then the answer is YES. Let s be an arbitrary sink of the original graph. Also, if S is some set of sinks, let h(S) be the set of sources containing every source directly connected to some sink from S. We can use mathematical induction to prove that every source and every sink is reachable from s in the resulting graph:

Initially we state that s is reachable from s (quite obvious);If there is a set of sinks S reachable from s, then either |S|=C (and the whole graph is reachable from s), or the number of sinks reachable from h(S) is at least |S|+1, so some set of |S|+1 sinks is reachable from s.So in fact checking every possible subset of sources is enough.

Educational Codeforces Round 49 Editorial

By awoo, history, 4 years ago, In English1027A - Palindromic Twist

Tutorial1027A - Palindromic TwistIf some string can't be transformed to palindrom then it has some pair of positions (i,n−i+1) with different letters on them (as no such pair affects any other pair). Thus you need to check each pair for i from 1 to n2 and verify that the distance between the corresponding letters is either 0 or 2.

Overall complexity: O(T⋅n).

Solution (PikMike)1027B - Numbers on the Chessboard

Tutorial1027B - Numbers on the ChessboardLet's see the following fact: if we will decrease ⌈n22⌉ from all numbers written in cells with an odd sum of coordinates and write out the numbers obtained on the board from left to right from top to bottom, the sequence will looks like 1,1,2,2,…,⌈n22⌉,⌈n22⌉ for even n (for odd n there is only one number ⌈n22⌉ at the end of the sequence, but, in general, it does not matter).

Let's try to find out the answer for some query (x,y). Let cnt=(x−1)⋅n+y (1-indexed). There cnt is the position of our cell in order of the written sequence. The first approximation of the answer is ⌈cnt2⌉. But now we are remember that we decreased ⌈n22⌉ from all numbers written in cells with an odd sum of coordinates. So if x+y is even then the answer is ⌈cnt2⌉, otherwise the answer is ⌈cnt2⌉+⌈n22⌉. Note that you should be careful with integer overflow in C++, Java or similar languages. 64-bit datatype is quite enough.

Time complexity: O(q).

Solution (Vovuh)1027C - Minimum Value Rectangle

Tutorial1027C - Minimum Value RectangleLet's work with the formula a bit:

P2s = 4(x+y)2xy = 4(2+xy+yx) = 8+4(xy+yx)Let a=xy, then the formula becomes 8+4(a+1a). Considering x≥y, a=xy≥1, thus (a+1a) is strictly increasing and has its minimum at a=1.

So the solution will be to sort the list, extract the pairs of sticks of equal length and check only neighbouring pairs in sorted order for the answer.

Overall complexity: O(nlogn).

Solution (PikMike)1027D - Mouse Hunt

Tutorial1027D - Mouse HuntMouse jumps on a cycle at some point, no matter the starting vertex, thus it's always the most profitable to set traps on cycles. The structure of the graph implies that there are no intersecting cycles. Moreover, mouse will visit each vertex of the cycle, so it's enough to set exactly one trap on each cycle. The only thing left is to find the cheapest vertex of each cycle. This can be done by a simple dfs.

Overall complexity: O(n).

Solution (adedalic)1027E - Inverse Coloring

Tutorial1027E - Inverse ColoringYou can notice that every coloring can be encoded by the two binary strings of length n. You firstly generate one string to put as a first row and then use the second string to mark if you put the first string as it is or inverting each color.

That way, you can also guess that the area of maximum rectangle of a single color you will get in you coloring is the product of maximum lengths of segments of a single color in both of the strings.

Let's consider the following dynamic programming solution:

dp[i][j][k] is the number of binary strings of length i, such the current last segment of a single color has length j and the maximum segment of a single color has length k.

The transitions are:

dp[i+1][j+1][max(k,j+1)] += dp[i][j][k] — color the new tile the same as the previous one;dp[i+1][1][max(k,1)] += dp[i][j][k] — color the new tile the opposite from the previous one.The starting state is dp[0][0][0]=1.

Let's sum the values of this dp to an array cnt[i] — the number of binary strings of length n such that the maximum segment of a single color in them has length i. You can also do another dp to calculate this not in O(n3) but in O(n2) using some partial sums in it.

Finally, you iterate over the first side of the resulting rectangle (the maximum length of segment of a single color in a first binary string) and multiply the number of ways to get it by the total number of ways to get the second side of the resulting rectangle, so that the area doesn't (k−1).

Overall complexity: O(n3) or O(n2).

Solution (PikMike) O(n^3)Solution (BledDest) O(n^2)1027F - Session in BSU

Tutorial1027F - Session in BSUThis problem has many approaches (as Hall's theorem, Kuhn algorithm (???) and so on), I will explain one (or two) of them.

Let's find the answer using binary search. It is obvious that if we can pass all the exams in k days we can also pass them in k+1 days.

For the fixed last day k let's do the following thing: firstly, if there exists some exam with the day of the first opportunity to pass it greater than k, then the answer for the day k is false.

Next, while there exist exams having only one possibility to pass them (because of the upper bound of the maximum possible day or constraints imposed by the other exams), we choose this day for this exam and continue (after choosing such day there can appear some new exams with the same property). Now there are no exams having only one day to pass them.

Let's take a look on the graph where vertices represent days and edges represent exams (the edge between some vertices u and v (u<v) exists iff there is an exam with the first day to pass it equal to u and the second day to pass it equal to v). Let's remove all the exams for which we identified the answer. Now let's take a look on the connected components of this graph and analyze the problem which we have now. Our problem is to choose exactly one vertex incident to each edge of the connected component such that no vertex is chosen twice (and we have to do this for all the connected components we have).

Let cntv be the number of vertices in the current connected component and cnte be the number of edges in the current connected component. The answer for the connected component is true iff cnte≤cntv, for obvious reasons. There is very easy constructive method to see how we can do this. If cnte<cntv then the current connected component is a tree. Let's remove some leaf of this tree and set it as the chosen vertex for the edge incident to this leaf (and remove this edge too). If cnte=cntv then let's remove all leaves as in the algorithm for the tree. For the remaining cycle let's choose any edge and any vertex incident to it, set this vertex as the chosen to this edge and remove them. Now we have a chain. Chain is a tree, so let's apply the algorithm for the tree to this chain.

So, if for some connected component c holds cntec>cntvc then the answer for the day k is false. Otherwise the answer is true.

Overall complexity O(nlogn) because of numbers compressing or using logarithmic data structures to maintain the graph.

Also there is another solution (which can be too slow, I don't know why it works). It is well-known fact that if we will apply Kuhn algorithm to the some bipartite graph in order of increasing indices of vertices of the left part, then the last vertex in the left part of this graph which is in the matching will be minimum possible. Oh, that's what we need! Let the left part of this graph consist of days and the right part consist of exams. The edge between some vertices u from the left part and v from the right part exists iff u is one of two days to pass the exam v. Let's apply Kuhn algorithm to this graph, considering days in increasing order. The first day when matching becomes n (all exams are in the matching) will be the answer. I don't know its complexity, really. Maybe it works too fast because of the special properties of the graph... If someone can explain in which time it works I will very happy!

Solution (Vovuh)Solution (Vovuh) Kuhn's Algorithm1027G - X-mouse in the Campus

Tutorial1027G - X-mouse in the CampusSome notes:

At first, there is x−1modm since (x,m)=1 (lets define GCD(a,b) as (a,b)). That means that for each v=0..m−1 there is exactly one u that u⋅x=v. So if we look at this problem as the graph then it consists of cycles (consider loops as cycles of length one). So we need to know number of cycles in this graph.

At second, (v,m)=(v⋅xmodm,m) since (x,m)=1, v⋅xmodm=v⋅x−m⋅k and (v,m)∣v and (v,m)∣m. So all v can be divided in groups by its (v,m). And we can calculate number of cylces in each group independently.

Let fix some GCD equal to g. All numbers v such that (v,m)=g can be represented as v=g⋅v′ and (v′,m)=1. Number of such v equals to φ(mg). Moreover gv′⋅x≡gv′⋅(xmodmg)modm. Here we can shift from v, x and m to v′, (xmodmg) and mg.

In result we need for each d∣m calculate number of cycles created by xmodd from numbers v, that 1≤v<d and (v,d)=1. Lets set x=xmodd.

Next step is to find minimal k>0 such that xk≡1modd, let's name it order of x or ord(x). Then for each 0≤i,j<k if i≠j then xi≢xj and v⋅xi≢v⋅xj, so each cycle will have length equal to ord(x) and number of cycles will be equal to φ(d)ord(xmodd).

Last step is calculate ord(x) for each d∣m. There is a fact that ord(x)∣φ(d) so can try to iterate over all divisors df of φ(d) and check xdf≡1 by binary exponentiation (It seems as O(divs(m)2logm) but it's faster and author's version work around 2 seconds. It doesn't pass but somebody can write better). But we'll speed it up. Let φ(d)=pa11pa22…pakk. So we can independently for each pi find its minimal power bi≤ai such that xφ(d)⋅pbi−aii≡1. We can just iterate over all pi and ai since ∑ai=O(logm).

Some words about finding φ(d) — its factorization differs from factorization of d just by lowering degrees of primes and adding factorizations of some (pi−1). But we can manually find factorization of (pi−1) with memorization (or even without it) since ∑pi−−√≤∏pi−−√=O(m−−√).

So our steps are next: factorize m, recursively iterate over all divisors of m, find φ(d) and ord(xmodd), and add to the answer φ(d)ord(xmodd).

Result complexity is O(m−−√+divs(m)⋅log2m).

And the last note is how to multiply a,b<1014 modulo mod≤1014. You can use binary multiplification which will give you extra logm what is not critically in this task (in C++, of course). Or you can use multiplification from hashes, which will work with 64 bit double, since it's only 1014.

Educational Codeforces Round 48 — Editorial

By BledDest, history, 5 years ago, translation, In English1016A - Death Note

Tutorial1016A - Death NoteIn this problem all we need is to maintain the variable res which will represent the number of names written on the current page. Initially this number equals zero. The answer for the i-th day equals ⌊res+aim⌋. This value represents the number of full pages we will write during the i-th day. After the answering we need to set res:=(res+ai)%m, where operation x%y is taking x modulo y.

Solution (Vovuh)1016B - Segment Occurrences

Tutorial1016B - Segment OccurrencesLet's take a look at a naive approach: for each query [l,r] you iterate over positions i∈[l,r−|m|+1] and check if s[i,i+|m|−1]=t. Okay, this is obviously O(q⋅n⋅m). Now we notice that there are only O(n) positions for t to start from, we can calculate if there is an occurrence of t starting in this position beforehand in O(n⋅m). Thus, we transition to O(q⋅n) solution. Finally, we calculate a partial sum array over this occurrence check array and answer each query in O(1).

Overall complexity: O(n⋅m+q).

Solution (PikMike)1016C - Vasya And The Mushrooms

Tutorial1016C - Vasya And The MushroomsA route visiting each cell exactly once can always be denoted as follows: several (possibly zero) first columns of the glade are visited in a zigzag pattern, then Vasya goes to the right until the end of the glade, makes one step up or down and goes left until he visits all remaining cells:

There are n - 1 such routes. To calculate the weight of collected mushrooms quickly, we will precompute three arrays for the first row of the glade — sum123, sum321 and sum111. sum123 will be used to compute the weight of mushrooms collected when Vasya moves to the right until the last column of the glade, sum321 — when Vasya moves to the left from the last column, and sum111 — to handle the growth of mushrooms.







Also we have to compute the same arrays for the second row of the glade.

Let's iterate on the number of columns Vasya will pass in a zigzag pattern and maintain the weight of mushrooms he will collect while doing so. Then we have to add the weight of the mushrooms Vasya will gather while moving to the right, and then — while moving to the left. The first can be handled by arrays sum123 and sum111, the second — by arrays sum321 and sum111.

Solution (Ajosteen)1016D - Vasya And The Matrix

Tutorial1016D - Vasya And The MatrixIf , then there is no suitable matrix. The operation  means xor.

Otherwise, we can always construct a suitable matrix by the following method: the first element of the first line will be equal to . The second element of the first line is b2, the third element is b3, the last one is bm.

The first element of the second line will be a2, the first element of the third line is a3, the first element of the last line is an. The rest of the elements will be zero.

It is not difficult to verify that the matrix obtained satisfies all the restrictions.

Solution (Ajosteen)1016E - Rest In The Shades

Tutorial1016E - Rest In The ShadesLet's calculate the answer for a fixed point P. If you project with respect of P each segment of the fence to the line containing light source you can see that the answer is the length of intersection of fence projection with segment (A,B) of the trajectory light source.

Key idea is the fact that the length of each fence segment is multiplied by the same coefficient k=Py+|sy|Py.

On the other hand, fence segments whose projections lie inside (A,B) form a subsegment in the array of segments, so its total length can be obtained with partial sums. And at most two fence segment are included in the answer partially, their positions can be calculated with lower_bound if you project points A and B on OX axis.

So now you can answer the query with O(logn) time (and quite small hidden constant) and resulting complexity is O(n+qlogn).

Solution (adedalic)1016F - Road Projects

Tutorial1016F - Road ProjectsThe first solution (editorial by PikMike)

Firtsly, we can notice that we get the most profit by placing the edge in a same position, no matter the query. Moreover, once you have calculated the minimum difference you can apply to the shortest path difmin by adding edge of the weight 0, you can answer the queries in O(1) each. Let the current shortest distance between 1 and n be curd. Then the answer to some query x is min(curd,curd−mind+x).

Let's proceed to proofs of the following. Consider any of the optimal positions for the edge of weight 0. Then weight 1 will add 1 to the answer in this position (if the path isn't curd already but that is trivial). Let there be another position such that the answer in it is less than the current one. That means that the answer for weight 0 in it is less by 1 which is smaller than the first one we got, which leads to contradiction. The second fact can deduced from the first one.

Then let me introduce the next bold statement. We root the tree with vertex 1. Then if there exists such a vertex in that it's not an ancestor of vertex n and the number of vertices in its subtree (inclusive) is greater than 1 then difmin=0. That is simple: just put the edge between the parent of this vertex and any of vertices of the subtree, there always be such that the edge doesn't exist yet. That won't change the shortest path, no matter which x it is.

Then, we have a graph of the following kind:



That is the simple path between 1 and n and some vetices on it have additional children leaves. Finally, let's proceed to the solution.

We want to choose such a pair of vertices that the sum of edge on a path between them, which are also a part of the path between 1 and n plus the weights of the newly included to shortest path edges (if any) is minimal possible. Let's precalc dv — the sum of weights of edges from vertex 1 to vertex v and pv — parent of vertex v. Let w(v,u) be the weight of an edge between v and u. Then we end up with the four basic cases for these vertices v and u with v having greater or equal number of edges on path to 1 than u: each of the form (whether v belongs to the simple path between 1 and n, whether u belongs to it).

u doesn't belong: the answer is dv+w(pu,u)−d[pu];u belongs, v doesn't: du+w(pv,v)−d[pv];both belongs: dv−du.Each of these formulas can be broken down to parts with exacly one of the vertices. Let's call them ptv and ptu. That means minimizing the result is be the same as minimizing each of the parts.

We run depth-first search on vertices which belong to a simple path between 1 and n inclusive. Maintain the minimum value of ptu you have already passed by. Try connecting each vertex with this u and also parent of the parent of the current vertex using all the possible formulas and updating difmin with the resulting value.

Finally, after the precalc is finished, asnwer the queries in O(1) with difmin.

Overall complexity: O(n+q).

The second solution (editorial by BledDest)

Let's denote the distance from vertex 1 to vertex x in the tree as d1(x). Similarly, denote the distance from n to x in the tree as dn(x).

Suppose we try to add a new edge between vertices x and y with length w. Then two new paths from 1 to n are formed: one with length d1(x)+w+dn(y), and another with length d1(y)+w+dn(x). Then the new length of shortest path becomes min(d1(n),d1(x)+w+dn(y),d1(y)+w+dn(x)). So if we find two non-adjacent vertices such that min(d1(x)+dn(y),d1(y)+dn(x)) is maximum possible, then it will always be optimal to add an edge between these two vertices.

How can we find this pair of vertices? Firstly, let's suppose that d1(x)+dn(y)≤d1(y)+dn(x) — when we pick vertex x, we will try to pair it only with vertices y corresponding to the aforementioned constraint. This can be done by sorting vertices by the value of d1(x)−dn(x) and then for each vertex x pairing it only with vertices that are later than x in the sorted order.

How do we find the best pair for x? The best pair could be just the vertex with maximum possible dn(y), but it is not allowed to connect a vertex with itself or its neighbour. To handle it, we may maintain a set of possible vertices y, delete all neighbours of x from it, pick a vertex with maximum dn, and then insert all neighbours of x back into the set.

This solution works in O(nlogn+q) time.

The first solution (PikMike)The second solution (BledDest)1016G - Appropriate Team

Tutorial1016G - Appropriate TeamAt first, X∣Y must be met (since X∣v and v∣Y). Now let Y=ppy11ppy22…ppyzz and X=ppx11ppx22…ppxzz. From now on let's consider only pk such that pxk<pyk.

Now let's look at ai: X∣ai must be met. Let ai=ppa11ppa22…ppall⋅a′. Since GCD(v,ai)=X, if pak>pxk then v must have pk to the power of pxk in its factorization; otherwise power of pk can be any non-negative integer ≥pxk. It leads us to the bitmask of restrictions mini (mini[k]=(pak>pxk)) with size equal to the number of different prime divisors of Y.

In the same way let's process aj. Of course, aj∣Y and if pak<pyk then v must have pk to the power of pyk in its factorization. This is another restriction bitmask maxj (maxj[k]=(pak<pyk)).

So, for any pair (i,j) there exists v if and only if mini AND maxj=0. Since we look only at pk where pxk<pyk then v can't have power of pk equal to pxk and pyk at the same time. For any other p it is enough to have power of p in v equal to the power of p in Y (even if it's equal to 0).

So, for each maxj we need to know the number of ai such that mini is a submask of NOT maxj. So we just need to calculate sum of submasks for each mask; it can be done with O(n⋅2n) or O(3n).

Finally, how to factorize number A up to 1018. Of course, Pollard algorithm helps, but there is another way, which works sometimes. Let's factorize A with primes up to 106. So after that if A>1 there is only three cases: A=p, A=p2 or A=p⋅q. A=p2 is easy to check (sqrtl helps). Otherwise, just check GCD with all ai, X and Y: if you have found GCD≠1 and GCD≠A, then A=p⋅q and you have found p. Otherwise you can assume that A=p, because this probable mistake doesn't break anything in this task.

Result complexity is O(A13+nlogA+z⋅2z) where z is the number of prime divisors of Y (z≤15).

Разбор Educational Codeforces Round 47

By awoo, history, 5 years ago, translation, In English1009A - Game Shopping

Tutorial1009A - Game ShoppingLet's keep the variable pos which will represent the number of games Maxim buy. Initially pos=0. Assume that arrays a and c are 0-indexed. Then let's iterate over all i=0…n−1 and if pos<m and a[pos]≥c[i] make pos:=pos+1. So pos will be the answer after this cycle.

Solution (Vovuh)1009B - Minimum Ternary String

Tutorial1009B - Minimum Ternary StringLet's notice that described swaps allows us to place any '1' character to any position of the string s (relative order of '0' and '2' obviously cannot be changed). Let's remove all '1' characters from the string s (and keep their count in some variable). Now more profitable move is to place all the '{1}' characters right before the first '2' character of s (and if there is no '2' character in s, then place they after the end of the string).

Solution (Vovuh)1009C - Annoying Present

Tutorial1009C - Annoying PresentJudging by constraints, you can guess that the greedy approach is the right one.

Firstly, let's transition from maximizing the arithmetic mean to the sum, it's the same thing generally.

Secondly, notice that each x is being added to each element regardless of the chosen position.

Finally, take a look at a function f(d,i) — total sum obtained by applying change with d to position i and notice that it is non-strictly convex. Its maximum or minimum values can always be found in one of these positions: n2 (method of rounding doesn't matter), 1 and n.

Thus, the solution will look like this: for positive d you apply the change to position 1 and for non-positive d — to position ⌊n2⌋. The impact of the change can be calculated with the formula of the sum of arithmetic progression.

Also, you should either do all of your calculations in long double (10-byte type) or maintain sum in long long (you can estimate it with m⋅n2⋅MAXN≤1018, so it fits) and divide it by n in the end (then double will work).

Overall complexity: O(m).

Solution (PikMike)1009D - Relatively Prime Graph

Tutorial1009D - Relatively Prime GraphEven though n is up to 105, straightforward O(n2logn) solution will work. You iterate for i from 1 to n in the outer loop, from i+1 to n in the inner loop and check GCD each time. When m edges are found, you break from both loops.

Here is why this work fast enough. The total number of pairs (x,y) with 1≤x,y≤n,gcd(x,y)=1 is φ(1)+φ(2)+⋯+φ(n), where φ is Euler's totient function. We also want to substract a single pair (1,1). And this sum grows so fast that after about 600 iteratons φ(1)+φ(2)+⋯+φ(600) will be greater than 100000 for any n.

The only thing left is to check that m is big enough to build a connected graph (m≥n−1) and small enough to fit all possible edges for given n (the formula above).

Overall complexity: O(n2logn).

Solution (PikMike)1009E - Intercity Travelling

Tutorial1009E - Intercity TravellingLet's consider each kilometer of the journey separatedly and calculate the expected value of its difficulty (and then use linearity of expectation to obtain the answer).

The difficulty of each kilometer depends on the rest site right before it (or, if there were no rest sites, on the distance from Moscow to this kilometer). So when considering the difficulty of i-th kilometer (one-indexed), we may obtain a formula:

diffi=a12+a222+⋯+ai−12i−1+ai2i−1. The denominator of the last summand is 2i−1 because it represents the situation where the last rest was in Moscow, and its probability is exactly 12i−1.

We can actually rewrite this as follows: diff1=a1, diffi+1=diffi−ai2i+ai+12i, thus calculating all that we need in linear time.

Solution (BledDest)1009F - Dominant Indices

Tutorial1009F - Dominant IndicesIn this problem we can use small-to-large merging trick (also known as DSU on tree): when building a depth array for a vertex, we firstly build depth arrays recursively for its children, then pull them upwards and merge them with small-to-large technique. In different blogs on this technique it was mentioned that this will require O(nlogn) operations with structures we use to maintain depth arrays overall.

However, in this problem we may prove a better estimate: it will require O(n) operations. That's because the size of depth array (if considering only non-zero elements) for a vertex is equal to the height of its subtree, not to the number of vertices in it. To prove that the number of operations is O(n), one can use the intuitive fact that when we merge two depth arrays, all elements of the smaller array are "destroyed" in the process, so if the size of smaller array is k, then we require O(k) operations to "destroy" k elements.

The main problem is that we sometimes need to "pull" our depth arrays upwards, thus inserting a 1 to the beginning of the array. Standard arrays don't support this operation, so we need to either use something like std::map (and the complexity will be O(nlogn)), or keep the depth arrays in reversed order and handle them using std::vector (and then complexity will be O(n)).

Solution (BledDest)1009G - Allowed Letters

Tutorial1009G - Allowed LettersThe idea of solution is the following: we build the answer letter-by-letter; when choosing a character for some position, we try all possible characters and check that we can build the suffix after placing this character. But we need to somehow do this checking fast.

As in many previous Educational Rounds, in this round some participants' solutions were much easier to write and understand than our own model solution.

Authors' solution (uses network flows):

Let's build a flow network, where we have 6 vertices representing the characters of the string and 26 vertices representing the masks of characters. Add directed edges from the source to every node representing some character with capacity equal to the number of such characters in the original string; also add directed edges from every node representing some character to all vertices representing masks where this character is contained (with infinite capacity); and finally, add a directed edge from every "mask"-node to the sink with capacity equal to the number of positions where this mask of characters is allowed.

If we find maximum flow in this network, we can check that the answer exists, and if it exists, build some answer. Now let's try to build optimal answer by somehow rebuilding the flow in the network.

Suppose we are trying to place a character x to position containing mask m. To check whether we can do it, we have to try rebuilding the flow in such a way that the edge from vertex corresponding to x to vertex corresponding to m has non-zero flow. If it is already non-zero, then we are done; otherwise we may cancel a unit of flow going through an edge from source to x-vertex, then cancel a unit of flow going through an edge from m-vertex to sink, decrease the capacity of these two edges by 1 and check that there exists an augmenting path. If it exists, then returning the capacities back and adding one unit of flow through the path source→x→m→sink actually builds some answer where some character x is placed on some position with mask m, so we may place it there; otherwise it's impossible.

When we finally decided to place x on position m, we have to decrease the flow through source→x→m→sink and the capacities of edges source→x and m→sink.

All this algorithm runs in O(n⋅2A⋅A2), where A is the size of the alphabet.

Participants' solution (uses Hall's theorem):

Hall's theorem allows us to check that we may build the suffix of the answer much easier.

Each time we try to place some character, we need to iterate on all possible subsets of characters we still need to place and check that the number of positions that are suitable for at least one character in a subset is not less than the size of subset (just like in regular Hall's theorem). The key fact here is that if we have, for example, 3 characters a yet to place, then we don't need to check any subset containing exactly 1 or 2 characters a, since the number of "suitable" positions for this subset won't become larger if we add all remaining characters a to a subset. So the subsets we have to consider are limited by the masks of possible characters, and there will be only 64 of them.

Разбор Educational Codeforces Round 46

By BledDest, 5 years ago, translation, In English1000A - Codehorses T-shirts

Editorial1000A - Codehorses T-shirtsAt first, let's remove all coinciding entries of both lists. The most convinient way is to use map/hashmap but it's not the only option. Now divide entries into categories by their length. You can notice that it takes exactly one second to remove an entry in each category (to make it equal to an entry of the opposing list). Thus the answer is n−(number of coinciding entries).

Overall complexity: O(nlogn) or O(n).

Solution1000B - Light It Up

Editorial1000B - Light It UpAt first, let's insert 0 and M in array a, so all possible positions for inserting will always belong to (ai,ai+1).

At second, let x be value to insert and ai<x<ai+1. It can be proven, that it's always optimal to move x to ai or to ai+1. So, for each (ai,ai+1) we need to check only x=ai+1 and x=ai+1−1. To check it fast enough, we need to know total time of lamp is lit for each prefix and precalculate for each i, total time of lamp is lit if starting from ai light is on / lights is off.

Result complexity is O(n).

Solution1000C - Covered Points Count

Editorial1000C - Covered Points CountThis problem with small coordinates can be solved using partial sums and some easy counting. Let's carry an array cnt, where cnti will be equal to the number of segments that cover the point with coordinate i. How to calculate cnt in O(n+maxX)?

For each segment (li,ri) let's add +1 to cntli and −1 to cntri+1. Now build on this array prefix sums and notice that cnti equals the number of segments that cover the point with coordinate i. Then ansi will be equal to ∑j=0maxXcntj=i. All the answers can be calculated in O(maxX) in total. So the total complexity of this solution is O(n+maxX).

But in our problem it is too slow to build an entire array cnt. So what should we do? It is obvious that if any coordinate j is not equals some li or some ri+1 then cnti=cnti−1. So we do not need carry all the positions explicitly. Let's carry all li and ri+1 in some logarithmic data structure or let's use the coordinate compression method.

The coordinate compression method allows us to transform the set of big sparse objects to the set of small compressed objects maintaining the relative order. In our problems let's make the following things: push all li and ri+1 in vector cval, sort this vector, keep only unique values and then use the position of elements in vector cval instead of original value (any position can be found in O(logn) by binary search or standard methods as lower_bound in C++).

So the first part of the solution works in O(nlogn). Answer can be calculated using almost the same approach as in solution to this problem with small coordinates. But now we know that between two adjacent elements cvali and cvali+1 there is exactly cvali+1−cvali points with answer equals to cnti. So if we will iterate over all pairs of the adjacent elements cvali and cvali+1 and add cvali+1−cvali to the anscnti, we will calculate all the answers in O(n).

So the total complexity of the solution is O(nlogn).

Solution1000D - Yet Another Problem On a Subsequence

Editorial1000D - Yet Another Problem On a SubsequenceThe problem is solved by the dynamic programming.

Let dpi be the answer for the prefix of the array starting at i (it contains the indices i,i+1,…,n).

If ai≤0, then dpi=0.

Otherwise, let's go over the position j, with which the next good array begins. Then we need to select ai positions among j−i−1 positions, which will be elements of the array. The number of ways to choose an unordered set of k items from n of different objects is calculated using the formula Ckn=n!K!(N−k)!. Thus, the dynamics is as follows:

dpi=∑j=i+ai+1n+1Caij−i−1⋅dpj.

The basis of dynamics is the value dpn+1=1.

Solution1000E - We Need More Bosses

Editorial1000E - We Need More BossesIt's quite obvious that we can place bosses only on the bridges of the given graph — if an edge is not a bridge, then removing it doesn't make the graph disconnected, so there still exists a path between any pair of vertices. And if we fix two vertices s and t, and then find some simple path between them, then we will place the bosses on all bridges belonging to this path (since the set of bridges would stay the same no matter which simple path between s and t we choose).

If we find bridges in the given graph and compress all 2-edge-connected components (two vertices belong to the same 2-edge-connected component iff there exists a path between these vertices such that there are no bridges on this path) into single vertices, we will obtain a special tree called bridge tree. Every edge of a bridge tree corresponds to a bridge in the original graph (and vice versa). Since we want to find the path with maximum possible number of bridges, we only need to find the diameter of the bridge tree, and this will be the answer to the problem.

Solution1000F - One Occurrence

Editorial1000F - One OccurrenceSuppose all queries have the same right border r. Then the answer for the query can be some integer i such that the last occurence of i on the prefix [1,r] of the array is inside the segment, but the second to last occurence is outside the segment (or even does not exist). More formally, let f(i) be the maximum index j such that j<i and aj=ai (or −1 if there is no such j); the answer to the query is some number ak such that l≤k≤r and f(k)<l (and k is the rightmost occurence of ak in the segment [1,r]). For a fixed right border r, we can build a segment tree which for every index x such that x is the rightmost occurence of ax on [1,r] stores the value of f(x); and if we query minimum on the segment [l,r] in such tree, we can try to find the answer. Let the position of minimum be m. If f(m)<l, then am can be the answer; otherwise there is no answer.

But this is too slow since we can't afford to build a segment tree for every possible value of r. There are two methods how to deal with this problem: you may sort all queries by their right borders and maintain the segment tree while shifting the right border (when going from r to r+1, we have to update the values in the positions f(r+1) and r+1), or we may use a persistent segment tree and get an online solution.

We tried to eliminate solutions using Mo's algorithm, but in fact it's possible to squeeze some implementations of it into TL. There are two optimizations that might help there. When dividing the elements into blocks, we may sort the first block in the ascending order of right borders, the second — in descending, the third — in ascending order again, and so on. And also it's possible to obtain a Mo-based solution with worst case complexity of O((n+q)n−−√) if we maintain the set of possible answers using sqrt decomposition on it.

Solution with persistent segment treeSolution with persistent segment tree (a bit unreadable but runs faster)Solution with standard segment treeMo-based solution1000G - Two-Paths

Editorial1000G - Two-PathsLet's solve this task in several steps.

Step 1. Calculate dpi for each vertex.

Let dpi be maximal profit of some 2-path starting at i and finishing at i. If vertex i is a root of the tree, then dpi equivalent to d′i, where d′i — maximal profit of 2-path (i,i), when we can go only in subtree of i. The d′i can be calculated with next approach: d′v=av+∑to∈Children(v)max(0,d′to−2⋅w(v,to)).

To calculate dpi we can use next technique. Let's manage next invariant: when processing vertex v all its neighbours (even parent) will hold d′i as if v its parent. Then dpv=av+∑to∈Neighbours(v)max(0,d′to−2⋅w(v,to)). After that, we can proceed with each child to of v, but before moving to it we must change value d′v since we must keep invariant true. To keep it true, it's enough to set d′v=dpv−max(0,d′to−2⋅w(v,to)). Also let's memorize value max(0,d′to−2⋅w(v,to)) as dto(v,to).

Step 2. Processing queries.

Let simple path (qu,qv) be qu→p1→p2→⋯→pk→qv. If qu=qv then answer is dpqu. Otherwise, each edge on this simple path must be used exactly once. But, while travelling from qu to qv using this simple path, at each vertex v we can go somewhere and return to v — the only condition is not use edges from simple path. And we can do it using precalculated values dpi and dto(v,to). So, if we want to find max profit of 2-path (v,v) with prohibited edges (v,to1), (v,to2), so we can use value dpv−dto(v,to1)−dto(v,to2).

Finally, to process queries, let's find l=lca(qu,qv), divide it on two queries (qu,l), (qv,l). Now we can handle all queries offline, travelling on tree in dfs order. Let's manage some data structure on current path from current vertex to the root (this DS can be based on array of depths). Then, when we come to vertex v, just add value dpv−dto(v,parent(v)) to DS in position depth(v) (and erase it before exit). Each query (v,l) becomes a query of sum to some subsegment in DS (don't forget carefully handle value in lca). And, before moving from v to to, you need subtract dto(v,to) from current value of v (here you can at once subtract weight of edge (v,to)). Don't forget to return each change in DS, when it needed.

As we can see, DS is just a BIT with sum on segment and change in position.

Result complexity is O((n+m)logn). Fast IO are welcome.

Educational Codeforces Round 45 Editorial

By awoo, history, 5 years ago, translation, In English990A - Commentary Boxes

Tutorial990A - Commentary BoxesNotice that you need to check just two numbers: the closest one less or equal to n and the closest one greater than n. Distances to them are (nmodm) and (m−(nmodm)) respectively. Now you should multiply the first result by b, the second result by a and compare the products.

Overall complexity: O(1).

Solution (PikMike)990B - Micro-World

Tutorial990B - Micro-WorldIt can be proved that the optimal answer equals to a number of bacteria which can't be eaten by any other bacteria. So for each bacteria i you need to check existence of any bacteria j satisfying condition ai<aj≤ai+K.

There plenty of ways to check this condition. One of them is to sort array a and for each i find minimal aj>ai with upper_bound or with two-pointers technique. Or you can use the fact that ai≤106 and build solution around it.

Result complexity is O(nlogn).

Solution (adedalic)990C - Bracket Sequences Concatenation Problem

Tutorial990C - Bracket Sequences Concatenation ProblemLet f(s) be the mirror reflection of the string s. For example: f("((") = "))", f("))(") = ")((", f("()") = "()".

Let string be good if it does not have a prefix, which have more closing brackets than opening ones. For example, "((", "(())(", "()()" are good, and "())", ")((", "()())" are not.

The balance bal(s) of the string s is the difference between number of opening and closing brackets in s. For example, bal("(()") = 1, bal("()") = 0.

Let cnt[x] be the number of good strings with a balance x.

The answer to the problem is ∑s, where f(s) is goodcnt[bal(f(s))].

Solution (Ajosteen)990D - Graph And Its Complement

Tutorial990D - Graph And Its ComplementLet's prove that if a>1, then b=1. Let G be the original graph, and H — the complement of the graph G. Let's look at each pair of vertices (u,v). If u and v belong to different components of the graph G, then there is an edge between them in the graph H. Otherwise, u and v belong to the same component of the graph G, but since G has more than one component, there is vertex x in other component of G, and there are edges {u,x} and {v,x} in H. That's why, there is a connected path for any pair of vertices (u,v), and the graph H is connected. Similarly, the case b>1 is proved.

So, if min(a,b)>1, then the answer is "NO". Otherwise, min(a,b)=1. Consider the case where b=1 (if b>a, we can swap a and b, and output complement of the constructed graph). To have a components in the graph G, it is enough to connect the vertex 1 with the vertex 2, the vertex 2 with the vertex 3, ⋯, the vertex n−a with the vertex n−a+1.

A particular cases are the tests n=2,a=1,b=1 and n=3,a=1,b=1. There is no suitable graph for them.

Solution (Ajosteen)990E - Post Lamps

Tutorial990E - Post LampsLet's start with learning how to place lamps of fixed power to cover the segment with the minimal number of them. The following greedy strategy works: find the rightmost non-blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp. Initially you only consider 0 to be covered. Function f(i) — the minimal number of post lamps to cover segment [0;i] is clearly monotonous, thus you want to update states as early as possible.

Okay, now you iterate over all l∈[1;k] and update the answer with the results multiplied by cost.

Now, why will this work fast? You obviously precalculate the rightmost free position for each prefix segment. If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment. Finally, any two consecutive iterations of the algorithm will either move you by k+1 positions or return -1. This can be easily proven by contradiction.

Overall complexity: O(n⋅logn), as you do about nl steps for each l and that is a common series sum.

Solution (PikMike)990F - Flow Control

Tutorial990F - Flow ControlThe answer is "Impossible" if and only if the sum of values is not equal to 0. Writing some number on edge does not change the total sum and the goal of the problem is to make 0 in each vertex, thus getting 0 in total.

The algorithm is simple: you get an arbitrary spanning tree (with dfs or dsu), output the difference between sums of values of subtrees (can be calculated with dfs) for edges in this tree and 0 for the rest of edges.

Let's take an arbitrary correct answer. If is has some cycle in graph of edges with non-zero numbers on them, then you can remove it. For example, select any edge on it and subtract the number on it from all the edges of the cycle. This doesn't break the correctness of the answer, as you change both in and out flows for each vertex by the same value. Now that edge has 0. This way, any answer can be transformed to tree. And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller.

Overall complexity: O(n+m).

Solution (PikMike)990G - GCD Counting

Tutorial990G - GCD CountingFirstly, for every i∈[1,2⋅105] we can calculate the number of paths such that g(x,y) is divisible by i. We can do it as follows: generate all divisors of numbers ai (numbers not exceeding 2⋅105 have at most 160 divisors, so this will be fast enough), and then for every i∈[1,2⋅105] analyze the graph containing the vertices that have i as its divisor. Each component of this graph gives us k(k+1)2 paths (if its size is k), and this is the only formula we need to calculate the number of paths where g(x,y) is divisible by i (let this be h(i)).

How can we get the answer if we know the values of h(i)? We can use inclusion-exclusion with Mobius function, for example, to prove that ans(1)=∑i=12⋅105μ(i)h(i); and then if we want to apply the same technique for finding ans(x) with any possible x, we could divide all numbers ai by x and do the same thing. But it might be too slow, so it's better to rewrite this formula as ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi), because we will do exactly the same when dividing all numbers by x.

In fact, most contestants have written a much easier version of this solution, so this might be a bit too complicated.

This problem can also be solved with centroid decomposition.

Educational Codeforces Round 44 Editorial

By awoo, history, 5 years ago, translation, In English985A - Chess Placing

Tutorial985A - Chess PlacingFirstly let's sort our array p (pay the attention that there are  elements in this array, not n). Then for 0-indexed array p answer will be equal to , where |a - b| is an absolute value of difference between a and b.

Solution (Vovuh)985B - Switches and Lamps

Tutorial985B - Switches and LampsLet's maintain an array cnt of size m, where cnti will be equal to the number of switches that are connected to the i-th lamp. Then answer will be "YES" if and only if there exists some switch such that for each lamp i that is connected to this switch cnti > 1. Otherwise the answer will be "NO".

Solution (Vovuh)985C - Liebig's Barrels

Tutorial985C - Liebig's BarrelsAt first, sort all ai in non-decreasing order.

Let rg be first position that arg > a1 + l (if am ≤ a1 + l, rg = m + 1). Then each barrel should have at least one stave from segment [1, rg). So if rg - 1 < n answer is 0.

Otherwise, for each i from 1 to n let's take no more than k smallest staves from this segment in the i-th barrel, but in such way, that there are at least n - i staves left for next barrels.

Solution (adedalic)985D - Sand Fortress

Tutorial985D - Sand FortressLet's consider the optimal answer to always look like h1 ≤ h2 ≤ ... ≤ hk ≥ hk + 1 ≥ ...

k will be the leftmost position of a pillar with maximum height. We will heavily use the fact that all integers from 1 to hk - 1 appear in this sequence to the right of k.

If you are able to construct any answer, it is easy to rearrange it to this pattern: select the leftmost maximum k, sort [1..k - 1] in non-decreasing order and [k + 1..∞) in non-increasing order. Sorted sequence will also be valid.

Let a pyramid of height k be such a valid castle that it occupies exactly 2k - 1 consecutive spots and 1 = h1 < h2 < ... < hk > hk + 1 > ... > h2k - 1 = 1. Exactly k2 sand packs are required to build it.

At first let's solve the problem without even touching the fence. This won't always give the minimal answer but it'll help us further. Given some k you can build the pyramid of height k and get n - k2 sand packs left over. This can fit in exactly  pillars (you can place any pillar of height  ≤ k next to some pillar of the same height). That way we see that .

This function is non-increasing, let's show that for any k from 2 to  ans(k) - ans(k - 1) is non-positive.

ans(k) - ans(k - 1) =  =  =  =  =  = .

  (n + k)(k - 1) ≤ nk + k(k - 1) - 1  nk - n + k2 - k ≤ nk + k2 - k - 1  n ≥ 1.

Now we can show that it is always optimal to push the initial pyramid to the left as far as possible, probably removing some pillars on positions less than k. That way the leftmost pillar will have height h1 = min(k, H). The total number of sand packs required to build it is . This pattern will also include all the integers from 1 to k and will have the minimal width you can achieve. Monotonicity of this function can be proven in the similar manner.

Finally, the answer can be calculated using the following algorithm:

Find the maximum k such that , where h1 = min(k, H). Solve the equation or just do the binary search;Output the width of resulting truncated pyramid plus the minimal number of additional pillars it will take to distribute leftover sand packs.You should also take into consideration the upper bound on k to avoid multiplying huge numbers. It's about , so 64-bit integer type will be enough for all the calculations.

Overall complexity: O(1) or .

Solution (PikMike)985E - Pencils and Boxes

Tutorial985E - Pencils and BoxesAt first you need to sort the sequence. Then if there exists some answer, there also exists an answer such that every box in it contains some segment of pencils.

Now it's pretty standard dp approach. Let dpi be 1 if it's possible to distribute the first i pencils into boxes correctly, 0 otherwise, dp0 = 1 initially. Now you can come up with straightforward O(n2) implementation. Let's iterate over every  and set dpi + 1 to 1 if for some j dpj = 1, i - j + 1 ≥ k and ai - aj ≤ d.

Now we should optimize it a bit. Notice that the second and the third conditions actually form some segment of indices. You need to check if there is at least one 1 value on this segment. This can be maintained with two pointers, set, BIT, segment tree. Anything you can code to get update in point and sum/max on segment queries.

Overall complexity: .

Solution (PikMike)985F - Isomorphic Strings

Tutorial985F - Isomorphic StringsYes, authors also implemented hashes.

Note that if substrings s and t are isomophic, then position pos of first encounter of some character si in s must be position of first encounter of some character tj in t. More over, if we sort all positions posis for all distict characters in s and sort all positions posjt for t, then posis must be equal posit for any i. This observation gives us fact, that f(s[posis]) = t[posit].

So, to check isomorphism of s and t we need check for each i, that positions of all encounters of character s[posis] equal to posistions of all encounters of character t[posit].

To do that we can generate for each character boolean array with checked positions of its encounter and calculate prefix hashes on this arrays. Also we need precalculate order of first encounters ordk for each suffix of string s. To do it fast note that in transition from ordk + 1 to ordk only sk can change its relative order.

Result complexity is O(n·A) with quite big constant from hashing.

Solution (adedalic)985G - Team Players

Tutorial985G - Team PlayersLet's solve this task in several steps.

At first, let's calculate all — sum of all triples. For each player i consider three cases:

j<k<i — there are exactly (i2) ways to choose triple;j<i<k — there are i⋅(n−i−1) ways;i<j<k — there are (n−i−12) ways.At second, let's calculate sub1 — sum over all triples j<k<i such that exists pair (j,i) or (k,i). To calculate it we need for each i iterate over all neighbors x<i of i. Again some cases:

if x=j<k<i then there are exactly (i−j−1) ways to choose k;if j<x=k<i, there are x ways to choose j.But we calculated some triples twice, so we need to subtract triples j<k<i where both (j,i) and (k,i) exists. It is easy to calculate sorting adjacency lists of all i.At third, let's calculate sub2 — sum over all triple j<k<i where exists pair (j,k), but pairs (j,i) and (k,i) are not. sub2=sub02−sub12−sub22+sub122.

sub02 is a sum of all triples j<k<i where pair (j,k) exists. It can be calculated while iterating i in increasing order.sub12 is a sum of all triples j<k<i where pairs (j,k) and (j,i) exists. It can be calculated while iterating (j,i) and asking sum on segment of adjacency list of j (O(1) with prefix sums for each vertex j).sub22 is a sum of all triples j<k<i where pairs (j,k) and (k,i) exists. It can be calculated while iterating (k,i) and asking sum on prefix of adjacency list of k (same O(1)).sub122 is a sum of all triples j<k<i where all pairs (j,k), (j,i) and (k,i) exists. It is modification of calculating number of triangles in graph. It can be done in O(MM−−√) and will be explained below.Then result res=all−sub1−sub2.

The algorithm of finding all triangles in the given graph G is following:

Let's call vertex heavy if |G(v)|≥M−−√ and light otherwise. For each heavy vertex v precalculate hasv[i] — boolean array of adjacency of vertex v. It's cost O(NM−−√) of memory and time but memory can be reduced by using bitsets.

To calculate number of triangles j<k<i let's iterate over i. There are two cases:

if i is heavy, then just iterate over all edges (j,k) and check hasi[j] and hasi[k]. This part works with O(MM−−√) time since there are O(M−−√) heavy vertices.if i is light, then iterate over all pair (j,k), where j,k∈G(i) (at first fix k, then iterate j<k). To check existence of edge (j,k) consider two more cases:if k is heavy, just check hask[j]. It works in O(1).if k is light, just check in some global array curHas all neighbors of k, check all j with curHas[j] and uncheck neighbors of k. Checking in array curHas require O(|G(k)|) time and will be done O(|G(k)|) times. So it will be O(∑|G(v)|2)=O(M−−√∑|G(v)|)=O(MM−−√) in total.Similarly, iterating pairs j,k∈G(i) works with O(∑|G(i)|2)=O(MM−−√) in total.So comlexity of algorithm and all task is O(MM−−√).

Educational Codeforces Round 43 Editorial

By vovuh, history, 5 years ago, translation, In English976A - Minimum Binary Number

Editorial976A - Minimum Binary NumberIf n = 1 then the answer is equal to s. Otherwise answer will be equal to 2cnt0, where cnt0 is the count of the zeroes in the given string (i.e. the answer is the binary string of length cnt0 + 1, in which the first character is one and the other characters are zeroes).

Solution (Vovuh)976B - Lara Croft and the New Game

Editorial976B - Lara Croft and the New GameNaive solution would be just simulate the tranversal and break when k steps are made. Obviously, this won't fit into time limit. Then we can decompose the path to some parts which can be calculated separately.

Walk from the top left to the bottom left corner;Walk from second column to m-th on even rows;Walk from m-th column to second on odd rows.If k < n then it's the first part. Otherwise you can use the fact that rows are of the same length. (k - n)div(m - 1) will tell you the row and (k - n)mod(m - 1) will get you the number of steps Lara have made along this row.

Overall complexity: O(1).

Solution (PikMike)976C - Nested Segments

Editorial976C - Nested SegmentsLet's sort segments firstly by their left border in increasing order and in case of equal by their right border in decreasing order. If there is any valid pair then the inner segment will always go after the outer one.

Now you can go from left to right, keep the maximum right border of processed segments and compare it to the current segment.

Overall complexity: .

Solution (PikMike)976D - Degree Set

Editorial976D - Degree SetWe prove that the answer always always exists by constructing it.

Graph for n = 0 is a single vertex;Graph for n = 1 is a clique of d1 + 1 vertices;Graph for some (d1, d2, ..., dk) is obtained from the graph (d2 - d1, d3 - d1, ..., dk - 1 - d1) by adding (dk - dk - 1) vertices initially connected to nothing and d1 vertices connected to all previously mentioned ones.The vertices connected to nothing got degrees d1, the vertices from the previous step increased their degrees by d1 and finally there appeared vertices of degree dk. The number is vertices is dk + 1 as needed.

Solution (PikMike)976E - Well played!

Editorial976E - Well played!At first let's prove that in optimal solution all spells of 1-st type are assigned to single creature. By contradiction: let's optimal answer contains indices i ≠ j where hp'i = hpi·2x and hp'j = hpj·2y. If hp'i(j) ≤ dmgi(j) using spells of 1-st type is meaningless. Otherwise, if (in general case) hp'i ≥ hp'j then hpi·2x + 1 + hpj·2y - 1 > hp'i + hp'j. Contradiction.

So, we can check for each creature maximal damage with its health multiplied.

At second, if we sort all creatures in order by decreasing (hpi - dmgi), using b spells on first b creatures gives best answer ans. So, calculating answer for chosen creature invokes 2 cases:

if chosen creature is belong to first b creatures, then subtract from ans its contribution, calculate new value and add it to ans;otherwise, we need one spell of second type, which is optimal to take from b-th creature, so along with replacing old value of chosen one we need to replace in ans contribution of b-th creature.Result complexity is O(n·log(n))

Solution (Ajosteen)976F - Minimal k-covering

Editorial976F - Minimal k-coveringTo get the answer for some k we can build the following network: connect the source to every vertex of the first part with edge with capacity degx  -  k (where degx is the degree of vertex), then transform every edge of the original graph into a directed edge with capacity 1, and then connect each vertex from the second part to the sink with capacity degx  -  k. Then edges saturated by the maxflow are not present in the answer (and all other edges are in the answer).

To solve it fastly, we might just iterate on k from its greatest value to 0 and each time augment the flow we found on previous iteration. Since maxflow in the network is at most m, and we will do not more than m searches that don't augment the flow, this solution is O((n + m)2).

Educational Codeforces Round 42 Editorial

By fcspartakm, history, 5 years ago, translation, In English962A - EquatorTo solve the problem we need to know the total number of problems which Polycarp planned to solve. We count it in one iteration through the given array and save the total number of problems in the variable sum.

After that, we will again iterate through the array and count the number of problems that Polycarp will solve on the first i days. Let this sum is equal to l. We need to find the smallest i for which it is true that l⋅2≥sum. This day will be the answer.

962B - Students in Railway CarriageWe will iterate from the left to the right through the given string and take the maximal substrings consisting from the dots only (bounded by asterisks/string bounds). Let the length of the current such substring is len.

If len is even, in the places corresponding to this substring, you can put maximum len/2 students of each type, simply alternating them. Considering remaining a and b, you can put min(a,len/2) student-programmers and min(b,len/2) student-athletes in these places.

If len is odd, then in the places corresponding to this substring, you can put (len+1)/2 students of the one type and len/2 students of the other type. If a>b, then you need to start put students from a student-programmer. So,  min(a,(len+1)/2) of student-programmers and  min(b,len/2) of student-athletes can be put in this substring. Otherwise, you need to put students in the same way, but starting from a student-athlete.

Also, you need to remember to maintain the number of remaining students a and b after processing the current substring and move on to the next substring consisting of the dots only.

962C - Make a SquareConsider the given integer as a string s. Use the masks to brute all possible ways to delete digits. Let the remaining integer for the current mask is a string t. If the first character of t is zero, skip this mask. Otherwise, we revert the string t into the integer cur.

Now we need to check does the cur is a square of some integer. It can be done in many ways, for example, by adding all the integer squares less than 2⋅109 into the set (its size will be approximately equal to the square root of 2⋅109) and check that cur is in this set. If this is the case, we should update the answer with the difference between the string s and the string t, because this difference is equal to the number of deleted digits for the current mask.

962D - Merge EqualsTo solve this problem we should use a set of pairs, let's call it b. We will store in it all the elements of the current array (the first number in the pair)and the positions of these elements in the current array (the second number in the pair). The first elements of pairs should have type long long, because the result of merging the array elements can become large and the type int will overflow.

Initially, you need to put in b all elements of the given array with their positions.

While there are elements in b, we will perform the following algorithm. Let x be a pair in the beginning of b. Then look at the next element of b. If it does not exist, the algorithm is complete. Otherwise, let the next element is equal to y.

If x.first≠y.first, then there is no pair number for the element x.first, which is in the position x.second, and it will never appear, because all elements can only increase. So, remove x from b and repeat the algorithm from the beginning.

Otherwise, the number at the position x.second will be deleted, and the number in the position y.second will be double up. So, remove x and y from b, put (y.first⋅2,y.second) in b and repeat the algorithm from the beginning. For the convenience of restoring the answer, you can mark deleted positions of the given array in an additional array, so, in this case you need to mark x.second as a deleted position.

962E - Byteland, Berland and Disputed CitiesWe will call the disputed cities — purple points, the cities of Byteland — blue points, and the cities of Berland — red points.

If there are no any purple points among the given points, you just need to connect all the neighboring red points between each other and all the neighboring blue points with each other. Thus, the answer is the sum of the distances between the leftmost red point and the rightmost red point and between the leftmost blue point and the rightmost red point.

Otherwise, you firstly should connect all the neighboring purple points with each other. Consider what you should do to connect the red points. All the red points to the left of the leftmost purple point should be connected as follows: first from the left with the second from the left, second from the left with the third from the left and so on. The rightmost of these red points should be connected to the leftmost purple point. All the red points to the right of the rightmost purple point are connected in a similar way.

Consider all the gaps between the neighboring purple points, and all the red and blue points between them. They should be connected in one of two ways.

The first way is to connect the left purple with the leftmost red, the rightmost red with the right purple, and also connect all the neighboring red dots. Similarly we should make for the blue points. Let the total length of the edges for such a connection is equal to len1.

The second way is to connect the left and right purple point. Now consider only the purple points and the red ones. All adjacent points need to be connected to each other, except those which are on the maximum distance from all other pairs. If there are several, then we do not connect any pair. Similarly we make for the purple and blue points. Let the total length of the edges for such a connection is equal to len2.

If len1>len2 we should connect points from the current gap in the second way, otherwise, in the first.

962F - Simple Cycles EdgesTo solve this problem, it is good to know about fundamental set of cycles.

Briefly, in the graph it is easy to select such a minimal set of cycles C that any other cycle can be obtained as XOR of some subset of cycles from C. This set is also called the fundamental set of cycles. To find it in a connected graph, you can find any carcass and, alternately, independently add to this carcass each of the edges that are not entered into it. When each such edge is added to the carcass, its cycle closes. The set of these cycles is a fundamental set of cycles. Thus, if the graph is connected, then the size of the fundamental set of cycles is exactly m−n+1.

It is easy to see that if an edge belongs to exactly one cycle from the fundamental set of cycles, then it belongs to exactly one simple cycle.

We solve the problem independently for each connected component. For a connected component, it finds its carcass by a search in depth, and each edge that does not enter the search tree into the depth will close a cycle. We only take into account those cycles that do not intersect along the edges. We should print only them in the form of a set of edges.

If the carcass was built with a search in depth, then each cycle represents a path from the vertex to the child (plus the reverse edge). Thus, the problem now is: a set of pairs of vertices (a vertex and its descendant) that specify a set of paths from top to bottom is given in the tree. It is required to select those paths that do not intersect with any other paths from this set.

To find such ways quickly it is possible with help of DSU (system of non-intersecting subsets) on paths. On the edge, you should store the -1 mark or the path number to which it belongs. When passing the edges without marking, it should be marked by this path. When passing an edge with a mark, it is necessary to merge two paths into the DSU, because they intersect. After processing the path, for all the vertices of the path, the ancestor should be reassign to the top vertex of the path. Because if we do not make this we will repeatedly go through the same path.

Using the following code, we find for each vertex its depth in the depth search tree and all the back edges (an array be):

void dfs(int u, int pu, int d) {    dep[u] = d;    color[u] = 1;    p[u] = pu;    for (int v: g[u]) {        if (v == pu)            continue;        if (p[v] == -1)            dfs(v, u, d + 1);        else if (color[v] == 1)            be.push_back({u, v});    }    color[u] = 2;}Using the following code, we process all paths (actually cycles), merging the intersecting ones.

pp = p;k = be.size();for (int i = 0; i < k; i++) {    int x = be[i].first;    vector<int> path;    while (dep[x] > dep[be[i].second]) {        path.push_back(x);        if (index[x] == -1)            index[x] = i;        else            unite(i, index[x]); // DSU        x = p[x];    }    for (auto j: path)        p[j] = be[i].second;}Let pp — it is an original array of ancestors in depth search tree (because array p has been changed by the code above). Now, it is sufficient to the answer to take such paths plus the corresponding reverse edge that do not intersect with others (that is, the size of the DSU component is 1):

vector<int> sizes(k);for (int i =  0; i < k; i++)    sizes[leader(i)]++;

set<int> result;for (int i = 0; i < be.size(); i++)    if (sizes[i] == 1) {        result.insert(e[{be[i]}]);        int x = be[i].first;        while (x != be[i].second) {            result.insert(e[{x, pp[x]}]);            x = pp[x];        }    }This problem has another solution, based on the allocation of the doubly connected components with the help of the corresponding linear algorithm.

962G - Visible Black AreasFirst, lets build a graph that represents only part of the polygon that is inside the window, as well as borders of the window. Do do this, for each segment of the polygon, find the intersection of that segment with the window, and, if it still is a segment with non-zero length, add it to the graph (add both endpoints as vertices and the segment itself as an edge). Next, add four corners of the window as vertices. Last, connect all the points on each of the four borders of the window with edges.

This way, we have a planar graph, and we can find faces in this graph which will represent all the connected areas inside the window, both belonging to the polygon and not. To count only those that belong to the polygon one can mark those oriented edges, that were created while intersecting polygon's segments with the window, as important. Only mark an edge if it is directed the same way as the corresponding segment of the polygon. This way, those faces of the graph that are to the left of important edges, are the ones belonging to the polygon.

But there is one bad case — when no segment of the polygon intersects with the window. It such case, the window is either entirely outside of the polygon, or entirely inside of it. To check this, find number of intersections of the polygon with a ray starting from inside of the window. If the number of intersections is even, the window is outside of the polygon. If it is odd, the window is outside.

Educational Codeforces Round 41 Editorial

By vovuh, history, 5 years ago, In English961A - Tetris

Editorial961A - TetrisThe answer will be equal to mini=1ncnti, where cnti is the number of squares that will appear in the i-th column.

Solution (Vovuh)961B - Lecture Sleep

Editorial961B - Lecture SleepLet's iterate over all i from 1 to n and if ti is equal to 1 then add ai to the some variable res and replace ai with 0. Then answer will be equal to , where  can be easily calculated with prefix sums for each i.

Solution (Vovuh)961C - Chessboard

Editorial961C - ChessboardSince n is odd, exactly 2 pieces of the board will have upper left corner colored black (and exactly 2 — white). Let's check every option to choose two pieces of the board so their upper left corners will be painted white when we assemble the board, calculate the number of board cells that have to be recolored, and find the minimum of this value among all possible choices.

Solution (Ajosteen)961D - Pair Of Lines

Editorial961D - Pair Of LinesIf the number of points is less than 3, then the answer is obviously YES. Else let's fix first 3 points. Check if there is a solution if 1-st and 2-nd points lie on the same line. Just erase all points which lie on this line and check the remaining points if they belong to one line. If we didn't find the answer, let's check points 1 and 3 in the same way. If its failed again then line which contains point 1 can't contain points 2 and 3, so points 2 and 3 must lie on one line. If we didn't succeed again, then there is no way to do it, so the answer is NO.

Checking that points a, b and c belong to the same line can be done by calculating 2d version of cross product (b - a) × (c - a). It equals to 0 if vectors (b - a) and (c - a) are collinear.

Solution (adedalic)961E - Tufurama

Editorial961E - TufuramaAt first, it doesn't matter if some season has more than n episodes, so we can set ai = min(ai, n).

Let's maintain next invariant: when we proceed i-th season we will have only seasons containing the episodes with indices  ≥ i. Then the number of pairs (i, y) is just number of seasons with index  ≤ ai. One of the ways to maintain this invariant is the following: for each number of episodes ai store a list with indices of seasons with exactly ai episodes. Then after proceeding of i-th season just erase all seasons with exactly i episodes.

Maintaining seasons and counting them can be done by BIT with zeros and ones.

Finally, notice, that we counted each pair (x < y) twice, and also counted the pairs (x, x), so we must subtract the number of pairs (x, x) (where ax ≥ x) and divide the result by two.

Solution (Ajosteen)961F - k-substrings

Editorial961F - k-substringsLet's look at suprefix of fixed k-substring: we can't find its maximal length via binary search because this function isn't monotone in general case. But, by fixing not the left border but the center of the prefix, we also fix the center of the corresponding suffix (center of a prefix in position i is tied with the center of the suffix in position n + 1 - i), and, more important, function becomes monotone.

So solution is next: iterate over all valid centers of prefix i and try to binary search maximal length 2x + 1 of such substring that its center is in position i, and it's equal to the substing with center in n + 1 - i. ansi - x then can be updated with value 2x + 1. And don't forget to update each ansi with value ansi - 1 - 2.

Easy way to check substrings for equality is to use hashes. Harder way is to use string suffix structures (like bundle of Suffix Array + LCP + Sparse Table or Suffix Tree + LCA).

Note for SuffArray users: don't forget about changing sort to stable_sort (merge sort) and breaking if all suffixes are different. This optimizations can save you from writing radix (or bucket) sort.

Alternative solution (jtnydv25)Solution (adedalic, suffix array)Solution (adedalic, hashes)961G - Partitions

Editorial961G - PartitionsLet's look at some facts. At first, the answer is the sum of weights wi taken with some coefficients cfi. So, it's enough to calculate those coefficients.

Then cfi can be calculated by iterating on the size of the subset containing i-th element: , where f(n, k, size) is the number of partitions of set with n elements into k nonempty subsets with one subset of fixed size size where i belongs.

This solution is still quite slow, so the next fact is: if two elements i and j belong to the same subset, then j "increases" the coefficient before wi. So for each element i we can iterate over all elements j which will lie in one subset with i. In other words, . g(n, k, i, j) is the number of ways to divide set with n elements into k subsets in such a way that elements i and j wil lie in one subset.

g(n, k, i, j) can be calculated using Stirling numbers of the second kind: let  be the number of partitions of set with n elements into k non-empty subsets. If i = j then , else we just merge i and j into one element and let .

Final formula is . And the answer is .

Counting Stirling numbers can be done with inclusion-exclusion principle or by searching Wiki: .

Resulting complexity is O(nlog(n)).

Educational Codeforces Round 40 Editorial

By awoo, history, 5 years ago, translation, In English954A - Diagonal WalkingLet's iterate over all characters of the string from left to right (excluding last character). Suppose i is a position of the current element of the string. If si ≠ si + 1, increase answer by 1 and increase i by 2, else just increase i by 1.

954B - String TypingLet's consider s[i; j) as a substring of string s from position i to position j (j is not included). Let's iterate over all lenghts of the copied prefix from  to 0 inclusive, and then if s[0; len) = s[len; 2·len) then answer will be min(n, n - len + 1) and iterating over smaller lenghts is not necessary.

954C - Matrix WalkYou can notice that moves of kind (i - 1, j) and (i + 1, j) are changing value x to x - m and x + m. Thus, you can determine m by checking adjacent nodes in the path. The answer is YES if there are one or zero distinct values of differences not counting difference of 1.

You can also set n to arbitrary big value, it doesn't really matter until you can fit all values. 109 will work just fine.

Finally, knowing n and m, simulate the process and check that all moves are valid.

Overall complexity: O(n).

954D - Fight Against TrafficLet's use bfs to calculate the smallest distances to all vertices from the vertex s and from the vertex t. These will be ds[i] and dt[i] for all i.

ds[t] = dt[s] = D is the the current smallest distance between s and t. What you need is to iterate over all pairs (u, v) and check if the edge between them doesn't exist and neither (ds[u] + dt[v] + 1) nor (ds[v] + dt[u] + 1) is smaller than D.

Overall complexity: O(n2).

954E - Water TapsThe following greedy strategy work. Let's turn all the taps at full power. If total temperature is greater than T then we would like to decrease power on some taps with higher temperature. We want to decrease as low power as possible, so we should prioritize taps with the highest temperature. Sort all taps by temperature and find the total power on suffix you should decrease to have equal temperatures. This can be done with binary search. The same works for smaller initial temperature.

Overall complexity: .

954F - Runner's ProblemThere is a simple dynamic programming solution that works in O(m). Let's try to improve it.

Firstly, if there are no obstacles in some column i and we have calculated the number of paths to every cell of the previous column, then we may get the values in column i by multiplying the vector of values in column i - 1 by the following matrix:



Then we may use binary exponentiation to skip long segments without obstacles in O(logk), where k is the length of the segment.

Let's try to modify this matrix if we have to forbid some rows. All we need to change is to set every value in i-th row to 0 if i-th row is forbidden. So we may skip long segments not only if they don't contain any obstacles, but also if the set of forbidden rows doesn't change on this segment.

So the solution is the following: divide the whole matrix into 2n + 1 segments by the endpoints of the obstacles, then in every segment the set of forbidden rows doesn't change (so we can skip it using fast matrix exponentiation).

954G - Castle DefenseFirstly, if we may obtain reliability at least x, then we may obtain reliability not less than x - 1 with the same number of archers. So we may use binary search and check whether we may obtain reliability at least x.

How can we check it? Let's find the leftmost section such that its defense level is less than x. Let its index be i. We obviously have to add some archers controlling this section, and since every section to the left of it is already controlled, the best option where to add archers is the section with index min(i + r, n). After we added enough archers, we move to next section such that its defense level is less than x and do the same. If we run out of archers without protecting all the sections, then it's impossible to obtain reliability x.

To do checking in O(n), we may use prefix sums or "sliding window" technique.

954H - Path CountingAt first when we read the problem, a simple solution comes to our mind, take a look at the LCA (Lowest Common Ancestor) of that starting and ending vertices of the path and then use combinatorics to calculate the number of the paths, but after trying to implement this or solve this on paper it doesn't seem to be easy at all and it may even be impossible to implement this. So lets try to solve this problem in a different way.

For calculating the answer, we count the number of times each path starts or ends at every vertex, and then divide them by 2 to get the answer for each vertex.

For calculating the answer to the above, it is easy to see that all vertices with the same height have the same number of paths going through them, so if we calculate the number of paths going through one of them and then multiply it by the number of the vertices in that height (let it be ch) it gets equal to our answer.

We can calculate the answer for a certain height. So to do that, we divide the paths into two types, paths that go only into the subtree of a vertex (let's call it dh), and paths that go up (let's call it uh).

For the ones that are in the subtree, it is easy to see if there are at least k other vertices that go down, we can go all paths going down (let the number of them be ph, k), and the answer for this part, equals to:

For the ones that go up, we use dynamic-programming, and we define dph, k the number of paths that start at a vertex with height h and have length k and do not use the leftmost edge exiting the vertex at height h. To update this either we go down on one of the ah - 1 paths and then we go through a path of length k - 1, or we go up and get a path of length k - 1 starting at a vertex from height h - 1, so the answer for this one equals to:

Now .

And the final complexity of the solution will be O(n2), but because of the large constant of the solution the time limit is higher.

954I - Yet Another String Matching ProblemUnfortunately, it seems we failed to eliminate bitset solutions.

The approach in our model solution is the following:

Firstly, let's try to find some "naive" solution for calculating the distance between two strings. We may build an undirected graph where vertices represent letters, and edges represent that one letter must be transformed into another. Then all letters in the same component should become one letter, so the answer is the number of distinct letters minus the number of components.

Then let's get back to original problem. For every substring of S we have to find which letters have to be merged to make it equal with T. This can be done with the help of FFT: to find all positions in substrings of S with character a that coincide with occurences of b in T, we may compute a convolution of two following arrays: set 1 to every position in S where occurs a, and to every position in T where b occurs (all other elements should be 0). After trying these convolutions for every pair of different characters, we compute the answer for every substring using DFS (or any other method).

Educational Codeforces Round 39 Editorial

By awoo, history, 5 years ago, translation, In English946A - PartitionThe answer for this problem can be calculated by the next simple formula: , where |ai| is the absolute value of ai.

946B - Weird Subtraction ProcessThe answer can be calculated very easy by Euclid algorithm (which is described in the problem statement), but all subtractions will be replaced by taking by modulo.

946C - String TransformationThe problem can be solved by the next greedy algorithm. At first we need to store the last character of the alphabet we haven't obtained, for example, in variable c (initially it will be equal to 'a'). Then we will just iterate over all characters of the string from left to right and if the current character of the string is not greater than c, we just replace it to c and increase c by 1. If in any moment c will be greater than 'z', we got the answer. And if after iterating over the string c will be not greater than 'z', the answer is «-1».

946D - TimetableThe problem can be solved in the following dynamic programming manner. Let dp[i][j] be the smallest number of hours Ivan can spend in university in the first i days while having j lessons skipped. To calculate it we can store mn[i][j] — minimal number of hours Ivan is required to spend in the i-th day so that he attends j lessons.

Then we can iterate over all lengths from 0 to k and update dp[i + 1][j + lengthcur] with dp[i][j] + mn[i][lengthcur].

Precalc works in O(nm2) and dp can be processed in O(nk2).

946E - Largest Beautiful NumberThis is pretty typical problem on greedy construction: you are asked to build lexicographically maximal string. In the majority of cases it's done like this.

Imagine you've built some prefix of length i with all numbers equal to the prefix of length i of the original string. You are also sure there exists some suffix for it that will give proper beautiful number.

Now you have two options: you either put si if possible and proceed to the same task of longer prefix or you put the smaller number and fill the entire suffix with the maximum possible beautiful number you can obtain.

Now you should learn how to check if any valid suffix exists. It means at least the smallest possible beautiful number with current prefix is smaller than s.

It's built like this. Let cnt be the number of digits which currently have odd number of occurences. You put all zeroes but the last cnt digits and then output these odd occurence number digits in increasing order. The first part can be checked with partial sums on the number of zeroes on segment in the original string and the second part has its length not greater than 10 and can be checked naively.

Overall complexity: O(|s|).

946F - Fibonacci String SubsequencesIf F(x) was not really large, then we could run the following dynamic programming solution:

Let dp[i][j] be the number of ways to process first i characters of F(x) so that the suffix of the subsequence of length j matches the prefix of s with length j. This is not really different from a usual approach with dynamic programming on KMP (constraints in this problem allow us to build KMP automaton naively without the help of any fast prefix-function algorithm). However, the length of F(x) is really large.

Let's consider the traversions we make in dynamic programming. Let A be the KMP automaton matrix (that is, let A[p][c] be the new value of prefix-function if the previous value was p and we added a character c). Then from the state dp[i][j], if the following character is 0, we make traversions to dp[i + 1][j] and to dp[i][A[p][0]]. This actually leads to rewriting traversions as a matrix. Let di be the vector such that its j-th element is equal to dp[i][j]. Then advancing from di to di + 1, if i-th character is 0, can be represented as follows: di + 1 = di × M0, where M0 can be filled with the help of KMP automaton: for every  we add 1 to M0[k][k], and also add 1 to M0[k][A[k][0]]. The same approach can be used to form matrix M1 that denotes adding character 1, and if we want to add the string F(x), we can actually represent its matrix as Mx = Mx - 1 × Mx - 2.

This matrix multiplication approach will run in O(xn3), but the problem is that it doesn't give us the answer. To obtain it, we may add an auxiliary state n + 1 to the dynamic programming, add 1 to it each time we traverse to state n, multiply it by 2 each time we add a character, and rewrite it into matrix form.

Model solution: https://pastebin.com/ctSVxmnD

946G - Almost Increasing ArrayIf the problem was to make the array strictly increasing, then we could use the following approach: for every element subtract its index from it, find the longest non-decreasing subsequence, and change every element not belonging to this sequence. In this problem we can use a similar technique.

Let's iterate on the element we will remove after changing everything we need (let's call it k). For every i < k we will subtract i from ai, and for every i > k we will subtract i - 1 from ai. Let's maintain the longest non-decreasing subsequence ending in every element on prefix, and the longest non-decreasing subsequence starting in every element on suffix (this can be done by a lot of different techniques, for example, two segment trees and rollbacking, which is used in our model solution). Then we need to somehow merge these sequences. The easiest way to do it is to consider only the subsequence ending in element k - 1 (since if we will need to consider the subsequence ending in some index less than k - 1, we would check this possibility choosing other value of k) and use some data structure (BIT, segment tree or something similar) to find the longest subsequence that can be appended to the one we fixed. After checking if we need to delete element k, we add it to the data structure on prefix, remove element k + 1 from the data structure on suffix, check if we have to remove element k + 1 and so on.

Model solution: https://pastebin.com/BiaFgYx6

Educational Codeforces Round 39 Editorial

By awoo, history, 5 years ago, translation, In English946A - PartitionThe answer for this problem can be calculated by the next simple formula: , where |ai| is the absolute value of ai.

946B - Weird Subtraction ProcessThe answer can be calculated very easy by Euclid algorithm (which is described in the problem statement), but all subtractions will be replaced by taking by modulo.

946C - String TransformationThe problem can be solved by the next greedy algorithm. At first we need to store the last character of the alphabet we haven't obtained, for example, in variable c (initially it will be equal to 'a'). Then we will just iterate over all characters of the string from left to right and if the current character of the string is not greater than c, we just replace it to c and increase c by 1. If in any moment c will be greater than 'z', we got the answer. And if after iterating over the string c will be not greater than 'z', the answer is «-1».

946D - TimetableThe problem can be solved in the following dynamic programming manner. Let dp[i][j] be the smallest number of hours Ivan can spend in university in the first i days while having j lessons skipped. To calculate it we can store mn[i][j] — minimal number of hours Ivan is required to spend in the i-th day so that he attends j lessons.

Then we can iterate over all lengths from 0 to k and update dp[i + 1][j + lengthcur] with dp[i][j] + mn[i][lengthcur].

Precalc works in O(nm2) and dp can be processed in O(nk2).

946E - Largest Beautiful NumberThis is pretty typical problem on greedy construction: you are asked to build lexicographically maximal string. In the majority of cases it's done like this.

Imagine you've built some prefix of length i with all numbers equal to the prefix of length i of the original string. You are also sure there exists some suffix for it that will give proper beautiful number.

Now you have two options: you either put si if possible and proceed to the same task of longer prefix or you put the smaller number and fill the entire suffix with the maximum possible beautiful number you can obtain.

Now you should learn how to check if any valid suffix exists. It means at least the smallest possible beautiful number with current prefix is smaller than s.

It's built like this. Let cnt be the number of digits which currently have odd number of occurences. You put all zeroes but the last cnt digits and then output these odd occurence number digits in increasing order. The first part can be checked with partial sums on the number of zeroes on segment in the original string and the second part has its length not greater than 10 and can be checked naively.

Overall complexity: O(|s|).

946F - Fibonacci String SubsequencesIf F(x) was not really large, then we could run the following dynamic programming solution:

Let dp[i][j] be the number of ways to process first i characters of F(x) so that the suffix of the subsequence of length j matches the prefix of s with length j. This is not really different from a usual approach with dynamic programming on KMP (constraints in this problem allow us to build KMP automaton naively without the help of any fast prefix-function algorithm). However, the length of F(x) is really large.

Let's consider the traversions we make in dynamic programming. Let A be the KMP automaton matrix (that is, let A[p][c] be the new value of prefix-function if the previous value was p and we added a character c). Then from the state dp[i][j], if the following character is 0, we make traversions to dp[i + 1][j] and to dp[i][A[p][0]]. This actually leads to rewriting traversions as a matrix. Let di be the vector such that its j-th element is equal to dp[i][j]. Then advancing from di to di + 1, if i-th character is 0, can be represented as follows: di + 1 = di × M0, where M0 can be filled with the help of KMP automaton: for every  we add 1 to M0[k][k], and also add 1 to M0[k][A[k][0]]. The same approach can be used to form matrix M1 that denotes adding character 1, and if we want to add the string F(x), we can actually represent its matrix as Mx = Mx - 1 × Mx - 2.

This matrix multiplication approach will run in O(xn3), but the problem is that it doesn't give us the answer. To obtain it, we may add an auxiliary state n + 1 to the dynamic programming, add 1 to it each time we traverse to state n, multiply it by 2 each time we add a character, and rewrite it into matrix form.

Model solution: https://pastebin.com/ctSVxmnD

946G - Almost Increasing ArrayIf the problem was to make the array strictly increasing, then we could use the following approach: for every element subtract its index from it, find the longest non-decreasing subsequence, and change every element not belonging to this sequence. In this problem we can use a similar technique.

Let's iterate on the element we will remove after changing everything we need (let's call it k). For every i < k we will subtract i from ai, and for every i > k we will subtract i - 1 from ai. Let's maintain the longest non-decreasing subsequence ending in every element on prefix, and the longest non-decreasing subsequence starting in every element on suffix (this can be done by a lot of different techniques, for example, two segment trees and rollbacking, which is used in our model solution). Then we need to somehow merge these sequences. The easiest way to do it is to consider only the subsequence ending in element k - 1 (since if we will need to consider the subsequence ending in some index less than k - 1, we would check this possibility choosing other value of k) and use some data structure (BIT, segment tree or something similar) to find the longest subsequence that can be appended to the one we fixed. After checking if we need to delete element k, we add it to the data structure on prefix, remove element k + 1 from the data structure on suffix, check if we have to remove element k + 1 and so on.

Model solution: https://pastebin.com/BiaFgYx6

Educational Codeforces Round 38 — Editorial

By BledDest, history, 5 years ago, In EnglishA. Word CorrectionHint: When does some vowel stay in string?

SolutionB. Run For Your PrizeHint 1: It's never profitable to go back. No prizes left where you have already gone.

Hint 2C. Constructing TestsHint: At first we will solve the problem mentioned in the statement. The formula is . Firstly, each submatrix k × k should have at least one row with zero in it. Exactly  non-intersecting submatrices fit in matrix n × k. The same with the columns. So you should have at least this amount squared zeros.

SolutionD. Buy a TicketThe function of the path length is not that different from the usual one. You can multiply edge weights by two and run Dijkstra in the following manner. Set disti = ai for all  and push these values to heap. When finished, disti will be equal to the shortest path.

Model solution

E. Max HistoryHint 1: Count the number of times each number appears in the sum of all fa.

Hint 2: Try to find a sufficient and necessary condition that ai appears in fa of a permutation.

More hintsF. Erasing SubstringsLet's denote n = |s|.

Hint: There is a simple  solution: dp[m][mask] — best answer if we considered first m characters of the string and a mask of erased substrings. However, storing a string as a result of each state won't fit neither into time limit nor into memory limit. Can we make it faster?

SolutionG. Shortest Path QueriesThis is a more complex version of problem G from Educational Round 27. You can find its editorial here.

To solve the problem we consider now, you have to use a technique known as dynamic connectivity. Let's build a segment tree over queries: each vertex of the segment tree will contain a list of all edges existing in the graph on the corresponding segment of queries. If some edge exists from query l to query r, then it's like an addition operation on segment [l, r] in segment tree (but instead of addition, we insert this edge into the list of edges on a segment, and we make no pushes). Then if we write some data structure that will allow to add an edge and rollback operations we applied to the structure, then we will be able to solve the problem by DFS on segment tree: when we enter a vertex, we add all edges in the list of this vertex; when we are in a leaf, we calculate the required answer for the corresponding moment of time; and when we leave a vertex, we rollback all changes we made there.

What data structure do we need? Firstly, we will have to use DSU maintaining the distance to the leader (to maintain the length of some path between two vertices). Don't use path compression, this won't work well since we have to do rollbacks.

Secondly, we have to maintain the base of all cycles in the graph (since the graph is always connected, it doesn't matter that some cycles may be unreachable: by the time we get to leaves of the segment tree, these cycles will become reachable, so there's no need to store a separate base for each component). A convenient way to store the base is to make an array of 30 elements, initially filled with zeroes (we denote this array as a). i-th element of the array will denote some number in a base such that i-th bit is largest in the number. Adding some number x to this base is really easy: we iterate on bits from 29-th to 0-th, and if some bit j is equal to 1 in x, and a[j] ≠ 0, then we just set  (let's call this process reduction, we will need it later). If we get 0 after doing these operations, then the number we tried to add won't affect the base, and we don't need to do anything; otherwise, let k be the highmost bit equal to 1 in x, and then we set a[k]:  = x.

This method of handling the base of cycles also allows us to answer queries of type 3 easily: firstly, we pick the length of some path from DSU (let it be p), and secondly, we just apply reduction to p, and this will be our answer.

Educational Codeforces Round 37 — Editorial

By BledDest, history, 5 years ago, translation, In English920A - Water The GardenThe answer is the maximal value among the following values:  (to cover all water beds within some segment), a[1] (to cover water beds before the first tap), n - a[k] + 1 (to cover all water beds after the last tap).

920B - Tea QueueLet's store the last moment when somebody gets a tea in the variable lst. Then if for the i-th student lst ≥ ri then he will not get a tea. Otherwise he will get it during max(lst + 1, li) second. And if he gets a tea then lst will be replaced with the answer for this student.

920C - Swap Adjacent ElementsTake a look at some pair (i, j) such that i < j and initial ai > aj. It means that all the swaps from i to j - 1 should be allowed. Then it's easy to notice that it's enough to check only i and i + 1 as any other pair can be deducted from this. You can precalc pos[ai] for each i and prefix sums over the string of allowed swaps to check it in no time.

Overall complexity: O(n).

920D - TanksEliminate the obvious corner case when we don't have enough water (). Now we don't consider it in editorial.

Let's fix some set of tanks S, and let d be  (the total amount of water in the set). If d ≡ V (mod K) (d and V have the same remainders modulo k), then we can transfer all water from S to one tank x, transfer all water from  to another tank y, and then using some number of operations transfer required amount of water from x to y (or from y to x). So we have a solution when we have some set of tanks S such that d ≡ V(mod K).

What if we don't have such set? In this case it is impossible to solve the problem since we cannot obtain a tank with d water such that d ≡ V (mod K) (and, obviously, we cannot obtain a tank with exactly V water).

To find this set S, we may use some sort of knapsack dynamic programming.

920E - Connected Components?Let S be the set of unvisited vertices. To store it, we will use some data structure that allows us to do the following:

insert s — insert some value s into the set;erase s — delete s from the set;upper_bound s — find the smallest integer y from the set such that y > s.For example, std::set<int> from C++ allows us to do all these operations fastly. Also we can use this structure to store the adjacency lists.

We will use a modified version of depth-first-search. When we are entering a vertex with dfs, we erase it from the set of unvisited vertices. The trick is that in dfs we will iterate over the set of unvisited vertices using its upper_bound function. And we will make not more than O(m + n) iterations overall because when we skip an unvisited vertex, that means there is no edge from this vertex to the vertex we are currently traversing in dfs, so there will be no more than 2m skips; and each iteration we don't skip decreases the number of unvisited vertices.

920F - SUM and REPLACEAt first let's notice that this function converges very quickly, for values up to 106 it's at most 6 steps. Now we should learn how to skip updates on the numbers 1 and 2.

The function values can be calculated from the factorization of numbers in  with Eratosthenes sieve.

Let's write two segment trees — one will store maximum value on segment, the other will store the sum. When updating some segment, check if its maximum is greater than 2. Updates are done in the manner one can usually write build function, you go down to the node corresponding to the segment of length 1 and update the value directly.

Overall complexity:  as we access any segment no more than 6 times.

920G - List Of IntegersLet's use binary searching to find the answer. Denote as A(p, y) the number of positive integers z such that z ≤ y and gcd(z, p) = 1; the answer is the smallest integer d such that A(p, d) ≥ A(p, x) + k. We may use, for example, 1018 as the right border of segment where we use binary searching; although the answers are a lot smaller than this number, for y = 1018 it is obvious that A(p, y) will be really large for any p from [1;106].

How can we calculate A(p, y) fastly? Let's factorize p and use inclusion-exclusion. Let S be a subset of the set of prime divisors of p, and P(S) be the product of all numbers from S. For each possible subset S, we have to add  to the result (since there are exactly  integers from [1, y] divisible by every prime from S). Since any number from [1, 106] has at most 7 prime divisors, there are at most 27 subsets to process.

Educational Codeforces Round 36 Editorial

By vovuh, history, 5 years ago, translation, In English915A - GardenIn this problem we just need to find maximum divisor of k that belongs to array a. Let's call it r. Then we need to print .

915B - BrowserIf l = 1 and r = n then the answer is 0. If l = 1 and r ≠ n or l ≠ 1 and r = n then answer is |pos - l| + 1 or |pos - r| + 1 respectively. And in the other case (when l ≠ 1 and r ≠ n) the answer is r - l + min(|pos - l|, |pos - r|) + 2.

915C - Permute DigitsLet's construct the answer digit by digit starting from the leftmost. Obviously, we are asked to build lexicographically maximal answer so in this order we should choose the greatest digit on each step.

Precalc cnti — number of digits i in number a. Iterate over all possible digits starting from the greatest. For each digit check if it's possible to put it in this position. For this you construct minimal suffix (greedily put the lowest digit) and compare the resulting number with number b. If it became less or equal then proceed to the next digit.

Overall complexity: O(|a|2·|AL|), where AL is digits from 0 to 9.

915D - Almost Acyclic GraphThe constraits are set in such a way that naive O(m·(n + m)) solution won't pass (unmark every edge one by one and check if graph of marked edges doesn't contain cycles with dfs/bfs).

Thus we should somehow limit the number of edges to check. Let's take arbitrary cycle in graph. Do dfs, store the vertex you used to travel to any other vertex and restore edges with this data if cycle is met. With this algo length of cycle will not exceed n. Then do the naive algo but check only edges from this cycle.

Overall complexity: O(n·(n + m)).

915E - Physical Education LessonsLet's store current intervals with non-working days in set sorted by the right border. When new query comes you search for the first interval to have its right border greater or equal than the currect left border and update all intervals to intersect the query (either fully delete or insert back its part which doesn't intersect query). Finally, if k = 1 then insert the query into current set. Updates on the number of working days can be done while deleting segments on the fly.

Overall complexity: .

915F - Imbalance Value of a TreeLet's calculate the answer as the difference between sum of maxima and sum of minima over all paths. These sums can be found by the following approach:

Consider the sum of maxima. Let's sort all vertices in ascending order of values of ai (if two vertices have equal values, their order doesn't matter). This order has an important property that we can use: for every path, the maximum on this path is written on the vertex that has the greatest position in sorted order. This allows us to do the following:

Let's denote as t(i) a tree, rooted at vertex i, that is formed by the set of such vertices j that are directly connected to i or some other vertex from the set, and have aj < ai. Consider the vertices that are connected to i in this tree. Let's denote them as v1, v2, ..., vk (the order doesn't matter), and denote by sj the size of the subtree of vj in the tree t(i). Let's try to calculate the number of paths going through i in this tree:

 paths that have i as its endpoint; paths (connecting a vertex from subtree of vx to a vertex from subtree of vj).So vertex i adds the sum of these values, multiplied by ai, to the sum of maxima. To calculate these sums, we will use the following algorithm:

Initialize a DSU (disjoint set union), making a set for each vertex. Process the vertices in sorted order. When we process some vertex i, find all its already processed neighbours (they will be v1, v2, ..., vk in t(i)). For every neighbour vj, denote the size of its set in DSU as sj. Then calculate the number of paths going through i using aforementioned formulas (to do it in linear time, use partial sums). Add this number, multiplied by ai, to the sum of maxima, and merge i with v1, v2, ..., vk in DSU.

To calculate the sum of minima, you can do the same while processing vertices in reversed order.

Time complexity of this solution is .

915G - Coprime ArraysFor a fixed upper bound i, this is a well-known problem that can be solved using inclusion-exclusion:

Let's denote by f(j) the number of arrays with elements in range [1, i] such that gcd(a1, ..., an) is divisible by j. Obviously, . With the help of inclusion-exclusion formula we can prove that the number of arrays with gcd = 1 is the sum of the following values over all possible sets S: ( - 1)|S|f(p(S)), where S is some set of prime numbers (possibly an empty set), and p(S) is the product of all elements in the set. f(p(S)) in this formula denotes the number of arrays such that their gcd is divisible by every number from set S.

However, the number of such sets S is infinite, so we need to use the fact that f(j) = 0 if j > i. With the help of this fact, we can rewrite the sum over every set S in such a way: , where μ (j) is 0 if there is no any set of prime numbers S such that p(S) = j, |μ (j)| = 1 if this set S exists, and the sign is determined by the size of S (μ (j) = 1 if |S| is even, otherwise μ (j) =  - 1).

An easier way to denote and calculate μ (j) is the following (by the way, it is called Möbius function):

μ(j) = 0, if there is some prime number p such that p2|j. Otherwise μ(j) = ( - 1)x, where x is the number of primes in the factorization of j.

Okay, so we found a solution for one upper bound i, it's . How can we calculate it for every i from 1 to k?

Suppose we have calculated all values of f(j) for some i - 1 and we want to recalculate them for i. The important fact is that these values change (and thus need recalculation) only for the numbers j such that j|i. So if we recalculate only these values f(j) (and each recalculation can be done in O(1) time if we precompute the xn for every ), then we will have to do only  recalculations overall.

Educational Codeforces Round 35 — Editorial

By BledDest, history, 5 years ago, translation, In English911A - Nearest MinimumsThis task can be done by one array traversal. Maintain cur — current minimum value, pos — position of the last occurrence of cur, ans — current minumum distance between two occurrences of cur. Now for each i if ai < cur then do cur:  = ai, pos:  = i, ans:  = ∞. For ai = cur do ans = min(ans, i - pos), pos:  = i. In the end cur will be the global minimum of array and ans will keep the closest its occurrences.

Overall complexity: O(n).

911B - Two CakesLet's fix x — number of plates to have pieces of the first cake. n - x plates left for the other cake. Obviously, the most optimal way to distribute a pieces to x plates will lead to the minimum of  pieces on a plate. Now try every possible x and take maximum of .

Overall complexity: O(n).

911C - Three GarlandsThere are pretty few cases to have YES:

One of ki is equal to 1;At least two of ki are equal to 2;All ki equal 3;k = {2, 4, 4}.It's easy to notice that having minimum of ki equal to 3 produce the only case, greater numbers will always miss some seconds. Let's consider minimum of 2, let it cover all odd seconds. Now you should cover all even seconds and 2 and 4, 4 are the only possible solutions.

Overall complexity: O(1).

911D - Inversion CountingPermutaion with one swap is called transposition. Any permutation can be expressed as the composition (product) of transpositions. Simpler, you can get any permutation from any other one of the same length by doing some number of swaps. The sign of the permutation is the number of transpositions needed to get it from the identity permutation. Luckily (not really, this is pure math, check out all proofs at wiki, e.g) the sign can also tell us the parity of inversion count.

Now you can start with computing parity of inversion count of the original permutation (naively, check all pairs of indices). Finally you can decompose queries into swaps, any method will be ok. Like, you can swap al and ar, then al + 1 and ar - 1 and so on (this is  swaps). Then parity of inversion count of the resulting permutation will change if you applied odd number of swaps.

Overall complexity: O(n2 + m).

911E - Stack SortingLet's denote A(l, r) as some stack-sortable array which contains all integers from l to r (inclusive).

We can see that if the first element of A(l, r) is x, then A(l, r) = [x] + A(l, x - 1) + A(x + 1, r), where by  +  we mean concatenation of arrays. It's easy to prove this fact: if the first element is x, then we have to store it in the stack until we have processed all elements less than x, so in A(l, r) no element that is greater than x can precede any element less than x.

This way we can represent the prefix we are given. For example, if n = 7, k = 3 and prefix is [6, 3, 4], then we can rewrite the permutation we have to obtain as:

A(1, 7) = [6] + A(1, 5) + A(7, 7) = [6] + [3] + A(1, 2) + A(4, 5) + A(7, 7) = [6] + [3] + [1] + A(2, 2) + A(4, 5) + A(7, 7).

So the unknown suffix is a contatenation of some stack-sortable arrays. It's easy to see that if an array is sorted in non-increasing order, then it is stack-sortable. So we can replace each block A(x, y) with an array [y, y - 1, y - 2, ..., x].

If during rewriting the given prefix we obtain some impossible situation (for example, when n = 7 and given prefix is [6, 7], we have [6] + A(1, 5) + A(7, 7) and 7 can't be the beginning of A(1, 5)), then answer is  - 1.

911F - Tree DestructionThe solution is to choose some diameter of given tree, then delete all the leaves which don't belong to diameter (iteratively), and then delete the diameter. I.e. while tree includes vertices aside from the ones forming diameter we choose some leaf, increase answer by the length of the path between this leaf and farthest endpoint of the diameter (from this leaf) and delete this leaf. Then while tree consists of more than one vertex we choose two endpoints of diameter, increase answer by the length of the path between it and delete any of them.

At first we need to prove that we can choose any diameter. It can be proved by next fact: we can find the diameter by two graph traversals (DFS/BFS) (we need to find farthest vertex and then again find farthest vertex from found farthest vertex, given path is a diameter of the tree). It means that for each vertex that doesn't belongs to the diameter we will add maximal possible path length by the algorithm described above.

And finally obviously that at some moment we need to delete the diameter and there is no way to do this better than we do it in described solution.

911G - Mass Change QueriesWe can represent a query as a function f: f(i) = i if i ≠ x, f(x) = y. If we want to apply two functions, then we can calculate a composition of these functions in time O(max ai); in this problem max ai is 100.

So we can do the following:

Use scanline technique. Build a segment tree over queries where we store a composition of functions on segment in each vertex. Initially all transformations are f(i) = i. When a segment where we apply a query begins, we update the segment tree: we change the transformations on this query's index to the following: f(i) = i if i ≠ x, f(x) = y. When a segment ends, we revert the transformation on this index to f(i) = i. The trick is that the composition of all current transformations is stored in the root of the segment tree, so we can easily calculate the result of transformation.

Educational Codeforces Round 34 Editorial

By vovuh, history, 5 years ago, translation, In English903A - Hungry Student ProblemThere are lots of different approaches to this problem. For example, you could just iterate on the values of a and b from 0 to 33 and check if 3a + 7b = x.

903B - The ModcrabA simple greedy solution works: simulate the process until the Modcrab is dead, and make Vova drink a potion if his current health is less than a2 + 1, and monster's current health is greater than a1 (because in this case Vova can't finish the Modcrab in one strike, but the Modcrab can win if Vova doesn't heal). In any other situation Vova must attack.

Since all parameters are up to 100, the number of phases won't exceed 9901.

903C - Boxes PackingYou can always show that the answer is equal to the amount of boxes of the size appearing the most in array. Result can be easily obtained by constructive algorithm: take these most appearing boxes, put smaller boxes in decreasing order of their size into free ones (there always be space) and put resulting boxes into the larger ones in increasing order.

Overall complexity: .

903D - Almost DifferenceStarting pretty boring this came out as the most fun and controversial problem of the contest...

Well, here is the basis of the solution. You maintain some kind of map/hashmap with amounts each number appeared in array so far. Processing each number you subtract ai i times (1-indexed), add prefix sum up to (i - 1)-th number, subtract cntai - 1 * (ai - 1), cntai * ai and cntai + 1 * (ai + 1) and add ai cntai - 1 + cntai + cntai + 1 times. Then update cnt with ai.

And now we have to treat numbers greater than long long limits. Obviously, you can use built-in bigints from java/python ot write your own class with support of addition and printing of such numbers. However, numbers were up to 1019 by absolute value. Then you can use long double, its precision is enough for simple multiplication and addition. You can also use unsigned long long numbers: one for negative terms and the other one for positive terms, in the end you should handle printing negative numbers.

Overall complexity: .

903E - Swapping CharactersIf we don't have two distinct strings then we just have to swap any pair of characters in any of the given strings and print it. Otherwise we have to find two indices i and j such that si ≠ sj. Then let's store all positions p such that si, p ≠ sj, p in array pos. If the number of those positions will exceed 4 then the answer will be «-1». Otherwise we need to iterate over all positions diffpos in array pos, try to swap si, diffpos with any other character of si and check that current string can be the answer. We also should try the same thing with string sj.

It is clear how we can check string t to be the answer. Let's iterate over all strings s1, s2, ..., sk and for each string si count the number of positions p such that si, p ≠ tp. Let's call it diff(si, t). If for any given string diff(si, t) is not equal to 0 or 2 then string t can't be the answer. Otherwise if for any given string diff(si, t) is equal to 0 and all characters in string si are distinct then t can't be the answer.

If there is no string that satisfies all aforementioned conditions then the answer will be «-1».

903F - Clear The MatrixConstraints lead us to some kind of dp solution (is it usually called dp on broken profile?). Let dp[i][j][mask] will be the minimum price to get to i-th column and j-th row with mask selected. mask is the previous 12 cells inclusive from (i, j) (if j = 4 then its exactly current column and two previous ones).

Transitions for submatrices 1 × 1, 2 × 2 and 3 × 3 are straighforward, just update mask with new ones and add ak to current value.

If the first cell of these 12 is empty or 1 is set in this position, then you can go to dp[i][j + 1][mask»1] (or (i + 1) and 1 if j = 4) for free.

Finally you can go to dp[i + 1][j][212 - 1] with the price of a4.

Initial value can be 0 in dp[3][4][0] (the first 12 cells of the matrix).

The answer will be stored in some valid mask of dp[n][1][mask]. However, you can add 4 extra empty columns and take the answer right from dp[n + 4][1][0], it will be of the same price.

Overall complexity: O(n·4·212).

903G - Yet Another Maxflow ProblemFirst of all, let's calculate minimum cut instead of maximum flow.

The value of the cut is minimum if we choose S (the first set of the cut) as x first vertices of part A and y first vertices of part B (1 ≤ x ≤ n, 0 ≤ y < n). That's because if i is the minimum index such that , then we don't have to add any vertices Aj such that j > i to S, because that would only increase the value of the cut. Similarly, if i is the maximum index such that , then it's optimal to add every vertex Bj such that j < i to S.

Okay, so we can try finding minimum cut as a function F(x, y) — value of the cut if we choose S as the union of x first vertices in A and y first vertices in B.

To find its minimum, let's rewrite it as F(x, y) = F1(x) + F2(y) + F3(x, y), where F1(x) is the sum of capacities of edges added to the cut in part A (it doesn't depend on part B), F2(y) is the sum of capacities added to the cut from part B, and F3(x, y) is the sum of capacities added to the cut by edges going from A to B.

These functions can be denoted this way:

F1(x) = 0 if x = n; otherwise F1(x) is the capacity of the edge going from Ax to Ax + 1;F2(y) = 0 if y = 0; otherwise F2(y) is the capacity of the edge going from By to By + 1;F3(x, y) is the sum of capacities over all edges Ai → Bj such that i ≤ x and j > y.Since only the values of F1 are not fixed, we can solve this problem with the following algorithm:

For each x (1 ≤ x ≤ n), find the minimum possible sum of F2(y) + F3(x, y). Let's denote this as best(x), and let's denote T(x) = F1(x) + best(x);Build a segment tree that allows to get minimum value and modify a single value over the values of T(x). When we need to change capacity of an edge, we add the difference between new and old capacities to T(x); and to calculate the maximum flow, we query minimum over the whole tree.But how can we calculate the values of best(x)? We can do it using another segment tree that allows to query minimum on segment and add some value to the segment. First of all, let's set x = 0 and build this segment tree over values of F2(y) + F3(x, y). The value of F2(y) is fixed for given y, so it is not modified; the value of F3(x, y) is initially 0 since when x = 0, there are no vertices belonging to S in the part A.

And then we calculate the values of best(x) one by one. When we increase x, we need to process all edges leading from Ax to part B. When we process an edge leading to vertex Bi with capacity c, we have to add c to every value of F3(x, y) such that i > y (since if i > y, then ), and this can be performed by addition on segment in the segment tree. After processing each edge leading from Ax to part B, we can query best(x) as the minimum value in the segment tree.

Time complexity of this solution is .

Educational Codeforces Round 33 Editorial

By awoo, history, 5 years ago, translation, In English893A - Chess For ThreeThis task is about pure implementation. Maintain the number of current spectator and check if he doesn't win. With knowledge of current winner w and current spectator s you can easily get the third player by formula 6 - w - s (just the sum of all numbers without the known ones).

Overall complexity: O(n).

893B - Beautiful DivisorsLet's notice that there are only 8 beautiful numbers less than 105. Generate them all and select the greatest one which is also divisor of n.

Overall complexity: O(1).

893C - RumorIn this problem you are given an undirected graph with weighted vertices. And the problem is to calculate the sum of minimum values in every connected component. To do this we just need to run DFS or BFS several times.

893D - Credit CardThe following greedy solution works.

Firstly, deposite money only on days with ai = 0. Secondly, every time the balance is negative to the day with ai = 0, refill it to maximal possible value such that it won't go over d later.

Days with ai ≠ 0 can only lead to invalid state by going over card limit. We can only add money to the balance. Adding zero money in those days won't make invalid states if all were valid previously. Finally, if it's possible to get valid state in every day then it's possible to get it by refilling the same day the check happens. For example, you can make max(0, currentBalance) balance in those days. Then you will never have negative balance there. Though it's not the most optimal way.Let delta be some value you deposite in some day with ai = 0 to pass all conditions till the next day with aj = 0. I state that function of number of game's moves dependancy on delta is monotonious. Let's check it for some fixed x. Define minimum balance you will get on any suffix from now as minBal. Obviously, taking x - 1 will make it minBal - 1. If it goes negative then you will need an extra move to finish the game. Thus taking maximal delta will lead to the lowest score possible.And last but not least — realization part. What will be the maximum possible value to deposite? Actually, it's such a value that optimal game after this will lead to maximum balance of d in some day. Thus, you want to check what will be the maximum balance maxBal if you add zero money and take delta as d - maxBal. Obviously, if it's negative then output  - 1.

Naively this still works on O(n) per day and lead to O(n2) overall. Notice that by depositing delta you increase maximums on each suffix for now by delta. So, you can calculate it as you will do nothing and add sum deltaSum of your delta's to get actual value. You store prefix sum of aj up to i in pri. Then take maximum on suffix for every i (sui is the maxumum prj for j from i to n). delta = d - (deltaSum + sui).

I hope I made it clear enough. :D

Overall comlpexity: O(n).

893E - Counting ArraysFill the array with ones. Now we should take every prime divisor i of x and distribute cnti (maximum power of this prime to appear in x) of it into some cells of the array. It is pretty well-known problem, it's equal to . Take product of this values for every prime i. This will be the answer if there were no negative numbers. But we should also multiply it by number of ways to select even number of position to put unary minuses — 2y - 1 (like you can fill in y - 1 position anyhow and the final one will be determined by parity of current count).

To process many queries you should factorize numbers in  (by precalcing the smallest prime divisor of every number up to 106 with sieve of Eratosthenes), get  in O(1) (by precalcing factorials and inverse factorials) and get 2k in  (binary exponentiation).

Overall complexity: .

893F - Subtree Minimum QueryThe main idea is to use a two-dimensional data structure: one dimension is depth of vertices, and other dimension is the time we entered a vertex during DFS.

Model solution uses sparse table for these purposes. First of all, let's renumerate the vertices so we can handle them easier. We run DFS from the root and then sort the vertices by their depth (and if depths are equal, by time we entered them in DFS). Then we renumerate vertices in this sorted order.

We need to denote some functions in order to continue:

D(x) — depth of vertex x in the tree;tin(x) — the time we entered x during DFS;tout(x) — the time we left x during DFS.For each depth we can store a sorted array of vertices belonging do this depth. This will allow us to build an auxiliary sparse table lf, where lf[i][x] is such vertex j that:

D(j) = D(x) + 2i;tin(j) > tin(x);tin(j) is minimal among all vertices that meet first two conditions.We also need a second sparse table rg, where rg[i][x] is j iff:

D(j) = D(x) + 2i;tout(j) > tout(x);tout(j) is minimal among all vertices that meet first two conditions.These sparse tables can be built using binary search in arrays we created for depths.

Okay, why do we need them? To create a third sparse table that will process the queries themselves:

table[i][j][x] — the minimum value of ay among vertices y such that y belongs to 2j-blocked subtree of some vertex with index included in [x, x + 2i). This table can be built backwards with the help of auxiliary tables.

So, how do we answer the queries? We need to look at the binary representation of k + 1 and do something like binary lifting (but descending the tree instead of ascending) and maintain the leftmost and the rightmost vertices on current depth which belong to the subtree we are interested in (and make queries to table on the segment between these two vertices).

This solution works in , but, unfortunately (or fortunately to some participants), we made the time limit too high so the structures that require  time to process each query, such as two-dimensional segment trees, might also get AC.

Educational Codeforces Round 32 — Editorial

By BledDest, history, 5 years ago, translation, In English888A - Local ExtremaIterate over indices from 2 to n - 1 and check if at least one of given local extremum conditions holds.

Overall complexity: O(n).

888B - Buggy RobotConsider the final cell after original path. It has some distance dx to x = 0 and dy to y = 0. That means the path included at least dx and dy in corresponding directions. Let's remove just these minimal numbers of moves.

Finally, the answer will be n - dx - dy, where (dx, dy) are distances from the final cell of the original path to (0, 0).

Overall complexity: O(n).

888C - K-Dominant CharacterAt first, notice that the final answer is minimum over answers for each character.

The answer for one character can be obtained like this. Write down lengths of segments between two consecutive occurrences of this character, from the first occurrence to the start of the string and from the last to the end of the string. Take maximum of these values. Answer will be this maximum + 1.

Overall complexity: O(|Alpha|·n).

888D - Almost Identity PermutationsLet's iterate on m — the number of indices such that pi ≠ i. Obviously, 0 ≤ m ≤ k.

How to count the number of permutations with fixed m? First of all, we need to choose the indices that have the property pi ≠ i — there are  ways to do this. Secondly, we need to construct a permutation q for chosen indices such that for every chosen index qi ≠ i; permutations with this property are called derangements, and the number of derangements of fixed size can be calculated using exhaustive search (since m ≤ 4).

So the answer is , where d(m) is the number of derangements of size m.

888E - Maximum SubsequenceLet's consider the naive solution in O(2n) or O(2n·n). Iterate over all subsets of original set, calculate sums and take maximum of them modulo m.

Now we can use meet-in-the-middle technique to optimize it to . Preprocess the first  elements naively and push sums modulo m to some array. After this process the second half with following algorithm.

Take sum of the set and find the greatest total sum of current and some sum in the array. As any sum of two numbers less than m can go no greater than 2m, we can consider just two values: the greatest number in array and the greatest number less than m - currentSum in the array. This can be found by binary search over sorted array.

Overall complexity: .

888F - Connecting VerticesWe can use dynamic programming to solve this problem, but we need to choose the states we maintain very carefully.

One of the approaches might be: dp[i][j] — the number of ways to connect the vertices between i and j to vertices i or j if i and j are already connected (so there is no possibility to connect any vertex between i and j to some vertex outside).

What dp values should we access if we, for example, try to connect i-th vertex to some vertex x? To get everything connected, we then have to connect vertices from interval (i, x) to these two, and vertices from (x, j) to x, j or i — and connections to i from the second interval are difficult to handle. We need to somehow get rid of them, and the solution is to choose x as the vertex with greatest index that we connect directly to i. And vice versa, if we connect something to j, then we choose the smallest index of vertex to be connected with j directly.

But that's not all we have to handle. Suppose we have four vertices, and 0 is already connected to 3. One of the possibilities to finish it is to connect 0 to 1 and 2 to 3, but if we process current dynamic programming as it is, we will count it twice (if we choose to connect 1 to 0 firstly, or if we connect 2 to 3). To get rid of this problem, we will use a flag that will denote whether we can connect anything to vertex i, and if we choose to pick the first connection from j, then we don't connect anything to i.

So the solution is:

dp[i][j][flag] — the number of ways to connect the vertices from interval (i, j) to i and j, and flag denotes if we can connect anything to i.

How to calculate it:

If j = i + 1, then dp[i][j][flag] = 1 (there is nothing left to connect);Otherwise set dp[i][j][flag] = 0;If flag = 1, then iterate on vertex x we connect to i and add dp[i][x][flag]·dp[x][j][flag];Iterate on vertex y we connect to j and add dp[i][y][0]·dp[y][j][1].The answer is dp[0][n][0] (if vertices are 0-indexed). Vertex n is actually vertex 0, so don't forget to update the matrix a for it.

888G - Xor-MSTWe can use Boruvka's algorithm to solve this problem.

This algorithm usually works in : initially MST is empty, and then we run a number of iterations. During each iteration we find connected components in the graph formed by already added edges, and for each component we find the shortest edge that leads out of this component. Then we add the edges we found to the MST (but we should be careful to avoid adding edges that form cycles in MST). The number of iterations is at most , and each of iterations can be done in O(m).

However, in this problem we need to speed up this algorithm. We can do each iteration in  time using a binary trie. We can store all values from a in a trie. When we need to find the shortest edge that connects some component with vertices outside of it, we firstly remove all values contained in this component from the trie. After that, for each vertex in the component we can find the closest vertex outside the component in  by descending the trie. And then we insert the values of ai belonging to the component back into the trie. Since for each vertex we descend the trie three times (to remove it, to find closest vertex and to add it back), each iteration requries , and the whole algorithm works in  time.

Educational Codeforces Round 31 Editorial

By awoo, history, 5 years ago, translation, In English884A - Book ReadingLet's read the book greedily. On i-th day Luba will read for 86400 - ai seconds. Subtract value for each day from t until t becomes less or equal to zero. That will be the day Luba finishes the book.

Overall complexity: O(n).

884B - Japanese Crosswords Strike BackThe only answer is when no segment can be moved one cell either to the left or to the right. So there should be exactly one cell between two consecutive segments and the first and the last segments should touch the borders.

Thus total count of cells needed is .

Overall complexity; O(n).

884C - Bertown SubwayLet's notice that one swap can affect at most two cycles of this permutation. Moreover you can join two cycles into one with the length equal to the sums of lengths of initial ones.

The function we are going to maximize is f(a, b) = (a + b)2 - a2 - b2, where a and b are the lengths of the cycles we are joining together. f(a, b) = (a2 + 2ab + b2) - a2 - b2 = 2ab. Now its easily seen that the maximum is achived when joining two cycles with the greatest product of lengths. Finally they are the two longest cycles in permutation.

Overall complexity: O(n).

884D - Boxes And BallsLet's consider the process backwards: we will store the number of balls of each color in a multiset and then "merge" some of them.

If n is odd, then we can always pick three groups of balls with minimal sizes and replace them by one group (adding the size of this group to the penalty). Repeat until you have only one group.

If n is even, then we need to add an auxiliary group of size 0. Then n becomes odd, so we can use the above algorithm to solve this case.

Why does it work? This algorithm is exactly the same as the algorithm of building a Huffman code with the alphabet of size 3. And it can easily be seen that these problems are similar: by separating a group of balls into three groups, we add a new character to the codes of the colours present in that group, and our goal is to obtain a prefix code.

884E - Binary MatrixThe main idea is to read and process each row of the matrix separately. To do this, we will use DSU data structure. The answer will be equal to the difference between the number of 1's and the number of merge operations in DSU.

When processing the row, we will keep the DSU for the previous row. When processing a certain index in the row, we will try to merge it with the element to the left of it and with the element to the top — that's all we have to check here.

You also have to handle the fact that we cannot store the whole DSU since the number of components can be up to , and it's impossible to store all required information for them. So each time we process a row, we have to renumerate all components in this row to ensure that every time we are operating with indices of components not greater than 2m.

884F - Anti-PalindromizeThis problem has two different solutions: a mincost maxflow approach and a greedy one. We will tell you about the latter.

First of all, let t = s. Then find all pairs of indices (i, n - i + 1) such that ti = tn - i + 1 (let the number of these pairs be m). It's obvious that we have to replace at least one letter in each of these pairs.

For each of these pairs let's replace the letter with lower bi with something. Let's analyze the letters we are going to replace. Let cnt(x) be the number of occurences of letter x that we have to replace. There are two cases:

There is no letter x such that 2 * cnt(x) > m. Then we can replace these letters without involving anything else and get an antipalindromic string with minimal possible cost;There is a letter x such that 2 * cnt(x) > m. It's obvious that there is at most one such letter. Let's replace some occurences of x with other letters that are to be replaced. Then we will still have some occurences of x that need to be replaced. Let's take one letter from each pair such that both of letters in a pair are not equal to x. Among these possibilities choose the required number of letters with minimum values of bi. Then we can replace remaining occurences of x with these letters.

Educational Codeforces Round 30 Editorial

By awoo, history, 5 years ago, translation, In English873A - ChoresSince , it is better to do exactly k chores in time x. And since we need to minimize total time we need to spend, it's better to speed up the "longest" chores. So the answer is .

873B - Balanced SubstringLet cnt0(i) be the number of zeroes and cnt1(i) — the number of ones on prefix of length i; also let balance(i) = cnt0(i) - cnt1(i) (i ≥ 0). The interesting property of balance is that the substring [x, y] is balanced iff balance(y) = balance(x - 1). That leads to a solution: for each value of balance maintain the minimum i where this balance is obtained (let it be called minIndex), and for each index i in the string update answer with i - minIndex(balance(i)).

873C - Strange Game On MatrixLet's notice that this task can be solved independently for each column, total result will be the sum of results for columns.

The ones you should remove will always be the top ones in column. It makes no profit to erase some one while there are still ones on top of it, score won't become higher.

Go from the top of the column to the bottom and recalculate the score after removing every one. Take the first position of the maximal score and update global answer with it.

Overall complexity: O(n3). O(n2) can be achieved with partial sums.

873D - Merge SortFirst of all, if k is even, then there is no solution, since the number of calls is always odd (one call in the beginning, and each call makes either 0 or 2 recursive calls).

Then, if k is odd, let's try to start with a sorted permutation and try to "unsort" it. Let's make a function unsort(l, r) that will do it. When we "unsort" a segment, we can either keep it sorted (if we already made enough calls), or make it non-sorted and then call unsort(l, mid) and unsort(mid, r), if we need more calls. When we make a segment non-sorted, it's better to keep its both halves sorted; an easy way to handle this is to swap two middle element.

It's easy to see that the number of unsort calls is equal to the number of mergesort calls to sort the resulting permutation, so we can use this approach to try getting exactly k calls.

873E - Awards For ContestantsLet's consider naive solution: make three loops to fix amounts of people to get dimplomas of each degree, take the best. Obviously, sorting the scores will regroup optimal blocks for each degree in such a way that they come in segments of initial array.

We tried to make these solutions fail but underestimated the abilities of contestants to optimize this kind of stuff and couple of such made it to the end of contest. :(

To be honest, we just need to get rid of the last loop. Let bi be the difference between ai and ai + 1 (a is sorted, bn - 1 = an - 1). Then let i2 be the position of the last diploma of second degree and cnt1, cnt2 be the amounts of diplomas of the first ans the second degrees. Thus the best position to put the separator between the third degree and no diploma is the postion with the maximum number in array b over segment . This are the borders of possible amount of the dimplomas of the third degree.

Maximum over segment can be implemented with segment tree, sparse table or even naive square matrix with O(n2) precalc time and O(n2) memory.

Overall complexity: O(n2)/.

873F - Forbidden IndicesThis problem can be solved with different suffix structures. Model solution uses suffix array.

First of all, let's reverse s, so for f(a) we will count only occurences that start in non-forbidden indices.

Then, if there is at least one non-forbidden index, there are two cases:

f(a) = 1, then the best option to choose a is to use a suffix which begins in the leftmost (after reversing s) non-forbidden index.f(a) > 1, then a is the longest common prefix of some two suffixes of s. Let's build a suffix array, then calculate the LCP array. Then recall the fact that a LCP of two suffixes is the minimum on the segment of LCP array between these two suffixes, so we can use a common stack algorithm that will for each LCP find the segment of suffixes such that this LCP is a prefix of these suffixes (to do this, for each element of LCP array we find the largest segment such that this element is minimal on that segment), and then we can use prefix sums to find the number of non-forbidden suffixes such that chosen LCP is a prefix of this suffix (and so calculate f(a) easily for each LCP).

Educational Codeforces Round 29 — Editorial

By BledDest, history, 5 years ago, translation, In English863A - Quasi-palindromeYou can check if the given is quasi-palindromic by removing all the trailing zeros and checking if resulting string is a palindrome.

863B - KayakingFirstly let's learn how to split persons in pairs as if there are no single kayaks. Let there be people with weights a, b, c and d (a ≤ b ≤ c ≤ d). Obviously, the lowest instability you can achieve is max(b - a, d - c). Swapping any two elements will only make the result greater. This greedy strategy can be used to distribute all the seats.

Now you need to check every pair of persons to seat in single kayaks and calculate total instability for the rest. The answer will be the minimun instabily over all pairs.

Overall complexity: O(n3).

863C - 1-2-3Notice that there are only 9 possible patterns in this game. You can used in a following way. Simulate games till one of the patterns get repeated. Games between this pair of occurences will get you the same total outcome no matter when they are played.

Let the distance between the games with the same pattern is dif and index of these games are idx1 and idx2 (zero-indexed). Total score of some interval is score(l, r).

Then the answer will be score(0, idx1) +  + ((k - idx1) mod dif)·score(idx1 + 1, idx1 + (k - idx1) mod dif).

863D - Yet Another Array Queries ProblemOne can guess from the constraits that complexity of the algorithm should be either O(nm + q) or O(qm). And there is a solution with the second one.

Let's try to solve the reversed problem — answer what position will some number be at after all the queries. Check the impact of some query on position pos. Let the query be on some segment [l, r]. If pos is outside this segment then you can skip it. Otherwise reverse will swap apos and ar - (pos - l), shift will swap apos and apos - 1 (if pos = l then it will be r instead of (pos - 1)).

This task can be translated to the given one just by reversing the query list.

Overall complexity: O(qm).

Obviously, you can also solve it with Cartesian tree online in .

863E - Turn Off The TVFirstly let's compress the moments of time. Note that storing only l and r isn't enough (consider pairs ([1, 2], [3, 4]) and ([1, 2], [4, 5])), you also should take (l - 1).

Now moments of time are up to 6·105. For every moment calculate the number of segments to cover it (make cntl +  = 1 and cntr + 1 -  = 1 for each segment and take prefix sums over this array). Then let prefi be the number of moments of time covered by only one segment on some prefix up to i-th moment.

And finally if for some segment [l, r] from the input prefr - prefl - 1 is 0 then you can safely delete this segment.

Overall complexity: .

863F - Almost PermutationThis problem can be solved with mincost maxflow approach.

Let's construct a following network:

Construct a vertex for every number from 1 to n. For each of these vertices add n directed edges from the source to this vertex, the capacity of each edge will be 1, and the costs will be 1, 3, 5, ..., 2n - 1 (so pushing k flow from the source to the vertex will cost exactly k2);Also construct a vertex for every index of the array. For each number make add a directed edge with capacity 1 and cost 0 to every position in the array such that this number can be put into this position, and for every index make a directed edge from the vertex constructed for this index to the sink with capacity 1 and cost 0.Minimum cost maximum flow in this network will construct a suitable array with minimum cost, so the answer to the problem is minimum cost of maximum flow in the network.

863G - Graphic SettingsIf m = 1, then everything is simple. Cycle exists if a[1] = 2, and path exists if b[1] = 1 or b[1] = a[1].

Let's consider the case when m = 2. Let's call the combination odd if the sum of parameters is odd for this combination, and even otherwise. It's easy to see that if a[1] and a[2] are both odd, then it's impossible to construct a cycle because the number of even combinations is greater than the number of odd combinations. Furthermore, it's impossible to construct a path if our initial combination is an odd one.

Let's show how to construct answer in all other cases. Constructing a cycle is easy if at least one of a[i] is even:

And constructing a path can be divided into four cases.

Starting point in corner:

Start near the border:

Both coordinates of starting point are even:

Both coordinates are odd:

So the case when m = 2 is solved.

Now, if m = 3, then it can be reduced to m = 2 as follows:

Suppose we have a[1] = 3, a[2] = 3, a[3] = 3. Then let's at first consider only combinations where the third parameter is equal to 1:

Then, if we need to add the combinations with third parameter equal to 2, we mirror the "layer":

And if we need to add the third "layer", we mirror it again:

And so on.

This way can also be used to reduce m > 3 to m = 2.

Educational Codeforces Round 28 — Editorial

By BledDest, history, 5 years ago, translation, In English846A - Curriculum VitaeThe statement literally asks for the longest subsequence which looks like [0, 0, 0, ..., 1, 1, 1]. Let's find out how many zeroes will be in this sequence and then take all ones which come after the last zero. On each step take the next zero from the beginning of the sequence and count ones after it. Update answer with the maximum value.

You can precalc number of ones on suffix with partial sums but it was not necessary in this task.

Overall complexity: O(n2) (naively) or O(n) (with partial sums).

846B - Math ShowConstraints tell us that we can avoid making any weird assumptions for any greedy solutions.

You can easily count the answer for some fixed amount of tasks completed. Just sort all left subtasks (but the longest to solve in each uncompleted task) and take the easiest till the time is over. Now you can iterate from 0 to n tasks completed and take maximum over all options.

Overall complexity: O(n2·k).

846C - Four SegmentsImagine the same task but without the first term in sum. As the sum of the array is fixed, the best second segment should be the one with the greatest sum. This can be solved in O(n) with partial sums. When recalcing the best segment to end at position i, you should take minimal prefix sum from 0 to i inclusive (from the whole sum you want to subtract the lowest number).

Now let's just iterate over all possible ends of the first segment and solve the task above on the array without this segment.

Oveall complexity: O(n2).

846D - MonitorAt first let's sort broken pixels in non-descending order by times they appear.

Obviously, if the first cnt broken pixels make monitor broken, cnt + 1 pixel won't fix it.

Thus, binary search on answer will work. Let's search for the first moment in time when the monitor becomes broken. The function to check if in some moment anst monitor is broken looks the following way.

As we want to check if there is a submatrix of size k × k, which consists only of broken pixels, let's precalc the array of partial sums cnt, cnti, j is the number of broken pixels on submatrix from (1, 1) to (i, j).

cnti, j is calculated as (1 if ai, j is broken pixel, 0 otherwise)  + cnti - 1, j + cnti, j - 1 - cnti - 1, j - 1. Sum on submatrix of size k × k then looks like cnti, j - cnti - k, j - cnti, j - k + cnti - k, j - k.

Check all possible i and j from k to n and find out if there exists submatrix with sum equal to k·k.

Overall complexity: .

846E - Chemistry in BerlandSince xi < i, then the transformation graph is a tree. Let's solve the problem recursively.

Suppose that material j is a leaf in the tree (there is no y such that xy = j). Then if we don't have enough material j, we have to transform some of material xj into j. Let's transform the amount required to set current amount of material j to aj; if we don't have the required amount of material xj, then this amount will temporarily be negative. And if we have more material j than we need to conduct the experiment, then we will transform it to xj. The same algorithm can be applied to any non-root node, but we first need to do this for all its children. This algorithm is optimal because each time we take the minimum possible amount from the parent.

After this the root will be the only node such that aj is not necessarily equal to current amount of material j. Since we solved the problem for all other materials and did it optimally, now the answer is YES iff current amount of material 1 is not less than a1.

This must be implemented carefully. Since the total amount of materials never increases, then if some material's current amount is less than, for example,  - 2·1017, then the answer is already NO. Also overflows in multiplication must be avoided; to do this, we can firstly check if the result of multiplication is not too big by multiplying values as real numbers.

846F - Random QueryFor each index i we will find the number of pairs (l, r) (before swapping) such that i is the first occurence of ai in the chosen segment. Let f(i) be previous occurence of ai before i (if i is the first occurence, then f(i) = 0 if we suppose the array to be 1-indexed). Let's find the number of pairs such that l ≤ r, and then multiply it by 2 and subtract 1 for this index. l has to be in segment (f(i), i], and r has to be in segment [i, n], so the number of ways to choose this pair is (i - f(i))(n - i + 1).

The value we receive as the sum of these values over all segments is the total number of distinct elements over all pairs (l, r), so we need to divide it by the number of these pairs.

Educational Codeforces Round 27 — Editorial

By BledDest, history, 5 years ago, In English845A - Chess TourneyLet's sort the input array in non-decreasing order. Now we should take the first n players to the first team and the last n players — to the second team. That will guarantee that every member of the first team has greater or equal rating than every member of the second team. Now the only thing left is to check if all ratings in the first teams differ from all the ratings in the second team (if some are equal then an = an + 1 in sorted order).

845B - Luba And The TicketLet's iterate over all 6-digit numbers. Now we will calculate number of positions in which digit of current ticket differs from digit of input ticket and call it res. Then answer will be minimal value res over all lucky tickets.

845C - Two TVsLet's process all the segments on the line from left to right. For each segment we should push events (li, 1) and (ri + 1,  - 1) into some array. Sort this array of pair in increasing order (usual less comparator for pairs). Then we iterate over its elements and maintain cnt — the current amount of open segments (we passed their left border and didn't pass their right border).

When we meet the event of the first type, we increment the value of cnt, the second type — decrement cnt. If cnt ≥ 3 in some moment then the answer is "NO".

Overall complexity: .

845D - Driving TestLet's notice that you should never say that you didn't notice signs "no speed limit" and "overtake is allowed". Also if you drive with speed sp, you don't want to remove signs "speed limit" with number greater or equal to sp.

Thus, greedy solution will work. Process all the events in chronological order. We should maintain stack of signs "speed limit" and amount of signs "no overtake allowed".

If we meet sign "speed limit", we push its limit to stack, sign "no overtake allowed" — increase cnt, "no speed limit" — clear stack, "overtake is allowed" — assign cnt to zero. After every event we should check if our speed is fine. While value of sign on the top of the stack is less than current speed, pop it and increase answer. If we overtake someone, we add cnt to answer and assign cnt to zero.

Overall complexity: O(n).

845E - Fire in the CityWe can use binary search to find the answer.

When binary searching, to check whether the whole city will be lightened up after t minutes, we can use sweep line technique to find the smallest x-coordinate of the cell that is not lightened by k centers of ignition (and the smallest y-coordinate too). Suppose that x0 and y0 are these coordinates; then we can place the last center of ignition at coordinates (x0 + t, y0 + t). Then we can use sweep line again to check whether the city is fully ignited.

845F - Guards In The StorehouseThis problem can be solved using dynamic programming with broken profile. First of all, we have to make the number of rows not larger than 15; if it is larger, then we can just rotate the given matrix.

Let's fill the matrix from left to right, and in each column from top to bottom. Let dp[pos][mask][f1][f2] be the number of ways to achieve the following situation: we now want to fill cell with index pos, mask denotes the rows which are already protected in this column (so there is a wall in this row or there is a guard to the left), f1 is a flag that denotes if current cell is protected by some guard above, and f2 is a flag that denotes if there was a cell that was not protected.

When advancing from one column to another, we have to change the mask so we update the rows that are currently protected. The rows such that in the previous column there was a wall in this row become un-protected, and the rows such that there is a wall in current column in this row become protected. And, of course, f1 becomes zero.

When we place a guard, we set f1 to one and make the corresponding row protected. And when we are at the wall, we have to set f1 to zero, so the guard from above doesn't protect next cell.

The answer is the sum of all dp[n·m][whatever][whatever][whatever] values.

845G - Shortest Path Problem?Let's find some path from 1 to n. Let its length be P, then the answer to the problem can be represented as , where C is the total length of some set of cycles in the graph (they can be disconnected; it doesn't matter because we can traverse the whole graph and return to the starting vertex with cost 0).

Let's treat each cycle's cost as a vector (c0, c1, c2...) where ci is the i-th bit in binary representation of cycle's cost. We can use Gaussian elimination to find the independent set of vectors that generates all these vectors. To do this, let's build any spanning tree of the graph, and then for any edge (x, y) not belonging to the spanning tree we can try to add  to the independent set (d(x) is the length of the path from the root to x in the spanning tree). When trying to add some vector, we firstly need to check if it can be represented as a combination of some vectors from the set, and only if it's impossible, then we add it to the set. The number of vectors in the set won't exceed 30, so we can use Gaussian elimination to check if the vector is a combination of elements from the set.

Then, after we found the basis, let's build the answer greedily from the most significant bit to the least: we will check if we can set the current bit so it is equal to the corresponding bit of P, while maintaining all the previous bit. To check it, we also can use Gaussian elimination.

Educational Codeforces Round 26 Editorial

By awoo, history, 6 years ago, translation, In English837A - Text VolumeMaintain the amount of capital letters taken by going from left to right, make it zero when you meet space.

Overall complexity: O(n).

837B - Flag of BerlandThere are lots of ways to check correctness. For example, you can keep boolean array with already used colors, check stripes naively and mark the color used if the stripe has single color. If all the colors are used in the end then the answer is YES.

Overall complexity: O(n·m).

837C - Two SealsIf you can place two rectangles in some way (without rotations), then it's always possible to move one of them to the top left corner and stick the other either to the bottom of the first (and push it all the way to the left) or to the right of it (and push it all the way to the top).

Now let's try all possible reorderings and rotations for every pair of seals. If there is at least one correct reordering then update the answer.

Overall complexity: O(8·n2).

837D - Round SubsetLet's use dynamic programming to solve this task.

Obviously, the roundness of the number is determined by minimum of powers of 2 and 5 in the number. Let pw5i be the maximal power of 5 in the number and pw2i be the maximal power of 2.

Let dp[i][j][l] be the maximum amount of twos we can collect by checking first i numbers, taking j of them with total power of five equal to l. It is usually called "the knapsack problem".

There are two types of transitions. You can either take current element or skip it:

dp[i + 1][j + 1][l + pw5i] = max(dp[i + 1][j + 1][l + pw5i], dp[i][j][l] + pw2i)dp[i + 1][j][l] = max(dp[i + 1][j][l], dp[i][j][l])The answer will be maximum of min(i, dp[n][k][i]) for every i. Also keeping this many states can cause ML, the first dimension should be stored in two layers and recalced on the fly.

Overall complexity: .

837E - Vasya's FunctionOne important fact is that when we subtract gcd(x, y) from y, new gcd(x, y) will be divisible by old gcd(x, y). And, of course, x is always divisible by gcd(x, y).

Let's factorize x. Consider the moment when gcd(x, y) changes. If we denote old value of gcd(x, y) by g, the new value of gcd(x, y) will be divisible by some k·g, where k is a prime divisor of x. Let's check all prime divisors of x and for each of these divisors find the number of times we need to subtract g from y to get gcd(x, y) divisible by k·g; that is just  (don't forget that x also has to be divisible by k·g). Among all prime divisors of x pick one with the minimum required number of operations (let this number of operations be m), add m to answer, subtract m·g from y and repeat the process.

837F - Prefix SumsLet's delete all zeroes from the beginning of the array; they won't affect the answer. Also we will return an array of m elements when calculating prefix sums (sum of zero elements becomes a zero in the beginning of the array, and so has to be removed).

If the size of array is at least 10, then we will get k after calculating only a few prefix sums, so we can use simple iteration. So now we have to obtain the solution in case array has less than 10 elements.

If we remove zeroes from the beginning of each array, then p(A) = A·T, where T is a matrix m × m, Ti, j = 1 if i ≤ j, otherwise Ti, j = 0. Then we can use matrix exponentiation to check whether Ai contains a number which is equal to or greater than k, and we can use binary search to find the answer. To avoid overflows, each time we get a number greater than k, we can set it to k.

837G - Functions On The SegmentsLet's build a data structure that allows us to find sum of functions on some prefix. The answer to the query can be obviously obtained using two answers on prefixes.

We will use some persistent data structure that handles prefix sum queries — persistent segment tree, for example. We will actually use two different structures: let the sum of functions in some point x0 be x0·k + m; one structure will allow us to find k, and another one will allow us to find m.

Obviously, for prefix of length 0 both k and m are equal to 0. Then when we advance from prefix of length i to prefix of length i + 1, we do the following: in the structure that handles k we add ki in position xi, 1 + 1 and add ( - ki) in position xi, 2 + 1, so it is added only on segment [x1 + 1, x2]. The same approach can be used to find m: add yi, 1 in position 0, add mi - yi, 1 in position xi, 1 + 1 and add yi, 2 - mi in position xi, 2 + 1. And to get the value in point x0 on some prefix, we just make a prefix sum query to the corresponding structure.

Educational Codeforces Round 25 — Editorial

By BledDest, history, 6 years ago, translation, In English825A - Binary ProtocolLet's decode the number digit by digit starting from the leftmost. When you meet '1' in the string, increase the value of the current digit. For '0' print current digit and proceed to the next one. Don't forget to print the last digit when the string is over.

Overall complexity: O(|s|).

825B - Five-In-a-RowThis one is a pure implementation task. Just check every possible line of length 5. If the current one contains 4 crosses and 1 empty cell then the answer is 'YES'.

825C - Multi-judge SolvingObviously sorting the tasks by difficulty will always produce the most optimal order of solving. In that case ability to solve some task i will mean ability to solve any task from 1 to i - 1.

Now let's maintain the upper limit of difficulty of problem Makes is able to solve. Right after solving some problem i it will be 2·max(k, ai). Initially it's just 2·k.

Transition from i to i + 1 will then look like this. If the upper limit it greater or equal to ai + 1 then we solve this problem and update the upper limit. Otherwise we will need some problems from other judges. As our goal is to maximize the upper limit, the most optimal task to solve is the hardest possible. So you should solve task with the difficulty of upper limit and update the limit itself. Keep doing it until upper limit becomes grater or equal to ai + 1.

You will require no more then  tasks from the other judges. By algorithm it's easy to see that by solving task with difficulty d we update upper limit with the value 2·d. This function produces such a estimate.

Overall complexity: .

825D - Suitable ReplacementNotice that the order of letters doesn't matter at all, suitability depends only on amount of each letter.

Let fi be the possibility that string t will occur in s at least i times after replacing all '?' signs and after some swaps. If fi is true then fi - 1 is also true. That leads to binary search over the answer.

Let cntTj be the amount of letters j in t and cntSj — the amount of letters j in s. qcnt is the number of '?' signs.

fi is true if . If some letter appears in s less times than needed then replace some '?' signs with it.

Answer can be restored greedily by replacing '?' signs with the letters needed.

Overall complexity: , where AL is the size of the alphabet.

825E - Minimal LabelsThis problem is usually called "Topological labelling". Though it's pretty common problem, we decided that it might be educational to some of participants.

Let's set labels in descending order starting from label N to label 1. Look at first step. Vertex with label N should have out-degree equal to zero. Among all such vertices we should put the label on the one that has the largest index. Ok, but why will this produce the lexicographically smallest labelling?

We can prove this by contradiction. Let this vertex be labeled X (X < N). Change it to N and renumerate vertices with label X + 1, ..., N to labels X, ..., N - 1. Labelling will come lexicographically smaller than it was, this leads to contradiction.

So the algorithm comes as following. On step i (i = N... 1) we find vertices with out-degree equal to zero, select the one with the largest index, set its label to i and remove this vertex (and all edges connected to it) from the graph.

Current minimal out-degree can be maintained with set, for example.

Overall complexity: .

825F - String CompressionLet dp[i] be the answer for the prefix of s consisting of i first characters.

How can we update dp[j] from dp[i] (i < j)? Suppose that we try to represent the substring from index i to index j - 1 (0-indexed) by writing it as some other string k times. Then this string has to be the smallest period of the substring, and , where T is the length of the smallest period.

The smallest period of some string t can be calculated as follows: compute prefix-function for t, and if |t| is divisible by |t| - plast (plast is the last value of prefix-function), then the length of the smallest period is |t| - plast (if not, then the length of the smallest period is |t|).

This allows us to write a solution with complexity O(|s|3). To improve it to O(|s|2), we can use the fact that when we compute prefix-function for some string, we compute it for every prefix of this string. So to obtain all values of plast we need in our solution, we only need to compute prefix-functions for every suffix of s.

825G - Tree QueriesAfter the first query make the vertex that we painted black the root of the tree and for each other vertex calculate the minimum index on the path to the root. This can be done by simple DFS.

Then suppose we are painting some vertex x black. In can easily proved that for every vertex y and every vertex z that is on a path form x to the root there exists a path from y to some black vertex coming through z. So we have to store the minimum index among all vertices z such that z belongs to the path from the root to some black vertex (it is a global value, let's call it globalMin), and the answer to every query of type 2 is just the minimum of the value we calculated in DFS and globalMin. To update globalMin quickly after painting vertex x black, we ascend from x to the root until we arrive to some node that was visited during previous queries (and we stop there because this node and all nodes on the path from it to the root were used to update globalMin in previous queries).

This solution works in O(n) time.

Educational Codeforces Round 24 — Editorial

By BledDest, history, 6 years ago, translation, In English818A - Diplomas and CertificatesLet a be the number of students with diplomas and b — students with certificates. b is always a·k. So the total number of winners is a + a·k = a·(k + 1). It should not exceed , so the maximum value for a will be hit in (n div 2) div (k + 1), where a div b is .

Overall complexity: O(1).

818B - Permutation GameLet's show by construction that there can be no ambiguity in values of aj of the children who were leaders at least once (except for probably the last leader).

If li + 1 > li then on this step the value of al[i] taken was exactly li + 1 - li. Otherwise li + al[i] went over n and in circle ended up to the left or in the same position. So for this case al[i] should be (n - li) + li + 1. Obviously counting cannot go over n two or more times as this will result in al[i] > n.

We only need to check if all the numbers are unique and fill the unvisited children with remaining values to form the permutation.

Overall complexity: O(n).

818C - Sofa ThiefCoordinates don't exceed 105 so it's possible to use sweep line method to solve the problem.

Let's calculate cnt value separately for each side. I will show the algorithm for left side and all the others will be done similarly.

Let cnt_left[i] be the number of sofas which has smaller of their x coordinates less than or equal to i. To count that let's firstly increment by one cnt_left[min(x1i, x2i)] for all sofas and then proceed from left to right and do cnt_left[i] = cnt_left[i] + cnt_left[i - 1].

Now cnt_left[max(x1i, x2i) - 1] will represent number of sofas to the left of the current one but the sofa itself can also be counted. You need to decrement the result by one if x1i ≠ x2i.

The same is for top value but with y coordinates insted of x.

For the right and bottom values you should calculate cnt_right[max(x1i, x2i)] and cnt_bottom[max(y1i, y2i)]. Then take cnt_right[min(x1i, x2i) + 1] and cnt_bottom[min(y1i, y2i) + 1].

The only thing left is to compare values of each sofa with given ones and find the suitable sofa.

Overall complexity: O(n).

818D - Multicolored CarsLet's maintain the current availability of colors and the amounts of cars of each color.

Firstly color A is never available.

When car of some color C (C ≠ A) goes, you check if the number of cars of color C past before this one isn't smaller than the number of cars of color A. Only after that increment the amount by one. If it was less then set its availability to false.

If car of color A goes then simply increment its amount.

In the end iterate over all colors and check if it's both available and has higher or equal amount than the amount of cars of color A.

Okay, why this works? As all the amounts cannot decrease, color C will become not available at some moment when car of color A goes. And this will be encountered either when the new car of color C goes, or in the end of the sequence. Amount of cars of color C doesn't update between this periods. And if there was point when there became more cars of color A than of color C then this inequality will hold until the next moment we will check.

Overall complexity: O(n).

818E - Card Game AgainLet's use two pointers.

Firstly you need to learn to factorize any number in no more than . We don't actually need any of their prime divisors except for those that are presented in k. So let's factorize k in . After that check for the maximum power of each useful prime will work in  for each number.

Now notice that if some segment [l, r] has its product divisible by k then all segments [l, i] for (r ≤ i ≤ n) will also have products divisible by k.

Now we have to find the smallest r for each l out there. That's where two pointers kick in. Let's maintain the current product of the segment in factorized form (only useful primes), as in normal form its enormous. The power of some prime in this form is the sum of powers of this prime in all the numbers in the segment.

We firstly move the left border of the segment one step to the right and then keep moving the right border to the right until power of at least one prime number in the product is smaller than in k. It means that it is not divisible by k. Moving the left border means subtracting all the powers of useful primes of number al from the product and moving the right border is adding all the powers of useful primes of ar.

The first time we reach such a segment, we add (n - r) to answer (consider r 0-indexed).

Overall complexity: , where MAXN is up to 109.

818F - Level GenerationThe best way to build a graph is to make a 2-edge-connected component with k vertices and connect each of the remaining n - k vertices to it with a single edge. Then we will have n - k bridges outside the component and  edges in the component. So the answer for some fixed k and n is ; let's denote is at f(k).

Now since  is increasing, and n - k is decreasing, there exists some k0 such that if k ≤ k0, then , and if k > k0, then .

Then f(k) is strictly increasing on the segment [1, k0], and strictly decreasing on the segment [k0 + 1, n]; and this proves that we can use ternary search to find its maximum.

818G - Four MelodiesLet's build a directed graph where vertices represent notes and a directed edge comes from vertex i to vertex j iff i < j and ai and aj can be consecutive notes in a melody. Now we have to find four longest vertex-disjoint paths in this graph.

This problem can be solved with mincost k-flow algorithms. We build a network where each vertex of the graph is split into two (let's denote the vertices that we obtain when we are splitting some vertex i as vi, 1 and vi, 2). Then each directed edge  transforms into a directed edge from vertex vi, 2 to vertex vj, 1 in the network, the capacity of this edge is 1, and the cost is 0. Also we add directed edges from the source to every vertex vi, 1 and from every vertex vi, 2 to the sink (they have the same characteristics: capacity is 1, cost is 0). And for each i we add a directed edge between vi, 1 and vi, 2; these edges actually represent that we are using some note in a melody, so their capacities are also equal to 1, and their costs are  - 1. The answer to the problem is equal to the absolute value of minimum cost of 4-flow in this network.

The bad thing is that the network is really large. So we have to use some advanced mincost algorithm here.

Model solution uses Dijkstra's algorithm with Johnson's potentials to find augmenting paths of minimum cost. We set a number p(v) for each vertex v of the network (these numbers are called potentials). Then we modify costs of the edges: if some edge  had cost ci, j, now it's cost is {c'}i, j = ci, j + p(i) - p(j). It's easy to prove that if some path from vertex v to vertex u was the shortest one between these vertices without modifying the costs with potentinals, then after modifying it will also be the shortest between these vertices. So instead of looking for an augmenting path in the original network we can try looking for it in a network with modified edges. Why? Because it is always possible to set all potentials in such a way that all costs of edges will be non-negative (and we will be able to use Dijkstra to find the shortest path from the source to the sink).

Before looking for the first augmenting path, we calculate potentials recursively: p(source) = 0, p(v) = min{p(u) + cu, v} (we check all u's such that there is an edge  in the network). The network is acyclic before we push flow, so there is always a way to calculate these potentials with dynamic programming. Then each time we want to find an augmenting path, we run Dijkstra's algoritm on modified network, push flow through the path we found and modify the potentials: new potential of each vertex v becomes p'(v) = p(v) + d(v), where d(v) is the distance between the source and vertex v in the modified network (and we found this distance with Dijkstra). When we have found four augmenting paths, we are done and it's time to evaluate the cost of the flow.

Educational Codeforces Round 23 — Editorial

By BledDest, history, 6 years ago, translation, In EnglishWe are really sorry for the issue with the testing system. We hope that it won't happen during next contests.

817A - Treasure HuntFirstly, let's approach this problem as if the steps were  and . Then the answer is "YES" if |x1 - x2| mod x = 0 and |y1 - y2| mod y = 0.

It's easy to see that if the answer to this problem is "NO" then the answer to the original one is also "NO".

Let's return to the original problem and take a look at some sequence of steps. It ends in some point (xe, ye). Define cntx as  and cnty as . The parity of cntx is the same as the parity of cnty. It is like this because every type of move changes parity of both cntx and cnty.

So the answer is "YES" if |x1 - x2| mod x = 0, |y1 - y2| mod y = 0 and  mod  mod 2.

Overall complexity: O(1).

817B - Makes And The ProductMinimal product is obtained by multiplying three smallest elements of the array.

Let's iterate over the middle element of these three and calc sum of all options.

Firstly let's precalc two arrays of pairs — mnl and mnr. mnl[x] is minimum and number of its occurrences on the prefix of array a up to index x inclusive. mnr[x] is minimum and number of its occurrences on the suffix of array a up to index x inclusive. It can be done with two traversals over the array.

Let's also store set of three elements which give minimal product of the array.

Consider every index j from 1 to n - 2 inclusive (0-indexed). If set (a[j],  mnl[j - 1].first,  mnr[j + 1].first) is equal to the stored set of three minimums then add to the answer number of ways to choose pair (i,  k), that is mnl[j - 1].second · mnr[j + 1].second.

Overall complexity: O(n).

817C - Really Big NumbersLet's prove that if x is really big, then x + 1 is really big too.

Since the sum of digits of x + 1 (let's call it sumd(x + 1)) is not greater than sumd(x) + 1, then x + 1 - sumd(x + 1) ≥ x - sumd(x), and if x - sumd(x) ≥ s, then x + 1 - sumd(x + 1) ≥ s. So if x is really big, then x + 1 is really big.

This observation allows us to use binary search to find the minimum really big number (let's call it y). And if y ≤ n, then all numbers in the segment [y, n] are really big and not greater than n, so the quantity of these numbers is the answer to the problem.

817D - Imbalanced ArrayFirst of all, we will calculate the sum of maximum and minimum values on all segments separatedly. Then the answer is the difference between the sum of maximum values and minimum values.

How can we calculate the sum of minimum values, for example? For each element we will try to find the number of segments where it is the leftmost minimum element. So, we will calculate two arrays left (left[i] = j means that j is the maximum index such that ai ≥ aj and j < i) and right (right[i] = j means that j is the minimum index such that ai > aj and j > i). So actually, left[i] and right[i] represent the borders of the largest segment where ai is the leftmost minimum element (and we need to exclude those borders). While knowing these values, we can calculate the number of subsegments where ai is the leftmost minimum element.

How can we calculate, for example, the array left? We will use a stack where we will store some indices in the array a in such a way that, if we change all indices to the values in the array a, they will be in sorted order (the maximum element will be at the top of the stack, and the minimum — at the bottom). Let's calculate left from the minimum index to the maximum. When we calculate left[i], we remove all elements j such that aj > ai from the stack (since the stack is "sorted", all these elements will be at the top of the stack, and when we encounter the first element j such that aj ≤ ai, it is guaranteed that all elements below it don't need to be deleted). Then, if there's any element on top of the stack, it becomes the value of left[i], then we push i into the stack. Since every element will be added (and deleted) not more than one time, the complexity of this algorithm is linear.

We can apply the same technique to calculate the values of right and the sum of maximums.

817E - Choosing The CommanderLet's use binary trie to store all personalities of warriors (that is, just use the trie data structure on binary representations of all pi). For each subtree of this trie you have to maintain the number of pi's currently present in this subtree — when inserting a value of pi, we increase the sizes of subtrees on the path from the node with pi to the root by 1, and when removing pi, we decrease the sizes of subtrees on this path by 1.

How can it help us with answering the events of third type? We will descend the trie. When descending, we will try to find the number  in the structure. When we go to some subtree, we determine whether we add the quantity of numbers in the subtree we are not going into by checking if the current bit in li is equal to 1 (if so, then for all numbers from this subtree their bitwise xor with the current commander's personality is less than li). The answer to the event is the sum of sizes of all subtrees we "added" while descending into the trie.

817F - MEX QueriesThere are many ways to solve this problem, you can use cartesian tree, segment tree, sqrt decomposition, maybe something else. I personally see the solution with the segment tree the easiest one so let me describe it.

Firstly, let's notice that the queries are offline. So we can compress the numbers by taking L and R + 1 of each query. MEX will be either one of these numbers or 1. So now we have numbers up to 2·105 and pretty basic task on segment tree.

The first two types of queries are translated to "assign value 1 or 0 on a segment" (set the number on some position is either present or not). The third is "for each i in segment [l, r] assign xi to " (this will inverse the segment as described in statement).

Segment tree should keep sum of the segment in its nodes. XOR on segment will turn val into len - val, len is the length of the segment being covered by the node.

The leftmost zero cell is MEX.

While standing in some node v, check if its left son is full (has 1 in every cell of the segment, like t[v * 2] = mid - left if you use 1-indexed tree and intervals for it). If it is full then go down to the right son, otherwise there exists some zero cell in a segment of the left child and you should go down to it.

You should use lazy propagation to guarantee  per query.

Overall complexity: .

Educational Codeforces Round 22 — Editorial

By BledDest, history, 6 years ago, In English813A - The ContestNotice that we can keep solved tasks and then submit all at once. So the solution goes down to this: you should find the first moment of time t that the site works at that moment and . Also it's convinient that the intervals are already sorted in increasing order.

Let's sum up all elements of array a and write it to some variable sum. The answer is obtained this way: if the sum lies in the current interval then the answer is the sum. Otherwise there are two cases. If there exists some interval j that lj ≥ sum then the answer is lj. In other case the answer is "-1".

813B - The Golden AgeNotice that xa for x ≥ 2 has no more than 60 powers which give numbers no greater than 1018.

So let's store all possible sums of all powers of x and y. Now the answer to the query can be obtained in linear time by checking difference between neighbouring unlucky years in sorted order.

Don't forget that you should handle multiplying of such big numbers very carefully. For example, instead of writing

while (num <= 1e18)    num = num * xor

while (num * x <= 1e18)    num = num * xyou should write

while (num <= 1e18 / x)    num = num * xto avoid getting overflow errors of 64-bit type.

Integer division will work fine in that case because num·x will never exceed 1018 if num doesn't exceed .

Overall complexity: .

813C - The Tag GameIf you check some games then you will notice that the most optimal strategy for Bob is always like this:

Climb up for some steps (possibly zero)Go to the lowest vertex from itStay in this vertex till the endThus let's precalc the depth (the distance from the root) of the lowest vertex of each subtree (using dfs), distance from Alice's starting node and from Bob's starting node to the vertex (again dfs/bfs).

Now iterate over all vertices and check if Bob can reach this vertex earlier than Alice. If he can then update the answer with the lowest vertex that can be reached from this one.

The answer is doubled depth of the obtained lowest reachable vertex. That is the time which will take Alice to get there.

Overall complexity: O(n).

813D - Two MelodiesLet's solve this problem with dynamic programming.

Let dp[x][y] be the maximum answer if one melody finishes in note number x and another melody — in note number y. x and y are 1-indexed; if one of them is 0, then the melody is empty.

How shall we update dp[x][y]? First of all, we will update from previous dp values only if x > y. If x = y, then obviously answer is 0, and if x < y, then we take the answer for dp[y][x].

Secondly, to avoid intersections, we will update dp[x][y] only using values of dp[i][y], where i ≠ y and i < x. Why? Because if we update dp[x][y] from some dp[x][i], and x > y, then it can lead to some intersection (we can't guarantee we didn't use i in the first melody).

How can we make fast updates? We will count dp from y = 0 to y = n. Then, while counting dp for some specific y, we will maintain two arrays:

maxmod[j] — the maximum value of dp[i][y] encountered so far where a[i] mod 7 = j;maxnum[j] — the maximum value of dp[i][y] encountered so far where a[i] = j.So when we need to count dp[x][y], it will be the maximum of four values:

maxmod[a[x] mod 7] + 1 — if we add a note which is congruent modulo 7 with the last one;maxnum[a[x] + 1] + 1 — if we add a note which is less by 1 than the last note;maxnum[a[x] - 1] + 1 — if we add a note which is greater by 1 than the last note;dp[0][y] + 1 — if we just start a melody.These values can be calculated in O(n2).

813E - Army CreationEvery time we process a plan, let's count only the first k warriors of some type.

When will the warrior on position i be counted? Of course, he has to be present in the plan, so l ≤ i ≤ r. But also he has to be among k first warriors of his type in this plan.

Let's denote a function prev(x, y):

prev(x, 1) is the position of previous warrior of the same type before warrior x (that is, the greatest i such that i < x and ai = ax). If there's no any, then prev(x, 1) =  - 1;prev(x, y) = prev(prev(x, 1), y - 1)) if y > 1.It is easy to prove that the warrior x will be among k first warriors in some plan iff l > prev(x, k) and x ≤ r.

So we can make a new array b: bi = prev(i, k). Then we build a segment tree on this array. The node of the segment tree will store all values of bi from the segment corresponding to this node (in sorted order). Then to get answer to the plan, we have to count the number of elements on segment [l, r] that are less than l.

Complexity is , or  if you use fractional cascading technique.

813F - Bipartite CheckingIf the edges were only added and not deleted, it would be a common problem that is solved with disjoint set union. All you need to do in that problem is implement a DSU which maintains not only the leader in the class of some vertex, but also the distance to this leader. Then, if we try to connect two vertices that have the same leader in DSU and the sum of distances to this leader is even, then we get a cycle with odd length, and graph is no longer bipartite.

But in this problem we need to somehow process removing edges from the graph.

In the algorithm I will describe below we will need to somehow remove the last added edge from DSU (or even some number of last added edges). How can we process that? Each time we change some variable in DSU, we can store an address of this variable and its previous value somewhere (for example, in a stack). Then to remove last added edge, we rollback these changes — we rewrite the previous values of the variables we changed by adding the last edge.

Now we can add a new edge and remove last added edge. All these operations cost (O(logn)) because we won't use path compression in DSU — path compression doesn't work in intended time if we have to rollback. Let's actually start solving the problem.

For convinience, we change all information to queries like "edge (x, y) exists from query number l till query number r". It's obvious that there are no more than q such queries. Let's use divide-and-conquer technique to make a function that answers whether the graph is bipartite or not after every query from some segment of queries [a, b]. First of all, we add to DSU all the edges that are present in the whole segment (and not added yet); then we solve it recursively for  and ; then we remove edges from DSU using the rollback technique described above. When we arrive to some segment [a, a], then after adding the edges present in this segment we can answer if the graph is bipartite after query a. Remember to get rid of the edges that are already added and the edges that are not present at all in the segment when you make a recursive call. Of course, to solve the whole problem, we need to call our function from segment [1, q].

Time complexity is , because every edge will be added only in  calls of the function.

Educational Codeforces Round 21 — Editorial

By BledDest, history, 6 years ago, In English808A - Lucky YearNotice that the next lucky year always looks like (first digit of the current + 1) · 10^(number of digits of the current - 1). It holds also for numbers starting with 9, it will be 10 · 10^(number of digits - 1). The answer is the difference between the next lucky year and current year.

808B - Average Sleep TimeTo get the sum for i-th week you need to take sum of (i - 1)-th week, subtract first element of (i - 1)-th week from it and add up last element of i-th week. All common elements will remain.

Thus by moving right week by week calculate sum of all weeks and divide it by n - k + 1.

Overall complexity: O(n).

808C - Tea PartyAt first, let's pour minimal amount of tea in each cup, that is . If it requires more tea than available then it's -1.

Now let's sort cups in non-increasing order by volume and start filling up them until we run out of tea in the teapot.

It's easy to see that everyone will be satisfied that way. If sequence of ai is non-increasing then sequence of  is also non-increasing. So we can't make someone unsatisfied by filling the cup with maximal possible volume.

And finally get the right order of cups back and print the answer.

Overall complexity: .

808D - Array DivisionSuppose we want to move an element from the prefix to the suffix (if we need to move an element from the suffix to the prefix, we can just reverse the array and do the same thing).

Suppose the resulting prefix will contain m elements. Then we need to check that the prefix with m + 1 elements contains an element such that the sum of this prefix without this element is equal to the half of the sum of the whole array (and then we can move this element to the suffix).

To check all the prefixes, we can scan the array from left to right while maintaining the set of elements on the prefix and the sum of these elements.

808E - Selling SouvenirsThere are lots of different solutions for this problem.

We can iterate on the number of 3-elements we will take (in this editorial k-element is a souvenir with weight k). When fixing the number of 3-elements (let it be x), we want to know the best possible answer for the weight m - 3x, while taking into account only 1-elements and 2-elements.

To answer these queries, we can precalculate the values dp[w] — triples (cost, cnt1, cnt2), where cost is the best possible answer for the weight w, and cnt1 and cnt2 is the number of 1-elements and 2-elements we are taking to get this answer. Of course, dp[0] = (0, 0, 0), and we can update dp[i + 1] and dp[i + 2] using value of dp[i]. After precalculating dp[w] for each possible w we can iterate on the number of 3-elements.

There are also several binary/ternary search solutions.

808F - Card GameThe most tricky part of the problem is how to check if some set of cards allows us to build a deck with the required power (not taking the levels of cards into account).

Suppose we have not more than one card with magic number 1 (if there are multiple cards with this magic number, then we obviously can use only one of these). Then two cards may conflict only if one of them has an odd magic number, and another has an even magic number — otherwise their sum is even and not less than 4, so it's not a prime number.

This allows us to solve this problem as follows:

Construct a bipartite graph: each vertex represents a card, and two vertices are connected by an edge if the corresponding pair of cards can't be put in a deck. Then we have to find the maximum weight of independent set in this graph. This can be solved using maximum flow algorithm: construct a network where source is connected with every "odd" vertex (a vertex that represents a card with an odd magic number) by an edge with capacity equal to the power of this card; then connect every "odd" vertex to all "even" vertices that are conflicting with this vertex by edges with infinite capacities; and then connect every "even" vertex to the sink by an edge with capacity equal to the power of the card (all edges have to be directed). Then the maximum power of the deck is equal to sum - mincut, where sum is the sum of all powers and mincut is the minimum cut value between the source and the sink (which is equal to the maximum flow).

This allows us to check if we can build a deck of required power using only some set of cards (for example, only cards with level less than or equal to some x).

808G - Anthem of BerlandLet's denote the string obtained by concatenation t + # + s (where # is some dividing character that isn't a part of the alphabet) as ts. Recall that KMP algorithm builds the prefix function for this string.

We can calculate dp[i][j] on this string, where i is the position in this string and j is the value of prefix function in this position. The value of dp[i][j] is the maximum number of occurences of t found so far (or  - 1 if this situation is impossible). If (i + 1)th character is a Latin letter, then we just recalculate prefix function for this position (the fact that in KMP the value of prefix function won't exceed |t| allows us to do so). If (i + 1)th character is a question mark, then we check all 26 possible characters and recalculate prefix function for all of these characters (and update the corresponding dp values). The size of s and t is pretty big, so we need to recalculate these values in O(1) time; this can be done by precalculating the values of next[i][j] (i is the value of prefix function, j is a new character and next[i][j] is the value of prefix function after adding this character).

Educational Codeforces Round 20 Editorial

By awoo, history, 6 years ago, translation, In English803A - Maximal Binary MatrixLet's construct matrix from top to bottom, from left to right. At current step we consider position (i, j). Look at contents of cells a[i][j] and a[j][i]. If number of zeroes in them doesn't exceed k, then let's fill those cells with ones and decrease k by this number.

If k isn't equal to 0 in the end of algorithm, then there is no answer.

Overall complexity: O(n2).

803B - Distances to ZeroLet's divide the solution into two parts: firstly check the closest zero to the left and then the closest zero to the right. After that we can take minimum of these numbers.

Initialize distance with infinity. Iterate over array from left to right. If value in current position is 0 then set distance to 0, otherwise increase distance by 1. On each step write value of distance to the answer array.

Do the same thing but going from right to left. This will find closest zero to the right. Now you should write minimum of current value of distance and value that's already in answer array.

Finally you should retrieve the answer from distances.

Overall complexity: O(n).

803C - Maximal GCDNotice that GCD of the resulting sequence is always a divisor of n. Now let's iterate over all divisors up to .

Current divisor is d. One of the ways to retrieve resulting sequence is to take d, 2d, 3d, ..., (k - 1)·d, their sum is s. The last number is n - s. You should check if n - s > (k - 1)·d.

s is the sum of arithmetic progression, its equal to .

Don't forget that you should consider d and , if you check divisors up to .

Take maximum of possible divisors or output -1 if there were no such divisors.

Overall complexity: .

803D - Magazine AdFirstly notice that there is no difference between space and hyphen, you can replace them with the same character, if you want.

Let's run binary search on answer. Fix width and greedily construct ad — wrap word only if you don't option to continue on the same line. Then check if number of lines doesn't exceed k.

Overall complexity: .

803E - Roma and PokerThis problem can be solved using dynamic programming: dpi, j is true if Roma could play first i games with balance j. dp0, 0 is true; and for each dpi, j such that 0 ≤ i < n and  - k < j < k we update dpi + 1, j + 1 if si = W, dpi + 1, j if si = D, dpi + 1, j - 1 if si = L, and all three states if si =  ?. If either of dpn, k and dpn,  - k is true, then we can restore the sequence.

Time and memory complexity is O(n·k).

As an exercise, you can think about linear solution.

803F - Coprime SubsequencesThis problem can be solved using inclusion-exclusion.

Let f(x) be the number of subsequences such that all elements of the subsequence are divisible by x. We can calculate cnt(x), which is the number of elements divisible by x, by factorizing all elements of the sequence and generating their divisors, and f(x) = 2cnt(x) - 1.

Then we can apply the inclusion-exclusion principle and get the resulting formula: , where μ is the Möbius function.

803G - Periodic RMQ ProblemMost of the solutions used the fact that we can read all the queries, compress them and process after the compression using simple segment tree. But there is also an online solution:

Let's build a sparse table on array b to answer queries on segments that are not modified in O(1). To process modification segments, we will use implicit segment tree and lazy propagation technique. We do not build the whole segment tree; instead, in the beginning we have only one node for segment [1, n·k], and if some modification query accesses some node, but does not modify the complete segment this node maintains, only then we create the children of this node. So, the leaves of the segment tree are the nodes such that their segments are completely set to some value or not modified at all. Since each modification query affects only O(log(n·k)) nodes, the resulting complexity will be O(qlog(n·k) + nlogn).

Educational Codeforces Round 19 Editorial

By awoo, history, 6 years ago, translation, In English797A - k-FactorizationThere are many approaches to this problem. You can, for example, factorize n, store all multipliers in a list, and while size of this list is greater than k, take any two elements of this list and replace them with their product. If the initial size of this list is less than k, then answer is -1.

797B - Odd sumThe answer to this problem can be constructed this way:

Sum up all positive numbersFind maximum maxodd of negative odd numbersFind minimum minodd of positive odd numbersIf sum was even then subtract min(minodd,  - maxodd)Overall complexity: O(n).

797C - Minimal stringOn every step you should maintain minimal alphabetic letter in current string s (this can be done by keeping array of 26 cells with number of times each letter appear in string nd updating it on every step). Let's call string t a stack and use its terms.

Now you extract letters from s one by one. Put the letter to the top of the stack. Pop letters from the top of stack and push them to answer while they are less or equal than any letter left in string s. After string s becomes empty push all the letters from stack to answer.

The answer will be lexicographically minimal. It is obvious if we consider the case when current top of stack is strictly greater than any character from the remaining string s, or there is a character in s that is strictly less than current top. If current top is equal to some character then appending answer with the letter from top won't make answer worse.

Overall complexity: O(n * |AL|), where |AL| is the length of the alpabet, 26 in our case.

797D - Broken BSTLet's firstly consider tree with only distinct values in its nodes. Then value will be reached if and only if all the jumps to the left children on the path from the root were done from the vertices with values greater than the current one and all the jumps to the right children on the path from the root were done from the vertices with values less than the current one.

Thus let's run dfs from the root and maintain maximal transition to the left child on current path and minimal transition to the right child on current path. If the value of current node is greater than left bound and less than right bound then it will be found.

Now let's return to the original problem. Notice that transitions and comparations won't change. Store every found value in set and just calculate how many values of vertices isn't present there.

Overall complexity: O(n·log(n)).

797E - Array QueriesThere are two possible solutions in O(n2) time.

First of them answers each query using simple iteration — changes p to p + ap + k for each query until p becomes greater than n, as stated in the problem. But it is too slow.

Second solution precalculates answers for each p and k: if p + ap + k > n, then ansp, k = 1, else ansp, k = ansp + ap + k, k + 1. But this uses O(n2) memory and can be done in O(n2) time.

Now we can notice that if , then second solution will use only  time and memory, and if , then first solution will do not more than  operations on each query. So we can combine these two solutions.

Time complexity: .

797F - Mice and HolesThis problem can be solved using dynamic programming. Let dpi, j be the answer for first i holes and j mice.

If the constraints were smaller, then we could calculate it in O(n2m) just trying to update dpi, j by all values of dpi - 1, k where k ≤ j and calculating the cost to transport all mice from the segment to ith hole.

To calculate this in O(nm), we will use a deque maintaining the minimum (or a queue implemented on two stacks, for example). We iterate on i and update all the values of dpi + 1, j with the help of this deque: for each index j we insert a value in the deque equal to dpi, j - cost, where cost is the total distance required to move first j mice to hole i + 1. Updating the value is just extracting the minimum and adding this cost to it. Don't forget to delete values from the deque to ensure that we don't send too much mice to the hole.

Time complexity: O(nm).

Educational Codeforces Round 18 — Editorial

By BledDest, 6 years ago, translation, In EnglishWe want to apologize for the issue with problem C. We hope this didn't totally ruin the contest to those who got Judgement Failed on their submissions.

792A - New Bus RouteAt first let's notice that if there exists such triple ai, aj and ak that ai < aj < ak, then |ak - ai| > |aj - ai| and |ak - ai| > |ak - aj|.

Thus we can sort all numbers and check only adjacent ones. There are exactly n - 1 of such pairs. The only thing left is to find minimal distance of all pairs and count pairs with that distance.

Overall complexity: 

792B - Counting-out RhymeThe task was just about implementing algorithm described in statement.

This is one of many possible ways of doing this. Firstly you should notice that doing ai iterations in i-th step is equal to doing ai mod (n - i) iterations (0-based numbering). That is less than n.

Now fill array of length n with ones and create pointer to current leader. Then on i-th step move pointer to the right (from cell n - 1 proceed to 0) till you encounter ai mod (n - i) ones. When finished, write 0 to this cell and move pointer to next cell which contains 1.

Overall complexity: O(n2).

792C - Divide by ThreeLet's declare a function which takes number as a string and erases minimal number of digits in substring from 2-nd to last character to obtain beautiful number.

Note that if the answer for given string exists, then this function will erase no more than 2 digits. If the number is divisible by 3 then sum of its digits is also divisible by 3. So here are the only options for the function:

Sum of digits is already equal to 0 modulo 3. Thus you don't have to erase any digits.There exists such a digit that equals sum modulo 3. Then you just have to erase this digit.All of the digits are neither divisible by 3, nor equal to sum modulo 3. So two of such digits will sum up to number, which equals sum modulo 3 ((2 + 2) mod 3 = 1, (1 + 1) mod 3 = 2).Let positions of non-zero numbers be a1, a2, ..., ak. Then you can easily see that its enough to check only three function outputs: on substrings [a1..n], [a2..n] и [a3..n]. We imply that all digits to the left of the taken non-zero digit are erased. As we can erase no more than 2 digits, these options will cover all the cases.

If there exists no answer for any of substrings, than you need to check if the number contains 0 — it will be answer in that case. If there is no 0, then answer is  - 1.

Otherwise the answer is the function output of maximal length.

Overall complexity: O(n).

792D - Paths in a Complete Binary TreeIn this editorial x represents the number of vertex we are currently in.

Let k be the maximum integer number such that x is divisible by 2k (or the number of zeroes at the end of the binary representation of x). It is easy to prove that if k = 0, then x is a leaf; if k = 1, then both children of x are leaves, and so on. Even more, the difference between x and any of his children is exactly 2k - 1. So to traverse to the left child, we have to subtract 2k - 1 from x (if x is not a leaf), and to traverse to the right child, we add 2k - 1 to x.

How can we process traversions up? Let y be the number of the parent node. y has exactly k + 1 zeroes at the end of its binary representation, so to traverse from y to x, we need to either add or subtract 2k from y. And to traverse from x to y we also have to either subtract or add 2k to x. One of these operations will lead us to the number divisible by 2k + 1 and not divisible by 2k + 2, and we need to choose this operation.

Time complexity is .

792E - Colored BallsIf we want to divide all balls from some box into k sets with sizes x and x + 1 (and there are ai balls in this box), then either  or . So the solution will be like that:

Iterate over the possible sizes of sets x (from 1 to , or to some constant — in our solution it's 40000) and check if we can divide all balls into sets with sizes x and x + 1,Then iterate over the number of sets k, calculate the sizes of sets if we want to divide the first box exactly into k sets and try to divide balls from all other boxes into sets of these sizes.If we want to divide ai balls from the same box into k sets, then the sizes will be  and ; but if , then we also have to check if sizes can be  and .

If we fix sizes x and x + 1 and we want to check whether we can divide a box with ai balls into sets with these sizes (and to get the minimum possible number of such sets), then the best option will be to take  sets. If , then such division is possible. If not, then it's impossible to divide ai balls into sets of x and x + 1 balls.

Time complexity of this solution is .

792F - Mages and MonstersLet's represent spells as points on cartesian plane. If we consider three spells A, B and C such that Ax ≤ Bx ≤ Cx and B is above AC on the cartesian plane or belongs to it, then we don't need to use spell B because we can replace it with a linear combination of spells A and C without any additional mana cost.

We can maintain the lower boundary of the convex hull of all points from 1-type queries and the point (0, 0). Then to process 2-type query we have to find the intersection of aforementioned lower boundary and the line  (our average damage in this fight has to be at least this value). If there is no intersection, then the answer is NO because even with infinite mana Vova's character can't deal that much damage before dying. If there is an intersection, we have to check that it is not higher than the line  to ensure that we have enough mana to kill the monster in given time. Model solution uses only integral calculations, but it seems that long double precision is enough.

Time complexity: O(q·log q).

Educational Codeforces Round 17 Editorial

By HellKitsune, history, 6 years ago, translation, In EnglishTask AIf you find all the small divisors of n that are less than sqrt(n), you can find the rest of them dividing n by the small ones.

By the way, this problem is widely known and googlable :) You can, for example, check out this link: http://stackoverflow.com/questions/26753839/efficiently-getting-all-divisors-of-a-given-number

Task BTry coming up either with greedy algorithm or with two pointers algorithm.

SpoilerTask CTry thinking not about erasing a substring from B, but rather picking some number of characters (possibly zero) from the left, and some from the right.

SpoilerTask DThe toughest thing about this task, is that you can go to the left. Try to come up with something to handle that.

SpoilerTask ETry to come up with a solution where you iterate over each frequency

SpoilerTask FNo nested spoilers. It's serious business here!

One of the possible ways to make your life easier is to count the number of automorphisms of tree T. This way you will be able to first calculate the number of labeled matchings of vertices of tree T to the vertices of tree S, and then divide this number by the number of automorphisms.

Although solution that I will describe does not use this! :D

First, remember that every automorphism has a fixed point. Either a vertex or an edge. This is called center of the tree, and you can find it by first finding the diameter of the tree. It's middle vertex (or an edge, if there are two middle vertices) is the center of the tree.

Let's root T at it's center. Now let's enumerate subtrees (rooted ones!) of T in such a way that if two subtress are isomorphic they will receive the same number and vice versa. You can do it in a single dfs processing subtrees bottom-up. These numbers will correspond to different isomorphisms.

Now you can do a dp with memoization to calculate for each subtree of S rooted at some directed edge the number of ways to "attach" each of the isomorphisms from above to this subtree. This can be done by going through all immediate children of the currently processed vertex of S and doing a bitmask DP, where bits are immediate children of the root of currently processed isomophism of T. 1 means it is "attached" to some children in S, 0 means not.

One of the problems here is that root of current isomorphism of T can have isomorphic children, and if we shuffle how they are attached to children in S we will still receive the same way to cover S with T, so we will calculate some ways twice or more. The solution is to sort children by their isomorphism number and when processing a bitmask, never put 1 to the bit that has a 0 bit to the left that corresponds to the child with the same isomorphism number. This way you will match such children in a fixed order and won't calculate anything unnecessary.

Editorial of Educational Codeforces Round 16

By Edvard, history, 6 years ago, translation, In English710A - King MovesEasy to see that there are only three cases in this problem. If the king is in the corner of the board the answer is 3. If the king is on the border of the board but not in a corner then the answer is 5. Otherwise the answer is 8.

С++ solutionComplexity: O(1).

710B - Optimal Point on a LineThe function of the total distance is monotonic between any pair of adjacent points from the input, so the answer is always in some of the given points. We can use that observation to solve the problem by calculating the total distance for each point from the input and finding the optimal point.

The other solution uses the observation that the answer is always is the middle point (by index) in the sorted list of the given points. The last fact is also can be easily proven.

C++ solutionComplexity: O(nlogn).

710C - Magic Odd SquareThe problem was suggested by Resul Hangeldiyev Resul.

The solution can be got from the second sample testcase. Easy to see that if we place all odd numbers in the center in form of rhombus we will get a magic square.

C++ solutionComplexity: O(n2).

710D - Two Arithmetic ProgressionsI wanted to give this problem a lot of time ago. I thought it is very standard problem, but I underestimated its difficulty.

Let's write down the equation describing the problem: a1k + b1 = a2l + b2 → a1k - a2l = b2 - b1. So we have linear Diofant equation with two variables: Ax + By = C, A = a1, B =  - a2, C = b2 - b1. The solution has the form: , where the last equation can be solved by extended Euclid algorithm and p is any integral number. The variable p should satisfy two conditions:  and . The values A and B are fixed, so we can get the segment of possible values for the values p. The length of the segment is the answer for the problem.

C++ solutionComplexity: O(log(max(a1, a2))).

710E - Generate a StringThe problem was suggested by Zi Song Yeoh zscoder.

This problem has a simple solution described by participants in the comments.

My solution is a little harder. Let's solve it using dynamic programming. Let zn be the smallest amount of time needed to get n letters 'a'. Let's consider transitions: the transition for adding one letter 'a' can be simply done. Let's process transitions for multiplying by two and subtraction by one simultaneously: let's decrease the number 2·i i times by one right after getting it. Easy to see that such updates never include each other, so we can store them in queue by adding the new update at the tail of the queue and taking the best update from the head.

The solution is hard to describe, but it is very simple in the code, so please check it to understand the idea :-)

C++ solutionComplexity: O(n).

710F - String Set QueriesThe problem was suggested by Alexandr Kulkov adamant.

Let's get rid of the queries for deleting a string. There are no strings that will be added two times, so we can calculate the answer for the added (but not deleted strings) and for the deleted separately and subtract the second from the first to get the answer. So we can consider that there are no queries of deletion.

Now let's use Aho-Corasik algorithm. The only difficulty is that the strings are adding in online mode, but Aho-Corasik algorithm works only after adding all the strings. Note that the answer for the given set of strings equal to the answer for any part of the set plus the answer for the remaining part. Let's use the trick with converting the static data structure (Aho-Corasik in this case) to the dynamic one.

For the set of n strings let's maintain a set of no more than logn sets of the strings with sizes of different powers of two. After adding new string we should move the sets from the lowest powers of two to the largest until we got an invariant set of sets.

Easy to see that each string will be moved no more than logm times, so we can process each query in O(logn) time.

C++ solutionComplexity: O((slen + m)logm), where slen is the total length of the string from the input.

Educational Codeforces Round 15 Editorial

By fcspartakm, history, 7 years ago, translation, In English702A - Maximum IncreaseLet's iterate through the given array from the left to the right and store in the variable cur the length of the current increasing subarray. If the current element is more than the previous we need to increase cur on one. In the other case we need to update the answer with the value of cur and put in cur 1, because new increasing subarray began.

702B - Powers of TwoTo solve this problem we need to use map cnt and store in this map how many times every integer appears in the given array.

Then we need to iterate through all given numbers with variable i. Let the current number is equal to ai. For this number we need to iterate on all possible powers of 2 (the number of these powers is no more than 31). Let the current power is equal to cur. Then we need to make cnt[ai] –  and add the value cnt[ai - cur] to the asnwer.

702C - Cellular NetworkAt first store coordinates of all towers in set towers.

Then let's look through all cities. Let the current city be located in the point cur. Let it = towers.lowerbound(cur). Then if it is not equal to the end of the set we put in the variable dist the value ( * it - cur) — the distance to the nearest tower on the right for the current city. If it is not equal to the beginning of the set we need to make it –  and update dist = min(dist, cur -  * it) — the distance to the nearest tower on the left to the current city. After that we only need to update the answer: ans = max(ans, dist).

Also this problem can be solved with help of two pointers in linear time.

702D - Road to Post OfficeTo solve this problem we need to analyze some cases.

If d ≤ k then Vasiliy can ride car all road without breaking, so the answer is d * a.

If t + k * a > k * b (i. e. it is better to do not repair the car), Vasiliy must ride car the first k kilometers and then walks on foot, so the answer is k * a + (d - k) * b.

The only case left when it is better to ride car through all road until d % k kilometers left. Now we need to understand what better — repair the car and ride or do not repair the car and walk on foot. Let cnt = d / k, so Vasiliy necessarily must repair the car cnt - 1 times. Then the answer equals to k * cnt * a + (cnt - 1) * t + min(t + (d % k) * a, (d % k) * b).

702E - Analysis of Pathes in Functional GraphThis problem can be solved with help of the binary exponentiation.

Let the fr[u] is a structure, which for the vertex u store the information about the path from this vertex with length equals to r. The information which we need:

fr[u].to — the number of vertex, in which ends the path with length r from the vertex u,fr[u].len — the sum of the arcs weights on the path with length r from the vertex u,fr[u].min — the minimal weight of the arc on the path with length r from the vertex u.So if we have this values for all vertices and two fixed values r: r = r1 and r = r2 it is easy to find the values fr1 + r2[u] for all u:

fr1 + r2[u].to = fr2[fr1[u].to].to, i. e. at first we went to the vertex fr1[u].to, and then with help of the array fr2 we can undrstand where we will stand in the end of the path;fr1 + r2[u].len = fr1[u].len + fr2[fr1[u].to].len;fr1 + r2[u].min = min(fr1[u].min, fr2[fr1[u].to].min).The structures for the values r = r1 and r = r2 are and arrays of the structures, indexed with numbers of the graph vertices. So we showed that if we have two arrays for r = r1 and r = r2 we can get the array for r = r1 + r2. The operation which we described above we can call the multiply of the arrays, then the needed values fk can be found with help of raised values f1 to the power k. For make it we can use the binary exponentiation.

Also this problem can be solved with help of "binary shifts", but in fact it is the same thing that we described above.

702F - T-ShirtsTutorial is not available

Soon...

Editorial of Educational Codeforces Round 14

By Edvard, history, 7 years ago, translation, In English691A - Fashion in BerlandThe problem was suggested and prepared by Arthur Jaworski KingArthur.

In this problem you should simply check the conditions from the problem statement.

С++ solutionComplexity: O(n).

691B - s-palindromeThe problem was suggested by Nikita Melnikov nickmeller.

In this problem you should simply find the symmetric letters by picture and also observe that the pairs (b, d) and (p, q) is the symmteric reflections.

C++ solutionComplexity: O(n).

691C - Exponential notationThe problem was suggsted by user blowUpTheStonySilence.

This is an implementation problem. You should do exactly what is written in the problem statement. On my mind the simplest way is to find the position of the first not zero digit and the position of the dot. The difference between that positions is the value of b (if the value is positive you should also decrease it by one).

C++ solutionComplexity: O(n).

691D - Swaps in PermutationThe problem was suggested by Zi Song Yeoh zscoder.

Consider a graph with n vertices whose edges is the pairs from the input. It's possible to swap any two values with the positions in some connected component in that graph. So we can sort the values from any component in decreasing order. Easy to see that after sorting the values of each component we will get the lexicographically maximal permutation.

C++ solutionComplexity: O(n + m).

691E - Xor-sequencesThe problem was suggested by Zi Song Yeoh zscoder.

Let zij be the number of xor-sequences of length i with the last element equal to aj. Let gij be equal to one if  contains the number of ones in binary presentation that is multiple of three. Otherwise let gij be equal to zero. Consider a vectors zi = {zij}, zi - 1 = {zi - 1, j} and a matrix G = {gij}. Easy to see that zi = G × zi - 1. So zn = Gnz0. Let's use the associative property of matrix multiplication: at first let's calculate Gn with binary matrix exponentiation and then multiply it to the vector z0.

C++ solutionComplexity: O(n3logk).

691F - Couple CoverThe problem was suggested by Michael Kirsche mkirsche.

Let's count the number of pairs with multiple less than p. To get the number of not less pairs we should sumply subtract from n·(n - 1) the number of less pairs. Let cnti be the number of values in a equal to i and zj be the number of pairs from a with the multiple equal to j. To calculate the values from z we can use something like Eratosthenes sieve: let's iterate over the first multiplier a and the multiple of it b = ka and increment zb by the value cnta·cntk. After calculating the array z we should calculate the array of its partial sums and find the number of less pairs in O(1) time.

C++ solutionComplexity: O(n + XlogX), where X is the maximal value in p.

Editorial of Educational Codeforces Round 13

By Edvard, history, 7 years ago, translation, In English678A - Johny Likes NumbersThe problem was suggested by Abdrakhman Ismail bash.

We should find minimal x, so x·k > n. Easy to see that . To learn more about floor/ceil functions I reccomend the book of authors Graham, Knuth, Patashnik "Concrete Mathematics". There is a chapter there about that functions and their properties.

С++ solutionComplexity: O(1).

678B - The Same CalendarThe problem was suggested by Arthur Jaworski KingArthur.

Two calendars are same if and only if they have the same number of days and starts with the same day of a week. So we should simply iterate over years and maintain the day of a week of January, 1st (for example). Easy to see that the day of a week increases by one each year except of the leap years, when it increases by two.

C++ solutionComplexity: O(1) — easy to see that we will not iterate more than some small fixed constant times.

678C - Joty and ChocolateThe problem was suggested by Sheikh Monir skmonir.

Easy to see that we can paint with both colours only tiles with the numbers multiple of lcm(a, b). Obviously that tiles should be painted with more expensive colour. So the answer equals to .

C++ solutionComplexity: O(log(max(a, b))).

678D - Iterated Linear FunctionThe problem was suggested by Zi Song Yeoh zscoder.

The problem can be solved using closed formula: it's need to calculate the sum of geometric progression. The formula can be calculated using binary exponentiation.

I'll describe more complicated solution, but it's more general. If we have a set of variables and at each step all variables are recalculating from each other using linear function, we can use binary matrix exponentiation. There is only one variable x in our problem. The new variable x' is calculating using formula A·x + B. Consider the matrix z = [[A, B], [0, 1]] and the vector v = [0, 1]. Let's multiply z and v. Easy to see that we will get the vector v' = [x', 1]. So to make n iterations we should multiply z and v n times. We can do that using binary matrix exponentiation, because matrix multiplication is associative.

As an exercise try to write down the matrix for the Fibonacci numbers and calculate the n-th Fibonacci number in O(logn) time. The matrix and the vector is under the spoiler.

The matrix and the vector for the Fibonacci numbersC++ solutionComplexity: O(logn).

678E - Another Sith TournamentThe problem was suggested and prepared by Alexey Dergunov dalex.

Let's solve the problem using dynamic programming. zmask, i — the maximal probability of Ivans victory if the siths from the mask already fought and the i-th sith left alive. To calculate that DP we should iterate over the next sith (he will fight against the i-th sith): .

C++ solutionTime complexity: O(2nn2).

Memory complexity: O(2nn).

678F - Lena and QueriesThe problem was suggested by AmirMohammad Dehghan PrinceOfPersia.

Let's interpret the problem geometrically: the pairs from the set are the lines and the problem to find to topmost intersection of the vertical line with the lines from the set.

Let's split the queries to  blocks. Consider the lines added before the current block and that will not deleted in the current block. Let's build the lower envelope by that lines. Now to calculate the answer to the query we should get maximum over the lines from the envelope and the lines from the block before the current query that is not deleted yet. There are no more than  lines from the block, so we can iterate over them. Let's find the answers from the envelope for all queries of the third type from the block at once: we should sort them and iterate over envelope using two pointers technique.

C++ solutionComplexity: .

Editorial of Educational Codeforces Round 12

By Edvard, history, 7 years ago, translation, In English665A - Buses Between CitiesThe problem was suggested by Sergey Erlikh unprost.

Consider the time interval when Simion will be on the road strictly between cities (x1, y1) (x1 = 60h + m, y1 = x1 + ta). Let's iterate over the oncoming buses. Let (x2, y2) be the time interval when the oncoming bus will be strictly between two cities. If the intersection of that intervals (x = max(x1, x2), y = min(y1, y2)) is not empty than Simion will count that bus.

С++ solutionComplexity: O(1).

665B - ShoppingThe problem was suggested by Ayush Anand JeanValjean01.

In this problem you should simply do what was written in the problem statement. There are no tricks.

C++ solutionComplexity: O(nmk).

665C - Simple StringsThe problem was suggested by Zi Song Yeoh zscoder.

There are two ways to solve this problem: greedy approach and dynamic programming.

The first apprroach: Considerr some segment of consecutive equal characters. Let k be the length of that segment. Easy to see that we should change at least  characters in the segment to remove all the pairs of equal consecutive letters. On the other hand we can simply change the second, the fourth etc. symbols to letter that is not equal to the letters before and after the segment.

Greedy approach on C++The second approach: Let zka be the minimal number of changes so that the prefix of length k has no equal consecutive letters and the symbol s'k equals to a. Let's iterate over the letter on the position k + 1 and if it is not equal to a make transition. The cost of the transition is equal to 0 if we put the same letter as in the original string s on the position k + 1. Otherwise the cost is equal to 1.

DP solution on C++Complexity: O(n).

665D - Simple SubsetThe problem was suggested by Zi Song Yeoh zscoder.

Consider the subset A that is the answer to the problem. Let a, b, c be the arbitrary three elements from A and let no more than one of them is equal to 1. By the pigeonhole principle two of three elements from a, b, c have the same parity. So we have two integers with even sum and only one of them is equal to 1, so their sum is also greater than 2. So the subset A is not simple. In this way A consists of only two numbers greater than one (with a prime sum) or consists of some number of ones and also maybe other value x, so that x + 1 is a prime.

We can simply process the first case in O(n2) time. The second case can be processed in linear time. Also we should choose the best answer from that two.

To check the value of order 2·106 for primality in O(1) time we can use the simple or the linear Eratosthenes sieve.

C++ solutionComplexity: O(n2 + X), where X is the maximal value in a.

665E - Beautiful SubarraysThe problem was suggested by Zi Song Yeoh zscoder.

The sign  is used for the binary operation for bitwise exclusive or.

Let si be the xor of the first i elements on the prefix of a. Then the interval (i, j] is beautiful if . Let's iterate over j from 1 to n and consider the values sj as the binary strings. On each iteration we should increase the answer by the value zj — the number of numbers si (i < j) so . To do that we can use the trie data structure. Let's store in the trie all the values si for i < j. Besides the structure of the trie we should also store in each vertex the number of leaves in the subtree of that vertex (it can be easily done during adding of each binary string). To calculate the value zj let's go down by the trie from the root. Let's accumulate the value cur equals to the xor of the prefix of the value sj with the already passed in the trie path. Let the current bit in sj be equal to b and i be the depth of the current vertex in the trie. If the number cur + 2i ≥ k then we can increase zj by the number of leaves in vertex , because all the leaves in the subtree of tha vertex correspond to the values si that for sure gives . After that we should go down in the subtree b. Otherwise if cur + 2i < k then we should simply go down to the subtree  and recalculate the value cur = cur + 2i.

C++ solutionComlpexity by the time and the memory: O(nlogX), where X is the maximal xor on the prefixes.

665F - Four DivisorsThe editorial for this problem is a little modification of the materials from the lecture of Mikhail Tikhomirov Endagorion of the autumn of 2015 in Moscow Institute of Physics and Technology. Thanks a lot to Endagorion for that materials.

Easy to see that only the numbers of the form p·q and p3 (for different prime p, q) have exactly four positive divisors.

We can easily count the numbers of the form p3 in , where n is the number from the problem statement.

Now let p < q and π(k) be the number of primes from 1 to k. Let's iterate over all the values p. Easy to see that . So for fixed p we should increase the answer by the value .

So the task is ot to find  — the number of primes not exceeding , for all p.

Denote pj the j-th prime number. Denote dpn, j the number of k such that 1 ≤ k ≤ n, and all prime divisors of k are at least pj (note that 1 is counted in all dpn, j, since the set of its prime divisors is empty). dpn, j satisfy a simple recurrence:

dpn, 1 = n (since p1 = 2)

dpn, j = dpn, j + 1 + dp⌊ n / pj⌋, j, hence dpn, j + 1 = dpn, j - dp⌊ n / pj⌋, j

Let pk be the smallest prime greater than . Then π(n) = dpn, k + k - 1 (by definition, the first summand accounts for all the primes not less than k).

If we evaluate the recurrence dpn, k straightforwardly, all the reachable states will be of the form dp⌊ n / i⌋, j. We can also note that if pj and pk are both greater than , then dpn, j + j = dpn, k + k. Thus, for each ⌊ n / i⌋ it makes sense to keep only  values of dp⌊ n / i⌋, j.

Instead of evaluating all DP states straightforwardly, we perform a two-step process:

Choose K.

Run recursive evaluation of dpn, k. If we want to compute a state with n < K, memorize the query ``count the numbers not exceeding n with all prime divisors at least k''.

Answer all the queries off-line: compute the sieve for numbers up to K, then sort all numbers by the smallest prime divisor. Now all queries can be answered using RSQ structure. Store all the answers globally.

Run recurisive evaluation of dpn, k yet again. If we want to compute a state with n < K, then we must have preprocessed a query for this state, so take it from the global set of answers.

The performance of this approach relies heavily on Q — the number of queries we have to preprocess.

Statement. .

Proof:

Each state we have to preprocess is obtained by following a dp⌊ n / pj⌋, j transition from some greater state. It follows that Q doesn't exceed the total number of states for n > K.

The preprocessing of Q queries can be done in , and it is the heaviest part of the computation. Choosing optimal , we obtain the complexity .

C++ solutionComplexity: .

Editorial of Educational Codeforces Round 11

By Edvard, history, 7 years ago, translation, In English660A - Co-prime ArrayThe problem was suggested by Ali Ibrahim C137.

Note that we should insert some number between any adjacent not co-prime elements. On other hand we always can insert the number 1.

С++ solutionComplexity: O(nlogn).

660B - Seating On BusThe problem was suggested by Srikanth Bhat bharsi.

In this problem you should simply do what was written in the problem statement. There are no tricks.

C++ solutionComplexity: O(n).

660C - Hard ProcessThe problem was suggested by Mohammad Amin Raeisi Smaug.

Let's call the segment [l, r] good if it contains no more than k zeroes. Note if segment [l, r] is good than the segment [l + 1, r] is also good. So we can use the method of two pointers: the first pointer is l and the second is r. Let's iterate over l from the left to the right and move r while we can (to do that we should simply maintain the number of zeroes in the current segment).

C++ solutionComplexity: O(n).

660D - Number of ParallelogramsThe problem was suggested by Sadegh Mahdavi smahdavi4.

It's known that the diagonals of a parallelogram split each other in the middle. Let's iterate over the pairs of points a, b and consider the middle of the segment : . Let's calculate the value cntc for each middle. cntc is the number of segments a, b with the middle c. Easy to see that the answer is .

C++ solutionComplexity: O(n2logn).

660E - Different Subsets For All TuplesThe problem was suggested by Lewin Gan Lewin.

Let's consider some subsequence with the length k > 0 (the empty subsequences we will count separately by adding the valye mn at the end) and count the number of sequences that contains it. We should do that accurately to not count the same sequence multiple times. Let x1, x2, ..., xk be the fixed subsequence. In the original sequence before the element x1 can be some other elements, but none of them can be equal to x1 (because we want to count the subsequence exactly one time). So we have m - 1 variants for each of the elements before x1. Similarly between elements x1 and x2 can be other elements and we have m - 1 choices for each of them. And so on. After the element xk can be some elements (suppose there are j such elements) with no additional constraints (so we have m choices for each of them). We fixed the number of elements at the end j, so we should distribute n - k - j numbers between numbers before x1, between x1 and x2, \ldots, between xk - 1 and xk. Easy to see that we have  choices to do that (it's simply binomial coefficient with allowed repititions). The number of sequences x1, x2, ..., xk equals to mk. So the answer is . Easy to transform the last sum to the sum . Note the last inner sum can be calculating using the formula for parallel summing: . So the answer equals to . Also we can get the closed formula for the last sum to get logarithmic solution, but it is not required in the problem.

C++ solutionComplexity: O((n + m)log MOD), где MOD = 109 + 7.

660F - Bear and Bowling 4The problem was prepared by Kamil Debowski Errichto. The problem analysis is also prepared by him.

The key is to use divide and conquer. We need a recursive function f(left, right) that runs f(left, mid) and f(mid+1, right) (where mid = (left + right) / 2) and also considers all intervals going through mid. We will eventually need a convex hull of lines (linear functions) and let's see how to achieve it.

For variables L, R (, ) we will try to write the score of interval [L, R] as a linear function. It would be good to get something close to aL·xR + bL where aL and bL depend on L, and xR depends on R only.

For each L we should find a linear function fL(x) = aL·x + bL where aL, bL should fit the equation ( * ):

Now we have a set of linear functions representing all possible left endpoints L. For each right endpoint R we should find xR and constR to fit equation ( * ) again. With value of xR we can iterate over functions fL to find the one maximizing value of bL + aL·xR. And (still for fixed R) we should add constR to get the maximum possible score of interval ending in R.

Brute Force with functionsNow let's make it faster. After finding a set of linear functions fL we should build a convex hull of them (note that they're already sorted by slope). To achieve it we need something to compare 3 functions and decide whether one of them is unnecessary because it's always below one of other two functions. Note that in standard convex hull of points you also need something similar (but for 3 points). Below you can find an almost-fast-enough solution with a useful function bool is_middle_needed(f1, f2, f3). You may check that numbers calculated there do fit in long long.

Almost fast enoughFinally, one last thing is needed to make it faster than O(n2). We should use the fact that we have built a convex hull of functions (lines). For each R you should binary search optimal function. Alternatively, you can sort pairs (xR, constR) and then use the two pointers method — check the implementation in my solution below. It gives complexity  because we sort by xR inside of a recursive function. I think it's possible to get rid of this by sorting prefixes  in advance because it's equivalent to sorting by xR. And we should use the already known order when we run a recursive function for smaller intervals. So, I think  is possible this way — anybody implemented it?

Intended solution with two pointersComplexity: O(nlog2n).

Editorial of Educational Codeforces Round 10

By Edvard, history, 7 years ago, translation, In English652A - Gabriel and CaterpillarThe problem was suggested by unprost.

Let's consider three cases.

h1 + 8a ≥ h2 — in this case the caterpillar will get the apple on the same day, so the answer is 0.

The first condition is false and a ≤ b — in this case the caterpillar will never get the apple, because it can't do that on the first day and after each night it will be lower than one day before.

If the first two conditions are false easy to see that the answer equals to .

C++ solutionAlso this problem can be solved by simple modelling, because the heights and speeds are small.

Complexity: O(1).

652B - z-sortThe problem was suggested by Smaug.

Easy to see that we can z-sort any array a. Let  be the number of even positions in a. We can assign to those positions k maximal elements and distribute other n - k elements to odd positions. Obviously the resulting array is z-sorted.

C++ solutionComplexity: O(nlogn).

652C - Foe PairsThis is one of the problems suggested by Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A.

Let's precompute for each value x its position in permutation posx. It's easy to do in linear time. Consider some foe pair (a, b) (we may assume posa < posb). Let's store for each value a the leftmost position posb such that (a, b) is a foe pair. Denote that value as za. Now let's iterate over the array a from right to left and maintain the position rg of the maximal correct interval with the left end in the current position lf. To maintain the value rg we should simply take the minimum with the value z[lf]: rg = min(rg, z[lf]). And finally we should increment the answer by the value rg - lf + 1.

C++ solutionComplexity: O(n + m).

652D - Nested SegmentsThe problem was suggested by Alexey Dergunov dalex.

This problem is a standard two-dimensional problem that can be solved with one-dimensional data structure. In the same way a lot of other problems can be solved (for example the of finding the maximal weighted chain of points so that both coordinates of each point are greater than the coordinates of the predecessing point). Rewrite the problem formally: for each i we should count the number of indices j so that the following conditions are hold: ai < aj and bj < aj. Let's sort all segments by the left ends from right to left and maintain some data structure (Fenwick tree will be the best choice) with the right ends of the processed segments. To calculate the answer for the current segment we should simple take the prefix sum for the right end of the current segment.

So the condition ai < aj is hold by sorting and iterating over the segments from the right to the left (the first dimension of the problem). The condition bj < aj is hold by taking the prefix sum in data structure (the second dimension).

C++ solutionComplexity: O(nlogn).

652E - Pursuit For ArtifactsThe problem was suggested by Alexey Dergunov dalex.

Edge biconnected component in an undirected graph is a maximal by inclusion set of vertices so that there are two edge disjoint paths between any pair of vertices. Consider the graph with biconnected components as vertices. Easy to see that it's a tree (if it contains some cycle then the whole cycle is a biconnected component). All edges are destroying when we passing over them so we can't returnto the same vertex (in the tree) after leaving it by some edge.

Consider the biconncted components that contains the vertices a and b. Let's denote them A and B. Statement: the answer is YES if and only if on the path in the tree from the vertex A to the vertex B there are an edge with an artifact or there are a biconnected component that contains some edge with an artifact. Easy to see that the statement is true: if there are such edge then we can pass over it in the tree on the path from A to B or we can pass over it in biconnected component. The converse also easy to check.

Here is one of the ways to find edge biconnected components:

Let's orient all edges to direction that depth first search passed it for the first time.

Let's find in new directed graph strongly connected components.

Statement: the strongly connected components in the new graph coincide with the biconnected components in old undirected graph.

Also you can notice that the edges in tree is the bridges of the graph (bridges in terms of graph theory). So you can simply find the edges in the graph.

Not too short C++ solutionComplexity: O(n + m).

652F - Ants on a CircleThe problem was suggested by Lewin Gan Lewin.

The first observation: if all the ants are indistinguishable we can consider that there are no collisions and all the ants are passing one through another. So we can easily determine the final positions of all the ants, but we can't say which ant will be in which position.

The second observation: the relative order of the ants will be the same all the time.

So to solve the problem we should only find the position of one ant after t seconds.

Let's solve that problem in the following way:

Consider the positions of all the ants after m time units. Easy to see that by the first observation all the positions of the ants will left the same, but the order will be different (we will have some cyclic shift of the ants). If we find that cyclic shift sh we can apply it  times.

After that we will have only t ± od m time units.

So the problem now is to model the process for the one ant with m and r ± od m time units. Note that in that time interval the fixed ant will have no more than two collisions with each other ant. So if we model the process with ignoring all collisions except the ones that include the fixed ant, we will have no more than 2n collisions.

Let's model that process with two queues for the ants going to the left and to the right. Each time we should take the first ant in the queue with opposite direction, process the collision and add that ant to the end of the other queue.

Hint: you will have a problem when the fixed ant can be in two different positions at the end, but it's easy to fix with doing the same with the next ant.

C++ solutionComplexity: O(nlogn).

Разбор задач Educational Codeforces Round 9

By Edvard, history, 7 years ago, translation, In English632A - Grandma Laura and ApplesThe problem was suggested by unprost.

Consider the process from the end. The last buyer will always buy a half of an apple and get a half for free (so the last string always is halfplus). After that each buyer increases the number of apples twice and also maybe by one. So we simply have the binary presentation of the number of apples from the end. To calculate the answer we should simply restore that value from the end and also calculate the total money grandma should have.

С++ solution by me.

С++ solution by unprost.

Complexity: O(p).

632B - Alice, Bob, Two TeamsThe problem was suggested by Lewin Gan Lewin.

Let's calculate the prefix sums for all numbers (and store it in array s1) and for numbers with letter B (and store it in array s2). Now we can find the sum of all numbers in any segment in O(1) time and the sum of numbers with letter B.

Let's iterate over prefix or suffix to flip and calculate the sum in that case by formulas: sum(s1, 0, n - 1) + sum(s2, 0, i) - 2·sum(s1, 0, i) for prefixes and sum(s1, 0, n - 1) + sum(s2, i, n - 1) - 2·sum(s1, i, n - 1) for suffixes.

C++ solution by me.

Python solution by Lewin.

Complexity: O(n).

632C - The Smallest String ConcatenationThe problem was suggested by Lewin Gan Lewin. The proof of the transitivity also belongs to him.

Let's sort all the strings by comparator a + b < b + a and concatenate them. Let's prove that it's the optimal answer. Let that operator be transitive (so if ). Consider an optimal answer with two strings in reverse order by that operator. Because of the transitivity of operator we can assume that pair of strings are neighbouring. But then we can swap them and get the better answer.

Let's prove the transitivity of operator. Consider the strings as the 26-base numbers. Then the relation a + b < b + a equivalent to . The last is simply the relation between real numbers. So we proved the transitivity of the relation a + b < b + a.

C++ solution by me.

Python solution by Lewin.

Complexity: O(nLlogn), where L is the maximal string length.

632D - Longest SubsequenceThe problem was suggested by Denis Bezrukov pitfall.

Let cntx be the number of occurences of the number x in the given array (easy to see that we can ignore the numbers greater than m). Let's iterate over  and 1 ≤ k, x·k ≤ m and increase the value in the position k·x in some array z by the value cntx. So the value zl equals the number of numbers in the given array which divide l. Let's find the minimal l with the maximum value zl (1 ≤ l ≤ m). Easy to see that the answer to the problem is the numbers which divide l.

Let's calculate the complexity of the solution. The number of the pairs (k, x) we can bound with the value .

C++ solution by me.

Java solution by pitfall.

Complexity: O(n + mlogm).

632E - Thief in a ShopThe problem was suggested by Alexey Chesnokov CleRIC.

Let k = 2, then it is the standard problem which can be solved by FFT (Fast Fourier Transform). The solution is the following: consider the polynomial which the i-th coefficient equals to one if and only if there is the number i in the given array. Let's multiply that polynomial by itself and find i for which the coefficient in square not equals to 0. Those values i will be in the answer. Easy to modificate the solution for the arbitrary k. We should simply calculate the k-th degree of the polynomial. The complexity will be WlogWlogk, where W is the maximal sum.

We can improve that solution. Instead of calculating the k-th degree of the polynomial we can calculate the k-th degree of the DFT of the polynomial. The only problem is the large values of the k-th degrees. We can't use FFT with complex numbers, because of the precision problems. But we can do that with NTT (Number-theoretic transform). But that solution also has a problem. It can happen that some coefficients became equals to zero modulo p, but actually they are not equal to zero. To get round that problem we can choose two-three random modules and get the complexity O(W(logW + logk)).

The main author solution has the complexity O(WlogWlogk) (FFT with complex numbers), the second solution has the same complexity, but uses NTT and the third solution has the improved complexity (but it was already hacked by halyavin).

С++ solution, complex FFT by me.

С++ solution, NTT by me.

С++ solution, improved NTT by me.

С++ solution by CleRIC.

P.S.: To get faster solution you should each time multiply the polynomials of the required degree, but not of the degree 220.

Complexity: O(WlogWlogk) or O(W(logW + logk)), depending the bravery of the coder :-)

UPD: It turns out that the first approach also has complexity O(W(logW + logk)). See below the comment of halyavin.

632F - Magic MatrixThe problem was suggested by Lewin Gan Lewin. The solution and proof also belongs to him.

Consider the undirected complete graph with n nodes, with an edge between nodes i, j with cost aij. Let Bij denote the minimum possible value of the max edge of a path from i to j. We know that aij ≥ Bij by definition.

If the matrix is magic, we can choose arbitrary k1, k2, ..., km such that aij ≤ max(ai, k1, ak1, k2, ..., akm, j) by repeating invocations of the inequality given. Also, you can show that if this inequality is satisfied, then the matrix is magic (by choosing an m = 1 and k1 arbitrary).

So, this shows that the matrix is magic if and only if aij ≤ Bij. Thus, combining with aij ≥ Bij, we have aij = Bij.

We need a fast way to compute Bij for all pairs i, j. This can be computed as the MST, as the path in the MST minimizes the max edge between all pairs of nodes. So, the algorithm works as follows. First, find the MST on the complete graph. Then, the matrix is magic if and only if the max edge on the path between i, j in the MST is exactly equal to ai, j. Also you shouldn't forget to check symmetry of the matrix and diagonal for zeros.

P.S.: Unfortunately we couldn't increase the value n in this problem: the tests already had the size about 67MB and they couldn't be given with generator. So most of the users who solved this problem uses bitset-s. The complexity of their solution is , where b = 32 or b = 64.

C++ solution, binary lifts by me.

Java solution by Lewin.

Complexity: O(n2logn) or O(n2).

Editorial of Educational Codeforces Round 8

By Edvard, history, 7 years ago, translation, In English628A - Tennis TournamentThe problem was suggested by unprost.

Here you can simply model the process. Or you can note that after each match some player drops out. In total n - 1 players will drop out. So the first answer is (n - 1) * (2b + 1). Obviously the second answer is np.

С++ solution 1

С++ solution 2

Complexity: O(log2n), O(logn) or O(1) depends on the realization.

628B - New SkateboardThis is one of the problems suggested by Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A.

The key observation is that the number is divisible by 4 if and only if its last two digits forms a number divisible by 4. So to calculate the answer at first we should count the substrings of length one. Now let's consider pairs of consecutive digits. If they forms a two digit number that is divisible by 4 we should increase the answer by the index of the right one.

C++ solution

Complexity: O(n).

628C - Bear and String DistanceThe problem was suggested and prepared by Kamil Debowski Errichto. He also wrote the editorial.

There is no solution if the given required distance is too big. Let's think what is the maximum possible distance for the given string s. Or the more useful thing — how to construct a string s' to maximize the distance? We can treat each letter separately and replace it with the most distant letter. For example, we should replace 'c' with 'z', and we should replace 'y' with 'a'. To be more precise, for first 13 letters of the alphabet the most distant letter is 'z', and for other letters it is 'a'.

Let's solve a problem now. We can iterate over letters and greedily change them. A word "greedily" means when changing a letter we don't care about the next letters. We generally want to choose distant letters, because we may not find a solution otherwise. For each letter si we change it into the most distant letter, unless the total distance would be too big. As we change letters, we should decrease the remaining required distance. So, for each letter si consider only letters not exceeding the remaining distance, and among them choose the most distant one. If you don't see how to implement it, refer to my C++ solution with comments.

Other C++ solution

Complexity: O(n).

628D - Magic NumbersKareem Mohamed Kareem_Mohamed suggested the simpler version of the problem.

Denote the answer to the problem f(a, b). Note that f(a, b) = f(0, b) - f(0, a - 1) or what is the same f(a, b) = f(0, b) - f(0, a) + g(a), where g(a) equals to one if a is a magic number, otherwise g(a) equals to zero. Let's solve the problem for the segment [0, n].

Here is described the standard technique for this kind of problems, sometimes it is called 'dynamic programming by digits'. It can be realized in a two ways. The first way is to iterate over the length of the common prefix with number n. Next digit should be less than corresponding digit in n and other digits can be arbitrary. Below is the description of the second approach.

Let zijk be the number of magic prefixes of length i with remainder j modulo m. If k = 0 than the prefix should be less than the corresponding prefix in n and if k = 1 than the prefix should be equal to the prefix of n (it can not be greater). Let's do 'forward dynamic programming'. Let's iterate over digit  in position i. We should check that if the position is even than p should be equal to d, otherwise it cannot be equal to d. Also we should check for k = 1 p should be not greater than corresponding digit in n. Now let's see what will be the next state. Of course i' = i + 1. By Horner scheme j' = (10j + p) mod m. Easy to see that . To update the next state we should increase it: zi'j'k' +  = zijk. Of course all calculations should be done modulo 109 + 7.

C++ solution

Complexity: O(nm).

628E - Zbazi in ZeydabadThe problem was suggested by Ali Ahmadi Kuzey.

Let's precalculate the values zlij, zrij, zldij — the maximal number of letters 'z' to the left, to the right and to the left-down from the position (i, j). It's easy to do in O(nm) time. Let's fix some cell (i, j). Consider the value c = min(zlij, zldij). It's the maximum size of the square with upper right ceil in (i, j). But the number of z-patterns can be less than c. Consider some cell (x, y) diagonally down-left from (i, j) on the distance no more than c. The cells (i, j) and (x, y) forms z-pattern if y + zrxy > j.

Let's maintain some data structure for each antidiagonal (it can be described by formula x + y) that can increment in a point and take the sum on a segment (Fenwick tree will be the best choice for that). Let's iterate over columns j from the right to the left and process the events: we have some cell (x, y) for which y + zrxy - 1 = j. In that case we should increment the position y in the tree number x + y by one. Now we should iterate over the cells (x, y) in the current column and add to the answer the value of the sum on the segment from j - c + 1 to j in the tree number i + j .

С++ solution

Complexity: O(nmlogm).

628F - Bear and Fair SetThe problem was suggested and prepared by Kamil Debowski Errichto. He also wrote the editorial.

At the beginning, to make things simpler, we should add a query (hint) with upTo = b, quantity = n, and then sort queries by upTo. Sorted queries (hints) divide interval [1, b] into q disjoint intervals. For each interval we know how many elements should be there.

Let's build a graph and find a max flow there. The answer is "YES" only if the flow is n.

The first group A contains 5 vertices, representing possible remainders.The second group B contains q vertices, representing intervals.Each vertex from A should be connected with the source by an edge with capacity n / 5. Each vertex from B should be connected with the sink by an edge with capacity equal to the size of the interval. Between each vertex x from A and y from B should be an edge with capacity equal to the number of numbers in the interval y, giving remainder x when divided by 5.

You can also use see that it's similar to finding matching. In fact, we can use the Hall's marriage theorem. For each of 25 sets of vertices from A (sets of remainders) iterate over intervals and count how many numbers we can take from [1, b] with remainders from the fixed set of remainders.

The implementation with the Hall's theorem: C++ solution.

Complexity: O(2Cn). In our problem C = 5.

Editorial of Educational Codeforces Round 7

By Edvard, history, 7 years ago, translation, In English622A - Infinite SequenceLet's decrease n by one. Now let's determine the block with the n-th number. To do that let's at first subtract 1 from n, then subtract 2, then subtract 3 and so on until we got negative n. The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get.

С++ solution

Complexity: .

622B - The TimeIn this problem we can simply increase a times the current time by one minute (after each increasing we should check the hours and the minutes for overflow).

Another solution is to use the next formulas as the answer: .

C++ solution 1

C++ solution 2

Complexity: O(a) or O(1).

622C - Not Equal on a SegmentThis problem is a simplified version of the problem suggested by Mohammad Nematollahi Deemo.

This problem can be solved differently. For example you can use some data structures or sqrt-decomposition technique. But it is not required. We expected the following simple solution from the participants. Let's preprocess the following values pi — the position of the first element to the left from the i-th element such that ai ≠ api. Now to answer to the query we should check if ar ≠ x then we have the answer. Otherwise we should check the position pr.

C++ solution

Complexity: O(n).

622D - Optimal Number PermutationThis problem was suggested by Aleksa Plavsic allllekssssa.

Let's build the answer with the sum equal to zero. Let n be even. Let's place odd numbers in the first half of the array: the number 1 in the positions 1 and n, the number 3 in the positions 2 and n - 1 and so on. Similarly let's place even numbers in the second half: the number 2 in the position n + 1 and 2n - 1, the number 4 in the positions n + 2 and 2n - 2 and so on. We can place the number n in the leftover positions. We can build the answer for odd n in a similar way.

Easy to see that our construction will give zero sum.

C++ solution

Complexity: O(n).

622E - Ants in LeavesThis problem was suggested by Aleksa Plavsic allllekssssa.

Easy to see that the answer is equal to the answer over all sons of the root plus one. Now let's solve the problem independently for each son v of the root. Let z be the array of the depths of all leaves in the subtree of the vertex v. Let's sort z. Statement 1: it's profitable to lift the leaves in order of their appearing in z. Statement 2: denote ax — the time of appearing the x-th leaf in the vertex v, let's consider the leaves zi and zi + 1 then azi + 1 ≥ azi + 1. Statement 3: azi + 1 = max(dzi + 1, azi + 1), where dx is the depth of the x-th leaf in the subtree of the vertex v. The last statement gives us the solution for the problem: we should simply iterate over z from left to right and recalculate the array a by formula from the third statement. All statements can be easily proved and it's recommended to do by yourself to understand better the idea of the solution.

С++ solution

Complexity: O(nlogn).

622F - The Sum of the k-th PowersThis problem was suggested by Ivan Popovich NVAL.

Statement: the function of the sum is a polynomial of degree k + 1 over variable n. This statement can be proved by induction (to make step you should take the derivative).

Denote Px the value of the sum for n = x. We can easily calculate the values of Px for x from 0 to k + 1 in O(klogk) time. If n < k + 2 then we already have the answer. Otherwise let's use Lagrange polynomial to get the value of the sum for the given value n.

The Largange polynomial have the following form: . In our case xi = i - 1 and yi = Pxi.

To calculate P(n) in a linear time we should use that xi + 1 - xi = xj + 1 - xj for all i, j < n. It's help us because with that property we can recalculate the inner product for i + 1 from the inner product for i simply by multiplying by two values and dividing by two values. So we can calculate the sum in linear time over k.

С++ solution

Complexity: O(klog MOD) (logk appeared because we should find the inverse element in the field modulo MOD = 109 + 7).

Editorial of Educational Codeforces Round 6

By Edvard, history, 7 years ago, translation, In English620A - Professor GukiZ's RobotEasy to see that the answer is max(|x1 - x2|, |y1 - y2|).

С++ solution

Complexity: O(1).

620B - Grandfather Dovlet’s calculatorLet's simply iterate over all the values from a to b and add to the answer the number of segments of the current value x. To count the number of segments we should iterate over all the digits of the number x and add to the answer the number of segments of the current digit d. These values can be calculated by the image from the problem statement and stored in some array in code.

C++ solution

Complexity: O((b - a)logb).

620C - Pearls in a RowLet's solve the problem greedily. Let's make the first segment by adding elements until the segment will be good. After that let's make the second segment in the same way and so on. If we couldn't make any good segment then the answer is  - 1. Otherwise let's add all uncovered elements at the end to the last segment. Easy to prove that our construction is optimal: consider the first two segments of the optimal answer, obviously we can extend the second segment until the first segment will be equal to the first segment in our construction.

C++ solution

Complexity: O(nlogn).

620D - Professor GukiZ and Two ArraysWe can process the cases of zero or one swap in O(nm) time. Consider the case with two swaps. Note we can assume that two swaps will lead to move two elements from a to b and vice versa (in other case it is similar to the case with one swap). Let's iterate over all the pairs of the values in a and store them in some data structure (in C++ we can user map). Now let's iterate over all the pairs bi, bj and find in out data structure the value v closest to the value x = sa - sb + 2·(bi + bj) and update the answer by the value |x - v|. Required sum we can find using binary search by data structure (*map* in C++ has lower_bound function).

C++ solution

Сложность: O((n2 + m2)log(n + m)).

620E - New Year TreeLet's run dfs on the tree and write out the vertices in order of their visisiting by dfs (that permutation is called Euler walk). Easy to see that subtree of any vertex is a subsegment of that permutation. Note that the number of different colours is 60, so we can store the set of colours just as mask of binary bits in 64-bit type (*long long* in C++, long in Java). Let's build the segment tree over the permutation which supports two operations: paint subsegment by some colour and find the mask of colours of some segment.

С++ solution

Complexity: O(nlogn).

620F - Xors on SegmentsWe gave bad constraints to this problem so some participants solved it in O(n2 + m) time.

Note that . The values f(0, x) can be simply precomputed. Also you can notice that the value f(0, x) is equal to x, 1, x + 1, 0 depending on the value x modulo 4.

Let's use Mo's algorithm: we should group all the queries to  blocks by the left end and sort all the queries in each block by the right end. Let r be the maximal left end inside the current group then all left ends will be in distance not greater than  from r and right ends will be in nondecreasing order, so we can move the right end by one (total we will made no more than n movements in each block). During moving of the right end inside some group from the value r + 1 to the value of the current right end we will maintain two tries: the first for the values f(0, x - 1) and the second for the values f(0, x), in the first we will maintain the minimal value of x, in the second — the maximal. After adding some values to the trie we should find the maximal value that can be formed by the current value x. To do that we should go down in the first trie maintaining the invariant that in the current subtree the minimal value is not greater than x. Each time we should go by the bit that is not equal to the corresponding bit in x (if we can do that, otherwise we should go by the other bit). In the second trie we should do the same thing with the difference that we should maintain the invariant that the maximal value in the current subtree is not less than the value x. After moving the right end we should iterate from the left end of the query to r and update the answer (without adding the current value to the tries). Also after that all we should iterate over all the queries and with new empty tries iterate from the left end to r, add the current values to the tries and update the answer.

С++ solution: in this code the trie number 0 corresponds to the second trie and the trie number 1 corresponds to the first trie.

Complexity: .

Editorial of Educational Codeforces Round 5

By Edvard, history, 7 years ago, translation, In English616A - Comparing Two Long IntegersNote that solutions in Java with BigInteger class or input() function in Python2 will fail in this problem. The reason is the next: standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system. Actually they are working in O(n2), where n is the legth of the number.

To solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length. After that you should simply compare them alphabetically.

С++ solution

Python solution

Complexity: O(n).

616B - Dinner with EmmaFirstly you should find the minimum value in each row and after that you should find the maximum value over that minimums. It's corresponding to the strategy of Jack and Emma.

C++ solution

Complexity: O(nm).

616C - The LabyrinthLet's enumerate all the connected components, store their sizes and for each empty cell store the number of it's component. It can be done with a single dfs. Now the answer for some impassable cell is equal to one plus the sizes of all different adjacent connected components. Adjacent means the components of cells adjacent to the current impassable cell (in general case each unpassable cell has four adjacent cells).

C++ solution

Complexity: O(nm).

616D - Longest k-Good SegmentThis problem is given because on the Codeforces pages we often see questions like "What is the method of the two pointers?". This problem is a typical problem that can be solved using two pointers technique.

Let's find for each left end l the maximal right end r that (l, r) is a k-good segment. Note if (l, r) is a k-good segment then (l + 1, r) is also a k-good segment. So the search of the maximal right end for l + 1 we can start from the maximal right end for l. The only thing that we should do is to maintain in the array cntx for each number x the number of it's occurrences in the current segment (l, r) and the number of different numbers in (l, r). We should move the right end until the segment became bad and then move the left end. Each of the ends l, r will be moved exactly n times.

C++ solution

Complexity: O(n).

616E - Sum of RemaindersUnfortunately my solution for this problem had overflow bug. It was fixed on contest. Even so I hope you enjoyed the problem because I think it's very interesting.

Let's transform the sum . Note that the last sum can be accumulated to only value min(n, m), because for i > n all the values will be equal to 0.

Note in the last sum either  or . Let's carefully accumulate both cases. The first sum can be simply calculated by iterating over all . We will accumulate the second sum independently for all different values . Firstly we should determine for which values i we will have the value . Easy to see that for the values i from the interval . Also we can note that the sum of the second factors in  with fixed first factor can be calculaed in constant time — it's simply a sum of arithmetic progression . So we have solution with complexity .

С++ solution

Complexity: .

616F - Expensive StringsThis problem was prepared by Grigory Reznikow vintage_Vlad_Makeev. His solution uses suffix array.

This problem is a typical problem for some suffix data structure. Four competitors who solved this problem during the contest used suffix automaton and one competitor used suffix tree. My own solution used suffix tree so I'll describe solution with tree (I think it's simple except of the building of the tree).

Let's build the new string by concatenation of all strings from input separating them by different separators. The number of separators is O(n) so the alphabet is also O(n). So we should use map<int, int> to store the tree and the complexity is increased by O(logn). Let's build the suffix tree for the new string. Let's match all the separators to the strings from the left of the separator. Let's run dfs on the suffix tree that doesn't move over separators and returns the sum of the costs of the strings matched to the separators from the subtree of the current vertex. Easy to see that we should simply update the answer by the product of the depth of the current vertex and the sum in the subtree of the current vertex.

С++ solution

Complexity: O(nlogn).

Editorial of Educational Codeforces Round 4

By Edvard, history, 7 years ago, translation, In English612A - The Text Splitting

Let's fix the number a of strings of length p and the number b of strings of length q. If a·p + b·q = n, we can build the answer by splitting the string s to a parts of the length p and b parts of the length q, in order from left to right. If we can't find any good pair a, b then the answer doesn't exist. Of course this problem can be solved in linear time, but the constraints are small, so you don't need linear solution.

Complexity: O(n2).

612B - HDD is Outdated Technology

You are given the permutation f. Let's build another permutation p in the following way: pfi = i. So the permutation p defines the number of sector by the number of fragment. The permutation p is called inverse permutation to f and denoted f - 1. Now the answer to problem is .

Complexity: O(n).

612C - Replace To Make Regular Bracket Sequence

If we forget about bracket kinds the string s should be RBS, otherwise the answer doesn't exist. If the answer exists each opening bracket matches to exactly one closing bracket and vice verse. Easy to see that if two matching brackets have the same kind we don't need to replace them. In other case we can change the kind of the closing bracket to the kind of the opening. So we can build some answer. Obviously the answer is minimal, because the problems for some pair of matching pairs are independent and can be solved separately.

The only technical problem is to find the matching pairs. To do that we should store the stack of opening brackets. Let's iterate from left to right in s and if the bracket is opening, we would simply add it to the stack. Now if the bracket is closing there are three cases: 1) the stack is empty; 2) at the top of the stack is the opening bracket with the same kind as the current closing; 3) the kind of the opening bracket differs from the kind of the closing bracket. In the first case answer doesn't exist, in the second case we should simply remove the opening bracket from the stack and in the third case we should remove the opening bracket from the stack and increase the answer by one.

Complexity: O(n).

612D - The Union of k-Segments

Let's create two events for each segment li is the time of the segment opening and ri is the time of the segment closing. Let's sort all events by time, if the times are equal let's sort them with priority to opening events. In C++ it can be done with sorting by standard comparator of vector<pair<int, int>> events, where each element of events is the pair with event time and event type ( - 1 for opening and  + 1 for closing).

Let's iterate over events and maintain the balance. To do that we should simply decrease the balance by the value of the event type. Now if the balance value equals to k and before updating it was k - 1 then we are in the left end of some segment from the answer. If the balance equals to k - 1 and before updating it was k then we are in the right end of the segment from the answer. Let's simply add segment [left, right] to the answer. So now we have disjoint set of segments contains all satisfied points in order from left to right. Obviously it's the answer to the problem.

Complexity: O(nlogn).

612E - Square Root of Permutation

Consider some permutation q. Let's build by it the oriented graph with edges (i, qi). Easy to see (and easy to prove) that this graph is the set of disjoint cycles. Now let's see what would be with that graph when the permutation will be multiplied by itself: all the cycles of odd length would remain so (only the order of vertices will change, they will be alternated), but the cycles of even length will be split to the two cycles of the same length. So to get the square root from the permutation we should simply alternate (in reverse order) all cycles of the odd length, and group all the cycles of the same even length to pairs and merge cycles in each pair. If it's impossible to group all even cycles to pairs then the answer doesn't exist.

Complexity: O(n).

612F - Simba on the Circle

The author solution for this problem uses dynamic programming. I think that this problem can't be solved by greedy ideas. Let's calculate two dp's: z1i is the answer to the problem if all numbers less than ai are already printed, but the others are not; and z2i is the answer to the problem if all numbers less than or equal to ai are already printed, but the others are not. Let's denote dij — the least distance between i and j on the circular array and odij is the distance from i to j in clockwise order. Easy to see that z2i = minj(zj + dij) for all j such that the value aj is the least value greater than ai. Now let's calculate the value z1i. Consider all elements equals to ai (in one of them we are). If there is only one such element then z1i = z2i. Otherwise we have two alternatives: to move in clockwise or counterclockwise direction. Let we are moving in clockwise direction, the last element from which we will write out the number would be the nearest to the i element in counterclockwise direction, let's denote it u. Otherwise at last we will write out the number from the nearest to the i element in clockwise direction, let's denote it v. Now z1i = min(z2u + odiu, z2v + odvi). Easy to see that the answer to the problem is mini(z1i + dsi), over all i such that ai is the smallest value in array and s is the start position.

Additionally you should restore the answer. To do that, on my mind, the simplest way is to write the recursive realization of dp, test it carefully and then copy it to restore answer (see my code below). Of course, it's possible to restore the answer without copy-paste. For example, you can add to your dp parameter b which means it's need to restore answer or not.

Complexity: O(n2).

Editorial of Educational Codeforces Round 3

By Edvard, history, 7 years ago, translation, In EnglishThis round was unusual: some of problems was prepared by students and employees of Saratov State U for some of past olympiads and one of problems was prepared by dalex for Codeforces regular round but was not used there.

609A - Флеш-карты

Let's sort the array in nonincreasing order. Now the answer is some of the first flash-drives. Let's iterate over array from left to right until the moment when we will have the sum at least m. The number of elements we took is the answer to the problem.

Complexity: O(nlogn).

609B - Книга - лучший подарок

Let's denote cnti — the number of books of i th genre. The answer to problem is equals to . In first sum we are calculating the number of good pairs, while in second we are subtracting the number of bad pairs from the number of all pairs.

Complexity: O(n + m2) or O(n + m).

609C - Load Balancing

Denote s — the sum of elements in array. If s is divisible by n then the balanced array consists of n elements . In this case the difference between maximal and minimal elements is 0. Easy to see that in any other case the answer is greater than 0. On the other hand the array consists of  numbers  and  numbers  is balanced with the difference equals to 1. Let's denote this balanced array b. To get array b let's sort array a in nonincreasing order and match element ai to element bi. Now we should increase some elements and decrease others. In one operation we can increase some element and decrease another, so the answer is .

Complexity: O(nlogn).

609D - Gadgets for dollars and pounds

If Nura can buy k gadgets in x days then she can do that in x + 1 days. So the function of answer is monotonic. So we can find the minimal day with binary search. Denote lf = 0 — the left bound of binary search and rg = n + 1 — the right one. We will maintain the invariant that in left bound we can't buy k gadgets and in right bound we can do that. Denote function f(d) equals to 1 if we can buy k gadgets in d days and 0 otherwise. As usual in binary search we will choose . If f(d) = 1 then we should move the right bound rg = d and the left bound lf = d in other case. If binary search found the value lf = n + 1 then the answer is  - 1, otherwise the answer is lf. Before binary search we can create two arrays of gadgets which are selling for dollars and pounds, and sort them. Easy to see that we should buy gadgets for dollars on day i ≤ d when dollar costs as small as possible and j ≤ d when pounds costs as small as possible. Let now we want to buy x gadgets for dollars and k - x gadgets for pounds. Of course we will buy the least cheap of them (we already sort the arrays for that). Let's iterate over x from 0 to k and maintain the sum of gadgets for dollars s1 and the sum of gadgets for pounds s2. For x = 0 we can calculate the sums in O(k). For other x's we can recalculate the sums in O(1) time from the sums for x - 1 by adding gadget for dollars and removing gadget for pounds.

Complexity: O(klogn).

609E - Minimum spanning tree for each edge

This problem was prepared by dalex.

Let's build any MST with any fast algorithm (for example with Kruskal's algorithm). For all edges in MST the answer is the weight of the MST. Let's consider any other edge (x, y). There is exactly one path between x and y in the MST. Let's remove mostly heavy edge on this path and add edge (x, y). Resulting tree is the MST contaning edge (x, y) (this can be proven by Tarjan criterion).

Let's fix some root in the MST (for example the vertex 1). To find the most heavy edge on the path from x to y we can firstly find the heaviest edge on the path from x to l = lca(x, y) and then on the path from y to l, where l is the lowest common ancestor of vertices x and y. To find l we can use binary lifting method. During calculation of l we also can maintain the weight of the heaviest edge.

Of course this problem also can be solved with difficult data structures, for example with Heavy-light decomposition method or with Linkcut trees.

Complexity: O(mlogn).

It's very strange but I can't find any articles with Tarjan criterion on English (although there are articles on Russian), so here it is:

Some spanning tree is minimal if and only if the weight of any other edge (x, y) (not from spanning tree) is not less than the weight of the heaviest edge on the path from x to y in spanning tree.

609F - Frogs and mosquitoes

Let's maintain the set of not eaten mosquitoes (for example with set in C++ or with TreeSet in Java) and process mosquitoes in order of their landing. Also we will maintain the set of segments (ai, bi), where ai is the position of the i-th frog and bi = ai + li, where li is the current length of the tongue of the i-th frog. Let the current mosquito landed in the position x. Let's choose segment (ai, bi) with minimal ai such that bi ≥ x. If the value ai ≤ x we found the frog that will eat mosquito. Otherwise the current mosquito will not be eaten and we should add it to our set. If the i-th frog will eat mosquito then it's tongue length will be increased by the size of mosquito and we should update segment (ai, bi). After that we should choose the nearest mosquito to the right the from frog and if it's possible eat that mosquito by the i-th frog (this can be done with lower_bound in C++). Possibly we should eat several mosquitoes, so we should repeat this process several times.

Segments (ai, bi) we can store in segment tree by position ai and value bi. Now to find segment we need we can do binary search by the value of ai and check the maximum bi value on the prefix to be at least x. This will work in O(nlog2n) time. We can improve this solution. Let's go down in segment tree in the following manner: if the maximum value bi in the left subtree of segment tree is at least x then we will go to the left, otherwise we will go to the right.

Complexity: O((n + m)log(n + m)).

Editorial of Educational Codeforces Round 2

By Edvard, history, 7 years ago, translation, In English600A - Extract Numbers

This is a technical problem. You should do exactly what is written in problem statement.

600B - Queries about less or equal elements

Let's sort all numbers in a. Now let's iterate over elements of b and for element bj find the index of lowest number that is greater than bj. We can do that using binary search. That index will be the answer for value bj.

Complexity: O(nlogn).

600C - Make Palindrome

Let's denote cntc — the number of occurences of symbol c. Let's consider odd values cntc. Palindrome can not contain more than one symbol c with odd cntc. Let's denote symbols with odd cntc as a1, a2...ak (in alphabetical order). Let's replace any one of symbols ak with symbol a1, ak - 1 with a2 and so on until the middle of a. Now we have no more than one odd symbol. If we have some let's place it in the middle of the answer. First half of answer will contain  occurences of symbol c in alphabetical order. The second half will contain the same symbols in reverse order. For example for string s = aabcd at first we will replace d by

Unable to parse markup [type=CF_TEX]

in the middle and after permuting the symbols we got abcba. Easy to see that it's the optimal solution.Compexity: O(n).

600D - Area of Two Circles' Intersection

If the circles don't intersect than the answer is 0. We can check that case with only integer calculations (simply by comparing the square of distance between centers with square of the sum of radiuses). If one of the circles is fully in other then the answer is the square of the smaller one. We can check this case also with only integer calculations (simply by comparing the square of distance between centers with square of the difference of radiuses).

So now let's consider the general case. The answer will be equal to the sum of two circular segments. Let's consider the triangle with apexes in centers if circles and in some intersecting point of the circles. In that triangle we know all three sides so we can compute the angle of the circular segment. So we can compute the square of circular sector. And the only thing that we should do now is to subtract the square of triangle with apexes in the center of circle and in the intersecting points of circles. We can do that by computing the half of absolute value of cross product. So we have the following formulas:

,

where d is the distance between centers of the circles. And also we should do the same thing with second circle by replacing of indices 1 ≤ ftrightarrow2.

 

Complexity: O(1).

600E - Lomsat gelral

The name of this problem is anagram for ''Small to large''. There is a reason for that :-) The author solution for this problem uses the classic technique for computing sets in tree. The simple solution is the following: let's find for each vertex v the ''map<int, int>'' — the number of occurences for each colour, ''set<pair<int, int>>'' — pairs the number of occurences and the colour, and the number sum — the sum of most frequent colours in subtree of v. To find that firstly we should find the same thing for all childs of v and then merge them to one. These solution is correct but too slow (it works in O(n2logn) time). Let's improve that solution: every time when we want to merge two map-s a and b let's merge the smaller one to larger simply by iterating over all elements of the smaller one (this is the ``Small to large''). Let's consider some vertex v: every time when vertex v will be moved from one map to another the size of the new map will be at least two times larger. So each vertex can be moved not over than logn times. Each moving can be done in O(logn) time. If we accumulate that values by all vertices then we get the complexity O(nlog2n).

I saw the solutions that differs from author's but this technique can be used in a lot of other problems.

600F - Edge coloring of bipartite graph

Let's denote d is the maximum degree of vertex in graph. Let's prove that the answer is d. We will build the constructive algorithm for that (it will be the solution to problem). Let's colour the edges one by one in some order. Let (x, y) be the current edge. If there exist colour c that is free in vertex x and in vertex y then we can simply colour (x, y) with c. If there is no such colour then there are a couple of colours c1, c2 so that c1 is in x and not in y and c2 is in y but not in x. Let's make vertex y free from colour c2. Denote z the other end of edge from y with colour c2. If z is free from colour c1 then we can colour x, y with c2 and recolour y, z with c1. So me make alternation. If z is not free from colour c1 let's denote w the other end of the edge from z with colour c1. If w is free from colour c2 then again we can do alternation. And so on. We will find an alternating chain because the graph is bipartite. To find the chain we can use depth first search. Each chain contains no more than O(n) vertices. So we have:

Сложность решения: O(nm).

Разбор задач Educational Codeforces Round 1

By MikeMirzayanov, 7 years ago, In RussianЗадачи учебные — постараемся сделать разбор подробным.

598A - Хитрая суммаЕсли бы в этой задаче не было бы "хитрости" и надо бы было просто найти сумму 1 + 2 + ... + n, то, воспользовавшись формулами суммирования арифметической прогрессии, можно было прийти к результату s = n·(n + 1) / 2 (числа такого вида называются треугольными).

Однако каждое число, которое является степенью двойки, должно быть просуммировано не со знаком "плюс", а со знаком "минус". Давайте вычтем по два раза (так как первое вычитание просто изымет число из суммы, а второе — вычтет) каждую из степеней двойки, которые не превосходят n. Проще всего это сделать с помощью цикла вроде этого:

long long pow2 = 1;while (pow2 <= n)    s -= pow2 * 2, pow2 *= 2;Значение s после такого цикла и будет ответом. Количество итераций этого цикла не превосходит двоичного логарифма числа n (точнее — еще плюс единица), что является числом около 30 для максимального возможного теста.

Асимптотика:  (на один тест в наборе).

598B - Запросы на строкеТак как значения ki довольно велики (до миллиарда), то попробуем найти решение, которое не моделирует все ki вращений. Очевидно, что если рассматривать k-й циклический сдвиг строки длины t, то все сдвиги, кратные t, не меняют строку. Более того, k-й циклический сдвиг строки длины t неотличим от сдвига на величину k mod t (остаток от деления k на длину t).

Таким образом, сразу после чтения очередного запроса можно заменить ki на ki mod (ri - li + 1). Далее определим результат после запроса i. Части строки до li и после ri останутся без изменения. А вот подотрезок li... ri провернётся на ki. Это значит, что вперед встанут заключительные ki символов этой подстроки, а потом — часть подстроки без заключительных ki. В итоге обработанный подотрезок будет записан так: s.substr(r - k + 1, k) + s.substr(l, r - l + 1 - k) (участок длины k от позиции на k - 1 левее r + участок длины "длина подотрезка минус k" от позиции l). Следовательно, весь запрос обрабатывается фрагментом кода:

s = s.substr(0, l)    + s.substr(r - k + 1, k) + s.substr(l, r - l + 1 - k)    + s.substr(r + 1);Конечно, в данной задаче удобнее было бы воспользоваться функцией std::rotate, от этого код стал бы только короче. Однако такой подход более С++-специфичный. Эквивалентная строка с использованием std::rotate выглядит так: rotate(s+l,s+r+1-k,s+r+1);.

Асимптотика: O(|s|·m).

598C - Ближайшие вектораНа этой задаче споткнулись очень многие участники. Некоторые даже очень опытные участники соревнований допустили ошибки. Видимо, эта задача проходит с использованием atan2 в long double на g++ (но не на Visual Studio, так как в ней long double имеет такой же размер как и double — 8 байт).

Я опишу здесь решение в целых числах, которое, безусловно, неплохо понимать и знать.

В своих решениях с несложной геометрией я люблю использовать typedef pair<T,T> pt (где T — основной тип данных для точки/вектора), одновременно с дефайнами X на first и Y на second.

Грубо говоря, план решения такой: отсортируем все вектора по полярному углу, затем переберем все пары соседних векторов и выберем такую, угол между векторами в которой минимален.

Для того, чтобы отсортировать что-либо, надо определить функцию порядка "меньше" (возвращает true тогда и только тогда, когда первый аргумент строго меньше второго).

Ниже будем использовать псевдоскалярное произведение векторов (cross(a, b) = a.X * b.Y - a.Y * b.X), которое для простоты будем называть просто векторным. Напомним, что оно равно |a|·|b|·sin(a, b), где sin(a, b) — синус ориентированного угла от первого вектора ко второму. Поэтому знак векторного произведения указывает "верно ли, что угол от первого до второго вектора меньше 180 градусов?" или (что тоже самое) "верно ли, что кратчайший способ совместить (сонаправить) первый вектор со вторым будет двигать первый вектор против часовой стрелки?". Когда величина равна 0 — это значит, что всё равно, как: то есть вектора либо сонаправлены, либо противонаправлены.

Поэтому, чтобы понять, верно ли, что при сортировке первый вектор должен предшествовать второму, почти всегда достаточно посмотреть на знак векторного произведения (больше нуля — значит, "да"). Однако это не будет работать на стыке при переходе через цикл (например, вектор (1, -1) будет определен как стоящий до вектора (1, 1)). Для этого сначала сравним полуплоскости, в которых они расположены (при Y = 0 в верхнюю полуплоскость отдадим положительное направление луча Ox). Функция top определяет "верно ли, что p лежит в верхней полуплоскости?".

bool top(pt p) {    return p.Y < 0 || p.Y == 0 && p.X < 0;}Следовательно, полностью функция "меньше" для сортировки векторов по полярному углу в целых числах выглядит так:

bool polarLess(const pt& a, const pt& b) {    bool ta = top(a);    bool tb = top(b);    if (ta != tb)        return ta;    return cross(a, b) > 0;}Теперь решим вторую подзадачу — для четырех векторов a1, b1, a2 и b2 проверить, верно ли, что угол между a1 и b1 строго меньше угла между a2 и b2.

Напомним, что неориентированный угол между векторами a и b можно получить так: представим, что мы расположили оба вектора так, что вектор a встал по направлению Ox (т.е. просто вправо). Тогда будет достаточно найти полярный угол для b (координату b.Y надо взять по модулю, так как угол неориентированный). Но вектор a не направлен вдоль Ox. Давайте найдем длину проекции b на a (это на самом деле x в системе координат, что направлена так, как нам хочется) и длину проекции b на вектор, повернутый от a на 90 градусов (перпендикулярный) влево. Длину первой проекции найти легко — это |b|·cos(a, b), а длина второй проекции — это |b|·sin(a, b). Однако, если мы возьмем просто скалярное произведение, то получим |a|·|b|·cos(a, b), а векторное — |a|·|b|·sin(a, b).

То есть вектор p = (dot(a, b), cross(a, b)) (где dot(a, b) — скалярное произведение) — это вектор, сонаправленный вектору b' (где b' — результат поворота вектора b, если одновременно вращать и b и a так, что a совпадет с Ox). Здесь хорошо бы сделать рисунок, но уже не до этого.

Таким образом, например, чтобы найти ориентированный угол между векторами (от  - π до π), достаточно взять направление вектора p; иными словами, atan2(cross(a, b), dot(a, b)). Если нужен угол неориентированный, то от векторного произведения (а это фактически координата y у вектора p) надо взять модуль.

Теперь найдем пару векторов p1 и p2, как описано выше, затем посмотрим, кто из них образует меньший полярный угол. Это можно сделать с помощью уже знакомого свойства векторного произведения.

Таким образом, полный код функции "меньше" для величины угла между векторами a1 и b1 против величины угла между векторами a2 и b2 выглядит так:

bool angleLess(const pt& a1, const pt& b1, const pt& a2, const pt& b2) {    pt p1(dot(a1, b1), abs(cross(a1, b1)));    pt p2(dot(a2, b2), abs(cross(a2, b2)));    return cross(p1, p2) > 0;}Асимптотика:  (на сортировку).

598D - Игорь в музееЗдесь надо подробнее описать, что нужно обходить поиском в глубину компоненту связности лабиринта, причем каждую не более одного раза. Во время обхода подсчитывать количество картин и хранить это прямо по индексу компоненты. Если запрос пришел про клетку, для которой уже обработали ее компоненту, то забираем ответ по номеру компоненты. Вот пример простого короткого решения 14257172.

Асимптотика: O(n·m + k) (каждая клетка обходится не более одного раза).

598E - Плитка шоколадаЗдесь надо подробнее описать динамическое программирование, которое используется в решении. В решении ниже dp[a][b][k] — ответ на задачу, если есть плитка размера a × b и надо наотламывать k долек из нее. В приведенном решении используется ленивое программирование (каждое состояние анализируется фактически не более раза с помощью поиска в глубину по состояниям) для подсчета таких значений: 14258732.

Асимптотика:  (K — оценка на k, то есть 50).

598F - Длина разрезаЭту задачу я когда-то давно подготовил на тренировку СГУ. Ее сдали несколько наших сильных участников (возможно, в дорешку): Nerevar, e-maxx, RAD, stan, NALP. По результатам взломов — все их решения оказались неверными! Участники Educational Codeforces Round 1 добавили отличные тесты!

Вот короткое решение одного из участников раунда (и эффективного взломщика): 14258627.

Асимптотика:  (для обработки одной прямой нужна сортировка всех точек пересечения её и многоугольника).

ЗаключениеЯ буду рад дать права на пост тому, кто поможет перевести разборы или улучшит наброски разборов по задачам D-F. Спасибо!



