Editorial of Codeforces Round #700

By liouzhou_101, history, 2 years ago, In EnglishUPD: Solutions are added.

1480A - Yet Another String Game

Tutorial1480A - Yet Another String GameAfter some observations, we can see that the players should always choose the most significant letter to change, because it coordinates the lexicographical order of the final string most. Therefore, Alice will choose all odd indices while Bob will choose all even indices, and then Alice will change all letters she choose to the smallest possible letters while Bob will change all letters he choose to the largest possible letters. That is, Alice will change letters to "a" if the original letter is not "a" and to "b" otherwise; Bob will change letters to "z" if the original letter is not "z" and to "y" otherwise.

The time complexity is O(n).

Solution1480B - The Great Hero

Tutorial1480B - The Great HeroThe hero needs ⌈bi/A⌉ attacks to kill the i-th monster, and he will obtain ⌈bi/A⌉ai damage after that.

Suppose the k-th monster is the last monster killed by the hero. Then the health value of the hero before the last attack ishk=B− n∑i=1 ⌈biA ⌉ai+ak.All monsters can be killed if and only if maxk{hk}>0. This can be checked in O(n) time.

Solution1479A - Searching Local Minimum

Tutorial1479A - Searching Local MinimumWe maintain by binary search a range [l,r] which has a local minimum. Moreover, we assume that al−1>al and ar<ar+1. Initially, [l,r]=[1,n].

In each iteration, let m be the midpoint of l and r.

Case 1. If am<am+1, then the range becomes [l,m].

Case 2. If am>am+1, then the range becomes [m+1,r].

When l=r, we have found a local minimum al.

The number of queries to ai is at most 2⌈log2n⌉≤34<100.

Solution1479B1 - Painting the Array I

Tutorial1479B1 - Painting the Array IFormally, for every sequence a1,a2,…,an, and we assume that a1,a2,…,an are positive integers, the number of segments in a is defined to beseg(a)= n∑i=1 [ai−1≠ai],where a0=0, and [Boolean expression]=1 if the Boolean expression is true and 0 otherwise.

Let's restate the problem as

Problem. Given a sequence a1,a2,…,an, divide it into two disjoint subsequences s and t such that seg(s)+seg(t) is as large as possible.

Solution. We will construct two disjoint subsequences by scanning through the sequence a1,a2,…,an.

Initial setting: s and t are two empty sequences, and a1,a2,…,an remains not scanned.

Move on: Suppose the last elements of s and t are x and y, respectively, and x=0 (resp. y=0) if s (resp. t) is empty. Let z be the current element scanning through a1,a2,…,an. Our greedy strategy is described in two cases:

Greedy Strategy I: If z equals to one of x and y, then assign z to the opposite subsequence. That is, if z=x, then append z after y; and if z=y, then append z after x. In particular, if z equals to both x and y, the assignment could be arbitrary.Greedy Strategy II: If z differs from both x and y, then append z after the one with the nearest next same value. That is, let next(x) denote the next position where x appears in a1,a2,…,an after z, then append z after x if next(x)<next(y), and after y otherwise.The greedy strategy is intuitive, and with this strategy, an O(n) algorithm is immediately obtained. However, its proof turns out to be complicated. We append its proof for completeness.

An Intuitive Proof

Consider any optimal assignment b1,b2,…,bn, we will show that our strategy is not worse than it. Let a[l…r]=al,al+1,…,ar be the subarray of a.

Now suppose we are at some position p, where the optimal assignment conflicts with our strategy. We assume that s=(a[1…p])(0)=s′x ends with x, and t=(a[1…p])(1)=t′y ends with y, and ap+1=z.

Greedy Strategy I: If b conflicts with Greedy Strategy I, then we must have x≠y and without loss of generality, we assume that x=z. Greedy Strategy I suggests we append z after y but b suggests we append z after x. Suppose b results in the two subarrays  s′xzs′′t′yt′′ , while there is indeed another optimal assignment that agrees with our strategy and results in  s′xt′′t′yzs′′ .

Greedy Strategy II: If b conflicts with Greedy Strategy II, then we must have x, y and z are distinct and without loss of generality, we assume that the next occurrence of x goes in front of that of y. Greedy Strategy II suggests we append z after x but b suggests we append z after y. Suppose b results in the two subarrays  s′xs′′t′yzt′′ . Consider two cases.

Case 1. If s′′ does not start with y, then there is another optimal assignment that agrees with our strategy and results in  s′xzt′′t′ys′′ .

Case 2. If s′′ starts with y, i.e. s′′=ys1, then since the first occurrence of x is in front of that of y, we have that x must be in t′′, and assume that t′′=t1xt2. The result of b is restated as  s′xys1t′yzt1xt2 . We find that there is another optimal assignment that agrees with our strategy and results in  s′xzt1ys1t′yxt2  (Note that t1 does not contain any x or y in it).

A Formal Proof

The number of alternations in a sequence a starting with x is defined to besegx(a)= n∑i=1 [ai−1≠ai],where a0=x. We note that seg0(a)=seg(a).

Let fx,y(a) denote the maximal possible sum of numbers of alternations in the two disjoint subsequences s and t of a, i.e.fx,y(a)= maxs,t {segx(s)+segy(t)},where s and t ranges over all possible pairs of disjoint subsequences of a. It is obvious that the order of x and y does not matter, i.e. fx,y(a)=fy,x(a). We note that our goal is to compute f0,0(a).

Let next(x) denote the least index k such that ak=x, i.e. next(x)=min{k∈N:ak=x}. In case no such index k exists, next(x) is defined to be ∞.

In fact, our problem can be solved by DP regardless of the time complexity.

Proposition 1 (Dynamic Programming). For n≥1 and every x,y∈N,fx,y(a1,a2,…,an)=max{fa1,y(a2,…,an)+[a1≠x],fx,a1(a2,…,an)+[a1≠y]}.In particular, for empty sequence ϵ, we have fx,y(ϵ)=0.We can obtain some immediate properties of fx,y(a) by the above DP recurrence.

Proposition 2. For every x,y∈N, fx,0(a)≥fx,y(a)≥fx,x(a). Moreover, if next(y)=∞, then fx,0(a)=fx,y(a).

After some observations, we have

Proposition 3. For every x,y,z∈N and sequence a, fz,x(a)+1≥fz,y(a).

Proof: By induction on the length n of sequence a.

Basis. It is trivial for the case n=0 since the left hand side is always 1 and the right hand side is always 0.

Induction. Suppose true for the case n=k(k≥0), i.e.fz,x(a)+1≥fz,y(a)holds for every sequence a of length k. Now consider a sequence a1,a2,…,ak+1 of length k+1.

Case 1. x=y. It is trivial that fz,x(a)+1≥fz,x(a).

Case 2. z=x≠y. We should prove that fx,x(a)+1≥fx,y(a). By Proposition 1, we need to prove that{ fa1,x(a2,…,ak+1)+[a1≠x]+1≥fa1,y(a2,…,ak+1)+[a1≠x],fa1,x(a2,…,ak+1)+[a1≠x]+1≥fx,a1(a2,…,ak+1)+[a1≠y]. The second inequality is obvious. The first inequality becomesfa1,x(a2,…,ak+1)+1≥fa1,y(a2,…,ak+1),which holds by induction.

Case 3. x≠y=z. We should prove that fx,y(a)+1≥fx,x(a). By Proposition 1, we only need to prove thatfx,a1(a2,…,ak+1)+[a1≠y]+1≥fa1,x(a2,…,ak+1)+[a1≠x],which is obvious.

Case 4. x≠y,z≠x and z≠y. By Proposition 1, fz,x(a)+1≥fz,y(a) is equivalent tomax{fa1,x(a2,…,ak+1)+[a1≠z],fz,a1(a2,…,ak+1)+[a1≠x]}+1≥max{fa1,y(a2,…,ak+1)+[a1≠z],fz,a1(a2,…,ak+1)+[a1≠y]}. Case 4.1. a1=z. The left hand side becomesmax{fz,x(a2,…,ak+1),fz,z(a2,…,ak+1)+1}+1=fz,z(a2,…,ak+1)+2by induction that fz,z(a2,…,ak+1)+1≥fz,x(a2,…,ak+1). The right hand side becomesmax{fz,y(a2,…,ak+1),fz,z(a2,…,ak+1)+1}=fz,z(a2,…,ak+1)+1by induction that fz,z(a2,…,ak+1)+1≥fz,y(a2,…,ak+1). The inequality holds immediately.

Case 4.2. a1=x. The left hand side becomesmax{fx,x(a2,…,ak+1)+1,fz,x(a2,…,ak+1)}+1=fx,x(a2,…,ak+1)+2by induction that fx,x(a2,…,ak+1)+1≥fz,x(a2,…,ak+1). The right hand side becomesmax{fx,y(a2,…,ak+1)+1,fz,x(a2,…,ak+1)+1}.By induction that fx,x(a2,…,ak+1)+1≥fx,y(a2,…,ak+1)+1 and fx,x(a2,…,ak+1)+1≥fx,z(a2,…,ak+1)+1, the inequality holds.

Case 4.3. a1=y. The left hand side becomesmax{fy,x(a2,…,ak+1)+1,fz,y(a2,…,ak+1)+1}+1.The right hand side becomesmax{fy,y(a2,…,ak+1),fz,y(a2,…,ak+1)+1}=fz,y(a2,…,ak+1)+1by induction that fy,y(a2,…,ak+1)+1≥fz,y(a2,…,ak+1)+1. The inequality immediately holds as fz,y(a2,…,ak+1) appears in both sides (and can be eliminated together).

Case 4.4. a1∉{x,y,z}. The left hand side becomesmax{fa1,x(a2,…,ak+1)+1,fz,a1(a2,…,ak+1)+1}+1.The right hand side becomesmax{fa1,y(a2,…,ak+1)+1,fz,a1(a2,…,ak+1)+1}.By induction that fa1,x(a2,…,ak+1)+1≥max{fa1,y(a2,…,ak+1),fa1,z(a2,…,ak+1)}, the inequality holds.

The inequality holds for all cases. Therefore, the inequality holds for n=k+1.

Conclusion. The inequality holds for every n≥0. ◻Proposition 4. Suppose a1,a2,…,an is a sequence. For every distinct x,y,z∈N, i.e. x≠y,y≠z and z≠x, if next(x)<next(y), then fz,y(a)≥fz,x(a).

Proof: By induction on the length n of sequence a.

Basis. It is trivial for the case n=0 since the both hand sides are 0.

Induction. Suppose true for the case n=k(k≥0), i.e.fz,y(a)≥fz,x(a).holds for every sequence a of length k. Now consider a sequence a1,a2,…,ak+1 of length k+1.

Case 1. a1=z. By Proposition 1 and 3, the left hand side becomesmax{fz,y(a2,…,ak+1),fz,z(a2,…,ak+1)+1}=fz,z(a2,…,ak+1)+1,and the right hand side becomesmax{fz,x(a2,…,ak+1),fz,z(a2,…,ak+1)+1}=fz,z(a2,…,ak+1)+1The inequality holds immediately.

Case 2. a1=x. By Proposition 1, the left hand side becomesmax{fx,y(a2,…,ak+1)+1,fz,x(a2,…,ak+1)+1},and the right hand side becomesmax{fx,x(a2,…,ak+1)+1,fz,x(a2,…,ak+1)}.By Proposition 2, we havefz,x(a2,…,ak+1)≥fx,x(a2,…,ak+1),and therefore, the inequality holds.

Case 3. a1=y. This is impossible because next(x)<next(y), i.e. there is an element of value x in front of the first element of value y.

Case 4. a1∉{x,y,z}. The left hand side becomesmax{fa1,y(a2,…,ak+1)+1,fa1,z(a2,…,ak+1)+1}.The right hand side becomesmax{fa1,x(a2,…,ak+1)+1,fa1,z(a2,…,ak+1)+1}.Case 4.1. If next(y)>next(z), then by induction we havefa1,y(a2,…,ak+1)≥fa1,z(a2,…,ak+1),and (because next(y)>next(x), )fa1,y(a2,…,ak+1)≥fa1,x(a2,…,ak+1).The inequality holds.

Case 4.2. If next(y)<next(z), then by induction we havefa1,z(a2,…,ak+1)≥fa1,y(a2,…,ak+1),and (because next(z)>next(y)>next(x), )fa1,z(a2,…,ak+1)≥fa1,x(a2,…,ak+1).The inequality holds.

The inequality holds for all cases. Therefore, the inequality holds for n=k+1.

Conclusion. The inequality holds for every n≥0.

Proposition 5 (Greedy Strategy I). Suppose a1,a2,…,an is a sequence. For every x,y∈N, if a1=x, thenfx,y(a1,…,an)=fx,x(a2,…,an)+1.Proof: By Proposition 1, we havefx,y(a1,…,an)=max{fx,y(a2,…,an),fx,x(a2,…,an)+1}.By Proposition 3, we havefx,x(a2,…,an)+1≥fx,y(a2,…,an).Combining with the both above yields the proof. ◻Proposition 6 (Greedy Strategy II). Suppose a1,a2,…,an is a sequence. For every x,y∈N with x≠y, if a1∉{x,y}, thenfx,y(a1,…,an)={ fa1,y(a2,…,an)+1	next(x)<next(y),fx,a1(a2,…,an)+1	otherwise. Proof: If next(x)<next(y), by Proposition 4, we havefa1,y(a2,…,an)≥fx,a1(a2,…,an).Therefore, by Proposition 1, we have fx,y(a1,…,an)=fa1,y(a2,…,an)+1.

The same statement holds for next(x)>next(y). ◻Solution1479B2 - Painting the Array II

Tutorial1479B2 - Painting the Array IIThere are two approaches from different perspectives.

DP Approach

The first observation is that merging adjacent elements with the same value will not influence the answer. Therefore, without loss of generality, we may assume that there are no adjacent elements with the same value, i.e. ai≠ai+1 for every 1≤i<n.

We can solve this problem by a DP approach. Let f(i) denote the minimal possible number of segments for sub-array a1,a2,…,ai over all assignments b1,b2,…,bi with bi≠bi−1, where b0=−1 for convenience. To obtain the answer, we enumerate the last position 1≤i≤n such that bi−1≠bi, and append all elements ai+1,ai+2,…,an to the end of ai, which implies an arrangement with f(i)+n−i segments. The minimal number of segments will be the minimum among f(i)+n−i over all 1≤i≤n.

It is straightforward to see that f(0)=0 and f(1)=1.

For 2≤i≤n, f(i) can be computed by enumerating every possible position 1≤j<i such that bj−1≠bj=bj+1=⋯=bi−1≠bi. That is, aj,aj+1,…,ai−1 are assigned to the same sub-sequence, and aj−1 and ai are assigned to the other sub-sequence. Since no adjacent elements has the same value (by our assumption), there are (i−j) segments in aj,aj+1,…,ai−1 (we note that the first segment, i.e. the segment of aj, is counted in f(j)). Moreover, there will be zero or one new segment when concatenating aj−1 and ai depending on whether aj−1=ai or not. Hence, for every 2≤j≤n, we havef(i)= min1≤j<i {f(j)+(i−j−1)+[aj−1≠ai]},where [Boolean expression]=1 if the Boolean expression is true and 0 otherwise. Here, we obtain an O(n2) DP solution.

To optimize the DP recurrence, we fix i, and let g(j)=f(j)+(i−j−1)+[aj−1≠ai], then f(i)=max1≤j<i{g(j)}. We can observe that

Lemma 1. For 2≤i≤n, we havef(i)=min{g(i−1),g(j∗)},where j∗=max{1≤j<i:aj−1=ai}, max∅=0, and g(0)=+∞.

This lemma is very intuitive, which means we need only to consider two cases: one is to just append ai after ai−1 in the same sub-sequence, and the other is to append ai after the closest aj with the same value, i.e. ai=aj, and then assign the elements between them (not inclusive) to the other sub-sequence. With this observation, we immediately obtain an O(n) DP solution.

The proof is appended below for completeness.

Proof: For every 1≤j<i, we havef(i)≤g(j)=f(j)+(i−j−1)+[aj−1≠ai]≤f(j)+i−j,which implies that f(i)−i≤f(j)−j for every 1≤j≤i≤n.

Now we consider g(j) for every 1≤j<i in two cases.

aj−1≠ai. We haveg(j)	=f(j)+(i−j−1)+1=f(j)−j+i≥f(i−1)−(i−1)+i=f(i−1)+1≥g(i−1). aj−1=ai. Suppose there are two different positions j1 and j2 such that 1≤j1<j2<i and aj1−1=aj2−2=ai, theng(j1)	=f(j1)+(i−j1−1)=f(j1)−j1+i−1≥f(j2)−j2+i−1=g(j2). Combine the two cases, we conclude that f(i)=min{g(i−1),g(j∗)}, where j∗=max{1≤j<i:aj−1=ai}. ◻Greedy Approach

Consider we have a computer whose cache has only two registers. Let's suppose the array a is a sequence of memory access to the computer. The problem is then converted to a more intuitive one that asks the optimal cache replacement.

Suppose the current two registers contains two memory accesses x and y, and the current requirement memory access is z.

The greedy strategy is simple: If z matches one of x and y, just do nothing. Otherwise, the register that contains the memory access whose next occurrence is farther than the other will be replaced by z.

This strategy is know as Bélády's algorithm or farthest-in-the-future cache/page replacement policy (see here for more information). The complexity is O(n) since we only need to preprocess every element's next occurrence.

Solution1479C - Continuous City

Tutorial1479C - Continuous CityThe answer is always "YES". For convenience, we write (x,y,z) for a directed road from block x to block y of length z.

Step 1. We can solve the case L=1 and R=2k for k≥0 inductively. The case for k=0 is trivial, i.e. only one edge (1,2,1).

Suppose there is a city of k+2 blocks for L=1 and R=2k for some k≥0, and the induced city from block 1 to block x is (1,2x−2)-continuous for every 2≤x≤k+2. Let block k+3 be a new block, and add (1,k+3,1) and (x,k+3,2x−2) for 2≤x≤k+2. We can see that the new city containing block k+3 is (1,2k+1)-continuous.

Step 2. Suppose L=1 and R>1. Let R−1=∑ki=0Ri2i be the binary representation of R−1, where 0≤Ri≤1. Let Gk be the (1,2k)-continuous city constructed in Step 1. Let block k+3 be a new block. Connect (1,k+3,1), and then for every 0≤i≤k, if Ri=1, then connect (i+2,k+3,1+∑kj=i+1Rj2j). We can see that the new city containing block k+3 is (1,R)-continuous.

Step 3. Suppose 1<L≤R. Consider HR−L+1, where HR denotes the (1,R)-continuous city constructed in Step 2 and there are k blocks in HR−L+1. Connect (k,k+1,L−1). We can see that the new city containing block k+1 is (L,R)-continuous.

We note that there is at most 23 blocks in our constructed city.

Solution1479D - Odd Mineral Resource

Tutorial1479D - Odd Mineral ResourceLet s(u,v,c) denote the number of cities between city u and city v, whose mineral resource is c. We restate the problem that for each query u,v,l,r, find an integer c such that l≤c≤r and s(u,v,c)≢0(mod2).

We give a randomized algorithm with success probability extremely high. For every kind of mineral resources 1≤i≤n, we assign a random variable Xi to it. Those random variables Xi are independent and identically uniformly distributed from [0,264−1]. For every city u, we assign its weight to be Xcu.

For every query u,v,l,r, Let f(u,v,l,r) be the bitwise XOR of all weights of all cities between city u and city v, whose mineral resources are in [l,r]. We claim that

Pr[f(u,v,l,r)=0∣∀c,s(u,v,c)≡0(mod2)]=1, which means that if a suitable c does not exist then f(u,v,l,r)=0 for certainty, andPr[f(u,v,l,r)≠0∣∃c,s(u,v,c)≢0(mod2)]=1−2−64, which means that if a suitable c does exist then f(u,v,l,r)≠0 with high probability.Let's consider the reverse thatPr[∀c,s(u,v,c)≡0(mod2)∣f(u,v,l,r)=0]=1−2−64, which implies with high probability no suitable mineral resource exists if f(u,v,l,r)=0, andPr[∃c,s(u,v,c)≢0(mod2)∣f(u,v,l,r)≠0]=1, which implies with certainty at least one suitable mineral resource exists.According to the above discussion, our strategy isto report no solution if f(u,v,l,r)=0, andto find a c (l≤c≤r) such that f(u,v,c,c)≠0 if f(u,v,l,r)≠0.Our strategy will succeed with probability p≥1−2−64.Now consider there are q queries. Let Ai denote the event that the i-th query succeeds. The i-th query will succeed with probability Pr[Ai]≥1−2−64 (however, they may not be independent). Then we havePr[ q⋀i=1 Ai]	=1−Pr[ q⋁i=1  ˉA i]≥1− q∑i=1 Pr[ ˉA i]=1− q∑i=1 (1−Pr[Ai])≥1− q∑i=1 (1−(1−2−64))=1−2−64q, which means all queries succeed simultaneously with probability at least 1−2−64q≥1−2−44 if q≤220, which is high enough under constraints of the problem.

To this end, we shall compute f(u,v,l,r) and find a c (l≤c≤r) such that f(u,v,c,c)≠0. This can be solved by consistent segment trees. Let's root the tree (by any vertex, say vertex 1). For every vertex u, we maintain a (consistent) segment tree that for each interval [l,r] computes f(1,u,l,r). Let father(u) be the father of vertex u, and lca(u,v) be the least common ancestor of vertex u and vertex v. Thenf(u,v,l,r)=f(1,u,l,r)⊕f(1,v,l,r)⊕f(1,lca(u,v),l,r)⊕f(1,father(lca(u,v)),l,r).For more details, please according to SPOJ COT. Therefore, we have solved this problem with high enough probability in O(nlogn) time and space.

Solution1479E - School Clubs

Tutorial1479E - School ClubsSection 1. The Expected Value of Stopping Time

There may be several ways to deal with the expected value of stopping time. Here, we decide to give an elegant way to derive the expected stopping time inspired by MiFaFaOvO's comment. Here, we are going to introduce the mathematical tool we will use in the following description (see here for a Chinese explanation.)

Consider a random process A0,A1,A2,…, where Ai is called the i-th event of the process, or the event at time i. Let random variable T∈N be its stopping time. That is, for every t∈N, It can be decided whether T=t as long as A0,A1,…,At are given. If there is a function ϕ(⋅) that maps an event to a real number such that

E[ϕ(At+1)−ϕ(At)∣A0,A1,…,At]=−1 for every t∈N, andE[ϕ(AT)] depends on some properties of the events and the stopping time, which is usually a constant in practice.Let Xt=ϕ(At)+t, then E[Xt+1−Xt∣A0,A1,…,At]=0. That is, X0,X1,X2,… is a martingale of A0,A1,…. By the optimal stopping theorem, under some ignorable conditions, we have that E[XT]=E[X0]. Therefore, E[T]=E[ϕ(A0)−ϕ(AT)]. Moreover, if ϕ(AT) is a constant, thenE[T]=ϕ(A0)−ϕ(AT).We will use the above identity to find the expected value of T, the stopping time. Usually, ϕ(⋅) is called the potential function.To begin our journey, we should first describe an event as something (a number, a tuple, a sequence, or a set) in our problem. We find it naturally to use a (multi-)set A={a1,a2,…,am} to describe it, where m denotes the number of clubs, the i-th of which contains ai students. We see that the explicit order of the clubs does not matter but the number of students in each club. Furthermore, we notice that every club's status is equal, which implies us to define the potential function as the formϕ(A)= ∑a∈A f(a)= m∑i=1 f(ai),where m=|A|. It should be noted that the sum of elements in A is a constant, so we letn= ∑a∈A a= m∑i=1 ai.We first consider the corner case for the value of f(0). Since students will never join an empty club, A and A∪{0} denotes the events with the same property. Therefore, we need ϕ(A)=ϕ(A∪{0}), which immediately yields f(0)=0.

We now investigate how the potential function behaves from the t-th event At={a1,a2,…,am} to the (t+1)-th event At+1. We note that the student who gets angry is in the i-th club with probability ain . After that, the angry student will

leave and create a new club with probability 12 . In this case, At+1={a1,a2,…,ai−1,ai−1,ai+1,…,am,1}, and we haveϕ(At+1)=ϕ(At)−f(ai)+f(ai−1)+f(1),join the j-th club (j≠i) with probability aj2n . In this case, At+1={a1,a2,…,ai−1,aj+1,…,am}, and we haveϕ(At+1)=ϕ(At)−f(ai)−f(aj)+f(ai−1)+f(aj+1),stay still in the i-th club with probability ai2n . In this case, At+1=At, and we haveϕ(At+1)=ϕ(At).To sum it up, we get thatE[ϕ(At+1)∣At]= m∑i=1 ain [	12 (ϕ(At)−f(ai)+f(ai−1)+f(1))+ ∑j≠i aj2n (ϕ(At)−f(ai)−f(aj)+f(ai−1)+f(aj+1))+ai2n ϕ(At)]. Let E[ϕ(At+1)−ϕ(At)∣A0,A1,…,At]=−1, and then we obtain thatf(1)+ m∑i=1 ain2 [(2n−ai)f(ai−1)+(n−ai)f(ai+1)−(3n−2ai)f(ai)]+2=0.Here, we need to find a function f(⋅) that satisfies the above condition with the corner case f(0)=0.

There are several possible ways to assign the value of f(a). We choose the most simple one such that f(1)+2=0, which removes the constant term. Under this assignment, we have f(1)=−2. After this, we have to make that(2n−a)f(a−1)+(n−a)f(a+1)−(3n−2a)f(a)=0,i.e.(n−a)[f(a+1)−f(a)]=(2n−a)[f(a)−f(a−1)].holds for every a.

We let g(a)=f(a+1)−f(a) for a≥0. Therefore, g(0)=f(1)−f(0)=−2, andg(a)	=2n−an−a g(a−1)=2n−an−a ⋅2n−(a−1)n−(a−1) g(a−1)=…=2n−1n−1 ⋅2n−2n−2 ⋅⋯⋅2n−an−a g(0). We find thatf(a)	=f(0)+g(0)+g(1)+⋯+g(a−1)=−2[1+P(1)Q(1) +P(2)Q(2) +⋯+P(1)P(2)…P(a−1)Q(1)Q(2)…Q(a−1) ], where P(x)=2n−x and Q(x)=n−x. If we can compute f(a) in an efficient way, then the problem is solved. However, it seems not so straightforward.

Section 2. The Trick for the Prefix Sum by Generating Functions

For convenience, we denoteS(a)=P(1)Q(1) +P(2)Q(2) +⋯+P(1)P(2)…P(a)Q(1)Q(2)…Q(a) ,where P(x) and Q(x) are linear functions (polynomials of degree 1). To compute S(a), we use the trick mentioned in min_25's blog. However, the trick we adopt here can deal with more general cases.

Let N>a be a large enough positive integer. Then we haveS(a)=1Q(1)Q(2)…Q(N) [	P(1)Q(2)Q(3)…Q(a)Q(a+1)…Q(N)+P(1)P(2)Q(3)…Q(a)Q(a+1)…Q(N)+⋯+P(1)P(2)P(3)…P(a)Q(a+1)…Q(N)]. We only have to compute the inner sum s(a)=S(a)Q(1)Q(2)…Q(N). We now use the SQRT trick here. Let B≈√N be the block size. LetR(z)=	P(z+1)Q(z+2)Q(z+3)…Q(z+B)+P(z+1)P(z+2)Q(z+3)…Q(z+B)+⋯+P(z+1)P(z+2)P(z+3)…P(z+B). Then we will see thats(a)=	 ⌊a/B⌋∑k=0 P(1)…P(kB)R(kB)Q((k+1)B+1)…Q(N)+ a∑i=(⌊a/B⌋+1)B+1 P(1)…P(i)Q(i+1)…Q(N). It is more convenient to let P(k)=P(1)…P(kB) and Q(k)=Q(kB+1)…Q(N), then the main summation in s(a) is written as⌊a/B⌋∑k=0 P(k)R(kB)Q(k+1).Now, we have three values needed, which are R(z),P(k),Q(k).

Compute R(z)

We deal with R(z) first. We note that R(z) is a polynomial of degree B and we want to compute R(kB) for every 0≤k≤N/B. If we can obtain the values of R(0),R(1),…,R(B), then by Lagrange interpolation, we can recover the polynomial R(z). And then, if we know the exact polynomial R(z), then by multi-point evaluation trick, we can compute the values of R(kB) for every k≤N/B. The total time complexity would be O(√Nlog2N).

We can compute R(0) in O(B) time. And then, we note thatR(z)=Q(z+B)P(z) R(z−1)−Q(z+1)…Q(z+B)+P(z+1)…P(z+B).Therefore, R(1),…,R(B) can be computed in O(B) time if we simultaneously maintain the values of block product of P(⋅) and Q(⋅) in the above identity.

Bonus: A "log" in the complexity may be eliminated by some trick similar to min_25's blog?

Compute P(k)

This subproblem is very similar to compute the factorial-like product, which is originally mentioned in min_25's blog. To solve it, we definefP(z)=P(z+1)P(z+2)…P(z+B).Then P(k)=fP(0)fP(B)…fP((k−1)B). What we need is to compute fP(kB) fast enough. We also note that fP(z) is a polynomial of degree B. We can easily find the values of fP(0),fP(1),…,fP(B) in O(B) time. Therefore, the values of fP(kB) can be obtained by Lagrange interpolation and multi-point evaluation. In particular, we are able to compute P(1)P(2)…P(N) in this way, which is considered to be a general factorial.

compute Q(k)

This subproblem is more tricky if we are able to compute P(k) fast. Similarly, we define fQ(z) as what we did when computing P(k). Let Q′(k) be the prefix block products of Q(x) as an analog for P(k) and P(x). It can be easily seen thatQ(k)=Q(1)Q(2)…Q(N)Q′(k) .Having computed all values we need in the previous several sections, we are able to compute the value of a single f(a) in O(√N) time. Therefore, the overall complexity is O(√Nlog2N+m√N).

Bonus: Saving logn in Complexity

Moreover, we can save logn in complexity with an improved interpolation method for shifting evaluation values. See the paper "A. Bostan, P. Gaudry, and E. Schost, Linear recurrences with polynomial coefficients and application to integer factorization and Cartier-Manin operator. SIAM Journal of Computing, 36(6): 1777–1806. 2007".

Shifting evaluation values

Suppose given are a polynomial f(x) of degree d by a point-value representation f(0),f(1),…,f(d) and a shift δ. It is asked to compute an alternative point-value representation f(δ),f(δ+1),…,f(δ+d). A straightforward way to solve this problem is to directly make use of Lagrange interpolation and multi-point evaluation, which yields an O(dlog2d) arithmetic complexity algorithm. In fact, we can do it better in O(dlogd) time.

Recall the formula of Lagrange interpolation that given n points (xi,yi) where yi=f(xi), then the unique polynomial of degree (n−1) isf(x)= n∑i=1 yi ∏j≠i x−xjxi−xj .Rewrite this formula in our case that f(0),f(1),…,f(d) are given, thenf(x)= d∑i=0 f(i) ∏j≠i x−ji−j .We assume that δ,δ+1,…,δ+d do not overlap with 0,1,…,d, then for 0≤k≤d, we havef(δ+k)	= d∑i=0 f(i) ∏j≠i δ+k−ji−j =( d∏j=0 (δ+k−j))( d∑i=0 (−1)d−if(i)i!(d−i)! ⋅1δ+k−i ). The summation can be computed by FFT. Consider two polynomials:A(x)= d∑i=0 (−1)d−if(i)i!(d−i)! xi,B(x)= 2d∑i=0 1δ+i−d xi.We havef(δ+k)=( d∏j=0 (δ+k−j))[xd+k]A(x)B(x).Therefore, f(δ),f(δ+1),…,f(δ+d) can be computed in O(dlogd) time.

Arithmetic sequence shifting

Now we consider a modified version: given a polynomial of degree d by a point-value representation f(0),f(s),f(2s),…,f(ds) and a shift δ, compute f(δ),f(δ+s),f(δ+2s),…,f(δ+ds).

The trick is to let g(x)=f(xs), which is also a polynomial of degree d. Then the problem becomes: given g(0),g(1),…,g(s) and a shift δ′=δ/s, compute g(δ′),g(δ′+1),…,g(δ′+d).

Divide and conquer

Let's consider how to compute R(z). For convenience, we denote thatRB(z)=	P(z+1)Q(z+2)Q(z+3)…Q(z+B)+P(z+1)P(z+2)Q(z+3)…Q(z+B)+⋯+P(z+1)P(z+2)P(z+3)…P(z+B), PB(z)=P(z+1)P(z+2)…P(z+B),QB(z)=Q(z+1)Q(z+2)…Q(z+B),where B indicates the number of elements in the product. We need to compute the values ofRB(0),	RB(s),	…,	RB(sB),PB(0),	PB(s),	…,	PB(sB),QB(0),	QB(s),	…,	QB(sB). To compute these values recurrently, we should notice thatR2B(z)=RB(z)QB(z+B)+PB(z)RB(z+B),P2B(z)=PB(z)PB(z+B),Q2B(z)=QB(z)QB(z+B).We choose P2B(z) as an example. Here we need to computeP2B(0)	=PB(0)PB(B),P2B(s)	=PB(s)PB(s+B),…,P2B(sB)	=PB(sB)PB(sB+B),P2B(sB+1)	=PB(sB+1)PB(sB+B+1),…,P2B(2sB)	=PB(2sB)PB(2sB+B). There are 4B values of PB(z) that are needed, which arePB(0),	PB(s),	…,	PB(sB),PB(B),	PB(B+s),	…,	PB(B+sB),PB(sB),	PB(sB+s),	…,	PB(sB+sB),PB(B+sB),	PB(B+sB+s),	…,	PB(B+sB+sB). The first line is our target and the rest three lines can be obtained by shifting the first line by B, sB and B+sB, respectively. Let T(d) be the complexity where d is the degree of our polynomials, thenT(d)=T(d/2)+O(dlogd).Hence, T(d)=O(dlogd).

In our case, d=O(√N), then the complexity is reduced to O(√NlogN+m√N).

Conclusion

We use the trick, SQRT decomposition, to split summations into blocks, and then use Lagrange interpolation and multi-point evaluation to compute the value in each block. We obtain an algorithm with complexity O(√Nlog2N+m√N).

A more subtle trick to save a logN is obtained by the shifting technique, which yields a faster algorithm with complexity O(√NlogN+m√N). The constant factor of Lagrange interpolation and multi-point evaluation is very large, so this approach to save a logN brings a significant improvement.

However, we allow suboptimal solutions that directly use Lagrange interpolation and multi-point evaluation to get AC.

Credits

Some related problems:

Stopping time: 1349D, 850F, 1025G.Generating function: SPOJ FACTMODP, CodeChef QPOLYSUM, 1349F2.Solution

Codeforces Round #699 (Div. 2) Editorial

By El3ageed_Abu_Shehab, history, 2 years ago, In English1481A - Space NavigationHint 1: You can think of this problem as 2 independent 1D questions (one is up and down , and the other is left and right) instead of 1 2D question.

Hint 2: For each 1D part what is the interval of positions that you can reach and see if the end point is in this interval.

Hint 3: The interval of up and down is [-The count of D , The count of U] and the interval of left and right is [-The count of L , The count of R].

codeAuthor: Salem_Alwarawreh

1481B - New ColonyThe two key observation here is that if one boulder fall into the collection system all later boulders will fall into the collection system too and the number of boulders that will end up at any mountain is too small (Hence it will be at most (n−1)⋅(100−1)).

So we can simulate all boulders throwing until one boulder fall into the collection system, this will take at most O(100⋅n).

codeAuthor: Warawreh

1481C - Fence PaintingWe must first see that the most important painter is the last one (and he will paint plank x where bx=cm) because of two reasons: when he paints plank x it won't be changed and if some other painter have a color that we don't need we can make him paint plank x, which will be repainted later.

Now we need to find x where bx=cm, there are three options:

bx≠ax.bx=ax.There are no bx=cm this case is impossible and the answer is "NO".If the first two are true we choose x such that bx≠ax, then we greedily distribute all painters j (1≤j<m) such that:

There is plank i such that bi=cj and bi≠ai then the jth painter will paint plank i (as a result the color of the ith plank will be changed).There is no plank i such that bi=cj and bi≠ai then the jth painter will paint plank x.At the end there might be some planks that didn't end up as we want so we make a last liner check on all planks i and check if bi=ai, the total time is O(n).

codeAuthor: El3ageed_Abu_Shehab

Preperation: Warawreh

1481D - AB GraphIf you can find any two nodes x, y such that the edge going from x to y has the same value as the edge going from y to x, then the answer is obviously YES.

If not, if m is odd you can just choose any two nodes x and y and keep going y→x→y→x→y→x→y until you have a string with length m, because any alternating string of odd length is a palindrome.

If m is even than you should check if there is two consecutive edges with the same value, that is you need to find three different nodes x, y and z such that the edge x→y has the same value as the edge y→z. Otherwise any string you can get will be an alternating string and any alternating string with even length is not a palindrome (note that for (n≥3) it is always possible to find these three nodes).

After finding nodes x y, z a way that guarantees you can generate a palindrome string is:

if m2 is odd just keep moving x→y→z→y→x→y→z until you have a string of length m.



The string will look like aabbaabb...aabbaa which is palindrome.

if m2 is even then keep moving y→z→y→x→y→z→y until you have a string of length m.



The string will look like abbaabba...abba which is palindrome.

Complexity O(n2+m).

codeAuthor: El3ageed_Abu_Shehab

1481E - Sorting BooksLets try to solve the opposite version of the problem where you want to find the maximum number of books that will stay unmoved, so we will choose number of books that will stay unmoved and then move the rest in a way that will make the shelf beautiful.

To do that lets first for each color c find the leftmost and rightmost occurrence lc and rc and the frequency of this color fc.Then we will use dpi which will find for each i the maximum number of books that we can leave unmoved in the suffix [i,n].

We will go from right to left and for each index i the dp will work as follow :

If i=lai, we leave all occurrences of color ai unmoved and move everything in between the first and last occurrence of color ai, so between lai and rai only books with color ai will stay unmoved, we can see that this will be only true if we are at the first occurrence of color ai (when i=lai because we want to cover the segment [lai,rai]), as a result dpi=fai+dprai+1.If i≠lai, we can keep all books with color ai in range [i,n] unmoved and move everything else, as a result dpi=cfai where cfai is the number of books with color ai in range [i,n] (we can update this array as we move) (note that here we move all books even those after rai).In either cases we can move the book ai and get dpi=dpi+1.The answer will be n−dp1 and the time is O(n).

codeAuthor: Warawreh

1481F - AB Treelet the diameter of the tree (the maximum distance between a root and a leaf) be d, then the answer couldn't be less than d+1 because you will add strings of all lengths between 1 and d+1.

In order to have the answer d+1, you need all strings with the same length to be equal, so all nodes on the same level must have the same character. Let's define an array a of size d+1, such that ai = (number of nodes at level i). So if the answer is d+1 there must exist a subset from a with sum x, so we assign character a to all the nodes with a level belongs to that subset, and character b to all other nodes.

To check if there is a subset with sum x we can use dynamic programming, the complexity of this solution is O(x⋅(d+1)), which is in worst case O(n2).

But since the sum of array a is equal to n, the number of unique values in a will be at most n−−√, so lets have an array of size at most n−−√ having every value with it's frequency. Now let dp[i][j] be true if it is possible to find a subset with sum j in the suffix i. So to check if dp[i][j] is true or not we need to check dp[i+1][j−val[i]],dp[i+1][j−2⋅val[i]]...,dp[i+1][j−freq[i]⋅val[i]], in another way we need to find a value k such that dp[i+1][j−k⋅val[i]] is true and (k≤freq[i]), so for every j let's find the minimum possible k, if dp[i+1][j] is true then kj will be equal to 0, otherwise it is equal to kj−val[i]+1.

So this way we can check if the answer is d+1 in O(n⋅n−−√).

Now if the answer is not d+1, then it is d+2. To find the answer let's start from level 0 to level d, when you are at level i let the number of remaining nodes be m (the number of nodes with depth greater than or equal to i) and you have y remaining a's you can still use.

If ai is not greater than y or not greater than m−y, you can assign all nodes on the current level with the same character and move on to the next level.

If not then you will have to use the two characters on the current level so you are going to add at least one more string on the answer. If you have two nodes on the same level having the same character but the nodes have different prefixes, then the strings will not be considered equal, so to guarantee not adding more than one string to the answer later on, you should make sure to assign the same character to all non-leaf nodes on the current level.

Now if we have l non-leaf nodes then l must be less than or equal to m2, because every non-leaf node should have at least one more node in it's sub tree, and we know that for any value y (m2≤max(y,m−y)), so it is possible to assign the same character to all non-leaf nodes, after assigning all non-leaf nodes with the same character make sure to finish all the remaining copies of this character on the current level so you guarantee on the next levels all nodes will be the same.

This way only one string will be added on the current level so the answer will be d+2.

Total complexity is O(n⋅n−−√)codeAuthor: El3ageed_Abu_Shehab

Editorial of Codeforces Round #698 (Div.1, Div.2)

By Nezzar, history, 2 years ago, In EnglishThanks for joining us today! Here is the editorial for today's problems:

1478A - Nezzar and Colorful Balls

Tutorial1478A - Nezzar and Colorful BallsFor positions which numbers are the same, they cannot be colored using same color.

Let us color the i-th occurrence of any number using color i.

We can see that:

We cannot use fewer colors: if there are k occurrence of any number, at least k color is needed.The assignment of color is valid: Since the sequence was non-increasing, for any subsequence it is also non-increasing. As there are no duplicates in colored subsequence, the subsequence is strictly increasing as well.Therefore, we only need to count the number of occurrence of every number and take the maximum of them.

Time complexity: O(n) per test case

Solution1478B - Nezzar and Lucky Number

Tutorial1478B - Nezzar and Lucky NumberFor any given d, We can observe the following:

10d to 10d+9 contains d as one of its digitLet k=10d+9 be the upper bound of such range For every number x>k, we can keep reducing x by d, x will eventually fall into the range mentioned above, which contains d as digit.Therefore, for numbers x>k, they are always achievable. For x≤k−10, as k<=109, we can run a standard knapsack dynamicprogramming solution, where dp[x] indicates if x is achievable. dp[x] is achievable, if and only if one of the following is true:

x=0For some y<x, dp[y] is true and x−y contains d as digitIterating for every x, all dp[x] for x<k can be computed with O(k) per state (as we only need to consider y<k.

Besides dynamic programming solution, brute force solutions with enough optimization should also pass the test cases easily.

Time complexity: O((10d)2) per test case.

Solution1478C - Nezzar and Symmetric Array

Tutorial1478C - Nezzar and Symmetric ArrayWLOG, we may assume that 0<a1<a2<…<an, and ai+n=−ai for each 1≤i≤n.

Let's sort array d firstly. It can be observed that the array d satisfied the following property:

d2i−1=d2i for each 1≤i≤n;d2i≠d2i+2 for each 1≤i<n.d2i must be generated for index i or i+n.More importantly, we have the following relation:d2n−d2n−2= n∑i=1 (an−ai)+ n∑i=1 (an+ai)− n∑i=1 |an−1−ai|− n∑i=1 (an−1+ai)=(2n−2)(an−an−1)And observe that |ai−an|+|ai+an|=2an is a constant independent of index 1≤i≤n. Therefore, we may remove an and −an by subtracting some constant for di for all 1≤i≤2(n−1), indicating that we will calculate ai+1−ai for all 1≤i<n, which can be done in O(n).

Lastly, we should determine if there exists an postivie integer a1 which generates d1, which can be done in O(n).

Solution1477A - Nezzar and Board

Tutorial1477A - Nezzar and BoardLet's first assume that x1=0 (Otherwise, we could subtract x1 for x1,x2,…,xn and k). We will now prove that the answer is "YES" if and only if k can be divided by g=gcd(x2,x3,…,xn).

One direction is straightforward. Note that any number written on the board should be divisible by g, which follows from the fact that g|x,g|y⟹g|2x−y. It only remains to prove that for any x divisible by g, we could write down x on the board. We will prove it by induction on n.

Base case (n=2) is obvious. Let g0=gcd(x2,x3,…,xn−1). By Bézout's Theorem, there exists integers s,t such that g0s−xnt=g. By induction, we could write down g0 on the board, and trivially xnt can be written on the board. Therefore, we could write down g applying operation recursively.

Solution1477B - Nezzar and Binary String

Tutorial1477B - Nezzar and Binary StringThe operations can be described backward:

Iterate days in reverse order and start with f. In i-th day, if there is a strict majority of 0s or 1s between li and ri, change ALL element inside the range to be the majority. Otherwise, declare that the operation failed.We can see that the "backward" operation is deterministic, so we can compute the source string from destination string alone and check if the source string computed equal to s.

To simulate the operations, We need to support two kind of operations:

range query on sum, andrange assignmentWhich can be simulated using e.g. lazy segment tree.

Time complexity: O((q+n)logn)Solution1477C - Nezzar and Nice Beatmap

Tutorial1477C - Nezzar and Nice BeatmapThere are two different approaches to solve this task.

Furthest Points

Pick an arbitrary point, and in each iteration, select the furthest point from previously chosen point among all available points. Indeed, we can prove the correctness by contradiction.

Insertion Sorting

Notice that in any triangle (possibly degenerate), there exists at most one obtuse angle or right angle in this triangle. Therefore, we may build our permutation using modified version of insertion sort (it suffices to substitute comparing operator).

We believe that time complexity for the latter approach is better than O(n2). However, we fail to find a proof or counterexample for it. It would be grateful if someone could figure it out and inform us about it!

Solution1477D - Nezzar and Hidden Permutations

Tutorial1477D - Nezzar and Hidden PermutationsWe can describe the problem in graph theory terms:

We are given a graph $$$G$$$ of $$$n$$$ vertices and $$$m$$$ edge. The $$$i$$$-th edge connects vertices $$$l_i$$$ and $$$r_i$$$. We need to write down two numbers on each vertices, on $$$i$$$-th vertex we write $$$p_i$$$ and $$$q_i$$$ on it, so that:

$$$p$$$ and $$$q$$$ forms a permutation from $$$1$$$ to $$$n$$$,For each edge $$$(u,v)$$$, the relative order between $$$p_u$$$ and $$$p_v$$$ must be the same as between $$$q_u$$$ and $$$q_v$$$.We want to maximize the number of vertices $$$u$$$, so that $$$p_u \neq q_u$$$.We can observe the following:

For any vertex $$$u$$$ with degree $$$n-1$$$, $$$p_u = q_u$$$.Proof: For such vertex $$$u$$$, let $$$p_u = k$$$. Then, there are exactly $$$k - 1$$$ neighbors of $$$u$$$ that has its $$$p$$$-number smaller than $$$u$$$. Similarly, let $$$q_u = k'$$$. Then, there are exactly $$$k' - 1$$$ neighbors of $$$u$$$ that has its $$$q$$$-number smaller than $$$u$$$. Since the relative order between $$$u$$$ and its neighbors must be the same across $$$p$$$ and $$$q$$$, $$$k' - 1 = k - 1$$$, which leads to $$$k' = k$$$.

We can assign those numbers with any unused number and delete them from the graph. Now we will consider only vertices with degree $$$< m-1$$$, where $$$m$$$ is the number of remaining vertices. We claim that the maximum number of differing position to be exactly $$$m$$$.

As all vertices have degree $$$< m-1$$$, it is easier to consider the complement graph $$$G'$$$, where $$$(u,v)$$$ in $$$G'$$$ is connected if and only if $$$(u,v)$$$ is not connected in $$$G$$$. Notice that $$$G'$$$ consists of connected components and each vertex has at least one neighbor.

We will focus on a single connected component. Let us find any spanning tree of this particular component. If the spanning tree is astar, Let the center of star be $$$u$$$ and the other vertices be $$$v_1, v_2, \cdots v_k$$$. Then, the following is a valid assignment:

$$$p_u = 1, q_u = k + 1$$$$$$p_{v_i} = i + 1, q_{v_i} = i$$$ for $$$1 \leq i \leq k$$$Otherwise, we claim that we can decompose any tree into different connected stars with at least two nodes each. If we can do so, we can assign numbers $$$1, 2, \cdots k_1$$$ to first star with $$$k_1$$$ nodes, $$$k_1 + 1, k_1 + 2, \cdots k_1 + k_2$$$ to second star with $$$k_2$$$ nodes and so on. Notice that the relative order between nodes of different stars never change.

The remaining part is to decompose tree into stars. There are a lot of algorithms to do so, one of them would be:

Iterate all unassigned nodes. For any unassigned node $$$u$$$,If any neighbors of $$$u$$$ are unassigned, assign $$$u$$$ to be the center of new star component along with all unassigned neighbors of $$$u$$$.Otherwise, notice that all neighbors of $$$u$$$ is now a non-center member of some star component. Pick up any of $$$u$$$'s neighbor, $$$v$$$. If the star component of $$$v$$$ has at least two non-center nodes, remove $$$v$$$ from its original star component and make node $$$u$$$ and node $$$v$$$ a star component centered at $$$u$$$. Otherwise, make $$$v$$$ to be the center of its star component and add $$$u$$$ to it.We can see that the algorithm produces star components of at least two nodes each, and therefore we can apply the assignment of numbers to each stars individually and concat the results. In the end, all nodes will have their $$$p$$$ and $$$q$$$ assigned differently.

It is possible to find all the needed spanning tree in $$$O((n + m) \log n)$$$ time. Then, it takes $$$O(n)$$$ total time to compute answers for all trees. Therefore, time complexity is $$$O((n + m) \log n)$$$.

Solution1477E - Nezzar and Tournaments

Tutorial1477E - Nezzar and TournamentsLet's firstly consider a simplified problem where the scoring device will not reset to $$$0$$$. For any player, his score will be fully determined by his potential as well as the potential of first player when $$$k$$$ is fixed. Indeed, similar property still holds in our setting.

Observation 1. For any fixed arrangement of players with potentials $$$c_1,c_2,\ldots,c_{n+m}$$$, $$$score_i=k-c_1+c_i+\max(0,c_1-k-\min(c_1,c_2,\ldots,c_i))$$$, where $$$score_i$$$ is the score of the $$$i$$$-th player.

Observation 2. If the first player is fixed, it is optimal to place players in second team in descending order of potentials, then place all players in ascending order of potentials.

Let $$$f(t)$$$ be the difference where $$$a_x=t$$$ is selected as the first, and others ordered optimally (and $$$g(t)$$$ for sequence $$$b$$$ similarly). With some calculation, we may get $$$$$$f(t) = (n-1) \max(0,t-k-\min) - \sum_{i=1}^m \max(0,t-k-b_i) + (m-n) t + C$$$$$$ where $$$\min$$$ is the minimum value among $$$a$$$ and $$$b$$$, and $$$C$$$ is a universal constant(similarly for $$$g$$$).

Suppose that we have an oracle of $$$f$$$, we are aiming to find out the maximum value of $$$f(t)$$$ over sets of values $$$\{a_1,a_2,\ldots,a_n\}$$$. It can be seen that maximum values can only be reached on $$$O(1)$$$ inputs (which can be found in $$$O(\log n)$$$ time). For better understanding, you may refer to the following figure.

Here is a figure for $$$n=3$$$, $$$m=3$$$, $$$k=2$$$, $$$\min=4$$$, $$$b_1=6, b_2=8$$$ and $$$b_3=10$$$. It can be seen that in this configuration, function is monotone increasing when $$$t<10$$$ and decreasing after. It can be shown that $$$f$$$ acts similarly.Therefore, it only remains to calculate $$$f$$$ for any given input $$$t$$$ efficiently, which can be decomposed to the following queries.

minimum value over $$$a_i$$$, $$$b_i$$$.$$$\sum_{1 \le i \le m} \max(0,k-t-b_i)$$$ for given $$$k$$$.All those can be done efficiently via segment tree.

Solution1477F - Nezzar and Chocolate Bars

Tutorial1477F - Nezzar and Chocolate BarsLet's firstly solve an easier version where n=1.

Part 1 (n=1)

Let's firstly rephrase the original task and solve it for case n=1.

- Let pk the probability of event that X(i)−X(i−1)≤K for 1≤i≤k and L−X(k)≤K. Here, k real numbers X1,X2,…,Xk are chosen uniformly from (0,L), and X(1),X(2),…,X(k) is the sorted array of X0=0,X1,X2,…,Xk. Then the disire answer would be ∑+∞k=0(1−pk).

To simplify notations, denote w=KL . We are aiming to calculate pn from now on.

Let Zi=X(i)−X(i−1)，then the pdf(probability density function) of the union distribution of Z1,Z2,…,Zn is

f(z1,z2,…,zn)=n!I0<zi<1,∑ni=1zi<1Hence,

pn=n!∫0<zi<w,1−w<∑ni=1zi<11dz1dz2…dzn=n!wn∫0<zi<1,1w −1<∑ni=1zi<1w 1dzConsider Y1,Y2,…,Yn i.i.d, where Yi follows uniform distribution sampling from (0,1)，then the integral above is Pr[1w −1<∑ni=1Yi<1w ]。

Note that ∑ni=1Yi follows Irwin–Hall distribution whose CDF(cumulative distribution function) isF(x)=1n! ⌊x⌋∑k=0 (−1)k(nk )(x−k)nThus，pn=n!wn(F(1w )−F(1w −1))。

pn=1−( x∑k=0 (−1)k(nk )(1−wk)n− x−1∑k=0 (−1)k(nk )(1−(k+1)w)n)= x∑k=1 (−1)k−1((nk )+(nk−1 ))(1−kw)nwherex=[1w ]。

using identity ∑n≥k(nk )xn=xk(1−x)−(k+1) to finish this task.

Main version

To avoid confusion, we will let qm,j the probability that m operations are performed on line j but there still exists lines produced by line j with length greater or equal to K (which have been calculated in part 1, with notation pn).

Recall that qm,j=∑⌊LjK ⌋k=1(−1)k−1(m+1k )(1−kKLj )m.

Therefore, probability pm that one fails to finish the task within m rounds is1− ∑j1+j2+…+jn=m m!j1!j2!…jn! n∏r=1 (1−qjr,r)(LjL )jrLet Qj be EGF of sequence ((1−qm,r)Lj/L)m≥0, that is to say the m-th coefficient is[xm]Qj=1m!L (1−qm,r)Lj.Similarly, let P be EGF of sequence (pm)m≥0, one may observe thatP=exp(x)− n∏i=1 Qi.In the following part, we will calculate Qj.

Qj	= ∑m≥0 1m! (LjL − ⌊LjK ⌋∑k=1 (−1)k−1(m+1k )(1−kKLj )m)xm=exp(LjL x)− ⌊LjK ⌋∑k=1 (−1)k−1 ∑m≥k−1 (m+1)k!(m+1−k)! (Lj−kKL )mxm Note that ∑m≥k−1m+1k!(m+1−k)! ym=∑m≥kymk!(m−k)! +∑m≥k−1kymk!(m+1−k)! =ykk! exp(y)+yk−1(k−1)! exp(y). Therefore,

Qj	=exp(LjL x)− ⌊LjK ⌋∑k=1 (−1)k−1(1k! (Lj−kKL )kxk+1(k−1)! (Lj−kKL )k−1xk−1)exp((Lj−kK)xL ) Note that with NTT and above equalities, we may calculate coefficient of P in O(nLlognL) (Precisely, we will calculate coefficient of xk−jexp(1−KL kx) for each 0≤k≤L and 0≤j≤min(n,k)).

Lastly, we should notice that if EGF of sequence a is xkexp(Cx), then ak+n=(k+n)!n! Cn, and its OGF is k!∑n≥0(n+kk )Cnxn+k=k!(x/C)k(1−Cx)k+1 . Hence, we will be able to calculate OGF P′ of sequence pm, and answer is exactly P′(1).

It should be noticed that our approach will run in O(nLlognL) implemented appropriately , where L=∑ni=1li. However, larger time limit is set to allow suboptimal solution to pass(like O(nL2) or O(n2LlogL)).

Solution

Codeforces Round #697 (Div. 3) Editorial

By Stepavly, 2 years ago, translation, In English1475A - Нечетный делитель

Problem authors: Stepavly, Supermagzzz

Editorial1475A - Odd DivisorIf the number x has an odd divisor, then it has an odd prime divisor. To understand this fact, we can consider what happens when multiplying even and odd numbers:

even ∗ even = even;even ∗ odd = even;odd ∗ even = even;odd ∗ odd = odd.There is only one even prime number — 2. So, if a number has no odd divisors, then it must be a power of two. To check this fact, for example, you can divide n by 2 as long as it is divisible. If at the end we got 1, then n — the power of two.

Bonus: You can also use the following condition to check:n&(n−1)=0. If the number — is a power of two, then it contains only one unit in the binary notation. Then (n−1) contains units in all positions except the one in which the unit in n is located. So their bitwise "AND" does not contain units.

Solution1475B - Новогоднее число

Problem author: MikeMirzayanov

Editorial1475B - New Year's NumberLet x — the number of 2020, y — the number of 2021 (x,y≥0). Let us write the required decomposition of the number n:n=2020⋅x+2021⋅y=2020⋅(x+y)+yThen we get that n−y is divisible by 2020. Take y equal to the remainder of n divided by 2020. Then x is uniquely determined from the formula above:x=n−y2020−yThen, if the result is that x≥0 (y≥0 because the remainder of dividing n by 2020 is non-negative), then n can be represented as the sum of a certain number of 2020 and a certain number of 2021.

Solution1475C - Бал в Берляндии

Problem authors: Stepavly, Supermagzzz

Editorial1475C - Ball in BerlandWe can think that it is given a bipartite graph. Boys and girls are the vertices of the graph. If a boy and a girl are ready to dance together, then an edge is drawn between them. In this graph, you need to select two edges that do not intersect at the vertices.

Let deg(x) — the number of edges included in the vertex x.

Iterate over the first edge — (a,b). It will block deg(a)+deg(b)−1 of other edges (all adjacent to vertex a, to vertex b, but the edge (a,b) will be blocked twice. All non-blocked edges do not intersect with (a,b) at the vertices. So you can add k−deg(a)−deg(b)+1 to the answer.

Solution1475D - Очистка телефона

Problem authors: Stepavly, Supermagzzz

Editorial1475D - Cleaning the PhoneLet's say we remove x applications with bi=1 and y applications with bi=2. Obviously, among all the applications with bi=1, it was necessary to take x maximum in memory (so we will clear the most memory).

Let's split all the applications into two arrays with bi=1 and bi=2 and sort them. Then you need to take a prefix from each array.

Let's iterate over which prefix we take from the first array. For it, we can uniquely find the second prefix (we remove applications until the sum exceeds m). If we now increase the first prefix by taking a new application, then we don't need to take any applications in the second array. This means that when the first prefix is increased, the second one can only decrease.

To solve the problem, you can use the two-pointer method.

Solution1475E - Рекламное агентство

Problem authors: Stepavly, Supermagzzz

Editorial1475E - Advertising AgencyIt is obvious that Masha will enter into agreements only with bloggers that have the most subscribers. You can sort all the bloggers and greedily select the prefix.

Let x — be the minimum number of subscribers for the hired blogger. Then we must hire all the bloggers who have more subscribers. Let m — the number of bloggers who have more than x subscribers, cnt[x] — the number of bloggers who have exactly x subscribers. Then we should select k−m bloggers from cnt[x]. The number of ways to do this is equal to the binomial coefficient of cnt[x] by k−m.

You could calculate it by searching for the inverse element modulo. Then you could calculate the factorials and use the equality (nk)=n!k!⋅(n−k)!.

Alternatively, you can use the equation (nk)=(n−1k)+(n−1k−1) and calculate it using dynamic programming. This method is better known as the Pascal triangle.

Solution1475F - Необычная матрица

Problem authors: Stepavly, Supermagzzz

Editorial1475F - Unusual MatrixIt is clear that the order of operations does not affect the final result, also it makes no sense to apply the same operation more than once (by the property of the xor operation). Let's construct a sequence of operations that will reduce the matrix a to the matrix b (if the answer exists). Let's try iterate over: will we use the operation "horizontal xor".

Now, by the each element of the first line (a1,j), we can understand whether it is necessary to apply the operation "vertical xor" (if a1,j≠b1,j). Let's apply all necessary operations "vertical xor". It remains clear whether it is necessary to apply the operation "horizontal xor" for i (2≤i≤n). Let's look at each element of the first column (ai,1) by it you can understand whether it is necessary to apply the operation "horizontal xor" (if ai,1≠bi,1).

Solution1475G - Странная красота

Problem author: MikeMirzayanov

Editorial1475G - Strange BeautyLet's calculate for each number x how many times it occurs in the array a. Let's denote this number as cntx.

Let's use the dynamic programming method. Let dp(x) be equal to the maximum number of numbers not greater than x such that for each pair of them one of the conditions above is satisfied. More formally, if dp(x)=k, then there exists numbers b1,b2,…,bk (bi≤x) from the array a such that for all i≠j (1≤i,j≤k) one of the conditions above is satisfied.

Then to calculate dp(x) you can use the following formula:dp(x)=cnt(x)+maxy=1,xmody=0x−1dp(y).

Note that to calculate dp(x) you need to go through the list of divisors of x. For this, we use the sieve of Eratosthenes.

Solution

Codeforces Round #697 (Div. 3) Editorial

By Stepavly, 2 years ago, translation, In English1475A - Нечетный делитель

Problem authors: Stepavly, Supermagzzz

Editorial1475A - Odd DivisorIf the number x has an odd divisor, then it has an odd prime divisor. To understand this fact, we can consider what happens when multiplying even and odd numbers:

even ∗ even = even;even ∗ odd = even;odd ∗ even = even;odd ∗ odd = odd.There is only one even prime number — 2. So, if a number has no odd divisors, then it must be a power of two. To check this fact, for example, you can divide n by 2 as long as it is divisible. If at the end we got 1, then n — the power of two.

Bonus: You can also use the following condition to check:n&(n−1)=0. If the number — is a power of two, then it contains only one unit in the binary notation. Then (n−1) contains units in all positions except the one in which the unit in n is located. So their bitwise "AND" does not contain units.

Solution1475B - Новогоднее число

Problem author: MikeMirzayanov

Editorial1475B - New Year's NumberLet x — the number of 2020, y — the number of 2021 (x,y≥0). Let us write the required decomposition of the number n:n=2020⋅x+2021⋅y=2020⋅(x+y)+yThen we get that n−y is divisible by 2020. Take y equal to the remainder of n divided by 2020. Then x is uniquely determined from the formula above:x=n−y2020−yThen, if the result is that x≥0 (y≥0 because the remainder of dividing n by 2020 is non-negative), then n can be represented as the sum of a certain number of 2020 and a certain number of 2021.

Solution1475C - Бал в Берляндии

Problem authors: Stepavly, Supermagzzz

Editorial1475C - Ball in BerlandWe can think that it is given a bipartite graph. Boys and girls are the vertices of the graph. If a boy and a girl are ready to dance together, then an edge is drawn between them. In this graph, you need to select two edges that do not intersect at the vertices.

Let deg(x) — the number of edges included in the vertex x.

Iterate over the first edge — (a,b). It will block deg(a)+deg(b)−1 of other edges (all adjacent to vertex a, to vertex b, but the edge (a,b) will be blocked twice. All non-blocked edges do not intersect with (a,b) at the vertices. So you can add k−deg(a)−deg(b)+1 to the answer.

Solution1475D - Очистка телефона

Problem authors: Stepavly, Supermagzzz

Editorial1475D - Cleaning the PhoneLet's say we remove x applications with bi=1 and y applications with bi=2. Obviously, among all the applications with bi=1, it was necessary to take x maximum in memory (so we will clear the most memory).

Let's split all the applications into two arrays with bi=1 and bi=2 and sort them. Then you need to take a prefix from each array.

Let's iterate over which prefix we take from the first array. For it, we can uniquely find the second prefix (we remove applications until the sum exceeds m). If we now increase the first prefix by taking a new application, then we don't need to take any applications in the second array. This means that when the first prefix is increased, the second one can only decrease.

To solve the problem, you can use the two-pointer method.

Solution1475E - Рекламное агентство

Problem authors: Stepavly, Supermagzzz

Editorial1475E - Advertising AgencyIt is obvious that Masha will enter into agreements only with bloggers that have the most subscribers. You can sort all the bloggers and greedily select the prefix.

Let x — be the minimum number of subscribers for the hired blogger. Then we must hire all the bloggers who have more subscribers. Let m — the number of bloggers who have more than x subscribers, cnt[x] — the number of bloggers who have exactly x subscribers. Then we should select k−m bloggers from cnt[x]. The number of ways to do this is equal to the binomial coefficient of cnt[x] by k−m.

You could calculate it by searching for the inverse element modulo. Then you could calculate the factorials and use the equality (nk)=n!k!⋅(n−k)!.

Alternatively, you can use the equation (nk)=(n−1k)+(n−1k−1) and calculate it using dynamic programming. This method is better known as the Pascal triangle.

Solution1475F - Необычная матрица

Problem authors: Stepavly, Supermagzzz

Editorial1475F - Unusual MatrixIt is clear that the order of operations does not affect the final result, also it makes no sense to apply the same operation more than once (by the property of the xor operation). Let's construct a sequence of operations that will reduce the matrix a to the matrix b (if the answer exists). Let's try iterate over: will we use the operation "horizontal xor".

Now, by the each element of the first line (a1,j), we can understand whether it is necessary to apply the operation "vertical xor" (if a1,j≠b1,j). Let's apply all necessary operations "vertical xor". It remains clear whether it is necessary to apply the operation "horizontal xor" for i (2≤i≤n). Let's look at each element of the first column (ai,1) by it you can understand whether it is necessary to apply the operation "horizontal xor" (if ai,1≠bi,1).

Solution1475G - Странная красота

Problem author: MikeMirzayanov

Editorial1475G - Strange BeautyLet's calculate for each number x how many times it occurs in the array a. Let's denote this number as cntx.

Let's use the dynamic programming method. Let dp(x) be equal to the maximum number of numbers not greater than x such that for each pair of them one of the conditions above is satisfied. More formally, if dp(x)=k, then there exists numbers b1,b2,…,bk (bi≤x) from the array a such that for all i≠j (1≤i,j≤k) one of the conditions above is satisfied.

Then to calculate dp(x) you can use the following formula:dp(x)=cnt(x)+maxy=1,xmody=0x−1dp(y).

Note that to calculate dp(x) you need to go through the list of divisors of x. For this, we use the sieve of Eratosthenes.

Solution

Codeforces Round #695 (Div. 2) Editorial

By DS007, 2 years ago, In EnglishMany thanks to infinitepro, BledDest and alimq for helping me write the editorials.

1467A - Wizard of OrzIf there is only one panel, then pause it when digit 9 appears on it. You cannot do any better than that.

Otherwise, it is always optimal to pause the second panel from left, when the digit 8 appears on it. This would give an answer of the form 98901234567890123456…. You can verify that this is the largest number that can be achieved.

Solution

1467B - Hills And ValleysChanging the value of ai affects the hill/valley status of only elements {ai−1,ai,ai+1}. We claim that it is optimal to change ai to either ai−1 or ai+1 for valid i (1<i<n).

Let x be a value of ai such that the number of hills/valleys among elements {ai−1,ai,ai+1} is minimised. Now, if x<max(ai−1,ai+1), we can set x:=min(ai−1,ai+1) without changing any non-hill/non-valley element to a hill/valley. Similarly, if x>min(ai−1,ai+1) we can set x:=max(ai−1,ai+1). Hence proved.

The final solution is as follows. Precompute the number of hills and valleys in the original array. Then, for every valid index i, calculate the change in the number of hills/valleys of the elements {ai−1,ai,ai+1} on setting ai:=ai−1 and ai:=ai+1 and update the minimum answer accordingly.

Solution

1467C - Three BagsModel the problem as a rooted tree (graph). There are n1+n2+n3 nodes, corresponding to the elements from the three bags. Edges between two nodes represent an operation on the two elements and it can be seen that an edge can exist only between nodes of elements from different sets. A directed edge from b to a means that b is removed and a is replaced to a−b. All edges are directed towards the root.

In the given rooted tree, operations are applied bottom up, that is, an operation is applied on a leaf node and its parent, and the leaf node is removed. The process is continued until only the root node is remaining.

It is easy to see that the value of the element at the end of all operations is the sum of elements at even depth minus the sum of elements at odd depth (depth is 0 indexed).

Claim: The constructed rooted tree is valid, if the elements at odd depth are

1. are from at least two different bags, or

2. contain all elements from one bag.

Proof:

Consider a rooted tree with all elements at odd depth from exactly one bag (say X) which doesn't fulfil criteria 2. No remaining elements from bag X can be connected to the nodes at odd depth, making it impossible to construct a tree. This implies that 1 must hold.

However, if criteria 2 holds, no elements from bag X remain to be connected, and thus the tree can be constructed.

Hence proved.

Now, we have to minimise either of the two cases, which is the solution to the problem.

For the first case, we can choose the two smallest numbers such that they both appear in different bags to be at odd depth.

For the second case, we can choose all numbers from the bag where the sum of the numbers is minimum to be at odd depth.

Solution

1467D - Сумма путейThe main idea of the problem is to calculate the contribution of each cell to the answer.

Let cnti denote the sum of the number of times cell i appears in all good paths of length k. Then the answer is equal to a1∗cnt1+a2∗cnt2+⋯+an∗cntn. We shall use dynamic programming to calculate these values.

Let dpi,j denote the number of good paths of length j that end at cell i. Then, dpi,0=1 for all i such that 1≤i≤n. Further, for all i such that 1≤i≤n and for all j such that 1≤j≤k, dpi,j can be calculated as dpi,j=dpi−1,j−1+dpi+1,j−1 because we can move to cell i from either cell i−1 or cell i+1. Handle the cases where i=1 and i=n separately to avoid out-of-bounds error.

Observe that dpi,j is also equal to the number of good paths of length j that start at cell i.

Let ai,j denote the number of times cell i appears after exactly j moves in all valid paths of length k. Well ai,j=dpi,j∗dpi,k−j because we can split a path of length k into two paths of length j and length k−j, with the first path ending at cell i and the second path starting at cell i.

Since cnti denotes the sum of the number of times cell i appears in all good path of length k, cell i can appear after exactly 0,1,2,…,k moves. This means that cnti=∑kj=0ai,j.

Extending the solution to account for updates is easy once we have calculated these values.

Solution

1467E - Различающие корниRoot the tree arbitrarily. Consider any node v. Let us remove v from the tree and examine the trees that will be created in the resultant forest.

Let's say that a particular tree was attached to v through node u. Further, let's say that this tree has some node x satisfying av=ax. Then clearly, if any distinctive root exists, it must be in this component, because if it were in any other component, then, when you root the tree at that node, you will get a path from the root containing both v and x. Let us add a directed edge from v to u, signifying that all distinctive roots must be in this particular component.

Once we have repeated this for all nodes, we now have a set of directed edges. All distinctive roots must have each of these edges pointing to it. We can check this for all nodes using the rerooting technique. Link cut tree or difference array works as well.

Note: In order to check the number of nodes x which occur in a subtree, do a pre-order traversal of the tree. Create a map which maps a value b to the dfs-in times of all nodes i that satisfy ai=b. Now, two lower-bounds on this shall tell us the number of occurrences in the subtree in logarithmic time. Also, with this information, you can also calculate the number of times x occurs in the tree attached to v's parent.

Solution

UPD: Also, have a look at this comment for an explanation of the sample test case of C.

Codeforces Round #694 Editorial

By IgorI, history, 2 years ago, In English1471A - Strange PartitionNote that, ⌈a+bx⌉≤⌈ax⌉+⌈bx⌉. It means that the maximal sum is attained if we do not apply any operations, and the minimal one is attained if we replace all the element with a single one, equal to the sum of all elements.

1471B - Strange ListSolution 1. Let's represent each element ai as xbi⋅ci, where bi is the maximal possible. Let's take minimum over all values bi, and let's assume it's attained at position j. The robot will add each element to the array bj times (element at position j will be the first one, which will stop being divisible by x). However, we should not forget about the prefix before position j: each of those number is divisible by a higher power of x, and this prefix will count towards the total sum. The final answer is (bj+1)⋅∑ni=1ai+∑j−1i=1aiIn this solution we divide each number ai by x to generate the array b1,b2,…,bn, and then it takes O(n) to compute both sums. The final complexity of the solution is O(nlogA), where A denotes the maximum possible element of the array.

Solution 2. Let's maintain the list of pairs {ai,cnti} — it indicates a range of cnti elements equal to ai. Then we can easily implement the operation performed by the robot: if we consider pair {a,cnt}, we either append the array with a pair {ax,cnt⋅x}, or terminate the process. The answer to the problem equals to sum of values ai⋅cnti.

Each number ai will be copied to the end of the array at most O(logA) times, since each time ai is divided by x. Since there are n elements in the array initially, the total complexity of this solution is O(nlogA).

1470A - Strange Birthday PartyLet's note that it is beneficial to give cheaper gifts to people with a larger ki value.

Suppose that in the optimal answer a pair of people A and B, such that kA≥kB get gifts with values a≥b. Then we can give a gift b to a person A and to a person B give a gift a or min(a,ckB) dollars. If a≤ckB, than we spend the same amount of money. Otherwise, it's a better answer.

So the problem can be solved using greedy algorithm. Let's sort guest in order of descending value ki. Than give each person a cheapest gift, or cki dollars, if it better. To determinate a cheapest gift, let's store the index of the last purchased gift. Thus, the final asymptotics is O(mlogn).

1470B - Strange DefinitionIt is well known that lcm(x,y)=x⋅ygcd(x,y), and it immediately follows that lcm(x,y)gcd(x,y) = x⋅ygcd(x,y)2, which means that numbers x and y are adjacent if and only if x⋅y is a perfect square.

Let alphax be the maximum possible integer such that palphax divides x, and alphay be the maximum possible integer such that palphay divides y. Then x⋅y is perfect square if and only if αx+αy is even, which means αx≡αy (mod 2).

Let x=pα11⋅…⋅pαkk. Let's replace it with pα1mod21⋅…⋅pαkmod2k. After such a replacement two integers are adjacent if and only if they are equal.

Let's replace each element of the array and split the numbers into classes of equal numbers. If the number of integers in a single class is even, after a single operation each element from this class will be transformed to 1, and if the number of integers is odd, the class of the element will remain unchanged. Since the class of integer 1 always remains unchanged, all integers will keep their classes starting from after the first operation.

Since di denotes the size of the class, the beauty of the array is defined as the size of the maximal class. If a if the size of the maximal class at the beginning of the process, and b — the total number of elements with a class of even size or with the class equal to 1. Then for a query with w=0 the answer is a, for a query with w>0 the answer is max(a,b).

This solution can easily be implemented with O(nlogA) complexity, where A denotes the maximum number in the array.

1470C - Strange ShuffleShort version: note that, during the first n2 iterations the number of people with more than k cards, increases. Let's find at least one such person. To do this, let's wait for n−−√ iterations. After this there is always a continuous segment of length n−−√ with elements >k. To find it, we can split the array into blocks of size n−−√, ask one element from each block, and find the desired integer >k. Then we can use binary search to find the position p. In total we need 2n−−√+logn queries.

More detailed version: let's use induction to prove that players that are located from the same distance from the player p always have 2k cards in total. It is obviously true initially. After one operation, when the array a is transformed to the array b, and let's consider a pair of elements located on the same distance from position p: i and j. Note that, bi+bj=(⌈ai−12⌉+⌊ai+12⌋)+(⌈aj−12⌉+⌊aj+12⌋)=(⌈ai−12⌉+⌊aj+12⌋)+(⌊ai+12⌋+⌈aj−12⌉)=k+k=2k (excluding the neighbours of p). It proves that the player p will always have k cards.

Now let's prove that the number of cards that players p+1,p+2,…,n,1,…p−1 have is not increasing. Again, if we consider a single step: bi+1=⌈ai2⌉+⌊ai+22⌋≥⌈ai−12⌉+⌊ai+12⌋=bi.

During the first n2 iterations, the number of elements that are greater than k, is increasing. Before i-th iteration we have ap+i−1>k,ap+i=k. After i-th iteration ap+i=⌈ap+i−12⌉+k2>k, because k is even.

The rest of the solution is described in the «short» version of the solution above.

1470D - Strange HousingOne can prove that the answer always exists if the graph is connected, and the algorithm proves it.

Let us paint all vertices with black and white colors. Let us pick any vertex and paint it black, and let us paint all its neighbours with white. Then let's pick any uncoloured vertex that is connected to a white one, paint it black, and paint all its neighbours white. We continue this process until there are no uncoloured vertices left. We claim that the set of black vertices is the answer.

We are never painting two adjacent vertices black, since we colour all their neighbours with white. It is also true that the set of already coloured vertices is always connected if we keep only the edges adjacent to black vertices: it is true initially, and whenever we paint a vertex white, it is connected to a black one directly, and when we paint a vertex black, one of its edges goes to a white one coloured on the previous steps (that is how we pick the vertex to paint it white).

1470E - Strange PermutationLet call the cost of rotation of segment [L,R] value R−L coins.

Let's calculate how many ways can we apply to the array of length len with total cost less or equal to c. We can fix len−1 bars between neighbouring elements of array. There is a bijection between ways to select c of them and ways to apply some not overlapping rotations with total cost equals c. We can see, that the number of ways is equals (len−10)+⋯+(len−1c)=ways(len,c). Now we can check if the answer to the query is −1.

It is easy to see, that the answer on query depends only on construction of j-th permutation from p. This construction can be represented as set of rotations of size not larger than c. And the number of possible rotations in this set doesn't exceed m=nc. If we can answer this query for each suffix of p, we can determine j-th permutation:

l c k What is the leftmost rotation on the suffix of length len, if we have c coins and we want to get k-th permutation of this suffix.Let's fix any suffix px,px+1,…,pn. We can build a long array consisting of the leftmost rotations in construction of each permutation of this suffix using not more than c coins. It is easy to see that each rotation will appear on some segment of this array. We can determine the length of this segment: if it was the rotation [l,r], than the length of this segment is ways(n−r,c−r+l). Exactly once happends that there is no leftmost rotation.

For x−1 (suffix px−1,px,…,pn) relative order of this segments won't change because we will add px−1 to the beginning of each permutation. Only c segments will appear (rotations [x−1,x],[x−1,x+1],…,[x−1,x+c−1]).

We can show that new segment will appear only in the beginning and in the end (because only their first element isn't equal px−1).

We can show that query l c k is equivalent to query n c k′ because of the structure of this array.

In O(m) we can build this array using deque. We should do this for each c.

Let's answer the queries offline using the following algorithm:

Iterate in order of decreasing c (let's call a level set of queries with the same c).Sort queries in order of increasing k. Using two pointers approach we can move all queries to another level and change them to type n c k′.If we will remove queries from each level after answering them, memory will be reduced from O(qc+nc) to O(q+nc).

Total work time: O(sort(q)⋅c+nc2). It can be optimized to O(sort(q)+q⋅logn⋅logc+nc2) using another sort algorithms. Also there is a solution in O(nc2+q⋅c⋅log(nc)) and O(nc) memory with binary search and slower solutions with different data structures.

1470F - Strange CoveringIt is clear that there are only 3 structurally different ways to pick two rectangles optimally:

Two rectangles do not intersect:

In this case one can iterate over all horizontal / vertical lines, separating those rectangles, find the extremal points in both halfplanes, and pick the rectangles with corners in the extremal points.

Rectangles do intersect, forming a «cross»:

In this case note that for each of the rectangles at least two sides lie on the boundary of the bounding box of all points:

To find such rectangles efficiently, one can iterate over the right boundary of the «vertical» rectangle. Let Ld — be the lowest y coordinate of a point to the left of left boundary of the «vertical» rectangle, Lu — the highest y coordinate of a point to the left of the boundary of the «vertical» rectangle, and similarly Rd — the lowest y-coordinate of a point to the right of the «vertical» rectangle, Ru — the highest y-coordinate of a point to the right.

We can assume that Ru≥Lu (this can be guaranteed by picking a prefix in our data structure that we will find later). On such a prefix where Ld≥Rd we need to choose the rightmost bound. What remains is a subrange where Ld≤Rd and Lu≤Ru. If we fix two bounds of a rectangle L and R, their total area equals (Ru−Ld)⋅H+(R−L)⋅W, where W is the height of the bounding box, and H — its length. Rewriting (Ru−Ld)⋅H+(R−L)⋅W=(R⋅W+Ru⋅H)−(L⋅W+Ld⋅H) one can see that the optimal L can be chosen with a segment tree.

Two rectangles intersect in a such a way so that one of the vertices lies inside or on the boundary of the other one:

In this case one of the corners of each rectangle coincides with a corner of the bounding box. Let's call such a corner interesting.

If we fix the interesting vertex of one of the rectangles, the remaining rectangle can be uniquely determined. Looking at the formulas, it is clear that once we know the x-coordinate of an interesting corner of the rectangles, one can choose the y-coordinate of the interesting corner by answering a query in form «minimize a⋅x+b⋅y», where (a,b) — one of the pairs belonging to a fixed precomputed set, and (x,y) is a query. Dividing the expression by x one can get a+b⋅yx — a standard query that can be solved using convex hull trick. The only piece remaining is to guarantee that the chosen rectangles intersect. To achieve this once we fixed x we only need to consider a continuous segment of ys, so we need to find the maximal value of a subrange of linear functions, which can be implemented in offline manner in O(nlogn) time with a segment tree of convex stacks

The overall complexity of this solution is O(nlogn).

Codeforces Round #693 (Div. 3) Editorial

By Supermagzzz, history, 2 years ago, translation, In EnglishAll problems were invented MikeMirzayanov and developed by me Supermagzzz and Stepavly.

1472A - Cards for Friends

Editorial1472A - Cards for FriendsIf we cut the sheet in width, we will reduce its width by half, without changing the height. Therefore, the width and height dimensions do not affect each other in any way.

Let's calculate the maximum number of sheets that we can get by cutting. Let's say that initially this number is 1. Let's cut the sheet in width. Then the sheets number will become 2, but they will be the same. If we can cut the sheet again, it is more profitable to cut all the sheets we have, because this way we will get more new sheets and their size will still be the same.

So we can maintain the current number of identical sheets and as long as either the width or height is divided by 2, divide it, and multiply the number of sheets by two.

Solution1472B - Fair Division

Editorial1472B - Fair DivisionIf the sum of all the weights is not divisible by two, then it is impossible to divide the candies between two people. If the sum is divisible, then let's count the number of candies with a weight of 1 and 2. Now, if we can find a way to collect half the sum with some candies, then these candies can be given to Alice, and all the rest can be given to Bob.

Simple solution — let's iterate through how many candies of weight 2 we will give to Alice, then the remaining weight should be filled by candies of weight 1. If there are enough of them, then we have found a way of division.

In fact, if the sum is even and there are at least two candies with weight 1 (there can't be one candy), then the answer is always "YES" (we can collect the weight as close to half as possible with weight 2 and then add weight 1). If there are no candies with weight 1, then you need to check whether n is even (since all the candies have the same weight, you just need to divide them in half).

Solution1472C - Long Jumps

Editorial1472C - Long JumpsLet score(i) be the result of the game if we chose i as the starting position.

Let's look at some starting position j. After making a move from it, we will get a[j] points and move to the position j+a[j], continuing the same game. This means that by choosing the position j, we can assume that we will get a result a[j] more than if we chose the position j+a[j]. Formally, score(j)=score(j+a[j])+a[j].

Let's calculate all the results of score and store them in an array. Let's start iterating through the positions from the end, then being in the position i we will know score(j) for all j>i. Using the formula above, we can calculate score(i) in one operation. It remains only to choose the maximum of all such values.

Solution1472D - Even-Odd Game

Editorial1472D - Even-Odd GameLet's look at an analogy for this game.

If Alice takes an even number x, she adds x points to the global result, otherwise 0;If Bob takes an odd number x, he adds −x points to the global result, otherwise 0;Alice wants to maximize the global result and Bob wants to minimize it.Obviously, this game is completely equivalent to the conditional game.

Suppose now it's Alice's move. Let's look at some number x in the array.

If this number is even, then taking it will add x points, and giving it to Bob will add 0 points.If this number is odd, then taking it will add 0 points, and giving it to Bob will add −x points.So taking the number x by x points is more profitable than not taking it (regardless of the parity). To maximize the result, Alice should always take the maximum number in the array.

Similar reasoning can be done for Bob. In the task, it was necessary to sort the array and simulate the game.

Solution1472E - Correct Placement

Editorial1472E - Correct PlacementLet's sort all people by their height in descending order.

Now let's go through all the people and look for the position of the person in the sorted array, the height of which is strictly less than ours (for example, by binary search). Obviously, only those people who are in the sorted array later than the found person can stand in front of us (all of them have a height strictly less than ours).

Among all these people, it is more profitable for us to take a person with minimum width. In order to find such a person quickly, we can find a person with the minimum width for each suffix of the sorted array.

To handle a situation where a person is lying down, we need to swap the width and height and repeat the algorithm above.

Solution1472F - New Year's Puzzle

Editorial1472F - New Year's PuzzleIf the first column is empty, we can always cover it with a vertical tile:

if the next column is also empty, then we will have to put either two vertical or two horizontal tiles, but they are obtained from each other by rotating;if the next column contains at least one blocked cell, then we have no other options but to cover the column with a vertical board.If the first column is fully blocked, then we can just skip it.

Remove such columns from the beginning, reducing the problem. Now the first column contains one empty and one blocked cell. Obviously, in place of an empty cell, we will have to place a horizontal tile. If this did not work, then the tiling does not exist. Otherwise there are two cases:

if the next column is empty, it will turn into a column with one occupied cell. Then we continue to put horizontal tiles;if the next column contains one blocked cell, then it becomes fully blocked and we return to the first step.It turns out the following greedy algorithm, we sort all columns with at least one cell blocked (there are no more than m such columns) by number. Now, if we see a column with one occupied cell, then the next one must also be with one occupied cell (we skipped the empty columns), but this cell must have a different color in the chess coloring (so that we can tile the space between them with horizontal boards. This check is easy to do after sorting the columns.

Solution1472G - Moving to the Capital

Editorial1472G - Moving to the CapitalFind the distances to all vertices and construct a new graph that has only edges that goes from a vertex with a smaller distance to a vertex with a larger distance. Such a graph cannot contain cycles.

Next, you need to run a dynamic programming similar to finding bridges in an undirected graph. First, we write the minimum distance from each vertex to the capital using no more than one edge. This distance is either equal to the distance from the capital to the vertex itself, or the distance to the vertex connected to us by one of the remote edges. We can't go through more than one remote edge.

The real answer for a vertex v is the minimum of such values in all vertices reachable from v in the new graph. Since the new graph is acyclic, we can calculate the answer using dynamic programming and a depth-first search started from the capital.

Solution

Technocup 2021 Elimination Round 3 and Round #692 (Div. 1 + Div. 2) Editorial

By neckbotov, history, 2 years ago, In English1411A - In-game ChatYou should count the number of parentheses at the end of the string, suppose there are x such parentheses. Then if x>n2, message is bad. Note that you should divide n by 2 without rounding. Or you can compare 2⋅x and n instead. If 2⋅x>n, the message is bad.

1411B - Fair NumbersLet's call a number super-fair if it is divisible by each of the numbers 1..9. It is fair to say that super-fair numbers are also divisible by LCM(1..9) which is equal to 2520. The answer isn't larger than the nearest super-fair number, which means that you can increase the original n by one until it becomes fair. We will determine if the number is fair by checking each of its digits separately.

1411C - Peaceful RooksConsider rooks as edges in a graph. The position (x,y) will correspond to an edge (x→y). From the condition that there're at most one edge exits leading from each vertex and at most one edge leading to each vertex, it follows that the graph decomposes into cycles, paths, and loops (edges of type v→v).

What happens to the graph when we move the rook? The edge changes exactly one of its endpoints. By such operations, we must turn all edges into loops, and the constraint on the number of edges going in and out of a vertex must be satisfied. A path is quite easy to turn into loops, just start from one end. A cycle must first be turned into a path, which is always possible. We've only spent one extra move, it's not hard to see that this is optimal.

The answer is the number of rooks minus the number of loops plus the number of cycles.

1411D - Grime ZooConsider two adjacent question marks at positions l and r (l<r). Let c0 zeros and c1 ones be on the interval (l,r). In case sl=0, sr=1 there will be written (c1+1)⋅x+c0⋅x+out=(c0+c1+1)⋅x+out=(r−l)⋅x+out comments, where out is the number of comments for subsequences, at least one element of which is outside [l,r]. In the case sl=1, sr=0 we get (c0+1)⋅y+c1⋅y+out=(c0+c1+1)⋅y+out=(r−l)⋅y+out comments. Subtract the second from the first, we get (r−l)⋅(x−y). This means the following: if x≥y, it is always better to change 01 to 10. That is, there is such an optimal substitution of ? by 0 and 1 that some prefix of ? are replaced by 1, and the remaining by 0. In the case of x<y, similarly, there will be some prefix of 0, then suffix of 1. For O(n) implementation you can count how many ones and zeros on each prefix and iterate over the separation boundary.

1411E - Poman NumbersFirst, note that the last digit will always be taken with a plus sign, and the one before the last — with a minus sign. It turns out that all other digits may be taken with any sign. Let's prove it.

Suppose we want to get the mask −−−++−−++−−−+. All minuses on the left can be obtained by simply splitting one character at a time. We are left with the ++−−++−−−+ mask, split it as follows: (++−−++−)(−−+). That is, we left in the left part only one minus from the last segment of consecutive minuses. Change the signs in the left part: (−−++−−+)(−−+). We reduced it to a smaller problem. Doing this, we will end up with masks of the form +.

Now the problem is reduced to whether we can get the number X using the first n−2 letters. Since the weights of the items are powers of two, we can choose them greedily.

Bonus. Can you construct an answer in linear time (i.e. output a binary tree)?

1411F - The Thorny PathThe problem boils down to getting an array consisting of threes and a remainder (2 or 2+2 or 4) using split and merge operations. It helps to think that all merge operations are done before split operations.

To solve the problem, you can brute which elements of the array the remainder is subtracted from, then the rest of the operations are done greedily.

Bonus. Given k. We need to get an array consisting of k using these operations. Assume that the sum of the array elements is divisible by k. This can be represented as minimum cover of the hypergraph by edges with weights = (number of vertices - 1) + (sum of elements / k - 1). Is there a polynomial solution (k is a parameter)?

1411G - No Game No LifeThe winner of the game is determined by xor of Grundy values for all chips' vertices. Notice that every Grundy value ≤m−−√ so xor doesn't exceed 512. Let Pv be a probability of Alice's victory if the current xor is v.

Pv=∑Pto⋅prob(v→to)+[v≠0]⋅1n+1In the second term, we got n+1 and the process ended. It is clear that prob(v→to)=cnt[v⊕to]n+1, where cnt[x] is the number of vertices with the Grundy value equal to x. Now we have a system of 512 linear equations with variables Pv. We can solve it using the Gauss method. The answer is in P0. The proof that Gauss won't break along the way is left to the reader as an exercise.

There is also a solution using the Hadamard transform.

1464F - My Beautiful MadnessWhen I write "a vertex at a distance d up from the given", I mean such a vertex, if it exists; otherwise the root of the tree.

Let's learn how to answer the query of whether the intersection of d-neighborhoods of all paths is empty. For a given path poman is a vertex at a distance d up from the LCA of this path.

Lemma: if the intersection is non-empty, then the deepest poman vertex is included in it.

Proof: let the intersection be non-empty, and the deepest poman vertex (let's call it v) is not included in the intersection. The path that spawned v is located along with the neighborhood in v's subtree. v is not included in the intersection, so there is some path whose neighborhood does not contain v. Note that it cannot be in the subtree of v, since then its poman vertex would be deeper than v; hence it lies outside the subtree v with the neighborhood, hence the intersection of all neighborhoods is empty. Contradiction.

This knowledge allows us to check if the intersection is empty by checking if one particular vertex v lies in the intersection (for a query, recognizing v is easy if we maintain a set of LCA of paths from P, ordered by depth). Let kek be a vertex at a distance d above v. First, a necessary condition: for each path from P, the subtree of kek contains at least one end. Let's implement it like this: when the path (u,v) comes, we do ad[u]++, ad[v]++, ad[LCA(u, v)]--. Now the sum of ad in a subtree of a vertex is the number of ends of different paths in it.

Now we know for sure that there is no path that lies strictly outside the kek subtree, that is, all paths for which LCA is outside the subtree of kek pass through kek, and hence v lies in their d-neighborhood. The only remaining paths to check are those in the kek subtree. The shortest distance from v to such paths is the distance to their LCA (this is not true if the LCA lies on the path (v,kek), but this path itself has length d and we will definitely reach such LCA from v).

We got the following task about processing queries on a tree:

podkek[v]++podkek[v]--among the vertices of the given subtree with podkek[v]>0, find the farthest from the given vertex (also contained in this subtree)This one can be solved using HLD in O((q+n)⋅log2n), I recommend referring to the code.Code

Btw, congratulations to Benq on first-to-solve this problem!

Codeforces Round #691 Editorial (finished)

By Endagorion, history, 2 years ago, In EnglishKeeping track of both Codeforces round and online team contest was a doozy, so this is only the best draft of the editorial I have. Missing problems will gradually be added, and existing explanations may improve over time. Hope you enjoyed the problems, and let me know if anything can be explained better!

UPD: okay, all of the problems are out, and most of the bugs are fixed (I hope). By the way, we had a nice discussion with Errichto on his stream about Div. 2 problems, which some of you may find more approachable. Be sure to check it out, as well as other stuff Errichto creates!

1459A - Red-Blue ShuffleFirst we can observe that if a card has ri=bi, then if doesn't affect the comparison between R and B regardless of its position. We can forget about all such cards. Formally, if we erase all such cards after the permutation, then R and B are still compared in the same way, and further all the remaining cards are still permuted equiprobably.

Now we only have cards with ri>bi (let's call them Red-favourable) and ri<bi (call them Blue-favourable). But then, the comparison between R and B will only be decided by whether the first card is Red- or Blue-favourable. Naturally, if, say, there are more Red-favourable cards than Blue-favourable cards, then Red is more likely to win. If there is an equal number of Red- and Blue-favourable cards, then the chances are equal.

Thus, for the solution purposes we only need to count indices i with ri>bi and those with ri<bi, and compare these two numbers.

1459B - Move and TurnWe will describe an O(1) formula solution. Some slower solutions were also allowed.

First, consider the case when n is even. Regardless of the initial direction, we will make n/2 horizontal (west-east) steps and n/2 vertical (north-south) steps. Further, directions of horizontal and vertical steps may be decided independently.

If we have to make, say, k horizontal steps choosing left/right direction every time, there are k+1 possible horizontal positions x we can end up in. Indeed, all possible ways can be grouped as follows:

k steps left, 0 steps right: x=−k;k−1 steps left, 1 step right: x−−k+2;...0 steps left, k steps right: x=k.Back in the case of even n, since the directions for vertical and horizontal steps can be chosen independently, there are (n/2+1)2 possible combinations of final x and y.

Let's now say that n=2k+1 is odd. If we start with a horizontal step, then in total we will be making k+1 horizontal steps and k vertical steps, thus the number of combinations here is (k+1)×(k+2). A similar argument applies for when we start with a vertical step. Finally, observe that it is impossible to reach the same position starting with both vertical and horizontal step. This is because the parity of, say, the final horizontal position x is the same as the number of horizontal steps, thus it can not be the same after k and k+1 horizontal steps. Thus, in the odd case the answer is 2(k+1)(k+2), where k=n/2 rounded down.

1459C - Row GCDFrom basic properties of GCD we know that GCD(x,y)=GCD(x−y,y). The same applies for multiple arguments: GCD(x,y,z,…)=GCD(x−y,y,z,…). Let's use this for GCD(a1+bj,…,an+bj) and subtract a1+bj from all other arguments: GCD(a1+bj,…,an+bj)=GCD(a1+bj,a2−a1,…,an−a1).

If we find G=GCD(a2−a1,…,an−a1), then any answer can be found as GCD(a1+bj,G). Note that we have to assume that GCD of an empty set is 0, and GCD(x,0)=x for any x, since 0 is the only number divisible by any other number.

1459D - Glass Half SpilledSuppose that we want to collect water in a certain set of chosen glasses S. Let AS be the total capacity of chosen glasses, and BS be the total amount of water currently contained in chosen glasses. Also, let B be the total amount of water in all glasses.

Clearly, the optimal way is to directly transfer water from non-chosen glasses to chosen ones. Then, we already secured BS units, and we can transfer up to B−BS units, thus the largest possible amount is BS+(B−BS)/2=B/2+BS/2. But all this water may not fit into the chosen glasses, so the actual amount we collect is min(AS,B/2+Bs/2).

To find the optimum answer for each k, let's use dynamic programming: define dp[i][k][A] as the largest possible BS for a subset of k glasses among 1,…,i such that the total capacity in the subset is A. We can recalculate this with transition dp[i][k][A]=max(dp[i−1][k][A],dp[i−1][k−1][A−a[i]]+b[i]). Then, ans[k]=maxAmin(A,dp[n][k][A]/2+B/2). Time complexity is O(n3maxai), where maxai is the largest capacity of a glass. We can also get rid of storing the first dimension i by overwriting DP values as i increases, and obtain O(n2maxai) memory.

1459E - Latin SquareFor convenience, let's assume that all row and column indices, as well as matrix values, are from 0,…,n−1 instead for 1,…,n.

If only shift operations were present, we could solve the problem in linear time: just maintain where the top left corner ends up after all the shifts, and then the matrix can be easily reconstructed (if this is not immediately clear to you, take a moment and think how this should be done). For the inverse operations, the approach is going to be similar, but we'll need a different way to look at the matrix. Instead of the matrix, let's think about the set of all triples (i,j,a[i][j]). Imagining a set of n2 points in 3D, where i,j are x and y coordinates in the horizontal plance, and a[i][j] is the height z is a good mental picture.

Shift operations apply x→(x±1)modn and y→(y±1)modn to all points. We can think of this as a translation of the entire 3D space, with some looping at the borders. Instead of the given points, let's keep track of where the point (0,0,0) is located after the operations are done; it's just as easy as in two-dimensional version from before.

Now let's introduce the inverses. Consider, say, a row inverse operation, and all the points (i,j,k), where k=a[i][j], that have the same row index i. As an example, suppose that the top (0-th) row of the matrix contains numbers (2,1,3,0). The entries in the row correspond to points (0,0,2), (0,1,1), (0,2,3), (0,3,0). The inverse permutation to this row is (3,1,0,2), thus the new set of points should be (0,0,3), (0,1,1), (0,2,0), (0,3,2). In general, if there is currently a point (i,j,k) in the set, then after the inverse there must be a point (i,k,j). Thus, the entire operation may be summarized as "swap the second and third coordinates". Similarly, the column inverse is "swap the first and third coordinates". Again, we think of this transformation applied to the entire 3D space: this can be seen as a mirror reflection with respect to y=z or x=z plane.

How does this affect our "keep track of (0,0,0)" approach? It is easy to update its position: just swap respective coordinates. However, we now need to care about how the answer is reconstructed, since, say, the point (1,0,0) not necessarily ends up one step to the right of (0,0,0). Thus, in addition, let's keep track of how the direction vectors vx=(1,0,0), vy=(0,1,0), vz=(0,0,1) are permuted after all operations. Shifts do not affect them, but inverses swap two of them, depending on which coordinates where swapped.

We are almost done, we just need to reconstruct the answer at the end. If we had an initially given point p=(i,j,k), where will it end up? If the origin ends up at a position represented as a vector v0=(x,y,z), then p ends up at p′=v0+ivx+jvy+kvz, where vx,vy,vz are permuted accordingly. Once we have the result p′=(i′,j′,k′), all we need is to put k′ into b[i′][j′], where b is the answer matrix.

This results, once again, in a linear time solution. This explanation could have been much shorter with some linear-algebraic machinery (basically each transformation = multiplication by a certain matrix), but I chose to leave it as elementary (≠ simple!) as possible.

1459F - Flip and ReverseLet's go over characters of s left to right and keep track of the balance = (the number of 0's) - (the number of 1's) among the visited characters. We can think about starting at the point 0, and moving right (from x to x+1) when we see a 0, and moving left (to x−1) when we see a 1. Each time we go from x to x±1, let's connect the two points with an edge. We'll keep track of all the edges, even if there are multiple ones connecting the same pair of points. Since our path visits all edges we've created exactly once, it is an Eulerian path in the (multi)graph constructed this way. The start point of the path is 0, and the finish point is equal to the total balance of the string s.

Now, let's think about what a transformation does. A valid substring subject to the transformation has an equal number of 0's and 1's, thus it must correspond to a part of our path which is a round tour from a point x back to itself. Flipping and reversing the substring makes us traverse all the same edges, but in reverse order and in reverse direction. Thus, in terms of graphs and paths, what we're doing is reversing a cycle that occurs in the Eulerian path. Note that the collection of edges is preserved after every operation, in other words, the graph is an invariant of the process. Furthermore, the start and finish of the path also stay the same.

The answer (= lex. min. string) thus also corresponds to a certain Eulerian path in the very same graph, but which one? It should be the lex. min. path (where we prefer going right before going left) that is obtainable from the initial one with cycle reverses. However, the important observation is: in this particular graph any Eulerian path is obtainable from any other one with cycle reverses (as long as they start and finish in the same places).

There are a few ways to prove this. For example, consider two Eulerian paths, and look at the first point where they diverge: say, one goes x→x+1, while the other goes x→x−1. But both paths will have to eventually return to x to go in the other direction, thus there is at least one extra edge in each direction x→x+1 and x→x−1, unvisited before the divergence happened. Let's wait until the first path visits at least two edges between x and x−1, returning back to x, and reverse the resulting cycle. With this, the next edge after diverging have changed from x→x+1 to x→x−1, and now the two paths diverge some time later. We can proceed until both paths are the same.

The observation implies that we should simply look for the lex. min. Eulerian path in the entire graph. Let's try to do this greedily: build the path from the beginning, marking edges as used when we traverse them. Take the transition x→x+1 whenever there is a unused edge leading there, otherwise settle for x→x−1. There is a caveat, though: we can not go x→x+1 if this uses the last edge between x and x+1, and additionally we still have to visit x some time later (say, if x has unused edges to x−1). However, with this extra condition in place, the greedy algorithm will always find an Eulerian path, and it's clearly the lex. min. one. This procedure is fairly easy to implement in linear time: reconstruct the graph and do the greedy thing.

1458E - Nim ShortcutsGiven the shortcut positions, we can immediately mark some initial positions as winning or losing for the first player. Namely, all shortcut positions are immedilately losing, and any position within one move of a shortcut position is winning (unless it's also a shortcut position). In an example picture below cells (x,y) correspond to different initial positions. Red cells mark shortcut positions, and yellow cells are single move wins.

Which of the unmarked positions are losing for the starting player? We can repeatedly apply the usual game-analysing rule: if all positions reachable in one move from a position (x,y) are known to be wins, then position (x,y) loses. We'll consider all candidates subject to this rule in lexicographic order. The first candidate is the position (0,0). A few situations can happen as we proceed forward:

(x,y) is a shortcut position. There's no need to mark it as losing, just go to (x+1,y+1), as all positions (x+1,y), (x+2,y), … and (x,y+1), (x,y+2), … are known to be single-move wins to (x,y).(x,y) is a single move win to a shortcut (x′,y) with x′<x. Then, skip (x,y) and go to the next natural candidate (x+1,y), since all cells (x,y+1), (x,y+2), … are known to be single-move wins to (x′,y).(x,y) is a single move win to a shortcut (x,y′) with y′<y. Then, skip (x,y) and go to the next natural candidate (x,y+1), since all cells (x+1,y), (x+2,y), … are known to be single-move wine to (x,y′).Neither of the above applies. Then, there can be no losing positions reachable in one move from (x,y): single-move wins are eliminated, and all manually marked positions (x′,y′) saitsfy x′<x, y′<y. Thus, per our rule, we mark (x,y) as losing and proceed to (x+1,y+1).Here's what happens in the picture above. All candidates considered throughout the process are tinted blue, and all identified losing positions are dark blue.

With this procedure we can identify all losing positions (x,y) under x,y≤C in roughly O(Clogn) time (n is the number of shortcuts). This is too slow since coordinates can be up to 109. However, we can speed up consecutive applications of the last case of the above procedure as follows:

...Neither of the above applies. Let X>x and Y>y be the closest x-coordinate and y-coordinate of a shortcut position respectively (X and Y may correspond to different shortcut positions). Let Δ=min(X−x,Y−y). Then, mark all positions (x,y),(x+1,y+1),…,(x+Δ−1,y+Δ−1) as losing, and go to (x+Δ,y+Δ).This is justified since all thusly marked positions don't share any coordinate with a shortcut, thus surely they're all subject to this case of the procedure.

Looking up X and Y can be implemented with sets of all xi and yi, and upper bound calls. Further, instead of marking all cells (x,y),(x+1,y+1),…,(x+Δ−1,y+Δ−1) one by one, let's memorize them as a diagonal segment, described by the initial point (x,y) and length Δ. We can now observe that the optimized process only takes O(n) steps. Indeed, for each step we can find a shortcut (xi,yi) such that either x≥xi or y≥yi is true for the first time. In particular, the number of diagonal segments representing all additional losing positions is O(n).

Now, to answer any query (a,b) we have to check if one of the following is true:

(a,b) is a shortcut;(a,b) belongs to a diagonal segment.The first condition is easy to check if all shortcuts are stored, say, in a set structure. Diagonal segments can also be stored in a set, and we can find the closest to (a,b) with a lower bound, say, by comparing x-coordinates. This results in an O(nlogn) precomputation, and O(logn) per initial position query.

(Kudos to Golovanov399 for his neat grid drawing tool)

1458F - Range Diameter SumPlease bear with my formal style for this one as my hand-waving skills are too weak to explain this properly.

We'll use the "divide-and-conquer" strategy. Let us implement a recursive procedure solve(l,r) that will compute the sum ∑l≤i≤j≤rdiam(i,j). It will do so as follows:

If l=r, then answer is trivially 0.Otherwise, choose m=⌊(l+r)/2⌋, and compute the following sum: ∑mi=l∑rj=m+1diam(i,j).The only entries diam(i,j) that are not accounted for satisfy either l≤i≤j≤m or m+1≤i≤j≤r. Compute their total as solve(l,m)+solve(m+1,r), and return the total answer.Of course, ∑mi=l∑rj=m+1diam(i,j) is the tricky part. We'll need some preparation to compute it. To make arguments cleaner, let us introduce an extra vertex in the middle of every edge, subdividing it into two. We'll refer to new vertices as extra vertices, and the old vertices as proper vertices. Since all distances are doubled, we will have to divide the answer by two in the end.

We will define a circle C(v,r) of radius r centered at a vertex v in the tree as the set of all vertices at distance at most r from the vertex v. We also assume that if r>0 there are at least two vertices in C(v,r) exactly at distance r from v, otherwise decrease r accordingly.

For a set of vertices S we define Cover(S) as a circle of smallest radius containing all vertices of S. If we assume that all vertices of S are proper, then Cover(S) is unique. Indeed, after subdividing all distances among S are even, thus in Cover(S)=(v,r) we must have r=diam(S)/2, and v is the unique diameter midpoint. We can see that if r>0, then S has at least two vertices at distance r from the covering circle center v, namely, the diameter endpoints.

Warning: math ahead. It you're not interested in proofs, only read the premise of Lemma 2.

Lemma 1. If a circle C(v,r) contains two proper vertices a,b, then it also contains the midpoint c on the path between a,b, and further dist(v,c)≤r−dist(a,b)/2.

Proof. Say, for the vertex a we have dist(v,a)≤dist(v,c)+dist(c,a)=dist(v,c)+dist(a,b)/2. This inequality is strict: dist(v,a)<dist(v,c)+dist(c,a) only when v and a are in the same subtree with respect to c. If we assume that respective inequalities for a,b are both strict, then both a,b are in the same subtree of c, in which case c can not be the midpoint. Otherwise, say, for a we have r≥dist(v,a)=dist(v,c)+dist(c,a)=dist(v,c)+dist(a,b)/2, and dist(v,c)≤r−dist(a,b)/2 by simple rearrangement.

An immediate corollary of this lemma is this: if a circle C(v,r) contains a set of proper vertices S, it also contains Cover(S). We apply the lemma to the midpoint of diam(S), which is also the center v′ of Cover(S)=C(v′,r′), to establish dist(v,v′)≤r−r′. Then, for any vertex w of Cover(S) we dist(v,w)≤dist(v,v′)+dist(v′,w)≤r, thus w∈C(v,r).

Lemma 2. Let S, T be two non-empty sets of proper vertices. Then the smallest covering circle Cover(S∪T) can be found by only knowing Cover(S) and Cover(T), by the following rule:

If Cover(S)⊆Cover(T), then Cover(S∪T)=Cover(T).If Cover(T)⊆Cover(S), then Cover(S∪T)=Cover(S).Let none of Cover(S)=(vS,rS) and Cover(T)=(vT,rT) contain the other one. Then, Cover(S∪T)=C(V,R) has radius R equal to (rS+dist(vS,vT)+rT)/2 (which is asserted to be an integer), and its center V is located on the unique path vSvT at distance (r−rS)/2 (which is asserted to be an integer) from vS.Proof. The first two cases are somewhat easy. Say, in the first case Cover(S∪T) has to contain T, then it must contain Cover(T), and then it contains Cover(S) by default.

Now, assume the latter case. Any two vertices v∈S, u∈T satisfy dist(v,u)≤dist(v,vS)+dist(vS,vT)+dist(vT,u)≤rS+dist(vS,vT)+rT, thus maxdist(v,u)=2R≤rS+dist(vS,vT)+rT. Now, let ab and cd be diameter endpoints of S and T respectively. Here we can even choose, say, a outside of Cover(T), since S⊈Cover(T), similarly choose c∉Cover(S). We then must have dist(a,c)=rS+dist(vS,vT)+rT, thus Cover(S∪T) has radius R at least half of that, and V is the only possible center candidate.

When one or both of Cover(S) and Cover(T) has zero radius, the claim can established pretty much directly.

Okay, we're out of the woods now!

The last lemma allows us to maintain Cover(S)=C(v,r) for any set S, and further "merge" Cover(S) and Cover(T) to obtain Cover(S∪T), since all we need is distances between vertices, and finding a vertex on a vSvT at certain distance from vS. We can also efficiently check if C(v,r) contains C(v′,r′) by verifying dist(v,v′)≤r−r′. All of that can be done with binary lifting and LCA manipulations in O(logn) per operation.

At last, let's get back to the divide-and-conquer step. Let us find circles C1(i)=(vi,ri)=Cover(i,…,m), and C2(j)=(vj,rj)=Cover(m+1,…,r) for all relevant i,j. We have C1(m)=C(m,0), and C1(i) is a merge of C1(i+1) and C(i,0) for any smaller i; similar for C2(j).

Now, let's consider the sum ∑rj=m+1diam(i,j) for some i. diam(i,j) is equal to twice the radius of the merge of C1(i) and C2(j). Consider increasing j from m+1 to r. Since C2(j)⊆C2(j+1) for any j, we have three interesting ranges for j, in order from left to right:

j∈[m+1,t1(i)): C2(j)⊆C1(i);j∈[t1(i),t2(i)): C1(i) and C2(j) are not contained in each other;j∈[t2(i),r]: C1(i)⊆C2(j).In the first range diam(i,j)=2ri, and in the third range diam(i,j)=2rj. If we know the boundaries t1(i) and t2(i), then these can be accounted for with prefix sums on rj (and simple multiplcation for ri).

In the second range we have to sum up ri+dist(vi,vj)+rj. Again, summands ri and rj are accounted in the same way. Only ∑j∈[t1(i),t2(i))dist(vi,vj) remains.

Instead of computing this directly right now, consider how t1(i) and t2(i) change as i decreases from m to l. We have C1(i)⊆C1(i−1), thus we can conclude that t1(i) and t2(i) both do not decrease, and the range [t1(i),t2(i)) is a "sliding window" with both endpoints moving to the right. Boundaries t1(i) and t2(i) can thus be maintained with the two-pointers approach, and vertices in the range can be maintained with a queue, where vertices enter from the right and leave from the left.

On top of the queue that supports "push-back" and "pop-front", we'd also like to query "sum of distances from an arbitrary vertex v to all vertices in the queue". To this end (and only this), we will have to use centroid decomposition in its most basic form. It's fair to say that the margins of this explanation are already too crowded for a proper explanation of this. In short, we can add/remove vertices and query the distance sum in O(logn) time. This concludes the divide-and-conquer step description.

With the usual divide-and-conquer time analysis we arrive at an O(nlog2n) solution.

Codeforces Round #690 (Div. 3) Editorial

By Stepavly, 2 years ago, translation, In EnglishAll problems were created by MikeMirzayanov and developed by me (Stepavly) and Supermagzzz.

1462A - Favorite Sequence

Editorial1462A - Favorite SequenceIn this problem, you can implement an algorithm opposite to that given in the condition. Let's maintain two pointers to the left-most and right-most unhandled element. Then, restoring the original array, you:

put the left-most unhandled item in the first positionput the right-most unhandled item in the second positionput the left-most unhandled item in the third positionput the right-most unhandled item in the fourth position...That is, in general, you put the leftmost elements on all odd positions, and the rightmost ones on all even positions. After processing each element, you either move the left pointer forward by one, or the right one backward by one.Solution1462B - Last Year's Substring

Editorial1462B - Last Year's SubstringLet's see how the deleted substring t should look so that after deleting it, the string s turns into the string "2020". The length of the string t must be n−4. Then we can iterate over all substrings of the string s of length n−4 (there are no more than five such substrings) and look at the string obtained after deleting the substring.

That is, we need to check that one of the following character sequence matches the (2,0,2,0):

(s[1],s[2],s[3],s[4]);(s[1],s[2],s[3],s[n]);(s[1],s[2],s[n−1],s[n]);(s[1],s[n−2],s[n−1],s[n]);(s[n−3],s[n−2],s[n−1],s[n]);Solution1462C - Unique Number

Editorial1462C - Unique NumberFirst of all, let's understand that the answer to the problem should not contain zeros (leading zeros are useless, while others increase the number, but do not change the sum). It is also clear that the number we found should have the minimum possible length (since the longer the numbers without leading zeros, the larger they are). Numbers of the same length are compared lexicographically, that is, first by the first digit, then by the second, and so on. This means that the digits in the number must go in sorted order (the order of the digits does not affect the sum, but does affect the value).

Let's minimize the length of the number first. We need to get the specified sum in as few digits as possible. So we should use as large digits as possible. Then let's start with the number 9 and add the digits from 8 to 1 to the beginning of the number in turn, until the sum of the digits exceeds the specified sum. Obviously, you can't get an answer for fewer digits.

Now we minimize the number itself. First, we must minimize the first digit. The first digit is uniquely determined as the difference between the sum of the remaining digits and the required sum. So you need to maximize the sum of all digits except the first one (which has already been done in the previous paragraph). It only remains to correct the first digit and print the answer.

Solution1462D - Add to Neighbour and Remove

Problem authors: MikeMirzayanov, Supermagzzz, Stepavly.

Editorial1462D - Add to Neighbour and RemoveLet k — be the number of operations performed by Polycarp. Let's see how to check if k is the answer.

Let's denote by s the sum of numbers in the array a. Note that after each operation s does not change. Since we know that after k operations all elements must be the same and the sum of the numbers in the array does not change, then each of the remaining elements must be equal to sn−k.

Let's check if it is possible to perform k operations so that at the end all elements are equal to sn−k. Note that the process described in the condition is equivalent to the following process:

Choose a set of n−k+1 indices i1,i2,…,in−k+1 (1=i1<i2<⋯<in−k<in−k+1=n+1) — partitions;Create a new array b of n−k elements, wherebj=∑t=ijij+1−1btFor example, the array a of 8 elements after 4 operations could turn into an array b=[a1+a2+a3+a4,a5,a6+a7,a8]. In this case, the set of indices is i=[1,5,6,8,9].

Then, to check if k is the answer, it is necessary to split the a array into n−k subarrays, in which the sum of all elements is equal to sn−k. Such a check can be implemented greedily in O(n). It is enough to go through the array from left to right and take an element into the current subarray until the sum in it exceeds sn−k.

The resulting solution works in O(n⋅σ(s)) or O(n2), where σ(s) is the number of divisors s.

Solution1462E1 - Close Tuples (easy version)

Editorial1462E1 - Close Tuples (easy version)In the easy version of the problem, you can count how many times each number occurs (the numbers themselves do not exceed n). Note that we do not have very many options for which triples of numbers can be included in the answer.

Let's iterate over x – the minimum number in the triples. Then there are the following options:

[x, x+1, x+2];[x, x+1, x+1];[x, x+2, x+2];[x, x, x+1];[x, x, x+2];[x, x, x].In each option, you need to multiply the number of ways to choose one, two or three numbers from all occurrences of this number. This is done using binomial coefficients. Formally, if cnt[x] — is the number of occurrences of the number x, then the formulas corresponding to the options in the list above are as follows:

cnt[x]⋅cnt[x+1]⋅cnt[x+2];cnt[x]⋅cnt[x+1]⋅(cnt[x+1]−1)2;cnt[x]⋅cnt[x+2]⋅(cnt[x+2]−1)2;cnt[x]⋅(cnt[x]−1)2⋅cnt[x+1];cnt[x]⋅(cnt[x]−1)2⋅cnt[x+2];cnt[x]⋅(cnt[x]−1)⋅(cnt[x]−2)6.If we sum these values over all x from 1 to n, then we get the answer to the problem.

Solution1462E2 - Close Tuples (hard version)

Editorial1462E2 - Close Tuples (hard version)The key idea that allows us to move from the previous version to this one is that the values of the numbers themselves are not important to us. The main idea is to consider all numbers in the interval [x,x+k].

Let's also, as in the previous version, iterate over the minimum element x in the tuple. Now let's find the count of numbers cnt that lie in the interval [x,x+k] (this can be done with a binary search, two pointers, or prefix sums using an array of occurrences). Then it remains to add to the answer the number of ways to choose m−1 numbers from cnt−1 (we fixed one of the numbers as the minimum). You have to sum these values over all possible values of x (even the same) because now you are not fixing the value of the minimum element (as in the previous problem), but its index in the sorted array.

To calculate binomial coefficients quickly, you can pre-compute all factorial values and all 1n! values by modulo. If you do not know how to calculate the inverse element by modulo, then you could pre-compute the part of Pascal's triangle in O(nm).

Solution1462F - The Treasure of The Segments

Editorial1462F - The Treasure of The SegmentsAs we know from the problem statement:

Polycarp believes that a set of k segments is good if there is a segment [li,ri] (1≤i≤k) from the set, such that it intersects every segment from the set (the intersection must be a point or segment).

Let's iterate over this segment (which intersects all the others) and construct a good set of the remaining segments, maximum in terms of inclusion. It is easy to understand that this set will include all segments that intersect with ours. We must delete all other segments.

Two segments [l1,r1] and [l2,r2] intersect if max(l1,l2)≤min(r1,r2). Then if the segment that we iterate over has coordinates [L,R], then we must remove all such segments [l,r] for which r<L or R<l is satisfied (that is, the segment ends earlier than ours begins, or vice versa).

Note that these two conditions cannot be fulfilled simultaneously, since l≤r, and if both conditions are satisfied, then r<L≤R<l. This means that we can count the number of segments suitable for these conditions independently.

Each of these conditions is easy to handle. Let's create two arrays — all the left boundaries of the segments and all the right boundaries of the segments. Let's sort both arrays. Now we can count the required quantities using the binary search or prefix sums (but in this case, we need to use the coordinate compression technique).

Taking at least the number of deleted segments among all the options, we will get the answer to the problem.

Solution

Codeforces Round #689 (Div. 2). Editorial

By AleXman111, history, 2 years ago, In English1461A - String GenerationLet's note that the string like "abcabcabcabc..." has only palindromes of length 1, what means it is suitable for us in all cases.

Authors: AleXman111, sdryapko

author's solution: 100959880

1461B - Find the SpruceLet's iterate over the top of the spruce. When we meet the symbol "*", we will start iterating over the height of the current spruce. If for the current height k for each 1≤i≤k all cells with the row number x+i−1 and columns in range [y−i+1,y+i−1] are "*", then we increase the value of the answer. Otherwise, we stop the increment hight.

Author: Vladik

author's solution: 100960218

1461C - Random EventsLet's first define some variable R, which will be equal to the last unsorted number (the largest i for which ri!=i).

Now we can see that we are not interested in experiments with ri<R.

To get the answer, we just need to multiply the remaining (1−pi). This number will indicate the probability that all the remaining experiments failed. Since we need to deduce the probability of success, we can subtract the resulting number from one.

Author: Vladik

author's solution: 100960332

1461D - Divide and SummarizeTo begin with, you can notice that the cut operation does not depend on the order of the a array. So we can sort it.

Now let's build a tree of transitions from the original array to all its possible states. You can simply prove that the height of this tree does not exceed log(max). Since max(currenta)−min(currenta) after each operation of the section is reduced at least twice.

Having understood this, we can write a simple recursive search over the states (left,right). The state will describe a sub-segment of the a array that is the current array. For each state, we can calculate the current amount (on the segment from left to right) and add it to any convenient collection (set/HashSet).

Next, to respond to requests, we can simply look at our collected collection.

Author: Vladik

author's solution: 100960452

1461E - Water LevelIf y≤x, it is quite easy to calculate the answer. Note that at each iteration of the algorithm (except, perhaps, the first), the water level will decrease by x-y liters, and we will have to calculate whether it can decrease t times.

Otherwise, lets note, when we use the rise in water level, we change the value of the expression k mod x. At each step of the algorithm, we will lower the water level as many times as we can, and then raise the level. Further, we note that if we have already reached the value k mod x, then we are in a "cycle", and therefore we will be able to maintain the water level. If the water level is out of bounds, then the answer is No.

Authors: AleXman111, sdryapko

author's solution: 100960607

1461F - Mathematical ExpressionFirst, let's solve the problem without the multiplication sign. It is always beneficial for us to put a plus or a minus, if there is no plus sign.

Now we will solve the problem when there is a sign to multiply. The case when the plus sign is missing is very easy to solve. We put the sign to multiply to the first zero, then we put a minus sign in front of the zero, and after the multiplication signs. Let's consider the case when there is a plus sign and multiply.

Note that it is never beneficial for us to use the minus sign. If there are zeros in the expression, then we simply put plus signs between them and the expressions are split into other independent expressions.

Now you need to be able to solve an expression that has no zeros. To begin with, we take out all units at the beginning and at the end separately with plus signs. The following solution is now proposed. If the product of numbers is greater than or equal to 1016, then it is beneficial for us to put the multiplication sign everywhere. Otherwise, we can use dynamic programming, because the number of numbers greater than one is no more than log2(1016). Dynamic programming will be one dimension. dpi is the most profitable answer if you put signs on the prefix. Let us now stand at i and want to go to j, this means that between the numbers at the i-th and j-th positions there will be a sign to multiply, and after the j-th position there will be a sign a plus.

Author: AleXman111

author's solution: 100960771

Codeforces Round #688 (Div. 2) Editorial

By djm03178, history, 2 years ago, In English1453A - Cancel the TrainsLet's first determine whether it's possible for two trains that start from (i,0) and (0,j) to crash into each other. For this to happen, there must be a point where (i,T)=(T,j), which means i=T and j=T. Therefore, a train that starts from the bottom end can crash into a train that starts from the left end if and only if they have the same train number. We can cancel either one of them to prevent that crash.

Since n and m are small, we can brute-force every pair of trains and count the number of pairs of trains that share the same number, and print that value as the answer. The time complexity for this solution is O(nm) for each test case.

If we want an asymptotically faster solution, we can put all train numbers into a binary search tree structure (such as std::set in C++), and then find duplicate numbers from the trains of the other side by searching for those values. Another similar solution is to sort the former numbers, then perform binary search for the other values. The time complexity for these solutions is O((n+m)log(n)).

There is another solution with O(n+m) time complexity taking advantage of the fact that the train numbers are small. Let's make an array X of length 101, and set X[i]=true if and only if there is a train starting from (i,0). For each train starting from (0,j), we can check if X[j] is true, and count the total number of duplicates this way.

Solutions

O(nm) (C++)O(nm) (Java)O(nm) (Python 3)O((n+m)logn) (C++)O(n+m) (C++)1453B - Suffix OperationsFirst, let's find the optimal strategy for Gildong to follow to make all elements of the array equal.

It's obvious that there is no need to perform any operation on the suffix starting at a1, since that operation changes all the integers in the array. For i=2 to n, the only way for ai to have equal value to ai−1 is to perform one of the operations on the suffix starting at ai abs(ai−ai−1) times. This is because all operations starting at other positions do not change the difference between ai and ai−1. Therefore, the minimum number of operations Gildong has to perform is ∑ni=2abs(ai−ai−1).

How should we change one element so that we can minimize this value? Let's take care of some special cases first. The optimal way to change a1 is to make it equal to a2, and then the minimum number of operations Gildong has to perform is decreased by abs(a2−a1). Similarly, the optimal way to change an is to make it equal to an−1, and then the minimum number of operations Gildong has to perform is decreased by abs(an−an−1).

For the rest of the elements, changing ai affects both abs(ai−ai−1) and abs(ai+1−ai). Here, we need to observe an important fact: This value is minimized when ai is between ai−1 and ai+1, inclusive. Intuitively, if ai−1<ai>ai+1, Gildong has to perform one or more 2-nd operations on the suffix starting at ai, and then one or more 1-st operations on the suffix starting at ai+1 to compensate for the extra 2-nd operations. This applies to the scenario where ai−1>ai<ai+1 as well. If ai is between ai−1 and ai+1, these additional operations are unnecessary. In fact, the number of operations is decreased from abs(ai−ai−1)+abs(ai+1−ai) to abs(ai+1−ai−1).

Therefore, we can decrease the number of operations needed by:

max⎧⎩⎨abs(a2−a1)abs(an−an−1)maxi=2..n−1abs(ai−ai−1)+abs(ai+1−ai)−abs(ai+1−ai−1)The answer is x−y where x is the minimum number of operations Gildong needs to perform on the initial array, and y is the maximum number of operations we can decrease by changing exactly one element.

Time complexity: O(n).

Solutions - C++ - Java - Python 3

1453C - TrianglesLet's consider each d separately. For each cell that has the digit d, we'll check the case where this cell is used as a vertex of the end of a horizontal or vertical side (i.e. the base) of the triangle, and change the digit of another cell and use it as the other end of that side. Let's say the position for this cell is (i,j), and we change the cell at (p,q). Then there are two cases:

i=p: Since we always want to maximize the length of the base, q can be either 1 or n, depending on whether j−1>n−j or not. The length of the base will be max(j−1,n−j).j=q: Similarly, p can be either 1 or n, depending on whether i−1>n−i or not. The length of the base will be max(i−1,n−i).In the first case, since the base is horizontal, the area of the triangle will be determined only by the remaining vertex's row component. Therefore, we only need the maximum / minimum row position of d. Let's say they are max_row and min_row, respectively. We can easily pre-calculate them in advance. Assuming that b is the length of the base, the maximum area will be b×max(max_row−i,i−min_row)2. We can get rid of the 12 part as we will print the area multiplied by 2.

Thankfully, we don't need to check the case where we change a cell that is not used as an end of a base separately, since we can always move it around so that they will eventually be horizontal / vertical to one of the other vertices without changing the area, which becomes a case that we already took care of.

The same process can be applied to the second case as well. Summarizing the whole process, for each d, the maximum area (multiplied by 2) is:

max(i,j)=d{max(j−1,n−j)×max(max_row−i,i−min_row)max(i−1,n−i)×max(max_column−j,j−min_column))Since we check each cell exactly once, and pre-calculating max_row, min_row, max_column, and min_column takes O(n2), the total time complexity is O(n2) for each test case.

Solutions - C++ - Java - Python 3

1453D - CheckpointsAs already explained in the notes (and is quite obvious), the expected number of tries to beat stage i with a checkpoint where stage i+1 also has a checkpoint (or is the end of the game) is 2. What if stage i+1 doesn't have a checkpoint and stage i+2 has a checkpoint?

We can think of it like this. It takes 2 tries in expectation to get to stage i+1, and the player needs to add one more try, trying 3 times in total. But this also has a probability of 12 to succeed, so the expected number of tries to actually get to stage i+2 is multiplied by 2 – making it 6 in total.

This can be extended indefinitely. Let's say xi is the expected number of tries to beat i consecutive stages with only one checkpoint at the beginning. If we extend it to i+1 consecutive stages, it takes xi+1=2⋅(xi+1) tries. If this is not intuitive, we can always use Monte Carlo method to simulate how many tries each takes. The general term for this sequence is xi=2i+1−2, and it is introduced in OEIS A000918 with a similar example.

As each checkpoint makes the stages after that checkpoint independent of the previous stages, we can just add up appropriate xi's to make it equal to k. Using xi means we append the stages in 1 0 0 0 ... form where the number of 0's is i−1.

As every term of the sequence is even, the answer is −1 if k is odd. Otherwise, we can show that there always exists an answer for all even k≤1018. There are two simple strategies to make it with at most 2000 stages.

The first strategy is to greedily take the greatest xi≤y where y is the remaining number, then append xi and subtract it from y. This works because either y can be exactly 2⋅xi, or we can use xi once and repeat the process with y−xi. The worst case for this strategy is to use all of x57, x56, x55, ..., x1 and another x1, which sums up to total of 1654 stages.

Another strategy is to use xi and x1 if bit i+1 (0-indexed) is 1. Since there can be at most 58 1-bits, the worst case for this strategy is still far less than 2000.

Time complexity: O(log2k)Solutions - C++ - Java

1453E - Dog SnacksIt is obvious that the problem can be modeled as a tree rooted at the 1-st vertex. Given a large enough k, we can see that Badugi will always 'clear out' each subtree and then move back to its parent. This is because if there exists an unvisited child for a vertex, the distance between them is 1, while any unvisited vertex at the parent's side has distance of at least 2. Therefore, Badugi's moves will look like a preorder tree traversal.

This implies another fact. Let's say the j-th vertex is a child of the i-th vertex. After visiting the last vertex of a subtree rooted at the j-th vertex, Badugi has to move a longer distance when it was the last child of the i-th vertex than when the i-th vertex has another unvisited child. The only important rule for Badugi is to choose the child that has the shortest 'moving back' distance as the last child he will visit. This distance can be sent back to its parent so that the parent can choose between the candidates. Let's say the minimum among the candidates is mn, and the maximum is mx. It is optimal to use mn+1 as the 'moving back' distance, and the maximum of the 'child-to-child' distances will be mx+1.

There is one exception for this strategy – the root. Unlike the others, there is no need to move any further after visiting all vertices and then getting back to the root. This means choosing mx as the 'moving back' distance is optimal, because we don't need to add anything to it. Then we can use the sub-maximum of the candidates as the maximum of 'child-to-child' distances.

Along these processes we can update the answer whenever we find the maximum of 'child-to-child' distances, along with the last move back to the root.

Time complexity: O(n) for each test case, but it's too boring to find the sub-maximum in linear time, so just sort the candidates and it will be O(nlogn) for each test case.

Solutions - C++ - Java

1453F - Even HarderSince there is at least one way to win initially, every platform is reachable from the start. Note that this condition should still hold after we achieve what Gildong wants. Because of this, if there are multiple j's where j+aj≥i, there are at least two ways that can get to the i-th platform. Therefore, in order to leave only one way to get to the i-th platform, we need to change all aj's where j+aj>=i into 0 except for one of them. We'll call this process cleaning, and the platforms where we set aj=0 are the cleaned platforms.

Let dp[i][x] (i≤x) be the minimum number of platforms that should be cleaned to leave only one way to get to the i-th platform, where the only platform k that can directly move to the i-th platform (i.e. the predecessor) has a value at most x−k. In other words, dp[i][x] only considers all k's where k<i≤k+ak≤x, and choose the one that requires minimum number of cleaned platforms so far. We'll determine dp[i][i..n] in increasing order of i.

Now let cnt be the number of y's where j<y<i and y+ay≥i. Initially cnt is 0. Now for each j from i−1 to 1 (downwards), if j+aj>=i, minimize dp[i][j+aj] with dp[j][i−1]+cnt and then increase cnt by 1. This means we clean all platforms between j+1 and i−1 to let the j-th platform be the predecessor of the i-th platform, while it has possibility to reach the j+aj-th platform. Note that all k's where k<j and k+ak≥i are already cleaned when calculating dp[j][i−1], so we only need to count the cleaned platforms between j+1 and i−1 for cnt.

Then we can prefix-minimize dp[i][i..n] because the actual meaning of the dp[i][x] is the minimum number of platforms that should be cleaned for the predecessor of the i-th platform can reach at most the x-th platform; i.e. it should consider all cases where j+a[j]<x as well.

After we repeat these processes for all i's, the answer is dp[n][n]. Though the explanation is quite complicated, the code turns out to be very short.

Time complexity: O(n2).

Solutions - C++ - Java - Python 3

Editorial of Codeforces Round 687 (Technocup 2021 — Elimitation Round 2)

By KAN, 2 years ago, translation, In English1415A - Prison BreakThe problem is equivalent to finding the farthest cell from (x,y). It is easy to see that, if they move optimally, (i,j) can reach (x,y) just by moving in an L shape, and this is equivalent to the Manhattan distance between the two points. The longest distance a prisoner will move on rows is max(x−1,n−x), and for the columns it is (y−1,m−y). So answer is just max(x−1,n−x)+max(y−1,m−y)1415B - Repainting StreetIf we want to paint every house on the street with color x, it is easy to see that we need to change every house with color different from x, and not necessarily repaint houses already painted in color x. We can do the following greedy algorithm to minimize the number of days: Find leftmost house not painted in color x. Assume this is in position i. Then we will paint [i,i+k−1] with color x. Repeat this until all houses are painted in color x. Why is this optimal? When we find the leftmost house not painted in x, we know we need to change it, and as it is the leftmost one, everything before it is painted in x. To maximize our chances of changing other houses that need repainting, we choose this as the leftmost position in our painting range. This can be implemented easily with a linear pass. However, we don't know the color x that we will have at the end. Limit of colors are small enough, so we can try all of them and just keep the smallest answer.

Time complexity: O(n⋅max(c))Space complexity: O(n)1415C - Bouncing BallNote that instead of deletion of the first cell we can increase the value of p by one, these operations are equivalent. Now let's loop through the possible final values of p, let it be q (p≤q≤n). Then we need to add missing platforms in cells q, (q+k), (q+2k), and so on.

Let's compute the array ci — the number of cells without a platform among cells i, (i+k), (i+2k), an so on. It can be computed using the method of dynamic programming, going from large i to small: ci=ci+k+(1−ai).

Now the time required to add the platforms for a given value of q is cq⋅x, while the time needed to increase p to q is (q−p)⋅y. The total time equals cq⋅x+(q−p)⋅y. We only have to choose minimum among all possible values of q.

1415D - XOR-gunFirst let's compute array b1,b2,…,bn, where bi is the index of the highest bit equal to 1 in the binary notation of ai. The statement says bi≤bi+1. These values can be computed by dividing the given numbers by 2 until they are zero.

Note that if for a given i the equality bi−1=bi=bi+1=t holds, then we can apply an operation to ai and ai+1, and the resulting integer is smaller than ai−1. Indeed, in ai−1 the highest bit set is t, but in ai⊕ai+1 the t-th and higher bits are zeros. That means if there is such an i (it is easy to check in a single linear pass), then the answer is 1.

Now note that if there is no such i, then the size of the array n is not bigger than 2⋅(⌊log2109⌋+1)=60! Indeed, there are no more than two integers with the same highest bit set. It is much easier to solve the problem in such constraints.

Consider some solution. In the final array, let's denote it as c, there is i such that ci>ci+1. Note that each element of the final array is equal to XOR of some subsegment of the initial array, and each element of the initial array belongs to exactly one such subsegment. Let this subsegment for ci be al,al+1,…,am, and for ci+1 be am+1,am+2,…,ar. Then it's clear that to find an optimal solution it is enough to loop through all possible values of l, m, and r and check whether XOR of all elements of the left subsegment is larger than XOR of all elements of the right subsegment. If this inequality holds, update answer with value r−l−1. The complexity of this part is O(n3) or O(n4) depending on implementation.

1415E - New Game Plus!We see that each playthrough (whether it is the first one or any of the playthroughs after the reset) is completely independent of any other playthrough. Thus, we should instead think of the problem as partitioning the n bosses into k+1 playthroughs.

Consider a playthrough with x bosses which have point increments a1,a2,⋯,ax when fought in order. Then, the number of points that we will get is (x−1)a1+(x−2)a2+…+(1)ax−1+(0)ax. A simple greedy argument tell us that within a single playthrough, we should always fight the bosses in non-increasing order of point increments, i.e. a1≥a2≥…≥ax.

We can visualize this with k+1 stacks, each representing a playthrough. Each stack contains all of the bosses that will be fought in that playthrough, and the stack is non-increasing from top to bottom, meaning we fight the bosses from top to bottom.

We now see that k=0 is a fairly trivial case; just fight the bosses in non-increasing order of point increments. For the rest of the tutorial, we will assume k≥1.

For simplicity, we say that a boss is in position p of a playthrough if there are p more bosses below this one on its playthrough stack. Notice that if we have two bosses in two different playthroughs with point increments a and b with positions i and j in their respective playthroughs, then the total points gained from the two bosses is ia+jb. We now see that if a≥b, then i≥j and vice versa. For example, the configuration below is not optimal because swapping the −5 and −3 gives a better answer.

Therefore, all bosses in lower-numbered positions should have point increments that are less than any boss in a higher-numbered position. This means that we can place the bosses on the stacks one at a time in non-decreasing order of point increments to reach an optimal configuration.

Call a boss good if it has a non-negative point increment, and bad otherwise. Let's fix the arrangement of bad bosses and try to place the good bosses in non-decreasing order of point increments. We can see that placing a boss with point increment a on a stack with height h will add ah to the total, so we should always pick the stack with maximum height. Thus, all of the good bosses will always end up on the same stack, and that stack will be the stack of maximum height. Call this stack the main stack; the other k stacks are the side stacks.

If there exists two side stacks whose heights differ by at least 2, then we can always move the top-most bad boss of the taller side stack to the shorter side stack and decrease the loss in points. In the example below, the −10 on the left stack (of height 5) can be moved down to the top of the right stack (of height 3).

Thus, the maximum and minimum heights of these k side stacks cannot differ by more than 1.

Let the minimum height of these k stacks be h. If we consider the bottom h bosses of all k+1 stacks, we see that they still must have the property that all bosses in lower positions have point increments that are less than any boss in higher positions. Thus, they must consist of the h(k+1) bosses with smallest point increments.

Direct Greedy

We first sort the bosses in non-decreasing order of point increments. For each possible prefix P that contains only negative point increments, we take all bosses in P and distribute them evenly across the k+1 stacks. We then take the remaining bosses and place them on the tallest of the stacks (if there are multiple stacks of the same height, the result is the same).

Performing this computation naively takes O(n2) time, but this can be sped up using precomputation of weighted prefix and suffix sums to evaluate all configurations in O(n). The final time complexity is O(nlogn) due to sorting.

Smarter Greedy

Let's take all n point increments and place them in a "sliding" stack such that they are arranged in non-decreasing order from bottom to top. We will slide the stack across the k+1 playthroughs and leave the bottom point increment behind. Shown below is an example with n=8 and k=2.

Every time we slide the stack, we reduce the total by the sum of all of the point increments that we slide down by 1 position. Thus, we should only slide it down if the sum of those is less than 0 as that will give us a more optimal solution.

We notice that the point increments that we slide down always form a suffix of the point increments when sorted in non-decreasing order. The moment we stop sliding is when the sum of the suffix is non-negative, giving the optimal solution. Thus, we can find the optimal configuration directly by finding the right suffix and distributing the remaining negative point increments evenly.

Genius Greedy (found by K0u1e)

Sort the point increments in non-increasing order a1,a2,…,an. Maintain a priority queue that initially contains k+1 zeros. We now process the point increments in non-increasing order.

To process the current point increment ai, we perform the following steps in order:

Find the largest number x in the priority queue and remove it from the priority queueAdd x to our running totalPush x+ai back into the priority queueThe answer is the final total at the end. It will be left as an exercise to the reader to figure out why this solution is indeed equivalent to the previous solution.

1415F - Cakes for ClonesLet mintimei be the minimum time we can get to coordinate xi given that all previous cakes are collected and the latest created clone is already useless. Also let dpi,j be a boolean being true if we can reach a situation where we just collected the i-th cake, and our clone is currently waiting for the cake j in correct position.

Let us currently be in the position of the i-th event and the latest clone is useless (state mintimei). Then it is always optimal to collect the i-th cake with a new clone while we move somewhere. There are two possible options for further actions:

We directly go to the next event. Then we just need to update mintimei+1, and not forget to wait for the clone to collect the i-th cake.We want to leave clone somewhere waiting for some j-th cake and go take the (i+1)-th cake ourselves. Then if we have enough time to do that, make dpi+1,j reachable.Let us be in the state dpi,j (we have just collected the i-th cake, and our clone is waiting for the j-th cake). If i+1≠j, then we should just go and collect the i+1-th cake, otherwise there are two possibilities:

The j+1-th cake is collected by a new clone, then we have to updated mintimej+1.We want to leave a new clone waiting for some later cake k (after the old one collects cake j), and take the j+1-th cake ourselves, then the transition leads to the state dpj+1,k.We can collect all cakes if mintimen≤tn, or dpn−1,n is reachable.

The total complexity is O(n2), because we only loop through the position of the next clone in O(n) states.

1456E - XOR-rangesFirst, we will make all segments exclusive for convenience.

Assume we have segment (l,r), we gonna analyze the process of forming x from highest bit to lowest bit: Let hb is the highest bit such that hb-th bit of l and r are different (Apparently, bits higher than hb of x has to be same with bits of l and r). We call hb key bit of the segment. Now we set hb-th bit of x off (almost similar if we set on). From now on, we have x<r and continue considering lower bits. If the considered bit is on in l, we must set this bit on in x, otherwise, we have two choices:

Set this bit off in x and consider lower bits.Set this bit on in x and don't need to care about lower bits (Because x>l now).Let call low bits that we don't need to care free bits.Back to the problem, imagine if we fixed all non-free bits of every element, how should we set other bits in order to minimize the cost? It's quite simple: Consider i-th bit, call the pair (l,r) visible if i-th bits of l and r are non-free but ones of A[l+1,l+2,..,r−1] are free. For each visible pair such that i-th bit of endpoints in this pair are different from each other, we'll add ci to the answer. This thing inspire us to write a dynamic programming function: dp(i,l,r,state(l),state(r)) (state(l) is (f,c) with f is how did you set key bit for l-th element, and c is where is lowest non-free bit of this element (equal to or lower than i), similar to state(r)) is minimal cost at i-th and higher bits of A[l..r] such that (l,r) is currently visible. We have two types of transition:

Make (l,r) really visible by going to (i+1)-th bit.Make (l,r) invisible by choosing md(l<md<r) and choosing state(md) such that lowest non-free bit of md-th element is i.(Note that if i is the highest bit, first transition only be allowed if l+1=r)Our answer is just dp(0,0,N+1,(0,0),(0,0))

Codeforces Round #686 (Div. 3) Editorial

By vovuh, history, 2 years ago, In English1454A - Special Permutation

Idea: MikeMirzayanov

Tutorial1454A - Special PermutationThere are many possible solutions. One of them is just to print 2,3,…,n,1.

Solution1454B - Unique Bid Auction

Idea: MikeMirzayanov

Tutorial1454B - Unique Bid AuctionThis is a simple implementation problem. Let's calculate two values for each i from 1 to n: cnti — the number of occurrences of i in a and idxi — any position of i in a.

Then, let's iterate through i from 1 to n and, if cnti=1, just print idxi (because if it is the only such element then we found the winner). If we didn't find any such element, we have to print -1.

Solution1454C - Sequence Transformation

Idea: MikeMirzayanov

Tutorial1454C - Sequence TransformationFirstly, let's remove all consecutive equal elements (just keep one occurrence of each such element). For example, the array [1,1,2,3,3,3,2] becomes [1,2,3,2].

Now, the answer for each ai is almost the number of its occurrences plus one. Why is it so? Because we need to remove all segments of elements between every pair of consecutive occurrences of ai. The number of such segments is the number of occurrences of ai minus one. There is also a segment before the first occurrence of ai and a segment after the last occurrence of ai. But the first segment doesn't exist for the first element and the last segment doesn't exist for the last element.

So, after removing consecutive elements, let's calculate for each ai the number of its occurrences plus one, subtract one from the value of the first element and from the value of the last element. Then the answer is the minimum among these values for all ai.

Solution1454D - Number into Sequence

Idea: MikeMirzayanov

Tutorial1454D - Number into SequenceConsider n in this canonical form p1a1⋅p2a2⋅…⋅pkak (just find the prime factorization of n).

Let i be such an index that ai is the maximum among all values of a. Then the answer length can not exceed ai. This is because if the answer has greater length, then some number doesn't have pi in its representation (thus, there will be problems with divisibility because we are considering primes). So, let's create the answer of length ai consisting of pi. Then let's just multiply the last element by all other primes in their degrees. So, we satisfied the divisibility rule and the length of the answer is the maximum possible.

Solution1454E - Number of Simple Paths

Idea: vovuh

Tutorial1454E - Number of Simple PathsBecause our graph is just a tree with an additional edge, consider it as a cycle with trees hanged on cycle vertices.

Consider some tree hung on a vertex v on a cycle. There is only one path between each pair of its vertices (including the root which is a vertex v). So, if the tree has cntv vertices, then cntv(cntv−1)2 paths are added to the answer. What about paths that go out of a tree? Let's assume that there are cntv⋅(n−cntv) such paths (yeah, we counted only a half of actual paths from this component but this is fine). When we consider other trees, we will take into account the other half of paths.

This information can lead us to the conclusion that the only information we need to know about trees hanged on cycle vertices is the number of vertices in these trees. So, if we know cntv for each vertex on a cycle, we can just calculate the answer as ∑v∈cyclecntv(cntv−1)2+cntv⋅(n−cntv). So how to find values cntv?

Of course, there is a simple and straight-forward solution "just extract and mark all cycle vertices and run dfs from every vertex of a cycle", but there is another approach without any graph algorithms that works very well for such kind of graphs. Initially, let cntv=1 for each v from 1 to n. Let's create a queue containing all leafs of the graph. Let's take the leaf x, get its parent p, add cntp:=cntp+cntx and remove the vertex x with all edges incident to it. After that, if p became a leaf, let's add it to the queue.

We can see that after processing all leafs only cycle vertices remain in the graph, and cntv is exactly the number of the vertices in a tree (and we can just calculate the answer using the formula above).

This approach can be implemented in O(nlogn) or in O(n), there is almost no difference, but O(nlogn) one can be written a bit simpler than a linear one.

Solution1454F - Array Partition

Idea: MikeMirzayanov

Tutorial1454F - Array PartitionLet's fix the length of the first block (iterate through i from 0 to n−3). Let's also try to maximize the length of the third block using the second pointer. So, initially the length of the first block is 1 and the maximum in the block is a0 (after that, its length will be 2 and the maximum will be max(a0,a1), and so on). Let's move the left border of the third block r while ar≤a0 and the second block have at least one element.

After we expanded the third block, consider some cases: if its maximum is less than a0, then we don't need to consider this partition (we expanded the third block as much as we can but didn't find the required maximum). Otherwise, its maximum fits our conditions. Then let's find the minimum in the second block. Let it be mn. If mn<mx, this partition is also bad. If mn=mx, this partition is good, and we can just print it. Otherwise, mn>mx, and we need to fix the second block somehow. I claim that we only need to expand it by at most one element. Let's see why is it true. Consider we want to expand it to the right (the other case just uses the same logic). If we expanded our block by one element to the right and the new value in it is less than mx, then this partition is bad, and we can not use it (this is also the reason why we are trying to maximize the length of the third block). Otherwise, this value is always mx, because the first and the third blocks didn't have values greater than mx.

There are some cases in the implementation we need to consider carefully: first, we need to find the minimum in the second block fast enough. This can be done if we store it as a multiset (set with repetitions). Second, we can remove the only maximum in the third (or the first) block by expanding the second one. This can be handled easily if we just store all three blocks (not only the second one) as multisets. And the last case is that we sometimes need to move the left border of the third block to the right. This happens when we expand the first block and the second block becomes empty. So, this happens only O(n) times in total.

Total time complexity of this solution is O(nlogn).

There is also another solution from Gassa:

Let us start solving by asking the following question: in which segments will the maximal values end up?

Consider the maximum value m in the whole array. If there are at least three of them, a valid answer is to pick any maximum except the first and the last as the middle segment. For example, "3 2 3 1 3 2 3" (m=3) can be partitioned as "3 2[3]1 3 2 3" or as "3 2 3 1[3]2 3", where the middle segment is marked with square brackets. Otherwise, all m should end up in the middle segment, so that maximums to the left and to the right are less. For example, in "1 2 3 1 3 2 1", we have to put both threes into the middle segment.

Let us now calculate the minimum value v on the middle segment, considering the numbers between those equal to m. For example, in "1 2[3 1 3]2 1" the value v=min(3,1,3)=1. All numbers greater than v should also go into the middle segment, and everything between them, which can result in v decreasing even more. We have to expand the borders of the middle segment until the minimum value is such v that there are only values not greater than v left outside. Continuing with the example, we see that in "1 2[3 1 3]2 1", the middle segment should be expanded to "1[2 3 1 3 2]1". Conversely, if the maximum m was unique, then v=m, and we didn't have to expand the middle segment at this stage. For example, in "1 2 3 2 1", the current state is "1 2[3]2 1".

If the maximums to the left and to the right are exactly v, we found an answer. Otherwise, any possible middle segment contains the middle segment that we now got. So we have to expand the middle segment, either to the left or to the right. As a result, the value v may become smaller, which can cause another expansion.

What's left is to decide where to expand when we have a choice. We would like to do it greedily. Indeed, consider three values: the minimum on middle segment v, the maximum on left segment u and the maximum on right segment w. When we expand the middle segment, each of them can only decrease. And if we find an answer, the equation u=v=w will be satisfied. So, as we make the minimum of these three values smaller, we have less and less opportunities to make them equal. Thus we can pick the side of expansion after which the value min(u,v,w) is larger, and if these are equal, pick any.

For example, in the state "1 3[5 4 5]2 3 1", we have u=3, v=4, and w=3. If we expand to the left, we get "1[3 5 4 5]2 3 1" where u=1, v=3, and w=3. If we expand to the right, we get "1 3[5 4 5 2]3 1" where u=3, v=2, and w=3. Our algorithm will pick expanding to the right, however, there is no valid answer in this example anyway.

Implementation: let us precalculate the maximums on all prefixes and all suffixes of the array. Then we can expand the middle segment by one element in O(1), and the total running time is linear.

SolutionSolution (Gassa)

Editorial — Codeforces Round #685

By the_hyp0cr1t3, 2 years ago, In English1451A - Subtract or Divide

Tutorial1451A - Subtract or DivideKey Idea:

For n>3, the answer is 2 when n is even and 3 when n is odd. Cases when n≤3 can be handled separately.

Solution:

Case 1: n≤3For n=1,2,3, it can be shown that the minimum number of operations required are 0, 1, 2 respectively.

Case 2: n>3 and n is even

If n is even and greater than 2, then n2 is a proper divisor. So we can divide n by n2 to make it 2 and then subtract 1. This requires 2 operations.

Case 3: n>3 and n is odd

In this case, n can be made even by subtracting 1. From case 2, it can be seen that it will take 2 more operations. Thus a total of 3 operations are required.

Time complexity: O(1) per case

Code (C++)Code (Java)Idea by ridbit10

1451B - Non-Substring Subsequence

Tutorial1451B - Non-Substring SubsequenceKey Idea:

In each query, the answer is YES iff the first character of the given substring is not the first occurence of that character or the last character of the given substring is not the last occurrence of that character in the string.

Solution:

The condition stated above is both necessary and sufficient.

Proof that it is necessary:

Assume that a non-contiguous subsequence exists when the condition is false. If the first character of the substring is the first occurrence of its kind, then the subsequence cannot start before it. Similarly, if the last character of the substring is the last occurrence of its kind, then the subsequence cannot end after it. In such a case, the only subsequence that is of the same length as the given substring and equal to it, is the substring itself. However, this subsequence is contiguous  — which is a contradiction.

Thus, it is a necessary condition.

Proof that it is sufficient:

If the first character of the substring s[li...ri] occurs at some index j (j<li), then the subsequence sjsli+1...sri is good.

If the last character of the substring s[li...ri] occurs at some index j (j>ri), then the subsequence sli...sri−1sj is good.

Thus it is sufficient.

Time complexity: O(nq) or O(n+q) for each case depending on implementation.

Code (C++)Code (Java)Idea by the_hyp0cr1t3

1451C - String Equality

Tutorial1451C - String EqualityKey Idea:

For the answer to be YES, the frequencies of each character of the alphabet must match after performing some sequence of operations. Let freqi,a and freqi,b be the frequencies of the i-th character of the alphabet in strings a and b respectively. For each i starting from "a", we keep exactly freqi,b of the occurrences and try to to convert the rest into the next character. If at any step, this is not possible, the answer is NO.

Solution:

Consider operations of the first type. It can be shown that after some finite sequence of swaps, we can reorder the string in any way we like. This is helpful because we do not have to worry about the characters being adjacent when we perform an operation of the second type (we can always reorder the string to allow it). In other words, only frequency of the characters matter.

To convert string a into string b, we first make the frequencies of each character of the alphabet equal, then reorder the string using operations of the first type. The former can be done as described above. If for any i, there are an insufficient number of occurrences (freqi,a<freqi,b) or the remaining occurrences cannot all be converted into the next character, i.e. (freqi,a−freqi,b) is not a multiple of k, the answer is NO. Otherwise, the answer is YES.

Time complexity: O(n)Code (C++)Code (Java)Idea by Ashishgup

1451D - Circle Game

Tutorial1451D - Circle GameKey Idea:

Let z be the maximum integer such that the point (kz,kz) is within the circle. If the point (kz,k(z+1)) is also within the circle, player 1 wins. Otherwise player 2 wins.

Solution:

Regardless of what move player 1 makes, player 2 can force the token to be at some point on the line x=y at the end of his turn (if player 1 moves up, player 2 can move right and vice versa).

Case 1: (kz,k(z+1)) lies outside the circle

Player 2 can guarantee his victory in this fashion as player 1 will not have any moves left after reaching the point (kz,kz). Player 2 wins.

Case 2: (kz,k(z+1)) lies within the circle

After player 1 makes his first move, player 2 finds himself in the same situation as player 1 did in the previous case. That is, player 1 can ensure that they reach either (kz,k(z+1)) or (k(z+1),kz) in the same way. Points (k(z+1),k(z+1)) and (kz,k(z+2)) do not lie within the circle as by definition

d2<k2(z+1)2+k2(z+1)2<k2z2+k2(z+2)2.Thus player 2 will not have any moves left and player 1 wins.

Code (C++)Code (Java)Idea by Utkarsh.25dec

1451E1 - Bitwise Queries (Easy Version)

Tutorial1451E1 - Bitwise Queries (Easy Version)Key Idea:

a+b=(a⊕b)+2∗(a&b)Pick and distinct i,j,k and find ai+aj=x, ai+ak=y and aj+ak=z by querying their XOR and AND values (6 queries). This is a system of linear equation with three equations and three variables and thus us a unique solution.

Solving it you get the values of ai, aj, and ak. You can then get the remaining n−3 values using n−3 more queries. This uses a total of n+3 queries. Realize that aj ⊕ ak = (ai ⊕ aj) ⊕ (ai ⊕ ak) to reduce the number of initial queries from 6 to 5, for a total of n+2 queries.

Solution:

Lets take a look at the properties of the 3 operations we have, specifically what information we can recover from it.

AND - lossy in information about bits that are on, cant be used to recover the valuesOR - lossy in information about bits that are off, cant be used to recover the valuesXOR - lossless, a ⊕ (a ⊕ b) gives us b again.So clearly xor operations are going to be the core of recovering the values. If we can find one of the values, we can find the remaining n−1 values using xor queries.

But how do we get that first value?

Lets try to think about this for a operation for which we know how to obtain the individual values - addition. If we had a+b=x, a+c=y and b+c=z, we could just solve the three linear equations to obtain the answer.

So what's the difference between xor and addition anyway?

If the i-th bit is off in both the numbers, xor and addition both give 0.If the i-th bit is on in exactly oneof the numbers, xor and addition will both give 2i .But what about if the i-th bit is on in the both the numbers? Then addition contributes 2∗2i to the answer while xor contributes 0.Is there some way to recover this value? Well if i-th bit is on in the both the numbers, the AND will contribute 2i to the answer. So we can realize that a+b can be rewritten as (a ⊕ b) + 2× (a & b).

So now if we just choose positions 1, 2 and 3, we can obtain x=a1+a2, y=a1+a3 and z=a2+a3 using 3 XOR and 3 AND operations. Furthermore we can realize that a2 ⊕ a3 is just (a1 ⊕ a2) ⊕ (a1 ⊕ a3), so we can save one more operation.

Now solving the above simultaneous equations, we get a1 = x+y−z2. Now for 2≤i≤n, ai is just a1 ⊕ (a1 ⊕ ai). We already calculated a1 ⊕ a2 and a1 ⊕ a3 for the previous step, and can calculate the remaining xor values in n−3 steps.

So in total we use exactly 5+(n−3) = n+2 queries, which is enough to get AC.

Code (C++)Code (Java)Idea by Ashishgup and ridbit10

1451E2 - Bitwise Queries (Hard Version)

Tutorial1451E2 - Bitwise Queries (Hard Version)Key Idea:

Query the n−1 xor values of the form (1,i), for 2≤i≤n initially.

Since numbers lie in the range [0,n−1], one of two cases can arise:

1. There exists indices j, k such that aj=ak. This can be found as ai ⊕ aj = ai ⊕ ak. So we can just use the query aj & ak to get the value of aj. Now we can find the remaining values using the xor values previous queried in(n−1)+1=n queries.

2. All integers in the range [0,n−1] are present. There exists (several) pairs j,k such that aj ⊕ ak = n−1. This implies that neither of the numbers have any bits in common and as such aj & ak = 0, allowing us to save one query compared to E1. Thus we need (n−1)+3−1=(n+1) queries.

Solution:

Now we have to eliminate 1 more query but we are yet to use the info that all values of a are in the range [0,n−1].

It may be tempting to try to remove a xor query, but it is unlikely this will work, as we would not be able differentiate between two arrays which are equal in n−1 places and differ in the position we didn't check. As such it doesn't seem probable that we can recover the exact value if we don't use n−1 xor operations.

Since we'll need them anyway, lets go ahead and find a1 ⊕ ai for all 2≤i≤n.

Then clearly we have to eliminate 1 of the 3 AND queries.

Since numbers lie in the range [0,n−1], one of two cases must arise:

At least one value is repeated. Clearly if a1 ⊕ aj=a1 ⊕ ak, then aj=ak. So we can use the already queried xor values to check if there exists two such values. Its easy to see that x & x is x itself, so we can get the value of aj using the query aj & ak. Now we can just the xor values to find the remaining values. This needs (n−1)+1=n queries.All integers in the range [0,n−1] are present.We're trying to find a pair of values (aj,ak) for which we can find aj & ak without needing to query it. However we don't have any equal pair like the last case.The next easiest value that comes to mind would be 0. Can we easily select a pair with AND value zero based on just the info we currently have? Well if the i-th bit of aj ⊕ ak is on, then it must undoubtedly have been on in either aj or ak, not both. But we can't make any such statements about a bit being off, since the bit could be off in both (satisfying the condition), or on in both (doesn't satisfy nonzero AND).So can we choose a pair (aj,ak) such that all bits are on? Yes we can, this value will be n−1 since n is a power of 2 and there will be n2 pairs which equal it ((0,n−1), (1,n−2), (2,n−3), etc). So we can just find any one pair such that aj ⊕ ak = n−1.Now we know aj & ak = 0 and can reduce the number of required AND queries by 1. So we will need (n−1)+3−1=(n+1) queries.It is easy to see that these two cases cover all situations possible and in both cases we can find the answer in at max (n+1) queries which is enough to get AC.

Code (C++)Code (Java)Idea by FastestFinger, Ashishgup and ridbit10

1451F - Nullify The Matrix

Tutorial1451F - Nullify The MatrixLet's consider diagonals d of the form r+c - the diagonals where the sum of row index (r) and column index (c) is constant. Then xor of a diagonal d will be xor(d)=a(r1,c1)⊕a(r2,c2)⊕...a(rn,cn), such that r1+c1=d, r2+c2=d, .... rn+cn=d.

Solution: If ∀d,xor(d)=0 at the start of the game, then Jeel wins. Else, Ashish wins.

Proof:

Let's define two states S and S′:

S : ∀d,xor(d)=0S′ : ∃d,xor(d)≠0Lemma1: Any move on S converts the matrix to S′.

Proof: If we are in state S, xor(r1+c1)=0. Since, we need to anyhow decrease value of (r1,c1), xor(r1+c1) will become non-zero. Hence, any move on S converts the matrix to S′.

Lemma2: There always exists a move on S′ to convert it to S.

Proof: If we are given an S′ state, we can convert it into S as follows: Note that the diagonals between (r1+c1) and (r2+c2) can be arbitrarily changed to any value. (r1,c1) can only be decreased in value. Let (r1+c1) be such a diagonal that there is no diagonal d<r1+c1 with xor(d)!=0. Also, in order to ensure that we can make xor(r1+c1)=0 by decreasing, we select such a cell (r1,c1) whose largest set bit is equal to the largest set bit of xor(r1+c1). In this way, we ensure that diagonal r1+c1 can be made 0. Now, we need to fix (r2,c2). Let's fix (r2,c2) such that there is no diagonal d>r2+c2, such that xor(d)!=0. Since, (r2, c2) can be increased as well as decreased, we can easily make xor(r2+c2)=0. The diagonals in between can be arbitarily changed, so making them 0 is trivial. At the end of this move, all diagonals have become 0. Hence, given a state S′, we can always convert it to S.

Due to Lemma1 and Lemma2, a person starting on state S′ can always stay at S′ and can always force the opponent to start on state S. Since the state at the end of the game will be S, the opponent will always lose.

Complexity: O(n∗m)Code (C++)Code (Java)Idea by Jeel_Vaishnav

Codeforces Round #684[Div1 and Div2] Editorial

By Mehrdad_Sohrabi, history, 2 years ago, In EnglishWe want to mention BamiTorabi who we thank for helping us with translating the problems and writing the tutorials, and also we apologize for div1 A2 and B hopefully you will forgive us :( .

1440A - Buy the StringWe will consider each character seperately. Look at the i-th character; if it is originally a 1, we can either change it to a 0 and pay h+c0 coins for this specific character, or we can not change it and pay c1 coins for it. Since we want to pay as little as possible, we take the minimum of these two. So if the ith character is a 1, we will have to pay min(c1,h+c0) coins for it. A similar logic can be used for the zeroes; if the ith character is a 0 we will have to pay min(c0,h+c1) coins. So we iterate over s, and for each character we add the required minimum to the sum, depending on whether it's a 0 or 1.

Time complexity: O(n)Prepared by Mohammad.H915 Editorial by Mehrdad_Sohrabi

official solution1440B - Sum of MediansWe will consider a greedy approach. We take the ⌈n2⌉ biggest numbers from the end of the array and the ⌊n2⌋ smallest numbers from the beginning. We take these elements as one group, erase them from our array and then continue the same procedure on the remaining array. This can be done in a loop of O(k), by taking every ⌈n2⌉th character. We can also prove this claim. Imagine we have marked k elements to be the medians of these arrays. Each one of these elements need at least ⌈n2⌉−1 elements bigger than them and at least ⌊n2⌋ elements smaller than them to form a group in which it they are the median. So we can always push the biggest of these k numbers forward until we have exactly ⌈n2⌉−1 elements bigger than them, and by pushing forward the sum of medians either doesn't change or gets larger. So our algorithm will always give the biggest possible answer.

Time complexity: O(nk) for each testcase

Prepared by Mohammad.H915 Editorial by Mehrdad_Sohrabi

official solution1439A2 - Binary Table (Hard Version)Consider two cases: If n=2 and m=2, there are only 4 possible operations, and we can use up to 4 operations. So, one can check all the 24 possible ways of choosing these operations, and seeing which combination of these operation will result in a full 0 grid.

Otherwise, at least one of n and m is bigger than 2. Without loss of generality imagine n>2. Take the nth row. For each cell within that row, we can use one operation on it, its left neighbour and the two cells above to fix this cell. We can do this for the first n−2 cells in the row, and fix the last two with one operation on them. We will make at most n−1 operations and reach a situation with one empty row. We can take the last row away and apply this procedure for the remaining (n−1)×m grid. If we say inductively that we will have at most (n−1)m operations for the remaining grid, we will have done at most (n−1)m+n−1=nm−1<nm operations in total. When n=2, we can do the same with the columns, and when n=m=2, we can fix the remaining 2×2 grid as we discussed above.

Time complexity: O(nm) for each case.

Prepared by Mohammad.H915 Editorial by Mehrdad_Sohrabi

official solution1439B - Graph Subset Problemdiv1 B :

It is easy to see that if k>2m−−−√ the answer is −1; because if k>2m−−−√, no matter whether we have a clique of size k or a subset of the graph with δ≥k, we will have more than m edges in total.

Now, the main idea is to suppose u is the vertex with minimum degree; if d(u)<k−1 we should delete u becuase u can not be in clique or the subset of vertices such that each vertex of this subset has at least k neighbors in the subset; so we have to erase u and all edges attached to it.

If d(u)>k, remaining vertices will form a subset that every vertex have at least k neighbors in the subset, so we'll print this subset as answer.

If d(u)=k−1, we consider u and all neighbors of u as candidate for clique of size k. then we erase u and all edges attached to it.

If we erase all vertices and didn't found any good subset, then we should check clique candidates.

for checking clique candidates fast, iterate over vertices and name current vertex v. then for neighbors of v set neiv to 1 and 0 otherwise. for each clique candidate that contains v like C, we check edge between v and u∈C in O(1) using array nei.

every time we find new clique candidate, we remove at least k−1 edges, so number of clique candidates is at most mk−1. for every candidate we check O(k2) edges in overall. so time complexity is O(mk).O(k2)∈O(m.k).

Prepared by AliShahali1382 Editorial by Amoo_Safar

official solution1439C - Greedy ShoppingWe can prove that the hungry man will eat at most log2(maxY) continiuous subsegments, where maxY is the maximum amount of money possible. Why is that so? Suppose the hungry man buys a meal from the i th shop but can't buy a meal from the (i+1)th one after that. Then, the money the hungry man had before buying the ith food is at most twice the money he has after buying the ith food because ai>ai+1. So every time he breaks the subsegment of shops, his money is cut in at least half, so he will eat atmost log2(maxY) continuous subsegments.

Now we need a data structure with the following queries: range_max and range_sum. Since our array is non-increasing, a segment tree will suffice. The first type of query is just a range_max query. For the second type of query you can find the first element that is equal to or smaller than the hungry man's money and after that find the segment that he will eat, in which we can use a binary-search on the tree to find these both. After that we can repeat this action untill we reach the end of the array, or until his money runs out.

Time complexity: O((n+q)log(maxY)log(n))prepared by Mehrdad_Sohrabi Editorial by Mehrdad_Sohrabi

official solutionTutorial is loading...prepared by Mehrdad_Sohrabi Editorial by Mehrdad_Sohrabi

official solutionO(n2) solution1439E - Cheat and WinFirst let's solve the problem on arbitrary trees. Consider the following game: on some vertices of the tree we have some tokens. At each step you remove a token from some vertex and put a token in any subset of its ancestors. The first game can be transformed to this one by putting a token in each black vertex. So now we'll solve the new game.

Obviously the game is independent for different tokens, so we can use Grundy numbers. After working around some examples you can find that the Grundy number for a vertex at height h is 2h. it can be easily proved by induction since any number less than it can be built by exactly one subset of it's ancestors.

Consider the binary representation of the grundy for the game(let it be S). Each cheating move means reversing the bits of a prefix of S. So the minimum number of operations needed can be shown as T=(S[0]⊕S[1])+(S[1]⊕S[2])+... Since each operation decreases this expression at most once, we will need at least T operations, and there is an obvious way to make S equal zero with that number of operations.

Now to solve the original problem, we need to find a compressed tree of the marked vertices and then represent the black vertices as union of O(m) paths from the root. After this we can finally calculate the compressed form of the total Grundy number and find the answer. For compressing the tree we need to do some operations, like sorting the vertices by starting time(dfs order), finding the LCA of 2 vertices, etc. in O(H) time, where H=log(109).

How to do these? Well they can be done with the following observation (the details are left for the reader but they can be found in the model solution):

For some h, consider the tree on these 3 set of cells:T1:0≤x<2h,0≤y<2hT2:0≤x<2h,2h≤y<2h+1T3:2h≤x<2h+1,0≤y<2hOne can see (and can prove) that these 3 trees are similar; so this gives us some recursive approach.

Time complexity: O(mH), where H=log(109).

Prepared by AliShahali1382 Editorial by AliShahali1382

official solution

Meet IT Codeforces Round Editorial

By kpw29, 3 years ago, In EnglishThank you very much for taking part in the contest!

Contest timeline1447A - Добавьте конфет

Tiny hintWe're only interested in differences between the elements. Is there another way to express the operation?

HintThe operation in the i-th turn is equivalent to selecting one element and subtracting i from it.

SolutionThe sequence 1, 2, ..., n satisfies task's constraints. After the additions all positions will contain n⋅(n+1)2 candies.

1447B - Коробка с числами

HintWe want to minimize the number of negative numbers as much as we can by applying the operations. What is the minimum possible number of those negatives?

SolutionLet X be the number of non-zero numbers in the grid, and let's see what happens in different scenarios.

both cells have negative numbers, then X goes down by 2.both cells have positive numbers, then X goes up by 2.one cell has a positive number while the other one has a negative number, then X stays the same.It is important to notice that we can apply this operation not only for the two neighboring cells, but for any two — to achieve this effect we apply this operation on any path between the cells consecutively.

The parity of X never changes. So, for even X the answer is the sum of the absolute value of all numbers, S. Otherwise, one element will not be positive in the end -- so it's best to choose the one with minimum absolute value, V, and subtract 2⋅V from the sum.

The existence of zeroes doesn't really change anything, both formulas output the same value in such a case.

This gives us a solution in O(N⋅M)1447C - Рюкзак

HintAre there any items which you can put in the knapsack to fulfill the goal with one item? What happens if there are none?

SolutionIf there is an item of size C satisfying: ⌈W2⌉≤C≤W, it is enough to output only that item. Otherwise, we should exclude items which are larger than the size of the knapsack and take a closer look at the situation. Consider greedily adding items in any order until we find a valid solution or run out of items.

This is correct because all items have sizes less than W2, so it is not possible to exceed knapsack size by adding one item in a situation where the sum of items C doesn't satisfy constraint ⌈W2⌉≤C≤W.

This gives us a solution in O(n).

Alternative solutionFrom the analysis above, we can also conclude that greedily adding the items from largest to smallest if they still fit in the knapsack will always find a solution if one exists.

This gives us a solution in O(nlogn).

1447D - Ловя мошенников

HintThis is a dynamic programming problem. Recall the DP calculating the Longest Common Substring for two strings. What similarities are there in our setup, and what differs?

Key observationIf a substring has a negative score, we can throw it away and start from scratch.

SolutionLet DP[i][j] be the maximum similarity score if we end the first substring with Ai and the second substring with Bj. We will also allow the corresponding most similar string to be empty so that DP[i][j] is always at least 0.

It turns out that the fact we need to search for substrings of our words is not a big problem, because we can think of extending the previous ones. In fact, we have just two possibilities:

Ai and Bj are the same letters. In this case, we say that DP[i][j]=min(DP[i][j],DP[i−1][j−1]+2) as the new letter will increase the LCS by 1, but both of the strings increase by one in length, so the total gain is 4−1−1=2.

In every case, we can refer to DP[i][j−1] or DP[i][j−1] to extend one of the previous substrings, but not the LCS, so: DP[i][j] = max(DP[i-1][j], DP[i][j-1]) — 1.

An inquisitive reader may wonder why it doesn't hurt to always apply case 2 in calculations, so clearing the doubts, it's important to informally notice that we never get a greater LCS this way so wrong calculations only lead to the worse score, and that our code will always find a sequence of transitions which finds the true LCS as well.

Implementing the formulas gives a really short O(n⋅m) solution.

1447E - Ксор дерево

Small hintsIs it possible that the graph formed has a cycle? How to evaluate whether a sequence is good?

First stepSince we have n edges and two of them must coincide (the pair of numbers with the smallest xor), we will have at most n−1 edges in the graph. Thus, we only need to check if the resulting graph is connected. How to do it?

HintLet's look at the most significant bit, and group the numbers into two sets S0 and S1, depending on the value of the bit. What can we say about sizes of S0 and S1 in a good sequence?

Next stepIt is easy to see that if 2≤|S0| and 2≤|S1| then the whole sequence isn't good, as for any number in Si the smallest xor will be formed by another number in Si. So there won't be any connections between the numbers forming the two sets.

Thus, one of the sets must have no more than one element. If that set contains no elements, then the solution can obviously be calculated recursively. If it instead had one element, then as long as we make the other sequence good, it will be connected to something — and thus the whole graph.

SolutionLet F(S) be the maximum possible number of values we can take from S so that they form a good sequence. Divide the numbers into S0 and S1 as above. If S0 or S1 is empty, strip the most significant bit and solve the problem recursively. Otherwise, the result is 1+max(F(S0),F(S1)). Straightforward recursive calculation of this formula gives the runtime of (n⋅30), as all numbers are smaller than 230.

1447F1 - Задача о частотах (простая версия)

HintWhat can you say about the values which are the most frequent ones in the optimal solution?

First stepsLet D be the most frequent value in the whole sequence. If D is not unique, we output n. Otherwise, we can prove that one of the most frequent values in an optimal solution is D.

Proof of the observation aboveWe'll prove this by contradiction. Consider an optimal interval [a,b] in which D is not in the set of most frequent values. Let's think of the process of expanding the interval to [a−1,b], [a−2,b], ..., [1,b], [1,b+1], ..., [1,n]. Since D is most frequent in the entire sequence, at some point in this process it will appear the same number of times as at least one of the other most frequent values. The corresponding interval will also satisfy the task's conditions, hence [a,b] cannot be an optimal interval if D does not appear most frequently.

Consequence of the observationFor each value V we can solve the task when (D,V) are the most-frequent values independently, ignoring other values. Now we would like to solve the following subproblem: find the longest interval of sum 0 where elements in the array are either 1 (V), −1 (D) or 0 (other values). The solution's complexity should be proportional to the frequency of V in order to obtain an efficient solution for the entire task.

Why the simplification worksYou might be worried that we can't simply ignore the other values, since they may end up being more frequent than (D, V) in the interval that we've found. This might be true, but can only be an underestimation of the optimal interval's length. A similar expanding argument to the proof above shows that:

we never overestimate the resultfor the values of (D, V) which form the optimal interval we find exactly the right interval value.Solution for the easy versionFor the easy version, it's sufficient to consider all pairs (D, V) in linear time, by using the standard algorithm which computes the longest interval with sum 0. Thus, we get a solution with complexity O(100⋅n).

Hint for the subproblemA bit of thinking may lead you to the observation that solving the task in O(nlogn) or even O(nlog2n) isn't pleasant. The constraints are low enough to allow an O(nn−−√) solution, how about giving it a try?

Solution of the subproblemIf an element V appears more than n−−√ times, we can simply brute-force this pair with partial sums (D,V) in O(n).

For the other elements, for all the appearances of V we'll consider only at most |V|+1 neighboring occurrences of D to search for the optimal interval. We can generalize the brute-force solution to work for this case too, by writing a function that solves just for a vector of interesting positions. Don't forget to take into account extending intervals with zeroes as well.

With proper preprocessing, this gives a solution in O(|V|2) per value V. Therefore, total runtime is bounded by O(nn−−√).

1446E - Долгое выздоровление

SetupWe're interested in the longest possible recovery path, so let's imagine choosing the longest sequence of operations ourselves. How long can this process last?

The upper boundLet P be the number of pairs of neighboring cells with different state. Consider what happens to P after an operation where we change the state of a cell c. It can be seen that P decreases by 1 if c had a neighbor with the same state as c, and P decreases by 3 if all the neighbors of c had a different state. Let's call the first kind of operation cheap and the other expensive.

When does the organism remain sick?We now know that the process cannot last forever. When is it possible that the patient never recovers? If at some point there is a cycle of infected cells, then none of them can ever become healthy. Conversely, if there is no cycle of infected cells, and not all cells are healthy, then it is possible to make some infected cell healthy. If A is the initial set of infected cells, let A¯¯¯¯ be the set of cells which can eventually be infected. By the above, we should output SICK if and only if A¯¯¯¯ contains a cycle.

We can compute A¯¯¯¯ using a BFS. No cell with coordinates outside of [0,500)x[0,500) will ever become infected, so we can safely make the BFS linear in the number of cells in this region.

SolutionLet's assume that A¯¯¯¯ contains no cycle. We want to determine the minimum possible number of expensive operations used during the process of making all the cells healthy. We can consider each connected component of A¯¯¯¯ separately and add the results, so let's suppose A¯¯¯¯ is connected. The very last operation must be expensive, since it changes the state of an infected cell with three healthy neighbors. There is one other case where we need an expensive operation: if there's no way to make a cheap operation at the very beginning. In fact, this can happen only if A consists of three cells arranged in a 'triforce'. It turns out that we never need any other expensive operations.

So, assuming A¯¯¯¯ contains no cycle, we can compute the longest possible recovery period as follows. Compute the number P of pairs of neighboring cells with different states. Subtract twice the number of connected components of A¯¯¯¯. Subtract twice the number of connected components of A¯¯¯¯ for which the corresponding cells in A are just three cells arranged in a triforce.



Note that the observation that the bad beginning component is only a triforce is actually not necessary to code a working solution (one can just check if there's a cheap move at the beginning, just remember that we're inspecting components of A¯¯¯¯), but it will help us to prove the solution formally.

ProofLet's now prove that we never need any other expensive operations than the ones described. Suppose A is a set of at least 2 infected cells, such that (i) A¯¯¯¯ is cycle-free, (ii) A¯¯¯¯ is connected, and (iii) A is not a triforce. We claim that there is a some cheap operation, such that the resulting set A′ of infected cells still satisfies (i), (ii) and (iii). We will always have (i), since A′¯¯¯¯¯⊆A¯¯¯¯, so we just need to worry about (ii) and (iii), i.e. we need to ensure that A′¯¯¯¯¯ is connected and that A′ is not a triforce.

We need to consider a few different cases.

Suppose there is a cheap infection operation. Then just perform it. The resulting set A′ will have A′¯¯¯¯¯=A¯¯¯¯ still connected, and A′ will not be a triforce since it has adjacent infected cells.

Suppose there is no cheap infection operation, but there is a cheap operation turning a cell c from infected to healthy. Consider what happens if we perform it. Since there is no cheap infection operation, any cell in A¯¯¯¯∖A must have three neighbors in A. So it has at least two neighbors in A∖c. So it lies in A∖c¯¯¯¯¯¯¯¯¯¯¯. So A∖c¯¯¯¯¯¯¯¯¯¯¯⊇A¯¯¯¯∖c. We claim that (ii) is satisfied, i.e. A∖c¯¯¯¯¯¯¯¯¯¯¯ is connected. If c is a leaf in A¯¯¯¯, this is clear, since removing a leaf from a tree does not disconnect it. If c is not a leaf in A¯¯¯¯, then it has at least two neighbors in A∖c¯¯¯¯¯¯¯¯¯¯¯, so A∖c¯¯¯¯¯¯¯¯¯¯¯=A¯¯¯¯ is again connected. So the only possible issue is with (iii), i.e. A∖c might be a triforce. In this case, A must be a triforce with an extra cell added, and we should just have chosen another c.

Suppose there is no cheap operation. This means that no elements of A can be adjacent (since a tree with more than one vertex has a leaf). Moreover, any element of A¯¯¯¯∖A is surrounded by elements of A. Because A has at least 2 cells and A¯¯¯¯ is connected, we must somewhere have three cells in A arranged in a triforce. See the picture below. The green cells are not in A since no elements of A are adjacent, and the red cells are not in A since A¯¯¯¯ is cycle-free. So A cannot have any cells other than these 3, since A¯¯¯¯ is connected.

 

This covers all cases, finishing the proof.

1446F - Расстояние до прямой

Stupid hintBinary search is your friend. To determine if the answer is bigger or smaller than r, we need to count the number of pairs of points A, B such that d(O,AB)>r.

Geometric insightWe need to reformulate the condition d(O,AB)>r to make the counting easier.

Draw a circle of radius r centered on O, and consider two points A, B strictly outside the circle. Note that d(O,AB)>r if and only if AB does not intersect this circle.

Now draw the tangents from A, B to the circle. Let the corresponding points on the circle be A1,A2,B1,B2. Observation: the line segments A1A2,B1B2 intersect if and only if AB does not intersect the circle. Moreover, if we pick polar arguments a1,a2,b1,b2∈[0,2π), for the points in the circle, such that a1<a2 and b1<b2, then the line segments intersect if the intervals [a1,a2],[b1,b2] overlap.

We don't need to worry too much about precision errors, because if r is close to the real answer, then it doesn't matter what our calculations return.

(To compute a1, note that cos∠AOA1=r/|OA|. So we get a1,a2 be adding / subtracting cos−1r|OA| from the argument of A.)

Proof of observationWe can prove the observation by considering three different cases, shown in pictures.

 

One circle segment contains the other, and the line AB intersects the circle outside the segment AB.

 

The circle segments are disjoint, and the line segment AB intersects the circle.

 

The circle segments partially intersect, and the line AB does not intersect the circle.

Final detailsNow we have computed some intervals and want to find the number of pairs of intervals which partially overlap. To do this, first sort the endpoints of the intervals. Do some coordinate compression on the left endpoints. Build a Fenwick tree on the compressed coordinates. Sweep through the endpoints. Whenever you see a left endpoint, add it to the tree. Whenever you see a right endpoint, remove it from the tree, query the tree for the number of points greater than the corresponding left endpoint, and add the result to the answer.

Codeforces Round #682 (Div. 2) Editorial

By SleepyShashwat, history, 2 years ago, In EnglishThank you for participating, and I hope you enjoyed the problems! Once again, we're sorry about the round being unrated.

Also, here are video editorials by BRCode:

Problem A and BProblem CProblem DProblem EProblem F1438A - Specific Tastes of AndreThe array a = [1,1,…,1,1] is perfect since the sum of every subarray is exactly equal to its length, and thus divisible by it.

1438B - Valerii Against EveryoneWe claim the answer is NO if and only if the elements are pairwise distinct.

If any element has two occurrences, we can trivially select them as the two subarrays. Otherwise, since all elements are distinct, choosing a subarray is the same as choosing the set bits of a 109 digit long binary number. Since every number has a unique binary representation, no two subarrays can have the same sum.

1438C - Engineer ArtemThe increment by one operation essentially allows us to change the parity of any position. Let's color the matrix like a chessboard. Since every pair of adjacent cells consist of cells with different colors, we can make values at all black cells even and values at all white cells odd.

1438D - Powerful KseniaWe will first solve the problem for odd n, and then extend the solution to even n.

Note that applying the operation to a,b,b makes all of them equal to a. Thus, we can try making pairs of equal elements. This is easy for odd n:

While at least 3 unpaired elements exist, apply the operation on any 3.Pair any two of them and repeat.Finally, we will have just one unpaired element left, using which we can make all elements equal as described at the start.The number of operations used is exactly n−1.

Let us denote X as the xor of all elements in the original array.

To solve for even n, we note that applying the given operation does not change X.

Since the xor of an even number of same elements is 0, the answer is impossible for arrays with X≠0.

To solve for even n and X=0, we can just solve the problem for the first n−1 using the odd approach and the last element will magically be equal to the first n−1.

This problem was set by Anti-Light and prepared by knightron00

1438E - Yurii Can Do EverythingIt's natural to think that the number of good subarrays cannot be very large; this is indeed true.

The following algorithm works:

Fix the left endpoint l. Let k be the most significant set bit in al.Check every r in increasing order by bruteforce while sum(l+1,r−1) is smaller than 2k+1.Reverse the array, and do the same again. Note that we need to be careful here since we might count the same subarray twice.We, now, prove its correctness and efficiency.

Consider any good subarray a[l...r], let k1 be the most significant set bit in max(al,ar) and k2 the most significant set bit in sum(l+1,r−1). We must have k1≥k2 because all bits greater than k1 will be unset in al⊕ar, but k2 is set. Hence, the algorithm counts all possible good subarrays.

We now prove the number of subarrays our algorithm checks is of the order O(nlogai). For every r, let's count the number of l's it can be reached by. For a particular k, notice that only the 2 closest l's to the left with this bit set can reach this r. For the third one and beyond, the sum will be at least 2∗2k=2k+1 simply due the to the contribution of the closest two. Since there are n right endpoints and only logai possible values of k, our claim is true.

1438F - Olha and IgorThe solution is as follows.

Query 420 random triples.Let c1 and c2 be the two most frequently returned nodes  — these are the children of the root.Query c1,c2 with every other i, and only the root will return i.Firstly, note that a query — u, v, and w — returns a node x that minimizes the sum of distances from all the three nodes. Thus, the order of the 3 nodes is irrelevant. You can think of x as the node that lies on the path of every possible pair formed from the 3 nodes.

Now, let's calculate the number of triples for which node u is returned as the answer. For this, we will root the tree at u, and calculate the subtree sizes of its children  — s1, s2, and s3 (s3=0, if u is the actual root). With these values with us, the number of triples is:(s1×s2×s3)+(s1×s2)+(s2×s3)+(s3×s1)

In the above expression, the first term calculates the triples in which u is not present, while the other 3 terms assume u is one of the nodes in the triple. Nodes at the same depth will, of course, have the same count.

At this point, we can either observe that this expression is maximum when u is a child of the root or calculate values for every depth and compare them.

For example, for h=5, each child of the root is the answer to about 23% of the triples. This value converges to 18% per child when h approaches 18. Thus, when we query 420 random triples, we can be sure enough that the two most frequently appearing values will be the children of the root.

Finally, we just note that for all non-root nodes v, querying c1, c2, and v gives either c1 or c2.

Time Complexity: O(n)

VK Cup 2019-2020 -- Engine Editorial

By 300iq, 2 years ago, In English1443A - Kids SeatingNote that this seating arrangement for children satisfies all conditions: 4n,4n−2,4n−4,…,2n+2.

1443B - Saving the CitySince the activation of any mine explodes the entire segment of mines, which it is, you can immediately replace the input string with an array of mine segments. We now have two operations. We can delete any segment by a coins, or turn two adjacent segments [l1,r1], [l2,r2] (r1<l2) into one segment for b⋅(l2−r1). That is, two segments can be deleted for a cost of 2⋅a or a+b⋅(l2−r1). This means that you need to merge two segments while b⋅(l2−r1)≤a. You need to go through all adjacent segments and check this condition.

1443C - The Delivery DilemmaIf we order a courier with time x, then all couriers with time y<x can also be ordered, since they do not change the answer (all couriers work in parallel). Therefore, you can sort the array, couriers always bring the prefix of the array, and Petya will go for the suffix. The time prefix is the maximum b[i], and the suffix is the sum a[i]. Therefore, you need to calculate the suffix amounts and go through all the options.

1443D - Extreme SubtractionThe problem sounds like this — check that there are increasing and decreasing arrays, the element-wise sum of which is equal to the given array.

This problem can be solved greedily. Let's maximize each element of the decreasing array (let's call this array a, and the increasing one b). Suppose initial array is v and we have solved the problem on a prefix of length i−1. Then, for the element a[i], a[i]≤a[i−1] and v[i]−a[i]≥b[i−1] must be fulfilled. Rewriting the second inequality and combining with the first one, we get a[i]≤min(a[i−1],v[i]−b[i−1]). It is clear that taking a[i]=min(a[i−1],v[i]−b[i−1]) is best by construction.

1443E - Long PermutationLet's notice that most of the elements in the original permutation will not change during all queries. Since the maximum permutation number does not exceed 1010, only the last 15 elements of the permutation will change.

Thus, after each query of the second type, you need to generate a permutation with the corresponding number.

To answer the query of the first type, you need to split the segment into two parts: we sum the part of the segment that fell in the last 15 elements in a simple cycle and calculate the other part of the segment using the formula of an arithmetic progression.

1442B - Identify the OperationsConsider element with index i that has value b1 in the array a — ai. There are three options:

Both ai−1 and ai+1 are present in the array b. Then both of them should stay in the array a after the first operation  — we will write them down later on. However, ai can only be added to the array b while removing one of the neighbors. We have reached a contradiction, so the answer is 0.One of the numbers ai−1, ai+1 is present in the array b, another is not. Then we have to remove the one that is not present in b and continue solving the problem.Neither ai−1 nor ai+1 is present in b. ai is not present in any other place in b (because all number in b are unique), and ai−1, ai and ai+1 are indistinguishable by the following operations. Let us then remove any one of them (say, left) and "remove" all remaining tags. In this case, we can multiply answer by 2 and continue solving the problem.Now we know that the answer is either 0 or a power of 2. To calculate the answer we only need to implement the above-mentioned algorithm. Let us store a set of available numbers in the array a, and a set of numbers that are yet to appear in the array b to implement necessary checks. The solution will have O(nlogn) complexity (that can be optimized to O(n) with help of arrays and double-linked lists, but it was not necessary for this particular problem).

1442C - Graph TranspositionsConsider a sequence of actions that moves the token from vertex 1 to vertex n. Let us say it has A token movements and B graph transpositions. This sequence takes A+2B−1 seconds.

Note that the optimal path does not visit any edge twice. That means we need to consider only paths with A≤m. Consider another sequence consisting of A′ token movements and B′ graph transpositions. Let lm=⌈log2m⌉. Note the following. If B<lm<B′ then A+2B−1 < A′+2B′−1. This is true because the difference between A and A′ does not exceed m and 2B′−2B>m. This gives us the following: if there is any sequence of actions with B<lm that moves the token from vertex 1 to vertex n then optimal path's B is less than lm too. Let us check this with the following algorithm, and if it is so, find the optimal sequence of actions.

We can now build a new graph that consists of lm copies of the original graph:

Reverse all the edges in every even graph copy.For every vertex u add new edge between k-th and k+1-th copies of vertex u with weight 2k−1 for k=1…lm−1.We can find optimal paths from the first copy of vertex 1 to all the copies of vertex n using Dijkstra algorithm. Shortest of these paths would correspond to the answer: movement along a copy of original edge denotes token movement; movement along a new edge denotes graph transposition.

If the algorithm found no paths, then the sequence of actions that moves the token to from vertex 1 to vertex n consists of at least lm+1 transpositions. Note that if lm<B<B′ then A+2B−1 < A′+2B′−1. It means that all sequences of actions can be compared using ordered vector (B,A) lexicographically.

Let us build another graph consisting of 2 copies of the original graph:

Reverse all the edges in the second copy of the graph.Assign (0,1) to weights of all of these edges.For every vertex u add two new edges between copies of u: from the first to the second copy and back. Weights of both edges is (1,0).Let us find optimal paths from the first copy of vertex 1 to both copies of vertex n using Dijkstra algorithm. Let (B,A) be the length of the shortest one. New graph allows us to restore the optimal sequence of actions that moves the token from vertex 1 to vertex n that will take A+2B−1 seconds.

1442D - SumStraightforward dp solution, where s(i,j) – max possible sum after j operations on first i arrays and transition in O(k), has complexity of O(nk2) or precisely O(k⋅min(nk,∑i=1nti)) and doesn't fit into the time limit.

Taking into account the fact that the arrays are sorted helps to optimize it.

Consider the optimal solution. Let's denote as xi number of operations on i-th array. Let's call the array partially removed if we applied at least one operation to that array, but the array is not yet empty.

Consider two partially removed arrays within the optimal solution and integers p and q where 0<xp<tp and 0<xq<tq. Assume, without loss of generality, ap,xp+1≤aq,xq+1. Let y=min(xp,tq−xq)≥1. If we replace y operations on p-th array with y operations on q-th array, total sum will increase by ∑i=1yaq,xq+i−∑i=1yap,xp+1−i≥y⋅aq,xq+1−y⋅ap,xp+1≥0, but the number of partially removed arrays will lower by 1. We can repeat that substitution until we get a single partially removed array.

Now we need to identify the single partially removed array in the final solution. Every other array can either all be Vasya's pocket, or remain as is. We can solve the knapsack problem with (n−1) items, with array sizes as weights and sum of array's elements as value. For each 0≤w≤k we need to find g(w) – max possible total value of items with total weight w. The only remaining step is to brute force the size of prefix, Vasya removed from the single partially removed array and combine it with g(w).

Solving each knapsack problem independently results in O(n2k+∑i=1nti) complexity, but the similarities between the problems allows to optimize down to O(knlogn) using divide and conquer approach.

Let's split the items into two halves of approximately similar size. Before going in recursively into the first half we will relax dp values with each element of the second half (just like in usual knapsack problem) and undo the changes after.

This way as soon as we reach the subset with just one piece we have already calculated dp for every other piece. Adding each piece into dp takes O(logn), each relaxation takes O(k), final complexity is O(knlogn+∑i=1nti).

1442E - Black, White and Grey TreeLet's solve the task step by step:

Suppose that tree is a bamboo without the grey vertices. Such a tree can be viewed as an array of colors 1 and 2. We can see that if there are two adjacent vertices of equal color, we can always delete them together in one operation. We can merge adjacent vertices of the same color, and get an array of colors b1,b2,…,bk, such that bi∈{1,2};bi≠bi+1. Such an array can be defined by two numbers — b1,k.We can see that such an array b of length k can not be deleted in less than ⌊k2⌋+1 removals. It can be proved by induction. Also, you can delete all elements in this number of removals by deleting opposite leaves (after the first removal opposite leaves will have the same color).

Let's solve the task for a general tree without grey vertices. Let's assign the edge uv with weight 0 if au=av, and 1 otherwise. Let's find the longest path (diameter) in this weighted tree, and let it be the vertices v1,v2,…,vm. We can see this path as bamboo from the previous paragraph, and find the corresponding value k for this path (it is equal to diameter + 1). It is obvious that we can't delete the tree in less than ⌊k2⌋+1 removals (otherwise we would be able to delete the bamboo in a smaller number of removals).Turns out that we can delete all vertices in this number of removals. We can do the same algorithm — let's delete the opposite leaves of diameter, and also let's delete all leaves in the tree that have the same color (why not). After one such removal, our path will still be a diameter (if another path becomes the diameter, then one of its leaves should have the same color, and was going to be deleted).

We can find the diameter in such a 0/1 tree in linear time, or we can solve the task even simpler. We can see that we alternate the removal of black and white vertices, and we delete all the leaves with the same color. So, we can choose the first operation (delete black or white), and at each iteration just delete all corresponding leaves. It works in linear time.

Let's solve the task without additional constraints. Now there are the grey vertices. How do they change the solution? Let's see at the last removal — suppose we deleted vertex v, which was not grey. Then we can imagine that we make v the root of the tree, and paint all the grey vertices in the color of their parents. Then we have a tree without grey vertices, which we can solve. Obviously, the answer for such a colored tree is not less than the answer for the initial tree (because we can make the same removals as in a colored tree). But we can see that we can't get the smaller answer, as by coloring grey vertices we effectively removed them from the tree, and the value ⌊k2⌋+1 (over subsequences of black and white vertices) hasn't changed.So, overall, the solution is to choose the first removal (1 or 2), and alternate removals of black and white vertices. For removal of c∈{1,2} we delete all the leaves with color 0 or c. Also, we can note that the tree remains connected in this process.

1442F - Differentiating GamesLet's first solve the problem for an empty graph. To do this we need to build a construction with not too many edges, where all vertices are pairwise not equivalent.

For acyclic graph, there is not such construction. All Grundy functions of vertices should be different, so they must be integers from 0 to n−1. The only such graph is full, and it has quadratic number of edges. Moreover, if there is a part from which no cycles are reachable, it must be full acyclic graph, so it can't be too big.

So, how can other graph look? No vertices can be equivalent to any of vertices in acyclic part. The easiest way to achieve it is to add a loop to every vertex. Let's note, that after doing so all this vertices can't be losing in sum with any other game, because we can just go through loop and don't change anything. So, this games differ from each other be set of games in sum with which they would be winning, not draw. One can see, that such a game would be winning with any acyclic game, it have a move to, because we can go to it, and this will be move to acyclic game with Grundy function 0. The game would be draw with any other acyclic game (and with not acyclic too, but this is not important for solution). This is true, because if we don't move in game with loop, resulting position is not winning. Therefore, to win we must go out from loop vertex. But than we come into acyclic game with non-zero Grundy function, and it's winning, so we can't win. And we can go through loop, achieving a draw.

So, we need to build a graph, with acyclic part of full graph on k vertices, and all other vertices should have a loop and some edges to this k vertices, and all vertices should have different set of edges. If done, all vertices would be pairwise distinguishable by k queries for each acyclic part vertex. If any of them is lost, this vertex is chosen. If all of them is winning or draw, than the vertex with loop, which have an edge if and only if sum with this vertex is winning, is chosen. In opposite to acyclic case, we can distinguish exponentially many vertices.

Returning to the initial problem, one can get k=20, and get all subsets of size 0, 1 and 2, and required part of subsets of size 3. In such a graph there would be 190+980+1⋅0+20⋅1+190⋅2+769⋅3=3877 edges. The only remaining part is to understand what to do with existing edges.

One can not, then in built construction any edges between vertices with loops can be added, because they change nothing. If position is winning, then after first move they become unreachable, and doesn't change anything. If it was draw, they can't change anything too, because they are led to vertex with loop, which can't be losing.

Let's use 20 vertices, which have no edges outside of this set as vertices of acyclic part. Initial graph was acyclic, so we can find such vertices. Let's add loop to all other vertices. Now, we need to modify graph in a way that all sets of edges to acyclic part would be different. Let's go through vertices in any order, and change minimal possible number of edges, so, that this vertex set would not be equal to any of previous. For first vertex we won't do anything. For next 20 vertices, we would need to change at most 1 edge. For next 190 vertices, we would need to change at most 2 edges, and at most 3 for others. This led us to the same 3877 edges to change.

In general case we can do either O(nlogn) edges changes and O(logn) queries or O((d+1)∗n) edges changes and O(d!n−−−√d) queries. For this problem we need d = 3.

Codeforces Round #680 Editorial

By ch_egor, 2 years ago, translation, In EnglishThanks for the participation!

1445A - Array Rearrangment was authored by meshanya and prepared by ch_egor

1445B - Elimination was authored by Helen Andreeva and prepared by ismagilov.code

1444A - Division was authored by vintage_Vlad_Makeev and prepared by grphil

1444B - Divide and Sum was authored and prepared by NiceClock

1444C - Team-Building was authored by V--o_o--V and prepared by wrg0ababd

1444D - Rectangular Polyline was authored by Zlobober and prepared by DebNatkh

1444E - Finding the Vertex was authored by V--o_o--V and prepared by 300iq

1445A - Array RearrangmentIt's enough to sort a in non-decreasing order and sort b in non-increasing order and check, whether ai+bi≤x for all i.

Correctness can be proven by induction: let's show that if answer exists, there is a solution with minimum in a and maximum in b are paired. Let ma be minimum in a and mb be maximum in b. Let p be number paired with ma and q be number paired with mb. Since solution is correct, ma+p≤x and mb+q≤x. Since ma≤q, ma+mb≤x. Since p≤mb, p+q≤x. So, ma can be paired with mb.

1445B - EliminationThe answer is at least max(a+b,d+c) because we have at least 100 participants with the sum of a+b and at least 100 participants with the sum of d+c.

If we have 99 participants with points equal to (a,c), and 2 participants with points equal to (a,b) and (d,c), then the 100th participant will have a total of max(a+b,d+c) points, and the condition will be met, because a≥d, c≥b and a+c≥max(a+b,d+c).

1444A - DivisionLet y=p/x. Let's assume, that there exists prime a, such that a divides y, but q is not divisible by a. Then we can multiply x and a and the result will still divide p, but will not be divisible by q. So for maximal x there is no such a.

Let's assume, that there are two primes a and b, such that they both divide y, and both divide q. Because q is not divisible by x, there exists some prime c (c can be equal to a or b), such that number of occurrences of c in x is less than number of occurrences of c in q. One of a and b is not equal to c, so if we will multiply x and such number, the result will not be divisible by q. So for maximal x there are no such a and b.

That means that x=p/(power of some primal divisor of q). So to find maximal x, we have to find all prime divisors of q (we have to factorise q for it in time O(q√)) and for each of them divide p by it until result is not divisible by q. That will be all our candidates for greatest x. We will do all of that in time O(q√+logq⋅logp).

1444B - Divide and SumNo matter how we split the array, the cost of a partition will always be the same.

Let's prove it. Without loss of generality we will consider that the array a sorted and denote for L the set of elements with indexes from 1 to n, and for R the set of elements with indexes from n+1 to 2n.

Then split the array a into any two arrays p and q of size n. Let's sort p in non-decreasing order and q by non-increasing order. Any difference |pi−qi| in our sum will be the difference of one element of R and one element of L.

If this is not the case, then there is an index i such that both pi and qi belong to the same set. Let's assume that this is L.

All elements with indexes less than or equal to i in p belong to L (i elements)All items with indexes greater than or equal to i in q belong to L (n−(i−1) elements)Then L has at least i+n−(i−1)=n+1 elements, but there must be exactly n. Contradiction. For the set R the proof is similar.

Then the answer to the problem is (the sum of the elements of the set R minus the sum of the elements of the set L) multiplied by the number of partitions of the array Cn2n.

Complexity: O(nlogn) (due to sorting)

1444C - Team-BuildingYou're given an undirected graph without loops and multiple edges, each vertex has some color from 1 to k. Count the number of pairs of colors such that graph induced by vertices of these two colors will be bipartite.

Let's check for each color whether the graph induced by it is bipartite (for example, using depth-first search). This can be done in O(n+m). We will not use non-bipartite colors further since they can't be in any pairs.

Now let's construct a slow solution that we will make faster later.

Consider some color x. There're edges from vertices of this color to vertices of colors y1,y2,…,yk. Let's check whether the graphs induced by pairs (x,y1),(x,y2),…,(x,yk) are bipartite (also using depth-first search), thereby finding out which colors cannot be in pair with x. The others can. After doing this for each color x, we can find the asnwer.

How fast does this work? Notice that any edge between different colors we will use in DFS only two times. The problem are edges between vertices of the same color, we can use them up to k times, and there can be a lot of them.

Let's solve this problem and construct a faster solution.

A graph is bipartite if and only if it doesn't contains odd cycles. Consider some connected bipartite component induced by color x. If a cycle goes through this component, it doesn't matter how exactly it does it. If the path of the cycle in this component ends in the same side where it has started, then it has even length, and odd otherwise. This fact lets us compress this component to two vertices (one for each side) connected by one edge. For each color this way we compress all components formed by it.

Now we have the compressed graph, where all connected components are either one vertex or two vertices connected by one edge. Let's do the same process we did in slow solution and check every connected pair of colors whether the graph induced by it is bipartite.

To check the pair (x,y), for each edge between vertices of colors x and y in the original graph add a new edge to the compressed graph between corresponding vertices. After that use DFS to check if graph is bipartite, rollback the changes and do the same for all other pairs.

How long does this work for one pair (x,y)?

Let's start DFS only from components that were connected by added edges, since the others do not affect whether the graph is bipartite or not, but there can be a lot of them. This way DFS will use only added edges and some edges between vertices of the same color x or y. However, there will be at most two times more of the latter than the added, because each added edge connects at most two new components, and each new component has at most one edge. So, we check one pair in the time proportional to amount of edges between its colors, and it sums up to O(m) for all pairs.

So, the whole solution works in O(n+m) or O(mlogn), depending on the implementation.

1444D - Rectangular PolylineFirst, note that in a correct polyline, since the horizontal and vertical segments alternate, h=v: if this equality does not hold, the answer is negative. Now let's fix a vertex and go around the polyline in some direction. Then in the process of traversin, we will move in one of four possible directions: up, down, right or left. Since the polyline is closed, this means that we will move to the left in total by the same distance as we will move to the left in total. The same is true for moving up and down.

This means that if we split all the segments into four sets named Up, Down, Left, Right, then the total length of the segments in Up will be equal to the total length of the segments in Down, and the total length of the segments in Right will be equal to the total length of the segments in Left. But it means that the set of lengths of all horizontal segments can be divided into two sets with the same sum. The same should hold for vertical segments.

Let's check whether it is possible to divide the set of lengths of horizontal segments into two sets of the same sum. This classic problem can be solved by applying the dynamic programming method to solve the backpack problem. The complexity of this solution will be O(nC2) If it is impossible to split horizontal or vertical lengths into two sets of equal length, the answer is "No". Now we will show how to construct a correct answer if such divisions exist.

Let us divide all horizontal lengths into two sets of equal total length. We denote the smaller set as R, and the larger set as L. We will do the same with the set of lengths of vertical segments: we will denote the smaller set as D, and the larger one as U. Since |R|≤|L|, |R|≤h/2=v/2. Similarly, we have v/2≤|U|, which follows that |R|≤|U/, |D|≤|L|.

Now let's divide all the segments into pairs as follows: each segment of R, we match with a segment from U. All remaining segments of L are matched with one of the remaining vertical segments. Thus, we have divided all these segments into three sets of pairs: in the first one, a segment from R is paired with a segment from U. In the second set a segment from L is paired with a segment from U. In the third set a segment from D is paired with a segment from L.

From the first set of pairs, we make up the set of vectors directed up and to the right (from the pair (r, u), we construct the vector (r, u)). This way we can construct a set of vectors A. We will do the same with the second set of pairs (constructing a set of vectors B) and the third set of pairs (constructing a set of vectors C). for a better understanding, see the picture above. Note that the set B may be empty, while the other two can not.

Let's make a convex polyline from the vectors of A. In order to do this, sort them in ascending order by the polar angle and make a polyline from them in this order (see the picture below).

Now we will replace each of the vectors of our polyline with two vectors: one vector directed to the right and one vector directed upwards.

We will do the same for vectors from C: sort them in ascending order by the polar angle and make a convex polyline from them:

Let's combine these two polylines so that the first one goes from the point O to the point A and the second one goes from the point B to the point O:

We don't have much left to do: we hate to connect the points A and B using vectors from the set B. Let's take these vectors (directed up and to the left) in any arbitrary order, then, since the sum of all vectors is 0, the resulting polyline, if you draw it with the beginning at the point A, will end at the point B. Since the first two polylines were convex, this means that none of the points of the first two polylines will lie strictly inside the angle AOB, which means that if you replace each of the vectors of the third polyline with two vectors, one directed to the left and one directed upwards, the resulting closed polyline will not contain self-intersections.

It is easy to show that the resulting polyline will be closed and will satisfy all the conditions of the problem:

1444E - Finding the VertexConsider the optimal strategy.

Some edge will be your first query, mark it with a number 0.

After that, build similar colourings (recursively) for components on both sides of the edge, but increase their weights by one (to have only one zero in total).

This colouring corresponds to the strategy, and if k is the maximum weight of an edge in it, then this strategy can find a vertex in k+1 queries in the worst case.

This colouring has a wonderful property that helps us identify the vertex: on a path between any two edges with the same colour an edge with the smaller colour presents.

And any colouring with this property corresponds to a proper strategy! (Each time you can ask an edge with the smallest weight in the current component)

To make it easier for us, "invert" all weights in the colouring, mark the first edge with the weight k−1, and then use the same construction as we had before for our colouring, but now subtract 1 from the edges (weights should remain non-negative).

Now our goal is to find colouring with the min weight of the max edge, such that each pair of edges with the same colours have an edge with the larger colour between them.

We will build this colouring using subtree DP.

For the fixed colouring of a subtree of the vertex v, let's see which colours are visibile if you will look from v towards the subtree.

The colour is visible, if there is such an edge of this colour, that there are no edges with the larger colour on a path from this edge to v.

Potential function of our colouring is the sum 2c1+2c2+…+2ck, where ci are visible colours. Note that this value is a long number! Because our answer can be large.

Lemma: we are interested only in the colouring of our subtree with the smallest potential.

Assume that all subtrees of vertex v are already coloured into colourings with the smallest potentials.

Then we have to choose some weights of edges outgoing from v, such that after adding these edges to v, different subtrees won't have common visible colours (otherwise you will get a bad pair of edges of the same colour).

You can color an edge from vertex v to its child u in a colour c, if a colour c is not visible from u. After that, all weights smaller than c will disappear from the set of visible colours, but the colour c will be added.

You have to change colourings of the subtrees in this way, to not have carries during the addition of the potentials (it will correspond to the situation without common visible colours). Under this constraint, we have to minimize the total sum, the potential of v.

From this setting, the proof of the previous lemma is clear: for larger values of the potential, possible choices are not better.

You have to solve a problem: you are given an array a1,a2,…,ak of long binary numbers. You have to find an array with the smallest sum b1,b2,…,bk, such that bi>ai, and no carries will happen during the addition b1+b2+…+bk.

You can solve this problem with a quite simple greedy algorithm: we will set bits greedily from left to right, and check that we can finish our goal with the fixed prefix. To check that you can get some answer with the fixed prefix of bits and the upper bound on the used bits, you can go from left to right and each time when you have to replace some number to the current bit, replace the number with the largest suffix. You can implement it in a naive way in O(n3), but it also can be implemented in O(nlogn).

You have to solve this subtask n times, and we will get the solution with complexity O(n⋅T(n))=O(n2logn…n4).

Codeforces Round 679 (Div. 1, Div. 2) and Technocup Round 1 editorial

By Golovanov399, 2 years ago, In EnglishSorry for the issues with a couple of problems

Problem A of tc/div2 (Finding Sasuke)1413A - Finding SasukeThe following is always a valid answer: −a2, a1, −a4, a3, ..., −an, an−1.

Problem B of tc/div2 (A New Technique)1413B - A New TechniqueTo solve this problem it's sufficient to find the position of each row in the table. If we consider the first number of each row and find a column containing it, we will automatically obtain the position of the row. Since all numbers are distinct, the positions will be determined uniquely.

Problem C of tc/C div2/A div1 (Perform Easily)1413C - Perform EasilyConsider all possible frets we may need to use. To do this we sort all the pairs (bj−ai,j) lexicographically. Now we need to find a subsegment with the minimal range containing the first fields and also so that all numbers from 1 to n occur among the second fields (so it will mean that for each note there is at least one string-fret combination).

For each l, denote the minimal right(l) so that [l,right(l)] is a valid subsegment. It's easy to see that right(l)≤right(l+1), because if [l+1,right(l+1)] contains all numbers from 1 to n among the second fields, then so does [l,right(l+1)]. So to find all right(l) one can just use two pointers, maintaining the set of notes that occur on the segment.

Once we calculated it, we just print the minimal difference between the first fields of the endpoints of all possible segments [l,right(l)]. The final complexity is O(nmlog(nm)).

Problem D of tc/D div2/B div1 (Shurikens)1413D - ShurikensLet's note that if a shuriken of price x is being bought right now, then the only information we obtain about all the remaining shurikens is that they are of prices ≥x. It's also clear that if we consider two shurikens on the showcase then the one which was placed earlier has the stronger constraints (as written above).

Now consider all events that can happen when the shuriken of price x is bought. If for all shurikens that are currently on the showcase we know that they must have prices >x, then the answer is negative. Otherwise, for all shurikens that had a lower bound of something less than x we increase it to x, and remove any one of them, because we cannot remove any other shuriken, and these are indistinguishable. However, since we know that the last placed shuriken has the weakest constraint, we can just remove the last placed shuriken each time and check the consistency in the end. This verification can be done using any min-heap. The final time complexity is O(n⋅logn).

Problem E of tc/E div2/C div1 (Solo mid Oracle)1413E - Solo mid OracleIt will be easier to explain using illustrations. We will use timelines, where each cast spell instance will occupy a separate row; and each second will be represented as a column.

First of all, if a>b⋅c then the answer is −1. Indeed, after time t the total amount of damage dealt is (a−bc) for each spell which has expired completely plus some damage from spells which have not expired. The first summand can be as great as we want it to, and the second one is bounded by, say, −bc2 as there are at most c spells which have not yet expired, and each of them healed the enemy by at most b units each second, for at most c seconds. Therefore, the damage may be arbitrarily huge.

On the other hand, if a≤bc, then the answer always exists, and here is why. First of all, let's only look at the moments divisible by d — that is, the moments when damage was dealt. It is obvious that for every other moment t the enemy had less (or the same amount of) health at time t−1. Second, if t≥c, then the enemy had no more health than now at the moment t−d. Indeed, the difference between damages then and now is exactly one full-lasted spell, which is non-negative, as we know. For clarity take a look at the pictures below:

So now we know that we may consider only t<c, and it follows in particular that the answer exists. Also, when in general should we subtract d from t to obtain a more damaged enemy? One can see that if t<c then the damage we subtract is a−tb, and since t=dk for some integer nonnegative k, then we subtract a−bdk damage. It makes sense to do this while a−bdk<0:

In other words, we have reduced the task to the following: find the greatest k so that a≥bdk, and cast the spell (k+1) time. The enemy will have the least amount of health just after we cast the spell for the (k+1)-st time. The answer is thus a(k+1)−k(k+1)2bd. The time complexity of this solution is O(1) per test.

One could also find out that the enemy's health is convex over time and use ternary search to find the minimum. It requires O(logmaxanswer) per test, which is still ok.

Problem F of tc/D div1 (Roads and Ramen)1413F - Roads and RamenFix any diameter of the tree. One of the optimal paths always starts at one of the diameter's endpoints.

Proof:



Let AB be a diameter of the tree, and the optimal answer be EF. Then the parity of the number of stone roads on DE is the same as on DF, and also the same holds for CE and CF. Since a diameter has the greatest length among all paths in the tree, the stone roads parity is different on AC and on BC (otherwise, the diameter would be an answer). Hence, the stone roads parity on CE coincides with one of AC and BC. Assume without loss of generality that the stone roads parities of AC and CE are the same. Then the path AE contains an even number of stone roads. Note that since AB is a diameter, AC is no shorter than CF, hence AD is no shorter than DF, which implies that AE is not shorter than EF. This means that there is an optimal path starting at one of the diameter's endpoints.

Now remaining is to solve the problem if one of the endpoints is fixed. If we root the tree from it, and write down for each vertex the stone roads parity between it and the root, then each query is basically changing the parity of a subtree. In an euler-tour traversal every such subtree is represented by a contiguous subsegment. Now the original problem can be reformulated in a following way: we have a binary array, there are queries of type "flip a subsegment", and after each query we need to find a zero with the greatest depth parameter. This can be done via a segment tree, where in each node we store the deepest zero and the deepest one on the subsegment corresponding to that node. The final time complexity is O(nlogn).

Problem E of div1 (A Convex Game)1434E - A Convex GameIt's sufficient to calculate the Grundy value for each game instance. Consider a single game. Let maxc be the maximal value in the sequence v. We are going to prove that the Grundy value does not exceed 2⋅maxc−−−−−−−√+1.

Proof: Assume the contrary; that is, that the Grundy value equals d>2⋅maxc−−−−−−−√+1. Then, by definition, there is a sequence vi0, vi1, ..., vid−1 which is a valid sequence of moves. Indeed, initially there is a move into a position in game with the value d−1, then there is a move from it to the position with value d−2, and so on. It's easy to see that vij+1−vij≥j+1 for all j≤d−2. Then vid−1−vi0≥d(d−1)2≥(d−1)(d−1)2≥maxc, which leads to a contradiction.

It is clear from the statement that the outcome of the game is defined by the index of the last move and the last difference between the elements. It follows from the Grundy theory that if we fix the last index and gradually decrease the last difference, the grundy value will not decrease. It'd be great to calculate the value of dp[i][d] standing for the maximal possible last difference so that the Grundy value equals d, for each index i and each possible Grundy value d. This, in its turn, can be done by calculating maxv[d][i] being the maximal vj so that after the move from vi to vj the Grundy value will equal d. If we know it, then, standing at some index j and knowing the range of last differences so that the Grundy value equals d for all d (we can obtain it from the values of dp[i]), we need to remax the values of maxv[d] on some subsegment. Hence, we can already implement a segment tree solution working for O(n⋅maxc+∑mi⋅2⋅maxc−−−−−−−√⋅log(mi)). However, it's too long.

Now recall that the initial array is increasing in each game. This means that during the calculation of dp and maxv from left to right, we only need to remax something a single time (the first time). This operation can be done via DSU, if we compress subsegments of all already calculated values and one not yet calculated into a single component. Then the final time complexity will be O(n⋅maxc+∑mi⋅2⋅maxc−−−−−−−√⋅α(mi)).

Codeforces Round #678 (Div. 2). Editorial

By Vladik, 2 years ago, translation, In English1436A - ReorderYou can notice that the i-th number in the array will be included in the sum i times, which means that the value aii will add ai to the sum. That is, the permutation of the elements does not affect the required sum, and therefore it is enough to check whether the sum of the array elements is equal to the given number.

Author: aropan

author's solution: 96602393

1436B - Prime SquareFirst, note that the numbers 0 and 1 are not prime. Now let's try to build a square from only these numbers. To begin with, fill in the main and secondary diagonal of the square with ones.

If n is even, then the sum in each row and each column is 2 (prime number), and we have met the condition.

If n is odd, then the sum in the row with the number n+12 and in the column with the number n+12 will be equal to one. To fix this, add ones to the cells (n2,n+12) and (n+12,n+12+1). As a result, the sum in columns and rows will be equal to two or three, and we have fulfilled the condition of the problem.

Author: AleXman111

author's solution: 96598752

1436C - Binary SearchLet's simulate a binary search algorithm. Initially, we have the required position pos. For the next middle position in the binary search, we can determine exactly whether the next number at this position should be greater or less than x. For all other positions, the values can be eiteher greater or less than x. As a result of the simulation of the algorithm, we have cntBig positions at which numbers must be greater than x and cntLess positions at which numbers must be less than x. Let the large numbers be hasBig, and the smaller ones hasLess. Now let's count the number of ways to place large numbers in cntBig positions using the formula C(hasBig,cntBig)⋅cntBig!.

Let's calculate in a similar way for smaller numbers, and the product of the resulting results will be the answer to the problem.

Author: AleXman111

author's solution: 96598711

1436D - Bandit in a CityFirst, let's assume that all the citizens are at the root of the tree. Then the answer to the problem will be ⌈a1leaves⌉, where leaves is the number of leaves in the tree. According to the Dirichlet principle, this would be the minimum possible number of caught citizens.

The answer to the original problem is maxi⌈sumavleafsi⌉, where v lies in the subtree of i, leavesi is the number of leaves in the subtree i.

Consider some vertex i, for which it is impossible to split the citizens equally. Then there will be a vertex m in which in the optimal splitup will have the maximum number of citizens. Obviously, it is not profitable for us to send any citizen from vertex i to m.

In this case, we can go one level down in the tree in the direction of m. We will repeat this step until we can divide the citizens equally. Hence it is clear why the above formula is correct.

Author: hloya_ygrt

author's solution: 96727317

1436E - Complicated ComputationsLet's iterate over the answer. Let the current answer be x, then we can get it only when there are no subarrays, whose MEX is x. Note that we need to check the MEX of the subarrays that are between all occurrences of x. This can be done, for example, using a segment tree, processing its occurrences in order. A number for which MEX is not found will be the answer.

Author: andrew

author's solution: 96601544

1436F - Sum Over SubsetsLet's calculate the required product of the sums ansi for the sets, the greatest common divisor of the elements of which is i. First, let's select all the elements that are divisible by i. To find only those sets whose GCD is exactly i, one can find the product of the sums for all subsets and subtract the answers of all ansj such that i<j and i divides j without a remainder. To find the products of all subsets of a set of k elements, consider two cases:

the product ai⋅ai will be counted 2k−2⋅(k−1) times. Each element in the set A can be removed and this will add the product a2i. The number of elements k−1 and the number, select the rest of the subset 2k−2;the product ai⋅aj will be counted 2k−3⋅(k−2)+2k−2. The first term is similar to the example above. And the second is obtained if ai is removed from the set A - the number of ways to choose a subset of k−2 elements is 2k−2.It is only to count the individual sums ai⋅ai and ai⋅aj for all elements that are divisible by i. To do this, you can maintain for already added numbers their number, sum, sum of squares of numbers and pairwise sum of numbers. The answer to the problem will be ans1.Author: hloya_ygrt

author's solution: 96727345

P.S. We will add our own solutions soon

Codeforces Round #677 (Div. 3) Editorial

By vovuh, history, 2 years ago, In EnglishI'm really sorry about issues with problems E and F. Can't say anything more because I don't want to justify my mistakes.

1433A - Boring Apartments

Idea: vovuh

Tutorial1433A - Boring ApartmentsThis problem has a lot of solutions. You could even hard code all possible tests to solve it. But this problem has O(1) solution. Let the digit of x be dig. Then our character pressed each digit before dig exactly 10 times (1+2+3+4). And the amount of times he pressed the digit dig depends on the length of x. Let len be the length of x, then the amount of times he pressed the digit dig is 1+2+…+len=len(len+1)2. So the final answer is 10⋅(dig−1)+len(len+1)2.

Solution1433B - Yet Another Bookshelf

Idea: vovuh

Tutorial1433B - Yet Another BookshelfWe can notice that the answer is the number of zeros between the leftmost occurrence of 1 and the rightmost occurrence of 1. Why is it true? Let's take the leftmost maximum by inclusion segment of 1 and just shift it right. We can see that using this algorithm we will do exactly described amount of moves and there is no way improve the answer.

Solution1433C - Dominant Piranha

Idea: vovuh

Tutorial1433C - Dominant PiranhaIf all the piranhas have the same size then the answer is -1. Otherwise, there are at least two different sizes of piranhas and the answer always exists. Claim that the answer is such a piranha with the maximum size that one of the adjacent piranhas has the size less than a maximum.

Why is it true and why the answer always exists? First, if the piranha with the maximum size eats some other piranha, it becomes the only maximum in the array and can eat all other piranhas. Why is there always such a pair of piranhas? Let's change our array a bit: replace every maximum with 1 and every non-maximum with 0. There is always some 01-pair or 10-pair in such array because we have at least two different elements.

Solution1433D - Districts Connection

Idea: MikeMirzayanov

Tutorial1433D - Districts ConnectionIf all districts belong to the same gang then the answer is NO. Otherwise, the answer is always YES (yeah, as in the previous problem). How to construct it? Let's choose the first "root" as the district 1 and connect all such districts i that a1≠ai to the district 1. So, all disconnected districts that remain are under control of the gang a1. Let's find any district i that ai≠a1 and just connect all remaining districts of the gang a1 to this district. This district always exists because we have at least two different gangs and it is connected to the remaining structure because its gang is not a1. So, all conditions are satisfied.

Solution1433E - Two Round Dances

Idea: MikeMirzayanov

Tutorial1433E - Two Round DancesFirstly, we need to choose the set of n2 people to be in the first round dance (the other half is going to the second one). The number of ways to do that is (nn2). Then we need to set some order of people in both round dances, but we don't want to forget about rotation (because rotation can lead us to counting the same ways several times). So, the number of ways to arrange people inside one round dance is (n2−1)!. This is true because we just "fixed" who will be the first in the round dance, and place others in every possible order. So, we need to multiply our initial answer by this value twice because we have two round dances. And, finally, we have to divide our answer by 2 because we counted "ordered" pairs (i.e. we distinguish pairs of kind (x,y) and (y,x) but we don't have to do that). So, the final answer is (nn2)⋅(n2−1)!⋅(n2−1)! divided by 2. This formula can be reduced to n!n22⋅2.

You could also find the sequence of answers in OEIS (and this can be really useful skill sometimes).

Solution1433F - Zero Remainder Sum

Idea: MikeMirzayanov

Tutorial1433F - Zero Remainder SumThis is pretty standard dynamic programming problem. Let dp[x][y][cnt][rem] be the maximum possible sum we can obtain if we are at the element ax,y right now, we took cnt elements in the row x and our current remainder is rem.

Initially, all states are −∞ except dp[0][0][0][0]=0.

Transitions are standard because this is a knapsack problem: we either take the element if cnt<⌊m2⌋ or don't take it. If the element ax,y is not the last element of the row, then transitions look like that:

dp[x][y+1][cnt][rem]=max(dp[x][y+1][cnt][rem],dp[x][y][cnt][rem]) — we don't take the current element.dp[x][y+1][cnt+1][(rem+ax,y)%k]=max(dp[x][y+1][cnt+1][(rem+ax,y)%k],dp[x][y][cnt][rem]+ax,y) — we take the current element (this transition is only possible if cnt<⌊m2⌋).The transitions from the last element of the row are almost the same, but the next element is ax+1,0 and the new value of cnt is always zero.

The answer is max(0,dp[n][0][0][0]).

Solution1433G - Reducing Delivery Cost

Idea: MikeMirzayanov

Tutorial1433G - Reducing Delivery CostIf we would naively solve the problem, we would just try to replace each edge's cost with zero and run Dijkstra algorithm n times to get the cheapest paths. But this is too slow.

Let's try to replace each edge's cost with zero anyway but use some precalculations to improve the speed of the solution. Let's firstly run Dijkstra n times to calculate all cheapest pairwise paths. Then, let's fix which edge we "remove" (x,y).

There are three cases for the path (a,b): this edge was not on the cheapest path before removing and is not on the cheapest path after removing. Then the cost of this path is d(a,b). The second case is when this edge was not on the cheapest path before removing but it is on the cheapest path after removing. Then the cost of this path is min(d(a,x)+d(y,b),d(a,y)+d(x,b)). So we are just going from a to x using the cheapest path, then going through the zero edge and then going from y to b using the cheapest path also (or vice versa, from a to y and from x to b). And the third case is when this edge was already on the cheapest path between a and b but this case is essentially the same as the second one.

So, if we fix the edge (x,y), then the answer for this edge is ∑i=1kmin(d(ai,bi),d(ai,x)+d(y,bi),d(ai,y)+d(x,bi)). Taking the minimum over all edges, we will get the answer.

The precalculating part works in O(nmlogn) and the second part works in O(km).

Solution

Codeforces Round #676 (Div. 2) Editorial

By flaviu2001, history, 2 years ago, In English1421A — XORwice

Idea and solution: flaviu2001

HintThink about addition in base two. Say a = 10101 and b = 1001. What your operation does is it modifies the bits in your numbers, so if the first bit in a is 1 and the first bit in b is 1 (as is the case above) you can make both 0 by making that bit 1 in x. This is actually the only way you can decrease the resulting sum, so x = 1 is an answer above.

SolutionNoticing the hint above we now deduce x = a & b where & is bitwise AND. So just printing (a ⊕ (a & b)) + (b ⊕ (a & b)) works, but there's an even nicer formula. We'll leave it up to you to prove that (a ⊕ (a & b)) + (b ⊕ (a & b)) = a ⊕ b, where ⊕ is the bitwise XOR :)

1421B — Putting Bricks in the Wall

Idea: flaviu2001, solution: flaviu2001 and stefdasca

HintIt's hard to use the two valuable switches somewhere in the middle of the matrix, a much wiser choice would be to somehow block the S cell or the F cell. Perhaps you can set both neighbours of S to 1 to force Roger to pick 1.

SolutionIf we pick the neighbours of S to be 1 we can make the neighbours of F 0 and there would be no way to go from S to F. But this requires in the worst case 4 switches, which is not good enough. Luckily, in order to get down to 2 switches we only have to consider the other way around, making the squares neighboring S become 0 and the squares neighboring F 1. There must be a solution of the two with at most two switches and you won't get from S to F since you're forced to pick 1 (or 0) and can't get past the neighbours of F which are opposite.

1421C — Palindromifier

Idea and solution: flaviu2001

HintYou're not allowed to just pick the whole string and append its reversed result to the front, but what's the next best thing? We're very close to the answer if we take the whole string except for a letter (so for abcde we make dcbabcde).

SolutionThe operation above which transformed abcde into dcbabcde is very close, if only we could've somehow append e to the left. Turns out you can set that up, so from abcde first append d to the end, then you have abcded. Now apply the operation from the hint on this string and get edcbabcded. See why we added that d first? We can now append it to the front just like we wanted!. Do the operation L 2 and the job is finished.

Yep, amazingly just printing

R n−1L nL 2works!

1421D — Hexagons

Idea: flaviu2001, solution: flaviu2001 and koala_bear00

HintUsing too many edges in the solution feels wasteful, the solution surely has some neat line as straight as possible. Perhaps we can prove only two edges are required?

SolutionIndeed two edges are required in the solution, so one approach would be picking all combinations of edges and do linear algebra so see how many times each is required (or if it's impossible).

To prove that let's suppose our target is somewhere reachable by only taking C1 and C2 (the upper right sextant, a sixth division of the plane). C4 and C5 will never be used since they contribute in the wrong direction. We can now use C6, C1, C2 or C3 for our solution. If using C1 and C2 is not optimal we can choose C3 or C6, without loss of generality we choose C3. C6 cannot be used because it simply counters C3. Now we either use C1, C2 or C3, but we can further narrow down to just two edges. If we use all three this means we use C1 + C3 which goes the same way as C2, and C2 also goes the same way as C1 + C3. So we can just not use C2 if C1 + C3 < C2, or use C2 instead of C1 + C3 until either of C1 or C3 doesn't appear anymore on our solution.

1421E — Swedish Heroes

Idea and solution: flaviu2001

HintThe problem gives us an array and we have to come up with an achievable sequence of pluses and minuses such that summing the numbers after applying the signs we get the largest sum. Intuitively we can probably assign + to most positive numbers and — to most negative numbers somehow, but we should investigate exactly which are possible.

Sneaky corner caseBefore you try to find patterns you should observe that there is one case that is impossible to reach. You cannot assign alternating + and — to the array, like +−+−+−+− or −+−+−+−+. The reason is very simple, the very first thing you do is apply the operation on two consecutive numbers and make them both −−, and whenever you apply further operations on the both of them they remain the same sign. In the end we decided to give this in the samples but we know from testing many would miss this case.

SolutionIn order to explain the solution we will add some notations:

n = the length of the array.

m = the number of elements we multiply by −1 in the solution (put — in front of them).

p = the number of elements we do not multiply by −1 in the solution (put + in front of them).

The mysterious pattern is as follows: (n + m) % 3 = 1So yes, for n = 7 for example we can put 3 minus signs anywhere, like ++−−+−+, or 6 minus signs like −−+−−−− or full plus signs +++++++. We can arrange the pluses and minuses however we want as long as there are 2 consecutive equal signs and (n + m) % 3 = 1.

The solution now simply requires us to sort the array and multiply by −1 each number one by one and when (n + m) % 3 = 1 update the answer with the current sum. Of course there is one point where all the elements might form the forbidden +−+−+− so you should check that in that case they do not, or if they do pick the next smallest number to turn into — instead of the last one. So for the sample [4,−5,9,−2,1] you sort and get [−5,−2,1,4,9] and when you turn −5 into 5 instead of turning −2 into 2 you turn 1 into −1 and the array will be [5,−2,−1,4,9]. After that undo your modification, turn −2 into 2 and revert −1 to 1.

Proof for the patternThe proof can be done via induction, but I will try to explain why this happens. Suppose your solution looks like +−−+−−−+. What we need to do is to split into two substrings such that their negation is achievable and we are done, they will concatenate and reverse each sign. So we can split into (+−−) and (+−−−+) and notice that their negations are (−++) and (−+++−) which are achievable ((n + m) % 3 = 1 for both and are not alternating). We can always find such a split, start at the left-most point and see if you can split into (+) and (−−+−−−+). You can't, the negation of (+) is just (−) which you can't have. Splitting into (+−) and (+−−−+) won't do either for the same reasons, but (+−−) and (+−−−+) work, actually if the left substring starts with a + the very first time the last two signs are equal is a time where we can make the split, something like (+−+−++) when reversed will always have (n + m) % 3 = 1. So now you see even clearer why the corner case +−+−+ exists, you can never split it into two substrings where the last two signs of the first substring are equal.

You can also see the video solutions on stefdasca's Youtube channel

Codeforces Round #675 (Div. 2) Editorial

By aropan, history, 2 years ago, translation, In EnglishGood mood and pure thoughts to everyone who comes here.

1422A - FenceAuthor aropanSolution 94875319

Tutorial1422A - FenceA quadrilateral can be built when max(a,b,c,d)<a+b+c+d−max(a,b,c,d), that is, the sum of the minimum three numbers is greater than the maximum. To do this, you could choose max(a,b,c) or a+b+c−1 as d.

1422B - Nice MatrixAuthor andrewSolution 94875245

Tutorial1422B - Nice MatrixNote, that if the value of a1,1 is equal to some number x, then values of an,1, a1,m and an,m must also be equal to this number x by the palindrome property.

A similar property holds for all of the following elements ax,y (ax,y=an−x+1,y=a1,m−y+1=an−x+1,m−y+1), so the problem is reduced to finding the optimal number for each four of numbers (maybe less for some positions in matrix). This number is the median of these numbers (the average of the sorted set). The answer will be the sum of the differences between the median of the "four" and each number in the "four" for all "fours".

1422C - BargainAuthor aropanSolution 94875502

Tutorial1422C - BargainLet's count for each digit how many times it will be included in the final sum and in what place. Let's denote m as the length of the number n. Consider the digit ai at the position i in the number n (1≤i≤m). If some part of the number to the left of the digit is removed, then the current digit will remain in its place  — and we add the number of ways to remove the subsegment to the left to the answer multiplied by the current digit i∗(i−1)/2×10m−i×ai. If the segment to the right is deleted, then the place of the digit will change – (j+1)×10j×ai for all 0≤j<m−i, or ∑m−i−1j=0(j+1)×10j×ai. The j sum can be pre-calculated for all values.

1422D - Returning HomeAuthor aropanSolution 94875536

Tutorial1422D - Returning HomeYou can build a graph with vertices at the start point and all fast travel points. The distance between the vertices (x1,y1) and (x2,y2) is calculated as min(|x1−x2|,|y1−y2|). To avoid drawing all m∗(m+1)/2 edges in the graph, note that for a pair of points (x1,y1) and (x2,y2) such that |x1−x2|≤|y1−y2|, if there is a point with coordinate x3 such that it is between x1 and x2 (min(x1,x2)≤x3≤max(x1,x2)), then the distance between the first and second point will be equal to the sum of the distances between the first and third and between the third and second. In this case, the edge between the first and second points does not need to be drawn  – it will be unnecessary. It turns out that for each point of the graph it will be enough to draw the edges to the points nearest along the x axis in both directions. Similarly for y. Next, in the constructed graph, we find the minimum distance from the starting point to each point of the graph (x,y) and sum it up with the distance to the end point (fx,fy), which is equal to |x−fx|+|y−fy|. Among all the distances, we choose the minimum one.

1422E - MinlexesAuthor aropanSolution 94875558

Tutorial1422E - MinlexesLet's find the answer ansi for all suffixes, starting with the smallest in length. ansn is equal to an empty string. Then if si=si+1 (0≤i+1<n), then ansi=min(si+ansi+1,ansi+2), and otherwise ansi=si+ansi+1. To quickly find minimum of two strings, they can be stored as "binary lifts"  – nexti,j will be equal to the position in the string s, on which the 2j character ansi will be located, and hashi,j  – hash from the prefix ansi of length 2j. Values for (i,j) can be obtained from (i,j−1) and (i+2j−1,j−1). To restore the answer, nexti,j will be enough for us, and for simplicity we can additionally store the length of each answer.

1422F - Boring QueriesAuthor andrewSolution 94875580, author's solution with persistent segment tree 94875295

Tutorial1422F - Boring QueriesIn order to find the LCM of numbers on a segment, you can, for each prime number, find the maximum power with which it enters into any number on the segment and multiply the answer with this power. Let's calculate the LCM for primes less than MaxA−−−−−−√ and greater than MaxA−−−−−−√ separately using the segment tree.

There are k=86 prime numbers less than MaxA−−−−−−√. Let's store a sorted list of prime numbers with their maximum power in each subsegment of the tree. The union of two segments can be done in O(k). Then the construction of the entire tree can be done in O(n⋅k). In order to answer the query, we split it into O(log(n)) subsegments of the segment tree and sequentially combine them in O(k).

For each number ai in the array, there will be no more than one prime divisor pi greater than MaxA−−−−−−√. For a query, you need to find the product of unique numbers pi on a segment. To do this, for each such simple pi number, find previ  – the closest position to the left in the array of the same prime number (or −1 if there is no such number on the left). For a subsegment, we will store a sorted list of (previ,pi) pairs, and also pre-calculate the product pi for each prefix. Now, for each subsegment of the tree that will be included in the query (l,r), you need to select all such pairs for which previ<l and take product of pi. Since the list is ordered, all these numbers will form a prefix. The prefix can be found using a binary search for log(n).

Total complexity O(n⋅k+q⋅log(n)⋅k+q⋅log2(n)), where k=MaxA√lnMaxA√ (the number of primes up to the root).

Codeforces Round #674 (Div. 3) Editorial

By vovuh, history, 2 years ago, In English1426A - Floor Number

Idea: fcspartakm

Tutorial1426A - Floor NumberIf n≤2 then the answer is 1. Otherwise, you can "remove" the first floor and then the answer is ⌊n−3x⌋+2.

Solution1426B - Symmetric Matrix

Idea: BledDest

Tutorial1426B - Symmetric MatrixFirstly, if m is odd then the answer is "NO" by obvious reasons. Otherwise, we can notice that the top left and the bottom right values of the tile do not matter (since we can place tiles symmetrically). So we only need to check that there is some tile that its top right value equals its bottom left value (because this is how we get main diagonal symmetry).

Solution1426C - Increase and Copy

Idea: vovuh

Tutorial1426C - Increase and CopyIt is pretty intuitive that we firstly need to do all increments and only then copy numbers (because otherwise we can swap the order of moves and the sum will not decrease). You could notice that the answer does not exceed O(n−−√) so we can just iterate from 1 to ⌊n−−√⌋ and fix the number we will copy. Let it be x. Then we need x−1 moves to obtain it and also need ⌈n−xx⌉ moves to get the enough number of copies. So, we can update the answer with this number of moves.

Time complexity: O(n−−√) per test case.

Actually, the required number is always pretty near to ⌊n−−√⌋ so it is enough to try a few options in range [⌊n−−√⌋−5;⌊n−−√⌋+5] to get the optimal answer. This is O(1) solution.

SolutionSolution 21426D - Non-zero Segments

Idea: BledDest

Tutorial1426D - Non-zero SegmentsFirstly, let's understand that the sum of the segment [l;r] is zero if pr−pl−1 is zero (in other words, pl−1=pr), where pi is the sum of the first i elements (p0=0).

Let's iterate over elements from left to right and add all prefix sums in the set. If we get the sum that is already in the set, we get some segment with sum 0, and we need to fix it somehow. Let's insert some huge number before the current element in such a way that all prefix sums starting from the current element to the end will be significantly bigger than all prefix sums to the left. In words of implementation, we just get rid of all prefix sums to the left (clear the set) and continue doing the same process starting from the current element (so we just cut off the prefix of the array).

This way is optimal because we remove all segments with sum 0 ending at the current element using only one insertion (and we need to use at least one insertion to do that).

Time complexity: O(nlogn).

Solution1426E - Rock, Paper, Scissors

Idea: fcspartakm

Tutorial1426E - Rock, Paper, ScissorsThe maximum number of rounds Alice can win is pretty easy to calculate greedily: min(a1,b2)+min(a2,b3)+min(a3,b1). What about the minimum number of rounds?

It can be shown that if we started using some combination we are better to end it before using the other one. There are six possible combinations to not win the round:

a1 and b1.a2 and b2.a3 and b3.a1 and b3.a2 and b1.a3 and b2.We can iterate over all permutations of these combinations (there are 6!=720 possible permutations) and greedily apply them. Use the first while it is possible, then the second, and so on, and find the best answer.

It is also possible that the order of these combinations does not matter, but we didn't prove that fact.

Time complexity: O(1).

Solution1426F - Number of Subsequences

Idea: fcspartakm

Tutorial1426F - Number of SubsequencesThere are several more or less complicated combinatorial solutions to this problem, but I will describe a dynamic programming one which, I think, is way easier to understand and to implement.

Suppose we have fixed the positions of a, b and c that compose the subsequence (let these positions be pa, pb and pc). How many strings contain the required subsequence on these positions? Obviously, if some of these characters is already not a question mark and does not match the expected character on that position, the number of strings containing the subsequence on that position is 0. Otherwise, since we have fixed three characters, all question marks on other positions can be anything we want — so the number of such strings is 3x, where x is the number of question marks on positions other than pa, pb and pc. It allows us to write an O(n3) solution by iterating on pa, pb and pc, and for every such triple, calculating the number of strings containing the required subsequence on those positions.

But that's too slow. Let's notice that, for every such subsequence, the number of strings containing it is 3k−qPos(pa,pb,pc), where qPos(pa,pb,pc) is the number of positions from pa,pb,pc that contain a question mark. So, for each integer i from 0 to 3, let's calculate the number of subsequences matching abc that contain exactly i question marks — and that will allow us to solve the problem faster.

How can we calculate the required number of subsequences for every i? In my opinion, the simplest way is dynamic programming: let dpi,j,k be the number of subsequences of s that end up in position i, match j first characters of abc and contain k question marks. The transitions in this dynamic programming are quadratic (since we have to iterate on the next/previous position from the subsequence), but can be sped up to linear if we rewrite dpi,j,k as the number of subsequences of s that end up in position not later than i, match j first characters of abc and contain k question marks. Each transition is either to take the current character or to skip it, so they can be modeled in O(1), and overall this dynamic programming solution works in O(n).

Solution

Codeforces Round #673 Editorial

By bthero, history, 2 years ago, translation, In EnglishSeveral unexpected Kuhn solutions passed for D1F. Could you please discuss your solutions in the comments and prove its correctness or provide any counter-examples. Author's solution uses flows with Dinic.

Editorial is not completed yet. Problem D1F will be added later. Hope you enjoyed the problemset!

Editorial was/will be written by bthero and BledDest.

Our tester namanbansal013 has made amazing video-tutorials on YouTube for problems D2D/D1B and D2E/D1C. Make sure to check them out and show him some love!

Finally added the editorial for D1E. Currently it is very complicated and error-prone.

Div2A by bthero

Editorial1417A - Copy-pasteIf we do our operation on two arbitrary integers x≤y, it is always better to copy x into y rather than to copy y into x (since a resulting pair (x,x+y) is better than (y,x+y)).

Now, let's assume that we do our operation on two integers x≤y such that x is not the minimum element of our array. If we replace x with minimum, we can always achieve at least the same answer. Thus, we can take any index m such that am is the array minimum and use it to increase all other values.

Time complexity: O(n) or O(nk) per testcase.

Space complexity: O(n)Code in C++ (BThero)Div2B by nkamzabek

Editorial1417B - Two ArraysLet us partition the array into three sets X, Y, Z such that X contains all numbers less than T/2, Y contains all numbers equal to T/2 and Z contains all numbers greater than T/2. It is clear that f(X)=f(Z)=0. Now, since each pair in Y makes a sum of T, the best solution is to distribute all numbers in Y equally among X and Z.

Time complexity: O(n)Space complexity: O(n)Code in C++ (hugopm)Div2C/Div1A by nkamzabek

Editorial1416A - k-Amazing NumbersLet's fix some arbitrary number x and calculate the minimum value of k such that x occurs in all segments of length k. Let p1<p2<⋯<pm be the indices of entries of x in the array. Then, for each 1≤i<m it is clear that k should be at least the value of pi+1−pi. Also, k≥p1 and k≥n−pm+1. It is enough to just take the maximum of those values. Let's call this derived value of k as f(x).

Now, we can just go in increasing order of x from 1 to n and try update the suffix [f(x),n] with x. This can be done straightforwardly, just iterating over the range [f(x),n]. If we arrive at a cell for which the value of x is already calculated, we immediately terminate our loop and continue our algorithm from x+1.

Time complexity: O(n).

Space complexity: O(n).

Code in C++ (BThero)Div2D/Div1B by nkamzabek

Editorial1416B - Make Them EqualLet S be the sum of the array. If S is not divisible by n, then the answer is obviously −1. Otherwise, there always exists a solution which uses no more than 3n queries. We will solve this problem in two phases.

First phase: gather the sum in a1. Let's iterate over 2≤i≤n in increasing order. If ai is divisible by i, we can immediately transfer it using one operation. Otherwise, we have to make it divisible by transferring i−(aimodi) from a1 to ai. Note that this operation does not break a condition on non-negativity because all ai are initially positive. This way, we successfully finish this phase using at most 2(n−1) operations.

Second phase: distribute the sum across all elements. Just iterate over all 2≤i≤n and make a transfer of S/n from a1 to ai. This phase takes exactly n−1 operations.

Time complexity: O(n)Space complexity: O(n)Code in C++ (BThero)Div2E/Div1C by DimmyT

Editorial1416C - XOR InverseNote: the integer x from the statement is marked as an uppercase X for clarity.

Take any arbitrary integers x and y. It is a well-known fact that whether x<y or x>y depends only on one bit — the highest bit which differs in both.

So, let's construct a trie on our array integers. Represent each number as a binary string from the highest bit (29) to the lowest bit (0). Each leaf will keep a corresponding index/indices from the array and each non-leaf node will have at most two children — one for 0-edge and one for 1-edge.

Let's denote S(v) as a sorted list of indices of all values in the subtree of v. These lists can be easily maintained while inserting our numbers into trie. Take any arbitrary vertex v which has both children and has a depth (distance from root) of k. Let a and b be its children. Here comes the most important thing to notice: If the k-th highest bit of X is toggled, lists S(a) and S(b) will change their relative order. Otherwise, it will not change. Thus, exploiting the fact that both lists are sorted, we can efficiently calculate the corresponding number of inversions between those lists and add them to our values sum[k][0] and sum[k][1]. sum[i][j] means the number of inversions we have to add if i-th highest bit of X is equal to j.

After the calculation of our sum table is done, the value of X can be easily restored.

Time complexity: O(nlog109)Memory complexity: O(nlog109)Code in C++ (RedDreamer)Div2F/Div1D by DimmyT

Editorial1416D - Graph and QueriesBasically, we want to transform each "connected component maximum" query into "segment maximum" query. It can be efficiently done using DSU and processing all queries in reversed order. For simplicity, let's assume all edges will eventually get deleted in the process. If not, you can always add some extra queries at the end.

Initially, each vertex is a connected component on its own. We are processing all queries in reverse order. If the current query is of first type, remember the "boss" of the corresponding vertex. Otherwise, unite the corresponding vertices accordingly. If we want to unite two bosses a and b, we create a new fake vertex c and add edges (a,c), (b,c) so that the subtree of c becomes responsible for both components of a and b. Notice that we cannot apply small-to-large merging to our DSU, but we are still able to use path-compression heuristic.

Now, our DSU-tree is ready. Each query of first type is now a subtree-maximum query and all queries of second type can be ignored. The solution onwards should be pretty straightforward. We first do an Eulerian tour on our tree to transform each subtree into a segment. Using segment tree we are able to efficiently process all queries.

Time complexity: O((n+m+q)logn)

Space complexity: O(n+m+q)Code in C++ (BThero)Div1E by bthero

Editorial1416E - SplitNote that minimizing |b| is the same as maximizing the number of consecutive equal pairs. We will focus on the second version.

Let's forget about constraints and consider the most naive solution with dynamic programming. DP[i][j] will store the answer if we have already considered (a1, ..., ai) and our last element b2i is equal to j.

Let's get rid of our dimension i and keep our DP table by layers. Suppose that our current i-th layer is called curDP, next layer is called nxtDP, and ai+1 is called X.

After carefully analyzing our transitions, we have the following observations:

for any i, nxtDP[i]≥max(curDP), since we always have a transition from our maximum.max(nxtDP[i])−min(nxtDP[i])≤2, since we can add at most two pairs.The case max(nxtDP[i])−min(nxtDP[i])=2 may occur only if ai is even. Moreover, nxtDP[ai/2] will be the only maximum element.For some suffix upto i we always have a transition from curDP[X−i]+1 to nxtDP[i].If X is even, instead of calculating nxtDP[X/2] separately, we can calculate it as usual and increase its value by 1 at the end.Using everything said above, we could replace our naive DP with the following:

A variable called zero — the value of minimum of our current layer.A set called one — it keeps all indices i such that curDP[i]=zero+1.A variable called two — it is equal to −1 or X/2 depending on the parity of X and the value of curDP[X/2].Basically, we want to be able to:

Erase some elements from the prefix/suffix of our set one.Check if some number x is in our set one.Add a segment of values [l,r] into out set one.Rotate all elements in our set by a pivot x. That is, a number y should turn into x−y.We can efficiently process all queries by maintaining one as a simple set of non-intersecting segments. The rotation operation can be done as follows:

Suppose we had an integer X at the beginning.We rotate everything by a pivot A. X becomes A−X.We rotate everything by a pivot B. A−X becomes B−A+X.Following the logic, C−B+A−X, D−C+B−A+X, ...We can just maintain the sign of X and a global pivot, which is the combination of all our rotation operations.Time complexity: O(nlogn)Space complexity: O(n)Code in C++ (BThero)Alternative solution code in C++ (hugopm)Div1F by bthero

Editorial...

Code in C++ (BThero)

Editorial of Codeforces Round #672 (Div. 2)

By gepardo, history, 2 years ago, translation, In English1420A - Cubes Sorting

HintSolution1420A - Cubes SortingIt is not difficult to see that the answer «NO» in this task is possible when and only when all ai are different and sorted in descending order. In this case we need n⋅(n−1)2 operations. Otherwise the answer is always «YES».

Why does this solution work? Let's define number of inversions as the number of pairs 1≤i<j≤n such as ai>aj. Note that if the number of inversions is zero, the a array is sorted in non-decreasing order. If the array is not sorted, we can always choose two neighboring elements such that ai>ai+1 and swap them. In this case, the number of inversions is reduced by one. In this case, we cannot reduce the number of inversions by more than one, so it is equal to the minimum number of operations we must perform.

Now, all we have to do is notice that the number of inversions does not exceed n(n−1)2, and the maximum is only reached when ai>aj for all pairs 1≤i<j≤n. It follows that in this case the array must be strictly descending.

Thus, we have a solution with a time of O(n).

Code in C++ (Wind_Eagle)1420B - Rock and Lever

HintSolution1420B - Rock and LeverLet's take a pair (ai,aj) and see in which case ai & aj≥ai⊕aj will hold. For this we will follow the bits ai and aj from highest to lowest. If we meet two zero bits, the values of ai & aj and ai⊕aj will match in this bit, so we move on. If we meet a zero bit in ai and in aj —one bit(or vice versa), then we get ai & aj<ai⊕aj, and we can immediately say that the required condition is false. And if we meet two one bits, then the required condition is fulfilled,  e. ai & aj>ai⊕aj, and then the bits can no longer be considered.

Now let's consider the highest one bit in the number of ai (let it stand at pi position) and the highest single bit in the number of aj (let it stand at pj position). (Here, we consider that the bits are numbered in order of lowest to highest.) Then, pi=pj must hold. If pi>pj, then there is zero in the aj position and one unit in the ai position. But then from the reasoning above we get that ai & aj<ai⊕aj. The case of pi<pj is treated in a similar way.

It is also easy to see that if pi=pj then we automatically get the condition ai & aj>ai⊕aj.

From here the problem is solved. For each number we find the position of the highest one bit pi. Then we need to calculate the number of pairs of numbers, for which pi=pj. You may notice that the answer is ∑ℓkℓ⋅(kℓ−1)2, where kℓ — the number of numbers for which pi=pj.

The complexity of the solution is O(n).

Code in C++ (Wind_Eagle)1420C1 - Pokémon Army (easy version)

HintSolution1420C1 - Pokémon Army (easy version)The easy version of the task can be solved in different ways. For example, you can use the dynamic programming method.

Let d1i – be the maximum possible sum of a subsequence on a prefix from the first i elements, provided that the length of the subsequence is odd. Similarly enter d2i, only for subsequences of even length. Then d1i and d2i are easy to recalculate:d1i+1=max(d1i, d2i+ai),.d2i+1=max(d2i, d1i−ai).. The initial values are d10=−∞, d20=0. The answer will be stored in max(d1n,d2n).

This solution works for O(n) in time. Its main drawback is that it cannot be used to solve a complex version of a task where a different approach is needed.

Code in C++ (gepardo)1420C2 - Pokémon Army (hard version)

HintSolution1420C2 - Pokémon Army (hard version)Let's give a solution for a fixed array and then prove its optimality.

Let us name the element ai a local maximum if ai>ai−1 and ai>ai+1. Similarly let's call the element ai a local minimum if ai<ai−1 and ai<ai+1. If any of the ai−1 or ai+1 does not exist in the definitions above, we assume it is equal to −∞.

Note that the optimal subsequence will always be an odd length (otherwise we can delete the last element and increase the response). Elements with odd numbers shall be located at local maximums, and elements with even numbers — at local minimums.

It is not difficult to see that the first local maximum is always placed earlier than the first local minimum (otherwise it would happen that the initial permutation decreases from the first element to the local minimum, in which case the first element itself is the local maximum). Similarly, you may notice that the last local maximum always costs later than the last local minimum. Given that the local maximums and minimums alternate, you can simply take a subsequence of all the local maximums and minimums and get the best response.

Let's show that this construction is alpways optimal. Let's start with the case when an element with an odd number is not a local maximum. In this case, it shall be replaced with a bigger neighbor, and if the bigger neighbor is already in the sub-set, just delete both of these elements. After that, the response shall always increase. The same shall apply if the even-numbered element is not a local minimum. In this case, it may still happen that we cannot move the element downwards because it is on the edge. But then it is the last one in the subsequence, and it can be easily removed.

Thus, it is optimal to take only local highs and lows into the subsequence (considering that highs are on odd positions and lows — on even positions). It remains to be shown that it is profitable to take all local maximums and minimums. Indeed, if not all of them are involved, then there is a pair of standing local highs and lows. By adding them to the subsequence, we will increase the answer.

Okay. We know how to solve a problem for an initial array by reducing it to the sum of all local maximums and minimums. We will now learn how to process requests quickly. To do this, we will store whether an element is a local minimum or maximum and recalculate this information when exchanging elements. Suddenly it turns out that a single request will change the state of no more than six elements, so we can easily recalculate the response for O(1) per request.

Thus, we have a solution with an asymptotic O(n+q) in time.

Code in Java (gepardo)Code in C++ (Wind_Eagle)1420D - Rescue Nibel!

HintSolution1420D - Rescue Nibel!In this task, we need to find the number of sets of k segments such that these k segments intersect at least in one point.

Let's look at the starting point of the intersection. This point will always be the beginning of a segment. Let us find the number of sets of segments that their intersection begins at the point x. Let us denote p(x) as number of segments that pass through this point, and s(x) as numbers of segments that start at this point. Then all the k segments must pass through x and at least one segment must start at x. The number of sets of segments passing through x is (p(x)k) and the number of sets of segments passing through x, none of which starts at x, is (p(x)−s(x)k). From here we obtain that the required number of piece sets is (p(x)k).−(p(x)−s(x)k). By summing up all possible x values, we get the answer to the task.

It should be noted that p(x) and s(x) can be easily supported using the event method. Then, the total runtime will be O(nlogn).

Code in Java (gepardo)1420E - Battle Lemmings

Hint 1Hint 2Hint 3Solution1420E - Battle LemmingsFirst, let us denote f(A) as a conversion of the original sequence of A. In the beginning, we will write down the number of zeros before the the first one. Then, we write down the number of zeros standing between the first and second ones, then — between the second and third ones, and so on. For example, f(011000101100)={1,0,3,1,0,2}, because there is one zero before the first one, there are no zeros between the first and second ones, there are three zeros between the second and third ones, etc.  d. It is not difficult to see that the original sequence A can be unambiguously recovered with f(A).

Now, let us consider how f(A) will change if we change two different adjacent elements in the original A sequence. In this case, two neighboring numbers will change in f(A), one of which will decrease by one and the other — will increase by one. The reversed statement is also true: if we choose two neighboring numbers in f(A), one of them will increase by one, and the other — will decrease by one so that they both remain non-negative, this operation will correspond to an exchange of two neighboring elements in A. Let us name this operation (choosing two neighboring numbers, increasing one of them by one and reducing the other by one). pouring.

Let us consider such a task. We have two arrays A={a1,a2,…,ak} and B={b1,b2,…,bk}. We have to calculate the minimum amount of pouring operations we can turn A into B. (Obviously, the sum of the numbers in A and in B must be the same.) To solve this, let's try to split the array into two "barriers", standing after i-th position. Then, the A array is split into two parts: the left (elements from 1 to i) and the right (elements from i+1 to n). For the left part of the A array to have the same number of elements as in B, you need gA,B(i)=∣∣∑ij=1ai−∑ij=1bi∣∣ pouring operations involving i and i+1 elements. To sum up the number of necessary pouring operations for each pair of neighboring elements, you have to sum gA,B(i) for all i from 1 to n−1. It can be shown that the sum obtained will be the required number of pouring operations, because  since it is equal to zero only in case of equal arrays, and each pouring operation will reduce it by no more than 1 (and there is always a transfusion that reduces this sum by 1).

So, this subtask has been sorted out, let's move on. We have to learn how to read security for the sequence A, knowing f(A)={f1,f2,…,fk}. It is not difficult to see that it is equal top(A)=∑1≤i<j≤kfi⋅fj=12(∑1≤i,j≤kfi⋅fj−∑i=1kf2i)=12⎛⎝(∑i=1kfi)2−∑i=1kf2i⎞⎠.We already know the value of ∑ki=1fi: it is equal to the number of zeroes in A. So, we have to minimize ∑ki=1f2i.

Now we can finally get down to the task. To do this, let's try to build an optimal sequence of f(A)={f1,f2,…,fk} by applying no more than k of transfusions. Of course, we need to use the dynamic programming of dpi, s, k. This means that we have looked at the first i elements in f(A) and done with k pouring operations so that ∑ki=1fi equals s. The DP itself will store the minimum possible value of ∑ki=1f2i.

To get the answer we need to refer to dpi, c0, k where c0 — is the number of zeros in the original sequence. And to recalculate the dynamics of dpi, s, k we have to go through what fi+1 will be as a result. Let it be h. Then, the answer recovery happens in the following way:

dpi+1, s+h, k+|zi−(s+h)|min=dpi, s, k+h2.Here zi denotes ∑ij=1fi in the original sequence f(A).

The total asymptotic is O(n5) in time and O(n4) in memory, although with a correct implementation the constant is very small (the author's solution works for n527). In this task, there are solutions for O(n4logn), but I will not describe them here.

Code in C++ (gepardo)

Codeforces Round #671 Editorial

By shishyando, history, 2 years ago, In EnglishAll problems were prepared on Polygon by me, so if you faced any problems (we know about A) I am really sorry about it.

1419A - Digit GameLet's say that digits on odd positions are blue and digits on even positions are red. If n is even the remaining digit will be red. If there is at least one even red digit then Breach wins (he can mark all digits except the one that will remain in the end). In other case Raze wins, because any digit that may remain is odd.

If n is odd the remaining digit will be blue. If there is at least one odd blue digit then Raze wins (using the same strategy applied to her). In other case Breach wins.

Idea: shishyando

Jury solution: pastebin

1419B - StairsLet's prove, that the minimal amount of squares needed to cover the staircase is not less than n, where n is the height of a staircase. To highest cell of each stair is the top left cell of some square. That's why we need at least n squares. You need exactly n squares if and only if the top left cell of each stair is a top left cell of some sqaure.

Let's consider a square that covers the lowest cell in the last stair. Its top left corner should contain the highest cell with index n+12 for odd n. Then the staircase is divided into 2 staircases, each n−12 stairs high. These staircases should be nice, too. It means that nice staircases are 2k−1 stairs high, where k≥1. To maximize the amount of different staircases we should create staircases greedily.

If n is even, then we can consider a square that will have the lowest cell of the last stair. The top left corner of this square may not contain any top cells of a staircase, that's why you will need more than n squares. This means that a staircase with an even height may not be nice.

Idea: Artyom123

Jury solution: pastebin

1419C - KilljoyIf all n accounts have the rating equal to x then the answer is 0. Now let's consider other cases. Let's try to make all ratings equal to x in a single contest. It's possible only in two cases:

1. If at least one account is already infected we can infect all other accounts in a single contest. Let's say that some account i is already infected, then we can change all other accounts to x except i. Let's say that summary changes are d, then we can decrease i-th account's rating by d and every account will be infected while the summary changes will be equal to zero. So this will take only 1 contest.

2. ∑i=1n (ai−x)=0. In this case we can just make all ratings equal x and the sum of all changes will be 0 because of the equality, which means that we can infect everyone in only 1 contest.

In all other cases the answer is 2. Let's prove that. We can make the ratings of first (n−1) accounts equal to x after the first contest and the last account will have rating equal to an − ∑i=1n−1 (ai−x) so that the sum of rating changes is still equal to zero. After that first (n−1) accounts are already infected and we can change the rating of the last account by d so it's equal to x and we will decrease the rating of the first account by d so that the sum of rating changes is still equal to zero. After such two contests all accounts will be infected.

Idea: shishyando

Jury solution: pastebin

1419D2 - Sage's Birthday (hard version)Let's learn how to check whether it's possible to buy x ice spheres. Let's sort the array a in the non-decreasing order and then take x smallest elements of it. We will suppose that these x ice spheres will be cheap. To make these ice spheres cheap, we need x+1 ice spheres more, so let's take x+1 most expensive ice spheres. Why it's always good to take x+1 most expensive ice spheres? If we had an ice sphere with the price y and we took an ice sphere with price z≥y the answer will not become worse. Now we know how to check whether it's possible to buy x ice spheres. If we can buy x ice spheres then it's also possible to buy x−1 ice spheres. For that reason the binary search for the answer is working.

Idea: Artyom123

Jury solution: pastebin

1419E - DecryptionLet's factorize n: n=pq11⋅pq22⋅⋯⋅pqkkIf k=2 and q1=q2=1 (i.e. n is the product of two different prime numbers)Divisors p1 and p2 will definately be adjacent and they are coprime so we should make one operation to insert their lcm between them. After that the circle will be

p1, p1⋅p2=n, p2, p1⋅p2=nand there will be no such two adjacent numbers that are coprime. The answer is 1.

If k=2 and q1>1 or q2>1, then we can firstly place numbers p1,p1⋅p2,p2,n. After that we can insert all unused divisors that are multiples of p1 between p1 and n, all divisors that are multiples of p2 between p2 and n. It is easy to see that in this case the answer is 0.In another case it is possible to arrange the divisors so that there are no such two adjacent numbers that are coprime. Firstly, we need to arrange in a circle these numbers:p1, p2, p3, ..., pkAfter that we need to write down the products of these numbers between them:

p1, p1⋅p2, p2, p2⋅p3, ..., pk, pk⋅p1From now on we can just place unused numbers that way: insert all unused divisors, that are multiples of p1, after p1, insert all unused divisors, that are multiples of p2, after p2 and so on. If the solution is still unclear you may take a look at the image below. The answer in this case is 0.

Idea: shishyando

Jury solution: pastebin

1419F - Rain of FireWe can consider a graph where vertices are the points (detachments), and there is an edge between two points, if it's possible to move from one point to another. It is possible if these points are on the same line (xi=xj or yi=yj) and the distance between them is ≤T.

Now we can check, whether current t value is good (whether it is possible to check all detachments). It is easy to see, that it is only possible, when the graph is connected. This means, that we can make a binary search for t. Let's now learn how to check, whether it is possible to add at most one point to make the graph connected.

If there is 1 component, then the graph is already connected.

If there are 2 components, then we can search through all such pairs of points, that one point is from the first component, and another point is from the second component. We can connect these points, if they are on one line, and the distance between them is ≤2T or the differences |x1−x2|≤T and y1−y2≤T.

If 3 are three components, then we should consider triples of points. Two of these points should be on the same line. The added point should be on a segment between these two points, and there are O(n) such segments. Now let's search through all such pairs (segment, point) and check whether it is possible to place a point on the segment and connect it with the point from the pair.

If there are 4 components, then you can search trough pairs (segment, segment), so that one segment is horizontal and another one is vertical (they should make a cross). Now we just need to check whether it is possible to connect their intersection point with all 4 endpoints of the segments.

If there are more, than 4 components, then it is not possible to connect them adding only one point, because there are 4 movement directions. If your binary search did not find the answer even for T=2⋅109, then the answer is −1, because the maximal distance between any two points is ≤2⋅109.

Idea: isaf27 + Kotehok3

Jury solution: pastebin

Codeforces Round #670 (Div. 2) Editorial

By gyh20, 2 years ago, In EnglishUpd: fixed author's solution links.

Sorry for the slow Editorial, I am new using Polygon.

Special thanks to TechNite for his help.

About one hour before the contest Retired_cherry found the same problem, then we changed it to k=4 and he found another same one again. We are running out of time so we didn't have time for a new one, so we changed k to 5. But we didn't know there is still a similar problem. Sorry again.

1406A - Subset MexLet us store the count of each number from 0 to 100 in array cnt.

Now mex(A) would be the smallest i for which cnti=0.Let this i be x. mex(B) would be smallest i for which cnti≤1. This is because one count of each number less than x would go to A therefore the element which was present initially once would now not be available for B.

Overall Complexity: O(n).

idea:gyh20 solution:gyh20 tutorial:TechNite

Jury solution:92671575

1406B - Maximum ProductFirst, if all numbers are less than 0, then you should print the product of the five biggest numbers of them.

Otherwise, the maximum product must be non-negative. Sort the numbers by their absolute value from big to small.

If the first five numbers' product is positive then print it. Then we can always change one of the five to one of the n−5 other numbers to make this product positive. Enumerate which one to replace, and you can solve this problem in O(n) time.

idea: feecIe6418 solution:feecIe6418 tutorial:feecIe6418

Jury solution:92671590

1406C - Link Cut CentroidsLet vertex 1 be the root of the tree. If there is only one centroid, just cut any edge and link it back.

Otherwise there are two centroids. Let them be x and y, then there must be an edge connecting x and y. (If not, choose any other vertex on the path from x to y and the size of the largest connected component after cutting it will be smaller than x and y).

Let x be y's father. (If not, swap x and y) Then just cut a leaf from y's subtree and link it with x. After that, x becomes the only centroid.

Proof: It's easy to see that the size of y's subtree must be exactly n2. After cutting and linking, the maxinum component size of y becomes n2+1 while the maxinum component size of x is still n2.

idea:gyh20 solution:gyh20 tutorial:feecIe6418

Jury solution:92671713

1406D - Three SequencesSince sequence b is non-decreasing and sequence c is non-increasing, we need to mimimize max(c1,bn).

Now observe that if ai>ai−1 then bi=bi−1+ai−ai−1 and ci=ci−1.Else if ai<ai−1 then bi=bi−1 but ci=ci−1+ai−ai−1. Now we calculate ∑i=2nmax(0,ai−ai−1).Let this sum be K. Now lets assume c1 is x. So then b1 is a1−x.And as observed before bn=a1−x+K.

Now we just need to minimize max(x,a1−x+K). Now it is easily observable that x should be a1+K2.

For the changes, since we only need to know ∑max(0,ai−ai−1), so only al−al−1 and ar−ar−1 will change.

Total time complexity: O(n+q).

idea:isaf27 solution:gyh20 tutorial:TechNite

Jury solution:92671763

1406E - Deleting NumbersIf we know what prime factors x has, we can find x just using bruteforce.

To find the prime factors, we can just do B p for every prime p in ascending order, meanwhile calculate the numbers there supposed to be without x, if it differs with the number the interactor gives, then x contains the prime factor p.

This way, we can find every prime factor except for the smallest one.

Let m be the number of primes no greater than n.

Then we can split the prime numbers into m−−√ groups.

After finishing asking a group, ask A 1 and check if the return value same as it supposed to be without x. If it's the first time finding it different, it means the smallest prime number is in the range, then just check every prime numbers in the range by asking A p.

After finding the prime factors, for each factor, ask A pk, it can be proved this step will be done around log(n) times.

The total number of operations if around m+2m−−√+log(n), the total time complexity is O(nlogn)idea:gyh20 solution:gyh20 tutorial:gyh20

Jury solution:92671740

Codeforces Round #669 Editorial

By i.e, history, 2 years ago, translation, In English1407A — Ahahahahahahahaha

Tutorial1407A - AhahahahahahahahaLet cnt0 be the count of zeroes in the array, cnt1 — count of ones. Then if cnt1≤n2, we remove all ones and alternating sum, obliously, equals 0. Otherwise, cnt0<n2, we remove all zeroes and if cnt1 is odd — plus another 1. In this case, alternating sum equals 1−1+1−…−1=0 (because count of remaining ones if even) and we'll remove not more than cnt0+1≤n2.

Solution1407B — Big Vova

Tutorial1407B - Big VovaWe'll describe several constructive solutions for this task, differing by the time complexity:

1. O(n2logA)Let b be an empty sequence in the beginning. We'll consequently transfer elements from a to b in a certain order.

Let's notice that if we've already transfered (k−1) elements then we can always choose to the place of bk any element aj left in a such that ck=gcd(b1,…,bk−1,aj) is maximal. A-priory, if we've fixed the first (k−1) elements of the sequence, lexicographically greater would be the one in which ck is maximal. The particular value of bk here doesn't matter: each element ci divides all the previous ones, so gcd(bk,cj)=gcd(ck,cj) for any j>=k.

So the algorithm is following: let's say that we have auxiliary element of the sequence c0=0, and gcd(0,k)=k for any integer k≥1. Then we make n iterations: during the i-th one we choose such aj (overall elements left in a) that the value of gcd(aj,ci−1) is maximal, and make bi=aj, removing aj from the sequence a. The i-th iteration will be passed in O((n−i)logA), where A is the greatest possible value in the original a sequence, logA is the time complexity of the Euclidean algorithm for searching GCD. Via summing time complexities overall iterations we get summary O(n2logA) time complexity of the algorithm.

2. O(AnlogA)The main idea is the same as in the first solution, but the realisation is different: the main array a is contained as an array cnt of size A, where cntx is the amount of elements in a that are equal to x. Searching for the optimal element bk is O(AlogA) for each of n iterations, so the summary is O(AnlogA).

3. O(nlog2A)This solution is based on the following idea: for each i>1 either ci=ci−1 or 2ci≤ci−1. That means any possible sequence c contains O(logA) different values.

So we do O(logA) iterations, on each we find the value x among the elements left in a that maximizes O(ck,x) (where k is the amount of elements already transfered to b, and ck=gcd(b1,…,bk)) and transfer all the elements left in a of the value equal to x to the end of b. Each iteration is done in O(nlogA) so the total time complexity is O(nlog2A).

Solution1407C — Chocolate Bunny

Tutorial1407C - Chocolate BunnyObservation: (amodb>bmoda)⇔(a<b).

Proof: if a>b, then (amodb)<b=(bmoda). If a=b, then (amodb)=(bmoda)=0.

Let's maintain index mx of maximal number on the reviewed prefix (initially mx=1). Let's consider index i. Ask two queries: ? i mx and ? mx i. We'll know the less from both of them and either guess pmx and update mx=i or guess pi. In the end, all numbers will be guessed except pmx, that, obviously, equals n.

In total, we'll make 2⋅n−2 queries.

Solution1407D — Discrete Centrifugal Jumps

Tutorial1407D - Discrete Centrifugal JumpsConsider such a jump, when all of the skyscrapers between are smaller than initial and final (another case is similar). Let's stand on the skyscraper with index x. We want to find out whether y-th skyscraper satisfies our conditions. We have two cases:

hx≤hy. Then, obviously, y is the first skyscraper that not lower than x (otherwise we have a building that higher than starter, it's contradiction).hx>hy. Then, it's easy to see, that x is the first skyscraper to the left of y, that higher than y for the same reason.For another case, reasoning is similar, but skyscaper should be lower, not higher. We can see, that amount of pairs i,j:i<j such that we can jump from i to j, we can estimate as O(n).

So, we can find for each skyscraper the nearest bigger (and smaller) one using stack and simply count dpi — minimal count of jumps that we need to reach i-th skyscraper.

Check the solution for a better understanding.

Solution1407E — Egor in the Republic of Dagestan

Tutorial1407E - Egor in the Republic of Dagestan**This task has a simple intuitive proof, but I wanted to describe it formally so it's pretty complicated.**

We'll show a constructive algorithm for this task and proof it's correctness. We also provide a realisation with O(n+m) time complexity.

Let's change each edge's direction to the opposite. Then for vertex of color c all incoming edges of color c and only they are safe. We call a schedule optimal for x if the shortest path (from n) to x along the safe edges is the longest possible. We call a path (from n) to x optimal if it's the shortest path for any optimal schedule for x. So we have to find an optimal schedule for 1 and the length of optimal path for 1.

Let's make four parameters for each vertex x:

b[x] - the length of optimal path to x, if x is black,

w[x] - the length of optimal path to x, if x is white,

dp[x] - the length of optimal path to x among all possible schedules,

col[x] - the color of x.

The algorithm is following:

Initially b[n]=w[n]=dp[n]=0, b[x]=w[x]=dp[x]=+∞ for all x≠n. All vertices are unpainted.If there is no unpainted vertex x such that dp[x]<+∞ (including the case when all vertices are painted) - go to point 6Among all unpainted vertices choose vertex u with the smallest possible value of dp[u].If b[u]>w[u] set col[u]=0.

If w[u]>b[u] set col[u]=1.

If w[u]=b[u] then col[u] can be either 0 or 1.

Watch each edge (u,v) outgoing from u. Let an edge's color be t.If t=0 (black edge) - set b[v]=min(b[v],dp[u]+1).

If t=1 (white edge) - set w[v]=min(w[v],dp[u]+1).

Then set dp[v]=max(b[v],w[v]).

Go to point 2.For each unpainted vertex set the color just as in point 3.The value of dp[1] is equal to the desired answer (excluding dp[1]=∞ case: that means there's no way from n to 1 for the constructed schedule, and the answer is −1), and the values of col form the optimal schedule.Correctness proof

Let lb[x], lw[x] and l[x] be the real optimal values of b[x], w[x] and dp[x]. We'll show that the parameters found by the algorithm are optimal. Let's proof some statements:

1. Any optimal path is simple. This statement is obvious, because the shortest path in any graph doesn't contain repeating vertices.

2. For any black edge (u,v) l[u]+1≥lb[v]. For any schedule the length of the shortest path from n to u is not greater than l[u], and the color of v is fixed, so the length of the shortest path from n to v is not greater than l[u]+1. For white edges and correspondingly lw[u] the analogous statement is correct.

3. b[x]≥lb[x], w[x]≥lw[x] for any vertex x at every moment. Before the first iteration the statement 3 is correct. Let u be selected in the beginning of some iteration, and we update the parameters of v for a black edge (u,v). Let the statement 3 be correct before the update. Then due to the statement 2 l[u]+1≥lb[v]. b[u]≥lb[u] and w[u]≥lw[u], so dp[u]=max(b[u],w[u])≥l[u]=max(lb[u],lw[u]), and dp[u]+1≥l[u]+1≥lb[v]. After the update the value of b[v] can stay the same or be changed to dp[u]+1, but since as b[v]≥l[v], the final value of b[v] is not less than l[v], so the statement 3 remains correct after the update. Analogously we can show that for white edges it's correct, too. By induction we have that the statement 3 is invariant, i.e. it's always correct.

We can notice that for each painted vertex x it's value of dp[x] is not smaller than the value of dp[y] for any vertex y painted before the x. Also, the values of dp[x], b[x] and w[x] remain constant after the iteration when x is painted. These facts are easy-to-proof, but for shortness we won't do it here.

Lemma: in the end of the k-th iteration for each vertex x the values of b[x], w[x] and dp[x] correspond to the shortest (for the current schedule) paths passing through the painted vertices only (excluding x).

Proof: we'll show it by induction on the number of iterations.

It's easy to see that after the first iteration the Lemma remains correct.

Let the Lemma be correct after the first k iterations. Let x be painted during the (k+1)-th iteration. Then b[x] and w[x] are already equal to the lengths of shortest paths to x, passing through painted vertices only and ending by black and white edges, correspondingly (it's obvious, proof it yourself if you don't believe). The length of the shortest path for already painted vertices won't change, because dp[x] is not smaller than the values of dp of previously painted vertices.

Thus, at the end of the algorithm we get the desired schedule, where dp[x] for each x is equal to the length of the shortest path to x, and dp[x]≥l[x]; then from these two statements follows the fact that dp[x]=l[x] for all vertices x, what means that the constructed schedule is optimal.

Realisation

This algorithm can be realised as a modified BFS, where the vertex is added to the queue just as it's value becomes smaller than infinity (in the code the value of «infinity» can be just n). It's easy to proof that such realisation is equivalent to the algorithm.

Solution

Codeforces Round #668 Editorial

By Monogon, history, 2 years ago, In EnglishI hope everyone enjoyed the contest!

UPD: Added implementations for all problems.

1405A - Permutation Forgery

Author: antontrygubO_o

Tutorial1405A - Permutation ForgeryLet p′=reverse(p). Then

p′ is a permutation, since every value from 1 to n appears exactly once.p′≠p since p′1=pn≠p1. (Here, we use n≥2.)F(p′)=F(p) since any two adjacent values in p remain adjacent in p′.Implementation

1405B - Array Cancellation

Author: hugopm

Tutorial1405B - Array CancellationThe answer is the maximum suffix sum, which can be computed in O(n).

Formal proof.

Define ci=ai+ai+1+⋯+an (partial suffix sum). Note M=max(c).

We can observe that a1=⋯=an=0 if and only if c1=⋯=cn=0. (If c is null, ai=ci−ci+1=0−0=0.)

A free operation on i<j is equivalent to incrementing ci+1,…,cj. Free operations can only increment elements of c, so we obviously need at least M coins.

Let's do M times the operation (i=n,j=1), which decrement every element M times.

Now, for every i, ci≤0 and we can make it equal to 0 by performing −ci times the free operation (i−1,i).

Implementation

1405C - Balanced Bitstring

Author: Kuroni

Tutorial1405C - Balanced BitstringLet's denote the balanced bitstring (if any) deriving from s to be t. Also, for the ease of the tutorial, let the strings be 0-indexed (so the first character has index 0 and the last character has index n−1).

First of all, let's prove a very important observation: for every i such that 0≤i<n−k, ti=ti+k. This is because the length k substrings starting at i and i+1 share the k−1 characters ti+1…ti+k−1, so in order for both strings to have the same number of 1 characters, their remaining characters ti and ti+k must both be 1, or both be 0.

Extending this fact, we can easily prove that ti=tj if i≡j(modk). So first of all, for each 0≤i<k, we need to find out if all sj such that j mod k=i can be converted to the same character (i.e. there can't exist both 0 and 1 among these characters). Furthermore, we can deduce some information for ti: it must be 0 if at least one character among sj is 0, must be 1 if at least one character among sj is 1, or it can be undecided and can be freely assigned to 0 or 1 if all sj are ?.

An illustration for n=9, k=4. The positions highlighted with the same colors must have the same characters. By using the information from the known characters we can fill some of the unknown positions.

Lastly, we need to check if we can make the substring t0t1…tk−1 have exactly half of the characters are equal to 1 (we don't need to check for any other substring, because the condition ti=ti+k implies that all the substrings of size k will have the same number of 1 characters). We simply need to check if the number of decided 1 characters and the number of decided 0 characters do not exceed k2. It can easily be shown that if these numbers don't exceed this value then we can assign the undecided characters so that half of the characters are 1, and if one exceeds then it is impossible to do so.

Implementation

1405D - Tree Tag

Author: cabbit

Tutorial1405D - Tree TagLet's consider several cases independently.

Case 1: dist(a,b)≤da

Unsurprisingly, Alice wins in this case by tagging Bob on the first move.

Case 2: 2da≥tree diameter

Here, the diameter of a tree is defined as the length of the longest simple path.

In this case, Alice can move to a center of the tree. Once Alice is there, it doesn't matter where Bob is, since Alice can reach any vertex in the tree in just one move, winning the game.

Case 3: db>2da

In this case, let's describe a strategy for Bob to win. Because we are not in case 1, Bob will not lose before his first move. Then it is sufficient to show that Bob can always end his turn with distance greater than da from Alice.

Since we are not in case 2, there is at least one vertex with distance at least da from Alice. If Bob is at such a vertex at the start of his turn, he should simply stay there. Otherwise, there is some vertex v with dist(a,v)=da+1. Then dist(b,v)≤dist(b,a)+dist(a,v)≤da+(da+1)=2da+1≤db, so Bob can jump to v on his turn.

Case 4: db≤2da

In this case, Alice's strategy will be to capture Bob whenever possible or move one vertex closer to Bob otherwise. Let's prove that Alice will win in a finite number of moves with this strategy.

Let's root the tree at a. Bob is located in some subtree of a, say with k vertices. Alice moves one vertex deeper, decreasing Bob's subtree size by at least one vertex. Since db≤2da, Bob cannot move to another subtree without being immediately captured, so Bob must stay in this shrinking subtree until he meets his inevitable defeat.

Solution

The only non-trivial part in the implementation is checking for cases 1 and 2. Case 1 is simply checked with DFS. Case 2 only requires computing the diameter of the tree, which is a standard problem.

Complexity is O(n).

Implementation

1405E - Fixed Point Removal

Author: hugopm

Tutorial1405E - Fixed Point RemovalConvenient transformation

Replace ai by i−ai. The new operation becomes: remove a zero, and decrement all elements after by one.

For each query, note l=1+x and r=n−y the endpoints of the non-protected subarray.

The main idea of the solution is iterating over r, maintaining answers for each l in a BIT (increment on prefix) and answer queries offline (when we meet a right endpoint). What follows is a detailed explanation of this idea.

Simplified version

Let's suppose that l=1 holds for all queries.

We can intuitively see that ai is removable iff ai≥0 and we can remove at least ai elements before. We're going to rewrite this more formally.

Let f(r) be the maximum number of elements we can remove in the subarray a[1…r]. If ar<0 or ar>f(r−1), then it's obviously impossible to remove ar and in that case, f(r):=f(r−1).

Otherwise, if 0≤ar≤f(r−1), then f(r):=f(r−1)+1. We can reach this with the following strategy:

Perform the ar first steps in the prefix [1,r−1]Remove ar (which is equal to 0 at that moment)Perform the remaining f(r−1)−ar steps in the prefix [1,r−1].Hence, we can compute successively f(1),f(2),…,f(n) with a single loop: maintain current f(r) in a variable s, and at each iteration increment s if and only if 0≤ar≤s.

Complete version

Note f(l,r) the maximum number of elements we can remove in the subarray a[l…r] (zero if l>r). During our iteration over r, we're going to maintain the answers for each l:s=[f(1,r),f(2,r),…,f(n,r)]When the iteration continues, discovering a new element ar, what happens? If ar<0, nothing happens. Otherwise, sl is incremented by one if and only if sl≥ar.

Let lmax be the greatest l such that l≤r and slmax≥ar. We should increment the prefix ending here by one:

s1≥…≥slmax≥ar>slmax+1≥…≥snA binary indexed tree (aka Fenwick tree) is obviously the structure we need in order to maintain s, since it allows to add on segment and get one element in O(logn) (segment tree could work, but is slower in practice).

In order to find lmax, the easiest solution is to binary search, it takes O(log2n) time which is fast enough to get AC. We can also use binary lifting in order to optimize the search in O(logn). This technique is explained in this blog.

We have to read all queries in advance (offline algorithm). When the iteration over r meets the right endpoint of a query, we set its answer to the current weight of sl.

In order to get an online algorithm (answer the query before reading the next one), we would have to use a persistent data structure.

Final complexity: O((n+q)logn) with low constant factor.

Under given time limit, log2 solutions with reasonable constant factor could also pass.

Implementation

1404D - Game of Pairs

Author: Ari

Tutorial1404D - Game of PairsWe split the problem into two cases:

n is even

We claim that First can guarantee a win by forming the pairs (1,n+1),…,(n,2n). Note that no matter which elements Second chooses, he will always take one element having each remainder modulo n. Thus the total sum is

0+1+2+⋯+n−1≡n(n−1)2(modn)Say n=2m, then this reduces to m(2m−1)(mod2m). Since 2m−1 is an odd integer this is nonzero, and the sum isn't even divisible by n, let alone 2n.

n is odd

This is the more difficult part of the problem. We claim that now Second is able to win, and present a strategy. We have two important claims:

Claim 1. It is enough for Second to find a choice of elements from each pair such that the sum of the chosen numbers is divisible by n (instead of 2n).

Proof. Notice that the sum of all the numbers is 1+2+⋯+2n=n(2n+1), which is congruent to n(mod2n). If the sum of some numbers, one from each pair, is divisible by n, then it is either 0(mod2n) or n(mod2n). In the first case, we have already won. Otherwise, if we take every other number instead, the sum of those numbers will be 0(mod2n), and we will also win.

Claim 2. It is always possible to take one element from each pair such that each of the remainders modulo n appears exactly once.

Proof. Consider a graph with 2n vertices 1,2,…,2n and regard the pairs chosen by First as red edges in this graph. We will additionally create n edges connecting the vertices i and i+n for each i≤n, and paint them blue. Then every vertex is adjacent to one red edge and one blue edge. In particular, all vertices have degree 2, so the graph splits into disjoint cycles.

An illustration for the case n=5. The pairs are (1,6), (2,7), (3,5), (4,8) and (9,10). The numbers 1,7,3,4,10 on the white vertices cover all residues modn.

Since the edges in each cycle alternate between being red and blue, they all have even lengths, so it's possible to color their vertices alternately black and white, and we can construct such a coloring by a simple DFS. Finally, after doing this for all cycles, take the numbers corresponding to all the white vertices. Since no two of them are joined by a red edge, they are all in different pairs, and since no two of them are joined by a blue edge, their residues modulo n are all different, and thus each one appears exactly once.

Finally, by combining the two previous claims the problem is solved, since 0+1+⋯+n−1≡0(modn).

Complexity: O(n).

Implementation

1404E - Bricks

Author: Monogon

Tutorial1404E - BricksInstead of placing a minimum number of bricks into the cells, let's imagine that we start out with all 1×1 bricks and delete the maximum number of borders. Of course, we need to make sure that when we delete borders, all the regions are in fact bricks.

A region is a brick if and only if it contains no "L" shape. Let's construct a graph where each vertex is a border between two black cells, and we connect two vertices if deleting both would create an "L" shape.

Then the tilings correspond exactly with the independent vertex sets in this graph, and the optimal tiling corresponds to the maximum independent set. The number of bricks is simply the total number of black cells minus the size of our independent set. Here is the graph and independent vertex set corresponding to a tiling:

In general, computing the maximum independent vertex set of a graph is NP-complete. But in our special case, this graph is bipartite (the bipartition being horizontal borders and vertical borders). And Kőnig's Theorem states that for bipartite graphs, the size of the maximum matching is equal to the size of the minimum vertex cover. Recall that the complement of a minimum vertex cover is a maximum independent set.

The maximum matching can be computed using maximum flow. In particular, Dinic's algorithm runs in O(V−−√E) time. For our graph, V and E are both O(nm). Overall complexity is therefore O(nmnm−−−√).

Implementation

Codeforces Round #667 (Div. 3) Editorial

By vovuh, history, 2 years ago, In EnglishI'm so thankful to all testers, especially to Gassa and Rox for their invaluable help!

1409A - Yet Another Two Integers Problem

Idea: vovuh

Tutorial1409A - Yet Another Two Integers ProblemWe can add or subtract 10 until the difference between a and b becomes less than 10. And if it is not 0 after all such moves, we need one additional move.

Let d=|a−b| is the absolute difference between a and b. The final answer is ⌊d10⌋ plus one if dmod10>0. This formula can be represented as d divided by 10 rounded up, in other words ⌊d+910⌋.

Solution1409B - Minimum Product

Idea: vovuh

Tutorial1409B - Minimum ProductThe only fact required to solve the problem: if we start decreasing the number, we are better to end decreasing it and only then decrease the other number. So, we can just consider two cases: when we decrease a first, and b after that and vice versa, and just take the minimum product of these two results. The rest is just implementation.

Solution1409C - Yet Another Array Restoration

Idea: vovuh

Tutorial1409C - Yet Another Array RestorationThe only fact required to solve this problem is just to notice that the answer array is just an arithmetic progression. After that, we can fix the first element start, fix the difference d, construct the array [start,start+d,start+2d,…,start+d⋅(n−1)], check if x and y are in this array and, if yes, update the answer with start+d⋅(n−1). This is O(n3) solution.

There are faster solutions, though. Other author's solution is O(ny√) but I didn't want to make this problem harder, so I allowed O(n3) solutions.

It is obvious that the difference of the progression is some divisor of y−x. Let it be d. Let's add some elements starting from y "to the left" (y,y−d,y−2d and so on) and stop if we reach n elements or the next element is less than 1. If we didn't find x among these elements, just skip this difference, it is useless for us. Otherwise, if we have less than n elements, let's add y+d,y+2d,y+3d and so on until we get n elements. And then update the answer with the maximum element of the array.

There is also a solution in O(n+y√) with some greedy observations :)

Solution (Gassa)Solution (vovuh)Solution (Rox)1409D - Decrease the Sum of Digits

Idea: MikeMirzayanov

Tutorial1409D - Decrease the Sum of DigitsFirstly, let's check if the initial n fits the conditions. If it is, print 0 and continue. Otherwise, let's solve the problem greedily. At first, let's try to set the last digit to zero. Let dig=nmod10. We need exactly (10−dig)mod10 moves to do that. Let's add this number to n and to the answer and check if the current n fits the conditions. If it isn't, let's try to set the previous last digit to zero. Let dig=⌊n10⌋mod10. Then we need ((10−dig)mod10)⋅10 moves to do that. Let's add this number to n and to the answer and check if the current n fits the conditions. If it isn't, repeat the same with the third digit and so on. This cycle can do no more than 18 iterations. And we can fing the sum of digits of n in at most 18 iterations too (decimal logarithm of n).

So, the total time complexity is O(log210(n)).

Solution1409E - Two Platforms

Idea: vovuh

Tutorial1409E - Two PlatformsFirstly, we obviously don't need y-coordinates at all because we can place both platforms at y=−∞. Let's sort all x-coordinates in non-decreasing order.

Calculate for each point i two values li and ri, where li is the number of points to the left from the point i (including i) that are not further than k from the i-th point (i.e. the number of such points j that |xi−xj|≤k). And ri is the number of points to the right from the point i (including i) that are not further than k from the i-th point. Both these parts can be done in O(n) using two pointers.

Then let's build suffix maximum array on r and prefix maximum array on l. For l, just iterate over all i from 2 to n and do li:=max(li,li−1). For r, just iterate over all i from n−1 to 1 and do ri:=max(ri,ri+1).

The question is: what? What did we do? We did the following thing: the answer always can be represented as two non-intersecting segments of length k such that at least one endpoint of each segment is some input point (except the case n=1). Now, let's fix this border between segments. Iterate over all i from 1 to n−1 and update the answer with max(li,ri+1). So we took some segment that starts at some point to the left from i (including i) and goes to the left and took some segment that starts further than i+1 (including i+1) and goes to the right. With this model, we considered all optimal answers that can exist.

Time complexity: O(nlogn).

Solution1409F - Subsequences of Length Two

Idea: vovuh

Tutorial1409F - Subsequences of Length TwoI'm almost sure this problem can be solved faster and with greater constraints but this version is fine for the last problem.

Consider both strings 0-indexed and let's do the dynamic programming dpi,j,cnt0. It means the maximum number of occurrences of t if we considered first i characters of s, did j moves and the number of characters t0 is cnt0. The answer to the problem is maxck=0kmaxcnt0=0ndpn,ck,cnt0. Initially all states are −∞ and dp0,0,0 is 0. What about transitions? There are essentially three types of them: don't change the current character, change the current character to t0 and change the current character to t1.

Let's create three additional variables to make our life easier (if that were true...). e0 is 1 if si=t0 and 0 otherwise, e1 is 1 if si=t1 and 0 otherwise and e01 is 1 if t0=t1 and 0 otherwise. Now let's make and describe our transitions:

Don't change the i-th character:dpi+1,ck,cnt0+e0=max(dpi+1,ck,cnt0+e0,dpi,ck,cnt0+(e1 ? cnt0:0)).

The expression x ? y:z is just ternary if statement: if x is true, return y, otherwise return z. So, the number of characters t0 increases if si equals t0 and the answer increases if the i-th character equals t1 (because we added all occurrences that end in the i-th character).

Change the i-th character to t0 (possible only when ck<k):dpi+1,ck+1,cnt0+1=max(dpi+1,ck+1,cnt0+1,dpi,ck,cnt0+(e01 ? cnt0:0)).

The number of characters t0 always increases and the answer increases if t0 equals t1 by the same reason as in the previous transition.

Change the i-th character to t1 (possible only when ck<k):dpi+1,ck+1,cnt0+e01=max(dpi+1,ck+1,cnt0+e01,dpi,ck,cnt0+cnt0).

The number of characters t0 increases only if t0=t1 and the answer always increases.

Note that we always increase the number of moves in the second and the third transitions even when si equals t0 or t1 because this case is handled in the first transition, so we don't care.

Time complexity: O(n3).

There are also some greedy approaches which work in O(n4) with pretty small constant and can be optimized even further.

SolutionSolution (Gassa, greedy, O(n^4))

Codeforces Round #666 — Editorial

By DatVu, history, 2 years ago, In EnglishWe hoped you find our problems interesting. We apologize for the late editorial. Hopefully you were still able to enjoy our contest.

Anyway, here are the tutorials for each of the problems:

1397A - Juggling LettersIf the total number of occurrences of some character c is not a multiple of n, then it is impossible to make all n strings equal — because then it is impossible for all n strings to have the same number of c.

On the other hand, if the total number of occurrences of every character c is a multiple of n, then it is always possible to make all n strings equal. To achieve this, for every character c we move exactly ((the total number of occurrences of c) / n) characters c to the end of each string, and by the end we will have all n strings equal each other.

We can easily check if the condition satisfies by counting the total number of occurrences of each character c and check its divisibility by n. The final complexity is O(S⋅26) or O(S) where S is the sum of lengths of all strings.

C++ solutionPython solution1397B - Power SequenceFirst of all, the optimal way to reorder is to sort a in non-decreasing order.

ProofFrom now on, we assume a is sorted in non-decreasing order.

Denote amax=an−1 as the maximum value in a, f(x)=∑|ai−xi| as the minimum cost to transform a into x0,x1,⋯,xn−1, and c as the value where f(c) is minimum.

Note that cn−1−amax≤f(c)≤f(1), which implies cn−1≤f(1)+amax.

We enumerate x from 1,2,3,… until xn−1 exceeds f(1)+amax, calculate f(x) in O(n), and the final answer is the minimum among all calculated values. The final complexity is O(n⋅max(x)).

But why doesn't this get TLE? Because f(1)=∑(ai−1)<amax⋅n≤109⋅n, thus xn−1≤f(1)+amax≤109⋅(n+1). When n=3,4,5,6, max(x) does not exceed 63245,1709,278,93 respectively; so we can see that O(n⋅max(x)) comfortably fits in the time limit.

C++ solutionPython solution1396A - Multiples of LengthIn this problem, the answer is rather simple. Here is one possible solution to this task.

Solution for n = 1Solution for n != 1C++ solutionPython solution1396B - Stoned GameLet us denote S as the current total number of stones.

Consider the following cases:

Case A: There is a pile that has more than ⌊S2⌋ stones.

The first player (T) can always choose from this pile, thus he (T) is the winner.

Case B: Every pile has at most ⌊S2⌋ stones, and S is even.

It can be proven that the second player (HL) always wins.

Proof 1Proof 2Case C: Every pile has at most ⌊S2⌋ stones, and S is odd.

The first player (T) can choose from any pile, and we arrive back at case B where the next player to move loses.

So the first player (T) wins if and only if there is a pile that has more than ⌊S2⌋ stones or S is odd. This can be easily checked in O(n).

C++ solutionPython solution1396C - Monster InvadersIn this problem, it is useful to note that when the boss only has 1 hp left, just use the pistol because it has the least reloading time. So there are 3 strategies we will use when playing at stage i (1≤i≤n):

Take ai pistol shots to kill first ai monsters and shoot the boss with the AWP.Take ai+1 pistol shots and move back to this stage later to take another pistol shot to finish the boss.Use the laser gun and move back to this stage later to kill the boss with a pistol shot.Observation: We will always finish the game at stage n or n−1. Considering we are at stage i (i≤n−1) and the boss at both stage i stage i−1 has 1 hp left, we can spend 2∗d time to finish both these stages instead of going back later, which costs us exactly the same.

Therefore, we will calculate dp(i,0/1) as the minimum time to finish first i−1 stages and 0/1 is the remaining hp of the boss at stage i. The transitions are easy to figure out by using 3 strategies as above. The only thing we should note is that we can actually finish the game at stage n−1 by instantly kill the boss at stage n with the AWP so we don't have to go back to this level later.

Answer to the problem is dp(n,0). Time complexity: O(n).

C++ solution1396D - Rainbow RectanglesLet xl,xr,yd,yu denote a rectangle with opposite corners (xl,yd) and (xr,yu). For convenience, assume (xl≤xr) and (yd≤yu).

Let's try solving the problem if coordinates are in range [1,n]. We could easily do this by coordinates compression.

First, let's look at the problem with (yd,yu) fixed. We define fx to be the smallest integer such that x≤fx and (x,yd),(fx,yu) is a good rectangle (If there is no such integer, let fx=inf). It can be proven that fx is non-decreasing, i.e. if x<y, then fx≤fy.

Now, let's see how fx changes when we iterate yd over a fixed yu. It is hard to add points to the set, so we will try to support deleting points operation. For point i, we have the following definitions:

Let set S={j|cj=ci,yi<yj≤yu,xj≤xi}. Let prvi=j∈S with the largest xj.

Let set S′={j|cj=ci,yi<yj≤yu,xj≥xi}. Let nxti=j∈S′ with the smallest xj.

(Note that S or S′ might represent empty set).

With these two functions, we could see how fx changes after we delete point i. It looks something like this: For every xl∈(xprvi,xi] such that fxl≥xi,fxl=max(fxl,xnxti);

We could support this operation using segment tree with lazy propagation. The total time complexity is O(n2⋅logn).

C++ solution1396E - Distance MatchingRoot the tree at centroid c.

First, determine if there is any matching that satisfies the requirement. Consider an edge e that splits the tree into 2 subtrees with sizes x and N−x respectively, let z be the number of paths passing through e, then we have z has the same parity as x and x%2≤z≤min(x,N−x). Thus the necessary condition for a matching is ∑(sub(v)%2)≤K≤∑sub(v) and K has the same parity as ∑sub(v), where v≠c and sub(v) is the size of the subtree rooted at v. We prove that this is also the sufficient condition by its construction:

Consider the matching with maximum K, note that c lies on all the paths in the matching.

We can see that if we remove two vertices from the largest subtree, rooted at w≠c, then c is still the centroid. Also, if we match two vertices v and u in the subtree rooted at w, the answer decreases by 2⋅dist(c,lca(u,v)). Based on this, we can achieve the target K by repeating the following operation (currentK is the current maximum possible K, initially ∑sub(v)):

Let z be a non-leaf vertex in the largest subtree such that dist(c,z)≤currentK−targetK2 (if there are many z, take any z with maximum dist(c,z)). Match two vertices v and u whose LCA is z, then remove v and u from the tree.After some time currentK=targetK, so we just need to greedily match the remaining vertices to create the final matching.

The final complexity is O(NlogN).

C++ solution

Codeforces Round #665 (Div. 2) Editorial

By tlsdydaud1, 3 years ago, In EnglishThank you for participating. I hope you enjoyed the contest!

1401A - Distance and Axis

Tutorial1401A - Дистанция и осьIf n is less than k, we have to move A to coordinate k, and set the coordinate of B as 0 or k. So the answer is k−n.

If n is not less than k, let's define the coordinate of B as m(m×2≤n). By the condition in the problem, the difference between (m−0) and (n−m) should be equal to k. That is, (n−m)−(m−0) is k, and summarizing the formula, m=(n−k)/2. Because the coordinate of B is integer, if the parity of n and k is same the answer is 0, otherwise the answer is 1(If we increase the coordinate of A by 1, m becomes integer).

Time complexity : O(1)Solution CodeBehind Story1401B - Ternary Sequence

Tutorial1401B - Троичная последовательностьWe can find the kind of the value of ci is three (−2,0,2). And ci is −2 only if ai is 1 and bi is 2, and ci is 2 only if ai is 2 and bi is 1. Otherwise ci is 0. So we have to make (ai,bi) pair (1,2) as little as possible, and pair (2,1) as much as possible. To do this, first we can make (1,0) pair, (0,2) pair, and (2,1) pair as much as possible. After that, pairing the remaining values doesn't affect the sum of ci. (It ai in which value is 1 and bi in which value is 2 are all left, we have to pair them although the sum decreases.)

Time complexity : O(1)Solution CodeBehind Story1401C - Mere Array

Tutorial1401C - Просто массивLet's define the minimum element of a as m. We can find the position of the elements which is not divisible by m cannot be changed because these elements don't have m as factor. But we can rearrange elements divisible by m whatever we want in the following way:

∙ Let's suppose m = ax, and there is two elements ay, az in which x, y, z are all different. Swap(ax, ay), swap(ay, az), and swap(az, ax). Then only ay and az are swapped from the initial state. Repeat this process.

So we can rearrange elements divisible by m in non-descending order. After that if whole array is non-descending the answer is YES, otherwise NO.

Time complexity : O(nlogn)Solution CodeBehind Story1401D - Maximum Distributed Tree

Tutorial1401D - Максимально распределенное деревоLet's define wi as the product of the number of vertices belonging to each of the two components divided when the ith edge is removed from the tree, and zi as the number on ith edge. Now a distribution index is equal to ∑n−1i=1(wi×zi). Now there are two cases:

A : m≤n−1In this case, we have to label p1,p2,…pm to m distinct edges because we have to minimize the number of 1-s. And to maximize distribution index, we can label a larger pi to the edge in which wi is larger because the following holds:

∙ For four positive integers a,b,c,d (a≥b,c≥d), ac+bd≥ad+bcLet's suppose a=b+x,c=d+y (x,y≥0). Then the equation can be written as follows:

(b+x)(d+y)+bd≥(b+x)d+b(d+y)bd+by+xd+xy+bd≥bd+xd+bd+byxy≥0Because x,y≥0, we proved it.

And label 1 to the remaining edges.

B : m>n−1In this case, we can make no 1-s exist out of n−1 integers, and some of n−1 number would be composite. And to maximize distribution index, we can label the product of m−n+2 largest pi to the edge in which wi is largest, and label the remaining pi to the remaining edges in the same way as case A because the following holds:

∙ For five positive integers a,b,c,d,e (a≥b,d≥e), acd+be≥bcd+aeSubstituting f=cd in the above equation, we can find the equation is same as before. So we proved it.

After filling in the edge, calculate it and find the answer.

Time complexity : O(max(n,m)logmax(n,m))Solution CodeBehind Story1401E - Divide Square

Tutorial1401E - Разбиваем квадратUnder given condition, there are only two cases in which the number of pieces increases.

∙ When a segment intersects with two sides (facing each other) of the square, the number of pieces increases by one.

∙ When two segment intersects in the square (not including sides), the number of pieces increases by one.

So the answer is equal to (the number of segment intersecting with two sides of the square) + (the number of intersection in the square). You can sort the segments by ascending order of y-coordinate (Set the start and end points of vertical lines separately.) and do sweeping using segment tree to calculate the number of intersections in the square.

Time complexity : O(nlogn+mlogm)Solution CodeBehind Story1401F - Reverse and Swap

Tutorial1401F - Reverse и SwapLet's consider the sequence as 0-based. Then we can find the following two facts:

∙ If we do Reverse(k) operation once, ai becomes ai^(2k−1).

∙ If we do Swap(k) operation once, ai becomes ai^(2k).So in any state there is an integer x that makes the current ai equal to the initial ai^x and current ai^x is equal to the initial ai for each i (0≤i≤2n−1). (Don't consider the change of the values by Replace(x,k) operation.)

Therefore, if we can calculate ∑ri=lai^x fast for arbitrary x, also can solve the problem, and it can be done using segment tree. When processing Replace(i,k) queries, replace ai^x as k. And when processing Reverse(k) or Swap(k) queries, just replace x as x^(2k−1) or x^(2k).

And Sum(l,r) queries are left. To calculate this value, divide the segment [l,r] into smaller segments, in which length of each segment is power of 2 and can be found in the segment tree. (ex : segment [3,9] is divided into three segments - [3,3], [4,7], [8,9])

Next, find the sum of numbers in which index is in each segment. For divided segment [l,r] in which length is 2k, the values l^x,(l+1)^x,…(r−1)^x,r^x are, when sorted, form another segment [l^(x&~(2k−1)),r^(x&~(2k−1))], which x&~(2k−1) means the largest of multiples of 2k not greater than x. So you can find the sum of numbers in each divided segment ∑ri=l(current ai) as ∑r^(x&~(2k−1))i=l^(x&~(2k−1))(initial ai). Repeat this and we can find the answer for each Sum query.

Time complexity : O(nq)Solution CodeBehind Story

Codeforces Round #664 Editorial

By sshwyR, history, 3 years ago, In EnglishThank you for participating, and I hope you enjoyed the problems!

1395A - Boboniu Likes to Color BallsIdea: dqa2021

Tutorial1395A - Boboniu Likes to Color BallsIf there are less than or equal to one odd number in r, b, g, w, then you can order them to be a palindrome.

Otherwise, do the operation once (if you can) and check the condition above.

It is meaningless to do operation more than once because we only care about the parity of r, b, g, w.

Solution1395B - Boboniu Plays ChessIdea: Xiejiadong

Tutorial1395B - Boboniu Plays ChessThere are many solutions and I will describe one of them.

Let say f(i,j)=((i+Sx−2)modn+1,(j+Sy−2)modm+1).

Iterate i from 1 to n:

if i is odd, print f(i,1),f(i,2),…,f(i,m).Else print f(i,m),f(i,m−1),…,f(i,1).Solution1395C - Boboniu and Bit OperationsIdea: Retired_xryjr233

Tutorial1395C - Boboniu and Bit OperationsSuppose the answer is A. Thus for all i (1≤i≤n), ci|A=A.

Since ai,bi<29, we can enumerate all integers from 0 to 29−1, and check if there exists j for each i that (ai&bj)|A=A. The minimum of them will be the answer.

The time complexity is O(29⋅n2)Solution1394A - Boboniu Chats with DuIdea: sshwyR

Tutorial1394A - Boboniu Chats with DuIf ai>m, we consider it as a big item with value ai, else a small item with value ai. We are asked to choose some items and maximize the total value. If an item is not chosen, it means we put it on a muzzled day.

Enumerate the number of chosen big item, which is denoted by x. Thus they take (x−1)(d+1)+1 days. The remaining days are used to place small item on it. Choose items greedily. i. e. We sort items by value from largest to smallest, choose previous x big items and previous n−(x−1)(d+1)−1 small items and update the answer.

The total time complexity is O(nlogn).

Solution1394B - Boboniu Walks on GraphIdea: sshwyR

Tutorial1394B - Boboniu Walks on GraphLet degu denote the out degree of u. Let nexu,i denote the vertex, which the edge with the i-the smallest weight among all edges start from u ends at.

For a fixed tuple (t1,t2,…,tk), if {nexi,tdegi|1≤i≤n}={1,2,…,n} (i. e. each vertex appears exactly once), then it is a correct tuple.

Let Si,j denote if ci=j, the set for vertex with out degree i, which is {nexu,j|degu=i}. Thus the condition above can be changed to: S1,t1∪S2,t2∪…∪Sk,tk={1,2,…,n}.

Let's enumerate all k! situations and use hash to check if it's correct.

The hash function is diverse. For example, for a integer set T, we can use h(T)=∑x∈Tvalxmodp or h(T)=∏x∈Tvalxmodp. Just make sure it has associative property. Here valx may be a random number. Let alone using multiple hash.

The total time complexity is O(n+m+k!).

Solution1394C - Boboniu and StringIdea: sshwyR

Tutorial1394C - Boboniu and StringIt's obvious that the operation of BN-string is equivalent to the operation of BN-set, which I'm talking about, for a multi set s contains only B and N:

Remove a B or an N (if exists) from s.Insert a B or an N into s.Remove a B and an N from s.Insert a B and an N into s.So let's use pair (x,y) to denote a BN-set, which means there are x B and y N in it. We can do an operation to move to (x,y±1),(x±1,y),(x±1,y±1).

The definition of similar of BN-set (x1,y1) and (x2,y2) is simply x1=x2 and y1=y2.

Now the problem is to find a (xt,yt) and minimize maxni=1dist(si,t). There are many algorithms to solve it and I'll describe two of them.

We can figure out the distance between s1=(x1,y1) and s2=(x2,y2) is:dist(s1,s2)={|x1−x2|+|y1−y2|max(|x1−x2|,|y1−y2|)(x1−x2)(y1−y2)<0(x1−x2)(y1−y2)≥0It can be shown that the answer is a unimodal function on xOy. So by using Hill Climbing Algorithm, we can solve the problem in O(nT), where T denotes the times of iteration.

We also have non randomized algorithm. It can be shown that for a fixed pair P=(px,py), all the pair with distance x from P forms a hexagon:

So if we draw a hexagon centered on (xt,yt) with radius maxni=1dist(si,t), then it must cover all si.

So we can try to find a hexagon with minimal radius r to cover all si and then we can easily calculate (xt,yt). Let's use binary search and do some condition tests to calculate r. The total time complexity is O(nlog2n).

Solution1394D - Boboniu and JianghuIdea: Z18

Tutorial1394D - Boboniu and JianghuGenerally speaking, you're asked to use some simple directed paths (challenges) to cover the original tree and minimize the total cost (tiredness). Those edges with hu≠hv are already oriented, and for the other ones, we need to determine their directions.

At first, let's consider the case where each edge has already been oriented (or, for all edges (u,v), hu≠hv holds).

We use P(u,v) to denote the directed path from u to v.

In the beginning, for each edge u→v, let's set up P(u,v) to cover it. Thus the total cost of it is obviously ∑ni=1deg(i)⋅ti, where degi denotes the degree of vertex i.

We can choose two challenge P(x,y) and P(y,z) (y should be on P(x,z)) and merge them together to get a single challenge P(x,z). This operation will reduce the total tiredness by ty. Thus we try to do such operation to maximize the total reduction.

For vertex i, suppose that there are ini challenges end at i and outi challenges start from i. Thus the total reduction is ∑ni=1min(ini,outi)⋅ti.

Now, let's try to solve the original problem.

For the directed edges, we calculate in′i and out′i for every vertex i, and we can delete them from the tree. For the undirected edges, they form several small trees (a forest).

Let's choose an arbitrary root for each tree and do a DP on it. Let pu be the father of u. For a non-root vertex u and its subtree, fu denotes the maximum reduction when we orient pu→u (down), and gu denotes the maximum reduction when we orient u→pu (up).

Take fu for example. To calculate it, we should know the in degree and out degree of u (after directing the edges).

Suppose that u has c children. If x of them are oriented end at u (up) and (s−x) of them are oriented start from u (down), the reduction of u is min(in′u+1+x,out′u+(s−x))⋅tu (+1 because pu→u).

Now the question changes to: You are given c vertices v1,v2,…,vc, choose x of them forming a set A. Maximize ∑v∈Agv+∑v∉Afv. Calculate the maximum value for all 0≤x≤c. Actually, you can sort [v1,v2,⋯,vc] by (fv−gv) and calculate the prefix sum si. The answer for x=i is simply si+∑vgv.

The calculation for gu and the root is similar. The total time complexity is O(nlogn).

Solution1394E - Boboniu and Banknote CollectionIdea: sshwyR

Tutorial1394E - Boboniu and Banknote CollectionAt first, I'd like to explanation the fold operation in a intuitive way.

Section 1 Fold

To be exact, the origin problem isn't ask us to calculate the number of folds, but the number of folding marks.

Section 1.1 Example 1

For example, you can fold [1,1,1,1] three times, but you have different method to fold it:

Method 1:

Method 2:

The first method can be represent by folding sequence (defined in the statement) [1,−1,1,−1]. The second method seems to be invalid under the definition of fold (in statement). But really?

In fact, those methods are equivalent. The position of their folding marks are exactly the same, but different in whether it's valley folds or mountain folds.

For the first method, the folding type of each fold mark is: mountain, valley, mountain.For the second method, it's: mountain, mountain, valley.(Try it yourself!)

Although the second method does only two folds, it folds two layers of paper together so it gets two folding marks in one fold.

Section 1.2 Example 2

For [1,2,2,2,2,1,1,2,2], there are different folding methods. I'll display two of them:

Firstly to be notice, they have same number of folding marks. The first method can be represent by folding sequence [1,1,−1,1,−1,−1,1,1,1].

We can change the result of the second method to the first method:

Just change the blue part to red part.

Section 1.3 Summary

In fact, the definition of fold in statement always lead to alternate mountain and valley folds. But you can also use different folding method, because any results can be transform into alternate mountain and valley folds.

key point 1: While folding, we don't care whether it's mountain or valley folds, we just care about the position of folding marks (and the rule in statement).

key point 2: Fix the sequence a, for all folding methods of a, as long as the results of them don't have any available folds, then the number of folding marks of them must be equal, and their results must be the same (or simply reverse sequence).

Although I'll provide proof for these key points, I want you to first think of it intuitively.

Section 2 X-Y-X Folding Method

If understanding the folding operation intuitively, it'll be quite easy to come up with a naive algorithm runs in polynomial time. Now I'll describe a general folding method.

Note: I will consider sequence as a string (with a large character set). The definition of substring, palindrome is similar for sequence.

Let's consider […,a,b,b,b,c,…], we can fold three b into one b with a mountain fold and a valley fold.

Similarly, consider three continuous substring XYX, where Y is the reverse string of X:

We can fold them into one X with a mountain fold and a valley fold, according to the first two key points.

Let's call it X-Y-X substring and the folding method X-Y-X fold.

The questions are:

How many layers of paper are folded during a X-Y-X fold? Can we find a proper folding method where each fold contains only one layer of paper?How to fold a string which doesn't contain X-Y-X substring?Section 3 Key Points

(For high level competitor) I display all the key points firstly which may lead you to final solution quickly.

Intuitively, we will fold a from left to right. Let's maintain another string b. Each time:

Push ai to the end of b and check if b contains new X-Y-X substring. If it does, then fold it.Calculate the number of folds of b. Note that this step won't actually change b. After that you get the answer of [a1,a2,⋯,ai].key point 3: Using this folding method, each fold contains exactly one layer of paper.

key point 4: After pushing ai to the end of b, b contains at most one X-Y-X substring and it must be a suffix if exists.

lemma: For string s and two even palindromic substring s[l1,r1], s[l2,r2] of it, if [l1,r1] contains center position of s[l2,r2] and [l2,r2] contains center position of s[l1,r1], then s must contain X-Y-X substring.

Use information above, we can figure out a O(n3) or O(n2) solution.

key point 5: For a string b which doesn't contain X-Y-X substring, we can only fold its prefix or suffix. And it can be folded at most O(|b|−−√) times.

key point 6: For a string b which doesn't contain X-Y-X substring, after pushing an element to the end of b, it has at most O(log2|b|) even palindromic suffixes.

Use information above, we can figure out a O(nlog2n+nn−−√) or O(nlog2n) solution, which is enough to pass.

Section 3.1 Example

Let's say a=[1,2,2,2,2,1,1,2,2]. So the folding method performs like:

b=[1]. It doesn't have any available folds. The answer is 0.b=[1,2]. It doesn't have any available folds. The answer is 0.b=[1,2,2]. It can be folded once. The answer is 1.b=[1,2,2,2], has X-Y-X substring [2,2,2], so b is changed to [1,2]. Plus X-Y-X counter by 2. After that, b doesn't have any available folds. The answer is 2.b=[1,2]+a5=[1,2,2]. It can be folded once. The answer is 3.b=[1,2,2]+a6=[1,2,2,1]. It can be folded once. The answer is 3.b=[1,2,2,1]+a7=[1,2,2,1,1]. It can be folded twice. The answer is 4.b=[1,2,2,1,1]+a8=[1,2,2,1,1,2], has X-Y-X substring [1,2,2,1,1,2], so b is changed to [1,2]. Plus X-Y-X counter by 2. After that, b doesn't have any available folds. The answer is 4.b=[1,2]+a9=[1,2,2]. It can be folded once. The answer is 5.Each time the answer is the sum of X-Y-X counter and number of folds of b.

So the total output will be [0,0,1,2,3,3,4,4,5].

Section 4 Proof and Understanding

Now I'll describe the proof of some key points. If you have already understand them, skip this section and read the algorithm part.

Section 4.1 Lemma

Description: For string S and two even palindromic substring S[l1,r1], S[l2,r2] of it, if [l1,r1] contains center position of S[l2,rr] and [l2,r2] contains center position of S[l1,r1], then S must contain X-Y-X substring.

Lets say l1<l2 and |r1−l1|≥|r2−l2|. By construction we can get:

Blue lines denotes the center position of two substrings and the red part forms a X-Y-X substring.

Q. E. D.

Section 4.2 X-Y-X and Simple X-Y-X

Let define Simple X-Y-X substring (S-X-Y-X) as a X-Y-X string which doesn't contain any X-Y-X substring except itself.

key point 7: S-X-Y-X string contains exactly one even palindromic suffix. i. e. the Y-X part of it.

Proof: Use reduction to absurdity and the lemma.

Section 4.3 Key Point 4

Description: After pushing ai to the end of b, b contains at most one X-Y-X substring and it must be a suffix if exists.

Let b′=b+ai.

Just like the picture above, if b′ contains two or more X-Y-X substring, there are three cases:

black and redblack and blueblack and greenAll of the three cases can be negate by the lemma or plain discovery.

Q. E. D.

By the way:

key point 4 shows us that if b′ has a X-Y-X substring, it must be a S-X-Y-X substring.key point 7 shows us that that if b′ has a X-Y-X substring, it must be produced by its shortest even palindromic suffix.Section 4.4 Key Point 5

Description: For a string b which doesn't contain X-Y-X substring, we can only fold its prefix or suffix. And it can be folded at most O(|b|−−√) times.

Let's take suffix for example. Each time you can fold an even palindromic suffix if exists. And the length of it must be increasing:

So that it won't contain X-Y-X substring. Similar for prefix. So the folds will end up being

Thus you can fold less than 2|b|−−√ times.

Q. E. D.

Section 4.5 Key Point 6

Description: For a string b which doesn't contain X-Y-X substring, after pushing an element to the end of b, it has at most O(log2|b|) even palindromic suffixes.

Because of the lemma, even palindromic suffixes of b cannot both contain center position of each other, so that if we sort them by length, then every even palindromic suffix must be at least twice as long as the previous one:

Thus b has at most O(log2|b|) even palindromic suffixes.

Q. E. D.

Section 5 Algorithm

The algorithm itself is quite simple. Remember that:

Intuitively, we will fold a from left to right. Let's maintain another string b. Each time:

Push ai to the end of b and check if b contains new X-Y-X substring. If so, then fold it.Calculate the number of folds of b. Note that this step won't change b. After that you get the answer of [a1,a2,⋯,ai].Section 5.1 Part 1

Let's maintain Si, the set of even palindromic suffixes of b after the i-th time. Since the size of it is O(log2n), use any data structure you want.

Calculate Si from Si−1 in O(log2n) is trivial.

Then we simply find the shortest even palindromic suffix of b and check if it produce a X-Y-X substring in O(log2n).

If it does produce, then we simply fold it, which means remove the shortest even palindromic suffix of b.

Don't forget to update X-Y-X counter.

Section 5.2 Part 2

To calculate the number of folds of b, which doesn't contain X-Y-X substring:

Let pi denote the length of shortest even palindromic suffix of b[1,i] (index starts from 1).Let qi denote that, if we fold the shortest even palindromic prefix start from b[1,i] and repeat folding until you can't fold, the position of the first character of the result. i. e. b[1,i] is folded to b[qi,i] finally. Let ci denote the number of folds during the process.Calculate qi from qi−1 in O(log2n). Don't forget ci.

Get pi from Si.

ci denotes the number of prefix folds of b.

You can fold suffix of b using p and calculate the number of suffix folds in O(n−−√).

The sum of two above is the number of folds of b. Plus it by X-Y-X counter you'll get the answer.

Remove suffix of b is trivial.

The total time complexity is O(nlog2n+nn−−√).

Section 5.3 Bonus

Can you optimize the time complexity of part 2 to O(log2n) and implement the algorithm in O(nlog2n)?

Solution

Codeforces Round #663 (Div. 2) Editorial

By SleepyShashwat, history, 3 years ago, In EnglishThank you for participating, and I hope you enjoyed the problems!

Also, here are video editorials by BRCode:

Problem A and BProblem CProblem DProblem E1391A - SuborraysEvery permutation is good.

Proof: We use the fact that for any set of numbers, it's bitwise OR is at least the maximum value in it. Now, we just need to show that any subarray of length len has at least one element greater than or equal to len. If the maximum element is <len, then, we have len elements all with values in the range [1,len−1]. By the pigeonhole principle, at least 2 of them must be the same contradicting the fact the it's a permutation.

Time Complexity: O(n)Code: 89479484

1391B - Fix YouThe answer is #R in the last column + #D in the last row.

It's obvious that we must change all Rs in the last column and all Ds in the last row. Otherwise, anything placed in those cells will move out of the grid. We claim that doing just this is enough to make the grid functional. Indeed, for any other cell, any luggage placed in it will eventually reach either the last row or the last column, from which it will move to the counter.

Time Complexity: O(n∗m)Code: 894796031391C - Cyclic PermutationsThe answer is n!−2n−1.

Consider an arbitrary cyclic permutation — for example, [4,2,3,1,5,6]; it contains many cycles of length 3: [1,2,3], [1,3,5], [3,4,5]. Note that all the listed cycles contain nodes obtained from just one choice of i. We can generalize this to the following. If for any i, we make edges on both sides of it, this will create a simple cycle of length 3. The proof is simple and is an exercise for you.

Thus, there has to at most one peak that is the element n– all acyclic permutations increase, then reach n, and, finally, decrease. These are formally called unimodal permutations, and it's easy to see that any unimodal permutation forms a tree, and, thus, contains no simple cycle  — each element, except n, has a uniquely defined parent.

We can construct any unimodal permutation by adding the numbers n,n−1,…,1 into a deque in the same order. For example, [2,3,4,1] can be constructed by first pushing 4, 3, 2 to the front, and, finally, 1 at the back. Thus, for every element, except n, we have the choice of pushing it to the front or the back, making the total number of ways equal to 2n−1.

Time Complexity: O(n)Also, thanks to shash42 for the construction using deque idea!Code: 89479612

1391D - 505Firstly, if min(n,m)>3, then, no solution exists because this means the grid contains at least one 4×4 sub-matrix, which can further be decomposed into four 2×2 sub-matrices. Since all four of these 2×2 sub-matrices are supposed to have an odd number of ones, the union of them will have an even number of ones.

The problem, now, reduces to changing the least number of cells such that every 2×2 sub-matrix has an odd number of ones — this is possible to achieve for every valid grid. For example, for every even-indexed row, alternate the cells, and for every odd-indexed row, make all cells equal to 1.

We will solve this reduction using dynamic programming.

We represent the ith column as a n-bit integer — ai; let dp(i,mask) be the minimum cells we have to flip to make the first i columns valid, and the ith column is represented by mask. The transition is quite simple:dp(i,cmask)=min(dp(i−1,pmask)+bitcount(cmask⊕a[i]),dp(i,cmask)).The term bitcount(cmask⊕a[i]) is equal to the number of positions where these two masks differ.

Please note that we only consider those pairs, {pmask,cmask}, that when put adjacent do not form a 2×2 sub-matrix with an even number of ones. To speed up the transition, they can be pre-calculated.

Time Complexity: O(m∗22n+n∗m)Code: 894796271391E - Pairs of PairsLet's build the DFS tree of the given graph, and let dep(u) denote the depth of node u in the tree.

If dep(u)≥⌈n2⌉ holds for any node u, we have found a path. Otherwise, the maximum depth is at most ⌊n2⌋, and we can find a valid pairing as follows:

For every depth i (1≤i≤⌊n2⌋), keep pairing nodes at this depth until 0 or 1 remain.Clearly, at most 1 node from each depth will remain unpaired, so, in total, we have paired at least n−⌊n2⌋=⌈n2⌉ nodes.

Finally, let's prove that every subgraph induced from some 2 pairs has at most 2 edges.

Consider 2 arbitrary pairs, (a,b) and (c,d), where dep(a)=dep(b) and dep(c)=dep(d). W.L.O.G, let dep(a)<dep(c).

Obviously, the edges (a,b) and (c,d) cannot exist because edges can only go from a descendant to an ancestor. We can, further, show that each of c and d can have an edge to at most one of a and b. For example, if c has an edge to both a and b, we can conclude that a and b are ancestor-descendants, which is not possible because both of them are at the same depth.

Time Complexity: O(n+m)Code: 89479649

Codeforces Round #662 Editorial

By AlFlen, history, 3 years ago, translation, In English1393A - Rainbow Dash, Fluttershy and Chess Coloring

Idea: AlFlen

Tutorial1393A - Rainbow Dash, Fluttershy and Chess ColoringBy modeling the game on different grids it was possible to notice that the answer is equal to ⌊n2⌋+1. You can prove that this is the answer by using induction method separately for grids with even and odd sides.

Initially it was asked to solve the problem for rectangular grids. You can think about this version of the problem.

Solution (74TrAkToR)1393B - Applejack and Storages

Idea: 74TrAkToR

Tutorial1393B - Applejack and StoragesLet's maintain the array cnti, in it we are going to store the number of planks for each length. Let's note that to be able to build a square and a rectangle we need to have four planks of the same length and also two pairs of planks of the same length. To check it we can maintain two values: sum2=∑105i=1⌊cnti2⌋ and sum4=∑105i=1⌊cnti4⌋. Then, you will be able to build a square and a rectangular storage if sum4≥1 and sum2≥4. The first constraint satisfies the requirement about a square (you should have ≥4 planks of some length), and the second constraint satisfies the requirement about a rectangle (two pairs of the same length should be used and also two pairs are already used in the square).

Solution (74TrAkToR)1393C - Pinkie Pie Eats Patty-cakes

Idea: 74TrAkToR и lapochka_queen

Tutorial1393C - Pinkie Pie Eats Patty-cakesLet's note that if you can find the arrangement with the maximum distance ≥X, then you can also find the arrangement with the maximum distance ≥X−1. It allows you to use the binary search on the answer.

To check that the answer is at least X, we can use the greedy algorithm. Each time let's use the element that we can use (we didn't use it on the last x−1 steps) and the number of the remaining elements equal to it is as large as possible. You can store the set of elements that you can use in the sorted by the number of appearances in std::set. This sol works O(nlog2n).

Also there is a solution in O(n).

Solution (AlFlen)1393D - Rarity and New Dress

Idea: 74TrAkToR

Tutorial1393D - Rarity and New DressLet's note that if there is a rhombus of size X in the cell (i,j), then there are also rhombuses with the smaller sizes.

Let's divide the rhombus into the left part and the right part. Let's solve the problem separately for both of them and then the answer for the cell is going to be equal to the minimum of these values.

Note that if the maximum size for the cell (i,j) is X, then the maximum size for the cell (i,j+1) is at most X+1 (and at most 1, if these two cells are not equal). Also the maximums size for the left part is at most minimum of the number of consecutive cells to the up and to left from the fixed cell.

To find the number of consective equal cells to the up, we will use the dynamic programming. If the cells (i,j) and (i−1,j) are equal, then the answer for the cell (i,j) is equal to the answer for the cell (i−1,j) plus 1, otherwise it is equal to 1. Similarly we can find the answer for the cells to the left.

Now we need to find the maximum size of the left part. We can use dynamic programming and calculate it accordingly to our observations.

Similarly for the right part.

The total complexity is O(nm).

Solution (74TrAkToR)1393E2 - Twilight and Ancient Scroll (harder version)

Idea: AlFlen

Tutorial1393E2 - Twilight and Ancient Scroll (harder version)Let's use dynamic programming. dp[i][j]: the number of ways to form the non-decreasing subsequence on the strings 1…i, s.t. the delete character in string i is j. This works in O(L3), where L is the total length of all strings.

Let's optimize this solution. For each string, sort all strings obtained by deleting at most one character from this string. You can do it in O(L2⋅logL) for all strings. Then you can use two pointers to calculate or dp. To calculate the answer for the layer i we will consider strings in the sorted order, and add all dp values for the smaller strings. We can calculate this dp in O(L2) and solve the problem in O(L2⋅logL). We can use binary search and hash to compare strings in O(logL). Then you can sort all the strings in O(L⋅log2L).

Note that you can sort the strings in O(L). Look at the string s. For each character find the first character to the right not equal to it (array nxt[i]). Then we will store two pointers: to the beginning and the end of the list. Consider characters in the order from left to right. If si > snxt[i], add i to the beginning of the list (to the position l and increase l by 1), otherwise add it to the end of the list (to the position r and decrease r by 1). Then add s to some position in the list (s will be in the list after it without the last character). Then you can use the hash to make the comparisons for two pointers in O(logL). This sol works in O(L⋅logL) and fits into TL.

Solution (74TrAkToR)

Codeforces Round #661 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishAll ideas belong to MikeMirzayanov.

1399A - Remove Smallest

Tutorial1399A - Remove SmallestFirstly, let's sort the initial array. Then it's obvious that the best way to remove elements is from smallest to biggest. And if there is at least one i such that 2≤i≤n and ai−ai−1>1 then the answer is "NO", because we have no way to remove ai−1. Otherwise, the answer is "YES".

Solution1399B - Gifts Fixing

Tutorial1399B - Gifts FixingAt first, consider the problems on candies and oranges independently. Then it's pretty obvious that for candies the optimal way is to decrease all ai to the value min(a) (we need obtain at least this value to equalize all the elements and there is no point to decrease elements further). The same works for the array b. Then, if we unite these two problems, we need to take the maximum moves we need for each i, because we need exactly that amount of moves to decrease ai to min(a) and bi to min(b) simultaneously.

So, the answer is ∑i=1nmax(ai−min(a),bi−min(b)).

Solution1399C - Boats Competition

Tutorial1399C - Boats CompetitionThis is just an implementation problem. Firstly, let's fix s (it can be in range [2;2n]), find the maximum number of boats we can obtain with this s and choose the maximum among all found values.

To find the number of pairs, let's iterate over the smallest weight in the team in range [1;⌊s+12⌋−1]. Let this weight be i. Then (because the sum of weights is s) the biggest weight is s−i. And the number of pairs we can obtain with such two weights and the total weight s is min(cnti,cnts−i), where cnti is the number of occurrences of i in w. And the additional case: if s is even, we need to add ⌊cnts22⌋. Don't forget that there is a case s−i>n, so you need to assume that these values cnt are zeros.

Solution1399D - Binary String To Subsequences

Tutorial1399D - Binary String To SubsequencesLet's iterate over all characters of s from left to right, maintaining two arrays pos0 and pos1, where pos0 stores indices of all subsequences which end with '0' and pos1 stores indices of all subsequences which end with '1'. If we met '0', then the best choice is to append it to some existing subsequence which ends with '1'. If there are no such sequences, we need to create new one which ends with '0'. Otherwise we need to convert one of '1'-sequences to '0'-sequence. The same works with characters '1'. So, when we don't need to create the new sequence, we try to don't do that. And values in arrays pos0 and pos1 help us to determine the number of sequence we assign to each character.

And also, there is a cute proof of this solution from Gassa: let f(i) be the difference between the number of '1' and the number of '0' on the prefix of s of length i. We claim that the answer is max(f(i))−min(f(i)) and let's show why is it true. Let's build a function on a plane with points (i,f(i)). Then we can match each x between min(f(i)) and max(f(i)) with some subsequence.

Solution1399E1 - Weights Division (easy version)

Tutorial1399E1 - Weights Division (easy version)Let's define cnti as the number of leaves in the subtree of the i-th edge (of course, in terms of vertices, in the subtree of the lower vertex of this edge). Values of cnt can be calculated with pretty standard and simple dfs and dynamic programming.

Then we can notice that our edges are independent and we can consider the initial answer (sum of weights of paths) as ∑i=1n−1wi⋅cnti. Let diff(i) be the difference between the current impact of the i-th edge and the impact of the i-th edge if we divide its weight by 2. diff(i)=wi⋅cnti−⌊wi2⌋⋅cnti. This value means how the sum of weights decreases if we divide the weight of the i-th edge by 2.

Create ordered set which contains pairs (diff(i),i). Then the following greedy solution works: let's take the edge with maximum diff(i) and divide its weight by 2. Then re-add it into the set with new value diff(i). When the sum becomes less than or equal to S, just stop and print the number of divisions we made.

The maximum number of operations can reach O(nlogw) so the solution complexity is O(nlogwlogn) (each operation takes O(logn) time because the size of the set is O(n)).

Solution1399E2 - Weights Division (hard version)

Tutorial1399E2 - Weights Division (hard version)Read the easy version editorial first, because almost all solution is the solution to the easy version with little changes.

Firstly, let's simulate the greedy process we used to solve the easy version problem, for edges with cost 1 and edges with cost 2, independently. But we don't stop when our sum reach something, let's simulate until our sum becomes 0 and store each intermediate result in the array v1 for edges with cost 1 and v2 for edges with cost 2. So, the array v1 contains the initial total impact of edges of cost 1, then the impact after making one move, two moves, and so on... The same with v2 but for edges with cost 2.

Now let's fix how many moves on edges with cost 1 we do. Let it be i (and arrays v1 and v2 are 0-indexed). Then the sum we obtain from the 1-cost edges is v1[i]. So we need to find the minimum number of moves p we can do on 2-cost edges so that v1[i]+v2[p]≤S. This can be done using binary search or moving pointer (if we iterate over i in increasing order, place p at the end of v2 and move it to the left while v1[i]+v2[p]≤S). Then, if v1[i]+v2[p]≤S, we can update the answer with the value i+2p.

Time complexity is actually the same as in easy version of the problem: O(nlogwlogn).

Solution1399F - Yet Another Segments Subset

Tutorial1399F - Yet Another Segments SubsetFirstly, let's compress the given borders of segments (just renumerate them in such a way that the maximum value is the minimum possible and the relative order of integers doesn't change). Pretty standard approach.

Now let's do recursive dynamic programming dpl,r. This state stores the answer for the segment [l;r] (not necessarily input segment!). How about transitions? Firstly, if there is a segment covering the whole segment [l;r], why don't just take it? It doesn't change anything for us. The first transition is just skip the current left border and try to take the additional answer from the state dpl+1,r. The second transition is the following: let's iterate over all possible segments starting at l (we can store all right borders of such segments in some array rgl). Let the current segment be [l;nr]. If nr≥r, just skip it (if nr>r then we can't take this segment into the answer because it's out of [l;r], and if nr=r then we can't take it because we considered it already). Then we can take two additional answers: from dpl,nr and from dpnr+1,r. Don't forger about some corner cases, like when nr+1>r or l+1>r and something like that.

You can get the answer if you run the calculation from the whole segment.

What is the time complexity of this solution? We obviously have O(n2) states. And the number of transitions is also pretty easy to calculate. Let's fix some right border r. For this right border, we consider O(n) segments in total. Summing up, we get O(n2) transitions. So the time complexity is O(n2).

P.S. I am sorry about pretty tight ML (yeah, I saw Geothermal got some memory issues because of using map). I really wanted to make it 512MB but just forgot to do that.

Solution

Codeforces Round #660 Editorial

By Karavaiev, history, 3 years ago, In English1388A - Captain Flint and Crew Recruitment

Idea: Denisov

Tutorial1388A - Captain Flint and Crew RecruitmentConsider the three smallest nearly prime numbers: 6,10 and 14:

if n≤30=6+10+14, then the answer is NO.otherwise the answer is YES.The easiest way is to display 6,10,14,n−30 in cases where n−30≠6,10,14.

If n=36,40,44, then we can output 6,10,15,n−31.

In addition, it was possible to generate the first nearly prime numbers and iterate over all their possible triplets.

Complexity: O(1) or more if brute-force is written.

Solution (Karavaev1101)1388B - Captain Flint and a Long Voyage

Idea: Karavaiev

Tutorial1388B - Captain Flint and a Long VoyageStatement: x consists of digits 8−9.

This is so, because if x contains digits 0−7, which in their binary notation are shorter than digits 8−9, then the number k written on the board, and therefore the number r (obtained by removing the last n digits of the number k) will be shorter than if you use only the digits 8 and 9, which means it will not be the maximum possible.

Statement: x is 99…988…8.

Obviously, the more x, the more k and r. Therefore, to maximize k, x must be 99…999. However, due to the fact that r is k without the last n digits, at the end of the number x it is possible to replace a certain number of 9 digits with 8 so that r will still be the maximum possible.

Statement: the number of digits 8 in the number x of length n is equal to ⌈n4⌉.

810=10002 and 910=10012. We can see that the binary notations of the digits 8 and 9 are 4 long and differ in the last digit.

Suppose the suffix of a number x consists of p digits 8. Then the maximum r is achieved if at least 4⋅p−3 digits are removed from the end of k. By the condition of the problem, exactly n digits are removed, which means 4⋅p−3≤n and then p=⌊n+34⌋=⌈n4⌉.

Complexity: O(n).

Solution (Karavaev1101)1388C - Uncle Bogdan and Country Happiness

Idea: Karavaiev

Tutorial1388C - Uncle Bogdan and Country HappinessFor each city v count av — how many people will visit it. Knowing this value and the value of the level of happiness — hv, we can calculate how many people visited the city in a good mood: gv=av+hv2.

We can single out the 3 criterions for the correctness of the values of the happiness indices:

av+hv is a multiple of 2. For each v, gv — an integer.0≤gv≤av. In each city v the number of residents who passed this city in a good mood — a non-negative number not exceeding av.gto1+gto2+…+gtok≤gv, where to1, to2, …, tok are the cities where the resident can move out of the city v on the way home. This follows from the fact that the mood of the inhabitants can be deteriorated and cannot be improved.This is enough, since these conditions guarantee the correctness of the happiness indices by definition, as well as the peculiarities of changes in the mood of residents.

Solution (Karavaev1101)1388D - Captain Flint and Treasure

Idea: Denisov

Tutorial1388D - Captain Flint and TreasureLet's construct a graph G with n vertices and directed edges (i;bi).

Note that it is not profitable to process the vertex i if the vertices j, for which bj=i, have not yet been processed, since it is possible to process these vertices j so that they will not decrease ai.

We will do the following operation n times:

Choose a vertex V which does not contain any edge (there is always such a vertex due to an additional condition in the problem). Let's process it as follows:

if aV>0, then apply the operation from the condition to this vertex. This is beneficial because if bv≠−1 then we will improve the value of abV.if aV≤0, then the value of abV will not improve, which means that it is profitable to apply the operation to the vertex V after bV (if bV≠−1).Let's remember when to process the V vertex and then remove it from the graph.Let's store two containers now and after. In now we store the order of processing of vertices for which aV>0. In after - for which aV≤0. Then let's notice that the order now+reverse(after) is appropriate to achieve the maximum answer.

Total O(n) or O(n⋅log(n)) depending on the implementation.

Solution (Denisov)Solution (Karavaev1101)1388E - Uncle Bogdan and Projections

Idea: perekopskiy

Tutorial1388E - Uncle Bogdan and ProjectionsIt is easy to understand that there is an optimal vector at which the value we need is minimal and at least one pair of projections is touching. Note also that the vector is completely described by the angle between it and the positive direction of the OX axis. If two line segments are at different heights, then there are two ways to select a vector so that their projections touch. Let's find two angles that describe these vectors. If we project along a vector with an angle that is in the interval that the found two angles form, then the projections will intersect. So, this range of angles is 'forbidden'. Using the scanline method, we can find such angles that they are the boundaries of some 'forbidden' interval and do not fall into any 'forbidden' interval. Then we only need to check these angles.

We also need to quickly find the rightmost and leftmost points for each angle. Let's take two points at different heights. Let them project to one point with a vector with an angle α. Then on the interval (0∘;α) the upper one will be to the right, and on the interval (α;180∘) the upper one will be to the left. We will process two types of requests using the scanning line:

Check the answer for the current angle;Swap two points. It is necessary to carefully handle the case when, at some angle, several points are swapped.Alternative way: if you project the point (x;y) along the vector with the angle α, you get the point (x+y∗ctg( alpha);0). We'll use the Convex Hull Trick to quickly find the rightmost and leftmost points for each angle. We will store CHT for maximums and minimums with lines k=yi,b=xi. Queries at ctg(α) will give us the leftmost and rightmost points.

It is a corner case if all points are at the same height. Then the answer is max(xri)−min(xli).

Complexity of solution - O(n2log(n)).

Solution (perekopskiy)

Codeforces Round #659 Editorial

By dcordb, 3 years ago, In EnglishWe (the setters) hope you liked the problems. Here is the editorial:

1384A - Common PrefixesThe problem asks to find n+1 strings such that LCP(si,si+1)=ai for all i (1≤i≤n). A way to solve this problem is the following:

Set s1= "aaaa...aaaaaaa" (ie. 200 times 'a').For i such that (1≤i≤n) set si+1:=si and then flip (ai+1)-th character of si+1 (ie. if it was 'a' put 'b' otherwise 'a').So for each i:

si and si+1 will have exactly ai common characters from the prefix.The (ai+1)-th character of si+1 is different than (ai+1)-th character of si (this character always exists since 0≤ai≤50 and each string has length exactly 200).Therefore the LCP is ai as desired.

Time complexity: O(n) per testcase

C++ solutionPython solutionProblem idea: dcordb

Solution idea: dcordb and Devil

1384B1 - Koa and the Beach (Easy Version)For this version you can just simulate each possible action of Koa.

Let (pos,tide,down) a state where pos is the current position of Koa (ie 0 is the shore, from 1 to n is the i-th meter of sea and n+1 is the island), tide is the current increment of the tide, and down is a boolean that is true if the tide is decreasing and false otherwise.

You can see each state like a node and each action (ie. wait or swim) like an edge, so you can just do a dfs to see if the island is reachable from the shore.

The number of nodes and edges is O(n⋅k).

Time complexity: O(n⋅k) per testcase

C++ solutionProblem idea: Devil

Solution idea: Devil

1384B2 - Koa and the Beach (Hard Version)Let's define positions i such that (1≤i≤n) and di+k≤l as safe positions, also positions 0 and n+1 are safe too (ie. the shore and the island respectively). Remaining positions are unsafe.

Koa can wait indefinitely on safe positions without drowning, so she can reach the island (ie. position n+1) if and only if she can reach each safe position from the previous one.

Suppose Koa is at some safe position i and wants to reach the next safe position j (0≤i<j≤n+1):

A solution strategy for Koa is the following:

If Koa is at an unsafe position x at time t0, she must swim to x+1 as soon as she can, that is, at the first moment of time t≥t0 such that dx+1+p[(t+1)mod2k]≤l (to not drown).If Koa is at a safe position x at time t0, she must wait to some moment of time t1 such that tide is exactly at k units. After that she must follow the unsafe positions strategy until the next safe position.So a way to go from i to j would be, apply point 2 on i, and apply point 1 to reach each position p such that (i<p≤j).

This works because:

If there exists some position with dp greater than l she would drown with any tide so let's assume that all positions are less or equal to l.Suppose Koa drowns at some position p, she can leave i with some value of tide because di+1≤l and as long as the tide is decreasing whether she chooses to wait or not she would be safe. So she must have drown with the tide increasing.If she leaves i with other tide (different from k): suppose she would be able to reach position p, then the tide will have increased and it will be higher and therefore she would drown too, this is true because the tide never can be k and start decreasing again between i and j because these positions are unsafe ones.Time complexity: O(n) per test case

C++ solutionProblem idea: Devil

Solution idea: Devil

1383A - String Transformation 1First of all, if there exists some i such that Ai>Bi there isn't a solution.

Otherwise, create a graph where every character is a node, and put a directed edge between node u and node v if character u must be transformed into character v (ie. from Ai to Bi for all i). We must select a list with minimum number of operations such that if there is an edge from node u to node v, then it must exist a subsequence of the operations in the list that transforms u into v.

Each weakly connected component C can be solved independently and the answer for each component is |C|−1. So total answer is |ALP|−k where k is the number of weakly connected components in the graph.

Proof:

Each weakly connected component C requires at least |C|−1 operations (because they are connected). Since there are no cycles in the graph a topological order exists. Find one and select each pair of consecutive nodes in this order as the list of operations.

Time complexity: O(|A|+|B|+|ALP|) per test case where |ALP|=20 denotes size of alphabet

C++ solutionProblem idea: Devil

Solution idea: mnaeraxr and Devil

1383B - GameGameLet x be the number of ones and y be the numbers of zeros in the most significant bit of the numbers:

if x is even, whatever decision players take, both will end with the same score in that bit, so go to the next bit (if it doesn't exist the game ends in a draw). Indeed, the parity of the result of both players will be the same, since x is even.if x is odd, one of the players ends with 0 in this bit and the other with 1, the player with 1 in this bit wins the game because the well know inequality 2k>∑i=0k−12i for k≥1, so the game is equivalent to play on an array of x ones and y zeros.Lemma: The second player wins iff xmod4=3 and ymod2=0 otherwise the first player wins.

Proof: We know that xmod2=1 so xmod4 can be 1 or 3

if xmod4=1 the first player can choose one 1 and the remaining number of 1 is a multiple of 4, if the first player always repeats the last move of the second player (if ymod2=1 and the second player takes the last 0 both players start taking all the remaining ones), then both ends with the same number of ones which divided by 2 is even and therefore the first player wins.if xmod4=3if ymod2=0 the second player can repeat the last move of the first player always so the first ends with a even numbers of 1 and therefore the second player wins.if ymod2=1 the first player takes one 0 and the game now is exactly the previous case with the first player as the second player.Time complexity: O(n) per testcase

C++ solutionPython solutionProblem idea: Devil

Solution idea: Devil and dcordb

1383C - String Transformation 2The only difference between this problem and the previous problem is that the underlying graph might have cycles.

Each weakly connected component can be solved independently and the answer is 2⋅n−|LDAG|−1 where n is the number of nodes in the component and |LDAG| is the size of the largest Directed Acyclic Graph.

The largest directed acyclic graph can be computed using dynamic programming in O(2n⋅n).

For every node u store a mask reach[u] with all nodes it can reach directly. Then go through every possible mask from 1 to 2n−1 and check whether this set of nodes is acyclic or not. It is acyclic if there exists at least one node u (the last node in one topological order) such that the set without this node is acyclic and this node doesn't reach any other node in this set:

is_dag[0] = 1for mask in 1..2^n-1   for u in mask:      is_dag[mask] |= is_dag[mask ^ (1 « u)] && ((mask & reach[u]) == 0))Proof by @eatmore:

Lemma 1: Suppose that there is a weakly connected component with n vertices, and there is a solution with k edges. Then, the size of the largest DAG is at least 2⋅n−1−k.

Proof: Let's keep track of current weakly connected components. Also, in each of the components, let's keep track of some DAG. Initially, each vertex is in a separate component, and each DAG consists of a single vertex. So, there are n components, and the total size of all DAGs is n.

Processing an edge (u,v):

If u and v are in the same component: if v is in the DAG, remove it. Number of components is unchanged, the total size of all DAGs is decreased by at most 1.If u and v are in different components, join the components. Concatenate the DAGs (DAG of u's component comes before DAG of v's component). Number of components decreases by 1, the total size of all DAGs is unchanged.At the end, the number of components becomes 1, so n−1 edges are used to decrease the number of components. The remaining k−n+1 edges could decrease the size of DAGs, so the final size is at least n−(k−n+1)=2⋅n−1−k.

From lemma 1 we know that k>=2⋅n−1−|DAG|, then k is minimized when the size of the final DAG is maximized.

Time complexity: O(|A|+|B|+2n⋅n) per test case

C++ solutionProblem idea: Devil

Solution idea: mnaeraxr

1383D - RearrangeLet A be a matrix of size n⋅m that is formed by a permutation of elements from 1 to n⋅m. Find the maximum element on each row and column (i.e. the spectrum)

Now we are going to build the answer adding numbers one by one in decreasing order. We start with an empty 2 dimensional matrix (both dimensions have length 0) and at the end of each iteration the following invariants will be maintained on the matrix:

All elements processed are inside of the matrix.Each row and column is bitonic.The horizontal/vertical spectrum of this matrix is a subset of the expected horizontal/vertical spectrum.In addition we are keeping a queue with all positions in the matrix that doesn't contain any element yet. At the end of each iteration the following invariants will be maintained on the queue:

Let A be a position on the queue and B a position that contains a value that belongs to the horizontal spectrum in the matrix such that A and B are in the same row, then all positions between A and B have already an element in the matrix or occur in the queue before A.Let A be a position on the queue and B a position that contains a value that belongs to the vertical spectrum in the matrix such that A and B are in the same column, then all positions between A and B have already an element in the matrix or occur in the queue before A.

M := int[0][0]Queue := new Queue()// sides of the matrixx, y = 0, 0 

for num in n * m .. 1	if num belongs to the horizontal spectrum		// Add one row full of 0 in the bottom of the matrix		X += 1

	if num belongs to the vertical spectrum		// Add one column full of 0 in the right of the matrix		Y += 1

	if num belongs either to the horizontal or to the vertical spectrum:		// Put num in the bottom rightmost position of the matrix.		M[x][y] = num	else:		ax, ay = pop element from Queue		M[ax][ay] = num

	if num belongs to the horizontal spectrum		// Add all positions in the last row (but the last one) to the Queue from right to left		for py in y - 1 .. 1			Queue.add(x, py)

	if num belongs to the vertical spectrum:		// Add all positions in the last column (but the last one) to the Queue from bottom to top.		for px in X - 1 .. 1 			Queue.add(px, y)In the end, invariants on the matrix guarantee that all elements are placed, each row and column consist in a bitonic sequence as required and the spectrums are equal to the expected spectrums.

Let's prove each invariant on the matrix is kept:

Clearly on each step a different element is placed on the matrix on an empty position, we should only show that the operation pop element from Queue doesn't fail with Queue empty. Say the current element is t, so the matrix is filled with elements larger than t. Now we know that in original matrix there were at least n−x rows with maximums less than t and at least m-y columns with maximums less than t, so there could be at most x⋅y elements greater or equal than t but there are x⋅y+1 already.On each row and column the first element added is the maximum and then elements are added in each direction starting from it toward each edge, since elements are processed from largest to smallest then each row and column is bitonic.The first element added on each row and column is the maximum, and we only add it if it is part of the expected spectrum.Time complexity: O(n⋅m)C++ solutionProblem idea: gilcu3

Solution idea: gilcu3 and mnaeraxr

1383E - Strange OperationFirstly the described operation can be seen as divide s in sub-strings and take the bitwise or in each one. For each possible resultant string w let's think in the following way of obtain it from s:

Suppose we already have a 1 in w in previous steps (if not it can be handled later) and we used the firsts i characters of s to get the firsts j characters of w.

if the (j+1)-th character in w is 1, find the next 1 in s, (ie first i′>i such that si′=1), merge everything between the last 1 and i′−1 and take the new 1.if the (j+1)-th character in w is 0, and we have k zeros after the last 1 in w find the next block of k+1 zeros in s, (ie first i′>i such that for each (0≤k′≤k) si′−k′=0), if i′ is equal to i+1 just append the new 0 to w otherwise merge everything between the last 1 and i′−k and take the new zeros from i′−k+1 to i′.We can prove that in this way every possible resultant string w is generated in a unique way and it uses the minimum number of characters from s to obtain w.

So we can start thinking about dynamic programming keeping in mind this greedy.

Let dp(i) be the number of strings that we can obtain using the last n−i characters from s, the transitions are the previous described two cases, taking care of the case of ending with certain numbers of 0.

Therefore:

If there is at least a 1 in s, let i be the first position such that si=1, answer equals dp(i)⋅i (because we start assuming that there exists some previous 1 and before this 1 there are exactly i possibilities: empty, one 0, two 0s, ..., i−1 0s).Otherwise answer is |s| (because s consists of all 0).Time complexity: O(n)C++ solutionProblem idea: Devil

Solution idea: Devil and antontrygubO_o

1383F - Special EdgesFinding maximum flow from 1 to n is equivalent to find the minimum cut from 1 to n. Let's use the later interpretation to solve the problem.

Suppose there is a single special edge (k=1), on each query there are two options, either this edge belong to the minimum cut or it doesn't. If the edge doesn't belong to the minimum cut, the value of the cut won't change even if we increase the capacity of each edge arbitrarily (let's say to ∞). On the other hand, if the edge belong to the cut, then the value of the cut will be equal to the capacity of the edge + the value of the cut if the capacity of the edge was 0. With this in mind we can compute each query in O(1).

Let MC0 be the value of the minimum cut if the capacity of the special edge is 0, and MC∞ be the value of the minimum cut if the capacity of the special edge is ∞. Then for each query ci the minimum cut will be equal to min(MC∞,MC0+ci).

We can generalize this ideas to multiple edges in the following way. For each subset of special edges, they either belong to the minimum cut, or they don't. If we fix a subset S and say those are among the special edges the only ones that belong to the minimum cut, then the value of the cut will be equal to the sum of the values of the capacities of these edges plus the minimum cut in the graph were each of these edges has capacity 0 and other special edges has capacity ∞. In a similar way as we did for the case of k=1 we can pre-compute 2k cuts, fixing S as each possible set in O(2k⋅max_flow(n,m)), and then answer each query in O(2k). The overall complexity of this solution will be O(2k⋅max_flow(n,m)+q⋅2k).

However the preprocessing can be done faster. If we have the maximum flow (and the residual network) for a mask, we can compute the maximum flow adding one new edge in O(w∗m), doing at most w steps of augmentation as done by Ford-Fulkerson algorithm. To remove an edge we just store the residual network before augmenting, in such a way that we can undo the last change. The time complexity of the preprocessing will be O(max_flow(n,m)+2k⋅w⋅m) and since we need to be able to undo the last operation spatial complexity will be O(k⋅m).

It was possible to solve the problem without the last trick, but it was not guaranteed that slow flows implementations would work in O(2k⋅max_flow(n,m)).

C++ solutionProblem idea: mnaeraxr

Solution idea: mnaeraxr and Devil

Codeforces Round #658 Editorial

By Monogon, history, 3 years ago, In EnglishI hope you enjoyed the contest! I will add implementations later.

UPD I've added implementations.

1382A - Common Subsequence

Tutorial1382A - Common SubsequenceIf there is any common subsequence, then there is a common element of a and b. And a common element is also a common subsequence of length 1. Therefore, we need only find a common element of the two arrays, or say that they share no elements.

Complexity is

O(nm) if we compare each pair of elements,O((n+m)log(n+m)) if we sort the arrays and take their intersection, or use a set data structure, orO(n+m) if we use a hash table.Implementation

1382B - Sequential Nim

Tutorial1382B - Sequential NimSuppose a1>1. If removing the entire first pile is winning, player 1 will do that. Otherwise, player 1 can leave exactly one stone in the first pile, forcing player 2 to remove it, leaving player 1 in the winning position. Otherwise, if a1=1, then it is forced to remove the first pile.

So, whichever player gets the first pile with more than one stone wins. That is, let k be the maximum number such that a1=⋯=ak=1. If k is even, the first player will win. Otherwise, the second player will win. The only exception is when all piles have exactly 1 stone. In that case, the first player wins when k is odd.

Complexity is O(n).

Implementation

1382C1 - Prefix Flip (Easy Version)

Tutorial1382C1 - Prefix Flip (Easy Version)The easy version has two main solutions:

Solution 1: O(n) time with 3n operations

The idea is to fix the bits one-by-one. That is, make s1=t1, then make s2=t2, etc. To fix the bit i (when si≠ti), we can flip the prefix of length i, then flip the prefix of length 1, and again flip the prefix of length i. These three operations do not change any other bits in s, so it's simple to implement in O(n). Since we use 3 operations per bit, we use at most 3n operations overall.

Solution 2: O(n2) time with 2n operations

In this solution, we take a similar approach to solution 1, in that we fix the bits one-by-one. This time, we will fix the bits in reverse order. To fix the bit i, we can either flip the prefix of length i, or flip the first bit and then flip the prefix of length i. Since we do this in reverse order, the previously fixed bits do not get messed up by this procedure. And we use at most 2 operations per bit, so 2n operations overall.

However, we do have to simulate the operations in order to check if we should flip the first bit. Simulating an operation can easily be done in O(n) time per operation, or O(n2) time to simulate all operations.

Implementation 1 Implementation 2

1382C2 - Prefix Flip (Hard Version)

Tutorial1382C2 - Prefix Flip (Hard Version)There are several ways to solve the hard version as well.

Solution 1

Given an arbitrary binary string s, we can make all bits 0 in at most n operations. Simply scan the string from left to right. If bits i and i+1 disagree, apply the operation to the prefix of length i. This is also easy to simulate in O(n) time.

We can make s all zeros in at most n operations, and we can make t all zeros in at most n operations. By reversing the order of the operations on t, we have transformed s into t in at most 2n operations, as desired.

Solution 2

Another approach is to optimize the simulation for solution 2 from the easy version. You can do this with a data structure such as a balanced binary search tree in O(nlogn) time, but there is no need.

Instead, we can observe that after making the last k bits correct with our procedure, the prefix of s of length n−k will correspond to some segment of the original string s, except it will be possibly flipped (inverted and reversed). So, we need only keep track of the starting index of this segment, and a flag for whether it is flipped. Complexity is O(n).

Solution 3

A third solution uses randomization to improve the number of operations from 3n in solution 1 of the easy version. We can observe that in a random test case, approximately half the bits of s will be mismatches with t. Solution 1 in the easy version uses 3 operations per mismatch, which is 3n/2 operations in expectation. Obviously, you don't get to decide that all test cases are random. But you can spend a small number of operations initially, flipping random prefixes to make the string more random. If it doesn't work, you can try again repeatedly.

Flipping random prefixes is a complicated process that might be hard to compute the exact probability. But if the probability is p, and we try to flip k prefixes randomly, the time complexity is O((k+1)n)logp.

If you find a deterministic solution with a strictly lower ratio than 2 operations per bit, we would love to hear about it!

Implementation 1 Implementation 2

1382D - Unmerge

Tutorial1382D - UnmergeConsider the maximum element 2n of p. Assume without loss of generality that it comes from array a. Then the merge algorithm will exhaust array b before it takes the element 2n. Therefore, if 2n appears at index i in p, the entire suffix of p beginning at index i must be a contiguous block in one of the arrays a or b.

Then if we ignore this suffix of p, we should determine if the prefix of p can be the merge of two arrays of certain sizes. We can repeat the same argument, as the maximum remaining element also corresponds to a contiguous block.

Taking this argument all the way, consider all indices i where pi is greater than all elements that come before. This gives us all the lengths of the contiguous blocks, and we should determine if a subset of them add up to n. We've shown this condition is necessary. It is also sufficient because if we assign the blocks to a and b accordingly, the merge algorithm works correctly.

Now, this is just a subset-sum problem. The standard subset-sum DP approach takes O(n2) time, which is good enough.

It's also possible to do O(nn−−√) by using the fact that sum of values is 2n (as they are the lengths of disjoint blocks), meaning there are only O(n−−√) distinct values.

Implementation

1382E - Mastermind

Tutorial1382E - MastermindSuppose we have already decided which x indices agree on color. We should shuffle the remaining n−x indices in a way that minimizes the number of matches. We should also replace n−y indices with a color that doesn't contribute to the multiset intersection. Because there are n+1>n colors, there is some color c that doesn't appear in a, and we can use it to fill these n−y indices. Assuming that n−y is greater than or equal to the minimum number of excess matches we're forced to make, we have a solution.

Let f be the number of occurrences of the most frequent color in the n−x indices. Then the number of forced matches is clearly at least 2f−(n−x). And it can be achieved as follows. Let's reindex so that we have contiguous blocks of the same color. Then rotate everything by ⌊n−x2⌋ indices.

Now we need to decide on the x indices that minimize f. This can be done simply by always choosing the most frequent color remaining. We can do this with a priority queue in O(nlogn), or O(n) with counting sort.

To make the solution clearer, let's see how it works on the sixth test case in the sample: [3,3,2,1,1,1] with x=2,y=4. First, we greedily choose the most frequent color two times: [3,_,_,1,_,_]. After choosing 1 the first time, there is a tie between 1 and 3. So alternatively, we could choose the color 1 twice.

Then the remaining indices have colors 3,2,1,1. Rotating by (n−x)/2=2 indices, we can place the colors as 1,1,2,3 to get [3,1,1,1,2,3]. The color 4 does not appear in a, so we should fill n−y=2 indices with 4. (But not where we already forced a match.) For example, we get the solution [3,4,1,1,4,3].

Implementation

1381D - The Majestic Brown Tree Snake

Tutorial1381D - The Majestic Brown Tree SnakeLet the length of the snake be L.

Let's call a node p a "pivot" if there exist three edge-disjoint paths of length L extending from p. Clearly, if one of the snake's endpoints (head or tail) can reach a pivot, then the snake can rotate through these 3 paths, reversing itself. I claim two things:

If a snake's endpoint can reach some pivot, then it can reach all pivots.If a snake's endpoint cannot reach a pivot, the snake cannot reverse itself.Let's prove claim 1. Say there are two pivots p1 and p2, and a snake's endpoint can reach p1. At most one edge from p1 is on the path between p1 and p2. So let's put the snake in one of the other branches of p1. Then we can move the snake back through p1 and on the path to p2.

Let's prove claim 2. Consider the longest path in the tree. If it is impossible for the snake to enter this path, we may delete the path without changing the possible snake positions, so we apply induction on the smaller tree. Otherwise, if the snake can enter the path, we can show that it can never leave. (And therefore, it is also initially in the path, because snake moves are reversible.)

Assume for contradiction that the snake can leave the path. Then in its last move leaving the path, it occupies a length L path from a node in the longest path. And because we said it was the longest path, both of those branches must have length at least L as well. But then the snake's endpoint is at a pivot, giving us a contradiction. This completes the proof of claim 2.

Solution 1

Now that we understand claims 1 and 2, how can we use them? First, we can detect if any node is a pivot using DP to find the longest 3 paths from each node. If a pivot does not exist, we output NO. Otherwise, root the tree at the pivot p.

Let's move the snake back and forth in a greedy fashion like this: Move the head to the deepest leaf it can reach. Then move the tail to the deepest leaf it can reach. And repeat. If at any point, one endpoint becomes an ancestor of the other, we can move the snake up to p. Otherwise, if no more progress can be made (progress is determined by the smallest reachable depth of an endpoint), then the snake cannot reverse itself. Clearly, the snake can only go back and forth O(n) times before progress stops.

We can simulate the back-and-forth motion by answering k-th ancestor queries with binary lifting. Complexity is O(nlogn).

Solution 2

It's also possible to achieve O(n) with two pointers. Consider the path of nodes initially occupied by the snake, numbered from 1 to L. Each node has a subtree of non-snake nodes. Let ai be the height of the non-snake subtree of node i. We can maintain two pointers ℓ and r, where ℓ is the maximum achievable index of the head, and r is the minimum achievable index of the tail.

We do a similar back-and-forth motion as in solution 1. Send the head to the node that minimizes r, then send the tail to the node that maximizes ℓ, and repeat. The snake can reverse itself if and only if a pivot exists and ℓ,r can swap places.

Bonus: Can you prove that the number of times the snake must switch between moving the head and tail is O(n−−√)?

Implementation

1381E - Origami

Tutorial1381E - OrigamiFirst, let's imagine the problem in one dimension. And let's see how the length of the folded segment changes as we sweep the fold line from left to right.

If the fold line is to the left of the paper, it's just the length of the segment. Then as the fold line enters the left side of the paper, we subtract the length of paper to the left of the fold line, since it gets folded onto the right half. Then as the fold line passes the midpoint of the segment, we should add back the length we passed after the midpoint, since the left half gets folded past the right end of the paper. Finally, after the line exits the paper, the answer stays constant again.

Now let's advance to the two-dimensional setting. Imagine the process described above applied to all horizontal segments of the polygon simultaneously. We see that the answer is the integral of the answers for all the segments.

Now, let's split the polygon into two halves by the midpoints of each horizontal segment. For a fold line, the answer is the total area, minus the area left of the sweep line belonging to the first polygon, plus the area left of the sweep line belonging to the second polygon.

We can sort all line segments and queries, and answer all queries in a sweep line. To simplify the process, it helps to know the standard algorithm to compute the area of a polygon by considering a trapezoid for each line segment and combining their areas with inclusion-exclusion.

Essentially, we have to sweep the integral of a piecewise linear function.

Complexity is O((n+q)log(n+q)).

Implementation

Codeforces Round #657 Editorial

By ch_egor, 3 years ago, translation, In EnglishThanks for the participation!

1379A - Acacius and String was authored by ch_egor, meshanya and prepared by ch_egor, vintage_Vlad_Makeev

1379B - Dubious Cyrpto was authored by jury and prepared by DebNatkh

1379C - Choosing flowers was authored and prepared by grphil

1379D - New Passenger Trams was authored by Helen Andreeva and prepared by KiKoS

1379E - Inverse Genealogy was authored and prepared by voidmax and I_love_myself

1379F2 - Chess Strikes Back (hard version) was authored by 300iq and prepared by isaf27

1379A - Acacius and StringAt first, we will check if some string of length n contains exactly one occurrence of "abacaba".

Lemma 1. This check can be done in O(n) time.

Proof. We can try all the possible positions i of a string s and check whether i is a starting position for a substring "abacaba". This check can be performed in a O(1) time by checking if si+j=tj for all j∈[0;6] where string t is "abacaba". So, overall complexity of such a check works in n⋅O(1)=O(n) time.

To solve the problem we will iterate over all positions i and check whether there exists a valid string such that its single occurrence of a substring "abacaba" starts from position i. String s has a single occurrence i of a substring "abacaba" if and only if two following criteria are satisfied.

i is a occurrence of a substring "abacaba" in s.There are no occurrence j of a substring "abacaba" in s such that i≠j.First criterion can be checked directly. i can be an occurrence of a substring "abacaba" in a resulting string if and only if for all j∈[0;6] si+j=tj or si+j=′?′.

To check the second criterion we need the following lemma.

Lemma 2. Question marks in string s can be replaced with lowercase English letters in such a way that no new occurrences of "abacaba" will appear.

Proof. Let's replace all the questing marks with "z" letter. Any substring of s that contained question mark will not become a occurrence of "abacaba" since "abacaba" does not contain "z".

So after fixing position of a single occurrence i resulting string can be constructed directly.

This leads to a O(n2) solution. Refer to author's solution code for more details.

vintage_Vlad_Makeev code1379B - Dubious CyrptoThe task is to solve equation n⋅a+b−c=m in integers, where n — is some natural number, and a,b,c∈[l;r]. Note that the expression b−c can take any value from [l−r;r−l] and only these values. Indeed, if 0≤x≤r−l, then if we denote b=x+l, c=l, we get b−c=x. A similar statement is true for l−r≤x≤0.

So, since it was necessary to solve the equation n⋅a+b−c=m, this is equivalent to solving the equation n⋅a∈[m−(r−l);m+(r−l)], where a∈[l;r], n∈N. Let's fix some arbitrary a. Then we find the maximum n for which n⋅a≤m+(r−l) — this n will be equal to n′=⌊m+r−la⌋. Let's check whether it is true that n′>0 and n′⋅a∈[m−(r−l);m+(r−l)]. If this is the case, then restore b and c as indicated above.

This solution iterates over all possible values of a, and checks if such a can be used in answer if the manner described above. Thus, this solution has complexity O(r−l)1379C - Choosing flowersLet's look at sorts, for which there is more than one flower in the bouquet. We can prove, that there can be only one such sort. Let's assume that there are sorts x and y with bx≥by, such that for both sorts there are at least 2 flowers. Let's exclude flower of sort y from bouquet and add flower of sort x. The total happiness will change by bx−by, so it will not decrease. Repeating this, we can leave bouquet with only one flower of sort y without decreasing the total happiness. So, there always exists an answer where there is only one sort with multiple flowers.

Using this fact, we can solve the problem the following way. Let's iterate over each sort of flowers and for every x suppose that there are multiple flowers of sort x. It is obvious, that if some sort y has ay>bx, then we should take one flower of such sort, and if ay≤bx, then we would better take another flower of sort x. So, we need to know sum of ai for all flowers that have ai>bx. To do it in O(logm), we can sort all flowers by ay in decreasing order, calculate prefix sums on that array, and using binary search find maximum k, such that ak>bx and get prefix sum of ai for first k sorts. All the rest n−k flowers will be of the sort x.

Also we should take into account the case when for each sort only one flower of that sort is taken. In that case we should take n sorts with largest ai.

That way we can get the answer in O(mlogm) time.

1379D - New Passenger TramsLet's look what happens if we fix t for answer. Start time leads to canceling every train, which has mi in one of ranges [t−k+1,t−1], [t+m2−k+1,t+m2−1]. Some borders may be either negative or greater than m, but values must be count modulo m. We may imagine them as segments on a circle with length m.

Now let's look at every train. If train departs at mi then it must be canceled if we choose t in segments [mi+1,mi+k−1], [mi+m2+1,mi+m2+k−1]. Otherwise it shouldn't be canceled. So, we need to find such point t in [0,m2−1], that t is covered by minimal number of segments.

Note that we block two simmetrical segments — difference between their borders is equal to half of circle's length. Cause we need only segments in first half of the cycle, we can look at these segments modulo m2, where they collapse into one segment.

Now we need to sort segment's borders. Segments are placed on circle, so some of them should be split in two — one ends in m2−1, another starts at 0. Now we need to find point, which is covered by minimal number of segments. For that we will keep a variable counting current number of open segments, and change it from one coordinate to another. We can skip coordinates with no events on them, so all solution will take O(nlogn) time to solve.

1379E - Inverse GenealogyLet's rephrase the statement. Critical node — a non-leaf node with subtrees, where one 2 or more times smaller than another. We need to find an example of the binary tree with n nodes there k of them are critical.

First of all, let's count number of nodes if we know that there m leafs. Because of the fact, that tree is binary, size of the tree should be 2m−1. So for even n there is no answer.

A number of critical nodes can't be more than max(0,n−32). It is obvious that caterpillar tree have maximum number of critical nodes.

Let's say that n is almost a power of two then n+1 is a power of two.

If there 0 critical nodes, then n is almost a power of two (example full binary tree). Suppose exist trees that don't satisfy the condition. Let's look on the smallest one. Left and right subtrees satisfy the condition. If they are different, then one of them 2 times bigger than another and root is critical. If they are have equal sizes, then our tree satisfied the condition.

If there 1 critical nodes, then n isn't almost a power of two. Suppose there exist trees that don't satisfy the condition. Let's look on the smallest one. One of the subtrees is almost a power of two. If both subtrees are almost a power of two, then they are equal and there is no critical nodes. In other case, the root isn't critical. Then second subtree isn't almost a power of two. If we write two inequalities with the size of the tree and the size of the first subtree, then it becomes clear that size of the tree can't be almost a power of two.

How to construct an example with 1 critical node? Let m be some integer that: 2m<n<2m+1. It can be shown that one subtree in answer can be equals 2m−1 or 2m−1−1.

And finally, what we should do when k≥2? Let's go from (n,k) to (n−2,k−1). If n≥13 we can just make one subtree size of 1. In other cases we should precalculate answers.

So we have solution with complexity O(n).

The easy way to write a solution is make a function can(n,k) that return True if there exists needed tree and else False. Then we can find the smallest subtree with simple brute force. In this case complexity is O(nlogn).

1379F1 - Chess Strikes Back (easy version)Let's divide the grid into nm squares of size 2×2. Each square contains exactly two white cells. So, we should put exactly one king into one square.

Let's mark a square L, if its left upper cell is banned and R if its right down cell is banned. Square can be L and R at the same time.

If there exists some L-square (x1,y1) and R-square (x2,y2), such that:

x1≤x2y1≤y2the answer is NO. It's easy to prove because if such pair of cells exists we can consider path from (x1,y1) to (x2,y2). In this path, there will be two neighboring cells.

If no such pairs of cells exist the answer is YES.

Note that in this version of the problem cells cannot become available againg. This means that for some prefix of queries the answer is YES and for the remaining suffix the answer is NO. Let's do a binary search to find position of the last YES.

How to check that the answer is YES fast enough?

Let's calculate the values:

ax= minimal y, such that (x,y) is L-squarebx= maximal y, such that (x−1,y) is R-squareAfter that, we should check, that ai>bj for all i>j. We can easily do this using prefix maximums for a and suffix minimums for bTotal complexity is O((n+q)logq).

1379F2 - Chess Strikes Back (hard version)Let's divide the grid into nm squares of size 2×2. Each square contains exactly two white cells. So, we should put exactly one king into one square.

Let's mark a square L, if its left upper cell is banned and R if its right down cell is banned. Square can be L and R at the same time.

If there exists some L-square (x1,y1) and R-square (x2,y2), such that:

x1≤x2y1≤y2the answer is NO. It's easy to prove because if such pair of cells exists we can consider path from (x1,y1) to (x2,y2). In this path, there will be two neighboring cells.

If no such pairs of cells exist the answer is YES.

So, after each query, we should check this condition.

Let's maintain the values:

ax= minimal y, such that (x,y) is L-squarebx= maximal y, such that (x−1,y) is R-squareThese values can be maintained using O(n) sets in O(logq) time.

After that, we should check, that ai>bj for all i>j.

Let's make a segment tree with values:

minimal ai on segmentmaximal bi on segmentthe flag, that for all i>j from the segment it is true, that ai>bjIt is easy to merge two such segments, to calculate the flag, we should check, that minleft>maxright.

So, the total time to answer the query is O(logn+logq).

Total complexity is O((n+q)(logn+logq)).

Codeforces Round #656 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishAll ideas belong to MikeMirzayanov.

1385A - Three Pairwise Maximums

Tutorial1385A - Three Pairwise MaximumsSuppose x≤y≤z. If y≠z then the answer is -1, because z is the overall maximum among all three integers a, b and c and it appears in two pairs (so it should appear at most twice among x, y and z). Otherwise, the answer exists and it can be x, x and z (it is easy to see that this triple fits well).

Solution1385B - Restore the Permutation by Merger

Tutorial1385B - Restore the Permutation by MergerThe solution is pretty simple: it's obvious that the first element of a is the first element of the permutation p. Let's take it to p, remove it and its its copy from a. So we just have the smaller problem and can solve it in the same way. It can be implemented as "go from left to right, if the current element isn't used, take it and mark it's used".

Solution1385C - Make It Good

Tutorial1385C - Make It GoodConsider the maximum element amx of the good array a of length k. Then we can notice that the array a looks like [a1≤a2≤⋯≤amx≥⋯≥ak−1≥ak]. And this is pretty obvious that if the array doesn't have this structure, then it isn't good (you can see it yourself). So we need to find the longest such suffix. It's pretty easy doable with pointer: initially, the pointer pos is at the last element. Then, while pos>1 and apos−1≥apos, decrease pos by one. If we're done with the previous step, we do the same, but while pos>1 and apos−1≤apos. The answer is pos−1.

Solution1385D - a-Good String

Tutorial1385D - a-Good StringConsider the problem in 0-indexation. Define the function calc(l,r,c) which finds the minimum number of changes to make the string s[l…r) c-good string. Let mid=l+r2. Then let cntl=r−l2−count(s[l…mid),c)+calc(mid,r,c+1) and cntr=r−l2−count(s[mid…r),c)+calc(l,mid,c+1), where count(s,c) is the number of occurrences of the character c in s. We can see that cntl describes the second condition from the statement and cntr describes the third one. So, calc(l,r,c) returns min(cntl,cntr) except one case. When r−l=1, we need to return 1 if sl≠c and 0 otherwise. This function works in O(nlogn) (each element of s belongs to exactly logn segments, like segment tree). You can get the answer if you run calc(0,n, ′a′).

Solution1385E - Directing Edges

Tutorial1385E - Directing EdgesFirstly, if the graph consisting of initial vertices and only directed edges contains at least one cycle then the answer is "NO". Otherwise, the answer is always "YES". Let's build it. Let's build the topological sort of the graph without undirected edges. Then let's check for each directed edge if it's going from left to right (in order of topological sort). If it isn't true then there is a cycle and the answer is "NO". Otherwise, let's direct each edge from left to right in order of the topological sort.

Solution1385F - Removing Leaves

Tutorial1385F - Removing LeavesThis is mostly implementation problem. We can notice that all leaves are indistinguishable for us. So if we have some vertex with at least k leaves attached to it, we can choose it, remove these leaves from the tree and continue the algorithm. The rest is just an implementation: let's maintain for each vertex v the list of all leaves which are connected to it leavesv and the set of vertices which is sorted by the size of leavesv. So let's take any vertex which Is connected with at least k leaves (we can just take the vertex with the maximum value in the set) and remove any k leaves attached to it. If it has zero leaves after the current move, let's mark is as a leaf and append it to the list of the corresponding vertex (you also need to remove edges from the graph fast to find the required vertex, so you may need to maintain the graph as the list of sets). And don't forget about the case k=1 because it may be special for your solution so you could handle it in a special way.

Time complexity: O(nlogn).

Solution1385G - Columns Swaps

Tutorial1385G - Columns SwapsFirstly, we can determine that the answer is -1 if some number has not two occurrences. Otherwise, the answer exists (and we actually don't need to prove it because we can check it later). Let's find for each number i from 1 to n indices of columns in which it appears c1[i] and c2[i]. Consider some number i. If c1[i]=c2[i] then let's just skip it, we can't change anything by swapping values in this column. Otherwise, let r1[i] be the number of row of the number i in the column c1[i] and r2[i] is the number of row of the number i in the column c2[i]. If r1[i]=r2[i] then it's obvious that at exactly one of these two columns should be swapped. The same, if r1[i]≠r2[i] then it's obvious that we either swap both of them or don't swap both of them. Let's build a graph consisting of n vertices, when the vertex v determines the state of the v-th column. If r1[i]=r2[i] then let's add edge of color 1 between vertices c1[i] and c2[i]. Otherwise, let's add the edge of color 0 between these vertices.

So, we have the graph consisting of several connected components and some strange edges. Let's color it. If the edge (v,to) has the color 1 then the color of the vertex to should be different from the color of the vertex v. The same, if the edge (v,to) has the color 0 then the color of the vertex to should be the same as the color of the vertex v. This makes sense, because edges with color 1 mean that exactly one of the columns connected by this edge should be swapped (and vice versa).

So, after we colored the graph, we can ensure that conditions for each edge are satisfied. If it isn't so, the answer is -1 (but this case can't actually appear). Otherwise, we need to decide for each component independently, what is the color 0 and the color 1 means for it. The color 0 can mean that the column having this color isn't swapped (and the color 1 means that the column having this color is swapped in this case) and vice versa. We can choose greedily the minimum number of swaps for each component and print the answer.

Time complexity: O(n).

Solution

Codeforces Round #655 Editorial

By MagentaCobra, history, 3 years ago, In EnglishWe really hope you enjoyed the problems! We apologize again for the long queue and unrated round. Just for fun, here's how many of our problems were rejected:

Rejection Count1372A - Omkar and CompletionNotice that since all elements must be positive, k≠2k. The most simple construction of this problem is to simply make all elements equal to 1.

Solution: 86603804

Idea: MagentaCobra

Preparation: MagentaCobra, qlf9

1372B - Omkar and Last Class of MathShort Solution: The two integers are k and n−k, where k is the largest proper factor of n.

Proof: Let the two integers be k and n−k. Assume WLOG that k≤n−k. Notice that this implies that n−k≥n2 .

We first claim that LCM(k,n−k)=n−k<n if k∣n, and we prove this as follows: if k∣n, then there exists some integer m such that m⋅k=n. The integer n−k can then be written as (m−1)⋅k, which is a multiple of k. Thus, LCM(k,n−k)=n−k if k∣n.

We now show that LCM(k,n−k)≥n if k∤n. We show this by using the fact that LCM(a,b)=b iff a∣b, so if k∤n, k∤n−k, and so LCM(k,n−k)≠n−k. And since LCM(k,n−k) must be a multiple of both k and n−k, it follows that LCM(k,n−k)≥2⋅(n−k)≥2⋅n2 =n.

We have now established that to minimize LCM(k,n−k), k must be a factor of n. And, since LCM(k,n−k)=n−k when k is a factor of n, we need to minimize n−k, so we must maximize k by choosing it to be the largest proper factor of n (i. e. the largest factor of n other than n).

We then simply need to find k, the largest proper factor of n. If p is the smallest prime dividing n, then k=np , so it suffices to find the smallest prime factor of n. We can do this by simply checking all values of p such that 2≤p≤√n. If n is not prime, then it must have a prime factor not exceeding √n. Furthermore, if we do not find a factor of n between 2 and √n, then n must be prime so we simply get p=n and k=np =1.

We're given that n≤109, so √n≤1092 <105. t≤10, meaning that we will check less than 106 numbers, which runs well under the time limit.

Solution: 86603838Idea: qlf9

Preparation: qlf9

1372C - Omkar and BaseballYou need at most 2 special exchanges to sort the permutation. Obviously, 0 special exchanges are needed if the array is already sorted. Let's look into cases in which you need 1 special exchange to sort the array.

Refer to i as a matching index if ai=i. If there are no matching indices, then you can just use one special exchange to sort the entire thing. Otherwise, you can use the location of matching indices to determine whether you need more than 1 special exchange. If all matching indices are located in some prefix of the permutation, you can sort the permutation with one special exchange. The same is true for a suffix. In other words, if you can choose a subarray in the permutation such that all elements contained in the subarray are NOT matching and the elements outside of this subarray are matching, then one special exchange is needed to sort the array.

Otherwise, you need 2 special exchanges to sort the permutation. Let's prove why you do not need more than 2 special exchanges. You can quickly check that you need at most 2 special exchanges for all permutations of length ≤3. For permutations of length ≥4, I claim that we can perform 2 special exchanges on the whole array; to show this it suffices to construct a permutation p that has no matching indices with either the given permutation or the identity permutation 1,2,…,n. We can do this as follows:

For simplicity, assume that n is even. We will assign the numbers n2 +1,n2 +2,…,n to the first n2  positions of our permutation p and the numbers 1,2,…,n2  to the last n2  positions of p. This ensures that p has no matching indices with the identity permutation. Then, for all integers b such that their position i in a (i. e. the j such that aj=b) is in the appropriate half of p, assign pi=b; assign other b to arbitrary positions in the appropriate half of p. Finally, cyclically rotate each half of p – this ensures that p has no matching indices with a.

As an example, let's take a=[3,6,2,4,5,1]. You can quickly check that this cannot be done in less than 2 special exchanges. The construction of p goes as follows:

First, we move all numbers to the proper half of p, so that p=[4,5,6,1,2,3].

Observing that a2=6 and a6=1, we set p2=6 and p6=1 then replace the remaining elements arbitrarily into the correct half, so we can get, for example, p=[4,6,5,2,3,1].

Finally, we cyclically rotate each half of p, obtaining p=[5,4,6,1,2,3], which has no matching indexes with either a=[3,6,2,4,5,1] or [1,2,3,4,5,6].

This can be extended to odd n by first choosing some element other than 1 and a1 to be p1 (this works for n≥3 and we must have n≥5 anyway in this case), and then running the same algorithm on the rest of p.

Solution: 86603857Idea: MagentaCobra

Preparation: MagentaCobra, qlf9

1372D - Omkar and CircleFirst note that any possible circular value consists of the sum of some (n+1)/2 elements. Now let's think about how these (n+1)/2 values would look like in the circle.

Let's consider any one move on index i. ai will be replaced with the sum of ai−1 and ai+1 (wrap around to index 1 or n if needed). Then let's consider making a move on i+2, since it will be adjacent to i after the first move. Then its value will become ai−1+ai+1+ai+3. This implies that alternating values play a role in the construction of the (n+1)/2 values contained in the final circular value.

Now let's consider the final move when there's 3 elements left in the circle. This is the only move that takes the sum of two adjacent elements in the initial circle. With this observation, we can achieve our final construction as follows:

Choose any (n+1)/2 elements in the initial circle such that exactly one pair of chosen numbers are adjacent to each other. The answer will be the maximum of the circular value over all possible constructions.

While there are ways involving complicated prefix sums/segment trees, the cleanest implementation is as follows: create an array whose values consists of [a1,a3,...,an,a2,a4,...,an−1]. Append this new array to itself to account for the circular structure. Now all you simply have to do is to find the maximum sum over all subarrays of length (n+1)/2. This can be done with sliding window in O(n) time.

Solution: 86603878Idea: MagentaCobra

Preparation: MagentaCobra, Tlatoani

1372E - Omkar and Last FloorLet dpl,r be the answer for the columns from l to r.

To solve dpl,r, it is optimal to always fill some column within l to r to the max. Let's call this column k. The transition is thus dpl,k−1+( number of intervals that are fully within l and r and include k)2+dpk+1,r. For every dpl,r loop through all possible columns to be k and take the max.

The answer is dp1,m.

The efficiency is O(N⋅M3). There are M2 dp states. For every state, you transition based on M cases of k, and it takes O(N) to determine how much the max column contributes.

Proof: Consider an optimal arrangement and the column with the most 1's in that arrangement. If there is an interval intersecting that column whose 1 isn't in that column, then moving the 1 to that column would not decrease (and possibly would increase) the quality of that arrangement. Thus, it's optimal for the column with the most 1s to have all the possible 1s that it can have.

Solution: 86603896Idea: golions

Preparation: Tlatoani, golions

1372F - Omkar and ModesFor both solutions, we must first make the critical observation that because the array is sorted, all occurrences of a value x occur as a single contiguous block.

Solution 1

We will define a recursive function determine(l,r) which will use queries to determine the array. We will also store an auxiliary list of previously returned query values (x,f) – not the queries themselves, but only the values returned, so that we know that if (x,f) is in the list then some previous query revealed that there were f instances of x in some query, and that we haven't already determined exactly where in the array those f instances of x are.

The execution of determine(l,r) will proceed as follows: first, query the interval [l,r], and let the result be (x1,f1).

If there exists some previous query result (x1,f2) in our auxiliary list, then we will guarantee by details yet to be explained of determine(l,r) that the interval that produced that result contained [l,r] and that no part of those f2 occurrences of x1 occurred to the left of [l,r]. This allows us to exactly determine the location of those f2 occurrences of x1. We mark these occurrences in our answer, and then remove (x1,f2) from our auxiliary list and do not add (x1,f1). If [l,r] is not entirely composed of occurrences of x1, then the remaineder of the interval must be [l,r′] for some r′, and in that case we then call determine(l,r′).

If there does not exist some previous query result (x1,f2) in our auxiliary list, then we add (x1,f1) to the list and do as follows: while the exact locations of those f1 occurrences of x1 have not been determined, call determine(l′,l′+f1−1), where l′ is the leftmost index in [l,r] which has not yet been determined. Once those locations have been determined, call determine(l′,r).

To determine the entire array we simply call determine(1,n). It is clear that this will correctly determine the array. We can see that it uses at most 4k queries as follows: for each block of integers of the same value represented by a query result (x,f) that we add to our auxiliary list, we use 2 queries to determine the exact location of those integers: one when added (x,f) to the list, and one when removing (x,f) from the list.

This does not guarantee that the algorithm uses 2k queries because some calls of determine can split a block of integers of the same value into two blocks. However, we can show that any blocks formed by splitting a single block into two cannot be further split as they occur either at the beginning or end of a queried interval (the full proof is left as an exercise to the reader), so each distinct value in the array will produce at most 2 blocks, each of which will be determined in 2 queries, meaning that the algorithm uses at most 4k queries.

Side note: you can in fact further show that the algorithm always uses at most 4k−4 queries and that there exists an array for all k≥2 which forces the algorithm to use 4k−4 queries.

Solution 2

Again, we will define a recursive function determine(l,r), but this time we will only additionally maintain the currently known values in the answer.

The execution of determine(l,r) will proceed as follows: first, query the interval [l,r] and let the result be (x,f). Then, find the largest integer k such that 2k≤f and then for all j in [l,r] that are multiples of 2k, determine the value located at index j, either by querying [j,j] or by using already known values.

By the definition of k, there will be either one or two such indexes j such that the values at those indexes are equal to x.

If there is only one such index, let this index be j1. Make two queries [j1−2k+1,j1] and [j1,j1+2k−1] and let the results of these queries be (x1,f1) and (x2,f2) respectively. We can show that at least one of x1 and x2 must be equal to x. If x1=x, then we see that the f occurrences of x must be precisely the interval [j1−f1+1,j1−f1+f]. If x2=x, then we see that the f occurrences of x must be precisely the interval [j1+f2−f,j1+f2−1].

If there are two such indexes, let these indexes be j1 and j2 so that j1<j2. Note that it must be true that j1+2k=j2. Make a single query [j1−2k+1,j2] and let the result be (x1,f1). We can show that x1 must be equal to x, so we can then conclude that the f occurrences fo x must be precisely the interval [j2−f1+1,j2−f1+f].

After the interval containing the f occurrences of x has been determined, mark these occurrences in our answer and then call determine on the remaining not-fully-determined interval to the left if it exists and the remaining not-fully-determined interval to the right if it exists.

To determine the entire array we simply call determine(1,n). It is clear that this will correctly determine the array. We can see that it uses at most 4k queries as follows: Each call to determine finds all occurrences of a distinct value x. We will refer to the queries of single indexes j that were multiples of some 2k as j-queries. For each x, we perform the following queries other than j-queries: the first query in determine, and then either two additional queries if only one j-query was found to equal x, or a single additional query if two j-queries were found to equal x. This means that if we group each j-query with the value x that it equaled, then we will have performed exactly 4 queries for each x, and so the algorithm must therefore use exactly 4k queries.

Solution 1: 86603917Solution 2: 86603930

Idea: golions

Preparation: Tlatoani, golions

Codeforces Round #654 (Div. 2) Editorial

By physics0523, history, 3 years ago, In English1371A - Magical SticksOutput ⌈n2⌉.

When n is even, we can create 1+n=2+(n−1)=3+(n−2)=...When n is odd, we can create n=1+(n−1)=2+(n−2)=...Initially, there are only 1 stick which has length i(1≤i≤n). If we connect 2 sticks s1 and s2, after that, there is a stick which has a different length from s1 and s2. Then, we can create at most 1+⌊n−12⌋ sticks that have the same length. The value is equal to ⌈n2⌉.

Total complexity: O(1)Jury solution: 85699387

1371B - Magical CalendarFirst, let's consider in case of a week has exactly w days.

If w<n , the length of painted cells is strictly more than one week. So there are w valid shapes. (The first week contains 1,2,...,w days) The shapes have w-day width, then if the value of w are different, the shapes are also different.Otherwise (n≤w) , there is only one valid liner pattern. The shape is insensitive to the chosen value of w.We can sum up this for 1≤w≤r, by using following well-known formula: a+(a+1)+(a+2)+...+b=(a+b)∗(b−a+1)2Total complexity : O(1)Jury solution: 856998841371C - A Cookie for YouIf m<min(a,b),n+m≤a+b are satisfied, the answer is "Yes". Otherwise, the answer is "No". Let's proof it.

Of course, n+m≤a+b must be satisfied, because violating this inequality means lack of cookies.

When a type 2 guest comes, or when a=b, the value of min(a,b) is decremented by 1.

You need to consider only about the case that all type 2 guests come first and after that all type 1 guests come, because if there is a type 1 guest before a type 2 guest, swapping them is better to make no one angry. (Because if there is a type 1 guest before a type 2 guest, the type 1 guest have a possibility to decrease the value of min(a,b) unnecessarily.)

At last, all of type 1 guests eat one cookie when there is at least one cookie(both types are ok).

Total complexity: O(1)Jury solution: 85699939UPD: m<min(a,b) is wrong, the right text is m≤min(a,b)

1371D - Grid-00100We can construct a grid A which has f(A)=0 if k%n=0 , f(A)=2(12+12) otherwise (the values are smallest almost obviously.) in following method:

First, initialize Ai,j=0 for all i,j. Then, change a 0 into 1 k times by using following pseudo code:

let p=0 , q=0

    for i = 1..k

        Change A[p+1][q+1] into 1

        let p=(p+1) , q=(q+1)%n

        if(p==n)

            let p=0 , q=(q+1)%n

Total complexity : O(n2)Jury solution: 857001781371E1 - Asterism (Easy Version)Let's define m=max(a1,a2,...,an).

Yuzu should have at least m−n+1 candies initially to win all duels, then f(x)=0 for x<m−n+1. This is divisible by p.

And if Yuzu have equal or more than m candies initially, any permutation will be valid, then f(x)=n! for x≥m. This is divisible by p , too. (because p≤n)

Then, in this subtask, you should find whether each f(x) are divisible by p for m−n+1≤x<m in O(n).

You can find the value of f(x) by following simulation:

First, let v={the number of enemies they have strictly less than x candies}, ans=1.Then do the following steps for i=x,x+1,...,x+(n−1).v=v + {the number of enemies they have exactly i candies}ans=ans∗vv=v−1Now, p is a prime. Then, "Whether f(x) is divisible by p" is "Whether p was multiplied to ans as v at least once."

This can be simulated in O(n) time for each x.

Total complexity : O(n2)Jury solution: 857003341371E2 - Asterism (Hard Version)There are two different solutions to solve this problem.

Solution 1:

First, find the minimum s which has f(s)>0. You can use binary search or cumulative sum for it.

Now, we can say the answers form a segment [s,t] (or there are no answers). Find t and proof this.

Let's define bi as the number of the enemies who has equal or less than i candies.

Then, observe the value Ci(x)=bx+i−i (0≤i≤N−1) :

f(x)=∏N−1i=0Ci(x)once the value Ci(x) exceed p , f(x) is divisible by p because C(x) is decremented by (at most) 1 in one step and contains some Ci(x)=p in this x.Ci(x)≤Ci(x+1) are always satisfied.Then, once f(x) is divisible by p , f(x+α) is also divisible by p, so t can be find by using binary search.We can find t without binary search by the following method:1. let i←0,t←max(A)

2. if(Ci(t)<p){i++;}else{t–;}

3. Repeat the step 2. And when become i=N and the algorithm stops, t is the maximum value which we want.

Solution 2:

We can say that f(x)=∏i=xx+n−1bi−(i−x)=∏i=xx+n−1x−(i−bi) .

We should find all x∈Z, such that there is no x≤i<x+n, such that x≡i−bi(modp).

It's easy to see, that there should be max(ai)−n≤x≤max(ai) to have f(x)≠0 and f(x)≠n! (they are both divisible by p).

Let's calculate i−bi for all necessary values max(ai)−n≤x≤max(ai)+n and after that we can solve the problem by O(n).

Anyway, the total complexity is O(n) or O(nlogn).

Jury solution (Solution 1): 85700515Jury solution (Solution 2): 85700518

1371F - Raging ThunderFirst, observe where the balls fall. When there is a ">>>...>><<...<<<" structure, the balls on there will fall into one hole. So, our goal is handling this structure.

Each query is asking about a segment. Then, to solve this problem, we can use segment tree.

Each node maintains following:

Prefix structureSuffix structureThe answer for between above structuresFor example, a string "><<>><>><<>>>>" will be converted to the following data:

Prefix structure : "><<"Suffix structure : ">>>>"The answer for between above structures : take the answer of ">><" or ">><<". the largest answer is 4.And we need to implement that combining two data ( [left data] + [right data] ). Mainly we should merge left suffix and right prefix, and calculate the answer for the segment, but notice that there are some exceptions. The exceptions are in case of there are only one structure in the merged node, like ">>><<" or "<<<". (You may maintain other flags for your implement.)

Then, how to handling each queries? We also keep above data for when '>' are changed into '<' and vice versa on each node of the segment tree. And when a change query actually comes to some nodes, swap these data. Apply lazy propagation for handling this. When calculate the answer for a query, don't forget to consider about the prefix(or the suffix).

Total complexity : O(n+qlogn)Jury solution: 85700669Feel free to share your approach here!

Codeforces Round #653 (Div. 3) Editorial

By vovuh, history, 3 years ago, In English1374A - Required Remainder

Idea: vovuh

Tutorial1374A - Required RemainderThere are two cases in this problem. If we try to maximize the answer, we need to consider only two integers: n−nmodx+y and n−nmodx−(x−y). Of course, the first one is better (we get rid of the existing remainder and trying to add y to this number). If it's too big, then we can and need to take the second one (this number is just the first one but decreased by x). The answer can be always found between these numbers.

Time complexity: O(1).

Solution1374B - Multiply by 2, divide by 6

Idea: vovuh

Tutorial1374B - Multiply by 2, divide by 6If the number consists of other primes than 2 and 3 then the answer is -1. Otherwise, let cnt2 be the number of twos in the factorization of n and cnt3 be the number of threes in the factorization of n. If cnt2>cnt3 then the answer is -1 because we can't get rid of all twos. Otherwise, the answer is (cnt3−cnt2)+cnt3.

Time complexity: O(logn).

Solution1374C - Move Brackets

Idea: MikeMirzayanov

Tutorial1374C - Move BracketsLet's go from left to right over characters of s maintaining the current bracket balance (for the position i the balance is the number of opening brackets on the prefix till the i-th character minus the number of closing brackets on the same prefix).

If the current balance becomes less than zero, then let's just take some opening bracket after the current position (it obviously exists because the number of opening equals the number of closing brackets) and move it to the beginning (so the negative balance becomes zero again and the answer increases by one). Or we can move the current closing bracket to the end of the string because it leads to the same result.

Time complexity: O(n).

Solution1374D - Zero Remainder Array

Idea: vovuh

Tutorial1374D - Zero Remainder ArrayFirstly, we can understand that during each full cycle of x from 0 to k−1 we can fix each remainder only once. Notice that when we add some x then we fix the remainder k−x (and we don't need to fix elements which are already divisible by k). So, let cnti be the number of such elements for which the condition k−aimodk=i holds (i.e. the number of such elements that we can fix if we add the value imodk to them). We can count this using some logarithmic data structure (like std::map in C++).

So, what's the number of full cycles? It equals to the amount of most frequent element in cnt minus one. So, the answer is at least k⋅(max(cnt)−1). And there can be one last cycle which will be incomplete. So what is the remanining number of moves? It equals to the maximum possible i among all cnti=max(cnt). So if key is the maximum such i that cntkey=max(cnt) then the answer is k⋅(cntkey−1)+key+1.

Time complexity: O(nlogn).

Solution1374E1 - Reading Books (easy version)

Idea: MikeMirzayanov

Tutorial1374E1 - Reading Books (easy version)Let's divide all books into four groups:

00 — both Alice and Bob doesn't like these books;01 — only Alice likes these books;10 — only Bob likes these books;11 — both ALice and Bob like these books.Obviously, 00-group is useless now. So, how to solve the problem? Let's iterate over the number of books we take from 11-group. Let it be cnt. Then we obviously need to take exactly k−cnt books from groups 01 and 10. Among all books in these three groups we have to choose the cheapest ones. To calculate sum of times in each group fast enought, we can sort each group independently and implement prefix sums on these arrays. If k−cnt is less than zero or greater than the size of 01 or 10-group for each possible cnt then the answer is -1.

And don't forget that the answer can be up to 2⋅109.

Time complexity: O(nlogn).

Solution1374E2 - Reading Books (hard version)

Idea: MikeMirzayanov

Tutorial1374E2 - Reading Books (hard version)A little explanation: this editorial will be based on the easy version editorial so I'll use some definitions from it.

Here we go, the most beautiful problem of the contest is waiting us.

Well, the key idea of this problem almost the same with the easy version idea. Let's iterate over the number of elements in 11-group, we need to take the cheapest ones again. If the number of elements we take from 11-group is cnt then we need to take k−cnt elements from 01 and 10-groups. But one more thing: let's iterate over cnt not from zero but from the smallest possible number which can give us any correct set of books (the numeric value of the answer doesn't matter) start. The value of start can be calculated using k,m and sizes of groups by formula or even simple loop. If we can't find any suitable value of start, the answer is -1.

Let's call cnt elements from 11-group and k−cnt elements from 01 and 10-groups we take necessary. Other elements of the whole set of books are free (but elements of 11-group are not free). Let's create the set fr which contains all free elements (and fill it beforehand). So, now we took some necessary elements, but we need to take some free elements to complete our set. Let's create the other set st which contains free elements we take to the answer (and maintain the variable sum describing the sum of elements of st). How do we recalculate st? Before the start of the first iteration our set fr is already filled with some elements, let's update st using them.

Update is such an operation (function) that tosses the elements between fr and st. It will do the following things (repeatedly, and stop when it cannot do anything):

While the size of st is greater than needed (so we take more than m books in total), let's remove the most expensive element from st and add it to fr;while the size of st is less than needed (so we take less than m books in total), let's remove the cheapest element from fr and add it to st;while the cheapest element from fr is cheaper than the most expensive element form st, let's swap them.Note that during updates you need to recalculate sum as well.

So, we go over all possible values cnt, updating st before the first iteration and after each iteration. The size of both sets changes pretty smooth: if we go from cnt to cnt+1, we need to remove at most one element from st (because we take one element from 11-group during each iteration) and we need to add at most two elements to st and fr (because we remove at most two elements from 01 and 10-groups during one iteration).

To restore the answer, let's save such a value cnt that the answer is minimum with this value cnt (let it be pos). Then let's just run the same simulation once more from the beginning but stop when we reach pos. Then st will contain free elements we need to take to the answer, pos describes the number of elements we need to take from 11-group and k−pos describes which elements from 01 and 01-groups we need to take.

Of course, there are some really tough technical things like case-handling (there is a lot of cases, for example, the size of st can be negative at some moment and you need to carefully handle that, and k−cnt can be negative after some number of iterations and there are other cases because of that, and so on).

Time complexity: O(nlogn).

Solution1374F - Cyclic Shifts Sorting

Idea: MikeMirzayanov

Tutorial1374F - Cyclic Shifts SortingFirstly, let's solve the easier version of the problem. Assume we are given a permutation, not an array. Notice that the given operation applied to some segment of the permutation cannot change the parity of number of inversions (the number of inversions is the number of such pairs of indices (i,j) that j>i and aj<ai). So if the number of inversions in the given permutation is odd then we can't sort this permutation (we can't obtain zero inversions).

But if the number of inversions is even then we can always sort the permutation with the following greedy algorithm: let's find the minimum element and move it to the first position. If its position is i then we can apply the operation to the segment [i−2;i] and our element will move by two positions to the left. So, after all, our element is either at the first or at the second position. If it's at the second position, let's just apply two additional operations to the segment [1;3]. Then let's just cut off the first element and solve the problem without it. At the end we have only two numbers that can be not sorted and we can check all three possibilities and choose one which is suitable for us (it's always exists because the number of inversions is even).

How do we solve the problem if we are given the array, not the permutation? First of all, we can prove that if the array contains at least two equal elements, we can always sort it (we will prove it by construction). Let's just renumerate the elements of the given array in a way to obtian the permutation with the even number of inversions. Thus, if a[i1]≤a[i2]≤⋯≤a[in] then let's find such a permutation p that p[i1]<p[i2]<⋯<p[in]. We can find this permutation easily if we sort the array of pairs (ai,i) in increasing order. But there can be one problem: this permutation can have odd number of inversions. Then we need to find two consecutive pairs with the same first values and swap these two elements in the permutation. Because in fact these two numbers are equal in the array and have consecutive values in the permutation, we guaranteed change the parity of number of inversions. Then we can apply our algorithm for permutations and solve the problem for the array. If we failed then the answer is -1. Otherwise the number of operations always does not exceed n2 (because this sort works like a bubble sort) so our answer is suitable.

Time complexity: O(n2).

Solution

Codeforces Round #652 (Div. 2) Editorial

By DeadlyCritic, history, 3 years ago, In EnglishA. FashionabLee :Invented by DeadlyCritic.

Brief SolutionBriefSolution:A n-regular convex polygon is beautiful if and only if n%4=0. (% is the modular arithmetic symbol)

Complete Proof1369A - FashionabLeeCompleteProof:Proof by contradiction :

One can prove that if two edges in a regular polygon make a x<180 degrees angle, then for each edge a there exist two another edges b and c such that a and b make a x degrees angle as well as a and c. (proof is left as an exercise for the reader)

Consider a rotation such that an edge a is parallel to OX-axis and an edge b is parallel to OY-axis, then a⊥b (a and b are perpendicular, i. e. the angle between them is 90 degrees), we can see that there exist a third edge c such that it's also parallel to OX-axis and a forth edge d such that it's also parallel to OY-axis, so a⊥d and b⊥c and c⊥d.

Our polygon is regular so all the angles are equal, so that the number of angles between a and b is equal to the number of angles between b and c and so on, also we know that a regular n-sided convex polygon has n angles, so n is divisible by 4, contradiction!

Python solutionC++ solutionB. AccurateLee :Invented by DeadlyCritic.

Brief SolutionBriefSolution:If the string s is non-decreasing, then the answer is s itself, otherwise the answer is x+1 zeroes and y ones, where x is the number of leading zeroes of the string s, and y is the number of trailing ones of the string s.

Complete Proof1369B - AccurateLeeCompleteProof :

Realize that the answer is always non-descending, and we can't perform any operations on non-descending strings.

First we know that we can't perform any operations on non-descending strings, so the answer to a non-descending string is itself. From now we consider our string s to not to be non-descending. (i.e. there exist index i such that 1≤i≤n−1 and si>si+1)

Also realize that the remaining string wont be empty, so "0" is the cleanest possible answer, but we can't reach it probable.

Now realize that leading zeroes and trailing ones can't be present in any operation. So they have to be in the answer, erase them from s, and add them to the answer for the modified s. From now we know that the string s has no leading zeroes and/or trailing ones, and is not non-descending, so it starts with 1 and ends with 0. (why?)

With some small paperwork, we will realize that the answer to a string that starts with 1 and ends with 0 is a single 0(proof is bellow). So if the string s is non-descending and it has x leading zeroes and y trailing ones(x and y can be equal to zero), then the answer is 00…0x011…1y (its x+1 zeroes and y ones in order)

TheSmallPaperwork:We will randomly perform operations until we can't do any more or the string's length is equal to 2, but we wont erase the first 1 and the last 0, we want to prove that the remaining string's length is exactly 2 after the process ends, proof by contradiction :

So it's length is at least 3, so we have at least two 1 or at least two 0. If we had two or more 0 then the string [s1s2…sn−1] will not be non-descending(so we can perform more operations as we proved in STAR, but the process have ended, contradiction!) and if we had two or more 1 then the string [s2s3…sn] will not be non-descending. So the length of the remaining string is exactly 2, and we haven't erased first '1' and last '0', so the string is equal to "10", now erase '1' to get the cleanest string.

Sorry if the proof seems too long and hard, i wanted to explain it accurately. ^-^

Python solutionC++ solutionC. RationalLee :Invented by DeadlyCritic and adedalic.

Brief SolutionBriefSolution :

Give greatest elements to friends with wi=1. For the rest sort the elements in non-descending order of ai and sort the friends in non-ascending order of wi then give first w1−1 elements to friend 1, next w2−1 elements to friend 2 and so on, also give k−i+1-th greatest element to friend i (1≤i≤k).

Complete Proof1369C - RationalLeeCompleteProof :

First if wi=1 for some i, then assign the greatest element to i-th friends, it's always better obviously.

Sort the elements in non-descending order and sort the friends in non-ascending order of wi. Define vi the set of indices of elements to give to i-th friend. Also define li the minimum element to give to i-th friend and ri the maximum element to give to i-th friend, and define m=max1≤i≤kwi.

Now it's easy to see that the first element of a(the smallest element) is always equal to li for some i, Indeed it's better to have the rest of vi equal to a small number except one of them, which should be equal to a very large number. So we can greedily assign a1, a2 ... awi−1 to vi, and then assign an to it, also it's better to have wi=m. One can prove that there exist an optimal distributing such that the set({a1,a2…am−1,an}) is equal to one of vi-s(proof is blow). So add a1+an to the answer for remaining elements of a(excluding the set) and remaining friends(excluding one of the friends with maximum wi) and so, it will be optimal.

Look at an optimal distributing (which maximizes sum of happiness), first element of a is in vi for example, we want to prove that in at least one of the optimal distributings wi−1 smallest elements of a are in vi (including the first element), proof by contradiction:

If at least one of the smallest wi−1 elements is not in vi, then call the smallest of them x, lets say it's in vj, now add x to vi(and erase it from vj), instead add a greater number than x in vi to vj (it's at least two of them, and one of them is ri, so there exist another one, erase it from vi and add it to vj), it's easy to see that sum of happiness won't decrease that way, continue the process until all wi−1 smallest elements are in vi, so we have an optimal answer which has all wi−1 smallest elements in vi, contradiction!

As we proved above, we have an optimal distributing such that all wi−1 smallest elements are in vi(for some i), now we want to prove that the greatest element is in vi in at least one of the optimal distributings, again proof by contradiction.

Lets say it's not that way, so look at an optimal distributing such that first wi−1 elements are in vi and ri is not equal to the greatest element(for some i), if there exist such j that ri<lj, then swap ri and lj, the resulting distributing has the same happiness, continue it until no such j exist, now lets say the greatest element of a is in vj for some j, also we know that rj is equal to the greatest element of a and lj≤ri(if ri<lj then the process of swapping is not finished, which is contradiction). So now we can swap ri and rj, again the resulting distributing has happiness greater than or equal to the happiness of the optimal distributing(the one we chose in the beginning), and so, its also an optimal distributing, and ri is equal to the greatest element, we have found an optimal distributing such that first wi−1 elements of a and an are in vi(for some i), contradiction!

Now we have proved that there exist an optimal distributing such that first wi−1 elements of a and an are in vi(for some i), call such optimal distributing STAR, and now the only remaining part is to prove that there exist an optimal distributing such that first m−1 elements of a and an are in vi(for some i). See the whole algorithm, its like "we choose a permutation of friends then we do that greedy assignment to them one by one from left to right", now we want to prove that there exist an optimal distributing such that it's STAR and it's permutation is sorted in non-descending order of w, call them GOOD distributings. Again, proof by contradiction :

Choose a distributing such that it's a STAR, it's permutation(called p) is not sorted in non-descending order of w(otherwise it's a GOOD distributing, contradiction!), so there exist an i such that wpi>wpi+1, now swap them(i. e. swap pi and pi+1 and then do the same greedy assignment using the modified permutation of friends), it's easy to see that happiness of friends after i+1 in permutation p wont change, also happiness of friends before i in the permutation wont change as well.

Now look at the happiness of pi and pi+1, you can realize that sum of happiness will increase.

You really don't need to prove it like that, it's not time friendly at all. ^-^

Python solutionC++ solutionD. TediousLee :Invented by DeadlyCritic.

Brief SolutionBriefSolution :

Realize that a RDB of level i is consisted of a vertex (the root of the RDB of level i) connected to the roots of two RDBs of level i−2 and a RDB of level i−1.

Run a DP and calculate the answer for each level i (3≤i≤2⋅106), then dpi=2⋅dpi−2+dpi−1+(i%3==0?4:0).

Complete Proof1369D - TediousLeeCompleteProof :

First realize that a RDB of level i is consisted of a vertex (the root of the RDB of level i) connected to the roots of two RDBs of level i−2 and a RDB of level i−1.

Now define dpi equal to the answer for a RDB of level i. Also define ri equal to 1 if Lee can achieve dpi yellow vertices in a RDB of level i such that the root is green, and 0 otherwise. It's easy to see that dpi is equal to either 2⋅dpi−2+dpi−1 or 2⋅dpi−2+dpi−1+4. If both ri−1 and ri−2 are equal to 1, then we can color the claw rooted at the root of the RDB, then ri=0 and dpi=2⋅dpi−2+dpi−1+4. Also if either ri−2 or ri−1 is equal to 0 then ri=1 and dpi=2⋅dpi−2+dpi−1.

Python solutionC++ solutionChallenge : Try solving problem D for n≤1018. (no matrix-multiplication)

E. DeadLee :Invented by DeadlyCritic.

HintsHints :

Find some greedy approaches. Its guessable that the problem is greedy.

Define si for food i equal to the number of guys who likes food i. Then find some condition which is enough to be sure that no answer exist.

See the last friend in a suitable permutation. What food will he eat?

Its easy to see that if ∀1≤i≤m⇒si>wi, then no answer exist.

If a food i exist such that si≤wi, then what will happen to the friends who like this food? They can always eat this food no matter what happens, so lets call them as late as possible(so its less likely for them to eat more than one plate). Now continue the process with rest of the friends and foods.

Brief SolutionBriefSolution :

Define si equal to the number of friends who likes food i. If for some i, si≤wi then place all the friends who likes food i in the end of the permutation and erase them and continue doing the same thing for the rest of the friends and foods

It's easy to see that if the set of friends became empty then the permutation we constructed is suitable(and no one would eat Lee), otherwise Lee has to buy more food!!

Complete Proof1369E - DeadLeeCompleteSolution :

Define si equal to the number of friends who likes food i. We want to proof that if ∀1≤i≤m⇒si>wiorsi=0 then no answer exist, it can be proved easily by contradiction, just look at the last friend in any suitable permutation, he will eat Lee as there is no food for him.

So if it was the case, then print Dead and terminate, otherwise place all the guys who likes food i in the end of the permutation, they wont eat Lee as they can always eat food i, also it's always better to place them in the end, as if we place them in the end, then they wont eat two plates. Continue the process until no friends exist or no i exist such that wi≥si>0.

Note that when we erase the friends, we have to update si, also if si=0 we should erase food i from the set of foods.

ImplementationDetails :

Instead of erasing friends/foods, just remember if a friend/food is erased or not using another array. Also updating s should not be that much hard(when marking i-th friend, decrease sxi and syi by one, if there exist any), also you can have the food i with maximum wi−si with a priority queue, or any other data structure in O(log2n).

The whole solution will work in O((n+m)⋅log2(n+m) time, you can also try achieving O(n+m) and then show-off it in the comment section ^_^.

Python solutionC++ solutionF. BareLee :Invented by DeadlyCritic and AS.82.

Brief SolutionBriefSolution :

Define wins,e (s≤e) equal to 1 if Lee can win the game when s is written on the board, and equal to 0 otherwise, also define loses,e the same way.

Win :

If e is odd then if s is odd Lee loses otherwise Lee wins. So if e is even then :

if e2<s≤e then if s is odd then Lee wins, otherwise Lee loses;if e4<s≤e2 then Lee wins;if s≤e4 then the answer is equal to wins,⌊e4⌋.Lose :

If e<2⋅s, then Lee can immediately lose, otherwise the answer is equal to wins,⌊e2⌋.

Complete Proof1369F - BareLeeCompleteProof :

Define ws,e (s≤e) equal to 1 if Lee can win the game when s is written on the board, and equal to 0 otherwise, also define ls,e the same way. This leads to a simple dp. Forget l for now.

Recall that a state i,j of our dp is a losing state if wi,j=0, and is a winning state otherwise.

You can guess ws,e for all s in range e4<s≤e in O(1), you don't have to store them :

If e is odd then it will be w1,e=1,w2,e=0,w3,e=1…we,e=0, in other words if e is odd, then if s is odd too ws,e=0, otherwise ws,e=1. Prove it by induction, for s=e it's correct, assume that for an integer i (1≤i<e) we have proved that the statement is correct for all j where i<j≤e, now we want to prove the statement for i :

If i is odd then both i+1 and 2⋅i are winning states (as they are even), also if i is even then i+1 is odd, i+1 is smaller than e so it's a losing state(induction assumption).

From now we consider e to be even. Also ×2 operation is replacing a, the number on the board, with 2⋅a, and +1 operation is the other move.

For e2<s≤e whoever uses ×2 operation will lose. So they all have to use +1 operation, so for e2<s≤e if w is odd, then ws,e=1, otherwise ws,e=0. (it's obvious, it can be proved with a simple induction like the one in previous part)

For e4<s≤e2, Lee can do a ×2 operation in the first turn and he will win because his opponent is starting a losing state.

For s≤e4, ws,e is equal to ws,⌊e4⌋. (why?)

Now it's time to calculate ls,e.

Remember, whoever writes an integer greater than e will lose, so if e<2⋅s then the first guy can immediately lose. So ls,e for e2<s≤e is equal to 1. And ls,e for s≤e2 is equal to ws,⌊e2⌋. (why?)

Python solutionC++ solution

Editorial — Codeforces Round #651

By FastestFinger, 3 years ago, In English1370A - Максимальный НОД

Tutorial1370A - Максимальный НОДKey Idea:

Answer for any n≥2 is equal to ⌊n2⌋ .

Solution:

Let the maximum gcd be equal to g. Since the two numbers in a pair are distinct, one of them must be >g and both of them must be divisible by g. The smallest multiple of g, greater than g, is 2⋅g. Since each number in the pair must be ≤n, we must have 2⋅g≤n, or g≤⌊n2⌋. We can achieve g=⌊n2⌋, by choosing ⌊n2⌋ and 2⋅⌊n2⌋.

Time Complexity: O(1)CodeThis problem was prepared by the_hyp0cr1t3

1370B - Сжатие массива и НОД

Tutorial1370B - Сжатие массива и НОДKey Idea:

It is always possible to form n−1 pairs of elements such that their gcd is divisible by 2.

Solution:

We can pair up the odd numbers and even numbers separately so that the sum of numbers in each pair is divisible by 2. Note that we can always form n−1 pairs in the above manner because in the worst case, we would discard one odd number and one even number from a. If we discarded more than one even or odd numbers, we could instead form another pair with even sum.

Time Complexity: O(n)CodeThis problem was prepared by Ashishgup and ridbit10

1370C - Игра с числом

Tutorial1370C - Number GameKey Idea:

FastestFinger wins for n=1 , n=2x where (x>1) and n=2⋅p where p is a prime ≥3 else Ashishgup wins.

Solution:

Let's analyse the problem for the following 3 cases:

Case 1: n is oddHere Ashishgup can divide n by itself, since it is odd and hence nn=1, and FastestFinger loses. Here n=1 is an exception.

Case 2: n is even and has no odd divisors greater than 1Here n is of the form 2x. As n has no odd divisors greater than 1, Ashishgup is forced to subtract it by 1 making n odd. So if x>1, FastestFinger wins. For x=1, n−1 is equal to 1, so Ashishgup wins.

Case 3: n is even and has odd divisorsIf n is divisible by 4 then Ashishgup can divide n by its largest odd factor after which n becomes of the form 2x where x>1, so Ashishgup wins.

Otherwise n must be of the form 2⋅p, where p is odd. If p is prime, Ashishgup loses since he can either reduce n by 1 or divide it by p both of which would be losing for him. If p is not prime then p must be of the form p1⋅p2 where p1 is prime and p2 is any odd number >1. Ashishgup can win by dividing n by p2.

CodeRelevant MemeThis problem was prepared by FastestFinger and Ashishgup

1370D - Чет-нечет подпоследовательность

Tutorial1370D - Чет-нечет подпоследовательностьKey Idea:

Binary search over the answer and check if given x, it is possible to form a subsequence of length at least k such that either all elements at odd indices or even indices are ≤x.

Solution:

Let us binary search over the answer and fix if the answer comes from elements at odd or even indices in the subsequence. Suppose we want to find if there exists a subsequence of length at least k such that the elements at odd indices are ≤x. We will construct the subsequence greedily.

Let's iterate on the array from left to right. Suppose we are at index i in the array and the current length of the subsequence formed is l. If l is odd, the next added element would be at an even index. In this case, we do not care about what this element is as we only want elements at odd indices to be ≤x. So, in this case, we add ai to the subsequence. If l is even, then the next added element would be at an odd index, so, it must be ≤x. If ai≤x, we can add ai to the subsequence, otherwise we do not add ai to the subsequence and continue to the next element in a.

Note that we can do a similar greedy construction for elements at even indices. If the length of the subsequence formed is ≥k (either by construction from odd indices or even indices), then the answer can be equal to x and we can reduce the upper bound of the binary search otherwise we increase the lower bound.

Time Complexity - O(n⋅log2(Ai)) or O(n⋅log2(n))CodeThis problem was prepared by Ashishgup

1370E - Сдвиги подпоследовательностей

Tutorial1370E - Сдвиги подпоследовательностейKey Idea:

Firstly, if s is not an anagram of t, it is impossible to convert s to t - since total number of 0s and 1s are conserved. However, if they are anagrams, we can always convert s to t.

We can ignore all the indices where si=ti as it is never optimal to include those indices in a rotation. The remaining indices must be satisfy si=0,ti=1 or si=1,ti=0. In the optimal answer, the chosen subsequences should be of the form 01010101... or 10101010...

Solution:

There are many approaches to solving the problem, all revolving around the key idea. We can greedily find the minimum number of chains of alternating 0 and 1 that the string can be broken down into  — using faster ways of simulation, such as a counter-based for loop or using sets and deleting successive indices, etc.

However, we will discuss an elegant approach which allows us to solve the problem and also prove its optimality. Moreover, it allows us to solve the problem for queries of the form (l,r) - which denotes the answer for the strings s[l,r] and t[l,r] respectively.

Logic: Let's create an array a with values from (−1,0,1) as follows:

If si=ti, ai=0Else if si=1, ai=1Else ai=−1Then the answer is equal to the maximum absolute value of the sum of any subarray in a, that is, max(| ∑i=lrai |) (1≤l≤r≤n).Proof:

The chosen subsequences must be of the form 01010101 or 10101010 (alternating 0s and 1s). If there are two consecutive 0s or 1s we can remove any one of them as applying the rotation operation could only affect one of them.The maximum absolute value of subarray sum in a is a lower bound on the answer. Let the sum of any subarray in a be c. We can assume that c≥0 (otherwise we can interchange 1 and −1). In any move, c cannot be reduced by more than 1, since we must choose subsequences of the form 010101 or 101010.We can achieve the above lower bound, and hence it is the answer. To prove the claim, we just need to show that in every operation, we can reduce the value of maximum absolute subarray sum by 1 (if there are multiple such subarrays, then we must reduce all of them by 1).For the above, a key realization is: suppose the maximum comes from a subarray (l,r) with a positive sum. Then it is necessary that on both sides of its endpoints if there is an element, it must be −1 (we can ignore the 0s), since if either side had a +1, we would have a higher valued subarray. Now we can pick any 1 from this subarray and a −1 either from its left or right to reduce its sum by 1, thus completing the proof. (Note that any subarray with maximum absolute sum must have at least one element with sign opposite to its sum either to its left or right.)Time complexity: O(n)CodeThis problem was prepared by smartnj

1370F2 - Загадана пара вершин (сложная версия)

Tutorial1370F2 - Загадана пара вершин (сложная версия)Key Idea:

We can find out one of the nodes in the path between the two hidden nodes using a single query. We can then root the tree at this node find one of the hidden nodes using binary search on its distance from the root.

Solution:

If we query all nodes in the tree, we will receive one of the nodes in the path between the two hidden nodes and also the distance between the two hidden nodes.

Proof: Suppose the distance between the hidden nodes is equal to l. All the nodes in the simple path between the two hidden nodes have the sum of distances equal to l. For all other nodes, the sum of distances is >l.

Now that we found a node r in the path between the hidden nodes, we will root the tree at r. If we can find one of the hidden nodes, we can easily find the other hidden node by querying all nodes at distance l from the first hidden node.

We can find one of the hidden nodes using binary search on its distance from the root. Suppose we query all the nodes at distance d from the root and receive the minimum sum of distance as x. If there is at least one hidden node whose distance from the root is ≥d, then x must be equal to l. Otherwise, x must be greater than l. So we can binary search on d and appropriately change the upper or lower bound of the binary search based on the minimum sum of distances received for the query. This takes 10 queries as the maximum depth could be up to n.

Then we need one more query to find the other hidden node. This takes a total of 12 queries. Note that this is sufficient to pass the easy version.

We can further reduce the number of queries by 1 if we notice that at least one of the hidden nodes must be at least at a distance of ⌈l2⌉ from the root. So we can set the lower bound of the binary search to ⌈l2⌉.

Note that if we discard the largest child subtree of the root, it also reduces the number of queries by 1.

Time complexity: O(n2)CodeRelevant MemesThis problem was prepared by FastestFinger and Ashishgup

Meme credits: ridbit10 and the_hyp0cr1t3 and FastestFinger

Codeforces Round #650 (Div. 3) Editorial

By Supermagzzz, history, 3 years ago, translation, In EnglishAll problems were developed by me Supermagzzz and Stepavly.

1367A - Short Substrings

Author: MikeMirzayanov

Editorial1367A - Short SubstringsNote that the first two characters of a match the first two characters of b. The third character of the string b again matches the second character of a (since it is the first character in the second substring, which contains the second and the third character of a). The fourth character b matches with the third character of a.

It is easy to notice that such a pattern continues further. That is, the string a consists of the first character b and all characters at even positions in b.

Solution1367B - Even Array

Авторы: Supermagzzz, Stepavly

Editorial1367B - Even ArrayWe split all the positions in which the parity of the index does not match with the parity of the element into two arrays. If there is an odd number in the even index, add this index to the e array. Otherwise, if there is an even number in the odd index, add this index to the o array. Note that if the sizes of the o and e arrays are not equal, then there is no answer. Otherwise, the array a can be made good by doing exactly |o| operations by simply swapping all the elements in the o and e arrays.

Solution1367C - Social Distance

Авторы: Supermagzzz, Stepavly

Editorial1367C - Social DistanceLet's split a given string into blocks of consecutive zeros. Then in each such block, you can independently put the maximum number of people who fit in it. But there are three cases to consider.

If the current block is not the first and not the last, then there are ones at the border and this means that the first k tables of the current block and the last k are prohibited. Therefore, remove these zeroes from the string.If the current block is the first, then the one is at the end and you need to delete the last k zeros.If the current block is the last, then in the beginning there is one and you need to delete the first k zeros.Also, as a separate case, you need to consider — a string consisting only of zeros. Then there is exactly one block from which you do not need to remove zeros.Now all the tables in each block are free, then in each block we can put ⌊number of zerosk⌋. Sum these values over all blocks.

Solution1367D - Task On The Board Автор: MikeMirzayanov

Editorial1367D - Task On The BoardWe will construct the string t, starting with the largest letters. Note that if bi=0, then the i-th letter of the string t is maximal, so we know that the i-th letter affect all bj≠0. While the string t is not completely constructed, we will do the following:

Find all i such that bi=0 and the i-th character of string t is not placed;Put on all these positions i in the string t the maximum letter not used in the string t (there should be a sufficient number of letters in the string s);Subtract |i−j| from all bj≠0.Solution1367E - Necklace Assembly

Автор: MikeMirzayanov

Editorial1367E - Necklace AssemblyLet's iterate over the m — length of the k-beautiful necklace. For each position i, make an edge to the position p[i]=(i+k)modm, where amodb — is the remainder of dividing a by b. What is a cyclic shift by k in this construction? A bead located at position i will go along the edge to position p[i]. Consider all the cycles of a graph constructed on p. You may notice that if only equal letters are found in each cycle, then with a cyclic shift by k the graph and the string will remain unchanged. Thus, in order to check whether it is possible to make a k-beautiful necklace of length m, you need to make a graph p, find the cycles in it and check whether it is possible to distribute the letters from the string s in cycles such that each cycle have equal letters. The last part of the solution can be done with simple greedy.

Solution1367F2 - Flying Sort (Hard Version)

Автор: MikeMirzayanov Stepavly Supermagzzz

Editorial1367F2 - Flying Sort (Hard Version)Let's replace each number ai with the number of unique numbers less than ai.

For example, the array a=[3,7,1,2,1,3] will be replaced by [2,3,0,1,0,2].

Note that the values of the numbers themselves were not important to us, only the order between them was important.

Let's sort such an array. Let's see what maximum length of the segment from the array a is already sorted (it forms a subsequence). This segment can be left in place, and all other numbers can be moved either to the beginning or to the end. That is, the task came down to finding the maximum sorted subsequence in the array.

This problem can be solved with the help of simple dynamic programming. Let dp[i] —- be the maximum length of a subsequence ending in position i. To calculate it, we will find the closest past position, which also has the value a[i] and the position with value a[i]−1 (lower numbers cannot be used, since a[i]−1 must stand between them). Any of these positions can be extended, so we take the maximum out of them and add 1. It is necessary to separately consider the first numbers in the subsequence and the last, since the first should include their suffix, and the last should have their prefix.

Solution

Codeforces round #649 editorial

By mohammedehab2002, history, 3 years ago, In English1364A - XXXXXLet's start with the whole array. If every element in it is divisible by x, the answer is −1; if its sum isn't divisible by x, the answer is n. Otherwise, we must remove some elements. The key idea is that removing an element that is divisible by x doesn't do us any benefits, but once we remove an element that isn't, the sum won't be divisible by x. So let the first non-multiple of x be at index l, and the last one be at index r. We must either remove the prefix all the way up to l or the suffix all the way up to r, and we'll clearly remove whichever shorter.

Code link: https://pastebin.com/j2Y8AJBA

Alternatively, we can notice that this means the answer is either a prefix or a suffix, so we can simply bruteforce them all.

1364B - Most socially-distanced subsequenceTL;DR the answer contains the first element, last element, and all the local minima and maxima, where a local minimum is an element less than its 2 adjacents, and a local maximum is an element greater than it 2 adjacents.

Let's look at the expression in the problem for 3 numbers. If a>b and b>c or if a<b and b<c, |a−b|+|b−c|=|a−c|, so it's never optimal to use a, b, and c in a row because you can use just a and c and achieve a shorter subsequence. If you keep erasing your b's from the original permutation, you'll end up with the first element, the last element, and the local minima and maxima. You can see that erasing any of them would decrease the expression, so this is the optimal answer.

Code link: https://pastebin.com/e2HHuKFY

1364C - Ehab and Prefix MEXsThe key observation is: if for some index i, ai≠ai−1, then bi must be equal to ai−1, since it's the only way to even change the prefix MEX. We can use this observation to fill some indices of b. Now, how do we fill the rest? Let's start by avoiding every element in a. Something special will happen if we avoid using any element from a again. If we look at the first i numbers in b, ai will indeed be excluded, so MEX(b1,b2,…,bi)≤ai. Now we need to make it as big as possible. How do we make it as big as possible? The logical thing to do is to fill the rest of b with the numbers not in a in increasing order. It turns out this construction always satisfies the conditions. Indeed, if we look at the first i elements in b, every element less than ai will be present because ai≤i and we added the rest of the elements in increasing order.

Code link: https://pastebin.com/x9VtuBym

1364D - Ehab's Last CorollaryThe common idea is: if the graph is a tree, you can easily find an independent set with size ⌈n2⌉ by bicoloring the vertices and taking the vertices from the more frequent color. Otherwise, the graph is cyclic. Let's get a cycle that doesn't have any edges "cutting through it." In other words, it doesn't have any pair of non-adjacent vertices connected by an edge. If its length is at most k, print it. Otherwise, take every other vertex (take a vertex and leave a vertex) and you'll end up with a big enough independent set. How to find such cycle?

First solutionLet's do a dfs in our graph. In the very first time we hit a node that has a back-edge, we take the back-edge that goes to the deepest possible node to close our cycle. This cycle can't have any edges crossing it because none of our node's ancestors has a back-edge (by definition.)

Code link: https://pastebin.com/wsCXuzGy

Second solutionLet's get any cycle in the graph. Now, let's iterate over the edges that don't belong to the cycle. Whenever we meet one that "crosses the cycle," we use it to cut the cycle into 2 cycles with smaller length and keep any of them. When we finish, we'd have our desired cycle.

Code link: https://pastebin.com/ezwEURKW

1364E - X-ORThe common idea is: if we find the index that contains 0, we can query it with every element in p and finish in n queries (if you didn't do that, pleaaase share your solution.) How to get this index?

First solutionLet's try to make a magic function that takes an index i and tells us pi. Assume you have an array z such that zj is some index in the permutation that has a 0 in the jth bit. Building our magic function with it turns out to be very easy. We'll just return query(i,z0)&query(i,z1)&…&query(i,z10). Why does that work? If pi has a 1 in the jth bit, this expression will also have a 1 because pi will make every single clause have a 1. If it has a 0, query(i,zj) will also have a 0, making the whole expression have a 0!

But how do we find z? This turns out to be very easy. We'll query random pairs of indices, see where the result has a 0, and update z. We stop once we fill every index in z. This works quickly because for any bit, at least half the numbers from 0 to n−1 will have a 0.

Now we already have an nlog(n) solution (call our magic function with every index,) but how to make less calls? Let's carry an index idx that's supposed to have the index of 0 in the end, and let pidx be stored in val. Initially, idx is 1 and val could be found with our magic function. Now, let's iterate over the permutation. We'll query the current index, i, with idx. If the result isn't a subset of val, pi can't be 0, so let's throw it in the trash. Otherwise, we'll make idx equal to i and use our magic function to update val.

Code link: https://pastebin.com/kBQGrEqP

analysisSecond solutionThanks, Utkarsh.25dec for this solution.

I'll describe a way to start with n candidates to be 0 and end up with n−−√ candidates. Let's query random pairs until we find a pair whose bitwise-or has at most log(n)2 bits. Take one of the 2 indices in the pair (let's call it i) and query it with every candidate you have, and take the bitwise-and of the results. That will give you pi. Now, let's make the numbers whose query result with i is pi (hence, a subset of pi) our new candidates. Since i has at most log(n)2 ones, the number of its subsets is n−−√, and we have our desired result!

Now, to find the index of 0, we'll just do this recursively until we have 2 candidates. We'll keep querying them with random indices until the results differ. The one giving a smaller result is our 0.

Code link: https://pastebin.com/zMV5CPAz

analysisThird solutionThanks, Mohammad_Yasser for this solution.

Assume you have 2 candidates for 0 called a and b such that one of them is the index of 0 at the end of our algorithm, and we always know (pa|pb). Let's iterate over our indices in a random order and try to update a and b. Assume the current index is c. Let's query to get (pb|pc). We have 3 cases:

If (pa|pb)<(pb|pc), pc can't be 0, so we'll throw it away.If (pa|pb)>(pb|pc), pa can't be 0, so we'll throw it away and change a to be c.Otherwise, pb can't be 0 because that would imply pa=pc (recall that p is a permutation.) So we can throw it away and change b to be c. But notice that we now don't know (pa|pb), so we're gonna have to make one more query, since we need to keep track of it.After we're done, we can narrow our 2 candidates down to 1 with the same way described in the previous solution.

Code link: https://pastebin.com/Trifp8p3

analysis

Editorial — Codeforces Round #648

By FastestFinger, history, 3 years ago, In English1365A - Matrix Game

Tutorial1365A - Matrix GameKey Idea:

Vivek and Ashish can never claim cells in rows and columns which already have at least one cell claimed. So we need to look at the parity of minimum of the number of rows and columns which have no cells claimed initially.

Solution:

Let a be the number of rows which do not have any cell claimed in them initially and similarly b be the number of columns which do not have any cell claimed initially. Each time a player makes a move both a and b decrease by 1, since they only claim cells in rows and columns with no claimed cells.

If either one of a or b becomes 0, the player whose turn comes next loses the game. Since both a and b decrease by 1 after each move, min(a,b) becomes 0 first. So, if min(a,b) is odd, Ashish wins the game otherwise Vivek wins.

Time complexity: O(n⋅m)CodeThis problem was prepared by Ashishgup

1365B - Trouble Sort

Tutorial1365B - Trouble SortKey Idea:

If there is at least one element of type 0 and at least one element of type 1, we can always sort the array.

Solution:

If all the elements are of the same type, we cannot swap any two elements. So, in this case, we just need to check if given elements are already in sorted order.

Otherwise, there is at least one element of type 0 and at least one element of type 1. In this case, it is possible to swap any two elements! We can swap elements of different types using only one operation. Suppose we want to swap two elements a and b of the same type. We can do it in 3 operations. Let c be an element of the type different from a and b. We can first swap a and c, then swap b and c and then swap a and c again. In doing so, c remains at its initial position and a, b are swapped. This is exactly how we swap two integers using a temporary variable. Since we can swap any two elements, it is always possible to sort the array in this case.

Time complexity: O(n)CodeThis problem was prepared by Ashishgup

1365C - Rotation Matching

Tutorial1365C - Rotation MatchingKey Idea:

We only need to perform shifts on one of the arrays. Moreover, all the shifts can be of the same type (right or left)!

Solution:

First of all, a left cyclic shift is the same as n−1 right cyclic shifts and vice versa. So we only need to perform shifts of one type, say right.

Moreover, a right cyclic shift of b is the same as performing a left cyclic shift on a and vice versa. So we don't need to perform any shifts on b.

Now the problem reduces to finding the maximum number of matching pairs over all right cyclic shifts of a. Since n right cyclic shifts on a results in a again, there are only n−1 right cyclic shifts possible.

Since both arrays are a permutation, each element in a would match with its corresponding equal element in b only for one of the shifts. For example, if a is {2,3,1} and b is {3,1,2}, the number 3 in a would match with the number 3 in b only if one right cyclic shift is performed. So for each element in a we can find the number of right cyclic shifts after which it would match with its corresponding equal element in b. If ai = bj, then ai would match with bj after k=j−i right cyclic shifts. If j−i<0, then ai would with bj after n−j+i shifts.

Now for each shift, we can find the number of matching pairs and take the maximum.

Time complexity: O(n) or O(n⋅log(n)) if you use a map.

CodeThis problem was prepared by Ashishgup and ridbit10

1365D - Solve The Maze

Tutorial1365D - Solve The MazeKey Idea:

We can block all empty neighbouring cells of bad people and then check if all good people can escape and no bad people are able to escape.

Solution:

Consider all the neighbouring cells of bad people. There shouldn't be any path from these cells to the cell (n,m). If there is a path from any such cell, the bad person adjacent to that cell can also then reach the cell (n,m). So, if any good and bad people are in adjacent cells, the answer is "No".

Based on this idea, we can block any empty cell neighbouring a bad person. Suppose there is another solution in which a cell (i,j) neighbouring a bad person does not need to be blocked. There still won't be any path from (i,j) to (n,m) in that solution. So we can block (i,j) in that solution too without affecting the solution itself.

It is sufficient to block only the empty neighbouring cells of bad people and check the required conditions, which can be done using a bfs on the grid.

Proof:

We will assume there are no adjacent good and bad people since in that case, the answer is "No". There are three cases:

A bad person is adjacent to the cell (n,m). In this case, the cell (n,m) must be blocked. Now no one will be able to escape. If there is at least one good person present, the answer is "No".If after blocking the neighbouring cells of bad people, there is some good person who is not able to escape, then the answer is again "No".Otherwise, the answer is always "Yes". Suppose there is some path from a bad person at cell (i,j) to the cell (n,m). One of the neighbours of this person must be another bad person since the only other case is an adjacent good person (which is already covered above). Extending this, all the cells on the path from (i,j) to (n,m) must have bad people. This is not possible since in this case, there must be a bad person adjacent to (n,m) and this case is already covered above.Time complexity: O(n⋅m)CodeThis problem was prepared by Vivek1998299

1365E - Maximum Subsequence Value

Tutorial1365E - Maximum Subsequence ValueKey Idea:

For subsets of size up to 3, their value is the bitwise OR of all elements in it. For any subset s of size greater than 3, it turns out that if we pick any subset of 3 elements within it, then its value is greater than or equal to the value of s!

Solution:

Let k be the size of the chosen subset. For k≤3, max(k−2,1) is equal to 1. This implies that their value is equal to the bitwise OR of all the elements in it (since we need to add 2i for all i such that at least 1 element in the subset has i-th bit set in its binary representation).

Consider any subset s of size k>3. Let i be any number such that the i-th bit is set in at least k−2 elements of s. If we pick any 3 elements of this subset, then by Pigeonhole principle the i-th bit would also be set in at least one of these elements! If this is not true then the there are 3 elements in s which do not have the i-th bit set, which is not possible.

So for any subset s of size greater than 3, its value is less than or equal to the value of any subset consisting of 3 elements from s. Hence, we only need to check all subsets of size up to 3.

Time complexity: O(n3)CodeThis problem was prepared by Ashishgup and ridbit10

1365F - Swaps Again

Tutorial1365F - Swaps AgainKey Idea:

If we consider the unordered pair of elements {ai,an−i+1}, then after any operation, the multiset of these pairs (irrespective of the ordering of elements within the pair) stays the same!

Solution:

First of all, if the multiset of numbers in a and b are not the same, the answer is "No".

Moreover, if n is odd, it is not possible to change the middle element of a, i.e., a(n+1)/2. So when n is odd and elements at the position (n+1)/2 do not match in a and b, the answer is again "No".

Suppose we pair up the elements at equal distance from the middle element in a (if n is even, the middle element does not exist but we can treat it as the one between positions n/2 and n/2+1). That is, we pair up {ai,an−i+1} (their individual order within the pair doesn't matter). After any operation on a, the multiset of these pairs does not change!

If we swap a prefix of length l with the suffix of length l, then consider any element at position i≤l before the swap. It's new position is n−l+i and the element it was paired with, i.e. the element at position n−i+1 goes to the position l−i+1. (n−l+i)+(l−i+1)=n+1, so these two elements are still paired after the swap.

For example, if a is [1,4,2,3], then the pairs are {1,3} and {2,4} (their individual ordering in the pair doesn't matter). Suppose we first apply the operation on the prefix of length 1 and then the prefix of length 2. After the first operation, a is [3,4,2,1] and after the second operation, a is [2,1,3,4]. Note that in both these arrays, the pairings are still the same, i.e., {1,3} and {2,4}.

We conclude that in any array resulting after some number of operations, these pairings do not change with respect to the initial array. It turns out that all such arrays with same pairings as the initial array can be formed by performing these operations! So we only need to check if the multiset of these pairs in b is the same as the multiset of pairs in a.

Proof:

We will show that given any array b such that the multiset of pairs in b is the same as the multiset of pairs in a, then we can form b from a in atmost ⌊3n2⌋ operations. We will start constructing the pairs in b starting from bn/2 to b1, i.e., we first bring elements bn/2 and bn−n/2+1 to their position in a followed by bn/2−1 and so on.

Note that if we bring the elements bn/2 and bn−n/2+1 to their respective positions in a then we can delete them in both a and b and continue the construction. Suppose we currently want to bring elements bi and bn−i+1 (i≤n/2) to their respective positions in a. If bi is at position j in a, then bn−i+1 must be at the position n−j+1. There are three cases:

If j=n, then we can swap the prefix and suffix of length i in a to achieve this.Otherwise if j=1, then we can first swap prefix and suffix of length 1 and then swap prefix and suffix of length i.Else we can swap prefix and suffix of length j in a and proceed to steps 1 and 2.In atmost 3 steps, we can bring each pair in a to its required position in b. So we need atmost ⌊3n2⌋ operations overall.

Time complexity: O(n⋅logn)CodeThis problem was prepared by FastestFinger, Ashishgup and Vivek1998299

1365G - Secure Password

Tutorial1365G - Secure PasswordKey Idea:

Unlike the last version of the problem, this is not doable using a binary search.

Solution using more queries:

It is possible to solve the problem using 2⋅logn queries in the following way:

For each i, we ask the bitwise OR of all numbers at indices which have the i-th bit set in their binary representation. We also ask the bitwise OR of all numbers at indices which do not have the i-th bit set in their binary representation.

Suppose we want to calculate the bitwise OR of all numbers except the i-th number. Let the bitwise OR be equal to a (initialize a=0). We iterate on all indices j from 1 to n (except i). If j is a submask of i, that is j∧i=j (where ∧ is the bitwise AND operator), then there must be some bit k that is set in i but not in j (since i≠j). In this case we replace a by a∨x where ∨ is the bitwise OR operator and x is the bitwise OR of numbers at indices that do no have the k-th bit set. Similarly, if j is not a submask of i then there must be some bit k which is set in j but not in i. In that case we use the bitwise OR of numbers at indices that have the k-th bit set.

In doing so, we included the contribution of each element except i at least once. Note that this works because taking the bitwise OR with the same number more than once does not affect the answer.

For example, if n=4 and indices are number 0 to 3, then we need to ask 4 queries: {0,2} (bit 0 not set), {1,3} (bit 0 set), {0,1} (bit 1 not set), {2,3} (bit 1 set).

Solution:

Note that in the suboptimal solution, we assigned a bitmask to each index (in that case bitmask for index i was equal to i). What if we assign these masks in a different way?

Suppose we are able to assign the masks in such a way that no two masks assigned to two indices are submasks of each other. In this case, we do not need to ask bitwise OR of indices which do not have the i-th bit set since for each pair of indices, there is a bit which is set in one but not in the other.

For example, if n=4, we can assign masks 1100, 1010, 1001 and 0110 (in binary representation). Now for each bit i, we will only query the indices which have the i-th bit set. In this case, for bit 0 we ask {3}, for bit 1 we ask {2,4}, for bit 2 we ask {1,4} and for bit 3 we ask {1,2,3}. Let x0,x1,x2,x3 be bitwise OR of these four subsets respectively. Then the elements of the password are x0∨x1, x0∨x2, x1∨x2 and x0∨x3 respectively.

What is the minimum number of bits we need to assign masks in such a way?

We are given the bound of 13 queries. There are 1716 numbers upto 213 which have 6 bits set in their binary representation. Clearly no two of these numbers would be submaks of each other. So we can use them to assign the masks!

It can be shown using Sperner's theorem that we need at least 13 queries to assign submaks in the above manner.

Time complexity: O(2q+n⋅q) where q is the number of queries asked.

CodeThis problem was prepared by FastestFinger

Codeforces Round #647 Editorial

By Okrut, history, 3 years ago, In English1362A - Johnny and Ancient Computer

Author: Anadi

Tutorial1362A - Johnny and Ancient ComputerLet us write a as ra⋅2x and b as rb⋅2y, where ra and rb are odd. The only operation we have changes x by {−3,−2,−1,1,2,3} so ra must be equal to rb, otherwise the answer is −1. It is easy to notice that we can greedily move x toward y so the answer is equal to ⌈|x−y|3⌉.

Solution1362B - Johnny and His Hobbies

Authors: Anadi and Okrut

Tutorial1362B - Johnny and His HobbiesConsider i-th least significant bit (0 indexed). If it is set in k, but not in s, it will be set in k⊕s. Hence k⊕s≥2i.

Consider such minimal positive integer m, that 2m>s holds for all s∈S. k cannot have the i-th bit set for any i≥m. From this follows that k<2m. So there are only 2m feasible choices of k. We can verify if a number satisfies the condition from the statement in O(n) operations. This gives us a solution with complexity O(n⋅2m). Note that in all tests m is at most 10.

There is also another solution possible. It uses the observation that if k satisfies the required conditions, then for every s∈S there exists such t∈S (t≠s) , that t⊕s=k. This gives us n−1 feasible choices of k and thus the complexity of this solution is O(n2).

Solution1362C - Johnny and Another Rating Drop

Author: MicGor

Tutorial1362C - Johnny and Another Rating DropLet us start by calculating the result for n=2k. It can be quickly done by calculating the results for each bit separately and summing these up. For i-th bit, the result is equal to 2k2i as this bit is different in d−1 and d iff d is a multiple of 2i. Summing these up we get that the result for n=2k is equal to 2k+1−1=2n−1.

How to compute the answer for arbitrary n? Let us denote b1>b2>…>bk as set bits in the binary representation of n. I claim that the answer is equal to the sum of answers for 2b1,2b2,…,2bk. Why?

We can compute results for intervals [0,2b1],[2b1,2b1+2b2],…,[n−2bk,n]. We can notice that the result for interval [s,s+2i], where s is a multiple of 2i, is equal to the answer for [0,2i] so we can just compute the results for intervals [0,2b1],[0,2b2],…,[0,2bk]!

This allows us to compute the answer for arbitrary n in O(logn) – just iterate over all bits b and add 2b+1−1 if b is set. Equivalently we can just write down 2n−#bits set as the answer.

Final complexity is O(tlogn).

Solution1361A - Johnny and Contribution

Author: Anadi

Tutorial1361A - Johnny and ContributionWe can view blogs as a graph, references as edges, and topics as colors. Now we can reformulate our problem as finding a permutation of vertices such that given in the statement greedy coloring algorithm returns coloring as described in the input.

Let us start with two observations:

Observation 1: If there is an edge between vertices with the same color, then the answer is −1.

Observation 2: If for a vertex u with color c there exist a color c′<c such that u has no edge to any vertex with color c′ then the answer is −1.

Both observations are rather straightforward to prove, so we skip it. Let us create permutation where vertices are sorted firstly by desired color and secondly by indices. We claim that if there exists any ordering fulfilling given regulations, then this permutation fulfills these too. Let us prove it:

Let us analyze vertex u with color c. From observation 2 we know that for each color c′<c there exist v with color c′ such that u and v are connected by an edge. Because vertices are sorted by colors in our permutation, v is before u in ordering. So the greedy algorithm will assign that vertex color k≥c. From observation 1, we now that u does not have an edge to vertex with color c, so the greedy algorithm has to assign to u color k≤c. Combining both inequalities, we reach that greedy must assign color k=c, which completes our proof.

So now the algorithm is rather straightforward – sort vertices by colors, check if that ordering fulfills given regulations, if so, then write it down, otherwise print −1. This can be implemented in O(nlogn) or O(n).

Solution1361B - Johnny and Grandmaster

Author: Okrut

Tutorial1361B - Johnny and GrandmasterThe solution for the case p=1 is trivial, the answer is 1 for odd n and 0 for even n. From now on, I will assume that p>1. Instead of partitioning the elements into two sets, I will think of placing plus and minus signs before them to minimize the absolute value of the resulting expression.

We will process the exponents in non-increasing order and maintain the invariant that the current sum is nonnegative. Say we are processing ki. In such cases, we will know the current sum modulo 109+7 and its exact value divided by pki (denoted as v) or information that it's too big.

Initially, the sum (I will denote it s) equals 0. While processing elements:

If s>0, subtract the current element from the sum (it easy to show that it won't be negative after this operation).

If s=0, add the current element to the sum.

If at any point of the algorithm, v=spki>n, there is no need to store the exact value of v anymore, because it is so big that all the elements from this moment on will be subtracted. Thus, it is enough to store this information and the current sum modulo 109+7.

When we move to the next element, the exponent may change, and v needs to be multiplied by a power of p. Since the exponents can be large, we use fast multiplication.

The time complexity of this solution is O(nlogn+nlogmaxki).

Solution1361C - Johnny and Megan's Necklace

Author: Okrut

Tutorial1361C - Johnny and Megan's NecklaceSay that we want to check if it is possible to construct a necklace with beauty at least b. To this end, we will construct a graph of 2b vertices. For a necklace part with pearls in colors u and v there will be an edge in this graph between vertices with zero-based indices v & (2b−1) and u & (2b−1). In a necklace with beauty (at least) b, only pearl with colors having last b bits the same can be glued together. Note that this is the exact condition that the edge endpoints have to satisfy to be in the same vertex. Since all the necklace parts have to be used, a necklace of beauty at least b is an Euler cycle of this graph.

The solution will construct the graph mentioned above for all possible values of b (we can iterate over all of them since there are only 21 of them). If the constructed graph is Eulerian, it is possible to achieve the current value of b.

In order to find a sample necklace with the optimal beauty, one has to find the Euler cycle in the graph corresponding to the optimal value.

Challenge: In another version of this task you are not allowed to glue pearls of the same color together. There is also a guarantee that there are no three pearls of the same color. Time complexity of the solution is the same.

Solution1361D - Johnny and James

Author: Okrut

Tutorial1361D - Johnny and JamesWe can easily model the way of calculating distances from the problem statement as a tree with n vertices, each corresponding to a base. This tree has the following structure: there is only one vertex which can have degree bigger than 2 (the one corresponding to the central base), I will call it the center of the tree. There are also some paths consisting of vertices corresponding to bases lying on the same half-line starting at point (0,0). We will call those arms of the tree. Assume that the center does not belong to any arm.

The task is to choose k vertices in a way that maximizes the sum of distances between them. Let us start with a lemma:

If x vertices are chosen from an arm, at least min(x,⌊k2⌋) of them are the ones furthest from the center.

Say that less than min(x,⌊k2⌋) is chosen from the end of the arm (counting from the center). Then there exists such chosen vertex v on the arm, that the next (counting from the center) vertex u is not chosen. Let the length of the edge between them be l and let there be t vertices further from the center than v. If we had chosen u instead of v, the sum of distances would change by l⋅(k−t−1)−l⋅t=l⋅(k−2t−1) (the chosen vertex would move closer by l to t vertices, but also it's distance to k−t−1 vertices would increase by l). But since t<k2, this value is non-negative (the sum of distances would not decrease).

There are two cases which will be solved independently:

First case: there is no arm containing more than k2 vertices chosen. By the lemma, in every arm, only vertices furthest from the center will be selected in an optimal solution.

If a vertex is chosen, all the ones in the same arm further from the center are chosen as well. Using this knowledge, we can assign weights to vertices in such a way that the result for a set will be the sum of weights. Weight for vertex v equals: wv=dist(center,v)∗(k−1−t−t) where t is the number of vertices further from center in the same arm as v. The weight of the center equals 0. Note that (with exception to the center) wv≤0 iff taking v would violate the condition that at most k2 are chosen from every arm.

The algorithm for this case is to add the vertices greedily to the set until k vertices have been chosen. The complexity of the above algorithm is O(nlogn).

Second case: there is an arm, in which more than k2 vertices are chosen in the optimal solution.

From the lemma, we know that ⌊k2⌋ vertices lying furthest from the center will be chosen. It can be proved (in a similar manner as the lemma) that in an optimal solution, all other selected vertices from this arm will be as close to the center as possible. Furthermore, the center and all the vertices in the other arms will be selected. Intuitively, when there are ⌊k2⌋ chosen vertices on a single-arm, we will not decrease the sum of distances by moving another selected vertex further from them along an edge.

There is at most one set of k vertices satisfying those conditions so that this part can be implemented in O(n).

The time complexity of this solution is O(nlogn).

Solution1361E - James and the Chase

Author: Anadi

Tutorial1361E - James and the ChaseFirst, let us describe an algorithm for checking if a vertex is interesting. Let v be the vertex we want to check. Find any DFS tree rooted in that vertex. We can see that v is interesting if and only if that tree is unique. The tree is unique iff every non-tree edge leads from some vertex u to u's ancestor. That condition can be easily checked in O(n).

Using the fact that we are interested only in cases when at least 20% of vertices are interesting, we can find any interesting vertex by choosing a random vertex, checking if it is interesting and repeating that algorithm T times or until we find an interesting vertex. For T=100 the probability of failure is around 2⋅10−10.

Denote that vertex as r. Find the DFS tree rooted in that vertex. We can notice that vertex is interesting if and only if it has a unique path to all of its ancestors in this tree. We will say that edge is passing vertex v if it starts in its subtree (including v) and ends in one of the proper ancestors of v. It is evident that if two edges pass through v, then v cannot be interesting.

Let us pick vertex v such that there is at most one edge passing through it. It is evident that if v≠r, then there is at least one such edge (because our graph is strongly connected). Let u be the endpoint of this edge being a proper ancestor of v. We prove that v is interesting if and only if u is interesting.

Pick arbitrary ancestor of v which is not an ancestor of u, let us denote it by t. There is precisely one simple path from v to t – descending in the subtree of v, using the non-tree edge to u and then tree edges to reach t.

Now pick arbitrary common ancestor of v and u, let it be k. If there is more than one simple path from u to k, then obviously there is more than one simple path from v to k. Otherwise, there is precisely one simple path from v to k – descend in the subtree, use edge to u and from u there is one simple path to k.

The above observations allow computing interesting vertices using simple DFSs. The final complexity is O(Tn).

Solution1361F - Johnny and New Toy

Author: Anadi

Tutorial1361F - Johnny and New ToyLet us start with an analysis of good subsegments for the fixed permutation. The whole permutation is a good subsegment itself, as W0=Wn=0<Wk for any k∈[1,2,…,n−1]. If we denote the minimal weight in W1,…,Wn−1 as Wm, then we can notice that subsegments [1,m] and [m+1,n] contain all good subsegments except the whole permutation. As a result, we can recursively find all good subsegments by recursive calls in [1,m] and [m+1,n]. We can view the structure of good subsegments as a binary tree.

Example structure of tree for P=[3,4,6,2,1,5] and W=[5,2,3,1,4]:

Now we want to analyze the possible moves for players. It turns out that the player's move is equivalent to choosing a vertex of a tree and swapping its left and right subtree. Notice that moves made in different vertices influence disjoint pairs of elements, so in some sense these moves are independent if we are interested only in the number of inversions. This observation allows us to find a simple method for calculating the result. For each vertex, calculate the number of inversions between the left and right subtree. Using these numbers for each vertex, we can find out whether we want to swap its subtrees or not, so the result can be calculated by a simple loop over all vertices.

From randomness of the input, we can deduce that the tree we built has height O(logn). We can calculate the number of inversions easily if in each vertex we keep a structure with elements from permutation contained in that vertex. Such structure must support querying the number of elements smaller than some x. The shortest implementation uses the ordered set, but any BST can do it (segment tree needs some squeezing to fit into ML).

The above solution works fast if there are no queries. We can view each request as two removals and additions of elements. If so, we can notice that each query modifies the number of inversions in at most O(logn) vertices. So all we need to do is update the number of inversions in these vertices and recalculate the global result.

Building a tree and calculating initial number of inversions takes O(nlogn) or O(nlog2n), answering each query cost O(log2n), so the final complexity is O(nlogn+qlog2n).

Solution

Editorial — Codeforces Round #646

By TheOneYouWant, history, 3 years ago, In EnglishHello, everyone! It was a delight for us to have you participate in our contest. We hope you enjoyed the problems! Here, we present to you the solutions of the problems. I have also prepared some memes for you to enjoy — disclaimer: not all of them were created by me.

1363A - Odd SelectionKey Idea: The sum of x numbers can only be odd if we have an odd number of numbers which are odd. (An odd statement, indeed).

Detailed Explanation: We first maintain two variables, num_odd and num_even, representing the number of odd and even numbers in the array, respectively. We then iterate over the number of odd numbers we can choose; which are 1,3,5,... upto min(num_odd,x), and see if num_even ≥x−i where i is the number of odd numbers we have chosen.

Time complexity: O(N)Author of this problem was Ashishgup.

Relevant MemeCode for A1363B - Subsequence HateKey Idea: There are two types of good strings: Those which start with a series of 1's followed by 0's (such as 1111100) and those which start with a series of 0's followed by 1's (such as 00111). Note that there are strings which do belong to both categories (such as 000).

Detailed Explanation: We will use the key idea to compute the minimum change required to achieve every possible string of each of the two types, and then take the minimum across them.

First, let us compute the total number of 1's and 0's in the string, denoted by num_ones and num_zeros. Now, as we iterate through the string, let us also maintain done_ones and done_zeros, which denote the number of 1's and 0's encountered so far.

Let us iterate through the string. When we are at position i (indexed from 1), we want to answer two questions: what is the cost for changing the string into 11..000 (where number of 1's = i) and what is the cost for changing the string into 00..111 (where number of 0's = i).

Assuming that done_zeros and done_ones also consider the current index, the answer to the first question is done_zeros + num_ones - done_ones. This is because done_zeros 0's must be converted to 1's, and num_ones - done_ones 1's must be converted to 0's. Similarly, the answer for the second question is done_ones + num_zeros - done_zeros.

The answer is the minimum over all such changes possible. Please do not forget to consider the all 1's and all 0's string in the above solution.

Time Complexity: O(N)Author of this problem was Ashishgup.

Relevant MemeCode for B1363C - Game On LeavesKey Idea: The main idea of this problem is to think backwards. Instead of thinking about how the game will proceed, we think about how the penultimate state of the game will look like, etc. Also, we take care of the cases where the game will end immediately (i.e, when the special node is a leaf node).

Detailed Explanation: First, let us take care of the cases where the game ends immediately. This only occurs when the special node x is a leaf node, so all we must do is check that deg[x] = 1. Please note that n=1 must be handled seperately here (just output Ayush).

Now, in the case where x is not a leaf node, the answer is as follows: Ashish wins if n is odd, and Ayush wins if n is even. I will provide a short sketch of the proof below.

With the hint from the key idea, let us analyze this game backwards. (I will assume that n>10 for the sake of a clear explanation). When x is removed from the game, it cannot be the only node remaining (because then the previous player could have also removed x, and thus he did not play optimally). Assume the structure of the game is something like the following WLOG at the last step (The tree attached to x could be any tree):

Consider also that Ayush won, and the last move was to remove x. Now, what could have been the state before this move? If Ashish had removed a node from the tree, then he did not play optimally - since he could have removed x! Thus, he must have removed something from x, which looks like the following:

Considering this state, Ashish should not infact remove 6, and instead remove something from the tree! Hence, the state that we assumed the game should look like at the end is impossible - and indeed, the tree attached to x should only consist of only one node (we already proved that x cannot be the only node remaining).

Thus, all we have to do is find who's turn it will be when the structure of the tree is as follows:

It is Ashish's turn if n is odd, and Ayush's turn if n is even. QED!

Time complexity: O(N)Author of this problem was TheOneYouWant.

Relevant MemeCode for C1363D - Guess The MaximumsKey Idea: The maximum of the array is the password integer for all except atmost 1 position. We find the subset (if the maximum is in a subset) in which the maximum exists using binary search, and then query the answer for this subset seperately. (For all the subsets, the answer is the maximum for the whole array).

Detailed Explanation: I will be working with an example in this explanation; let the array be a=[1,1,2,3,2,5,7,8,9,11,4], and array of length 11, and let there be 10 subsets, with first subset being [1], second being [2], etc (every index except 11 is a subset). Thus, a[1]=1,a[3]=2, etc.

First, let us query the maximum of the whole array using 1 query. This gives 11 as the output in our case.

Now, we check if the maximum is present in the subsets. We do this in the following manner: we query the first half of the subsets. If the value returned here is not the maximum, then we search in the second half - else, we know that the maximum must be in the first half of subsets. Hence, we binary search in the first half itself.

To proceed with our example, we query the maximum from subsets 1 to 5, which turns out to be 3. Thus, 11 must be present in subsets 6 to 10. Then we will query 6 to 8, which will return the value 8 - thus, the maximum may be present in subset 9, or 10. Thus, we query subset 9 and find that it does not contain the maximum. This step will require at most 10 queries, and we will get a subset which (may or may not) contain the maximum element (remember, it is possible that the maximum element was not in any subset!)

Thus, in our final query we ask about the maximum over all indices other than the canditate subset we found above. In our example, We query every index except those in subset 10 using 1 query, which gives us the answer as 9. Hence, the password is [11,11,11,11,11,11,11,11,11,9].

Note: The bound of 12 queries is tight.

Time complexity: O(N)Author of this problem was FastestFinger.

Relevant MemeCode for D1363E - Tree ShufflingKey Idea: Let the parent of node i be p. If a[i]≥a[p], we can do the shuffling which was done at i, at p instead. Thus, we can do the operation a[i]=min(a[i],a[p]).

Detailed Explanation: Let us denote nodes that have bi=1 and ci=0 as type 1, and those that have bi=0 and ci=1 as type 2. Firstly, the answer is −1 if and only if the number of nodes of type 1 and type 2 are unequal.

We also observe that only nodes of type 1 and 2 should be shuffled - it is unoptimal to shuffle those which already have b[i]=c[i]. Thus, we should try to exchange the values of type 1 and type 2 nodes.

We use the key idea by going down from the root, and at every node i, setting a[i]=min(a[i],a[p]) where p is the parent node of i in the tree. Thus, the a[i]'s now follow a special structure: they are non-increasing from the root to the leaves!

This paves the way for our greedy solution: we will go upwards from the leaves, and at each node i interchange type 1 and type 2 nodes until we have no nodes in one of these types. Then, we pass on the remaining nodes to the parent to be shuffled.

Time complexity: O(N)Author of this problem was Ashishgup.

Relevant MemeCode for E1363F - Rotating SubstringsKey Idea: We note that a clockwise rotation is the same as taking a character at any position in the string, and inserting it anywhere to it's left. Thus, we process the strings from the end, build the suffixes and move towards the prefix.

Detailed Explanation: The answer is −1 if both s and t do not have the same count of every character. Else, we can prove that it is always possible to convert s to t.

Now, let us remove the largest common suffix of both s and t. Now, using the key idea, we consider a move as picking a character at any position in s and inserting it to it's left. So, let us just "pick up" characters, and use them in any order as we iterate through s. Our total cost is equal to the number of characters we picked overall.

After removing common suffixes, suppose the last character of s is c. Since the last characters of s and t differ, we can pick up this c. Now, we want to make s[1,n-1] equal to t[1,n], given that we can insert c anywhere in s.

Let us consider dp[i][j] (only for when j ≥ i, which means that we want to make s[1,i] = t[1,j] by inserting some characters that we have picked. What characters can we pick? We can pick the characters whose count in s[i+1,n] > t[j+1,n]. The base case is dp[0][i] = 0. Now, let us write the transitions for this dp solution. Suppose that t[j] = x. There are three possible transitions from dp[i][j]:

If the count of x in s[i+1.n] is greater than it's count in t[j+1,n], then we can reach the state dp[i][j-1].If s[i] = t[j], then we can reach the state dp[i-1][j-1].We can pick up the character at position i (and insert it later) to reach dp[i-1][j] (with an additional cost of 1).The final answer is dp[n][n].

Time complexity: O(N2)Author of this problem was FastestFinger.

Relevant MemeCode for F

Codeforces Round #645 (Div. 2) Editorial

By crazyilian, 3 years ago, translation, In EnglishThis is our first contest for the three of us (Alexdat2000, crazyilian, sevlll777), so we would like to share our impressions of creating this contest. Check it if you want to!

ROUND LOGAnd, of course, here's the tutorial of the round.

1358A - Park LightingIdea: Alexdat2000

PictureTutorial1358A - Park LightingNote that if at least one of the sides is even, the square can be divided into pairs of neighbors and the answer is nm2.

If both sides are odd, we can first light up a (n−1)×m part of the park. Then we'll still have the part m×1. We can light it up with m+12 lanterns. Then the total number of the lanterns is (n−1)⋅m2+m+12=nm−m+m+12=nm+12.

Note that both cases can be combined into one formula: ⌊nm+12⌋.

The overall compexity is O(1) per test.

Solution1358B - Maria Breaks the Self-isolationIdea: crazyilian

PictureTutorial1358B - Maria Breaks the Self-isolationLet x be the maximum number of grannies that can go out to the yard. Then if Maria Ivanovna calls them all at the same time, then everyone will see x grannies. Since x is the maximum answer, then each granny of them satisfy ai≤x (otherwise there's no way for these grannies to gather in the yard), that is, such call is correct. So it is always enough to call once.

Note that if you order grannies by ai, Maria Ivanovna will have to call x first grannies from this list. She can take x grannies if ax≤x (otherwise, after all x grannies arrived, the last one will leave). To find x we can do a linear search.

The overall compexity is O(nlogn) per test.

Solution1358C - Celex UpdateIdea: crazyilian

PictureTutorial1358C - Celex UpdateLet's look at the way with the minimum sum (first we go y2−y1 steps right, and then x2−x1 steps down). Let's look at such a change in the "bends" of the way:After each step, the sum on the way will increase by 1.

We're going to bend like this until we get to the maximum sum. We're not going to miss any possible sum, because we're incrementing the sum by 1. We started with the minimum sum and finished with the maximum sum, so we can use these changes to get all possible sums.

In order for us to come from the minimum to the maximum way, we must bend the way exactly 1 time per each cell of table (except for the cells of the minimum way). That is, the number of changes equals the number of cells not belonging to the minimum way — (x2−x1)⋅(y2−y1). Then the number of different sums will be (x2−x1)⋅(y2−y1)+1.

The overall compexity is O(1) per test.

Solution1358D - The Best VacationIdea: sevlll777

PictureTutorial1358D - The Best VacationWe will double the array of days and solve the problem when the day vacation starts and the day it ends is always in the same year. Then a is an array of number of days in each of the months.

Consider array B=[1,2,...,a1]+[1,2,...,a2]+...[1,2,...,an]+[1,2,...,an]. Our task is to find a subsection of length k with the maximum sum in it. Further we will call this segment optimal.

Statement: We will find such an optimal segment that its end coincides with the end of some month.

Proof by contradiction: Pretend that's not the case. Consider the rightmost optimal segment. Let its last element be x, then the next one is x+1, otherwise x coincides with ai. Note that if we move this segment to the right, the sum must be reduced, which means that the first element of the segment >x+1. Then its left neighbor >x. It means that you can move the segment by 1 to the left so that the sum increases. So, the chosen segment is not optimal. Contradiction. (see picture)



Solution: now we just need to go through all the possible ends of the segment, which are only O(n). Let's build two arrays of prefix sums:

ci=a1+a2+...+aidi=a1(a1+z)2+...+ai(ai+1)2ci is responsible for the number of days before the i-th month, and di is responsible for the sum of numbers of all days before the i-th month.

For each of the n ends, let's make a binsearch to find which month contains its left border (k days less than the right one). You can use array ci to check whether the left border lies to the left/in the block/to the right, and use array di to restore the answer.

The overall compexity is O(nlogn).

Solution1358E - Are You Fired?Idea: sevlll777 и crazyilian

PictureTutorial1358E - Are You Fired?Let's call the value of all elements in the second half of the array x.

Let si=ai+ai+1+…+ai+k−1 — the reported incomes.

Pretend there exists such a k that k≤n2. Consider the following reported incomes: si and si+k. Notice that if we double k, the i-th reported income will be equal to si+si+k. si>0 and si+k>0 imply si+si+k>0. It means that after doubling k, the new value will still be correct  ⟹  if some k exists, there's also k>n2.

Now, let's notice that si+1=si+(ai+k−ai).

It means we can think of si as prefix sums of the following array:p=[s1, ak+1−a1, ak+2−a2, …, an−an−k].As k>n2, ak+j=x holds for j≥0, so, actuallyp=[s1, x−a1, x−a2, …, x−an−k].

How is this array changed when we increment k by 1?pnew=[s1+ak+1, ak+2−a1, ak+3−a2, …, an−an−k−1], which equals [s1+x, x−a1, x−a2, …, x−an−k−1].So, when you increase k by 1, the first element is changed, and the last element is removed — and that's it.

Recall that si=p1+p2+…+pi. Notice that the minimum reported income (some number from s) doesn't depend on the first element of p because it's a term of all sums (s1,s2,…). For example, if p1 is increased by 1, all si are increased by 1 too. So, let's calculate the following array m:mi=min(s1−p1,s2−p1,…,si−p1)=min(0,p2, p2+p3, …, p2+…+pi).This can be done in O(n).

Notice that this array is the same for all k, except its size. So, it's obvious that the minimum reported income for a particular k is p1+mn−k+1=a1+…+ak+mn−k+1. So, we can just check if this number is greater than 0 for some k.

We can calculate prefix sums and m in O(n), so the overall complexity is O(n).

Solution1358F - Tasty CookieIdea: sevlll777 и crazyilian

PictureTutorial1358F - Tasty CookieLet's define a few operations and constants:

pref — replace an array with its prefix sums arrayreverse — reverse an arrayrollback — restore the original array from a prefix sums arrayC — the array values upper bound — 1012First, we can prove that rollback is unambiguosly defined for strictly increasing arrays. Consider an array X. Let Y be the prefix sums array of X. Notice that X0=Y0, Xi=Yi−Yi−1 (for i>1). Thus we can restore X from Y. Note that if we apply rollback to an array for which Yi>Yi−1 doesn't hold, the resulting array will have a non-positive element which is forbidden by the statements.

Now let's analyze how many pref operations can theoretically be applied for arrays of different lengths (let's call their count t) (We can do that by applying pref to array [1,1,...,1] while all numbers are below C):



It's obvious that we'll need no more than t rollbacks for an array of length n. It can also be proved that t=O(C⋅(n−1)!−−−−−−−−−√n−1).

Let's restore the array B in steps. One each step we have several cases:

If B equals A or reverse(A), we know how to get A from B.If B is strictly increasing, apply rollback.If B is strictly decreasing, apply reverse.Otherwise, the answer is "impossible".This solution will run infinitely when n=1 and A≠B, so the case when n=1 has to be handled separately.

The asymptotic of this solution is O(n⋅ans). Notice that ans≤2t+1 because we can't have two reverse operations in a row. It means this solution will fit into TL for n≥3, but we need a separate solution for n=2.

Consider an array [x,y]. If we rollback it while x<y, the array will be transformed into [x,ymodx]. It means we can rollback several iterations at once.

So, the solution for n=2 is:

First sort A and B so that they both increase (and take this into account when printing answer)Now start the rollback loop:If B1=A1, we can break the loop if (B2−A2)modB1=0, otherwise the answer is "impossible".If B1≠A1, we can calculate how many rollback operations we should apply to transform B=[x,y] into [x,ymodx], modify the answer accordingly and jump to the next iteration for B=[ymodx,x] (after applying one reverse operation).This algorithm is very similar to the Euclidian's algorithm, and that's how we can prove there will be O(logC) rollbacks.

The overall complexity is O(n⋅ans) for n>2; O(logC) for n=2.

Solution by Alexdat2000Solution by Alivk06 (much shorter)Thank you, everyone, for participating in the round! We hope you've raised your rating! And if you haven't, don't be sad, you'll do it!

Codeforces Round #644 (Div. 3) Editorial

By Stepavly, 3 years ago, translation, In EnglishAll problems were invented by MikeMirzayanov and developed by me, Stepavly, and Supermagzzz.

1360A - Minimal Square

Editorial1360A - Minimal SquareObviously that both rectangles should completely touch by one of the sides. Otherwise, you can move them closer to each other so that the total height or total width decreases, and the other dimension does not change. Thus, there are only two options:

The rectangles touch by width, we get the side of the square equal to max(2b,a),The rectangles touch by height, we get the side of the square equal to max(2a,b).Thus, the minimum side of the square is equal to the minimum of these two options. Then the answer is (min(max(2b,a),max(2a,b)))2.Solution1360B - Honest Coach

Editorial1360B - Honest CoachLet's found two athletes with numbers a and b (the strength of a is not greater than the strength of b), which have the minimal modulus of the difference of their strength. Obviously, we cannot get an answer less than this. Let's show how to get the partition with exactly this answer.

Sort all athletes by strength. Our two athletes will stand in neighboring positions (otherwise, we can decrease the answer). Let the first team contains all athletes who stand on positions not further than a, and the second team contains other athletes. We got a partition, in which the athlete with number a has the maximal strength in the first team, and the athlete with number b has the minimal strength in the second team.

Solution1360C - Similar Pairs

Editorial1360C - Similar PairsLet e — be the number of even numbers in the array, and o — be the number of odd numbers in the array. Note that if the parities of e and of o do not equal, then the answer does not exist. Otherwise, we consider two cases:

e and o — are even numbers. Then all numbers can be combined into pairs of equal parity.e and o — are odd numbers. Then you need to check whether there are two numbers in the array such that the modulus of their difference is 1. If there are two such numbers, then combine them into one pair. e and o will decrease by 1 and become even, then the solution exists as shown in the previous case.Solution1360D - Buying Shovels

Editorial1360D - Buying ShovelsIf Polycarp buys a packages of b shovels and gets exactly n shovels in total, then a⋅b=n, that is, a and b are divisors of n. Then the problem reduces to the following, you need to find the maximum divisor of the number n not greater than k. To do this, iterate over all the numbers x from 1 to n−−√ inclusive and check whether n is divisible by x. If so, then x and nx — are both divisors of n and you can use them to try to improve the answer.

Solution1360E - Polygon

Editorial1360E - PolygonLet's see how the matrix looks like after some sequence of shoots:

The matrix consists of 0, orThere is at least one 1 at position (n,i) or (i,n), and any 1 not at position (n,j) or (j,n) must have 1 below or right.If the second condition is violated, then the 1 in the corresponding cell would continue its flight. Thus, it is necessary and sufficient to verify that the matrix satisfies the condition above.

Solution1360F - Spy-string

Editorial1360F - Spy-stringConsider all strings that differ from the first one in no more than one position (this is either the first string or the first string with one character changed). We will go through all such strings and see if they can be the answer. To do this, go through all the strings and calculate the number of positions where they differ.

Solution1360G - A/B Matrix

Editorial1360G - A/B MatrixLet's see how the desired matrix looks like. Since each row should have exactly a ones, and each column should have exactly b ones, the number of ones in all rows a⋅n should be equal to the number of ones in all columns b⋅m. Thus, the desired matrix exists iff a⋅n=b⋅m or nm=ba.

Let's show how to construct the desired matrix if it exists. Let's find any number 0<d<m such that (d⋅n)%m=0, where a%b — is the remainder of dividing a by b. In the first row of the desired matrix, we put the ones at the positions [1,a], and in the i-th row we put the ones, as in the i−1 row, but cyclically shifted by d to the right.

Solution1360H - Binary Median

Editorial1360H - Binary MedianIf we did not delete the strings, then the median would be equal to the binary notation of 2(m−1). After deleting n strings, the median cannot change (numerically) by more than 2⋅n.

Let's start with the median 2(m−1) and each time decrease it by one if there are fewer not deleted smaller numbers than not deleted large numbers. Similarly, you need to increase the median by one, otherwise. The algorithm stops when the result is the median of the current set. All these steps will run at most 200 times.

Solution

Codeforces Round #643 (Div. 2) Editorial

By DishonoredRighteous, history, 3 years ago, In English1355A - Sequence with DigitsLet's calculate the sequence for fixed a1=1: 1,2,6,42,50,50,50,…We got lucky and the minimal digit has become 0, after that the element has stopped changing because we always add 0.

Actually it is not luck and that will always happen. Note that we add no more than 9⋅9=81 every time, so the difference between two consecutive elements of the sequence is bounded by 81. Assume that we will never have minimal digit equal to 0. Then the sequence will go to infinity. Let's take X=1000(⌊a11000⌋+1). All the numbers on segment [X;X+99] have 0 in hundreds digit, so none of them can be element of our sequence. But our sequence should have numbers greater than X. Let's take the smallest of them, it should be at least X+100. But then the previous number in the sequence is at least (X+100)−81=X+19. It is greater than X but smaller than the minimal of such numbers. Contradiction.

In the previous paragraph we have actually shown that we have no numbers greater than X+100 in our sequence and we will see the number with 0 among first 1001 elements.

That means that we can build the sequence till we find the first number with 0 and then it will repeat forever.

In reality the maximal index of the first elements with 0 is 54 and minimal a1 for that to happen is 28217.

Author's solution: 80407149

1355B - Young ExplorersLet's sort all the explorers by non-decreasing inexperience. Suppose we have formed some group, how can we check is this group is valid? Inexperience of all the explorers in the group should be not greater than the group size. But we have sorted all the explorers, so the last explorer from the group has the largest inexperience. Therefore, to check the group for validity it is necessary and sufficient to check that inexperience of the last explorer is not greater than the group size.

We can notice that we don't even look at all the explorers except the last one, the only important thing is their number. In fact, we can organize the creation of groups in this way: first choose the explorers that will be the last in their groups, then assign sufficient number of other explorers to corresponding groups. It is not profitable to assign more explorers than needed for this particular last explorer, because we can always leave them at the camp.

So how should we choose the last explorers? We want to make more groups, so the groups themselves should me smaller... It is tempting to use the following greedy algorithm: let's greedily pick the leftmost (which means with the smallest necessary group size) explorer such that they have enough explorers to the left of them to create a valid group. The idea is that we spend the smallest number of explorers and leave the most potential last explorers in the future. Let's strictly prove this greedy:

The solution is defined by positions of the last explorers in their corresponding groups 1≤p1<p2<…<pk≤n. Notice that the solution is valid if and only if ep1+ep2+…+epi≤pi for all 1≤i≤k (we always have enough explorers to form first i groups).

Let 1≤p1<p2<…<pk≤n be the greedy solution and 1≤q1<q2<…<qm≤n be the optimal solution such that it has the largest common prefix with greedy one among all optimal solutions. Let t be the position of first difference in these solutions. t≤k since otherwise the greedy algorithm couldn't add one more group but it was possible. pt<qt since otherwise the greedy algorithm would take qt instead of pt. Since the explorers are sorted we have ept≤eqt. But then 1≤q1<q2<…<qt−1<pt<qt+1<…<qm≤n is a valid optimal solution and it has strictly larger common prefix with the greedy one which contradicts the choosing of our optimal solution.

To implement this solution it is enough to sort the explorers by the non-decreasing inexperience, then go from left to right and maintain the number of unused explorers. As soon as we encounter the possibility to create a new group, we do it.

Author's solution: 80407200

1355C - Count TrianglesSince x≤y≤z to be a non-degenerate triangle for given triple it is necessary and sufficient to satisfy z<x+y. Let's calculate for all s=x+y how many ways there are to choose (x,y). To do that we will try all x and add 1 on segment [x+B;x+C] offline using prefix sums. Let's calculate prefix sums once more, now we can find in O(1) how many ways there are to choose (x,y) such that their sum if greater than z. Try all z, calculate the answer. Total complexity — O(C).

Author's solution using formulas: 80407222

Author's solution using prefix sums: 80407239

1355D - Game With ArrayFor S≥2N Petya wins: let's take array [2,2,…,2,S−2(N−1)] and K=1. All the elements are strictly greater than 1, so there are no segment with sum 1 or S−1.

Let's prove that for S<2N Petya will lose. Suppose it is not true and there exist an array and K>0 (it is obvious that K=0 is bad). Note that the condition that there is a segment with sum K or S−K is equivalent to the condition that there is a segment with sum K in cyclic array. Let's calculate prefix sums for our array, and for prefix sum M let's mark all the numbers of the form M+TS for integer T≥0. It is easy to see that numbers X and X+K cannot be marked simultaneously: otherwise there is a segment with sum K in a cyclic array. Let's consider half-interval [0;2KS). It is clear that exactly 2KN numbers are marked on this half-interval. On the other hand, we can split all the numbers from this half-interval into KS pairs with difference K: (0,K),(1,K+1),…,(K−1,2K−1),(2K,3K),(2K+1,3K+1),…(2KS−K−1,2KS−1). In every such pair no more than one number is marked, so the total number of marked numbers is bounded by KS. Therefore 2KN≤KS which means 2N≤S. Contradiction.

Author's solution: 80407273

1355E - Restorer DistanceFirst of all let's do M=min(M,A+R) — this is true since we can emulate moving by adding+removing. After that it is never profitable to add and remove in one solution, since we can always move instead.

Suppose we have fixed H — the resulting height for all pillars. How can we calculate the minimal cost for given H? Some pillars have no more than H bricks, let the total number of missing bricks in these pillars be P. Other pillars have no less than H bricks, let the total number of extra bricks in these pillars be Q. If P≥Q then we are missing (P−Q) bricks in total, so we have to make (P−Q) additions. There won't be any more additions or removals, and we have to do at least Q moves since we have to somehow get rid of extra bricks from those pillars which have more than H bricks initially. It is clear that Q moves is enough. Therefore the total cost will be C=A(P−Q)+MQ. Similarly, if Q≥P then the total cost will be C=R(Q−P)+MP.

Let's now assume that P≥Q, we have exactly X pillars with no more than H bricks and exactly N−X pillars with strictly more than H bricks. Let's try to increase H by 1 and see how the total cost will change. P′=P+X, Q′=Q−(N−X)=Q−N+X. C′=A(P′−Q′)+MQ′=A(P+X−Q+N−X)+M(Q−N+X)=A(P−Q)+MQ+AN−M(N−X). We can see that the total cost has changed by AN−M(N−X). While X is constant the cost change will be constant. What are the moments when X changes? When H is equal to the initial height of some pillar. Therefore the cost as a function of H is piecewise linear with breakpoints in points corresponding to initial heights.

There is a nuance — we have assumed P≥Q. The same thing will be true for P≤Q but there can be additional breakpoints when we change between these two states. This change will happen only once for H≈∑hiN (approximate equality here means that this point can be non-integral so we should add both ⌊∑hiN⌋ and ⌈∑hiN⌉ as breakpoints).

The minima of piecewise linear function are in breakpoints so it is enough to calculate the cost for breakpoints (initial heights and H≈∑hiN) and choose minimal of them.

To calculate the cost for given H fast we can sort the initial heights and calculate prefix sums of heights. Then using binary search we can determine which pillars have height less than H and greater than H and then calculate P and Q using prefix sums. We can use two pointers instead of binary searches but it will not improve the total complexity which is O(NlogN) due to sorting (and binary searches if we are using them).

Author's solution: 80407303

Author's solution using ternary search: 80407326

1355F - Guess Divisors CountIf X=pα11⋅pα22⋅…⋅pαkk then d(X)=(α1+1)⋅(α2+1)⋅…⋅(αk+1).

If X has prime p in power α and Q has p in power β then gcd(X,Q) will have p in power γ=min(α,β). If γ<β then α=γ, otherwise γ=β and α≥γ. We don't know X, but we can choose Q. If we'll choose Q with known prime factorization then we'll be able to extract all the information from query fast (in O(logQ)).

After all the queries for each prime p we'll know either the exact power in which X has it, or lower bound for it. We can get upper bound from the fact that X≤109.

It is clear that we cannot get information about all primes — there are too many of them and too few queries. We want to somehow use the fact that we don't have to find the exact answer...

Suppose we have figured out that X=X1⋅X2 where we know X1 exactly and we also know that X2 has no more than t prime factors (including multiplicity). Then d(X1)≤d(X)≤d(X1)⋅d(X2)≤d(X1)⋅2t. If t≤1 then our answer will have relative error no more than 0.5...

One of the ways to guarantee that X2 has few prime factors is to show that it cannot have small prime factors. That means that we have to calculate the exact power for all small primes. This gives an overall idea for the solution: let's make a query Q=pβ for all primes p≤B (for some bound B) where β is chosen in such a way that pβ>109. This allows us to know the exact power in which X has p.

This basic idea can be improved in several ways:

X has no more than 9 different prime factors, so for most primes its power is 0. If we could exclude these redundant primes fast it could speed up the solution significantly. And there is a way: we could make a query Q=p1p2…ps for s different primes, after that we will know which of them are factors of X;β can be chosen such that pβ+1>109, because even if γ=β and α≥γ=β we will know that α≤β since otherwise X>109;From the previous point follows that we can find the exact power for two primes simultaneously, just make a query with a product of two respective numbers.How to choose B? Apparently we want B2>109. But actually t≤2 is ok for us: if we know that L≤d(X)≤4L then we can answer 2L and the relative error will be no more than 0.5. That means we want B3>109 or B=1001.

We are close: there are 168 primes less than 1001, we can check 6 primes (for being a factor of X) in one query since 10006≤1018, so we need 28 queries.

Let's note that if we have found some prime factors of X (let's say their product is X1) then X2≤109X1. Suppose we have checked all the primes not greater than p and X1⋅p3>109. That means that X2 has no more than 2 prime divisors and we are good.

What is left is to use our right to have absolute error: if X1≤3 we can just print 8! Either X1≤3 and we are fine with X2 having 3 prime factors, or X1≥4 and we have to check all primes up to 109/4−−−−−√3<630. There are 114 such primes, so we need only 19 queries.

We will also need some queries to find out the exact power for those small prime factors of X we have found. If we have found no more than 2 prime factors, we'll need 1 query, otherwise we'll have to check primes only up to 109/(2⋅3⋅5)−−−−−−−−−−−√3<330, of which there are only 66 so the first part of the solution spends no more than 11 queries.

So we have shown that the solution spends no more than 20 queries. We did some rough estimations, the actual bound for this solution is 17 queries.

Author's solution: 80407360

Codeforces Round #642 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishAll problems, except the problem D, are mine. The problem D author is MikeMirzayanov.

1353A - Most Unstable Array

Tutorial1353A - Most Unstable ArrayIf n=1 then the answer is 0. Otherwise, the best way is to construct the array [0,m,0,…,0]. For n=2 we can't reach answer more than m and for n>2 we can't reach the answer more than 2m because each unit can't be used more than twice. So the answer can be represented as min(2,n−1)⋅m.

Solution1353B - Two Arrays And Swaps

Tutorial1353B - Two Arrays And SwapsEach move we can choose the minimum element in a, the maximum element in b and swap them (if the minimum in a is less than maximum in b). If we repeat this operation k times, we get the answer. This can be done in O(n3), O(n2) but authors solution is O(nlogn).

Solution1353C - Board Moves

Tutorial1353C - Board MovesIt is intuitive (and provable) that the best strategy is to move each figure to the center cell (n+12 ,n+12 ). Now, with some paperwork or easy observations, we can notice that we have exactly 8 cells with the shortest distance 1, 16 cells with the shortest distance 2, 24 cells with the shortest distance 3 and so on. So we have 8i cells with the shortest distance i. So the answer is 1⋅8+2⋅16+3⋅24+⋯+(n−12 )2⋅8. It can be rewritten as 8(1+4+9+⋯+(n−12 )2) so we can just calculate the sum of squares of all integers from 1 to n−12  using loop (or formula n(n+1)(2n+1)6 ) and multiply the answer by 8.

Time complexity: O(n) or O(1).

Solution1353D - Constructing the Array

Tutorial1353D - Constructing the ArrayThis is just an implementation problem. We can use some kind of heap or ordered set to store all segments we need in order we need. To solve this problem on C++ with std::set, we can just rewrite the comparator for std::set like this:

struct cmp {	bool operator() (const pair<int, int> &a, const pair<int, int> &b) const {		int lena = a.second - a.first + 1;		int lenb = b.second - b.first + 1;		if (lena == lenb) return a.first < b.first;		return lena > lenb;	}};And then just write the std::set like this:

set<pair<int, int>, cmp> segs;Now the minimum element of the set will be the segment that we need to choose. Initially, the set will contain only one segment [0;n−1]. Suppose we choose the segment [l;r] during the i-th action. Let id=⌊l+r2 ⌋, where ⌊xy ⌋ is x divided by y rounded down. Assign (set) a[id]:=i, then if the segment [l;id−1] has positive (greater than zero) length, push this segment to the set and the same with the segment [id+1;r]. After n such actions we get the answer.

Time complexity: O(nlogn).

Solution1353E - K-periodic Garland

Tutorial1353E - K-periodic GarlandLet ti be the string containing all characters of s that have indices i,i+k,i+2k and so on (i.e. all such positions that have the remainder i modulo k). Suppose we choose that all turned on lamps will have remainder i modulo k. Then we need to remove all ones at the positions that do not belong to this remainder. Also considering the string ti, we need to spend the minimum number of moves to make this string of kind "contiguous block of zeros, contiguous block of ones and again contiguous block of zeros", because considering the characters modulo k will lead us to exactly this pattern (notice that some blocks can be empty).

How to calculate the answer for the string ti in linear time? Let dpi[p] be the number of moves we need to fix the prefix of ti till the p-th character in a way that the p-th character of ti is '1'. Let cnt(S,l,r) be the number of ones in S on the segment [l;r]. Notice that we can calculate all required values cnt in linear time using prefix sums. Then we can calculate dpi[p] as min(cnt(ti,0,p−1)+[ti[p]≠ ′1′],dpi[p−1]+[ti[p]≠ ′1′]), where [x] is the boolean value of the expression x (1 if x is true and 0 otherwise). Let len(S) be the length of S. Then the actual answer for the string ti can be calculated as ansi=min(cnt(ti,0,len(ti)−1), len(ti)−1minp=0 (dpi[p]+cnt(ti,p+1,len(ti)−1))) (thus we consider the case when the obtained string doesn't contan ones at all and consider each position as the last position of some one).

So the actual answer can be calculated as  k−1mini=0 (ansi+cnt(s,0,len(s)−1)−cnt(ti,0,len(ti)−1)).

Time complexity: O(n).

Solution1353F - Decreasing Heights

Tutorial1353F - Decreasing HeightsFirstly, consider the field in 0-indexation. Suppose that the cell (0,0) has some fixed height. Let it be b0,0. Then we can determine what should be the height of the cell (i,j) as bi,j=b0,0+i+j. In fact, it does not matter which way we choose, we actually need only the number of moves to reach the cell and the height of the cell (0,0).

Then (when the height of the cell (0,0) is fixed) we can solve the problem with the following dynamic programming: dpi,j is the minimum number of operations we need to reach the cell (i,j) from the cell (0,0). Initially, all values dpi,j=+∞ except dp0,0=0. Then dpi,j can be calculated as min(dpi−1,j,dpi,j−1)+(ai,j−bi,j). But one more thing: if ai,j<bi,j then this value of dp is incorrect and we cannot use it. We also can't update dp from the incorrect values. The answer for the problem with the fixed height of the cell (0,0) is dpn−1,m−1+a0,0−b0,0 (only when dpn−1,m−1 is correct and ai,j≥bi,j). This part can be calculated in O(n2).

But if we iterate over all possible heights, our solution obvious will get time limit exceeded verdict. Now we can notice one important fact: in the optimal answer, the height of some cell remains unchanged. Let this cell be (i,j). Then we can restore the height of the cell (0,0) as ai,j−i−j and run our quadratic dynamic programming to find the answer for this height.

Time complexity: O(n4).

Solution

Codeforces Round #641 Editorial

By BlueSmoke, 3 years ago, In EnglishYou can view Chinese editorial here: https://www.luogu.com.cn/blog/Caro23333/codeforces-round-641-zhong-wen-ti-xie

Div2.A Problem and editorial by BlueSmoke

Editorial1350A - Orac and FactorsIf we simulate the whole process we will get TLE because k is too large. So we need some trivial observations:

If n is even, then for each operation n will be added by 2 and keep being even.If n is odd, then for the first time n will be added by an odd number and then become even.So it's easy to see that the answer is{ n+2k	n is evenn+2(k−1)+d(n)	n is odd where d(n) is the smallest positive factor of x except 1, which can be calculated in O(n) time.

The overall complexity is O(n) .

CodeDiv2.B Problem and editorial by BlueSmoke

Editorial1350B - Orac and ModelsConsidering DP, we can design DP statuses as follow: fi stands for the length of the longest beautiful sequence end up with index i.

We can find the transformation easily:fi= maxj∣i,sj<si {fj+1}Then, the length of answer sequence is the maximum value among f1,f2,⋯,fn.

About the complexity of DP: If you transform by iterating multiples, it will be O(nlogn) (According to properties of Harmonic Series); if you iterate divisors, then it will be O(n√n). Fortunately, both of them are acceptable in this problem.

CodeDiv1.A Problem and editorial by mydiplomacy

Editorial1349A - Orac and LCMIn this tutorial p stands for a prime, v stands for the maximum of ai and ans stands for the answer.

Observation. pk ∣ ans if and only if there are at least n−1 integers in a that s.t. pk∣ ai.

Proof. if there are at most n−2 integers in a that s.t. pk∣ ai, there exists x≠y s.t. pk∤ax and pk∤ay, so pk∤lcm({ax,ay}) and pk ∤ ans. On the contrary, if there are at least n−1 integers in a s.t. pk∣ ai, between every two different ai there will be at least one multiple of pk. So for every (x,y), pk∣lcm({ax,ay}). Therefore pk ∣ ans.

Solution 1. Define di as a set that consists of all the numbers in a except ai. So gcd(di) is divisible by at least n−1 numbers in a. Also, if at least n−1 integers in a s.t. pk ∣ ai, we can always find i s.t. pk∣gcd(di). According to the Observation, ans=lcm({gcd(d1),gcd(d2),gcd(d3),...,gcd(dn)}).

Now consider how to calculate gcd(di). For every i, calculate prei=gcd({a1,a2,...,ai}) and sufi=gcd({ai,ai+1,...,an}). Therefore gcd(di)=gcd({prei−1,sufi+1}) and we can get pre and suf in O(n⋅log(v)) time.

Time complexity: O(nlogv)Solution 2. Enumerate every prime ≤v. For a prime p, enumerate every ai and calculate ki which stands for the maximum integer that s.t. pki∣ai. According to the Observation, the second smallest ki is the maximum integer k that s.t. pk∣ans. Now let's optimize this solution. If there has been at least two ai not divisible by p, then p∤ans, so just stop enumerate ai.

Time complexity of the optimized solution is O(v+nlogv) because every integer can be divided for at most logv times.

CodeDiv1.B Problem and editorial by A.K.E.E.

Editorial1349B - Orac and MediansLet Bi={ 0,Ai<k1,Ai=k2,Ai>k ，then just consider whether it can be done to make all elements in B become 1 in a finite number of operations.

It can be proved that a solution exists if and only if ∃1≤i≤n,s.t.Bi=1 and ∃1≤i<j≤n,s.t.j−i≤2,Bi>0,Bj>0 .

The necessity is obvious: if ∀1≤i≤n,Bi≠1 , no elements in B can be transformed into 1; If there are at least two zeros between any two positive numbers, then the median of each interval equals to 0, no solution exists.

Consider the sufficiency. If there are two adjacent elements in B both equals to 1 , just select an interval which contains at least three elements and exact one element unequal to 1 , and operate once on this interval. After this operation, there are still two adjacent elements in B both equals to 1, so we keep doing this until all elements are transformed into 1.

Therefore, if there is a interval [l,r] which satisfies r−l+1≥2 and the median of {Bl,Bl+1,…,Br} equals to 1, just perform an operation on [l,r] , then use the above strategy. It can be shown that such an interval can always be created in several operations with the condition.

If an interval [i,i+2] satisfies {Bi,Bi+1,Bi+2}={0,1,2} or {1,1,2} or {0,1,1} or {1,1,1}，just perform an operation on [i,i+2] .If [i,i+2] satisfies {Bi,Bi+1,Bi+2}={1,2,2} , then {Bi,Bi+1}={1,2} or {Bi+1,Bi+2}={1,2} . Perform an operation on [i,i+1] or [i+1,i+2] .If any interval with three elements doesn't satisfy the above conditions, because ∃1≤i<j≤n,s.t.j−i≤2,Bi>0,Bj>0 ，there is an interval [i,i+2] which satisfies {Bi,Bi+1,Bi+2}={0,2,2} or {2,2,2} . Take such an interval [i,i+2] , perform an operation on [i,i+2] first, then select an interval which contains at least three elements and exact one element unequal to 2 until two adjacent numbers equals to 1 and 2 respectively. Perform one operation on these two adjacent elements.Therefore, the sufficiency is proved. So just check whether there is an element in B equals to 1, and whether there is a pair of two positive integers (i,j) which satisfies 1≤j−i≤2,Bi>0,Bj>0 . The complexity is O(n).

CodeDiv1.C Problem and editorial by A.K.E.E.

Editorial1349C - Orac and Game of LifeA cell (i,j) is said to be good if and only if there is a cell (i′,j′) adjacent to (i,j) which has the same color to (i,j) . If a cell (i,j) is not good, it is said to be bad. Therefore, the color of a cell changes after a turn if and only if the cell is good.

According to the definition, any cell never changes its color if every cell is bad. Also, a good cell (i,j) would never turn into a bad cell .

For a bad cell (i,j), if there is a good cell (i′,j′) adjacent to (i,j), (i,j) will turn into a good cell after a turn because (i′,j′) currently has a different color from (i,j) and the color of (i′,j′) will change after a turn but the color of (i,j) won't change; otherwise, after a turn, the color of (i,j) and cells adjacent to (i,j) stays the same, so (i,j) is still bad.

For a cell (i,j), let fi,j be the number of turns needed for that (i,j) becomes a good cell. According to the paragraph above, fi,j equals to the minimal Manhattan distance from (i,j) to a good cell. Therefore, fi,j can be figured out by BFS.

Notice that for k≤fi,j , the color of (i,j) stays the same after the k-th turn; for k>fi,j , the color of (i,j) changes after the k-th turn. Therefore, each query can be processed with O(1) time complexity. The total time complexity is O(nm+t) .

P.S. R.I.P. John Horton Conway, you are a great mathematician that should be remembered forever.

CodeDiv1.D Problem and editorial by Rebelz

Part of solution by Elegia

Editorial1349D - Slime and BiscuitsLet Ex be the sum of probability times time when the game end up with all biscuits are owned by the x-th person (At here, the sum of probability is not 1, though the sum of probability in all Ex is 1). So the answer is  n∑i=1 EiLet E′x be the expectation of time when the game only ends when the x-th person own all the biscuits.

Let Px be the probability that the game end up with all biscuits are owned by the x-th person. It's easy to find that  n∑i=1 Pi=1。

And we let constant C be the expect time from when all biscuits are owned by i-th person to when all biscuits are owned by j-th person (now the end condition is that all biscuits are owned by j-th person, is the same with E′x . And for all (i, j), the value of C is the same). So we have a identity:

Ex=E′x− n∑i=1 [i≠x](Pi⋅C+Ei)We can get this by consider which people own all the biscuits when the game ends in all possible situation of E′x .

Then we can get:

n∑i=1 Ei=E′x−C⋅ n∑i=1 [i≠x]PiSum it up for x=1,2,⋯,n , and we get:

n n∑i=1 Ei= n∑i=1 E′i−C(n−1) n∑i=1 PiMention that ans= n∑i=1 Ei and  n∑i=1 Pi=1 , so we find that:

n⋅ans= n∑i=1 E′i−C(n−1)When we find the value of E′x and C , we only want to know whether the biscuit is owned by the person we want or not, so we can let fm represent the expect time the person will own m+1 biscuits when the person own m biscuits now. We can easily get f0 and equation between fi and fi−1 .

So we can get all fm and C in O( n∑i=1 ai⋅log mod) time. And we can get the answer.

The overall complexity is O( n∑i=1 ai⋅log mod) .

CodeDiv1.E Problem and editorial by A.K.E.E.

Editorial1349E - Slime and HatsFirst, let's renumber the players for convenience. Number the player at the front as n ，the player sitting behind him as n−1 , and so on.

Let ci be the color of player i's hat. Consider how to calculate ti if we have already known c1,c2,…,cn. If c1=c2=⋯=cn=0, then t1=t2=⋯=tn=1. Otherwise, let x be the maximal number of a player with a black hat. In the first turn, player 1 knows that someone wears a black hat.

If x=1, player 1 finds out that everyone except him wears a white hat, so he wears a black hat and he leaves. In the second turn, other players can figure out that c2=c3=⋯=cn=0. Therefore, t1=1,t2=t3=⋯=tn=2.If x≥2, there is a player with a black hat sitting in front of player 1 , so he can't figure out the color of his own hat and doesn't leave. Other players know that x≥2 in the next turn, and the problem is transformed into a subproblem on player 2,3,…,n. No one leaves until the x-th turn, player x knows that there is at least one player with a black hat in x,x+1,…,n, but player x,x+1,…,n all wear white hats, so he leaves. In the next turn, x+1,x+2,…,n leaves.According to the above process, player x leaves in the x-th turn, player x+1,x+2,…,n leave in the (x+1)-th turn, and a new process begins. Therefore, we can figure out the value of t1,t2,…,tn.

- If ci=1 , then ti= ∑j≥i,cj=1 j . Let bi=i . - If ci=0 , let k be the maximal number which satisfies ck=1 and k<i , then ti=tk+1 . For convenience, let c0=1,t0= ∑cj=1 j , so k always exists. Let bi=k.

Therefore, we can calculate t1,t2,…,tn using c1,c2,…cn, and ti=tbi+(1−ci) is satisfied.

Consider how to solve the original problem. Before using dynamic programming to solve the problem, we need to do some preparation for that.

If i≥j and ci=cj=1 , it is obviously that ti≤tj. Also, if ti>tj, bi≥bj. Therefore,∀i>j,ti−tj=tbi+(1−ci)−tbj−(1−cj)=tbi−tbj+(cj−ci)≤cj−ci≤1In fact, if i>j , we have{ ti−tj=1, if cj=1 and ∀i≥k>j,ck=0ti−tj=0, if ∃i>k>j,ck=1,c1=c2=⋯=ck−1=ck+1=⋯=cn=0 or ∀i≥k≥j,ck=0ti−tj<0, otherwise It is not difficult to prove the formula above with some simple classified discussions.

Define a set of intervals A={[l1,r1],[l2,r2],…,[lm,rm]} which satisfies these rules:

1≤l1≤r1<l2≤r2<⋯<lm≤rm≤n∀1≤k≤m,∃lk≤i≤rk, ti is given.∀1≤i≤n, if ti is given, ∃k,s.t. lk≤i≤rkFor all pairs (i,j) where i>j and ti,tj are both given, i and j are in the same interval if and only if ti≥tj.If li≠1, it can be known that cli+1=cli+2=⋯=cri=0 and bli=bli+1=⋯=bri. Let Bi=bli.

After the preparatory work, let's work on dp. Let fi,j be the maximal possible value of Bi when cli=j . Consider how to calculate fi,j′ if we know the value of fi+1,0 and fi+1,1 . For fi+1,j, enumerate all possible fi,j′ from large to small, Bi=fi,j′ might be satisfied iftfi,j′= ∑k≥fi,j′,ck=1 k=( ∑k≥fi+1,j,ck=1 k)+( ∑fi+1,j>k≥fi,j′,ck=1 k)=tfi+1,j+fi,j′+ ∑ri<k<fi+1,j,cj=1 kIf can be noticed that tfi,j′,fi,j′,tfi+1,j are already known, so we just need to check whether there exists some distinct integers in [ri+1,fi+1,j−1] where the sum of them equals to tfi,j′−fi,j′−tfi+1,j , which can be easily solved by binary search.

Besides fi,j, record whether fi,j is transformed from fi+1,0 or fi+1,1. Using these we can easily give a solution.

Notice that when l1=1, [l1,r1] doesn't satisfy cl1+1=cl1+2=⋯=cr1=0 . However, there is at most one i in [l1,r1] where ci=1. Just brute force which ci equals to 1 is okay. The whole complexity is O(nlogn).

CodeDiv1.F Problem and editorial by Rebelz

Hard version solution by Elegia

Editorial for easy version1349F1 - Slime and Sequences (Easy Version)First we can make a bijection between all the good sequences and permutations. Let a permutation of length n be a1,a2,⋯,an , and we fill '>' or '<' sign between each ai and ai+1 , so the value of pai is the number of '<' sign between a1,a2,⋯,ai plus one, it's easy to proof that this is a correct bijection.

Let di,j be the number of permutations of length i+1 that have at least j '<' signs in it. Then for each '<' sign, we can combine the places next to it, so for some combined places, there are only one way to put the numbers in it for a fix set of numbers. And we know that di,j have i−j+1 sets of combined places, so the value of di,j is the number of ways to assign i+1 numbers into i−j+1 different sets. From the EGF of the second kind of Stirling numbers, we know that di,j=(i+1)![zi+1](ez−1)i−j+1 . We can also use DP that similar with the Stirling numbers to get all di,j .

When we find the answers, for each 1≤i≤n , we consider the contribution of each places, so for each aj , we need to find the number of permutations that have i−1 '<' signs before it. So we can get:

ansi+1= n−1∑x=0  x∑y=i (−1)y−i(yi )dx,yn!(x+1)! =n!i! n−1∑x=0  x∑y=i (−1)y−iy!dx,y(y−i)!(x+1)! =n!i! n−1∑y=i (−1)y−iy!(y−i)! n−1∑x=y dx,y(x+1)! =n!i! n−1∑y=i (−1)y−iy!(y−i)! n−1∑x=y [zx+1](ez−1)x−y+1If we can find  n−1∑x=y [zx+1](ez−1)x−y+1 for each y , then we can find the answer in one convolution.

And because of the simple O(n2) DP algorithm to find all dx,y , so we can get a O(n2) complexity to solve the problem, and it can pass the easy version (other forms of DP can also get to this time complexity, but now we only introduce the form that leads to the solution of the hard version).

CodeEditorial for hard version1349F2 - Slime and Sequences (Hard Version)Now we consider how to get these values in less than O(n2) time.

n−1∑x=y [zx+1](ez−1)x−y+1= n∑x=y+1 [zx](ez−1)x−y=[zy] n∑x=y+1 (ez−1z )x−y=[zy] n−y∑x=1 (ez−1z )xLet F=ez−1z  , so now we just want to find [zi] n−i∑k=1 Fk for each 0≤i≤n−1 .

[zi] n−i∑k=1 Fk=[zi]11−F −[zi]Fn−i+11−F We can get the value of [zi]11−F  in one polynomial inversion, now we only need to deal with the second one.

[zi]Fn−i+11−F =[zn+1](zF)n−i+11−F Let w(z)=zF(z) , ϕ(z) satisfies w(z)ϕ(w(z)) =z , so zF(z)ϕ(w(z)) =z , F=ϕ(w) .

[zn+1](zF)n−i+11−F =[zn+1un−i+1] ∞∑k=0 (uzF)k1−F =[zn+1un−i+1]11−ϕ(w) 11−uw And from the Lagrange Inversion

=[un−i+1]1n+1 [zn]((11−ϕz 11−uz )′⋅ϕ(z)n+1)=1n+1 [znun−i+1](ϕ(z)n+1u+ϕ′(z)−uϕ(z)−uzϕ′(z)(1−ϕ(z))2(1−uz)2 )=1n+1 [znun−i+1](ϕ(z)n+1(u(1−ϕ(z))(1−uz)2 +ϕ′(z)(1−ϕ(z))2(1−uz) ))=1n+1 [znun−i+1](ϕ(z)n+1(11−ϕ(z) ∞∑k=0 (k+1)zkuk+1+ϕ′(z)(1−ϕ(z))2 ∞∑k=0 zkuk))=1n+1 [zn](ϕ(z)n+1((n−i+1)zn−i1−ϕ(z) +ϕ′(z)zn−i+1(1−ϕ(z))2 ))=1n+1 ([zi](ϕ(z)n+1n−i+11−ϕ(z) )+[zi−1](ϕ(z)n+1ϕ′(z)(1−ϕ(z))2 ))We can get ϕ(z)n+1n−i+11−ϕ(z)  and ϕ(z)n+1ϕ′(z)(1−ϕ(z))2  in O(nlogn) or O(nlog2n) time, and then get the answer.

The overall complexity is O(nlogn) or O(nlog2n) .

CodeYou can also view Div1.F editorial by Elegia here: https://codeforces.com/blog/entry/77280

Anyway, hope you like these problems and thank you for participating!

Codeforces Round #640 (Div. 4) Editorial

By vovuh, history, 3 years ago, In EnglishAll problem ideas belong to MikeMirzayanov. And he prepared all problems himself. I just helped with testing, reviewing and tutorial writing.

1352A - Sum of Round Numbers

Tutorial1352A - Sum of Round NumbersFirstly, we need to understand the minimum amount of round numbers we need to represent n. It equals the number of non-zero digits in n. Why? Because we can "remove" exactly one non-zero digit in n using exactly one round number (so we need at most this amount of round numbers) and, on the other hand, the sum of two round numbers has at most two non-zero digits (the sum of three round numbers has at most three non-zero digits and so on) so this is useless to try to remove more than one digit using the sum of several round numbers.

So we need to find all digits of n and print the required number for each of these digits. For example, if n=103 then n=1⋅102+0⋅101+3⋅100, so we need two round numbers: 1⋅102 and 3⋅100.

Because the last digit of n is n%10 (the remainder of n modulo 10) and we can remove the last digit of the number by integer division on 10, we can use the following code to solve the problem:

int n;cin >> n;vector<int> ans;int power = 1;while (n > 0) {	if (n % 10 > 0) {		ans.push_back((n % 10) * power);	}	n /= 10;	power *= 10;}cout << ans.size() << endl;for (auto number : ans) cout << number << " ";cout << endl;Solution1352B - Same Parity Summands

Tutorial1352B - Same Parity SummandsConsider two cases: when we choose all odd numbers and all even numbers. In both cases let's try to maximize the maximum. So, if we choose odd numbers, let's try to take k−1 ones and the remainder n−(k−1). But we need to sure that n−k+1 is greater than zero and odd. And in case of even numbers, let's try to take k−1 twos and the remainder n−2(k−1). We also need to check that the remainder is greater than zero and even. If none of these cases is true, print "NO".

Solution1352C - K-th Not Divisible by n

Tutorial1352C - K-th Not Divisible by nSuppose the answer is just k-th positive integer which we should "shift right" by some number. Each multiplier of n shifts our answer by 1. The number of such multipliers is need=⌊k−1n−1⌋, where ⌊xy⌋ is x divided by y rounded down. So the final answer is k+need (k-th positive integer with the required number of skipped integers multipliers of n).

You can also use a binary search to solve this problem :)

Solution1352D - Alice, Bob and Candies

Tutorial1352D - Alice, Bob and CandiesThis is just an implementation problem and it can be solved in O(n) time but we didn't ask for such solutions so you could solve it in O(n2) or maybe even in O(n2logn). I'll describe O(n) solution anyway.

Firstly, we need to maintain several variables: cnt (initially 0, the number of moves passed), l (the position of the leftmost remaining candy, initially 0), r (the position of the rightmost remaining candy, initially n−1), ansl (the sum of candies eaten by Alice, initially 0), ansr (the sum of candied eaten by Bob, initially 0), suml (the sum of candies eaten by Alice during her last move, initially 0) and sumr (the sum of candies eaten by Bob during his last move, initially 0).

So, let's just simulate the following process while l≤r: if the number of moves cnt is even then now is Alice's move and we need to maintain one more variable nsuml=0 — the sum of candies Alice eats during this move. How to calculate it? While l≤r and nsuml≤sumr, let's eat the leftmost candy, so variables will change like this: nsuml:=nsuml+al,l:=l+1. After all, let's add nsuml to ansl, replace suml with nsuml (assign suml:=nsuml) and increase cnt by 1. If the number of moves cnt is odd then the process is the same but from the Bob's side.

I'll also add a simply implemented O(n2) solution written by Gassa below :)

Solution in O(n)Solution in O(n^2)1352E - Special Elements

Tutorial1352E - Special ElementsThe intended solution for this problem uses O(n2) time and O(n) memory. Firstly, let's calculate cnti for each i from 1 to n, where cnti is the number of occurrences of i in a. This part can be done in O(n).

Then let's iterate over all segments of a of length at least 2 maintaining the sum of the current segment sum. We can notice that we don't need sums greater than n because all elements do not exceed n. So if the current sum does not exceed n then add cntsum to the answer and set cntsum:=0 to prevent counting the same elements several times. This part can be done in O(n2).

Solution1352F - Binary String Reconstruction

Tutorial1352F - Binary String ReconstructionConsider case n1=0 separately and print the sting of n0+1 zeros or n2+1 ones correspondingly.

Now our string has at least one pair "10" or "01". Let's form the pattern "101010 ... 10" of length n1+1. So, all substrings with the sum 1 are satisfied. Now let's insert n0 zeros before the first zero, in this way we satisfy the substrings with the sum 0. And then just insert n2 ones before the first one, in this way we satisfy the substrings with the sum 2.

Solution1352G - Special Permutation

Tutorial1352G - Special PermutationIf n<4 then there is no answer. You can do some handwork to be sure. Otherwise, the answer exists and there is one simple way to construct it: firstly, let's put all odd integers into the answer in decreasing order, then put 4, 2, and all other even numbers in increasing order. To test that it always works, you can run some kind of checker locally (you can check all 1000 tests very fast, in less than one second, this may be very helpful sometimes).

Solution

Codeforces Round #639 Editorial

By Monogon, history, 3 years ago, In English1345A - Puzzle Pieces

Tutorial1345A - Puzzle PiecesIf n=1 or m=1, then we can chain the pieces together to form a solution. If n=m=2, we can make the following solution:

Any other potential solution would contain a 2×3 or a 3×2 solution, which we can show is impossible.

A 2×3 grid has 7 shared edges between the pieces, and each shared edge must have a blank. But there are only 6 blanks available as there are 6 pieces.

1345B - Card Constructions

Tutorial1345B - Card ConstructionsLet's count the number of cards in a pyramid of height h. There are 2(1+2+3+⋯+h) cards standing up, and there are 0+1+2+⋯+(h−1) horizontal cards. So, there are 2h(h+1)2+(h−1)h2=32h2+12h cards total. Using this formula, we can quickly find the largest height h that uses at most n cards.

The quadratic formula or binary search can be used here, but are unnecessary. Simply iterating through all h values works in O(n−−√) time per test.

It's enough to see that this takes O(tN−−√) time overall, where N is the sum of n across all test cases. But interestingly, we can argue for a tighter bound of O(tN−−−√) due to the Cauchy-Schwarz Inequality:

∑i=1t(1⋅ni−−√)≤(∑i=1t12)(∑i=1t(n−−√i)2)−−−−−−−−−−−−−−−−−−−⎷=tN−−−√1345C - Hilbert's Hotel

Tutorial1345C - Hilbert's HotelSuppose that i+ai≡j+aj(modn) for some 0≤i<j<n. Then i+ai=j+aj+kn for some integer k, so the guest in room i is assigned the same room as guest j+kn.

Similarly, suppose that two different guests k and m are assigned the same room. Then we have i+ai≡j+aj(modn) for i=kmodn and j=mmodn.

This proves there is a collision if and only if all i+ai are not distinct (modn). That is, {(0+a0)modn,(1+a1)modn,…,(n−1+an−1)modn}={0,1,…,n−1}. This is simply checked with a boolean array to make sure each number from 0 to n−1 is included.

Note that there are also no vacancies if this condition holds: Let k be some room. Then kmodn must appear in the array, so there is some i with i+ai≡k(modn). Then there is an integer m with i+mn+ai=k, meaning guest i+mn is moved to room k.

Complexity is O(n).

1345D - Monopole Magnets

Tutorial1345D - Monopole MagnetsSuppose two cells A and B are colored black in the same row. Since there must be a south magnet in every row, there are segments of black cells from A and B to the cell with the south magnet. The same result holds for columns. Therefore, for a solution to exist, every row and every column has exactly one segment of black cells or is all-white.

Suppose there is an all-white row, but not an all-white column. (Or similarly, an all-white column but not an all-white row.) Then wherever we place a south magnet in this row, its column will have a black cell. But then the south magnet would be reachable, contradicting the fact that the row is all-white. Therefore, there should be an all-white row if and only if there is an all-white column, or no solution exists.

Now that we have excluded these cases where no solution exists, let's construct a solution. Place a south magnet in a cell if:

The cell is colored black, orIts row and column are both all-white.Then place one north magnet in each connected component of black cells. A north magnet cannot travel between components, so this is optimal.

1345E - Quantifier Question

Tutorial1345E - Quantifier QuestionBuild a directed graph of variables, where an edge xi→xj corresponds to an inequality xi<xj. Say that two variables are comparable if there is a directed path from one variable to the other.

Suppose xi and xj are comparable with i<j. Then xj cannot be universal since xi is determined before xj in the order and their comparability restricts the value of xj. So, a requirement for universality is that the variable is only comparable with larger-indexed variables.

If there is a cycle of inequalities, then there is no solution since the formula is contradictory. Otherwise, the graph is acyclic, so we can find a topological order. For each variable, we can find the minimum index of a node comparable to it by doing DP in forward and reverse topological order. Then for every variable not comparable to a smaller indexed variable, let it be universal. All other variables must be existential. Our requirement of universality proves this is optimal.

Let's prove this assignment gives a true statement (other than proof by AC). First, we can decrease the index of existential variables, which only strengthens the statement. So let's decrease the index of each existential variable to appear just after its largest-indexed comparable universal variable.

An existential variable xi may be comparable to many universal variables, but xi must be either greater than them all or less than them all. (Otherwise, we would have two comparable universals.) Without loss of generality, say xi is greater than its comparable universals. And suppose xi is less than another existential variable xj. Then xj is comparable to the same universals as xi, so we can determine the value of xj later such that it depends on xi. Therefore, each existential variable is only restricted by a lower bound or an upper bound of smaller-indexed variables. We can properly assign values to them, satisfying all inequalities.

1345F - Résumé Review

Tutorial1345F - Résumé ReviewIf we increment some bi to x, the value of f changes byΔi(x):=[x(ai−x2)]−[(x−1)(ai−(x−1)2)]=ai−3x2+3x−1,which decreases for x≥1. If we initially set all bi to 0, then greedily incrementing the best index gives an optimal solution. Since k is large, we cannot afford to do this one increment at a time. However, we can observe that this process increments the values as long as Δi(x)≥A for some constant A. Simply binary search on the value of A so that we increment exactly k times.

To compute the cutoffs for the x values, we can either use the quadratic formula or do another binary search.

There may be ties for the Δi(x) values, but this can be handled without too much trouble.

Let A=maxi=1,…,n{ai}. Complexity is O(nlog(A)) with the quadratic formula, or O(nlog2(A)) with another binary search.

1344E - Train Tracks

Tutorial1344E - Train TracksFirst, observe that a train can never pass one that enters earlier. So let's consider the trains independently. For a train i, look at the path from 1 to si. We may need to change the switches of several stations on this path. We must make each switch within a time interval (L,R], where L is the most recent time some other train was directed the other way, and R is the time train i will enter the station. Let's mark all of these switches as changed before processing the next train.

Suppose the total number of switch changes is k, and for each station, we know its time intervals. We can manage all events in a priority queue of size n, always changing the switch with the earliest deadline that we can. Keep doing this until we are too late for a deadline, in which case an explosion happens, or until we have successfully made every switch change. This part will take O(klogn) time.

Let's find a nice upper bound on k. Note that the switches decompose the tree into a set of disjoint paths. When we process a train i, we are changing the switches to make a path from the root to si. It turns out this is exactly the same as an access operation on a link/cut tree! Because link/cut trees have O(logn) amortized time per operation, we can guarantee that the total number of switch changes is k=O(n+mlogn).

Now let's consider the problem of finding all time intervals. We could use a link/cut tree, but everyone hates those, so let's discuss other methods. One strategy is to maintain a list of trains that go through a station, for every station. We start at the leaves and merge the lists going up. We can merge the lists efficiently by inserting elements from the smaller list to the larger list. Then a switch only needs to be changed when consecutive trains go to different children.

Unlike some of the testers, I wasn't smart enough to come up with the elegant small-to-large merging idea. So let's discuss an alternate solution using segment trees. When processing a train i, we want to do the following:

Find the top node x of the path leading to si.If x is not the root, make the parent of x point to x, and record the time interval we must make this switch. Repeat from step 1 until x is the root.The queries we want to support are thus:

Find the time the most recent train passed through a node x (ignoring trains with si=x, where it only stops at x).Find the top node of the path containing node x.Let's handle queries of type 1 with a segment tree. After processing train i, update the value at index si to i. To answer a query, find the maximum value in the range corresponding to the relevant subtree.

Let's also handle queries of type 2 with a segment tree. At a segment tree node, store the minimum value on its range. To answer a query, check the range [x,x]. Support lazy updates of the form "On a range [l,r], replace all values X with value Y, with the precondition that X is currently the minimum value in [l,r] and Y will remain the minimum value after the update". To make a switch change, we only need to do two lazy updates.

Therefore, finding all the time intervals will take O((m+k)logn) time.

The overall complexity is O(nlogn+mlog2n).

1344F - Piet's Palette

Tutorial1344F - Piet's PaletteEquate an empty cell with the color white, and let's represent the colors as 0/1 vectors:W=[00], R=[10], Y=[01], B=[11].Under this representation, mixing becomes addition (mod2). And the operations RY, RB, YB are linear transformations of the colors. That is, each of these operations is equivalent to multiplying the corresponding matrix by a cell's vector:RY=[0110], RB=[1101], YB=[1011].We simply have a system of 2k linear equations on 2n unknowns, which we can solve with Gaussian elimination using bitsets.

Complexity is O((2k)2(2n)/64).

Codeforces Round #638 (Div. 2) Editorial

By FieryPhoenix, 3 years ago, In English1348A - Phoenix and Balance

Tutorial1348A - Phoenix and BalanceWe observe that the coin with the weight 2n is greater than the sum of all the other weights combined. This is true because ∑i=1n−12i=2n−2. Therefore, the pile that has the heaviest coin will always weigh more. To minimize the weight differences, we put the n/2−1 lightest coins into the pile with the heaviest coin. The answer will be (2n+∑i=1n/2−12i)−∑i=n/2n−12i.

Time complexity for each test case: O(n)You can also solve the problem in O(1) by simplifying the mathematical expression.

Solution1348B - Phoenix and Beauty

Tutorial1348B - Phoenix and BeautyFor an array to be beautiful for some k, the array must be periodic with period k. If there exists more than k distinct numbers in the array a, there is no answer and we print -1 (because the array cannot be periodic with period k). Otherwise, we propose the following construction.

Consider a list of all the distinct numbers in array a. If there are less than k of them, we will append some 1s (or any other number) until the list has size k. We can just print this list n times. The length of our array b is nk, which never exceeds 104. Array b can always be constructed by inserting some numbers into array a because every number in a corresponds to one list.

Time complexity for each test case: O(nlogn+nk)Solution1348C — Phoenix and Distribution

Tutorial1348C - Phoenix and DistributionWe first try to assign one letter to each string ai. Let's denote the smallest letter in s as c. If there exists at least k occurrences of c in s, we will assign c as the first letter of each string ai. Otherwise, the minimal solution is the kth smallest letter in s. For example, if s=aabbb and k=3, the 3rd smallest letter is b and that will be the answer.

Otherwise, we consider the letters that are left in s. If they are all the same letter (or there are no letters left because n=k), we split the remaining letters as evenly as possible among ai. If not, we will show that it is optimal to sort the remaining letters in s and append them to arbitrary ai.

For example, let's suppose after assigning a letter to each ai that the remaining letters in s are aaabb. We want to assign the bs as late as possible, so any string ai that receives a b should have some number of as before. It makes sense in fact that the string that receives a b should receive all the as, because if not it will be lexicographically larger. It can then be shown that all remaining larger letters should be sorted and added to the same string ai to minimize the answer.

Time complexity for each test case: O(nlogn) (for sorting s)

Solution1348D - Phoenix and Science

Tutorial1348D - Phoenix and ScienceThere exists many constructive solutions, here is one I think is very elegant. We will try to approach the problem by considering how much the total mass increases every night. If there are x bacteria some day before the splitting, that night can have a mass increase between x and 2x inclusive (depending on how many bacteria split that day).

Therefore, we can reword the problem as follows: construct a sequence a of minimal length a0=1,a1,…,ak such that ai≤ai+1≤2ai and the sum of ai is n. To minimize the length of sequence a, we will start building our sequence with 1,2,…,2x such that the total sum s is less than or equal to n. If the total sum is n, we are done. Otherwise, we insert n−s into our sequence and sort. This gives a valid sequence of minimal length.

To transform our sequence a into the answer, we can just print the differences ai−ai−1 because the number of bacteria that split during the day is equal to how much the mass increase changes.

Time complexity for each test case: O(logn), if you sort by insertion

Solution1348E - Phoenix and Berries

Tutorial1348E - Phoenix and BerriesSolution 1:

There is no obvious greedy solution, so we will try dynamic programming. Let dp[i][j] be a boolean array that denotes whether we can have j extra red berries after considering the first i shrubs. A berry is extra if it is not placed into a full basket (of any kind). Note that if we know that there are j extra red berries, we can also easily calculate how many extra blue berries there are. Note that we can choose to never have more than k−1 extra red berries, because otherwise we can fill some number of baskets with them.

To transition from shrub i−1 to shrub i, we loop over all possible values l from 0 to min(k−1,ai) and check whether or not we can leave l extra red berries from the current shrub i. For some i and j, we can leave l extra red berries and put the remaining red berries in baskets possibly with blue berries from the same shrub if (ai−l) mod k+bi≥k. The reasoning for this is as follows:

First of all, we are leaving l red berries (or at least trying to). We show that from this shrub, there will be at most one basket containing both red and blue berries (all from this shrub). To place the remaining red berries into full baskets, the more blue berries we have the better. It is optimal to place the remaining ai−l red berries into their own separate baskets first before merging with the blue berries (this way requires fewest blue berries to satisfy the condition). Then, if (ai−l) mod k+bi is at least k, we can fill some basket with the remaining red berries and possibly some blue berries. Remember that we do not care about how many extra blue berries we leave because that is uniquely determined by the number of extra red berries.

Also note that we can always leave ai mod k extra red berries.

Denote the total number of berries as t. The answer will be maximum over all (t−j)/k such that dp[n][j] is true, 0≤j≤k−1.

Time Complexity: O(nk2)Solution 2:

We use dynamic programming. Let dp[i][j] be true if after considering the first i shrubs , j is the number of red berries in heterogenous baskets modulo k. Heterogenous baskets contain berries from the same shrub, and homogenous baskets contain berries of the same type.

Suppose we know the number of red berries in heterogeneous baskets modulo k. This determines the number of blue berries in heterogeneous baskets modulo k. Since the number of red berries in homogeneous baskets is a multiple of k, it also determines the number of red berries not in any baskets (we can safely assume this to be less than k since otherwise we can form another basket). Similarly, we can determine the number of blue berries not in any basket, and thus deduce the number of baskets.

To compute the possible numbers of red berries in heterogeneous baskets modulo k, it suffices to look at each shrub separately and determine the possible numbers of red berries modulo k in heterogeneous baskets for that shrub. If there is more than one heterogeneous basket for one shrub, we can rearrange the berries to leave at most one heterogeneous. Now we have two cases. If there are no heterogeneous baskets, the number of red berries in those baskets is obviously zero. If there is one heterogeneous basket, let x be the number of red berries in it and k−x be the number of blue berries in it. Clearly, 0≤x≤ai and 0≤k−x≤bi. Rearranging, we get max(0,k−bi)≤x≤min(ai,k). These correspond to the transitions for our DP.

There exists faster solutions (like O(nk)), can you find it?

Solution1348F - Phoenix and Memory

Tutorial1348F - Phoenix and MemoryThere are many many many solutions to this problem (which is cool!). I describe two of them below.

Both solutions first find an arbitrary valid ordering. This can be done in O(nlogn) with a greedy algorithm. We can sort the intervals (ai,bi) and sweep from left to right. To see which position that we can assign friend j to, we process all intervals with ai≤j and insert bi into a multiset (or similar) structure. We match friend j to the interval with minimal bi.

Solution 1:

We prove that if there exists more than one valid ordering, we can transform one into another by swapping two friends.

Proof:

In our valid ordering, each friend is assigned a position. We can think of this as a point being assigned to an interval (Friend - point, position - interval). We will prove there exists a cycle of length 2 or there exists no cycle at all.

Suppose we have a cycle: each point is on its interval and its predecessor's interval. Let's take the shortest cycle of length at least two. Let q be the leftmost point, p be q's predecessor, and r be q's successor.

Case 1: q's interval's right endpoint is to the right of p. p and q form a cycle of length 2.

Case 2: q's interval's right endpoint is to the left of p. r must be between q and p. So, we can remove q and get a shorter cycle. This is a contradiction.

□Denote pi as the position that friend i is assigned to in our arbitrary ordering. Now, we are interested whether or not there exists a friend i such that there also exists some friend j with pj such that pi<pj≤bpi and apj≤pi. If there does, we can swap friends i and j to make another valid ordering. This can be done with a segment tree (build it with values ai).

Time Complexity: O(nlogn)Solution 2:

The problem is equivalent to checking if there is a unique perfect matching in the following bipartite graph:

The vertices on the left correspond to position. The vertices on the right correspond to labels of the friends. A directed edge from a position node to a label node exists iff the friend with that label can be at that position.

Find a perfect matching (corresponding to finding any valid assignment) as described above.

The matching is unique iff contracting the edges (merging nodes connected by edges from our perfect matching into one node) in the perfect matching creates a DAG. The reasoning is as follows:

Consider a simpler graph, with only nodes representing positions. We draw a directed edge from node i to node j if the friend currently assigned at position i (from our greedy) can also be assigned to position j. So, if there exists any cycle, we can shift the friends around the cycle to create another valid ordering. In other words, if our graph is a DAG, the perfect matching is unique.

Now, returning back to the bipartite graph, we see that it is essentially the same. By contracting edges, all position nodes are equivalent to the friend node that is assigned to them (from the greedy). So, following an edge from the left side (position) to the right side (friend) puts us back on the left side (position), and this graph corresponds to the simpler version I explained above.

So, this can be done by DFS in O(n2), but this is too slow. We can speed it up by storing a set of unvisited vertices and only iterating across those (by binary search on set-like structure). Binary search works because every position corresponds to a range of friends.

Time Complexity: O(nlogn)Solution 1Solution 2

Codeforces Round #637 Editorial

By I_love_myself, 3 years ago, In English1341A - Nastya and RiceWe can get any weight of all grains from n(a−b) to n(a+b), so we need to check that the segments [n(a−b);n(a+b)] and [c−d;c+d] intersect.

Idea: I_love_myselfSolution: 77904333

1341B - Nastya and DoorLet's make an array consisting of 0 and 1, such that it shows whether the position i is a peak on the whole segment. To do this, we will go through the indices from 2 to n−1, and if the conditions ai−1<ai and ai>ai+1 are true, then we write 1 in a new array at position i. After that, we calculate the prefix sum in the new array pref. Now the number of peaks in the segment [l,l+k−1] is calculated as pref[l+k−2]−pref[l], so we find out how many peaks in the desired segment, not including the boundaries of the segment. It remains only to go through all l from 1 to n−k+1 and find the leftmost l, such that pref[l+k−2]−pref[l] as much as possible.

Idea: alexX512Solution: 779044081341C - Nastya and Strange GeneratorConsider the initial moment of time. Note that the array is r=[1,2,…,n], count=[1,1,…,1]. So the generator will choose a random position from the entire array – let it be the position i1. In the next step, r=[1,2,…i1+1,i1+1,i+2,…,n], count=[1,1,…,0,2,1,…,1]. That is, now there is only one maximum and it is reached at the position i1+1. Thus, we will fill in the entire suffix starting at position i1: a=[×,…,×,1,…,i1]. After this, this procedure will be repeated for some i2 (1≤i2<i1) and the array will become a=[×,…,×,i1+1,…,i1+i2,1,…,i1] . That is, we need to check that the array consists of several ascending sequences.

Idea: Aleks5dSolution: 779044551341D - Nastya and ScoreboardLet dp[i][j]=true, if at the suffix i…n you can turn on exactly j sticks and get the correct sequence of digits and false otherwise. It is easy to recalculate this dynamics: we will make transitions to all possible digits (the mask at position i should be a submask of the digit).

Asymptotic calculate of the dynamics O(10nd).

Now let's go in order from 1 to n and will try to eagerly set the maximum possible figure using our dynamics. It is easy to understand that in this way we get the maximum possible number of n digits.

Idea: I_love_myselfSolution: 777703311341E - Nastya and Unexpected GuestNotice the fact: if we somehow came to safety island and time imodg (mod - is a remainder after dividing i by g), we don't need anymore to come to this island at time j where i<j and imodg=jmodg, because this will form a cycle.

So that we can rephrase our task like this: we have some vertices, which are denoted as a pair (i,t), i - is island index, t is a remainder after dividing the time we came to i by g. So it will be enough to use only edges between vertices (i,t)→(i+1,(t+a[i+1]−a[i])modg) and (i,t)→(i−1,(t+a[i]−a[i−1])modg), because all remaining edges can be expressed through these ones. Now lets notice that edges, which make time t+a>g can't be used due to restriction of walking on red. But vertices with t+a=g are good for us. So we can say, that while green light is on, Denis can walk without restrictions, and when t+a=g we add g+r to time. So we can use 01-BFS to solve this task and at the end check find vertex and position from which we can go to our final destination.

Time complexity will be O(g∗m).

Idea: Aleks5dSolution: 779046461341F - Nastya and Time MachineLemma: The maximum time that Denis will visit will be at least maxv=1ndegv=TProof: consider an arbitrary vertex v. We will visit her degv−1 times when we will bypass all her neighbors and another 1 when we return to her ancestor. But we can't go to vertex at 0 time. So, we need degv moments more than 0.

We construct a graph traversal with a maximum time equal to T. Let us now stand at v at a time t and v has an un visited son u. We want to go to u, go around its entire subtree and return to v at time t+1. That is, the route will be something like this: (v,t)→(u,t+1)→…→(u,t)→(v,t+1).

Let k=degu−1, for wi we denote the i th son of u. If t+1≤T−k, then there are no problems, we will move back in time at the very end of the route: (v,t) → (u,t+1) → (w1,t+2) → … → (u,t+2) → … → (wk,t+k+1) → … → (u,t+k) → (u,t) → (v,t+1).

Otherwise, you have to go back in time in the middle of the route (exactly when we get to T) so that after the last visit we will be in (v,t+1), that is: (v,t) → (u,t+1) → (w1,t+2) → … → (u,t+2) → … → (u,T) → (u,t′) → … (wk,t+k+1) → … → (u,t+k) → (u,t) → (v,t+1) , where t′ can be easily calculated by the number of not visited sons.

Idea: Aleks5dSolution: 779047141340E - Nastya and BeesTutorial is not available

It turned out that the author’s solution does not work correctly and so far no one, including participants, can prove that Nastya can be caught. This comments contain a lot of good thoughts. But if you can offer at least some solution to this problem, then I (and some participants) will be very happy!1340F - Nastya and CBSWe will call the string exactly the wrong bracket sequence if we go through it with a stack and it will not be of the form close+open, where close is the sequence of closing brackets, and open is opening.

Claim: if s=a+b and a is exactly not CBS or b is exactly not CBS, then s is also exactly not CBS.

At the top of the Segment Tree, we will keep the line after going through it with the stack in the form close+open or marking that it is exactly not CBS. How to merge 2 segments of the form {close1+open1} and {close2+open2}? Note that 3 cases are possible:

    The suffix open1 is close2, then the result is close1+(close2−prefix)+open2.     The prefix close1 is equal to open2, similarly.     The result is exectly not CBS.How can we quickly consider this? Let's build a segment tree, which contains treaps (which contain hashes) in each node, then we need to check for equality some prefixes, glue some strings and save all versions in order to update the ST.

The resulting asymptotics of O(nlog2n).

Idea: I_love_myselfSolution: 77904971Thanks to Holidin for help in preparing this problem.

Codeforces Round #636 (Div. 3) Editorial

By vovuh, history, 3 years ago, In English1343A - Candies

Idea: vovuh

Tutorial1343A - CandiesNotice that ∑i=0k−12i=2k−1. Thus we can replace the initial equation with the following: (2k−1)x=n. So we can iterate over all possible k in range [2;29] (because 230−1>109) and check if n is divisible by 2k−1. If it is then we can print x=n2k−1.

P.S. I know that so many participants found the formula ∑i=0k−12i=2k−1 using geometric progression sum but there is the other way to understand this and it is a way more intuitive for me. Just take a look at the binary representation of numbers: we can notice that 20=1,21=10,22=100 and so on. Thus 20=1,20+21=11,20+21+22=111 and so on. And if we add one to this number consisting of k ones then we get 2k.

Solution1343B - Balanced Array

Idea: vovuh

Tutorial1343B - Balanced ArrayFirstly, if n is not divisible by 4 then the answer is "NO" because the parities of halves won't match. Otherwise, the answer is always "YES". Let's construct it as follows: firstly, let's create the array [2,4,6,…,n,1,3,5,…,n−1]. This array is almost good except one thing: the sum in the right half is exactly n2 less than the sum in the left half. So we can fix it easily: just add n2 to the last element.

Solution1343C - Alternating Subsequence

Idea: vovuh and MikeMirzayanov

Tutorial1343C - Alternating SubsequenceFirstly, let's extract maximum by inclusion segments of the array that consists of the numbers with the same sign. For example, if the array is [1,1,2,−1,−5,2,1,−3] then these segments are [1,1,2], [−1,−5], [2,1] and [−3]. We can do it with any "two pointers"-like algorithm. The number of these segments is the maximum possible length of the alternating subsequence because we can take only one element from each block. And as we want to maximize the sum, we need to take the maximum element from each block.

Time complexity: O(n).

Solution1343D - Constant Palindrome Sum

Idea: MikeMirzayanov

Tutorial1343D - Constant Palindrome SumIt is obvious that if we fix the value of x then there are three cases for the pair of elements:

We don't need to change anything in this pair;we can replace one element to fix this pair;we need to replace both elements to fix this pair.The first part can be calculated easily in O(n+k), we just need to create the array of frequencies cnt, where cntx is the number of such pairs (ai,an−i+1) that ai+an−i+1=x.

The second part is a bit tricky but still doable in O(n+k). For each pair, let's understand the minimum and the maximum sum we can obtain using at most one replacement. For the i-th pair, all such sums belong to the segment [min(ai,an−i+1)+1;max(ai,an−i+1)+k]. Let's make +1 on this segment using prefix sums (make +1 in the left border, −1 in the right border plus one and then just compute prefix sums on this array). Let this array be pref. Then the value prefx tells the number of such pairs that we need to replace at most one element in this pair to make it sum equals x.

And the last part can be calculated as n2−prefx. So, for the sum x the answer is (prefx−cntx)+(n2−prefx)⋅2. We just need to take the minimum such value among all possible sums from 2 to 2k.

There is another one solution that uses scanline, not depends on k and works in O(nlogn) but it has no cool ideas to explain it here (anyway the main idea is almost the same as in the solution above).

Solution1343E - Weights Distributing

Idea: MikeMirzayanov

Tutorial1343E - Weights DistributingIf we distribute costs optimally, then this pair of paths (a→b and b→c) can look like just a straight path that doesn't visit the same vertex twice or like three straight paths with one intersection point x. The first case is basically a subcase of the second one (with the intersection point a,b or c). So, if we fix the intersection point x then these two paths (a→b and b→c) become four paths (a→x, x→b, b→x and x→c). We can notice that each path we denoted should be the shortest possible because if it isn't the shortest one then we used some prices that we couldn't use.

Let the length of the shortest path from u to v be dist(u,v). Then it is obvious that for the fixed intersection point x we don't need to use more than dist(a,x)+dist(b,x)+dist(c,x) smallest costs. Now we want to distribute these costs between these three paths somehow. We can see that the path from b to x is used twice so it is more optimally to distribute the smallest costs along this part. So, let prefi be the sum of the first i smallest costs (just prefix sums on the sorted array p). Then for the intersection point x the answer is prefdist(b,x)+prefdist(a,x)+dist(b,x)+dist(c,x) (if dist(a,x)+dist(b,x)+dist(c,x)≤m). We can calculate distances from a, b and c to each vertex with three runs of bfs.

Time complexity: O(mlogm).

Solution1343F - Restore the Permutation by Sorted Segments

Idea: MikeMirzayanov

Tutorial1343F - Restore the Permutation by Sorted SegmentsLet's fix the first element and then try to restore permutation using this information. One interesting fact: if such permutation exists (with this first element) then it can be restored uniquely. Let's remove the first element from all segments containing it (we can use some logarithmic data structure for it). Then we just have a smaller problem but with one important condition: there is a segment consisting of one element (again, if such permutation exists). So, if the number of segments of length 1 is zero or more than one by some reason then there is no answer for this first element. Otherwise, let's place this segment (a single element) in second place, remove it from all segments containing it and just solve a smaller problem again.

If we succeed with restoring the permutation then we need to check if this permutation really satisfies the given input segments (see the first test case of the example to understand why this case appears). Let's just iterate over all i from 2 to n and then over all j from i−1 to 1. If the segment aj,aj+1,…,ai is in the list, remove it and go to the next i. If we can't find the segment for some i then this permutation is wrong.

Time complexity: O(n3logn) (or less, maybe?)

Solution

Codeforces Round #635 Editorial

By Sulfox, 3 years ago, In English1337A - Ichihime и треугольник

Idea: Sulfox

Tutorial1337A - Ichihime и треугольникThere are many possible solutions, one of them is to always output b, c, c. You can easily prove that b, c, c always satisfies the requirements.

Solution by Sooke1337B - Kana и игра Dragon Quest

Idea: EternalAlexander

Tutorial1337B - Kana и игра Dragon QuestFirst, it's better not to cast Void Absorptions after a Lightning Strike.

Otherwise, there will be a Void Absorption right after a Lightning Strike. Supposing the hit point was x before casting these two spells, if you cast Lightning Strike first, after these two spells the hit point will be ⌊x−102⌋+10=⌊x2⌋+5, but if you cast Void Absorption first, after these two spells the hit point will be ⌊x2⌋, which is smaller.

So the solution is to cast Void Absorptions until the dragon's hit point won't decrease with more casts or you can't cast more Void Absorptions, then cast all Lightning Strikes you have.

We can also use DP to solve this problem. Let fi,j,k=0/1 be possibility of defeating the dragon when the dragon's hit point is at i, you can cast j more Void Absorptions and k more Lightning Strikes. This is a slow solution but is enough to get accepted. You may have to use boolean arrays instead of integer arrays to save memory.

Solution by EternalAlexander1336A - Linova и королевство

Idea: EternalAlexander

Tutorial1336A - Linova и королевствоLemma: In the optimum solution, if a node (except the root) is chosen to develop tourism, its parent must be chosen to develop tourism, too.

Proof: Otherwise, if we choose its parent to develop tourism instead of itself, the sum of happiness will be greater.

Then we can calculate how much happiness we will get if we choose a certain node to develop tourism. Suppose the depth of node u is depu (i.e. there are depu nodes on the path (1,u)), the size of the subtree rooted on u is sizu (i.e. there are sizu nodes v that u is on the path (1,v)). Then, if we choose u to develop tourism, compared to choose it to develop industry, the total happiness will be increased by sizu−depu: the envoy of u won't be sent, we will lose depu−1 happiness; a total of sizu−1 envoys of all nodes in the subtree rooted on u except u itself will get one more happiness.

So, just use DFS to calculate all sizu−depu, then sort them from big to small, calculate the sum of the first n−k elements. You can also use std::nth_element in STL to get an O(n) solution.

Solution by EternalAlexander1336B - Xenia и разноцветные камушки

Idea: ustze & isaf27

Tutorial1336B - Xenia и разноцветные камушкиFirst, let's assume that there exists an optimum solution in which we choose rx, gy and bz satisfying rx≤gy≤bz.

Here's a lemma:

When y is fixed, rx is the maximum one that rx≤gy, and bz is the minimum one that gy≤bz.

It's easy to prove: no matter what z is, the bigger rx is, the smaller (rx−gy)2 and (rx−bz)2 are; for bz it's similar.

So, if we know that in one of the optimum solutions, rx≤gy≤bz, we can sort each array at first and then find x and z by binary search or maintaining some pointers while enumerating y.

Back to the original problem without rx≤gy≤bz, we can enumerate the six possible situations: rx≤gy≤bz, rx≤bz≤gy, gy≤rx≤bz, gy≤bz≤rx, bz≤rx≤gy and bz≤gy≤rx. Find the optimum solution in each situation and the optimum one among them is the answer.

Solution by Sooke1336C - Kaavi и магическое заклинание

Idea: EternalAlexander

Tutorial1336C - Kaavi и магическое заклинаниеWe can use DP to solve this problem.

Let fi,j be the answer when S[0..i−1] has already been used and the current A[0..min(i−1,m−1−j)] will be in the position [j..min(i+j−1,m−1)] after all operations are finished. Specially, fi,m means that all characters in the current A won't be in the position [j..min(i+j−1,m−1)] after all operations are finished.

By definition, fn,0=1 and fn,j=0(j≥1).

The state transition:

j=0If i≥m, A has already had the prefix T, so you can stop performing operations at any position, there are n−i+1 positions in total.

Otherwise, only when S[i]=T[i], you can add S[i] at the back of A, there are fi+1,0 different operation sequences in this situation.

1≤j≤m−1If i+j≥m or S[i]=T[i+j], you can add S[i] at the back of A, there are fi+1,j different operation sequences in this situation.

If S[i]=T[j−1], you can add S[i] at the front of A, there are fi+1,j−1 different operation sequences in this situation.

j=mYou can always add S[i] at the front/back of A in this situation (2fi+1,m different operation sequences). However, if S[i]=T[m−1], you can let S[i] to match T[m−1] (fi+1,m−1 different operation sequences).

So, if S[i]=T[m−1], fi,m=2fi+1,m+fi+1,m−1. Otherwise, fi,m=2fi+1,m.

The answer is 2(f1,m+∑T[i]=S[0]f1,i).

Solution by ouuan1336D - Yui и маджонг

Idea: Sulfox

Tutorial1336D - Yui и маджонгSuppose ci equals to the number of tiles in the current set with value i (before making a query).

If you insert a tile with value x:

The delta of triplet subsets is (cx2). Once you're sure that cx≠0 holds, you can determine the exact value of cx.The delta of straight subsets is cx−2cx−1+cx−1cx+1+cx+1cx+2. Once you've known the values of c1…cx+1 and you're sure that cx+1≠0, you can determine the exact value of cx+2.Let's insert tiles with following values in order: n−1, n−2, …, 3, 1, 2, 1.

We can easily get a1 by the delta of triplet subsets since we insert tiles with value 1 twice.

Consider the delta of straight subsets when you insert the tile with value 1. It equals to a2(a3+1) for the first time and (a2+1)(a3+1) for the second time. Use subtraction to get a3, then use division to get a2. (The divisor is a3+1, which is non-zero)

Finally, let do the following for each x from 2 to n−2. We've known the values of a1…ax+1. Since we've inserted a tile with value x+1 before inserting x, we can use division to get ax+2 by the delta of straight subsets and avoid dividing zero.

PinkRabbitAFO gives another solution which inserts tiles with value 1, 2, …, n−1, 1 in order. See more details here.

Solution by SookeSolution by PinkRabbit1336E1 - Chiori и выбор кукол (простая версия) and 1336E2 - Chiori и выбор кукол (сложная версия)

Idea: Sulfox

Tutorial1336E2 - Chiori и выбор кукол (сложная версия)Build linear basis A with given numbers. Suppose:

k is the length of A.S(A) is the set consisted of numbers which can be produced in A.pi is equal to the number of x, where x∈S(A) and popcount(x)=i.ansi is equal to the number of doll picking ways with value i. Thus, ansi=pi⋅2n−k. Algorithm 1

Enumerate each base of A is picked or not, so you can find out the whole S(A) in O(2k) and get p0…pm. Note that you should implement popcount(x) in O(1) to make sure the whole algorithm runs in O(2k).

 Algorithm 2

Let's assume the highest 1-bits in every base are key bits, so in A there are k key bits and m−k non-key bits. We can get a new array of bases by Gauss-Jordan Elimination, such that every key bit is 1 in exactly one base and is 0 in other bases.

Then, let fi,j,s be if we consider the first i bases in A, the number of ways that j key bits are 1 in xor-sum and the binary status of all non-key bits is s. Enumerate i-th base (suppose it is equal to x) is picked or not, we write the state transition: fi,j,s=fi−1,j,s+fi−1,j−1,s⊕x.

At last, we add up fk,j,s to pj+popcount(s). In conclusion, we get an O(k2⋅2m−k) algorithm.

So far, the easy version can be passed if you write a solution which runs Algorithm 1 or Algorithm 2 by the value of k.

 Algorithm 3

We can regard A as a 2m long zero-indexation array satisfying ai=[i∈S(A)]. Similarly, we define a 2m long zero-indexation array Fc satisfying fci=[popcount(i)=c].

By XOR Fast Walsh-Hadamard Transform, we calculate IFWT(FWT(A)∗FWT(Fc)) (also can be written as A⊕Fc). pc is equal to the 0-th number of resulting array. That means pc is also equal to the sum of every number in FWT(A)∗FWT(Fc) divide 2m.

Lemma 1: FWT(A) only contains two different values: 0 and 2k.

Proof: The linear space satisfies closure, which means A⊕A=A∗2k. Thus, FWT(A)∗FWT(A)=FWT(A)∗2k. We can proved the lemma by solving an equation.

Lemma 2: The i-th number of FWT(A) is 2k, if and only if popcount(i & x) is always even, where x is any of k bases in A.

Proof: XOR Fast Walsh-Hadamard Transform tells us, the i-th number of FWT(A) is equal to the sum of (−1)popcount(i & j) for each j∈S(A). Once we find a base x such that popcount(i & x) is odd, the sum must be 0 according to Lemma 1.

Lemma 3: The indices of FWT(A) which their values are 2k, compose an orthogonal linear basis.

Proof: See Lemma 2. If popcount(i & x) is even, popcount(j & x) is even, obviously popcount((i⊕j) & x) is even.

Lemma 4: Suppose B is the orthogonal linear basis. The length of B is m−k.

Proof: We know that A=IFWT(B∗2k), so a0=1=12m∑i=02m−1bi⋅2k. From this, we then find that |S(B)| should be 2m−k, which means the length of B is m−k.

Let the key bits in A are non-key bits in B and the non-key bits in A are key bits in B. Now I'll show you how to get the m−k bases in B. Divide key bits for A and put them to the left. Similarly, we put the key bits in B to the right. Let's make those 1 key bits form a diagonal.

Look at the following picture. Do you notice that the non-key bit matrices (green areas) are symmetrical along the diagonal?

 The proof is intuitive. popcount(x & y) should be even according to Lemma 2, where x is any of bases in A and y is any of bases in B. Since we've divided key bits for two linear basis, popcount(x & y) is not more than 2. Once two symmetrical non-key bits are 0, 1 respectively, there will exist x, y satisfying popcount(x & y)=1. Otherwise, popcount(x & y) is always 0 or 2.

In order to get B, you can also divide A into k small linear basis, construct their orthogonal linear basis and intersect them. It is harder to implement.

Lemma 5: The i-th number of FWT(Fc) only depends on popcount(i).

Proof: The i-th number of Fc only depends on popcount(i), so it still holds after Fast Walsh-Hadamard Transform.

Let wcd be the (2d−1)-th number of FWT(Fc). Again, Fast Walsh-Hadamard Transform tells us:

wcd=∑i=02m−1[popcount(i)=c](−1)popcount(i & (2d−1))Note that popcount(2d−1)=d. Let's enumerate j=popcount(i & (2d−1)). There are (dj) different intersections, each one has (m−dc−j) ways to generate the remaining part of i. So:

wcd=∑j=0d(−1)j(dj)(m−dc−j)It takes O(m3) to calculate all necessary combinatorial numbers and wcd.

Finally, let's consider the sum of every number in FWT(A)∗FWT(Fc). Suppose qi is equal to the number of x, where x∈S(B) and popcount(x)=i. We can easily get:

pc=12m∑d=0m2kqdwcd=12m−k∑d=0mqdwcdJust like Algorithm 1. We can enumerate each base of B is picked or not, find out the whole S(B) in O(2m−k), get q0…qm and calculate p0…pm at last. Since one of A, B has a length of not more than m/2, we just need to enumerate bases of the smaller one in order to pass the hard version in O(2m/2+m3+n).

Solution by SookeBonus1336F - Путешествия

Idea: EternalAlexander

TutorialFirst, let's choose an arbitrary root for the tree. Then for all pairs of paths, their LCA (lowest common ancestor) can be either different or the same.

Then, let's calculate the answer of pairs with different LCAs. In this case, if the intersection is not empty, it will be a vertical path as in the graph below.

 

Here path G−H and path E−F intersects at path B−G.

We can process all paths in decreasing order of the depth of their LCA. When processing a path p we calculate the number of paths q, where q is processed before p, and the edge-intersection of p and q is at least k. To do this we can plus one to the subtree of the nodes on the path k edges away from the LCA (node C and D for path G−H in the graph above), then we can query the value at the endpoints of the path (node E and F for path E−F). We can maintain this easily with BIT (binary indexed tree, or Fenwick tree).

Next, we calculate pairs with the same LCA. This case is harder.

For each node u we calculate the number of pairs with the LCA u.

 

For a pair of path (x1,y1) and (x2,y2), there are still two cases we need to handle.

Let dfnx be the index of x in the DFS order. For a path (x,y) we assume that dfnx<dfny (otherwise you can just swap them)

In the first case ( the right one in the graph above, where (x1,y1)=(B,E),(x2,y2)=(C,F) ), the intersection of (x1,y1) and (x2,y2) is the path that goes from LCA(x1,x2) to LCA(y1,y2) (path A−D)

In this case the intersection may cross over node u.

For all paths (x,y) with the LCA u. We can build a virtual-tree over all x of the paths, and on node x we store the value of y. Let's do a dfs on the virtual-tree. On each node a we calculate pairs (x1,y1),(x2,y2) that LCA(x1,x2)=a. For x1 , let's go from a to y1 for k edges, assume the node we reached is b, all legal y2 should be in the subtree of b.

We can use a segment tree on the DFS-order to maintain all ys in the subtree and merge them with the small-to-large trick, meanwhile, iterate over all x1 in the smaller segment tree, count the valid y2's in the larger segment tree.

In fact, you can use HLD (heavy-light decomposition) instead of virtual-tree, which seems to be easier to implement.

Now note that the solution above is based on the fact that the intersection of (x1,y1) and (x2,y2) is the path that goes from LCA(x1,x2) to LCA(y1,y2). But it is not always true, so here we have another case to handle.

In this case, (the left one in the graph above), the intersection is definitely a vertical path that goes from u to LCA(y1,x2). This can be solved similarly to the case of different LCAs.

The overall complexity of this solution is O(mlog2m+nlogn).

Solution by EternalAlexander

Codeforces Round #634 (Div. 3) Editorial

By vovuh, history, 3 years ago, In English1335A - Candies and Two Sisters

Idea: vovuh

Tutorial1335A - Candies and Two SistersThe answer is ⌊n−12⌋, where ⌊x⌋ is x rounded down.

Solution1335B - Construct the String

Idea: MikeMirzayanov

Tutorial1335B - Construct the StringIf we represent letters with digits, then the answer can be represented as 1,2,…,b,1,2,…,b,…. There is no substring containing more than b distinct characters and each substring of length a contains exactly b distinct characters because of the condition b≤a.

Time complexity: O(n).

Solution1335C - Two Teams Composing

Idea: MikeMirzayanov

Tutorial1335C - Two Teams ComposingLet the number of students with the skill i is cnti and the number of different skills is diff. Then the size of the first team can not exceed diff and the size of the second team can not exceed maxcnt=max(cnt1,cnt2,…,cntn). So the answer is not greater than the minimum of these two values. Moreover, let's take a look at the skill with a maximum value of cnt. Then there are two cases: all students with this skill go to the second team then the sizes of teams are at most diff−1 and maxcnt correspondingly. Otherwise, at least one student with this skill goes to the first team and the sizes are at most diff and maxcnt−1 correspondingly. So the answer is max(min(diff−1,maxcnt),min(diff,maxcnt−1)).

Time complexity: O(n).

Solution1335D - Anti-Sudoku

Idea: vovuh

Tutorial1335D - Anti-SudokuWell, if we replace all occurrences of the number 2 with the number 1, then the initial solution will be anti-sudoku. It is easy to see that this replacement will make exactly two copies of 1 in every row, column, and block. There are also other correct approaches but I found this one the most pretty.

Solution1335E1 - Three Blocks Palindrome (easy version)

Idea: MikeMirzayanov

Tutorial1335E1 - Three Blocks Palindrome (easy version)Let's precalculate for each number c (0-indexed) the array prefc of length n+1, where prefc[i] is the number of occurrences of the number c on the prefix of length i. This can be done with easy dynamic programming (just compute prefix sums). Also let sum(c,l,r) be prefc[r+1]−prefc[l] and it's meaning is the number of occurrences of the number c on the segment [l;r] (0-indexed).

Firstly, let's update the answer with maxc=025prefc[n] (we can always take all occurrences of the same element as the answer). Then let's iterate over all possible segments of the array. Let the current segment be [l;r]. Consider that all occurrences of the element in the middle block belong to al,al+1,…,ar. Then we can just take the most frequent number on this segment (cntin=maxc=025sum(c,l,r)). We also have to choose the number for the first and the last blocks. It is obvious that for the number num the maximum amount of such numbers we can take is min(sum(num,0,l−1),sum(num,r+1,n−1)). So cntout=maxc=025min(sum(c,0,l−1),sum(c,r+1,n−1)). And we can update the answer with 2cntout+cntin.

Time complexity: O(n2⋅AL), where AL is the size of alphabet (the maximum value of ai).

Solution1335E2 - Three Blocks Palindrome (hard version)

Idea: MikeMirzayanov

Tutorial1335E2 - Three Blocks Palindrome (hard version)I'll take some definitions from the solution of the easy version, so you can read it first if you don't understand something. Let sum(c,l,r) be the number of occurrences of c on the segment [l;r].

We will try to do almost the same solution as in the easy version. The only difference is how do we iterate over all segments corresponding to the second block of the required palindrome. Consider some number which we want to use as the number for the first and third blocks. If we take k occurrences in the first block then we also take k occurrences in the third block. Let's take these occurrences greedily! If we take k elements in the first block (and also in the third block) then it is obviously better to take k leftmost and k rightmost elements correspondingly.

Define posc[i] be the position of the i-th occurrence of the number c (0-indexed). So, if posc is the array of length sum(c,0,n−1) and contains all occurrences of c in order from left to right then let's iterate over its left half and fix the amount of numbers c we will take in the first block (and also in the third block). Let it be k. Then the left border of the segment for the second block is l=posc[k−1]+1 and the right border is r=posc[sum(c,0,n−1)−k]−1. So let cntin=maxc=0199sum(c,l,r) and cntout=k and we can update the answer with 2cntout+cntin.

It is easy to see that the total number of segments we consider is O(n) so the total time complexity is O(n⋅AL) (there are also solutions not depending on the size of the alphabet, at least Mo's algorithm in O(nn−−√), but all of them are pretty hard to implement so I won't describe them here).

And I'm also interested in O(nlogn) solution, so if you know it, share it with us!

Solution1335F - Robots on a Grid

Idea: MikeMirzayanov

Tutorial1335F - Robots on a GridFirst of all, I want to say about O(nm) solution. You can extract cycles in the graph, do some dynamic programming on trees, use some hard formulas and so on, but it is a way harder to implement than the other solution that only has an additional log, so I'll describe the one which is easier to understand and much easier to implement.

Firstly, consider the problem from the other side. What is this grid? It is a functional graph (such a directed graph that each its vertex has exactly one outgoing edge). This graph seems like a set of cycles and ordered trees going into these cycles. How can it help us? Let's notice that if two robots meet after some move, then they'll go together infinitely from this moment. It means that if we try to make at least nm moves from each possible cell, we will obtain some "equivalence classes" (it means that if endpoints of two cells coincide after nm moves then you cannot place robots in both cells at once).

So, if we could calculate such endpoints, then we can take for each possible endpoint the robot starting from the black cell (if such exists) and otherwise the robot starting from the white cell (if such exists).

How can we calculate such endpoints? Let's number all cells from 0 to nm−1, where the number of the cell (i,j) is i⋅m+j. Let the next cell after (i,j) is (ni,nj) (i.e. if you make a move from (i,j), you go to (ni,nj)). Also, let's create the two-dimensional array nxt, where nxt[v][deg] means the number of the cell in which you will be if you start in the cell number v and make 2deg moves. What is the upper bound of deg? It is exactly lognm=⌈log2(nm+1)⌉.

Well, we need to calculate this matrix somehow. It is obvious that if the number of the cell (i,j) is id and the number of the next cell (ni,nj) is nid then nxt[id][0]=nid. Then let's iterate over all degrees deg from 1 to lognm−1 and for each vertex v set nxt[v][deg]=nxt[nxt[v][deg−1]][deg−1]. The logic behind this expresion is very simple: if we want to jump 2deg times from v and we have all values for 2deg−1 calculated then let's just jump 2deg−1 times from v and 2deg−1 times from the obtained vertex. This technique is called binary lifting.

Now we can jump from every cell nm times in O(lognm) time: just iterate over all degrees deg from 0 to lognm−1 and if nm has the deg-th bit on, just jump from the current vertex 2deg times (set v:=nxt[v][deg]). The rest of solution is described above.

Time complexity: O(nmlog2nm).

SolutionSolution (actually _overrated_, fastest O(nm log nm))

Codeforces Round #633 Editorial

By McDic, history, 3 years ago, In EnglishHello! I hope all of you enjoyed my contest!

1339A - Filling DiamondsThe key observation of this problem is, wherever you put vertical diamond at some point, all other places are uniquely placed by horizontal diamonds like picture below.

There are n places you can put vertical diamond, so answer is n for each test case.

Behind story of A:

I tried to make the easiest Div2A ever. Will it work? :)1339B - Sorted Adjacent DifferencesSort the list, and make an oscillation centered on middle element like picture below.

In this way, you will always achieve to make |ai−ai+1|≤|ai+1−ai+2| for all i. Time complexity is O(nlogn).

Behind story of B:

I tried to block various heuristics. There were some critical heuristics which could pass so many cases. Fortunately I blocked them during testing period, so I hope there won't be much FST this time.1338A - Powered AdditionFirst, let's define b as ideal destination of a, when we used operations.

Observation 1. Whatever you select any b, there is only one way to make it, because there is no more than single way to make specific amount of addition. That means we just have to select optimal destination of a.

For example, if you want to make a1 from 10 to 21, then you must do 10→11→13→21. There is no other way to make 10 to 21 using given operations.

So now we have to minimize max(b1−a1,b2−a2,…,bn−an), as smaller differences leads to use shorter time to make a nondecreasing.

Observation 2. b is optimal when bi is the maximum value among b1,b2,…,bi−1 and ai.

Because for each position i, we have to make bi−ai as smallest possible. Since bi should be not smaller than previous b values and also ai, we derived such formula.

So from position 1,2,…,n, greedily find a bi, and check how many seconds needed to convert ai to bi. The answer is maximum needed seconds among all positions.

Time complexity is O(n), but you can do O(nlogn) with "std::set" or whatever.

Behind story of D2C/D1A:

Originally, there was a different problem for this position. But it used XOR. As I made new D2E/D1C problem, I threw old D2C/D1A away and put this.1338B - Edge Weight AssignmentLet's make an easy and good construction which can solve actual problem. Now reroot this tree at any leaf like picture below;

Our goal in this construction is, we are trying to make xor(path(l1,lca(l1,l2)))=xor(path(l2,lca(l1,l2)))=xor(path(root,lca(l1,l2))) for all two leaves l1 and l2 to satisfy xor(path(l1,l2))=0.

First, let's solve about minimum f value.

Observation 1. You can prove that minimum value of f is at most 3, by following construction;

Since we pick any leaf as root, root is not at the top in this picture.Weight of edges are only determined by degree of two vertices and whether that edge is connected to leaf or not. So answer for minimum value is at most 3.

Observation 2. If there is any construction such that f=2, then it is always possible to have construction of f=1. Because if f=2 then there should be even number of edges for each weight, and you can simply change all weights them to single value without violating validity of edge weight assignment.

If you want to check validity of f=1 assignment, then you can simply check if all leaves have same parity of distance from root. Because distances between all nodes should be even.

Now let's solve about maximum value.

Observation 3. You can solve maximum value of f by following construction;

So for each non-root vertex i, assign weight to edge between i and pi by followings (pi is parent of vertex i);

If i is not leaf, then assign 2i as weight.Otherwise, assign xor(path(root,pi)) as weight.This will differentize all edges' weights except for multiple leaves's edges which are connected to single vertex, because every non-leaf vertex have different weights of edge to its parent.

So the answer for maximum value is e−l+m, where

e is number of edges in this tree.l is number of leaves in this tree.m is number of non-leaves which has at least one leaf as its neighbor.Time complexity is O(n).

——————

(Update) There is an another way to approach, provided by Darooha.

If you label vertices instead of edges where all leaves have same label and none of neighbors have same label, then you can consider edge weight as xor of two vertices' labels, so this is basically equivalent to original problem.

Now for minimum, you can see that labelling 0 to leaves, and 1,2 to non-leaves are enough, so you can prove minimum value of f is at most 3. In same manner, you can try parity checking to check if f value can be 1 or not.

For maximum, assign 0 to all leaves and assign all different values(21,22,…) to non-leaf vertices, then you can see all edge weights(except leaves connected to same vertex) are different.

Behind story of D2D/D1B:

This problem is the most popular problem among testers. I also like this problem a lot.1338C - Perfect TriplesLet's try mathematical induction.

First, suppose you have fully used numbers only between 1 and 4n−1 inclusive. Now we are going to use all numbers between 4n and 4n+1−1 inclusive by following methods. Following picture is description of a, b and c in bitwise manner;

First row means we have already used all numbers until 4n−1. Other 3 rows mean a, b and c.Keep in mind that a, b, and c are the lexicographically smallest triple, so a⊕b=c and a<b<c should be satisfied at the same time.

Observation 1. a2n=1, a2n+1=0, b2n=0, b2n+1=1, c2n=c2n+1=1. Otherwise, a<b<c condition won't be satisfied, because top two digits of a, b, c are either 01, 10, and 11.

Then we have more freedom in lower digits, because since the highest 2 digits are all different, then we can fill lower digits of three numbers independently. Now look at picture below;

This table shows you how to fill each 2 digits of a, b and c.Observation 2. For each 2 digits, a, b and c should have form like this. Of course, you can use mathematical induction again here; Try to prove this in only 2 digits at the first, then expand this lemma to 4 digits, 6 digits, ..., 2n digits.

Now you know the pattern of digits of a, b, and c. Apply this pattern for each test case. Time complexity is O(logn).

Behind story of D2E/D1C:

Feedback for this problem was too different by testers.I made this problem by modifying Number Discovery, which is one of my previous problems.If you OEIS this, then you may find you can use Nimber Arithmetic to solve this.1338D - Nested Rubber BandsObservation 1. You have to generate optimal sequence which is subsequence of path between some two vertices. Neighbors of vertices in optimal sequence will be used as nested rubber bands.

This is an example of conversion. Red vertices are picked sequence, and blue vertices are neighbor of red vertices which are used as nested rubber bands.The reason why black vertices can't be used as nested rubber bands is, basically you have to make a tunnel between any two blue lines, but it's impossible, because in each tunnel there is at least one red vertex which blocks complete connection on tunnel.

Also, this can be described as finding maximum independent set on subtree, which consists of vertices which has at most 1 distance from the optimal path connection of red vertices. Now your goal is to maximize number of blue vertices.

Observation 2. The distances between two adjacent red vertices are at most 2. Adjacent in this sentence means adjacent elements in generated optimal sequence. Because if there is some unused

It is always optimal to take more red vertices than abandoning black vertices.Note that if there are two black vertices between two red vertices, then we cannot use both of them as blue vertices.

From those two observations, construct tree DP and run for it. Time complexity is O(n).

Behind story of D1D:

This problem was supposed to be D2E at first. But all LGM testers failed this problem during VC, so we thought that this problem's difficulty is high. Meanwhile, I found that old D1D problem can be easily googled, so we removed that problem, push this problem to be D1D, and made another D1C problem. I will share old D1D later.1338E - JYPnationThe solution contains several tricky observations, but its not hard to prove each of them seperately, so I will mention only the key points of the solution and proof.

Firstly, we should repeatedly remove points that have no in-degree. We can calculate their contribution easily.

For a node x, define in(x) to be the set of nodes u that u→x exists.

Lemma 1: in(x)∪x has no cycles for any node x.

Let's pick X to be the node with maximum in-degree.

Let P = in(X)∪X, and let Q = Z∖P, where Z is the set of all vertices.

Lemma 2: There exist nodes U∈Q,V∈P, such that U→V exists.

Let R = in(V)∩Q, and let S = Q∖RLemma 3: For all nodes A∈S,B∈R, A→B exists.

Lemma 4: S has no cycles, R has no cycles.

Lemma 5: P has no cycles, Q has no cycles.

That means we have partitioned the graph into two sets of nodes, where each set is completely ordered.

Lets label the nodes in P by Pi where i is an integer from 1 to |P|, such that for two nodes Pi and Pj, Pj→Pi exists iff j>i.

Label nodes in Q by Qi in similar manner.

Define inP(x) to be the set of nodes u∈P that u→x exists.

Define inQ(x) to be the set of nodes u∈Q that u→x exists.

Lemma 6a: If |inQ(Pi)|=|inQ(Pj)| then inQ(Pi)=inQ(Pj).

Lemma 6b: If |inP(Qi)|=|inP(Qj)| then inP(Qi)=inP(Qj).

Final observations:

dis(Pi,Pj)=1 iff i>jdis(Pi,Pj)=2 iff i<j and |inQ(Pi)|≠|inQ(Pj)|dis(Pi,Pj)=3 iff i<j and |inQ(Pi)|=|inQ(Pj)|dis(Qi,Qj)=1 iff i>jdis(Qi,Qj)=2 iff i<j and |inP(Qi)|≠|inP(Qj)|dis(Qi,Qj)=3 iff i<j and |inP(Qi)|=|inP(Qj)|dis(Pi,Qj)+dis(Qj,Pi)=3Finally, we can count the answer in O(N2) by the above observations.

Behind story of D1E:

Thanks tzuyu_chou for writing this problem. She is genius in both singing and problemsolving.

Codeforces Round #632 (Div. 2) editorial

By PuRpLe_FoReVeR, 3 years ago, In EnglishI hope you liked problems!

Sorry for incorrect placement of problems. I had to do swap(E, F).

1333A - Little ArtemIn this problem it is enough to simply paint the upper left corner white and all the others black for any size of the board Like this:

And there are W=1 (cell with coordinates {1,1}) and B=2 (cells with coordinates {1,2} and {2,1}).

In the first version, the task restrictions were 1≤n,m, but we thought it would be too difficult for div2A.

Solution C++1333B - Kind AntonFirst of all, note that we can add an element with index i to an element with index j iff i<j. This means that the element an cannot be added to any other element because there is no index j>n in the array. This is why we can first equalize the elements an and bn. If an=bn, they are already equal. If an<bn, then we need to have element equal to 1 along the elements a with indexes {1,...,n−1}. For an>bn, we need to have −1 along these elements. After the elements with index n become equal, we can go to the element with index n−1 and do the same. Then indexes n−2, n−3, ..., 1. You can implement this idea yourself!

Final time complexity: O(n)Solution C++1333C - Eugene and an arrayLet's solve this problem in O(n2×log(n))for now.

Note that if the subarray [ai,...,aj] is good, then the subarray [ai,...,aj−1] is also good, and if the subset [ai,...,aj] is not good, then the subarray [ai,...,aj+1] is not good either. Then for each left border ai we want to find the rightmost border aj such that [ai,...,aj] is good and add to the answer j−i+1 (subarrays [ai,...,aj],[ai,...,aj−1],...,[ai]) [1]. Let's denote the rightmost border j for border i as R(i).

Let's calculate the prefix-sum of the array P.

P0=0,Pi=a1+..+ai,1≤i≤n.

Note that a subset of [ai,...,aj] has a zero sum iff Pi−1=Pj. Then the subset [ai,...,aj] is a good iff sum of prefixes [Pi−1,...,Pj] has no duplicates [2].

Using [1] and [2], we can simply iterate over i from 0 to n and over j from i to n and count the set of prefix sums [Pi,...,Pj]. The first moment j0 when this set contains duplicates gives us the rightmost border j0−1, and we add (j0−1)−i (no +1, because it is an array of prefix sums) to answer.

To improve this solution to O(n×log(n)), we need to note that R(i) is monotonous over i. Now we can iterate over i from 0 to n and over j from R(i−1) to n uses a set of prefix sums from the previous iteration. Thus we have a solution O(n×log(n)), because j points to each element of the array exactly once.

If you code in C++, it is important not to use std:: unordered_set in this task, but use std::set. One of the participants hacked the solution using std:: unordered_set, using collisions in this structure. I highly recommend you to read this blog for more info https://codeforces.com/blog/entry/62393.

Final time complexity: O(n×log(n))Solution C++1333D - Challenges in school №41If solution exist let's count the minimum and maximum bounds for k for initial arrangement of children. A minimum k achieved all possible pairs of children turn theirs heads at every step. The maximum k reached if only one of possible pairs of children turn theirs heads at every step. This values is easy to count, I'll leave it to you!

If k from the statement not fit within our bounds, then we need to print −1. Otherwise solution exist and we need to construct them. For each next move we can use all pairs of children to turn theirs heads, decrease k by 1 and recalculate maximum bound (lets call it U) on k (just decrease them on the number of pairs used). If after moving new value of k fits in the bound (k≤U), then we proceed to the next iteration. Otherwise, we roll back to the previous iteration and use U−k+1 pairs in this move. Number of remaining moves will be k−1 and upper bound will be U−(U−k+1)=k−1. And from that moment, just use only one pair in one move to the end of the process (to find one of the pair quickly we need to store them in the queue).

Final time complexity: O(n2)Solution C++1333E - Road to 1600First of all notice that there are no such boards for N=1,2. Then you can find an example for N=3 by yourself or with counting all cases with program. One of possible examples (I find it using paper, pencil and my hands):

N=3:

For large N we can walk by spiral (like snake) to the case N=3.

N=4:

N=5:

Rook and Queen first going in a spiral and arrive to N=3 case. It can be used any of such spiral, not just this one.

Final time complexity: O(N2)Solution C++1333F - Kate and imperfectionLet A={a1,a2,...,ak} be one of the possible subsets with smallest imperfection. If for any number ai in A not all of its divisors contained in A then we can replace ai with one of it divisor. The size os the subset does not change and imperfection may only decrease. Then we can assume that for any ai all of it divisors contained in A. Let d(n) be the greatest divisor of n exclude n (d(1)=1). Since A contains element with its divisors then smallest gcd of pair of an elements not less than maximum of d(ai) over elements of A (because A contains ai with d(ai)). And for any element ai there is no element aj<ai in A with gcd(ai,aj)>d(ai) (because d(ai) is the greatest divisor). Then imperfection of A is equal to greatest d(ai) over elements of A. After this observation we can just sort elements {1,...,n} by theirs d(∗) and take smallest k for every 2≤k≤n. You can calculate d(∗) using the sieve of Eratosthenes.

Final time complexity: O(n×log(n))Solution C++

Codeforces Round #631 Editorial

By dreamoon_love_AA, history, 3 years ago, In English1330A - Dreamoon and Ranking CollectionThe total number of rounds this person participates after x more rated contests is n+x. So the number of places this person collects cannot exceed n+x. Then we can iterate k from n+x to 1. In each iteration, let r be the number of integers from 1 to k which doesn't appear in ai. This person can collect all places from 1 to k if only if r≤x. So the answer is the first k meeting the condition r≤x when iterating. The solution can be implemented in time complexity O((n+x)2) as a reference solution.

There are also many O(n) solutions that can solve this problem. But in the experience of author and testers, it's easy to make some mistake in the detail when writing O(n) solution : ) Please try it by yourself.

author's code:1330B - Dreamoon Likes PermutationsLet ma be the maximum value of all elements in a .

If you can recover the the array a to two permutations p1 abd p2, then ma must be max(len1,len2).

So there are at most two case:

1. len1=ma,len2=n−ma,

2. len1=n−ma,len2=ma.

We can check the two cases separately with time complexity O(n). Please see the example code for detail.

author's code1329A - Dreamoon Likes ColoringAfter reading the statement, you may find this is a problem that will be tagged as "constructive algorithms" in Codefores. And you also can find this problem is just problem A in Div. 1. So basically we can expect there exist some simple methods to solve it.

If a "constructive algorithms" problem asks you to determine whether the solution exists or not, usually they have a common pattern(especially in problem hardness which is before Div. 1 B(inclusive)), this is, there are some simple constraints can divide test data into "Yes", and "No". Therefore, the first thing to solve this problem is finding some trivial conditions that cannot achieve Dreamoon's hope.

After some try, you may find there are two trivial conditions that achieving Dreamoon's hope is impossible. The two conditions are listed as follows:

1. Sum of li is less than n. In this condition, there always is at least one empty grid.

2. There exists some i such that li+i−1>n. If n−li<i−1, it means after you do i-th operation, there only n−li grid is not colored by i-th color. So at least one of previous i−1 color will disapear after this operation.

Now I want to talk about another feature of some "constructive algorithms" first.

Sometimes, the condition given by the problem is to "open", this is to say that if we added some more strict constraint, the problem is still can be solved. And when the constraint it more strict, we can deduce the solution more easily.

One of common "strict constraint" is "sorted". I believe you have ever seen many problems that the first step is sorting something. Now, we also want to apply "sorted" in the problem.

After applying "sort", we firstly consider the edge cases of above two impossible conditions. The first case is "sum of li is equal to n". In this case, we have a unique solution after applying "sort", pi=m−∑j=i+1mlj+1. The second case is li+i−1=n is hold for all i. In this case, there is also a unique solution that pi=i. The two cases coressond to n is largest and n is smallest among all n that exist solutions for same li. And for same li, when we decrase n from the largest possible value, we can just change pi from m−∑j=i+1mlj+1 to i for some smallest indices i to get solution. To sum it up, finally, we get the answer. The answer is just pi=max(i,n−suffix_sum[i]+1), for each i.

There exist many other methods to construct solutions. I believe the construction method one can think out is relative to the study experience.

author's code1329B - Dreamoon Likes SequencesFirstly, we define a function h(x) as the position of the highest bit which is set to 1 in a positive integer x. For example, h(1)=0,h(2)=h(3)=1, and h(4)=h(7)=2.

If the constraints in this problem is satisfied, there is some observations, h(ai)=h(bi) and h(ai) must less than h(ai+1). And luckily, if h(ai)<h(ai+1) is always hold, the constraints in this problem will also be satisfied (Please prove them by yourself or wait for someone prove it in comments : ) P.S. the link of proof written by someone is int the end. )

In other words, for each non-negative integer v, there is at most one i such that h(ai)=v. This is, at most one of the positive numbers in range [2v,min(2(v+1)−1,d)] can occur in ai. In each non-empty range, we can choose one integer in it or don't choose anyone. So for each of them we have min(2(v+1)−1,d)−2v+2 different choice. Then according to the rule of product, we can multiply all number of choices for different v and minus the value by one to get the answer. For example, when d = 6, there are 2 choices for v=0, 3 choices for v=1, 4 choices for v=2. So the answer for d=6 is 2×3×4−1=23.

UPD: onthefloor provides proof for what I mention here.

author's code1329C - Drazil Likes HeapThe property of heap we concern in this problem mainly are:

1. The tree is a binary tree, each node has a weight value.

2. The weight of a node is always larger than the weight of its children.

3. We use a[I] to record the weight of vertex i, and the number of its children are 2×i and vertex 2×i+1 (if exist).

Another key point we should consider seriously is before all operations and after all operations, the tree must be a perfect binary tree. Many contestants didn't notice the constraint during the contest.

I think there are two different thinking directions for this problem. One is considering node from bottom to top. Another one is considering node from top to bottom. For me, from bottom to top is more intuitive.

Now we talk about "from bottom to top" first, it means we consider node from larger index to smaller index in the tree after all operations (call it final tree after). For the leaves in the final tree, it's not hard to know, the minimum possible final weight of each leaf is the minimum weight of nodes in its subtree before all operations (call it beginning tree after). For the other nodes in the final tree, its weight must satisfy two constraints, one is it should be larger than the final weight of his children, another is the weight should exist in its subtree of the beginning tree. Luckily, these lower bounds are all constraints we should consider to get the answer. For each leaf in the final tree, we maintain a data structure that stores all weight of its subtree in the beginning tree. Then the minimum value in this data structure is its final weight. For other nodes in the final tree, we merge the two data structures of its children. the remove all value which is less than the final weight of his children. There are many data structure can do these operations, such as min heap(author's code) or sorted array(isaf27's code).

With the above method, we get the minimum possible sum of the remaining 2g−1 elements. But we still don't know how to construct it. All we know is which weight values are reaming in the final tree. Now I want to prove that no matter how the order I call the function f, if the remaining weight values set is the same, the final shape of the final tree will be the same.

This time I prove it from top to bottom. We only know which weight values set to remain in the final, Then We iterate node from smallest index to the larger one. We always can determine the weight value of the iterated node, because the weight value only can be the maximum value in its subtree. This trait also can let us know that the final tree we get in our method is a perfect binary tree.

Conclude all things above. after we can apply the function f from bottom to top on these nodes with weight value doesn't exist in the final tree.

In the "from bottom to top" method, it has some thinking level difference between calculating the minimum sum and constructing a list of possible operations. So I determine let competitors output the operations.

- - -

Now we talk about the "from top to bottom" method. The main idea of this method is iterating index from 1 to 2g−1 and in each iteration, applying the function f on i-th node until the shape of the final tree is impossible to become a perfect binary tree. The method is quite easy to write and almost has no difference when asking you to output the operations. But I think it's hard to prove. Evenly, I think the solution should be wrong until I write this solution and test it.

Firstly I want to prove the minimum possible final weight value of node 1 is the same as the above "from top to bottom" method get. We call the value as mi1. If some algorithm B can get more small weight value in the final tree, It means all weight values which are not smaller than mi1 disappear. But according to the conclusion "if the remaining weight values set is the same, the final shape of the final tree will be the same.". the final tree generated by B can also get with firstly applying the function f on node 1 at least one more time than above "from top to bottom" algorithm, and do some other operations. But it will make the final tree is impossible to be the perfect binary tree. Now we disprove it.

Now we want to prove the final weight value of node i(i>1) is the same as the above "from top to bottom" method get. Only when applying function f on ancestors and descendants of node i will affect the final weight value of node i. And when we apply on its ancestors, the f may recursively apply f on it at most once. So each time f applies on its ancestors is equivalent to apply on itself once or do nothing. Therefore, The proof can be don as what we do on node 1 just by only considering the subtree of node i.

Now, we have proved the "top to bottom" algorithm can make each node of the final tree has the minimum possible weight value.

When I found the "top to bottom" algorithm during preparing the contest, I ever consider changing the problem to something else because the method is too easy to guess and to write. But I have no other more proper problem that can be used. It's a little pity for me.

a super simple solution which is differet to this blog provided by Swistakk.

author's code (from bottom to top with min heap)isaf27's code(from bottom to top with sorted array)author's code (from top to bottom)1329D - Dreamoon Likes StringsDenoting a string of length two which contains two i-th letter as ti. For example, t0 is "aa", t1 is "bb" .

And let ci be the occurrence count of ti as a substring in a. For example, when a= "aaabbcaa", c0=3,c1=1, and for other i, ci=0.

In this problem, if only asking contestants output the smallest number of steps to make a empty, the answer is simple. You just need to output max(⌈∑ci2⌉,max0≤i≤25ci)+1. (I will call this fomula for a given string a as f(a) behind.)

Firstly, let's see how the value of all ci change in one step. There are only four kinds of possible change for all ci.

1. For some i, ci is decreased by one. For example, deleting the first two letters of "abb".

2. For two different values i and j. ci and cj are both decrease by one. For example, deleting the second and third letter of "aabb".

3. Nothing changes for all ci. For example, deleting the first letter from "abb".

4. For some i, ci is added by one. For example, deleting the second letter from "aba".

Now, Let's consider how will these changes affect the f(a). Amazing! All possible changes will decrease the value of f(a) at most one! So if we can construct an algorithm to achieve it, then we solve it.

Now I introduce an algorithm of which time complexity is O(n).

The algorithm can be divided into three phases.

1.

In this phase, we maintain a stack that stores the position of substring ti in the current string from left to right. When we iterate to a string ti, there are two cases. Assum the top element in the stack is tj. When i is equal to j, we just add t_i into the stack. But if i≠j, we do a step that removing all letters from the second letter of tj to the first letter of ti. and pop tj from the stack. If there is any moment that ⌈∑ci2⌉≤max0≤i≤25ci)+1 is hold (So maybe you won't do anything in this phase), the phase will be terminated.

2.

In this phase, there must be an unique x satisifying cx≥⌈∑ci2⌉.

we also maintain a stack that stores the position of substring ti in the current string from left to right. But when we iterate to a string ti, the action we should do are different from the first phase.

Assum the top element in the stack is tj. When there is exactly one number among i and j is x, we do a step that removing all letters from the second letter of tj to the first letter of ti. and pop tj from the stack. Otherwise, we just add ti into the stack.

3.

When the algorithm enters the phase, for all i except x, ci will be 0. So we can use all occurrence of tx to divide the string into cx+1 segment and remove each segment one by on. After that the string will become empty.

Please see the reference code for the implementation detail.

author's code1329E - Dreamoon Loves AAThe idea of this problem comes to my brain when I recall that I'm cooking and I want to cut a carrot into many pieces and make the size of each piece as evenly as possible. I think this problem is very interesting. So that's why I determine to prepare a Codeforces contest after so many years. I hope I can share this problem with as many people as possible.

There are some methods to solve this problem. I only show the most beautiful one below. This method is given by isaf27 (And most AC users solve it with this method. I admire them very much).

Firstly, we translate the problem into a more convenient model.

Let pm+1=n, ai=pi−pi−1 (1≤i≤m+1), M=m+1, and K=m+1+k. Then the problem is equivalent to we want to do integer partition on M integers a1,a2,…,aM, such that ai is divided into di positive integers where ∑di=K. Our target is to minimize the difference between the largest integer and smallest integer after division.

An important observation is, we always can achieve our target by making the difference of the largest integer and the smallest integer that is divided from the same integer is at most one. So our target is minimizing max1≤i≤M(⌈aidi⌉)−min1≤i≤M(⌊aidi⌋) where 1≤di and ∑i=1∼Mdi=K.

There are two key values under the constraints 1≤di and ∑i=1∼Mdi=K, one is the minimum value of max1≤i≤M(⌈aidi⌉) (Let's call it U after), another is the maximum value of min1≤i≤M(⌊aidi⌋) (Let's call it D after). L and U can be calculated by binary searching with time complexity O(MlogM). (This part is relatively easy so I won't mention it here.)

There are two conditions after calculating L and U. One is, for all valid i, there exists at least one positive integer di such that L≤⌊aidi⌋≤⌈aidi⌉≤U. In this case, the answer is just U−L. proof is as below.

Let dui as the largest positive integer such that L≤⌊aidi⌋ and dli as the smallest positive integer such that ⌈aidi⌉≤U. By the define of L and U, we can get ∑i=1∼Mdui≥K and ∑i=1∼Mdli≤K. So we always can choose some d_i where dl≤di≤du such that ∑i=1∼Mdi=K and L≤⌊aidi⌋≤⌈aidi⌉≤U.

Now the essential condition is resolved. Another condition is there are some indices i that we cannot find any positive integer di such that L≤⌊aidi⌋≤⌈aidi⌉≤U. Let's call the set of these indices as I. For each element j∈I, let's calculate another two key values for index j. That is, we want to know the closest two values of ajdj near to range [L,U] (one is above [L,U] another is below [L,U]). Formulaically say, let v be the smallest dj such that ⌊ajdj⌋<L and call ⌊ajv⌋ as xj. And let u be the largest dj such that ⌈ajdj⌉>U and call ⌈aju⌉ as yj. Imaging we have a set S initially contains two positive integer L and U. Now for each j∈I, we want to choose either xi or yi to add to S. Then the minimum possbile value of difference between largest element and smallest element in S is the answer in this condition. The minimum possible value can be calculated as below.

Initially, for all j∈I, we choose yj to add to the set S. Then iterate from largest yj to smallest yj. In each iteration, we remove yj from S and add xj to S. The minimum possible value will exist during the process. These steps can also be done in time complexity O(MlogM).

The proof of correctness of the second condition is almost same as the first condition. We always can adjust di such that ∑i=1∼Mdi equal to K for constructed result.

The overall time complexity is O(mlogm) for the above method.

In the end, I want to thanks everyone who takes part in this contest. The worth of the contest will reveal on you, when you learn thing from these problems. Thanks a lot.

isaf27's solutionauthor's solution

Codeforces Round #630 Editorial

By triple__a, history, 3 years ago, In EnglishHope you enjoy those tasks!

1332A - Exercising Walk

Tutorial1332A - Exercising WalkThe key observation is x-axis and y-axis is independent in this task as the area is a rectangle. Therefore, we should only consider 1D case (x-axis, for example). The optimal path to choose alternates between right and left moves until only one type of move is possible. And sometimes there is no place to make even one move, which has to handled separately. So the verdict is "Yes" if and only if x1≤x−a+b≤x2 and (x1<x2 or a+b=0).

Solution (python by pikmike)Solution (C++)1332B - Composite Coloring

Tutorial1332B - Composite ColoringThe solution is obvious once one note that for any composite number k, there exists a prime d such that d≤k−−√ and k is divisible by d. Coincidentally, there are exactly 11 primes below 1000−−−−√. Thus, one can color balls according to their smallest divisor. That works because if all numbers of the same color have the same divisor then each pair has at least this divisor in their GCD.

Solution (python by pikmike)Solution (C++)1332C - K-Complete Word

Tutorial1332C - K-Complete WordOne should notice that word s of length n is k-complete if and only if there exists a palindrome t of length k such that s can be generated by several concatenations of t.

So in the final string all characters at positions i, k−i+1, k+i, 2k−i+1, 2k+i, 3k−i+1, … for all 1≤i≤k should all be equal. This helps us to solve the problem independently for each i. To minimize the required number of changes, you should make all the letters equal to the one which appears at these positions the most initially. Calculate that maximum number of appearances and sum up over all i. Be careful with an odd k because the letter in the center of each block has a different formula.

Solution(python by pikmike)Solution(C++)1332D - Walk on Matrix

Tutorial1332D - Walk on MatrixIn fact, the following matrix will work:(217+kk217217+k0k)To find such a matrix, one should find out why the dp solution fails.

One should notice that dp2,2=max(a1,1&a1,2&a2,2,a1,1&a2,1&a2,2) and dp solution will choose the optimal path from (1,1) to (2,2) for later decision. However, we should notice that we can only discard the suboptimal result if and only if anssuboptimal&ansoptimal=anssuboptimal rather than anssuboptimal<ansoptimal. Based on above analysis, we can construct the matrix easily.

In fact, even if n,m is fixed satisfying that n≥2,m≥2 and n⋅m>4, we could easily construct a matrix for a given k based on our 2×3 matrix.

Solution(python by pikmike)1332E - Height All the Same

Tutorial1332E - Height All the SameObservation 1. The actual values in the cells don't matter, only parity matters.

Proof. Using the second operation one can make all the values of same parity equal by applying it to the lowest value until done.

That observation helps us to get rid of the second operation, let us only have the first one.

Observation 2. Player is able to change parity of any pair of cells at the same time.

Proof. For any given cell u and cell v, there exists a path from u to v, namely p=w0w1…wk, such that w0=u and wn=v. Perform operation for adjacent cells wi−1 and wi for all 1≤i≤nObservation 3. If n×m is odd, player can always reach the goal no matter what the initial state is.

Proof. There are two cases: there is an even number of even cells or there is an even number of odd cells. Whichever of these holds, we can change all cells of that parity to the opposite one with the aforementioned operation, making all cells the same parity.

Observation 4. If n×m is even, and ∑ni=1∑mj=1ai,j is even, player can reach the goal.

Proof. Similar to the proof of Observation 3. Proof is omitted.

Observation 5. If n×m is even and ∑ni=1∑mj=1ai,j is odd, player can never reach the goal no matter what strategies player takes.

Proof. Note that applying the operation never changes the parity of the number of cells of each parity (i.e. if we start with an odd number of odd cells and an odd number of even cells, they will both be odd until the end). Thus, there is no way to make zero cells of some parity.

How does that help us to calculate the answer?

The first case (n×m is odd) is trivial, the answer is all grids. Let's declare this as total value.

The second case (n×m is even) is harder. Me and pikmike have different formulas to obtain it but the answer is the same.

WLOG, let's move the range of values from [L;R] to [0;R−L], let k=R−L.

Easy combinatorics solution (me):

Let's find out the number of ways to choose the grid such that the number of even cells is even and 0≤ai≤k.

Suppose that there are E even numbers in [0,k], O odds. Therefore, for any given 0≤i≤nm, the number of ways to have exactly i even numbers should be EiOnm−i×(nmi). Thus, the total answer should be ∑i=0nm/2E2iOnm−2i(nm2i), which should remind you of the Newton expansion.

Note that(E+O)nm=∑i=0nm/2E2iOnm−2i(nm2i)+∑i=1nm/2E2i−1Onm−(2i−1)(nm2i−1)and

(E−O)nm=∑i=0nm/2E2iOnm−2i(nm2i)−∑i=1nm/2E2i−1Onm−(2i−1)(nm2i−1).

Adding those two formulas will get us exactly the formula we were looking for but doubled. Thus, the answer is that divided by 2.

Easy intuition solution (pikmike):

There is a general solution to this kind of problems. Let's try to pair up each valid grid with exactly one invalid grid. Valid in our problem is such a grid that the number of even cells is even. If such a matching exists then the answer is exactly half of all grids (total2).

Let's come up with some way to pair them up. For example, this works but leaves us with two cases to handle.

Let k be odd. For each grid let's replace a0,0 with a0,0 xor 1. You can see that the parity changed, thus the number of even cells also changed its parity. So if the grid was invalid it became valid and vice versa.

For an even k it's slightly trickier but actually one can show that almost all grids pair up with each other and only a single grid remains unpaired. So we can add a fake grid and claim that the answer is total+12.

The algorithm is the following. Find the first position such that the value ai,j on it is not equal to k. Replace it with ai,j xor 1. You can easily see that only grid that consists of all numbers k has no pair.

Solution 1(python by pikmike)Solution 2(python by pikmike)1332F - Independent Set

Tutorial1332F - Independent SetWe will call one vertice is colored if and only if it is in the independent set. And a coloring is valid if and only if no two adjacent vertices are both colored.

Therefore, we are asked to calculate the sum of number of valid colorings over all edge induced subgraphs.

To deal with the task, one should notice that for a edge induced subgraph and one valid coloring, we may add those vertices which are removed due to the generation of edge induced subgraph, and remain it uncolored.

Therefore, for a coloring on the original graph G=(V,E), we could consider removing edges such that it will behave the same with above procedure.

In fact, given a coloring, we can define edge removing is valid if and only if there is no adjacent colored vertice and no isolated vertex is colored. We can actually show that there is almost a one to one corresponding relation betweeen those two procedure except for the case where all vertices remains uncolored and all edges are removed.

Therefore, we can actually solve the following task:

Given a tree G=(V,E), for any given coloring, define a edge removal is valid if it satisfies above constrains.

And it will suddenly becoming something easy to solve with tree dp. Define dpu,0 be the answer for subtree rooted at u with additional constraint such that u is not colored, dpu,1 be the answer where u is colored and dpu be the answer where edges from u to its children are removed.

Therefore, the dp formula should be

dpu,0=∏v(2dpv,0+2dpv,1−dpv)dpu,1=∏v(2dpv,0+dpv,1−dpv)dpu=∏v(dpv,0+dpv,1−dpv)The answer is easily calculated with those three states.

Solution(C++)1332G - No Monotone Triples

Contributor of idea of the solution: awoo

Tutorial1332G - No Monotone TriplesWe will solve this task with the following observations.

Observation 1. If an array x of length k (k≥3) has no monotone triple, then one of the following is true:

x1<x2>x3<x4>x5<…x1>x2<x3>x4<x5>…Observation 2. If an array x of length k (k≥4) has no monotone triple, then its subsequence has no monotone triple.

Observation 3. If an array x of length 4 has no monotone triple, then max(x2,x3)>max(x1,x4), min(x2,x3)<min(x1,x4),vice versa.

Proof. WLOG, we assume max(x2,x3)≤x1, by observation 1 we will know that x1>x2<x3>x4, since x1≥x3, we get a monotone triple (1,3,4), leading to contradiction. Second part can be verified easily.

Observation 4. For every array x of length k (k≥5), x must have monotone triple.

Proof. WLOG, we just need to prove the observation holds when k=5 and cases when not all elements are equal. In that case, one of extremal can be reached in position other than 3. WLOG, we will assume that maximum is reached at position 2. However, x2,x3,x4,x5 cannot be monotone-triple-free, leading to contradiction!

Combining those observations (or Erdos–Szekeres theorem if you know it), we would like to get the following solution, which runs in O(qn4).

If the subsequence is monotone, the answer should be 0.If there exists i,j,k,l such that L≤i<j<k<l≤R and ai, al fails to reach maximum and minimum among those four numbers, the answer should be 4.Otherwise, the answer should be 3.In the following paragraphs, we will only focus on the case of 4. Other stuffs can be dealt similarly (or easily).

O(n2) solution(the observation is crucial to obtain a faster solution)

Notice that constraint is equivalent to that there exists i,j such that ai,aj fails to reach maximum and minimum among ai,ai+1,…,aj. This observation allows us to solve this task in O(n2) with some precalculation. (though it's still not enough to get accepted).

O(nlogn) solution

Let's solve the task for a sequence of a pairwise distinct numbers and then change the conditions to a general sequence.

Let's fix ai — the leftmost element of b and look at what we are asked to find. So there should be some position j to the right of i so that the range of values on positions [i,j] excluding the greatest and the smallest values includes both ai and aj.

Let's process the array from right to left, maintaining two stacks. The top element in both stacks is the currently processed one. Next element of the first stack is the closest to the right element greater than the top one, and the next element of the second stack is the closest to the right smaller than the top one. And the stacks go like that until the end of array.

Iterating over one of these stacks will show the increase of the range of values in one direction, iterating over both at the same time will show how the range of values changes in total.

So I claim that the sequence we are looking for exists iff both stacks include more than 1 element and there is an element to the right of second elements of both stacks such that it is included in neither of the stacks. Naturally that condition tells that there is some position in which neither maximum, nor minimum values are updated.

The values that are in neither of stacks can be maintained in a queue or in a BIT.

Basically, the position when the range of values doesn't change is such a value which is both smaller than the maximum value on the segment and greater than the minimum one. Thus, we can choose ai, the latest elements in both stacks up to that position and that position itself.

How to deal with not pairwise distinct elements? Well, it's enough to change the conditions in stacks to the next greater or equal and the next smaller or equal. However, that will push the elements equal to the current one right next to it to the both stacks. Previously we kinda used the fact that no element except the current one is in both stacks. I think that the easiest way to deal with it is to get the answer for the rightmost of the consecutive equal elements and then just say that the answer for the rest of them is the same. Finally, push all these consecutive equal elements to the both stacks.

As for queries. I previously said that we can take the position where the value range doesn't change. Basically, the first valid position is coincidentally the shortest length valid segment starting from i. So to find the first position you just need to do a binary search over that queue or BIT of the values which are in neither of the stacks. We can easily remember it for each position and then do a range minimum query checking if any of the positions in [l,r] have their shortest right border smaller than r.

Solution (C++)

Codeforces Round #629 (Div. 3) Editorial

By vovuh, history, 3 years ago, In English1328A - Divisibility Problem

Idea: MikeMirzayanov

Tutorial1328A - Divisibility ProblemIf a%b=0 (a is divisible by b), just print 0. Otherwise, we need exactly b−a%b moves to make zero remainder of a modulo b. % is modulo operation.

Solution1328B - K-th Beautiful String

Idea: MikeMirzayanov

Tutorial1328B - K-th Beautiful StringLet's try to find the position of the leftmost occurrence of 'b' (iterate over all positions from n−2 to 0). If k≤n−i−1 then this is the required position of the leftmost occurrence of 'b'. Then the position of rightmost occurrence is n−k so we can print the answer. Otherwise, let's decrease k by n−i−1 (remove all strings which have the leftmost 'b' at the current position) and proceed to the next position. It is obvious that in such a way we consider all possible strings in lexicographic order.

Solution1328C - Ternary XOR

Idea: vovuh

Tutorial1328C - Ternary XORLet's iterate from left to right over the digits of x. If the current digit is either 0 or 2 then we can set ai=bi=0 or ai=bi=1 correspondingly. There are no better choices. And if the current digit xi is 1 then the optimal choise is to set ai=1 and bi=0. What happens after the first occurrence of 1? Because of this choice a is greater than b even if all remaining digits in b are 2. So for each j>i set aj=0 and bj=xj and print the answer. The case without 1 is even easier and in fact we handle it automatically.

Solution1328D - Carousel

Idea: MikeMirzayanov

Tutorial1328D - CarouselThe answer to this problem is at most 3. Let's prove it by construction.

Firstly, if all ti are equal then the answer is 1. Otherwise, there are at least two different values in the array t so the answer is at least 2. If n is even then the answer is always 2 because you can color figures in the following way: [1,2,1,2,…,1,2]. If n is odd then consider two cases. The first case is when some pair of adjacent figures have the same type. Then the answer is 2 because you can merge these two values into one and get the case of even n. Otherwise, all pairs of adjacent figures have different types and if you consider this cyclic array as a graph (cycle of length n) then you can notice that it isn't bipartite so you need at least 3 colors to achieve the answer (color all vertices in such a way that any two adjacent vertices have different colors). And the answer looks like [1,2,1,2,…,1,2,3].

Solution1328E - Tree Queries

Idea: MikeMirzayanov and vovuh

Tutorial1328E - Tree QueriesFirstly, let's choose some deepest (farthest from the root) vertex fv in the query (among all such vertices we can choose any). It is obvious that every vertex in the query should either belong to the path from the root to fv or the distance to some vertex of this path should be at most one. Now there are two ways: write some LCA algorithms and other hard stuff which is unnecessary in this problem or write about 15 lines of code and solve the problem.

Let's take every non-root vertex (except fv) and replace it with its parent. So, what's next? Now the answer is "YES" if each vertex (after transformation) belongs to the path from root to fv. Now we just need to check if it is true.

We can do this using the very standard technique: firstly, let's run dfs from the root and calculate for each vertex the first time we visited it (tin) and the last time we visited it (tout).

We can do this using the following code:

void dfs(int v, int par = -1) {    tin[v] = T++;    for (auto to : g[v]) {        if (to == par) continue;        dfs(to, v);    }    tout[v] = T++;}Initially, T equals zero. Now we have a beautiful structure giving us so much information about the tree. Consider all segments [tinv;toutv]. We can see that there is no pair of intersecting segments. The pair of segments [tinv;toutv] and [tinu;toutu] is either non-intersecting at all or one segment lies inside the other one. The second beautiful fact is that for each vertex u in the subtree of v the segment [tinu;toutu] lies inside the segment [tinv;toutv].

So, we can check if one vertex is the parent of the other: the vertex v is the parent of the vertex u if and only if tinv≤tinu and toutu≤toutv (the vertex is the parent of itself).

How do we check if the vertex u lies on the path from the root to the vertex fv? It lies on this path if the root is the parent of u (it is always true) and u is the parent of fv. This approach can be used for each vertical path (such a path from x to y that lca(x,y) is either x or y).

Time complexity: O(n+m).

Solution1328F - Make k Equal

Idea: MikeMirzayanov

Tutorial1328F - Make k EqualThis problem is just all about the implementation. Firstly, let's sort the initial values and compress them to pairs (i,cnt[val]), where cnt[val] is the number of elements val. The first observation is pretty standard and easy: some equal elements will remain unchanged. So let's iterate over all elements val in some order and suppose that all elements val will remain unchanged. Firstly, we need need=max(0,k−cnt[val]) elements which we should obtain by some moves. The second observation is that we first need to take elements from one end (only less or only greater) and only then from the other (if needed).

Consider the case when we first take less elements. The other case is almost symmetric.

Let needl=min(need,prefcntprv) be the number of less than val which we need to increase to val. If needl=0 then skip the following step. Otherwise, let prefcnti be the number of elements less than or equal to i, prefsumi be the sum of all elements less than or equal to i and prv be the previous value (the maximum value less than val). Then we need to increase all elements less than or equal to prv at least to the value val−1. It costs (val−1)⋅prefcntprv−prefsumprv moves. And then we need needl moves to increase needl elements to val.

And let needr=max(0,need−needl) be the number of elements greater than val which we need to decrease to val if we increased needl elements already. If needr=0 then skip the following step. Otherwise, let sufcnti be the number of elements greater than or equal to i, prefsumi be the sum of all elements greater than or equal to i and nxt be the next value (the minimum value greater than val). Then we need to decrease all elements greater than or equal to prv at least to the value val+1. It costs sufsumnxt−(val+1)⋅sufcntnxt moves. And then we need needr moves to decrease needr elements to val.

So we can update the answer with the sum of values described above and proceed to the next value. Arrays prefcnt,sufcnt,prefsum,sufsum are just simple prefix and suffix sums which can be calculated in O(n) using very standard and easy dynamic programming. Don't forget about the overflow.

Total time complexity: O(nlogn) because of sorting.

Solution

Codeforces round #628 editorial

By mohammedehab2002, history, 3 years ago, In English1325A - EhAb AnD gCda=1 and b=x−1 always work.

Code link: https://pastebin.com/ddHKD09B

First AC: sevlll777

Bonus task: can you count the valid pairs?

1325B - CopyCopyCopyCopyCopyLet the number of distinct elements in a be called d. Clearly, the answer is limited by d. Now, you can construct your subsequence as follows: take the smallest element from the first copy, the second smallest element from the second copy, and so on. Since there are enough copies to take every element, the answer is d.

Code link: https://pastebin.com/hjcxUDmY

First AC: socho

1325C - Ehab and Path-etic MEXsNotice that there will be a path that passes through the edge labeled 0 and the edge labeled 1 no matter how you label the edges, so there's always a path with MEX 2 or more. If any node has degree 3 or more, you can distribute the labels 0, 1, and 2 to edges incident to this node and distribute the rest of the labels arbitrarily. Otherwise, the tree is a bamboo, and it doesn't actually matter how you label the edges, since there will be a path with MEX n−1 anyway.

Code link: https://pastebin.com/u4H7Dtbd

First AC: vintage_Vlad_Makeev

1325D - Ehab the XorcistFirst, let's look at some special cases. If u>v or u and v have different parities, there's no array. If u=v=0, the answer is an empty array. If u=v≠0, the answer is [u]. Now, the length is at least 2. Let x=v−u2 . The array [u,x,x] satisfies the conditions, so the length is at most 3. We just need to figure out whether there's a pair of number a and b. Such that a⊕b=u and a+b=v. Notice that a+b=a⊕b+2∗(a&b), so we know that a&b=v−u2 =x (surprise surprise.) The benefit of getting rid of a+b and looking at a&b instead is that we can look at a and b bit by bit. If x has a one in some bit, a and b must both have ones, so a⊕b=u must have a 0. If x has a zero, there are absolutely no limitation on u. So, if there's a bit where both x and u have a one, that is to say if x&u≠0, you can't find such a and b, and the length will be 3. Otherwise, x&u=0 which means x⊕u=x+u, so the array [u+x,x] works. Can you see how this array was constructed? We took [u,x,x] which more obviously works and merged the first 2 elements, benefiting from the fact that u&x=0.

Code link: https://pastebin.com/7XuMk1v8

First AC: amiya

1325E - Ehab's REAL Number Theory ProblemNotice that for each element in the array, if some perfect square divides it, you can divide it by that perfect square, and the problem won't change. Let's define normalizing a number as dividing it by perfect squares until it doesn't contain any. Notice than any number that has 3 different prime divisors has at least 8 divisors, so after normalizing any element in the array, it will be 1, p, or p∗q for some primes p and q. Let's create a graph where the vertices are the prime numbers (and 1,) and the edges are the elements of the array. For each element, we'll connect p and q (or p and 1 if it's a prime after normalizing, or 1 with 1 if it's 1 after normalizing.) What's the significance of this graph? Well, if you take any walk from node p to node q, multiply the elements on the edges you took, and normalize, the product you get will be p∗q! That's because every node in the path will be visited an even number of times, except p and q. So the shortest subsequence whose product is a perfect square is just the shortest cycle in this graph!

The shortest cycle in an arbitrary graph takes O(n2) to compute: you take every node as a source and calculate the bfs tree, then you look at the edges the go back to the root to close the cycle. That only finds the shortest cycle if the bfs source is contained in one. The graph in this problem has a special condition: you can't connect 2 nodes with indices greater than sqrt(maxAi). That's because their product would be greater than maxAi. So that means ANY walk in this graph has a node with index ≤√maxAi. You can only try these nodes as sources for your bfs.

Code link: https://pastebin.com/4ixLQyvg

Bonus task: try to prove the answer can't exceed 2√maxAi.

1325F - Ehab's Last TheoremLet sq denote ⌈√n⌉.

A solution using DFS treesIf you're not familiar with back-edges, I recommend reading this first.

Let's take the DFS tree of our graph. Assume you're currently in node u in the DFS. If u has sq−1 or more back-edges, look at the one that connects u to its furthest ancestor. It forms a cycle of length at least sq. If u doesn't have that many back-edges, you can add it to the independent set (if none of its neighbors was added.) That way, if you don't find a cycle, every node only blocks at most sq−1 other nodes, the ones connected to it by a back-edge, so you'll find an independent set!

Code link: https://pastebin.com/b9phCSW8

First AC: imeimi

A solution using degreesThere's a pretty obvious greedy algorithm for finding large independent sets: take the node with the minimal degree, add it to the independent set, remove it and all its neighbors from the graph, and repeat. If at every step the node with the minimal degree has degree <sq−1, that algorithm solves the first problem. Otherwise, there's a step where EVERY node has degree at least sq−1. For graphs where every node has degree at least d, you can always find a cycle with length d+1. To do that, we'll first try to find a long path then close a cycle. Take an arbitrary node as a starting point, and keep trying to extend your path. If one of this node's neighbors is not already in the path, extend that path with it and repeat. Otherwise, all of the last node's d neighbors are on the path. Take the edge to the furthest and you'll form a cycle of length at least d+1!

Code link: https://pastebin.com/1VwZYPCj

First AC: imeimi after only 11 minutes!

There are probably other solutions and heuristics. Can you share yours?

Codeforces Round #627 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishSuddendly, all ideas of this contest are mine. And I'm very sorry about one missing small test in the problem B. This is the biggest mistake I made during the preparation of this round.

1324A - Yet Another Tetris Problem

Tutorial1324A - Yet Another Tetris ProblemThe answer is "YES" only if all ai have the same parity (i.e. all ai are odd or all ai are even). That's because placing the block doesn't change the parity of the element and the −1 operation changes the parity of all elements in the array.

Solution1324B - Yet Another Palindrome Problem

Tutorial1324B - Yet Another Palindrome ProblemThe first observation is that we can always try to find the palindrome of length 3 (otherwise, we can remove some characters from the middle until its length becomes 3).

The second observation is that the palindrome of length 3 is two equal characters and some other (maybe, the same) character between them. Now there are two ways: find the pair of equal non-adjacent characters in O(n2) or do it in O(n) (for each character we only need to consider its left and right occurrences).

Solution1324C - Frog Jumps

Tutorial1324C - Frog JumpsThe only observation we need is that we don't need to jump left at all. This only decreases our position so we have less freedom after the jump to the left. Then, to minimize d, we only need to jump between the closest 'R' cells. So, if we build the array b=[0,r1,r2,…,rk,n+1], where ri is the position of the i-th 'R' cell from left to right (1-indexed), then the answer is maxi=0kbi+1−bi.

Time complexity: O(n).

Solution1324D - Pair of Topics

Tutorial1324D - Pair of TopicsLet's rewrite the inequality from ai+aj>bi+bj to (ai−bi)+(aj−bj)>0. This looks much simpler. Let's build the array c where ci=ai−bi and sort this array. Now our problem is to find the number of pairs i<j such that ci+cj>0.

Let's iterate over all elements of c from left to right. For simplicity, we consider only "greater" summands. Because our sum (ci+cj) must be greater than 0, then at least one of these summands will be positive. So, if ci≤0, just skip it. Now ci>0 and we need to calculate the number of such j that ci+cj>0 and j<i. It means that each cj≥−ci+1 (for some j<i) will be okay. Such leftmost position j can be found with std::lower_bound or binary search. Then add the value i−j to the answer and consider the next element.

Time complexity: O(nlogn).

Solution1324E - Sleeping Schedule

Tutorial1324E - Sleeping ScheduleThis is a very standard dynamic programming problem. Let dpi,j be the maximum number of good sleeping times if Vova had a sleep i times already and the number of times he goes to sleep earlier by one hour is exactly j. Then the value maxj=0ndpn,j will be the answer. Initially, all dpi,j=−∞ and dp0,0=0.

What about transitions? Let the current state of the dynamic programming be dpi,j and s=∑k=0iak. Then we can don't go to sleep earlier and make the first transition: dpi+1,j=max(dpi+1,j,dpi,j+|(s−j)%h∈[l;r]|). The sign % is modulo operation and the notation |f| is the boolean result of the expression f (1 if f is true and 0 otherwise). And the second transition if we go to sleep earlier: dpi+1,j+1=max(dpi+1,j+1,dpi,j+|(s−j−1)%h∈[l;r]|).

Don't forget to don't make transitions from unreachable states.

Time complexity: O(n2).

Solution1324F - Maximum White Subtree

Tutorial1324F - Maximum White SubtreeThis problem is about the "rerooting" technique. Firstly, let's calculate the answer for some fixed root. How can we do this? Let dpv be the maximum possible difference between the number of white and black vertices in some subtree of v (yes, the subtree of the rooted tree, i.e. v and all its direct and indirect children) that contains the vertex v. We can calculate this dynamic programming by simple dfs, for the vertex v it will look like this: dpv=av+∑to∈children(v)max(0,dpto).

Okay, we can store the answer for the root somewhere. What's next? Let's try to change the root from the vertex v to some adjacent to it vertex to. Which states of dynamic programming will change? Only dpv and dpto. Firstly, we need to "remove" the child to from the subtree of the vertex v: dpv=dpv−max(0,dpto). Then we need to "attach" the vertex v and make it a child of the vertex to: dpto=dpto+max(0,dpv). Then we need to run this process recursively from to (store the answer, reroot the tree and so on) and when it ends we need to "rollback" our changes. Now v is the root again and we can try the next child of v as the root.

Time complexity: O(n).

Solution

Codeforces Round #626 Editorial

By ch_egor, 3 years ago, translation, In EnglishThanks for the participation!

1323A - Even Subset Sum Problem was authored and prepared by vintage_Vlad_Makeev

1323B - Count Subrectangles was authored and prepared by vintage_Vlad_Makeev

1322A - Unusual Competitions was authored by vintage_Vlad_Makeev and prepared by DebNatkh

1322B - Present was authored by meshanya and prepared by wrg0ababd

1322C - Instant Noodles was authored by vintage_Vlad_Makeev and prepared by ch_egor

1322D - Reality Show was authored by voidmax and prepared by okwedook

1322E - Median Mountain Range was authored by Sender and prepared by grphil

1322F - Assigning Fares was authored by mingaleg, vintage_Vlad_Makeev and prepared by KiKoS

1323A - Even Subset Sum ProblemIf there is an even element in array there is an answer consisting of only it. Otherwise if there is at least two odd elements in array there is an answer consisting of this two elements. Otherwise array is only one odd element and there is no answer.

1323B - Count SubrectanglesRectangle [x1;x2][y1;y2] consists of only ones iff subsegment [x1;x2] consists of only ones in a and subsegment [y1;y2] consists of only ones in b. Let's iterate over divisors of k. Let the current divisor be p (i.e. k=p⋅q), so we are interested in number of subsegments consisting of ones of length p in a and number of subsegments consisting of ones of length q in b.

It's possible to precalculate number of segments consisting of ones in a and b of each length. Let's find all maximal subsegments consisting of ones in a and b. Consider subsegment of length l. It adds l−s+1 for amount of subsegments of length s.

c++ code by gritukan1322A - Unusual CompetitionsObviously, if the number of opening brackets is not equal to the number of closing ones, then since the described operation does not change their number, it will be impossible to get the correct sequence. Otherwise, if their numbers are equal, you can take the entire string and rearrange its n characters so that the string becomes a right bracketed sequence, for example, "((((…))))".

Let pi be a prefix balance on the first i characters, that is, the difference between the number of opening and closing brackets.

Consider an index i such that bali−1≤0, bali<0, or bali−1<0, bali≤0. Then, if the si character does not participate in any shuffle oeration, the resulting string will have a ith or i−1th prefix balance negative, making the resulting sequence incorrect. This means that at least characters with such indexes i must participate in at least one operation. It will be shown below how to use only them in shuffles to make a right bracketed sequence.

Let's represent this bracketed sequence as a polyline. It will start at the point with coordinates (0,0), end at the point with coordinates (2n,0), i - th vector of this polyline will be equal to (+1,+1), if si= ( and (+1,−1) otherwise. Then the above-described indexes i, which must participate in at least one operation — are exactly all the segments below the line x=0. To make the sequence correct, we will turn all consecutive segments of such brackets backwards. It's not hard to see that the sequence will become correct.

An example of this conversion is shown below:

Given sequence was ())(()))()((After reshuffling 2 segments of total length 8, we can get a right bracketed sequence:()()((()())1322B - PresentLet's calculate each bit in the answer separately. Suppose we want to know the value of k-th (in 0-indexation) bit in the answer. Then we can notice that we are only interested in bits from 0-th to k-th, which means that we can take all numbers modulo 2k+1. After that, the sum of the two numbers can't exceed 2k+2−2. k-th bit is 1 if and only if sum belongs to [2k;2k+1) or [2k+1+2k;2k+2−2].

So, we have to count the number of pairs of numbers that give a sum that belongs to these segments. Let's sort all numbers (taken by modulo) and make a pass with two pointers or do binary searches for each number.

Total complexity: O(nlognlogC)Bonus: can you do it in O(nlogC)?

1322C - Instant NoodlesLet's split vertices of right half of graph in groups in such a way that group consists of vertices with same neighboring set. Then answer equals to gcd of sums of numbers in all groups except the group with empty neighboring set. Let's prove it.

If there are some vertices with same list of neighbors then they will both in some N(S) or none of them will be in it. It means that we can replace such vertices with one vertex with value equals to sum of values in these vertices. After that numbers in all vertices are divisible by answer and thus sum of every subset is divisible by it. Let's divide all the numbers by answer and prove that after it answer will be 1.

Consider some integer k and we'll find some set of vertices S such that f(S) is not divisible by k. If sum of all numbers is not divisible by k we can take all the left half and its sum is not divisible by k. Otherwise consider a vertex with minimum degree such that its value is not divisible by k (such vertex exists because gcd of numbers in right half is 1 now). Let's take subset of vertices in left part which are not connected to v. Which vertices are not neighboring to this set? It is v and all the vertices that their neighboring set it a subset of neighboring set of v (and their sum is divisible by k). But value of v is not divisible by k so sum in complement of its neighboring set is not divisible by k too.

1322D - Reality ShowFirst of all, we will notice that the order of entering doesn't affect the answer.

Let's reverse the sequence. We will add people in the non-decreasing order. Let's use dynamic programming: dp[i][k][cnt] is the answer if we processed first i candidates with the maximum value less or equal k and total number of people who will reach lj=k is cnt≤n.

How we should change values of dp when we go from k to k+1? dp[i][k+1][cnt/2]≤dp[i][k][cnt]+(cnt/2)⋅ck+1But how dp changes when we take i-th element? dp[i+1][ai][cnt]≤dp[i][ai][cnt−1]+si

After adding i-th element we also should change dp[i+1][>ai]. But every next lay will change less: n+⌈n2⌉+⌈n4⌉+⌈n8⌉+…=O(n+m).

It clear, that we can remove first parameter of dp and finally get the asymptotics O(n(n+m)).

1322E - Median Mountain RangeLet's assume that 1≤ai≤2. We can notice that if for some i ai=ai+1, than on i-th and (i+1)-th positions numbers will stay the same forever. So the only changes will happen to segments of consecutive alternating 1 and 2. Now let's look what will happen to such segments after first alignment of mountain peaks. The beginning and end of segment will stay the same, and all intermediate number will change (1 will change to 2 and 2 will change to 1). So the second number will be equal to first and pre last number will be equal to last. That means that lengths of all segments of consecutive alternating 1 and 2 will decrease by 2. So the number of alignments equals to length of longest segment divided by 2, and for each segment its first half will be equal to beginning of segment, and its second half will be equal to the end of segment.

Now let's fix some number x and create array b, where bi=1 if ai<x and bi=2 if ai≥x. It can be observed, that if we will make alignment with initial mountain heights and replace them with 1 and 2 the same way, we will get array b after first alignment. So if we will get array b after stabilization, we will know that on positions where bi=1 mountains will have height less than x, and on positions where bi=2 the mountain heights after stabilization will be grater or equal than x. So to get the number of alignments we will need to find the longest segment of consecutive alternating 1 and 2 for all possible x.

Now we need to get the final heights. Let's assume that we know all positions where final heights will be grater than x. Let's create array b the same way as described above. Using this array we can get positions where the mountain heights will be grater or equal than x after stabilization. As we know positions where the heights will be grater than x, we can get positions where heights will be equal to x. So if we will decrease x from maximum value to 1, we can get the final heights of all mountains.

To perform it quick enough, we can consider only those x, that equal to some of existing initial heights. Then we can decrease x and in some set store all segments of consecutive alternating 1 and 2 in array b for such x. When the x is decreased, on some positions 1 can change to 2. The changes can happen only to the segments that have such positions. (The segments can be splited by this position, or this position can be merged with neighbouring segment(s)) So in total there will be O(n) changes to segments, and we can perform all of them in O(nlogn) time. Also we can store in set all positions, for which we do not know the final heights, we for each new segment we can find positions where 1 will be in the end (it will be some segment of consecutive positions) and search free positions among them in the set. In total it will take O(nlogn) time.

There also exists solution in O(n) time.

1322F - Assigning FaresLet's assume cv is the color of vertex v. So, we need to find a coloring of tree, where cv strictly increases along every path.

First of all, if coloring exists, we can renumerate colors so that they will be in range [1, n]. Secondly, we can always revert our coloring, make cv→k+1−cv. Also, let's do binary search to find k. So, now we want to check if it is possible to paint tree using k colors.

Every path can be on of two directions. If we determine direction for path #0, then we also automatically determine direction for every path which has common edge with path #0. So, we can get a components of paths — if we choose one path direction, we choose every other paths direction. We can notice, that if a single component is not bipartite, answer is -1. So, for every path, we know it's component and it's orientation inside the component. It can be calculated using subtree sum — for vertexes a and b we make +1 for a, +1 for b, and -2 for lca(a,b). Let's make our tree rooted and then count dp on subtrees. dpv — minimal color of v, if all it's subtree is colored in a correct way and edge v→parentv goes from lower to higher color. How to calculate dp?

If we fix parentv→v edge direction, for some edges v→to we know the orientation. It happens when they were in same component as parentv→v. For other components, we can or use dpto or k+1−dpto — depending on which direction of component we use. If we will try both variants and combine all the constraints, we will get two different segments [l,r] and [k+1−r,k+1−l], and dpv must be in one of them. It can be solved with scanline in O(nlogn) time.

Now we can notice that r=k+1−dpto. Let's think of segments as about two left constraints: l1 and l2. We have two sets L and R. We either put l1→L, l2→R or l2→L, l1→R.

So, we want these conditions to be done:{max(L)≤min(k−R)max(L)→min→{max(L)+max(R)≤kmax(L)→minIf we fix what is more — max(R) or max(L), we get fixed distribuition between L and R — max of l1 and l2 goes to max of two sets. Then we just need to check conditions and use best of variants. Solution will have complexity O(nlogn).

Codeforces Round #625 Editorial

By BledDest, history, 3 years ago, In EnglishDiv2A1321A - Contest for RobotsScore distribution for problems having ri=bi is irrelevant (we can make pi=1 for all of them). Let's consider the remaining problems.

Suppose we have x problems solved by the first robot (and not solved by the second one), and y problems solved by the second robot (and not solved by the first one). If x=0, then the score of the first robot won't exceed the score of the second robot by any means, so the answer is −1.

Otherwise, we can set the score for problems solved by the first robot to some number p, and the score for all remaining problems to 1. Then, the condition xp>y must hold, or p>yx, so p=⌈y+1x⌉ is the answer. Note that the constraints allow us to iterate on p instead of implementing a formula for it.

Div2B/Div1A1320A - Journey PlanningLet's rewrite the equality given in the statement as ci+1−bci+1=ci−bci. It means that all cities in our path will have the same value of i−bi; furthermore, all cities with the same such value can always be visited in ascending order.

So we may group cities by i−bi, compute the sum in each group and find the maximum over all groups. For example, this can be done by storing the sum for each i−bi in an array (be careful with negative values of i−bi, though!)

Div2C1321C - Remove AdjacentThe optimal answer can be obtained by the following algorithm: choose the maximum possible (alphabetically) letter we can remove and remove it. We can do it naively and it will lead to O(n2) time complexity.

Why is it always true? Suppose we remove the maximum letter i that can be used to remove some other letter j (it is obvious that si+1=sj in such case).

If there are no other letters between si and sj then si is not the maximum letter, so we got contradiction with our algorithm.

Now suppose that we can remove all letters between si and sj. Then we first choose sj and only after that si by our algorithm.

Consider the last case — there is at least one letter sk between si and sj. Because we cannot remove sk then there are only two cases: sk>sj+1 or sk+1<si. Then we cannot use si to remove sj at all.

Div2D/Div1B1320B - Navigation SystemLet dv be the length of the shortest path from v to t. If we move from vertex v to vertex u on our path, then:

the rebuild will definitely occur if du>dv−1;the rebuild may occur if there exists at least one vertex w≠u such that dw=dv−1 (the navigation system could have built a path through w).We can calculate all values of dv using BFS from t on a transposed graph. Now for each vertex, we can easily determine whether it should be added to the set of vertices where the route definitely rebuilds and to the set of vertices where a rebuild is possible.

Div2E/Div1C1320C - World of Darkraft: Battle for AzathothLet Sa be the set of monsters which may be defeated with a weapon having attack a. Then the profit we get, if we use weapon i with attack a and armor j with defense b, is −cai−cbj+(the sum of zk over all monsters k from the set Sa having yk<b).

We will iterate on weapons in non-descending order of their attack values and maintain Sa. For each armor option, maintain the value of Dj=−cbj+(total profit from monsters having attack less than bj). If armor sets are sorted by their defense value, adding a new monster into Sa adds some value on the suffix of Dj. So we can maintain the values of Dj in a segment tree.

So the solution is:

Build a segment tree on values of −cbj, where all armors are sorted by bj.Iterate on weapons and monsters in sorted order (sort by ai/xk in non-descending order). For each new weapon i we should add all monsters xk<ai which were not added yet (we can maintain a pointer on the last added monster to find them quickly).Adding a monster means adding zk on suffix of Di.After that, for the current weapon i we may try −cai+maxDj as the answer.Div2F/Div1D1320D - Reachable StringsHow to determine if two strings can be transformed into each other? Obviously, the number of ones in both strings should be the same. Also the following invariant holds: if all pairs of consecutive ones are deleted, the positions of remaining ones are not affected by any operations.

We can prove that these conditions are sufficient: if we move all pairs of ones to the end of the string, the strings are the same if the positions of ones are the same and the number of characters is the same (moving all pairs of ones to the end of the string is almost the same as deleting them).

One of the possible solutions is the following — build a segment tree, where each vertex should maintain:

the number of deleted pairs of ones;the hash of positions of the remaining ones;the characters at the ends of the corresponding segment (we need these to delete pairs of consecutive ones, if they appear as a result of merging the segments).When merging a pair of vertices, we check if we have to delete a pair of consecutive ones and rebuild the hash for the new vertex.

There are lots of other approaches, including a deterministic one (which uses suffix structures).

Div1E1320E - Treeland and VirusesWhen processing a query, the key idea is to build a compressed version of the tree containing only some important vertices. We are not interested in vertices not belonging to any path between some vi and ui. Furthermore, we can compress all chains in the tree by deleting all vertices with degree <2 not listed in the query. To find all the important vertices in the compressed tree, we may do the following: sort all vi and ui by their entry time in DFS traversal of the tree, and then add LCA's of all neighbouring pairs in the sorted list.

To restore the edges, we will consider all important vertices in sorted order and maintain the path to the current vertex in a stack. When we process a vertex, we delete vertices from top of the stack until we get an ancestor of current vertex on top of the stack, then this ancestor is the parent of the current vertex in the compressed tree.

When we have the compressed tree, there are two approaches to determining the virus affecting each node:

Run Dijkstra's algorithm. The distance for each vertex v is the pair (the time when v becomes infected, the index of a virus infecting v). For each initially infected vertex vi the initial distance is (0,i). When processing a vertex with Dijkstra, we can try to infect all of its neighbours with the same virus.Use subtree DP. First of all, for each vertex we determine the virus from its subtree that will infecting it (not taking into account any viruses from above): it's either the virus in this vertex or the virus infecting one of its children. Then we may to the same thing in the other direction: push viruses down the tree and calculate whether they are infecting vertices faster than the viruses from the lower vertices.In any case, each query is processed in O((k+m)logn).

Div1F1320F - Blocks and SensorsInitially fill each cell with a colorless block, and then try to paint blocks and delete them if they definitely contradict the sensor data.

We have to delete a block if:

it is observed by a sensor which should see no blocks;it is observed by at least two sensors that report different block types.In any of these cases, we delete a block. Then we update all sensors which were looking at it: for each of them, find the next block which they are looking at, and maybe delete it (if the information for it is contradictory). If this results in deleting all blocks for a sensor that should see a block, then the answer is −1.

If this process terminates without any contradictions, we can construct the answer. Now all sensors that should not see any blocks don't see them, and each block observed by sensors can be assigned a type that does not contradict the sensor data. If some block is not observed by sensors at all, we may assign any color to it (or even delete it).

To maintain blocks that should be deleted, we may use a BFS-like approach with a queue, or a DFS-like function that deletes a block, updates the sensors looking at it, and maybe calls itself recursively for the blocks that have to be deleted after the updates.

Codeforces Round #624 (Div. 3) Editorial

By vovuh, history, 3 years ago, In English1311A - Add Odd or Subtract Even

Idea: vovuh

Tutorial1311A - Add Odd or Subtract EvenIf a=b then the answer is 0. Otherwise, if a>b and a−b is even or a<b and b−a is odd then the answer is 1. Otherwise the answer is 2 (you can always make 1-case in one move).

Solution1311B - WeirdSort

Idea: MikeMirzayanov

Tutorial1311B - WeirdSortThe simple simulation works here: while there is at least one inversion (such a pair of indices i and i+1 that a[i]>a[i+1]) we can fix, let's fix it (we can fix this inversion if i∈p). If there are inversions but we cannot fix any of them, the answer is "NO". Otherwise, the answer is "YES".

There is also a O(nlogn) solution: it is obvious that we have some segments in which we can change the order of elements as we want. And it is also obvious that we cannot move elements between these "allowed" segments. So, each of them is independent of each other. We can just find all these segments of indices using two pointers and sort them independently. Then we just need to check if the array becomes sorted.

Time complexity is O(n2) or O(nlogn).

Solution (n^2)Solution (n log n)1311C - Perform the Combo

Idea: vovuh

Tutorial1311C - Perform the ComboWe can consider all tries independently. During the i-th try we press first pi buttons, so it makes +1 on the prefix of length pi. So the i-th character of the string will be pressed (the number of pi≥i plus 1) times. We can use sorting and some kind of binary search to find this number for each character but we also can build suffix sums to find all required numbers. We can build suffix sums using the following code:

vector<int> cnt(n);for (int i = 0; i < m; ++i) {    ++cnt[p[i]];}for (int i = n - 1; i > 0; --i) {    cnt[i - 1] += cnt[i];}So as you can see, the i-th element of p will add 1 in each position from 1 to pi. So we got what we need. After that we can calculate the answer for each character in the following way:

vector<int> ans(26);for (int i = 0; i < n; ++i) {    ans[s[i] - 'a'] += cnt[i] + 1;}Time complexity: O(nlogn) or O(n).

Solution1311D - Three Integers

Idea: MikeMirzayanov

Tutorial1311D - Three IntegersLet's iterate over all possible values of A from 1 to 2a. It is obvious that A cannot be bigger than 2a, else we can just move a to 1. Then let's iterate over all possible multiples of A from 1 to 2b. Let this number be B. Then we can find C as the nearest number to c that is divisible by B (we can check two nearest numbers to be sure). These numbers are C=⌊cB⌋⋅B and C=⌊cB⌋⋅B+B. Then we can update the answer with the found triple. Note that the only condition you need to check is that B≤C.

Time complexity: O(nlogn) because of the sum of the harmonic series.

Solution1311E - Construct the Binary Tree

Idea: MikeMirzayanov

Tutorial1311E - Construct the Binary TreeThis problem has an easy constructive solution. We can find lower and upper bounds on the value of d for the given n. If the given d does not belong to this segment, then the answer is "NO". Otherwise, the answer is "YES" for any d in this segment.

How to construct it? Let's start from the chain. The answer for the chain is the upper bound of d and it is n(n−1)2. Then let's try to decrease the answer by 1 in one move. Let's take some leaf v (the vertex without children) with the smallest depth that is not bad and try to move it up. The definition of badness will be below. To do this, let's find such vertex p that its depth is less than the depth of v by 2 and it has less than 2 children. If we found such vertex p then let's make v the child of p and decrease the answer by one.

If we didn't find such vertex p, I claim that the vertex v has the minimum possible depth it can have and we should not consider it in the future. Let's mark this vertex as bad and continue our algorithm.

If at some moment we cannot find any not bad leaf v, then the answer is "NO". Otherwise, the answer is "YES".

Time complexity: O(nd).

Solution1311F - Moving Points

Idea: vovuh

Tutorial1311F - Moving PointsLet's understand when two points i and j coincide. Let xi<xj. Then they are coincide when vi>vj. Otherwise, these two points will never coincide and the distance between them will only increase.

So, we need to consider only the initial positions of points. Let's sort all points by xi and consider them one by one from left to right. Let the i-th point be the rightmost in the pair of points that we want to add to the answer.

We need to find the number of points j such that xj<xi and vj≤vi and the sum of xj for such points as well. We can do this using two BITs (Fenwick trees) if we compress coordinates (all values v) and do some kind of "scanline" by values x. Let the number of such points be cnt and the sum of coordinates of such points be sum. Then we can increase the answer by xi⋅cnt−sum and add our current point to the Fenwick trees (add 1 to the position vi in the first tree and xi to the position vi in the second tree). When we want to find the number of required points and the sum of its coordinates, we just need to find the sum on the prefix two times in Fenwick trees. Note that you can use any "online" logarithmic data structure you like in this solution (such as treap and segment tree).

There is also another solution that uses pbds. Let's do the same thing, but there is one problem. Such data structure does not have "sum on prefix" function, so we have to replace it somehow. To do this, let's calculate only xi⋅cnt part when we go from left to right. Then let's clear our structure, go among all points again but from right to left and calculate the same thing, but with the opposite sign (find the number of points j such that xj>xi and vj≥vi). When we go from right to left, we need to decrease the answer by xi⋅cnt. It is some kind of "contribution to the sum" technique.

Time complexity: O(nlogn).

Solution (Fenwick tree)Solution (pbds)

VK Cup 2019-2020 — Elimination Round (Engine) and Codeforces Round #623

By PavelKunyavskiy, history, 3 years ago, In English1315A - Dead PixelYou can see that you should place the window in such a way so that the dead pixel is next to one of the borders of the screen: otherwise we can definitely increase the size of the window.

There are four possible ways to place the window right next to the dead pixel — you can place it below, above, to the left or to the right of the dead pixel.

if you place the window to the left to the pixel, the maximal size of the screen will be x⋅b;if you place the window to the right to the pixel, the maximal size of the screen will be (a−1−x)⋅b;if you place the window above the pixel, the maximal size of the screen will be a⋅y;if you place the window above the pixel, the maximal size of the screen will be a⋅(b−1−y).These four cases can be united to one formula like max(max(x,a−1−x)⋅b,a⋅max(y,b−1−y)).

1315B - HomecomingThe first thing you should do in this problem — you should understand the problem statement (which could be not very easy), and get the right answers to the sample test cases.

Petya needs to find the minimal i such that he has enough money to get from i to n (not n+1, he doesn't need to use the transport from the last crossroad. This was a rather common mistake in misunderstanding the statement) using only public transport. We can see that if Petya can get from i to n using only public transport, he can also get from any j>i to n, using only public transport (because he will need fewer tickets).

Let's iterate the candidates for i from n to 1 and try to find the minimal possible i. Of course, Petya can go from n to n using only public transport (he doesn't need to buy any ticket). Suppose Petya can get from j to n for some j, and it would cost him tj money. How much money he would need to get from j−1 to n? He definitely should be able to buy a ticket at station j−1. So, if it is the same ticket he should buy at station j, he will need the same amount of money, because he doesn't need to buy two consecutive equal tickets, it has no sense. Otherwise, he should buy one more ticket.

So, a minimal amount of money tj−1 to get from j−1 to j is tj, if j<n and sj−1=sj, and tj+cost(sj−1) otherwise (cost(sj−1) is a if sj−1=A, and b otherwise). If this value is greater than p, he should go to j by foot, otherwise, we should resume the process because he can go to j−1 or even some less-numbered crossroads.

1315C - Restoring PermutationThis problem has a greedy solution. As you know the bi, which is equal to min(a2i−1,a2i), then one of a2i−1,a2i should be equal to bi. Which one? Of course, a2i−1, because we want to get the lexicographically minimal answer, and we want to place a smaller number before the larger number.

So, we know that a1=b1, a3=b2, a5=b3, and so on, so we know all elements of the permutation with odd indices. What number should be placed at a2? We know that a2≥a1 (as a1≠a2, and b1=min(a1,a2)). So, let's take the a2=x for minimal possible x such that x≥a1 and x≠a1,x≠a3,…,x≠a2n−1. If there is no such x (if all numbers greater than a1 are already used), there is no appropriate permutation. Otherwise, we should take a2=x and resume the process.

The question is, why do we can place the minimal not used integer each time? Suppose there is another optimal answer a′1,a′2,…,a′2n, and we get a1,a2,…,a2n or we didn't get any permutation by our greedy algorithm. As these two sequences are different, there is the first k such that a′2k≠a2k. As we tried to take the minimal possible a2k, there are two options:

a2k>a′2k. This is impossible as we tried to take the minimal possible a2k, contradiction;a2k<a′2k. As a′ is «optimal correct» answer, we didn't finish our sequence a. Let's see, where is the number a2k in the sequence a′. It should be on some position 2l, where l>k (as 2k is the first difference between the sequences). But we can swap a′2k and a′2l and get smaller, but still correct sequence a", so a′ is not optimal. Contradiction.1310A - RecommendationsIn this problem we have an array a1,…,an, we can increase each ai by one with cost ti, and we want to make all ai different with minimal total cost.

Let's sort ai in a non-decreasing way (and permute the t in a corresponding way). Let's see at the minimal number, a1. If it is unique, e.g. a1≠a2, then we don't need to change a1 — it is already unique, and it can't get equal to something else if we don't increase it. In this case, we can just skip a1 and solve the smaller problem without a1.

Otherwise, suppose there is some j>1 such that a1=a2=…=aj. Obviously, we should leave at most one of them with the current value, and increase other j−1 numbers by one. Which one should be not increased? We shouldn't increase the al (1≤l≤j) with the maximal tl because it minimizes the total cost. So, we should remove the maximal value tl among all elements with minimal al, and increase all other by one. This effectively reduces our problem to the smaller one, decreasing n by one.

This gives us a O(n2) solution — n times we discard one minimum from the array and increase all other minimums by one. We can further optimize it by using a multiset of values tl for all minimal al and its sum. At each iteration, we should (probably) add some values to a multiset, if the number of minimums in array increases, discard one maximum from multiset and add the current sum to the answer. Continue the process until the array becomes empty. This is an O(nlogn) solution.

1310B - Double EliminationThe main observation in this problem is that for each set of players that lie in the subtree of any vertex of a binary tree of the upper bracket, exactly one player will win all matches in the upper bracket, and exactly one player will win all matches in the lower bracket. We can define this set of players (in 0-indexation instead of 1-indexation from statement) as [a⋅2t;(a+1)⋅2t) for some 1≤t≤n, 0≤a<2n2t. For each fixed t the players with different values of id2t don't play with each other, and their upper and lower brackets are independent.

For each of these sets of players, we are interested only in a number of interesting matches between them, and if the winner of their upper and lower brackets are the teams that are we're fans of. This leads us to the dynamic programming solution:

dp[l…r][fup][flower] — the maximal number of matches between teams with indices in [l;r), if fup∈{0,1} is 1 if the we're fans of winner of upper bracket, and flower∈{0,1} is 1 if the we're fans of winner of lower bracket. Again, l…r is the special segment: l=a⋅2t,r=(a+1)⋅2t−1 for some 1≤t≤n, 0≤a<2n2t.

dp[l…r][fup][flower] can be recalculated from dp[l…l+r2][flup][fllower] and dp[l+r2…r][frup][frlower] — we just iterate over all possible flup,fllower,frup,frlower, and the results of all three matches (one in the upper bracket and two in the lower bracket).

In the end, we use dp[0…2n][fup][flower] to count the result with the last, grand-finals match.

This solution works in something like O(2n⋅27) because there are 2n interesting segments.

1310C - Au Pont RougeLet's list all distinct substrings, sort them and make a binary search. Now, we need to count number of ways to make minimal string no more then given one. Let's count inverse value — number of wat to make minimal string greater. It could be done by quadratic dynamic programming dppos,count — number of ways to split suffix starting at pos to count string all of which are greater then given value. Let's find first position where suffix differs which given string. If next character in suffix is smaller, no part can start here and answer is zero. Otherwise, any longer part is acceptable, so we need to find ∑i>lcp(S,s[pos:])dpi,count−1, which can be done in O(1) time by suffix sums and precalculating lcp for all pairs of suffixes. Later can by done by another quadratic dynamic programming. lcp of two suffix is equal to 0 if first letter differs, and equal to lcp of two smaller suffixes +1 otherwise.

1310D - TourismThere are two different solutions possible.

First, one is to fix all even vertices in the path. It can be done in O(nk/2−1) time. If it's done, we need to join them by the minimal path of length 2, not going through these vertices. It can be done by precalculating 6 minimal paths of length 2 between each pair of vertices and ignoring no more than 5 best ones until good one found.

Another solution is a randomized one. Let's color all vertices in 2 colors in a random way. We can find the best path which is consistent with given coloring in O(k⋅E) time using dynamic programming. With probability 1512 best path overall is consistent with coloring. So, if one repeats this operation 512⋅20 time, probability of fail would be about (511512)512⋅20≈e−20≈2⋅10−9.

1310E - Strange FunctionThe solution of the task consists of three cases:

k=1. For fixed n f(a) can be equal to any partition of n. We need to count the number of arrays b1,b2,…,bm, such that b1≥b2≥…≥bm and ∑i=1mbi≤n. This can be done by simple dp in O(n2) (or even faster, much faster).k=2. When the array b1≥b2≥…≥bm can be equal to value of f2(a) for some |a|≤n? When there exists some array c1,…,cl such that ∑i=1lci≤n, and f(c)=b. The values of b are the numbers of occurences of numbers in c, so we need to minimize ∑i=1mbivi, where vi — the unique numbers in c.To minimize this sum we should take v1=1,…,vm=m, so we need ∑i=1mbii≤n. This can be done by simple dp: dp[val][j][sum] — the number of prefixes of b such that we already took j elements to b, all elements on prefix are greater than or equal to val, and the ∑i=1jbii=sum.

This dp can look like it is O(n3), but it is actually O(n2logn), because there is a limitation val⋅j≤n, and there are O(nlogn) such pairs. There is also a subquadratic solution.

k≥3. We can notice that in the array f2(a) there are at most O(2n−−√) elements. We can use this fact to bruteforce all possible answers — candidates for the answer are the partitions of numbers not exceeding 2n−−√=64, there are few millions of them.How to check if the array b1≥b2≥…≥bm can be the falue of fk(a)? It happens that we can make k−2 iterations of the unfolding algorithm from case k=2 and get the «minimal» possible array a, and check, if it contains no more than n elements. This part works in O(P(2n−−√)).

1310F - Bad CryptographyOne of the well-known algorithms for the discrete logarithm problem is baby step giant step algorithm based on the meet in the middle idea. It can solve the problem in O(|F|−−−√) time, which is definitely too much for the field of size 264.

Multiplicative group of field has size F=264−1=3⋅5⋅17⋅257⋅641⋅65537⋅6700417. We can see, that all numbers in this factoring are not too big. Let's try to find an answer modulo each of these primes. If we do that, we can restore the answer by the Chinese remainder theorem, and we are done.

Let p be one of divisors. So, if x=k∗p+y is answer, than akp+y=b, than akF+yFp=bFp. aF is equal to 1, so problem is equivalent to searching such an y, that (aFp)y=bFp, which is discrete logarithm problem on multiplicative subgroup of size p. So it can be solved using O(p–√) multiplications, which is about 6000 multiplications total for all values of p.

If one of the discrete logarithms not exists, the total answer obviously not exists. Another corner case, that both values in subproblem can be equal to 1. That means, that any value for this module is good. Also, this means, that a and b both have a smaller period, so any of these values would lead us to the correct answer.

Another part of problem is making multiplication fast enough. The first idea is to cache multiplications for powers of 2. This solution works for about 5 seconds in my implementation, and probably can be squeezed in time limit with some hacks. But multiplication can be done asymptotically faster. Let's a=a1⋅P+a2, b=b1⋅P+b2 is decomposition to first and second half of bits (in fact P is equal to power in multiply_powers_of_2 function). Then a⊙b=(a1⋅P+a2)⋅(b1⋅P+b2)=(a1⊙P⊕a2)⊙(b1⊙P⊕b2)=(a1⊙b1)⊙(P⊙P)⊕(a2⊙b2)⊕((a1⊙b2)⊕(a2⊙b1))⊙P.

As in Karatsuba algroithm, this 4 products can be reduce for 3, if one notice, that (a1⊙b2)⊕(a2⊙b1)=(a1⊕a2)⊙(b1⊕b2)⊕(a1⊙b1)⊕(a2⊙b2). The only diffrenece is instead of shift for multiplying on P⋅P we need to do one more multiplication.

But P⊙P=P⊕P2. We can multiply by them separately. Multiplying on P is easy. The other one is multiplying on the power of 2, which can be done by the naive algorithm in linear time. On the other hand, we can just call multiply for the second one recursively, and it will work fast enough because most of the branches will lead to multiplying on zero. Also, to make things fast, one can precompute all multiplications for numbers smaller than 256. This makes multiplication about 5 times faster than naive approach.

Codeforces Round #622 Editorial

By ch_egor, 3 years ago, translation, In EnglishThanks for the participation!

1313A - Fast Food Restaurant was authored by Endagorion and prepared by ch_egor

1313B - Different Rules was authored by meshanya and prepared by DebNatkh

1313C2 - Skyscrapers (hard version) was authored by meshanya and prepared by Sehnsucht

1313D - Happy New Year was authored and prepared by voidmax

1313E - Concatenation with intersection was authored and prepared by isaf27

1313A - Fast Food RestaurantBruteforce solution

There are seven possible sets of dishes, so the simplest solution is to iterate over all possible 27 subsets of sets of dishes.

You can also go over 7! permutations of sets of dishes and gather sets of dishes greedily in the selected order.

Greedy solution

Note that the solution can be optimal only when it is impossible to add an additional set of dishes to it.

Let the solution be such that it is impossible to add a single set of dishes to it and it does not have any set consisting of one dish, but there is a set consisting of two or three dishes containing this one dish. Then you can replace the corresponding set with a set of one dish, without worsening the answer. This means that at the beginning you can greedily add all the sets consisting of one dish.

The same can show that any set of three dishes can be replaced with a set of two dishes, so after the sets of one and two dishes are fixed, it is enough to simply check whether you can add a set of three dishes.

However, it is wrong to choose sets of two dishes greedily. Suppose that after choosing sets of one dish, there is one dish of the first type, one dish of the second type and two dishes of the third type. Then you can choose two sets of dishes, but if you take at the beginning a set of dishes of the first and second types, you won't get two different sets.

In this case, you can simply iterate over the order of choosing sets of two dishes or notice that all such tests have the form 22x, 2x2, x22, where x≥3, and solve them separately.

1313B - Different RulesWithout loss of generality, assume that x≤y. For convenience, we will number the participants from 1 to n in the order of their places in the first round. Thus, the participant we are interested in is the participant x.

First we can prove the formula: MIN_PLACE=max(1,min(n,x+y−n+1))

First case: x+y<n. It can be shown that participant x can achieve first place in the Olympics. In order to do this, the following example can be built:i-th participant (1≤i≤x−1) takes (x+y+1−i)-th place in the second round (sum — x+y+1)x-th participant takes y-th place in the second round (sum — x+y)j-th participant (x+1≤j≤n−y) takes (n+x+1−j)-th place in the second round (sum — n+x+1)(n−y+1)-th participant takes (y+1)-th place in the second round (sum — n+2)t-th participant (n−y+2≤t≤n) takes (n+1−t)-th place in the second round (sum — n+1)The illustration below explains this example

Second case: x+y≥n+1;y≠nConsider the participant with the number k (k≤x+y−n<x). They will receive no more than x+y−n+n=x+y in total (because n is the maximum place in the second round they can take), that is guaranteed to overtake the main character. Thus we can't achieve any place better than x+y−n+1. For this assessment, an example below is given:

i-th participant (1≤i≤x+y−n) takes i-th place in the second round (sum — 2i<x+y)j-th participant (x+y−n+1≤j≤x−1) takes (x+y+1−j)-th place in the second round (sum — x+y+1)x-th participant takes the y-th place in the second round (sum — x+y)(x+1)-th participant takes (y+1)-th place in the second round (sum — x+y+2)t-th participant (x+2≤t≤n) takes (x+y+1−t)-th place in the second round (sum — x+y+1)The illustration below explains this example

Third case: x+y≥n+1; y=nThen the participant with the number k (k≤x+y−n+1=x+1) will receive no more than x+y−n+1+n−1=x+y in total, that is guaranteed to overtake the main character. That is, we can't take places better than x+y−n+1. For this assessment, we give an example below:

Participant i<x takes x-th place, overtaking x+yParticipant x+1 takes (n−1)-th place, overtaking x+yParticipant j (x+2≤j≤n) takes (x+y+1−j)-th placeA separate case: x=y=n, then the outcome is obvious

The formula for the minimum place is proved. The formula for the maximum place will be proven in the same way:

We prove the formula: MAX_PLACE=min(n,x+y−1)First case: x+y≥n+1. Then we can give an example in which we will take the last place:i-th participant (1≤i≤x+y−n−1) takes (y+x−n−i)-th place in the second round (sum — y+x−n)j-th participant (x+y−n−1≤j≤n) takes (x+y−j)-th place in the second round (sum — y+x)Second case: x+y≤n Consider a participant with the number k (x+y≤k). They are guaranteed to be overtaken by x+y (main character) So the main character can not take any place worse than x+y−1:i-th participant (1≤i≤x+y−1) takes (y+x−i)-th place in the second round (sum — y+x−n)j-th participant (x+y−1≤j≤n) takes (x+y+n−j)-th place in the second round (sum — y+x)Thus, the problem was reduced to the problem of output of two numbers – ⟨max(1,min(n,x+y−n+1)),min(n,x+y−1)⟩1313C2 - Skyscrapers (hard version)Let's solve the task on an array m of length n. Let's find a minimal element in this array. Let it be on the i-th (1≤i≤n) position. We can build the skyscraper at the i-th position as high as possible, that is ai=mi.

Now we should make a choice — we need to equate to ai either the left part of the array (a1=ai,a2=ai,…,ai−1=ai), or the right part (ai+1=ai,ai+2=ai,…,an=ai), and solve the task recursively on the remaining part of the array, until we get an array of length 1.

The described recursive task has n different states. Depending on the approach of finding a minimal element on a segment, we can get solutions of complexity O(n2), O(nn−−√) or O(nlogn).

There is another solution. It can be proved that the answer looks like this: from the start of the array the heights are non-decreasing, and starting from the certain skyscraper the heights are non-increasing. Let's call a skyscraper "peak" if there is the change of direction on this skyscraper. We are to find the optimal "peak".

We can build arrays l and r of length n. Let's iterate positions from left to right. Let we are on the i-th position. If mi is the smallest element among m1,…,mi, then li=i×mi. Otherwise, let's look at m1,m2,…,mi−1 and take the rightest number smaller than mi, let it be mj on the j-th position. Then li=lj+(i−j)×mi. Similarly, we build r (but changing the direction from right to left). The "peak" is the skyscraper t such that lt+rt−mt is maximal.

The complexity of this solution can be O(n2), O(nlogn), O(n) depending on the approach of finding "nearest" numbers to the right and to the left that are smaller than the current one.

1313D - Happy New YearWe wil use scanline to solve this problem. For all segments, we add event of its beginning and end. Let's maintain dpi,mask, where i is number of events that we have already processed. mask is mask of k bits, where 1 in some bit means that segment corresponding to this bit is taken.

How to move from one coordinate to another? For all masks we can count number of 1 bits and if it is odd, we should add distance between to points to value of this dp.

How to add new segment? As we know, at one point can be at most k segments, so when we add segment we can find free bit and create match to this segment. After this operation we also should change some values of dp. Deleting of the segments is similar to adding.

As you may notice, only (i−1)-th lay is needed to calculate i-th lay, so we can use only O(2k) additional memory.

Total complexity O(nlogn+n2k).

1313E - Concatenation with intersectionFor all 1≤i≤n let's define fai as the length of the longest common prefix of strings a[i,n] and s[1,m−1], fbi as the length of the longest common suffix of strings b[1,i] and s[2,m]. Values of fa can be easily found from z-function of the string "s#a", values of fb from z-function of the string "s¯¯¯#b¯¯" (here s¯¯¯ is defined as reversed string s).

Let's fix l1 and r2. Let's note, that l1≤r2, because segments have non-empty intersection. Also, the sum of lengths of segments is equal to m and they have non-empty intersection, so r2≤l1+m−2. It's easy to see, that segments will have non-empty intersection if and only if l1≤r2≤l1+m−2.

Let's note, that if for fixed l1 and r2 innequalities are true, the number of segments with such l1 and r2 is equal to max(fal1+fbr2−m+1,0). So, the answer to the problem is equal to ∑1≤l1≤r2≤min(l1+m−2,n)max(fal1+fbr2−m+1,0)=∑l1=1n∑r2=l1min(l1+m−2,n)max(fal1+fbr2−m+1,0).

Let's make two Fenwick trees on arrays of size m. Let's iterate l1 from 1 to n. For r2∈[l1,min(l1+m−2,n)] let's add in the position m−1−fbr2 of the first tree the number 1, in the position m−1−fbr2 of the second tree the number fbr2. After that the sum for fixed l1 can be easily found from sums in Fenwick trees on prefixes i≤fal1.

The total complexity is O(nlogn).

Codeforces Round #621 (Div. 1 + Div. 2) Editorial

By FieryPhoenix, 3 years ago, In English1307A - Cow and Haybales

Idea: FieryPhoenix

Tutorial1307A - Корова и стоги сенаAt any point, it is optimal to move a haybale in the closest pile from pile 1 to the left. So, for every day, we can loop through the piles from left to right and move the first haybale we see closer. If all the haybales are in pile 1 at some point, we can stop early.

Time Complexity: O(n⋅d)SolutionAlternative O(n) Solution:1307B - Cow and Friend

Idea: dragonslayerintraining

Tutorial1307B - Корова и другIf the distance d is in the set, the answer is 1.

Otherwise, let y denote Rabbit's largest favorite number. The answer is max(2,⌈dy⌉). This is true because clearly the answer is at least ⌈dy⌉: if it were less Rabbit can't even reach distance d away from the origin. If ⌈dy⌉ is at least 2, we can reach (d,0) in exactly that number of hops by hopping to the right ⌈dy⌉−2 times using y then using the last 2 hops for up to 2y additional distance.

Time Complexity: O(n)Solution1307C - Cow and Message

Idea: dragonslayerintraining

Tutorial1307C - Корова и сообщениеWe observe that if the hidden string that occurs the most times has length longer than 2, then there must exist one that occurs just as many times of length exactly 2. This is true because we can always just take the first 2 letters; there can't be any collisions. Therefore, we only need to check strings of lengths 1 and 2. Checking strings of length 1 is easy. To check strings of length 2, we can iterate across S from left to right and update the number of times we have seen each string of length 1 and 2 using DP.

Time Complexity: O(|s|c) (c is length of alphabet)

Solution1307D - Cow and Fields

Idea: FieryPhoenix

Tutorial1307D - Корова и поляThere are a few solutions that involve breadth first search (BFS) and sorting, this is just one of them. First, let's use BFS to find the distance from fields 1 and n to each special field. For a special field i, let xi denote the distance to node 1, and yi denote the distance to n.

We want to choose two fields a and b to maximize min(xa+yb,ya+xb). Without loss of generality, suppose xa+yb≤ya+xb.

Now we want to maximize xa+yb subject to xa−ya≤xb−yb. This can be done by sorting by xi−yi and iterating a over x while keeping a suffix maximum array of y to compute maxb>ayb.

Remember that an upper bound of the answer is the distance between field 1 and n.

Time Complexity: O(nlogn+m)Solution1307E - Cow and Treats

Idea: FieryPhoenix

Tutorial1307E - Корова и угощенияFirst, we observe that it is impossible to send more than one cow with the same favorite sweetness on the same side without upsetting any of them. This means we can send at most two cows of each favorite sweetness, one on each side.

Now, let's assume we know the index of the rightmost cow that came from the left side.

For each sweetness i, we denote the number of units of grass to the left of the index as li and to the right as ri. There are three cases we have to consider. If there does not exist a cow of this favorite sweetness or the one of this favorite sweetness with minimum hunger cannot be satisfied from either direction, then 0 cows of the type will be asleep. Otherwise, 1 or 2 cows will be asleep, and we can derive a simple formula based on li, ri, and the cows of this type. Remember that we always maximize the number of sleeping cows first.

We maintain how much each sweetness contributed to the answer. When we shift this index of the rightmost cow to the right, we can undo and recompute our answer.

You can speed up the solution using binary search, but we chose not to require it. We also chose to allow other O(n2) and O(n2logn) solutions to pass.

Time Complexity: O(nlogn)Solution1307F - Cow and Vacation

Idea: FieryPhoenix

Tutorial1307F - Корова и отпускWe will run a BFS from all the rest stops in parallel and use union-find to determine which rest stops can reach each other directly. We will split each edge into two to simplify this process. Note that this means Bessie can now travel at most 2k roads before needing a rest. While we perform the BFS, we also color all nodes that are within distance k from a rest stop and store the rest stop that can reach each colored node in an array. When two frontiers collide, merge them.

Let's consider each query individually. First of all, if a can reach b directly, the answer is YES.

Otherwise, let's walk a towards b for k edges, and b towards a for k edges. Note that they may cross over lca(a,b) in the process. The walks will not meet because if they did, the condition that a can reach b directly would have been satisfied.

Then, the answer is YES if the new a is a colored node, the new b is a colored node, and they both belong to the same component of rest stops which we can check from our union find.

Otherwise, the answer is NO.

Time Complexity: O((n+v)logn)Solution1307G - Cow and Exercise

Idea: dragonslayerintraining

Tutorial1307G - Корова и тренировкаThis problem can be formulated as a linear program, and looks like the LP dual of min-cost flow.

LP formulation of min-cost flow (see for example here: https://imada.sdu.dk/%7Ejbj/DM85/mincostnew.pdf):

xvw is flow on edge (v,w)cvw is cost on edge (v,w)uvw is capacity on edge (v,w)bv is demand at vertex v (flow in minus flow out)

Find minΣvwcvwxvw subject toΣ(v,w)∈E(xwv−xvw)=bvfor v∈V(Hopefully the signs are right.)

0≤xvw≤uvwfor (v,w)∈EThe LP Dual is

maxΣbvyv−Σuvwzvwsubject toyw≤yv+cvw+zvwzvw≥0for all (v,w)∈EThis is exactly what we need, except the objective function is a bit messy. Letting bsrc=−F, bsnk=F, bv=0 for other v, D=ysnk−ysrc, C=Σvwuvwzvw, the objective becomes

maxFD−CWe have the unweighted case, so assign capacities (cost in original problem) uvw=1 for all edges.

We can interpret yv as distance from src and zvw as the amount added to edge edge to it.

The set of all valid assignments to the variables form a convex polytope. If we project it onto the 2D space of D and C, it will still be convex. By varying F, we can get a piecewise linear function describing all Pareto optimal solutions. From this function, we can find the minimum C required to get some fixed D or maximum D achieve by some fixed C.

Since a feasible solution to a min-cost flow problem is optimal iff it has no negative cost cycles, and both successive shortest path and primal-dual never create negative cycles, they maintain optimal solutions to their current min-cost flow problems, which only differs in F. Thus, they effectively trace out the function as F varies from 0 to maximum. By binary searching and lerping, we can answer queries in O(logN).

(Since the cost is integral and bounded by N, there are at most N linear pieces.)

Time Complexity: O(n2m+qlogn)Solution

Codeforces Round #620 (Div. 2) Editorial

By djm03178, history, 3 years ago, In English1304A — Two Rabbits

Tutorial1304A - Two RabbitsWe can see that the taller rabbit will be at position x+Ta and the shorter rabbit will be at position y−Tb at the T-th second. We want to know when these two values are equal. Simplifying the equation, we get y−xa+b=T. Since we only consider positive integers for T, the answer is y−xa+b only if y−x is divisible by a+b. Otherwise, the answer is −1.

Another intuitive approach is to think of it as relative speed. In the perspective of the taller rabbit, the shorter rabbit will move (or more like, teleport) to the negative direction at speed of a+b per second. Therefore the initial distance y−x must be divisible by a+b in order to make the two rabbits meet at time y−xa+b.

Time complexity: O(1) for each test case.

Solution1304B — Longest Palindrome

Tutorial1304B - Longest PalindromeLet's define rev(S) as the reversed string of a string S. There are two cases when we choose K strings to make a palindrome string S1+S2+⋯+SK:

If K is even, for every integer X (1≤X≤K2), SX=rev(SK−X+1).if K is odd, SK+12 must be palindrome. Also for every integer X (1≤X≤K−12), SX=rev(SK−X+1).In either case we want to find as many pairs of strings as possible such that one is the reverse of the other. It is also clear that if T is a palindrome string then rev(T)=T. We cannot make a pair of T and rev(T) because all strings in the input are distinct.

Therefore, for each string we need to find if there is another string that is its reverse. If there exists one, put them on the left / right end respectively. If there are one or more strings that are palindrome themselves, pick any one of them and put it in the middle.

Time complexity: O(n2m) if we implement it naively. O(nmlogn) is possible if we use a data structure that provides O(logn) search such as std::set in C++.

Solution1304C — Air Conditioner

Tutorial1304C - Air ConditionerSince the range of temperatures can be large, it is impossible to consider all possible cases. However, we only need to find any case that can satisfy all customers, so let's try to maximize the possible range for each customer in the order of their visit time.

Let's define two variables mn and mx, each representing the minimum and maximum possible temperature that can be set now. Initially they are both m and the current time is 0. After K minutes, we can see that the possible range is [mn−K,mx+K]. This means if a customer that visits after K minutes has preferred temperature range [L,R] that intersects with this range (inclusive), Gildong can satisfy that customer. In other words, mn−K≤R and L≤mx+K must be satisfied. Then we can reset mn and mx to fit this intersected range: mn=max(mn−K,L) and mx=min(mx+K,R).

If this can be continued until the last customer, the answer is "YES". Otherwise, the answer is "NO".

Time complexity: O(n) for each test case.

Solution1304D — Shortest and Longest LIS

Tutorial1304D - Shortest and Longest LISThere are various strategies to solve each part. I'll explain one of them for each. It would be fun to come up with your own strategy as well :)

Shortest LIS

Let's group each contiguously increasing part. We can easily see that we cannot make the LIS shorter than the maximum size among these groups. It can be shown that we can make the length of the LIS not longer than that as well.

One strategy is to fill the largest unused numbers in increasing order for each group from left to right. There will be no indices i and j (i<j) such that perm[i] < perm[j] where i and j are in different groups. Therefore the maximum size among the groups will be the length of the LIS.

Longest LIS

Let's group each contiguously decreasing part. We can easily see that there can be at most one element from each group that is included in any possible LIS. It can be shown that we can make a sequence that takes one element from every groups to form the LIS.

One strategy is to fill the smallest unused numbers in decreasing order for each group from left to right. Then for every indices i and j (i<j) where i and j are in different groups, perm[j] will be always greater than perm[i]. Thus, we can take any one element from each and every groups to form the LIS.

Time complexity: O(n) for each test case.

Here's a little challenge for people who want harder things: Can you make a sequence that has the length of its LIS exactly k?

Solution1304E — 1-Trees and Queries

Tutorial1304E - 1-Trees and QueriesAssume that the length of a path from a to b is L. It is obvious that for every non-negative integer Z, there exists a path from a to b of length L+2Z since we can go back and forth any edge along the path any number of times. So, we want to find the shortest path from a to b where the parity (odd or even) of its length is same as the parity of k.

Since it is a tree, the parity of the length of every paths from a to b is unique. However, if we add another edge, we can possibly find a path of length with different parity. The parity is changed only if you use the added edge odd number of times and the length of the simple path from x to y is even. Since there is no reason to take the path multiple times to find the shortest path of same parity, let's assume we use it only once. If it doesn't change the parity, we can think of it as trying to find a shorter path with same parity of length.

Then there are three paths we need to check:

The simple path from a to b without using the added edge.The simple path from a to x without using the added edge, plus the added edge, plus the simple path from y to b without using the added edge.The simple path from a to y without using the added edge, plus the added edge, plus the simple path from x to b without using the added edge.Finding the length of each simple path can be done in O(logn) time using the well-known LCA (Lowest Common Ancestor) algorithm with O(nlogn) pre-processing.

Now for the ones that have the same parity of length as k, we need to determine if the minimum of them is less than or equal to k. If there are no such paths, the answer is "NO". Otherwise the answer is "YES".

Time complexity: O((n+q)logn).

Solution1304F1 — Animal Observation (easy version)

Tutorial1304F1 - Animal Observation (easy version)For simplicity, we'll assume that there is the n+1-st day when no animals appear at all. Let's say animal[i][j] is the number of animals appearing in the j-th area on the i-th day.

Let's define DP[i][j] (1≤i≤n,1≤j≤m−k+1) as the maximum number of animals that can be observed in total since day 1, if Gildong puts a camera on the i-th day to observe area [j,j+k−1] in day i and i+1. Obviously, DP[1][j] is the sum of the number of animals in area [j,j+k−1] in day 1 and day 2. Now, for each day since day 2, let's find three values to determine DP[i][j], which is the maximum among them.

For all x (1≤x≤j−k), maximum of DP[i−1][x] plus sum(animal[i…i+1][j…j+k−1]).For all y (j+k≤y≤m−k+1), maximum of DP[i−1][y] plus sum(animal[i…i+1][j…j+k−1]).For all z (j−k+1≤z≤j+k−1), maximum of DP[i−1][z] plus sum(animal[i…i+1][j…j+k−1]) minus the sum of animals in the intersected area on the i-th day.The summation parts can be calculated in O(1) time by prefix sum technique after O(nm) pre-processing. For the ones that have no intersection, we can pre-calculate the prefix max and suffix max for the values in DP[i−1] in O(m) time for each day, therefore finding it in O(1) as well.

Since k is small in this problem, we can naively check all cases when there are one or more intersected areas. For each area we need to check O(k) cases each in O(1) time, so the problem can be solved in O(nmk) time in total.

Solution1304F2 — Animal Observation (hard version)

Tutorial1304F2 - Animal Observation (hard version)We can further advance the idea we used in F1 to reduce the time complexity.

Solution: O(nmlogm)

Let's generalize all three cases we discussed in F1. Let's make a lazy segment tree supporting range addition update and range maximum query. Each node represents the maximum value of (DP[i−1] minus the sum of the animals appearing on the i-th day in the intersected area) in the corresponding interval. Then we can add sum(animal[i…i+1][j…j+k−1]) to the maximum value of the segment tree to determine DP[i][j].

For the i-th day, we insert DP[i−1][j] in the respective index of the segment tree for all j (1≤j≤m−k+1) initially. Now, to determine DP[i][j] for each j, we want to subtract sum(animal[i][max(j,x)…min(j,x)+k−1]) from the segment tree for all x (1≤x≤m−k+1). But it is infeasible to do this and add them back for every single x-s that has intersected areas. Here, we can use sliding window technique to improve it.

To determine DP[i][1], we can manually subtract the first k elements of animal[i] from the segment tree like above. Let's assume that we're done with determining DP[i][j−1]. When we move on to determining DP[i][j], we can see that animal[i][j−1] is no longer in the range and thus should be added back to the segment tree. Precisely, all DP[i−1][x]-s where x is within range [max(1,j−k),j−1] are affected by this and must be added with animal[i][j−1]. Similarly, animal[i][j+k−1] is now in the range and thus should be subtracted from all DP[i−1][y]-s where y is within range [j,j+k−1].

Each range update takes O(logm) time, and this happens only two times for determining each DP[i][j]. The 'initial' work takes O(k) time but it happens only once for each day. Therefore, it takes O(mlogm) time for each day and O(nmlogm) time in total.

Solution: O(nm)

It turns out that it's even possible without the segment tree. Of course, O(nmlogm) is intended to pass so you don't really need to implement this to solve the problem. Instead of segment tree, we'll use monotonic queue structure (the core idea for convex hull trick) to have the values in decreasing order from front to back. If you don't know what monotonic queue is, make sure you understand it first. You can read about it here.

We'll do basically the same thing we did for O(nmlogm) solution, but there are two major differences. First, we'll slide the window two times, one from left to right and the other one from right to left. Second, we'll only consider the values where the range of their indices intersects with the window, but only a part of them. We'll see how it works when sliding the window from left to right, then we can also do it in reverse direction.

We'll only consider all DP[i−1][x] where x is within range [max(1,j−k+1),j]. In other words, we only consider it when the intersected area is a prefix of the window. This means when we're about to determine DP[i][j], DP[i−1][j] (in fact, the actual value will be DP[i−1][j]−sum(animal[i][j…j+k−1])) is inserted into the queue and DP[i−1][j−k] is removed from the queue.

Now let's see how the 'real' values in the queue are changed while sliding the window. Since we'll only add the same value to all elements in the queue every time we slide the window, the order of the elements won't be changed, thus maintaining the monotone queue structure. However, we don't actually need to perform the 'add' action, simply because we can always calculate it in O(1) time by calculating the sum of the animals between the index of that element (inclusive) and the window (exclusive). So to the 'real' value at the front of the queue, we can add sum(animal[i…i+1][j…j+k−1]) to determine DP[i][j].

The exact same thing can be done in the reversed way, too. Now let's take back the prefix and suffix max we discussed in F1, so that we can check the cases when they do not intersect. We can see that each of these operations can be done in O(m) for each day. Therefore, the whole process is performed in O(nm) time.

Solution: O(nmlogm)Solution: O(nm)

Codeforces Round #619 (Div. 2) Editorial

By El3ageed_Abu_Shehab, 3 years ago, In English1301A - Три строкиFor every i (1≤i≤n) where n is the length of the strings. If ci is equal to ai we can swap it with bi or if ci is equal to bi we can swap it with ai, otherwise we can't swap it. So we only need to check that ci is equal ai or ci is equal to bi.

Complexity is O(n).

Code:https://ideone.com/Z5Hamc

1301B - Motarack's BirthdayLet's take all non missing elements that are adjacent to at least one missing element, we need to find a value k that minimises the maximum absolute difference between k and these values. The best k is equal to (minimum value + maximum value) / 2.

Then we find the maximum absolute difference between all adjacent pairs.

Complexity is O(n).

code:https://ideone.com/79k8oT

1301C - Функция АйоубаWe can calculate the number of sub-strings that has at least one symbol equals to "1" like this:

f(s) = (number of all sub-strings) − (number of sub-strings that doesn't have any symbol equals to "1").

if the size of s is equal to n, f(s) = n⋅(n+1)2 − (number of sub-strings that doesn't have any symbol equals to "1").

if we want to calculate them, we only need to find every continuous sub-string of 0's if it's length was l, then we subtract l⋅(l+1)2.

now we have a string contains (n−m) "0" symobol, and we want to divide these symbols into (m+1) groups so that the summation of l⋅(l+1)2 for every group is minimised.

The best way is to divide them into equal groups or as equal as possible.

let z be the number of zeroes in the string, z=(n−m), and g be the number of groups, g=m+1.

let k equal to ⌊ zg ⌋.

we should give every group k zeroes, except for the first (zmodg) groups, we should give them k+1 zeroes.

So the answer is n.(n+1)2 − k.(k+1)2⋅g − (k+1)⋅(zmodg).

Complexity is O(1).

code:https://ideone.com/rk5nDE

1301D - Time to RunA strategy that guarantees that you can visit all the edges exactly once:

1- keep going right until you reach the last column in the first row.

2- keep going left until you reach the first column in the first row again.

3- go down.

4- keep going right until you reach the last column in the current row.

5- keep going {up, down, left} until you reach the first column in the current row again.

6- if you were at the last row, just keep going up until you reach the top left cell again, otherwise repeat moves 3, 4 and 5.

We need only to take the first k moves, and we can print them in about 3⋅n steps.

complexity O(n)code:https://ideone.com/PkCMZM

1301E - НанософтFor each cell, we will calculate the maximum size of a Nanosoft logo in which it is the bottom right cell, in the top left square.

The cell marked with x in this picture:



If we had a grid like this:



If we take the cell in the second row, second column, it can make a Nanosoft logo with size 4×4, being the bottom right cell in the top left square.

We can calculate the answer for every cell using binary search , and checking every sub-square using 2D cumulative sum.

Now we build a 2D array that contains that previous calculated answer, lets call it val[n][m].

For the previous picture val will be like this:



Now for each query we can do binary search on its answer. We check the current mid this way:

The mid will tell us the length of one of the sides divided by 2.

Like if mid = 2, the area of the square we are checking is (4⋅4=16).

Now we should check the maximum element in the 2D array val, in the 2D range: (r1+mid−1,c1+mid−1,r2−mid,c2−mid).

The current mid is correct if the maximum element in that 2D range is greater than or equal to (4⋅mid⋅mid).

We can get the maximum value in a 2D range using 2D sparse table, with build in O(n⋅m⋅logn⋅logm) and query in O(1).

total Complexity is O(n⋅m⋅logn⋅logm+q⋅logm).

code:https://ideone.com/VyYsoc

1301F - Супер ДжаберIn the shortest path between any two cells, you may use an edge that goes from a cell to another one with the same color at least once, or you may not.

If you didn't use an edge that goes from a cell to another one with the same color then the distance will be the Manhattan distance.

Otherwise you should find the best color that you will use that edge in it, the cost will be (the minimum cost between any cell of that color with first cell + the minimum cost between any cell of that color with the second cell + 1).

In order to find the minimum cost from every color to each cell, we can run multi-source BFS for every color.

But visiting all other cells that has the same color every time is too slow, so we can only visit these cells when we reach the first cell from every color.

Complexity is O(n⋅m⋅k+q⋅k).

code:https://ideone.com/emv9dj

Codeforces Round #618 Editorial

By rotavirus, history, 3 years ago, In RussianAuthors:d2A: rotavirusd2B: nvmdavad1A: nvmdavad1B: rotavirusd1C: nvmdavad1D: rotavirusd1E: antontrygubO_o

1300A - Non-zeroWhile there are any zeros in the array, the product will be zero, so we should add 1 to each zero. Now, if the sum is zero, we should add 1 to any positive number, so the sum becomes nonzero. So the answer is the number of zeroes in the array plus 1 if the sum of numbers is equal to zero after adding 1 to zeros.

1300B - Assigning to ClassesLet's sort the array. From now on, a1≤a2⋯≤a2n.

Consider any partition. Suppose that the first class has 2k+1 students, and the skill level of this class is ai, and the second class had 2l+1 students, and the skill level of this class is aj, where (2k+1)+(2l+1)=2n⟹k+l=n−1. Without losing generality, i<j.

At least n+1 students have skill level at least ai. Indeed, as ai is a median of his class, he and k other students have skill level at least ai. As aj≥ai and at least l other students of the second class have skill level at least aj≥ai, we get at least k+l+2=n+1 students (including ai) with skill level at least ai. Therefore, ai≤an.

Similarly, we get that at least n+1 students have skill level at most aj. Therefore, aj≥an+1.

So, |aj−ai|≥an+1−an. However, an+1−an is achievable. Let's put student an into the class alone, and all other students into other class. an+1 will be the median skill level of that class, so the absolute difference will be exactly an+1−an.

Therefore, it's enough to sort the array and to output the difference between two middle elements.

1299A - Anu Has a FunctionIf you work on the bits, you may see f(a,b) can easily be written as a&(∼b).

And so, value of an array [a1,a2,…,an] would be a1&(∼a2)&…(∼an), meaning that if we are to reorder, only the first element matters.

By keeping prefix and suffix AND after we apply ∼ to the given array, we can find (∼a2)&…(∼an) in O(1).

Or notice that if a bit was to be in the answer, it must be in a1 and not in any of a2,a3,…an. So you can start from the most significant bit and check if that bit can be in the answer to find a1, resulting in O(n).

1299B - AerodynamicT has the central symmetry: indeed, if P(x,y) covers (0,0) and (x0,y0) then P(x−x0,y−y0) covers (−x0,−y0) and (0,0). So the answer for polygons which don't have the sentral symmetry is NO. Let's prove if P has the central symmetry then the answer is YES. Translate P in such a way that the origin becomes its center of symmetry. Let's show that the homothety with the center at the origin and the coefficient 2 transforms P into T:

if a point (x0,y0) lies in P, then P(x0,y0) covers both (0,0) and (2x0,2y0);if a point (x0,y0) doesn't lie in P, then consider a segment connecting the center of symmetry of the polygon P (also known as origin) and (x0,y0); it crosses some side of P; WLOG, assume this side is parallel to the x-axis and lies in the line y=y1,y1>0 (otherwise we can rotate the plane). Since the polygon is convex, it completely lies in the stripe y∈[−y1;y1], that's why there isn't any vector which connects two points in P with a y-coordinate greater than 2y1. Since 2y0>2y1, there isn't any vector which connects two points in P with a y-coordinate equal to 2y0, that's why the point (2x0,2y0) doesn't lie in T.To find whether a polygon has the central symmetry, check whether the midpoints of segments connecting the opposite vertexes coincide; if a polygon has an odd number of vertexes it can't have the central symmetry.

1299C - Water BalanceLet's try to make the operation simpler. When we apply the operation, only the sum of the segment matters. And so let's instead define the operation on prefix sum array:

Replace each of pl,pl+1,…,pr by pi=pl−1+pr−pl−1r−l+1⋅(i−l+1). You may see how similar it is to a line function. Hence we get the idea to plot points (i,pi) ((0,p0=0) included), and our operation is just drawing a line between 2 points on integer x coordinates.

Nicely if sequence a is lexicographically smaller than sequence b, then prefix sum array of a is smaller than prefix sum array of b.

So we need to find the lexicographically smallest array p. And then it is easy to see the lexicographically smallest sequence p will be the lower part of the convex hull.

If you're interested you can solve IMO 2018 SL A4 by plotting similar points. I have written my solutionhere

1299D - Around the WorldIt's common knowledge that in an undirected graph there is some subset (not necessarily unique) of simple cycles called basis such that any Eulerian subgraph (in connected graphs also known as a cyclic path) is a xor-combination of exactly one subset of basis cycles. In a given connected graph consider any spanning tree; any edge which isn't in that spanning tree forms a cycle with some tree's edges of some cost c. These cycles form the basis. A cost of a cyclic path is an XOR of costs of basis cycles that form this path. Now we can move from cycle space to the space of 5-dimensional vectors Z52. If the costs of basis cycles are linear dependent, then there is a cycle of cost 0, else they form the basis of some subspace of Z52.

In the given graph there are two types of "components" connected to 1, and after removing the edges each component contributes some subspace (possibly an empty one); these subspaces shouldn't intersect. These two types are components connected with an edge and components connected with two edges:



In the first picture, the basis cycles are formed by the blue edges. We can cut the edge incident to 1 or keep it; if we don't cut that edge, this component contributes a subspace formed by costs of basis cycles unless they are linear dependent, else it contributes the empty subspace.

In the second picture, the basis cycles are formed by the blue edges and the red edge. We can cut both edges, and then this component contributes an empty subspace; if we cut one edge, the red edge moves to the spanning tree and no longer form a basis cycle, so this component contributes a subspace formed by costs of basis cycles formed by blue edges; if we don't cut any edges, then this component contributes a subspace formed by costs of basis cycles formed by blue and red edges.

If any choice leads to keeping a set of linear dependent basis cycles' costs, then this choice is invalid.

Now for every component, we have from 1 to 4 valid choices of choosing the contributing subspace. There are 374 subspaces of Z52, which can be precalculated as well as their sums. Now we can calculate a dp dpi,j — the number of ways to get the subspace j using the first i components. The transitions are obvious: if we can get the subspace X at the i-th component, then for each existing subspace Y, if X and Y don't intersect, do dpi,X+Y:=dpi,X+Y+dpi−1,Y, where X+Y is the sum of subspaces. The answer is a sum of dp values for the last component.

1299E - So MeanLet's solve this problem in several steps.

First, let's ask a query about each group of n−1 numbers. Note that 1+2+⋯+(i−1)+(i+1)+⋯+n=n(n+1)2−i≡1⋅22−imod(n−1). Therefore, answer will be YES only for numbers 1 and n. Find the positions where 1 and n lie, assign one of them to be 1 and the other one to be n (it doesn't matter how to assign 1 and n to these 2 spots, as permutations [p1,p2,…,pk] and [n+1−p1,n+1−p2,…,n+1−pk] are indistinguishable).

n queries.

Note that knowing 1, we can find parity of every other number. Indeed, just ask about 1 and pi, if answer is YES, pi is odd, else it is even.

n queries.

Suppose that we have found numbers 1,2,…,k,n−k+1,n−k+2,…,n at some point. Let's find numbers k+1 and n−k.

Consider all numbers except 1,2,…,k,n−k+1,n−k+2,…,n now. Ask a query about each subset of n−2k−1 numbers among them. Again, we can see that we will get answer YES only when we omit k+1 and n−k. Indeed, k+1+…(i−1)+(i+1)+⋯+(n−k)=k⋅(n−2k−1)+(n−2k)(n−2k+1)2−(i−k)≡1−(i−k)mod(n−2k−1), which is 0 only for i=k+1 and n−k.

Now that we know parities of all numbers, we can distinguish between k+1 and n−k. So, we determined k+1 and n−k in n−2k queries.

Note that this already means that we can solve our problem in n+n+(n−2)+(n−4)+(n−6)⋯+(n−(n−2)) queries, which is n2+6n4 queries. Unfortunately, this is much larger than we are allowed. However, we will use this method for n≤8.

Let's use the procedure above to find numbers 1,2,3,4,n−3,n−2,n−1,n. We have used 5n−12 queries by now, but let's round this up to 5n. Now, we are going to find the remainders of each element of permutation modulo 3, 5, 7, 8. As 3⋅5⋅7⋅8=840≥800≥n, we will be able to restore each number uniquely.

To find remainders modulo 3, we will first ask each number with already found 1 and 2. We will get YES only for numbers, divisible by 3. Next, we will ask each number whose remainder under division by 3 we haven't yet found with 1, 3. This way we find all the numbers which give the remainder 2. All others give the remainder 1.

We spend n+2n3 queries.

Similarly, we find remainders mod 5 and mod 7. For mod 5, at step i ask each number whose remainder we don't know yet with n,n−2,n−3,i (for i from 1 to 4).

We spend n+4n5+3n5+2n5 queries.

For mod 7, first ask all numbers whose remainders we don't know yet with {1,2,3,n−3,n−2,n−1}, then with {1,2,3,n−3,n−2,n}, {1,2,3,n−3,n−1,n}, {1,2,3,n−2,n−1,n}, {1,2,4,n−2,n−1,n}, {1,3,4,n−2,n−1,n} (sums of all these sets are different mod 7).

We spend n+6n7+⋯+2n7 queries.

Now time to find remainders mod 4. We already know all remainders mod 2. To distinguish 4k from 4k+2, ask with 1,2,3. To distinguish 4k+1 from 4k+3, ask with 1,2,4.

We spend n queries.

Now time to find remainders mod 8. We already know all remainders mod 4. Similarly, to distinguish 8k from 8k+4, ask with n,n−1,n−2,n−3,1,2,3, …, to distinguish 8k+3 from 8k+7, ask with n,n−1,n−2,n−3,1,2,4.

We spend n queries.

Overall, we spend 5n+(n+2n3)+(n+4n5+3n5+2n5)+(n+6n7+⋯+2n7)+n+n∼15.324n.

Note that this bound is easy to optimize (for example, determine all remainders mod 3 and 4 from 1,2,n,n−1, and after that check only candidates which work mod 12 in phase 5. This will reduce the number of operations to 13.66n operations. Of course, a lot of other optimizations are possible.

Codeforces Round #617 (Div. 3) Editorial

By vovuh, history, 3 years ago, In English1296A - Array with Odd Sum

Idea: vovuh

Tutorial1296A - Array with Odd SumFirstly, if the array already has an odd sum, the answer is "YES". Otherwise, we need to change the parity of the sum, so we need to change the parity of some number. We can do in only when we have at least one even number and at least one odd number. Otherwise, the answer is "NO".

Solution1296B - Food Buying

Idea: vovuh

Tutorial1296B - Food BuyingLet's do the following greedy solution: it is obvious that when we buy food that costs exactly 10k for k≥1, we don't lose any burles because of rounding. Let's take the maximum power of 10 that is not greater than s (let it be 10c), buy food that costs 10c (and add this number to the answer) and add 10c−1 to s. Apply this process until s<10 and then add s to the answer.

Time complexity: O(logs) per test case.

Solution1296C - Yet Another Walking Robot

Idea: MikeMirzayanov

Tutorial1296C - Yet Another Walking RobotFormally, the problem asks you to remove the shortest cycle from the robot's path. Because the endpoint of the path cannot be changed, the number of 'L's should be equal to the number of 'R's and the same with 'U' and 'D'.

How to find the shortest cycle? Let's create the associative array vis (std::map for C++) which will say for each point of the path the maximum number of operations i such that if we apply first i operations we will stay at this point. Initially, this array will contain only the point (0,0) with the value 0. Let's go over all characters of s in order from left to right. Let the current point be (xi,yi) (we applied first i+1 operations, 0-indexed). If this point is in the array already, let's try to update the answer with the value i−vis[(xi,yi)]+1 and left and right borders with values vis[(xi,yi)] and i correspondingly. Then let's assign vis[(xi,yi)]:=i+1 and continue.

If there were no updates of the answer, the answer is -1. Otherwise, you can print any substring you found.

Time complexity: O(nlogn) per test case.

Solution1296D - Fight with Monsters

Inspiration: 300iq, idea: vovuh

Tutorial1296D - Fight with MonstersLet's calculate the minimum number of secret technique uses we need to kill each of the monsters. Let the current monster has h hp. Firstly, it is obvious that we can take h modulo a+b (except one case). If it becomes zero, let's "rollback" it by one pair of turns. Then the number of uses of the secret technique we need is ⌈ha⌉−1.

Let's sort all n monsters by this value and take the "cheapest" set of monsters (prefix of the sorted array) with the sum of values less than or equal to k.

Time complexity: O(nlogn).

Solution1296E1 - String Coloring (easy version)

Idea: MikeMirzayanov

Tutorial1296E1 - String Coloring (easy version)Note that the actual problem is to divide the string into two subsequences that both of them are non-decreasing. You can note that this is true because you cannot the relative order of the elements colored in the same color, but you can write down subsequences of different colors in any order you want.

In this problem, you can write the following dynamic programming: dppos,c1,c2 is 1 if you can split the prefix of the string s[1..pos] into two non-decreasing sequences such that the first one ends with the character c1 and the second one — with c2 (characters are numbered from 0 to 25), otherwise dppos,c1,c2 is zero. Initially, only dp0,0,0=1, other values are zeros. Transitions are very easy: if the current value of dp is dpi,c1,c2 then we can make a transition to dpi+1,c,c2 if c≥c1 and to dpi+1,c1,c if c≥c2. Then you can restore the answer by carrying parent values.

But there is another very interesting solution. Let's go from left to right and carry two sequences s1 and s2. If the current character is not less than the last character of s1 then let's append it to s1, otherwise, if this character is not less than the last character of s2 then append it to s2, otherwise the answer is "NO".

If the answer isn't "NO" then s1 and s2 are required sequences. The proof and other stuff will be in the editorial of the hard version.

Time complexity: O(n⋅AL2) or O(n⋅AL) or O(n).

Solution (dp)Solution (greedy)1296E2 - String Coloring (hard version)

Idea: MikeMirzayanov

Tutorial1296E2 - String Coloring (hard version)The solution of this problem is based on Dilworth's theorem. You can read about it on Wikipedia. In two words, this theorem says that the minimum number of non-decreasing sequences we need to cover the whole sequence equals the length of longest decreasing subsequence.

Let's calculate the dynamic programming dpi — the length of longest decreasing sequence that ends in the position i. To recalculate this dynamic, let's carry the array maxdp of length 26, where maxdpc means the maximum value of dp for the character c on the prefix we already considered. So, initially all dpi are ones, all values of maxdp are zeros. For the position i we update dpi with max(maxdpsi+1,maxdpsi+2,…,maxdp25)+1 and update maxdpsi with dpi.

Okay, how to restore the answer? That's pretty easy. The color of the i-th character is exactly dpi. Why it is so? If dpi becomes greater than max(maxdpsi+1,maxdpsi+2,…,maxdp25) then we surely need to use the new color for this character because we cannot append it to the end of any existing sequence. Otherwise, we will append it to some existing sequence (with the maximum possible number) and because it has the maximum number and we didn't update the value of dp with the number of this sequence plus one, the current character is not less than the last in this sequence.

Time complexity: O(n⋅AL) or O(nlogn).

Solution1296F - Berland Beauty

Idea: MikeMirzayanov

Tutorial1296F - Berland BeautyFirstly, let's precalculate n arrays p1,p2,…,pn. The array pv is the array of "parents" if we run dfs from the vertex v. So, pv,u is the vertex that is the previous one before u on the directed path (v,u). This part can be precalculated in time O(n2) and we need it just for convenience.

Initially, all values fj (beauties of the edges) are zeros. Let's consider queries in order of non-decreasing gi. For the current query, let's consider the whole path (ai,bi) and update the value fj for each j on this path in the following way: fj=max(fj,gi). After processing all queries, let's replace all values fj=0 with fj=106. This part works also in time O(n2).

And the last part of the solution is to check if the data we constructed isn't contradictory. We can iterate over all paths (ai,bi) and find the minimum value fj on this path. We have to sure if it equals gi. If it isn't true for at least one query, then the answer is -1.

Otherwise, we can print the resulting tree.

Time complexity: O(n2), but it can be done in at least O(nlogn) (I hope someone can explain this solution because I am too lazy to do it now).

Solution

Codeforces Round #616 Editorial

By Kuroni, history, 3 years ago, In EnglishHello everyone, this is the editorial for Codeforces Round #616 (Div. 1) and Codeforces Round #616 (Div. 2)! Along with the solution to each problem, we will have the theme and easter egg solution as well! I hope you all enjoyed our problems ( ´ ▽ ` )b

1291A - Even But Not Even

Author: 265918

Tutorial1291A - Even But Not EvenIf the number of odd digits is smaller than or equal to 1, it is impossible to create an ebne number.

Otherwise, we can output any 2 odd digits of the number (in correct order of course).

Implementation1291B - Array Sharpening

Author: hugopm

Tutorial1291B - Array SharpeningHow to know if we can make the prefix [1;k] strictly increasing? We just have to consider the following simple greedy solution: take down values to 0,1,…,k−1 (minimal possible values). It's possible if and only if ai≥i−1 holds in the whole prefix.

Similarly, the suffix [k;n] can be made strictly decreasing if and only if ai≥n−i holds in the whole suffix.

Using these simple facts, we can compute the longest prefix we can make strictly increasing, and the longest suffix we can make strictly decreasing in O(n). Then, we just have to check that their intersection is non-empty.

Implementation1290A - Mind Control

Author: Ari

Tutorial1290A - Mind ControlPeople behind you are useless, ignore them. Let's assume that k≤m−1. It's always optimal to control as many people as possible.

Your strategy can be summarized by a single integer x, the number of people you force to take the first element (among the k you control).

Similarly, the strategy of your opponents can be summarized by a single integer integer y, the number of non-controlled friends who choose to take the first element.

When it will be your turn, the array will contain exactly n−m+1 elements. You will be able to take the biggest element among the first element a1+x+y and the last element a1+x+y+(n−m).

These observations lead to an obvious O(n2) solution (iterate over all strategies x and for each strategy, iterate over all cases y), which was sufficient to pass the tests.

However, the second iteration can be easily optimized with a data structure.

Let's note bi=max(a1+i,a1+i+(n−m)). The final answer is maxx∈[0;k][miny∈[0;m−1−k]bx+y].

Note that it can be rewritten as maxx∈[0;k][miny′∈[x;x+m−1−k]by′].

It can be computed in O(nlogn) using segment tree or in O(n) using monotonic deque.

Implementation (quadratic)Implementation (linear)1290B - Irreducible Anagrams

Author: Ari

Tutorial1290B - Irreducible AnagramsWe claim that a string has at least one irreducible anagram if and only if one of the following conditions holds:

Its length is equal to 1.Its first and last characters are different.It contains at least three different characters.Once we have proven this characterization it is easy to solve the problem: For any given query, the first and second conditions are trivial to check, while the third condition can be checked efficiently if we maintain the number of appearances of each character in each prefix of our string. This allows us to answer queries in O(k) where k=26 is the size of our alphabet.

Now let's prove the characterization. Consider any string s with n=|s|≥2. First note that for any two strings a and b that are anagrams, it is enough to check that no two proper prefixes of them are anagrams for them to be irreducible anagrams, because if a and b are reducible then a1 and b1 are two proper prefixes that are anagrams. We will consider three cases. In what follows all indices are 1-based.

If s[1]≠s[n].Write all occurrences of s[n] in s, and then write all the remaining characters of s in any order. Every proper prefix of the resulting string will have more occurrences of s[n] than the corresponding prefix of s, so no two of them will be anagrams.

If s[1]=s[n] and s has at least three different characters.Consider the last distinct character that appears in s. Write all occurrences of it, followed by all occurrences of s[n], and then write the remaining characters of s in any order. We can check that every proper prefix of the resulting strings contains more occurrences of either this last distinct character, or more occurrences of s[n], than the corresponding prefix of s, so no two proper prefixes are anagrams.

If s[1]=s[n] and s has at most two different characters.Assume that s only has characters a and b, and that s[1]=a. Assume that s has an irreducible anagram t. Then t[1]=b, as otherwise s[1,1] and t[1,1] are anagrams.

Consider the leftmost position x such that the prefix s[1,x] has at least as many appearances of b as t. We have x≤n−1 because s[1,n−1] contains every possible appearance of b. Moreover, we have x>1. Now, notice that t[1,x−1] must have strictly more appearances of b than s[1,x−1]. This is only possible if this prefix had exactly one more appearance of b, and then s[1,x] and t[1,x] have the same number of appearances of b. But this means that the proper prefixes s[1,x] and t[1,x] are anagrams  — a contradiction.

Implementation1290C - Prefix Enlightenment

Author: hugopm

Tutorial1290C - Prefix EnlightenmentThe condition "the intersection of any three subsets is empty" can be easily rephrased in a more useful way: each element appears in at most two subsets.

Let's suppose for the moment that each elements appears in exactly two subsets. We can think of each element as an edge between the subsets, it's a classical point of view. If we see subsets as nodes, we can model the subsets choice by coloring nodes into two colors, "taken" or "non-taken".

If an element is initially off, we need to take exactly one of the subsets containing it. The corresponding edge should have endpoints with different color. If an element is initially on, we must take none or both subsets : endpoints with same color.

We recognize a sort of bipartition, obviously there are at most two correct colorings for each connected component: fixing the color of a node fix the color of all connected nodes.

Hence, the final answer is the sum for each component, of the size of the smaller side of the partition.

Since the answer exists for i=n, there exists a such partition of the graph (into "red" and "blue" nodes). We can find it with usual dfs, and keep it for lower values of i.

In order to compute all mi efficiently, we start from a graph with no edges (i=0), and we add edges with DSU, maintaining in each connected component the count of nodes in red side, and the count of nodes in blue side.

Now, how to deal with elements that appears in exactly one subset? They don't add any edge in the graph, but they force to take one of the sides of the connected component. To simulate this, we can use a special forced flag, or just fix the count of the other side to +∞ (but be careful about overflow if you do that).

Final complexity : O((n+k)⋅α(k)).

Implementation (preprocess with DFS)Implementation (dynamic bipartite DSU)1290D - Coffee Varieties (hard version)

Author: hugopm

Tutorial1290D - Coffee Varieties (hard version)Easy version (constant 2)

Let's try to maintain representative positions for each value. In the beginning, when we know nothing, every position can be a potential representative.

We will call them alive positions, and using queries, we will try to kill some positions and ending up with exactly one alive position per value. The answer will be the number of alive positions.

Note that when we kill a position, there must be another alive position with the same value. The danger here is to compare a position to a dead position of the same value: we may end up killing the single representative of the value.

Create blocks of size k2, (or 1 if k=1). Query 1,2,…,n and kill the element if you get Yes answer. Each value has at least one alive occurrence, its leftmost one. Moreover, all equalities inside blocks are removed.

In order to remove equalities between blocks, compare all unordered pairs of blocks (for each pair, reset the memory, look all elements in the first one, then all elements in the second one, and kill elements in the second one for each Yes answer). Note that we don't need to compare adjacent blocks. The number of queries is a bit less than 2n2k.

Hard version (constant 1.5)

Querying 1,2,…,n allowed us to compare pairs (i,i+1) in a very efficient manner because we reuse the memory of the previous comparison. Let's try to generalize this.

Consider a complete graph where nodes are blocks. Comparing pairs of blocks can be seen as covering edges of the graph. We can take any elementary path (that doesn't pass through a node twice), reset the memory and explore blocks in the corresponding order (killing elements for each Yes answer).

Each path will require (number of edges+1)⋅k2 queries. It's optimal to have disjoint paths (if a path goes through an already visited edge, we can split it there). Hence, we want to use a few disjoint paths to cover all edges.

A randomized DFS works experimentally well (constant around 1.2).

However, we can acheive constant 1 using the following zig-zag pattern: s→s−1→s+1→s−2→s+2→….

Implementation1290E - Cartesian Tree

Author: gamegame

Tutorial1290E - Cartesian TreeInstead of inserting numbers one by one, let's imagine I have n blanks in a row, and I will fill the blanks with integers from [1,n] in order, and I want to know about the cartesian tree after each blank filled.

In the following parts of the solution, I will use positions in the original array instead of positions in the contracted array to label things.

In the process of building a cartesian tree, a node is created for each recursive call of building a tree for a subarray [l,r]. Let's label the node created at that moment to be (l,r). We realize that r−l+1 will be the size of the subtree of that node. However, in our problem, some positions can be blanks, so the actual subtree size of a node (l,r) is the number of positions that are not blanks in the subarray [l,r].

So now we are finding the sum of the number of non-blanks in the range for each node (l,r) in our cartesian tree. Let pf(r) be the number of non-blanks in the first r positions of the sequence. Then we are finding sum of pf(r)−pf(l−1) for each node (l,r).

To proceed, observe a property for a cartesian tree. Let's define for each integer p, let maxr(p) to be the largest r such that (p,r) is a node, or just null if there is no nodes of the form (p,r). Similarly, define minl(p) to be the smallest l such that (l,p) is a node.

Then, for each node (l,r), exactly one of the following is true:

maxr(l)=r.minl(r)=l.Except when (l,r) is the root.

If we know:

sum of pf(maxr(l)) over all maxr(l) that is not null.sum of pf(l−1) over all maxr(l) that is not null.sum of pf(r) over all minl(r)that is not null.sum of pf(minl(r)−1) over all minl(r) that is not null.Then we can find out the answer. As it is more or less symmetric I will only care about part (1) and (2) from now on.

Let's find out what would happen to nodes of our tree if we fill i+1 into position x, replacing a blank. Let's omit how the nodes connect each other and just track the labels of each node. For convenience, we will make the following definitions.

Call prv the nearest non-blank position on the left side of x.Call nxt the nearest non-blank position on the right side of x.Call head the leftmost non-blank position.Call tail the rightmost non-blank position.Firstly, every node that is of the form (p,q) where p≤x≤q, will be split into two halves of (p,prv) and (nxt,q). Then, duplicates (nodes that represent the same range) will be removed. Finally, there will be a new node that would represent the root, which is (head,tail).

Let's track how maxr changes.

maxr(p)=min(maxr(p),prv) for all p in the range [head,prv].Some modification to values of maxr(head), maxr(x) and maxr(nxt).As the first step doesn't change whether values are null or not, and modifications to the second step can be easily handled, part (2) can be easily maintained by a Fenwick tree. So it remains to compute part (1).

Imagine instead of computing sum of pf(maxr(l)), we are computing sum of maxr(l) Then, we realise that we are having a Segment Tree Beats problem. You have to maintain a sequence with 3 kinds of operation:

Do a[x]=min(a[x],v) for x in [l,r].a[x]=v.Query the sum of the whole array.Check part 2 of this blog and this proof of time complexity.

Then we can solve this variation of the problem in O(nlogn).

So, we have to modify the above variant into solving the real problem. Look at what we do every time we are doing query 1. We are doing a total of O(nlogn) times of changing some occurrences of value u to value v. Which means, we can maintain the frequency for values of maxr. Therefore, for each put-tag operation in our segment tree beats, we just modify a Fenwick tree that represents the frequency of values in maxr. Because we have O(nlogn) updates to the segment tree, the total time complexity is O(nlog2n).

It is also possible to replace "segment tree beats" with "treap beats" and we can support online queries, but it is not required to pass this problem.

We also allowed methods of slower complexity (i.e. O(nn−−√)) to pass. It basically is the same but does the above things by sqrt decomposition instead. Care is needed to be sure that there is no extra log factor.

Implementation1290F - Making Shapes

Author: Kuroni

Tutorial1290F - Making ShapesNotice that there is a one-to-one correspondent between a non-degenerate convex shape and a non-empty multiset of vectors. That is because, for each shape, we can generate exactly one multiset of vectors by starting at the lowest-leftest point going counter-clockwise (this is possible because no two vectors are parallel); and for each multiset of vectors, we can generate a single convex shape by sorting the vectors by angle then add them in order.

Our problem is now counting the number of multisets of vectors that makes non-degenerate convex shapes that can be contained in a m×m square. Rather, we denote ci as the number of times the ith vector appears in our multiset. We need to count the number of arrays c such that:

∑i=1ncixi=∑i=1nciyi=0∑1≤i≤n,xi>0cixi≤m∑1≤i≤n,yi>0ciyi≤mNote that the first conditions are equivalent to ∑1≤i≤n,xi<0−cixi=∑1≤i≤n,xi>0cixi and ∑1≤i≤n,yi<0−ciyi=∑1≤i≤n,yi>0ciyi.

For the sake of brevity, let's call ∑1≤i≤n,xi<0−cixi, ∑1≤i≤n,xi>0cixi, ∑1≤i≤n,yi<0−ciyi, and ∑1≤i≤n,yi>0ciyi by nx, px, ny, and py respectively.

We will now focus on log2m layers of the array c, the ith layer is represented by a bitmask of n bits, where each bit j is the ith bit in the binary representation of cj. We see that if we iterate over these layers like this, we can slowly construct nx, px, ny, and py bit by bit, and be able to compare them with each other and with m. So, we do a dynamic programming solution where we maintain these states:

The current bit.The carry-over value for nx.The carry-over value for px.The carry-over value for ny.The carry-over value for py.Whether the suffix of px is larger than the suffix of m.Whether the suffix of py is larger than the suffix of m.When we iterate over the states, we iterate over the bitmask of the current layer and calculate and update on the next states. note that, for px for example, the carry-over value has a limit of ∑i=1∞⌊px2i⌋=px, and px≤4n, so each carry-over dimension is at most 4n (practically they cannot all be 4n at the same time, so pre-calculating the bound for each dimension is necessary).

Complexity: O(log2m⋅n4⋅2n).

ImplementationTheme and easter eggsSpoilers

Codeforces Round #615 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishThanks to Rox and _overrated_ for help with problem ideas and preparation!

1294A - Collecting Coins

Idea: MikeMirzayanov

Tutorial1294A - Collecting CoinsSuppose a≤b≤c. If it isn't true then let's rearrange our variables. Then we need at least 2c−b−a coins to make a, b and c equal. So if n<2c−b−a then the answer is "NO". Otherwise, the answer if "YES" if the number n−(2c−b−a) is divisible by 3. This is true because after making a,b and c equal we need to distribute all remaining candies between three sisters.

Solution1294B - Collecting Packages

Idea: MikeMirzayanov

Tutorial1294B - Collecting PackagesIt is obvious that if there is a pair of points (xi,yi) and (xj,yj) such that xi<xj and yi>yj then the answer is "NO". It means that if the answer is "YES" then there is some ordering of points such that xi1≤xi2≤⋯≤xin and yi1≤yi2≤⋯≤yin because we can only move right or up. But what is this ordering? it is just sorted order of points (firstly by xi then by yi).

So we can sort all points, check if this ordering is valid and traverse among all these points. For each k from 2 to n firstly do xik−xik−1 moves to the right then do yik−yik−1 moves to the up (because this order minimizing the answer lexicographically).

Time complexity: O(nlogn) or O(n2).

Solution1294C - Product of Three Numbers

Idea: MikeMirzayanov

Tutorial1294C - Product of Three NumbersSuppose a<b<c. Let's try to minimize a and maximize c. Let a be the minimum divisor of n greater than 1. Then let b be the minimum divisor of na that isn't equal a and 1. If nab isn't equal a, b and 1 then the answer is "YES", otherwise the answer is "NO".

Time complexity: O(n−−√) per query.

Solution1294D - MEX maximizing

Idea: vovuh

Tutorial1294D - MEX maximizingFirstly, let's understand what the operation does. It changes the element but holds the remainder modulo x. So we can consider all elements modulo x.

Let cnt0 be the number of elements with the value 0 modulo x, cnt1 be the number of elements with the value 1 modulo x, and so on. Let's understand, where is the "bottleneck" of MEX. Obviously, we can always fill exactly min(cnt0,cnt1,…,cntx−1) full blocks, so MEX is at least min(cnt0,cnt1,…,cntx−1)⋅x. MEX will be among all elements y∈[0;x−1] such that cnty=min(cnt0,cnt1,…,cntx−1). Among all such elements MEX will be the minimum such y. Let it be mn. So the final value of MEX is cntmn⋅x+mn.

How to deal with queries? Let's maintain the sorted set of pairs (cnty,y) for all y∈[0;x−1] and change it with respect to appended values. During each query let's change the set correspondingly and take the answer as the first element of this set using the formula above.

Time complexity: O(nlogn). There is also an easy linear solution that uses the same idea but in a different way.

Solution1294E - Obtain a Permutation

Idea: vovuh

Tutorial1294E - Obtain a PermutationAt first, let's decrease all elements by one and solve the problem in 0-indexation.

The first observation is that we can solve the problem independently for each column.

Consider the column j (j∈[0;m−1]). It consists of elements [j;m+j,2m+j,…,(n−1)m+j]. Now consider some element ai,j (i∈[0;n−1]). We don't need to replace it with some other number in only one case: if we shift the column such that ai,j will coincide with the corresponding number of the required matrix. Obviously, there is only one cyclic shift of the column that can rid us of replacing ai,j. So, the idea is the following: let's calculate for each cyclic shift the number of elements we don't need to replace if we use this cyclic shift. Let for the i-th cyclic shift (0-indexed) it be cnti. Then the answer for this column can be taken as mini=0n−1n−cnti+i.

How to calculate for the element ai,j the corresponding cyclic shift? Firstly, if ai,j%m≠j (% is modulo operation) then there is no such cyclic shift. Otherwise, let pos=⌊ai,jm⌋. If pos<n then there is such cyclic shift (pos can be greater than or equal to n because ai,j can be up to 2⋅105) and the number of such cyclic shift is (i−pos+n)%n. So let's increase cnt(i−pos+n)%n and continue. After considering all elements of this column take the answer by the formula above and go to the next column.

Time complexity: O(nm).

Solution1294F - Three Paths on a Tree

Idea: MikeMirzayanov

Tutorial1294F - Three Paths on a TreeThere is some obvious dynamic programming solution that someone can describe in the comments, but I will describe another one, that, in my opinion, much easier to implement.

Firstly, let's find some diameter of the tree. Let a and b be the endpoints of this diameter (and first two vertices of the answer). You can prove yourself why it is always good to take the diameter and why any diameter can be taken in the answer. Then there are two cases: the length of the diameter is n−1 or the length of the diameter is less than n−1. In the first case, you can take any other vertex as the third vertex of the answer c, it will not affect the answer anyway. Otherwise, we can run multi-source bfs from all vertices of the diameter and take the farthest vertex as the third vertex of the answer. It is always true because we can take any diameter and the farthest vertex will increase the answer as much as possible.

Time complexity: O(n).

Solution

Codeforces Round #614 Editorial

By AkiLotus, 3 years ago, In EnglishAll themes written by AkiLotus (I am the only one in the team playing Cytus II anyway :D).

1293A - КоннеР и A.R.C. Markland-NAuthor: xuanquang1999Development: xuanquang1999, AkiLotusEditorialist: xuanquang1999, AkiLotus

Tutorial1293A - ConneR and the A.R.C. Markland-NTeam Grimoire+あま猫 - XiorcSince there's only k closed restaurants, in the worst case we'll only have to walk for k staircases only (one such case would be s=n and all the restaurants from floor s−k+1 to s are closed).

Therefore, a brute force solution is possible: try out every distance x from 0 to k. For each, determine if either s−x or s+x is within range [1,n] and not being in the closed list.

The check of an element being a list or not can be done easily by a built-in function in most programming languages, for C++ it would be the "find" function with linear time complexity. Of course one would love to check with set/TreeSet, but for this problem it's an overkill.

Time complexity: O(k2).

Solution (Akikaze, C++)Solution (Akikaze, Java 8)Solution (Akikaze, Python 3)1293B - JOE на телевидении!Author: AkiLotusDevelopment: AkiLotusEditorialist: AkiLotus

Tutorial1293B - JOE is on TV!Frums - Turnstile JumperThis is a greedy problem, with the optimal scenario being each question eliminating a single opponent.

It is easy to see that we will want each question to eliminate one opponent only, since after each elimination, the ratio t/s will be more and more rewarding (as s lowers overtime) - as a result, each elimination should have the lowest possible t (i.e. t=1) so more opponents would have their rewards increased.

Time complexity is O(n).

Solution (Akikaze, C++)Solution (Akikaze, Java 8)Solution (Akikaze, Python 3)1292A - Игровой лабиринт НекоAuthor: xuanquang1999Development: xuanquang1999, AkiLotusEditorialist: AkiLotus

Tutorial1292A - NEKO's Maze GameSIHanatsuka - REmorseThe main observation is that, it is possible to travel from (1,1) to (2,n) if and only if there exist no pair of forbidden cell (1,a) and (2,b) such that |a−b|≤1.

Therefore, to answer the query quickly, for every d from −1 to 1, one should keep track of the number of pair (a,b) such that:

(1,a) and (2,b) are both forbidden.a−b=d.One of the methods to do this is: after a cell (x,y) has been swapped, check for all cells (3−x,y−1), (3−x,y), (3−x,y+1) and update the number of pairs based on the status of those cells and new status of (x,y). Since n≤105, the status of all cells can be easily kept in a 2D boolean array, and accessed in O(1) time complexity.

Total complexity: O(n+q).

Video editorialSolution (Akikaze, C++)Solution (Akikaze, Java 8)Solution (Akikaze, Python 3)1292B - Арома и её поискAuthor: AkiLotus feat. xuanquang1999Development: xuanquang1999, AkiLotusEditorialist: AkiLotus

Tutorial1292B - Aroma's SearchM2U feat. Kaicy - GravityFirst, keep a list of "important" nodes (nodes that are reachable from the starting point with t seconds), and denote this list [(x1,y1),(x2,y2),…,(xk,yk)]. Since ax,ay≥2, there are no more than log2(t) important nodes (in other words, k≤log2(t)).

In an optimal route, we must first reach a data node in fastest time possible. Suppose that we reach node z first, and we now have t′ seconds left.

Let's denote d(i,j) the time required to travel from the i-th node to the j-th node. d(i,j) is also the Manhattan distance between the i-th and the j-th node – in other words, d(i,j)=|xj−xi|+|yj−yi|. Since xi≥xi−1 and yi≥yi−1, we have d(u,v)+d(v,w)=d(u,w) for all 1≤u<v<w≤k. Therefore, if we consider all the nodes to stay in a line in such a way that xi=xi−1+d(i−1,i), the problem is reduced to the following problem:

To solve the above problem, one should notice that it is optimal to collect nodes in a continuous segment. Suppose that we collect all nodes from the l-th to r-th (for some l≤s≤r). An optimal route is one of the two below:

Go from z to r and then go to l. The time required for this route is d(r,z)+d(r,l).Go from z to l and then go to r. The time required for this route is d(z,l)+d(r,l).Therefore, the minimum amount of energy required to collect all the nodes from l-th to r-th is d(r,l)+min(d(z,l),d(r,z)).

Since k is small, one can brute-force through all triple of (l,z,r) such that 1≤l≤z≤r≤k and check if t seconds are enough to go to i-th node and then collect all the nodes from l-th to r-th or not.

The time complexity for that approach is O(log2(t)3).

However, we can notice that it's always the most optimal to choose z as either l or r, for a few reasons:

As the aforementioned formula, either d(z,l) or d(r,z) will be counted twice (one there, and one within d(r,l), so having it reduced to 0 nullifies the exceeded step.The distance from (xz,yz) to (xs,ys) does not break the minimal properties of the endpoint(s) regardless of (xs,ys)'s position. We can prove it by considering all possible relative positions of (xs,ys) over the segment (we'll consider the x-coordinates only, y-coordinates will have the same properties, without loss of generality):If xs≤xl, the distance is minimal at z=l.If xr≤xs, the distance is minimal at z=r.If xl≤xs≤xr, the travelling time in x-coordinates is d(s,z)+d(r,l)+min(d(z,l),d(r,z)). One can see that d(s,z)+min(d(z,l),d(r,z))=min(d(s,l),d(s,r)), therefore any z (including the endpoints, of course) is equally optimal. Proof for the above formula is trivial.The optimal solution's time complexity is O(log2(t)2).

Solution (Akikaze, C++)Solution (Akikaze, Java 8)Solution (Akikaze, Python 3)1292C - Атака КсенонаAuthor: xuanquang1999Development: xuanquang1999Editorialist: xuanquang1999

Tutorial1292C - Xenon's Attack on the GangsA-Tse & KIVΛ - Black HoleThe first observation is that, the formula can be rewritten as:

S=∑1≤u<v≤nmex(u,v)=∑1≤x≤n⎛⎝∑mex(u,v)=xx⎞⎠=∑1≤x≤n⎛⎝∑mex(u,v)≥x1⎞⎠=∑1≤x≤nf(x)Where f(x) is number of pairs (u,v) such that 1≤u<v≤n and mex(u,v)≥x (in other word, the path from u to v contains all numbers from 0 to x−1).

Consider the process of placing numbers in order from 0 to n−1 (first place number 0, then place number 1, etc.) on edges of the tree. Suppose that the placement for all numbers from 0 to x−1 are fixed, and now we need to place number x. To maximize S, we should try to place x in a way that there exists a path contain all numbers from 0 to x (if this is possible).

In other word, in the optimal solution, there will be a path connecting two leaf vertices that contain all numbers from 0 to l−1 (where l is the number of vertices in that path). The placement of numbers from l to n−2 does not matter, since it will not affect the result.

Now, suppose that the location of such path is fixed, and its length is l. Let a the sequence of number on edges on the path from u to v. One can show that, in other to archive maximum S, a must be a 'valley' sequence (there exist some position p such that a1>a2>…>ap<…<al−1<al.

All the observation above leads to the following dynamic programming solution:

Let dp[u][v] the maximum value of ∑1≤x≤lf(x) if all number from 0 to l−1 are written on the edges on the path from u to v (with l denote the length of that path). We also define:

par(r,u): the parent of vertex u if we root the tree at vertex r.sub(r,u): the number of vertices in the subtree of vertex u if we root the tree at vertex r.The figure below demonstrate par(u,v) and par(v,u) for two vertices u and v (in the figure, pu,v is par(u,v) and pv,u is par(v,u)).

To calculate dp[u][v], there are two cases:

Putting number l on the edge (u,par(v,u)). In this case:∑1≤x≤lf(x)=f(l)+∑1≤x≤l−1f(x)=sub(u,v)×sub(v,u)+dp[par(v,u)][v]Putting number l on the edge (v,par(u,v)). Similarly, ∑1≤x≤lf(x)=sub(u,v)×sub(v,u)+dp[u][par(u,v)]The final formula to calculate dp[u][v] is:

dp[u][v]=sub(u,v)×sub(v,u)+max(dp[par(v,u)][v],dp[u][par(u,v)])The formula can be calculated in O(1) if all the values of par(r,u) and sub(r,u) are calculated (we can preprocess to calculate these value in O(n2). by doing performing DFS once from each vertex). Therefore, the overall complexity for this algorithm is O(n2).

Solution (xuanquang1999, C++)Solution (xuanquang1999, Java 8)1292D - Хаотичная В.Author: AkiLotusDevelopment: AkiLotusEditorialist: AkiLotus

Tutorial1292D - Chaotic V.Ice - iLFirst of all, one can see that the network is a tree rooted at vertex 1, thus for each pair of vertices in it there can only be one simple path.

Also, the assembly node P must be on at least one simple path of a fragment to the root (proof by contradiction, explicit solution is trivial).

Let's start with P being node 1.

From here, moving down to any branch will increase 1 for each element not being in that branch and decrease 1 for each element being in, thus we'll only move down to the branch having the most elements until the decreasing cannot outmatch the increasing (in other words, the number of fragments in a branch must be more than half for that branch to be reached).

Given the criteria of the graph, we can see that: two nodes are in the same branch from the root if having the same one largest factor from the prime factorization, they are in the same branch from a depth-1-node if having the same two largest factors, ..., in the same branch from a depth-k-node if having the same k+1 largest factors.

Keep in mind that here the largest factors can be the duplicated, i.e. in the case of 576=26⋅32, the two largest factors are 3 and 3, and the three largest factors are 3, 3 and 2.

The process will now become factorizing the numbers, and then, cycle by cycle, pop the current largest factor of each number and group them, find out the group (branch) with most occurences and either move on (if the total sum can be lowered) or stop the process.

Since all of these are factorials, the factorizing can be done with a bottom-up dynamic programming fashion.

Also, as k≤5000 and n≤106, consider grouping duplicated elements to reduce calculating complexity.

Both factorization and processing has the worst-case complexity of O(MAXK2⋅f(MAXK)), with k⋅f(k) being the estimated quantity of prime divisors of k!.

It's proven that f(k)=M+lnlnk, with M being the Meissel-Mertens constant.

The proof of this formula is based on the fact this number is calculated through the sum of the reciprocals of the primes.

Solution (Akikaze, C++)Solution (Akikaze, Java 8)Solution (Akikaze, PyPy 3)1292E - Рин и неизвестный цветокAuthor: low_ (Sulfox Remix)Development: low_, Sulfox, AkiLotusEditorialist: low_

Tutorial1292E - Rin and The Unknown FlowerSherwin - The Grand DebateTo be fair, this is a complicated decision tree problem. I recommend instead of heading straight to read the main solutions for this, try to spend some time and come up with at least 2 solutions for the case when the query limit is 5/3 first.

<spoilers> There are many solutions when limit = 5/3, and I'll point 2 of them out. The difference between the two solutions is how you approach the string and build a decision tree out of those queries:

1. The easiest to come up with: disclose every joint of the string (which is equivalent to find every position i that S[i]==S[i+1]). All remaining letters can be filled up with the nearest disclosed letter to it. This can be done by asking 6 queries: "CH", "HC", "CO", "OC", "OH", "HO". If none of the letters is disclosed, then all of the letters are the same. You can disclose all of them by asking 2 more queries of length n and determine what letter is it.

2. The most natural solution (in my opinion): The idea of this is to disclose at least one letter of the string, to disclose the rest with at most one string of length 2 to n each. We could do this by simply asking "C". This could go either way:

If a 'C' is disclosed at a position i, we can disclose the position i+1 with one query of length 2, i+2 with one query of length 3, ... and so on. From there, undisclose position i−1 with a query of length n−i+1, i−2 with a query of length n−i+2, ... and so on.If no letter is disclosed, the problem narrows down to solve with a binary string and total cost of 2/3. There are multiple ways to tackle this so I won't spend any more time to explain this case.The key here is to come up with a strategy that works in all branches of the decision tree. And to do that, we must find a good starting query/set of queries to begin with.

In the two strategies above, number 1 is too brutal, and number 2 is too naive. But my main solution contains the essences which can be seen in both solutions. The main idea is to find a set of queries to begin with like strat #2 but would give us more hints and cost us less when things go the other way.

We'll start by asking queries with "CH", "CO", "HC", "HO", which in total have cost of 1. That way, the non-disclosed parts can be one of those:

Consecutive similar characters.A joint starting with "O".Supposed that after four above queries and no occurrences were found at all, the string can now be only in one of those kinds:

An entire string constructed by a single character.A string of form "OO...XX", with "X" being either "C" or "H". In other words, the string is constructed by n0 characters "O", followed by n1 characters "X" (n0+n1=n).Proof for this is trivial.

We'll find the trace of large chunks of "C" or "H" (cannot find every trace since the cost limit is very tight here, the minimum length allowed should only be 3). To do this, we'll ask queries "CCC" and "HHH" sequentially. If any of the two queries return occurrence(s), that means all occurrences of "C" or "H" has been revealed (and also guaranteed to completely inherit the right side of the string), any undisclosed characters on the left will obviously be "O". From here, we can conclude and return the original string.

However, if both queries return nothing, this means either the string contains only "O" characters or there are at most 2 rightmost characters being "C" or "H". Given this, we ought to find the chunk of "O" by asking query "OOO" (similar logic to the former step). If it returns occurrence(s) and there are still undisclosed characters, we'll need another query of length n to finalize: replacing all of the undisclosed positions to "C" then ask a query with that string, if it returns occurrence then "C" is for the missing characters, otherwise "H" is.

This method works because there will always be one chunk with length at least 3 (on either end of the string), except two cases: "OOCC" and "OOHH".

You will get to this if all three above queries failed to return anything. However, since this is a matter of picking one from two, a single query of either string will work: the original string is the asked string if occurrence found, otherwise the other.

This is also the worst case in this branch. Total cost would be 1+3⋅19+116=1.3958(3) - very close to the limit.

Back to the case that some occurrence(s) are found when after asking the 4 joint queries. The logic now is pretty similar to strat #2 mentioned above however due to the more varied undisclosed patterns, we'll need to take some extra caution.

First of all, we'll start at the leftmost revealed segment, and disclose any hidden characters to the left of it. It's easy to see that the leftmost revealed character can never be "O", and since the leftmost hidden segment always come in one of two forms similar to the no-occurrence case branch above, you can always reveal the nearest character by assuming it is the same as the current leftmost revealed character and use it as a query to ask. If the assumption is incorrect, then it and any remaining hidden letters to the left of it will be "O".

Now that we have a fully revealed prefix, we'll extend it by revealing letters to the right. For simplicity, let's split into two cases: one when there are revealed letter(s) not within our current prefix, one when there is none.

If such revealed letters are found, consider the one being closest to our prefix. We can see that the hidden gap between our prefix and it can only be produced by some (probably none) characters being the same as our rightmost character in the prefix, followed by some (probably none) characters being the same as our leftmost character outside of the prefix. Thus, we can simply assume the next hidden character is the same as our rightmost in-prefix character, then ask the query. If the assumption is incorrect, fill it and all the remaining hidden characters in that segment with the other one.

If there are none, then the last hidden segment is again, similar to the no-occurrence case branch. However, we have a significant clue this time: our rightmost in-prefix character. If it is not "O", we can quickly fill all the hidden positions with it, otherwise, we'll keep asking query again, assuming the next hidden character is still "O": if incorrect, take another query to ask if either it is "C" or "H", and then fill it and all the other hidden ones.

** Example interaction:

The string is "COHHHH..." (n=50, in other words the string is construct by appending 48 character "H" to the string "CO").

=> 50

(Finding joints not starting at O)

? CH => 0

? CO => 1 1

? HC => 0

? HO => 0

(Now, the string can be deduced as "CO????...")

? COO => 0 (Assuming that the third character is still "O", sadly it isn't.)

? COC => 0 (Assuming that the third character is still "C", and it isn't either.)

(By now we can deduce the string to be "COHHHH....", since the fourth character and beyond cannot be anything other than "H" (otherwise it would have raised a signal in the joints queries)).

! COHHHH... => 1

** End of example.

The maximum cost for this will be (i=3 because starting from a joint means we have at least 2 found characters, incremented by 1 by the character we're about to guess):

max4≤n≤50(1+∑i=3n1i2+1n2)With n going to positive infinity, the limit of this function will be 2π2−312<1.4, therefore this solution still works.

</spoilers>

Big credits to Sooke for making this problem more interesting by pointing out a way to reduce the initial limit (5/3) and make this problem much less trivial.

Solution (Akikaze, C++)Solution (Akikaze, Java 8)Solution (Akikaze, Python 3)1292F - Игрушки НорыAuthor: xuanquang1999 × MofKDevelopment: xuanquang1999Editorialist: xuanquang1999

Tutorial1292F - Nora's Toy BoxesKURORAK - Jakarta PROGRESSION3R2 - Starlight (KIVΛ Remix)We consider a directed graph G, where we draw an edge from vertex i to vertex j if ai∣aj. Notice that G is a DAG and is transitive (if (u,v),(v,w)∈G then (u,w)∈G).

For each vertex, we consider two states: "on" (not deleted) and "off" (deleted). An edge is "on" if both end vertices are not deleted, and "off" otherwise. The operation is equivalent to choosing a vertices triple (u,v,w) such that u, v, w are on and (u,v),(u,w)∈G; then turn off vertex w and append aw to the end of b.

We first solve the problem for a weakly connected component C (only choosing vertices triple belong to this component in each operation). Define S the set of all vertices with no incoming edges, and T the set of remaining vertices (T=C−S). Obviously, vertices in S can't be turned off. We need to figure out the maximum number of vertices in T we can turn off.

We consider the reversed process. Initially, some vertices in T are turned off, and we can turn on a vertex with the following operation: choose a vertices triple (u,v,w) such that u, v are on, w is off, and (u,v),(u,w)∈G; then turn on w and append aw to the beginning of b.

Lemma 1: For each vertex u∈T, there exist a vertex in S that has an outgoing edge to u.

Proof:

Consider a vertex u∈T.

If u has no incoming edge from another vertex in T, u must has an incoming edge from a vertex in S (if not, u have no incoming edge, which mean u should be in S instead of T, contradiction).Otherwise, let v the vertex with minimum av among all vertices in T with an outgoing edge to u. v has no incoming edge from another vertex in T, so there exist a vertex s∈S that has an outgoing edge to v. Since G is transitive and (v,u),(s,v)∈G, s has an outgoing edge to u. ■

Lemma 2: If at least one vertex in T is on, we can turn all other vertices in T on.

Proof:

Let's X the set of all vertices in T that is currently on, and Y the set of remaining vertices in T (Y=T−X). We will prove that, if X is not empty, we can always turn on a vertex in Y. If this is true, starting from the state where X contain only one vertex (and Y contain the remaining vertices of T), one can repeat turning on a vertex in Y until all vertices in T are on.

To prove it, we need to show that there exist a vertex in S that has an outgoing edge to some vertex in X and some vertex in Y (so we can choose the triple of three mentioned vertices to turn on a vertex in Y). Consider two cases:

Case 1: There exist some edge (v,w) with v∈X and w∈Y.Let s a vertex in S that has an outgoing edge to v. Since G is transitive and (s,v), (v,w) are in G, (s,w) are also in G. In other word, s∈S has an outgoing edge to both v∈X and w∈Y.

Case 2: There is no edge from a vertex in X to a vertex in Y.In this case, if there exist no vertex in S that has an outgoing edge to some vertex in X and some vertex in Y, the component would be divided into two smaller component (one with all vertices in X with their incoming vertices, one with all vertices in Y with their incoming vertices). This contradict the fact that S, X and Y are weakly connected. ■

The lemma above give us the maximum length of sequence B we can construct: |T|−1. Now we need to count the number of such sequence B. Equivalently, for each vertex u∈T, we need to count the number of orders to turn on all other vertices in T (given that u is initially on and all other vertices in T are initially off).

Let s1,s2,…,sp the vertices in S and t1,t2,…,tm the vertices in T. First, how can we know whether we can turn on a vertex in T, without having to consider the states of other vertices in T?

Lemma 3: When perform the above operation, it is sufficient to consider only all triples (u,v,w) such that u∈S and v,w∈T.

Proof:

For a vertex w in T that is off, assume that we can turn on w by choosing a triple (u,v,w) such that u,v∈T. In other to choose the triple, u, v must be on and (u,v),(u,w)∈G. Let s the vertex in S that has an outgoing edge to u (s is always on since s∈S). Since the graph is transitive, s also has outgoing edges to v and w. Therefore, we can turn on w by choosing the triple (s,v,w) instead. ■

With the above lemma, it is sufficient to only consider, for each vertex u∈S, whether there is an on outgoing edge from u. We can use a bitmask of length p to represent this information, with x-th bit equal 1 if sx has an on outgoing edge (and equal 0 otherwise). For each vertex ti∈T, let inMask[i] the bitmask of length p, with x-th bit equal 1 if sx has an outgoing edge to ti in G.

Let dp[mask][k] the number of distinct box piles of length k ROBO can have, with the x-th bit of mask equals 1 if sx has an on outgoing edge to a vertex in T that is turned on. For a vertex tj that is currently off, we can turn on tj if inMask[j]&mask≠0.

There are two cases:

Turn on a currently-off vertex tj in a way that mask is expanded (some bit(s) 0 turn into bit(s) 1). To archive this, we must select tj in such a way that inMask[j] must not be a subset of mask, and we can turn on tj (if a tj satisfy these two conditions, we know for sure that tj is currently off). Therefore, for 1≤j≤m such that inMask[j]⊈mask and inMask[j]&mask≠0, we update the following:dp[mask|inMask[j]][k+1]=dp[mask|inMask[j]][k+1]+dp[mask][k]Turn on a currently-off vertex tj in a way that mask is not expanded. Let cnt(mask) be the number of indices j such that inMask[j]⊆mask. We can turn on one of the cnt(mask)−k vertices that is currently off. Therefore, we update the following:dp[mask][k+1]=dp[mask][k+1]+dp[mask][k]∗(cnt(mask)−k)To solve the general case, we can calculate the number of orders for each weakly connected component separately and then combine the result with some combinatorics formula.

Complexity: O(2r∗n2), with r the maximum number of vertices with no incoming vertices (number of vertices in set S) among all weakly connected component. We will prove that r≤X4 (where X is the constraint of n and ai), therefore the algorithm fit the given time limit.

Proof:

For simplicity, assume that X is divisible by 4. Let's focus only on the weakly connected component C with maximum number of vertices (which will equal r). Let's define S and T in the same manner as the above solution. Notice that, for all x from X2 to X, if x in S, then x is a separate weakly connected component. Therefore, all numbers in S should range from 1 to X2.

On another hand, there should be no number in S that divide another one in S. In other word, consider the divisibility graph of all integer from 1 to X2. Therefore, the size of S cannot exceed the size of the maximum anti-chain (a subset of vertices such that no pair of vertices is connected by an edge) of the graph. The size of the maximum anti-chain of the divisibility graph with vertices from 1 to n is n2 (proof below). Therefore, the size of S cannot exceed X22=X4, or r≤X4. ■Though, for an anti-chain of the divisibility graph with X2 vertices, even if we include all the numbers from X2+1 to X, it may happen that vertices of the anti-chain belong to different weakly connected component. In reality, our brute-force program figure out that in the worst case, r=11 (achieved with a=[2,11,13,…,27,29,30,31,…,59,60]).

We still need to prove that, for even n, the maximum anti-chain of the divisibility graph with vertices from 1 to n is n2.

Proof:

For any number x, let f(x) the number received by continuously divide x by 2. In other word, let k the maximum value of i such that x is divisible by 2i, then f(x)=x2k. Notice that, for two number x and y, if f(x)=f(y) then x divides y or y divides x.

For all x from 1 to n, f(x) has at most n2 different value (all odd number from 1 to n−1). For any subset s of integers from 1 to n, if s has n2+1 elements or more, according to Pigeonhole principle, there are two elements in s that have the same value of f. One of these two numbers will divide the other, so s is not an anti-chain. ■Solution (xuanquang1999, C++)Solution (xuanquang1999, Java 8)Solution (xuanquang1999, PyPy 3)

Codeforces Round #613 (Div. 2) Editorial

By Osama_Alkhodairy, 3 years ago, In English1285A - Mezo Playing ZomaLet cL and cR be the number of 'L's and 'R's in the string respectively. Note that Zoma may end up at any integer point in the interval [−cL,cR]. So, the answer equals cR−(−cL)+1=n+1.

code1285B - Just Eat It!If there is at least a prefix or a suffix with non-positive sum, we can delete that prefix/suffix and end up with an array with sum ≥ the sum of the whole array. So, if that's the case, the answer is "NO".

Otherwise, all the segments that Adel can choose will have sum < than the sum of the whole array because the elements that are not in the segment will always have a strictly positive sum. So, in that case, the answer is "YES".

Time complexity: O(n)code1285C - Fadi and LCMThere will always be a solution where a and b are coprime. To see why, let's prime factorize a and b. If they share a prime factor we can omit all its occurrences from one of them, precisely from the one that has fewer occurrences of that prime, without affecting their LCM. Now, let's prime factorize X. Since there will be at most 11 distinct primes, we can distribute them between a and b with a bruteforce.

For an easier implementation, you can loop over all divisors d of X, check if LCM(d,Xd) equals X, and minimize the answer with the pair (d,Xd).

Time complexity: O(n−−√)codeeasier implementation1285D - Dr. Evil UnderscoresWe will solve this problem recursively starting from the most significant bit. Let's split the elements into two groups, one with the elements which have the current bit on and one with the elements which have the current bit off. If either group is empty, we can assign the current bit of X accordingly so that we have the current bit off in our answer, so we will just proceed to the next bit. Otherwise, both groups aren't empty, so whatever value we assign to the current bit of X, we will have this bit on in our answer. Now, to decide which value to assign to the current bit of X, we will solve the same problem recursively for each of the groups for the next bit; let anson and ansoff be the answers of the recursive calls for the on and the off groups respectively. Note that if we assign 1 to the current bit of X, the answer will be 2i+ansoff, and if we assign 0 to the current bit of X, the answer will be 2i+anson, where i is the current bit. So, simply we will choose the minimum of these two cases for our answer to be 2i+min(anson,ansoff).

Time complexity: O(nlog(maxai))code1285E - Delete a SegmentOk, looking for a new number of segments in a union is actually hard. Let nwi be the union of segments after erasing the i-th one. Obviously, each of the segments in nw[i] has its left and right borders. Let me show you how to calculate the number of any of these two kinds. Let's choose left borders. I will call the set of left borders of the set s of segments lfs.

Build the initial union of all segments (that is a standart algorithm, google it if you want). Call it init. We are asked to find maxi|nw[i]|, but let's instead find maxi|nw[i]|−|init| (that is the difference of sizes of the initial union and the new one for i). Surely, adding |init| to this value will be the answer. Moreover, maxi|nw[i]|−|init|=maxi|lfnw[i]|−|lfinit| and that's what we are going to calculate. Call that difference diffi.

Let's do the following sweep line. Add queries of form (li,i,1) and (ri,i,−1). Process them in sorted order. Maintain the set of the open segments. This sweepline will add segment i on a query of the first type and remove segment i on a query of the second type. Initialize all the diffi with zeroes, this sweepline will help us to calculate all the values altogether.

Look at the all updates on the same coordinate x. The only case we care about is: the current set of open segments contain exactly one segment and there is at least one adding update. Let this currently open segment be j. Consider what happens with nw[j]. x is not in the lfinit because at least that segment j covers it. x is also in lfnf[j] because after erasing segment j x becomes a left border of some segment of the union (you are adding a segment with the left border x and points slightly to the left of x are no longer covered by segment j). Thus, diffj increases by 1.

The other possible cases are:

there are no open segments currently — this is not important because x was a left border and stays as a left border;there are more than two open segments — not important because x will still be covered by at least one of them after erasing some other;there are no adding updates — x was a left border but doesn't become a new one.Thus, we handled all the left border count increasing cases. But there are also a decreasing case. Left border can get removed if the segment you are erasing had its left border in the initial union and was the only segment with such left border. You can get lfinit while getting init. Then for each of lfinit you can count how many segments start in it. Finally, iterate over i and decrease diffi by one if the value for the left border of the segment i is exactly 1.

Finally, diffi is obtained, (maxidiffi)+|init| is the answer.

Overall complexity: O(nlogn).

Author: MikeMirzayanov

code (pikmike)1285F - Classical?Since LCM(x,y)=x∗yGCD(x,y), it makes sense to try and fix GCD(x,y). Let's call it g. Now, let's only care about the multiples of g in the input. Assume we divide them all by g. We now want the maximum product of 2 coprime numbers in this new array.

Let's sort the numbers and iterate from the biggest to the smallest, keeping a stack. Assume the current number you're iterating on is x. While there is a number in the stack coprime to x, you can actually pop the top of the stack; you'll never need it again. That's because this number together with a number smaller than x can never give a better product than that of a greater, or equal, number together with x! Now, we just need to figure out whether there's a number coprime to x in the stack. This could be easily done with inclusion-exclusion. Assume the number of multiples of d in the stack is cntd; the number of elements in the stack coprime to x is:∑d|xμ(d)∗cntdWhere μ is the Mobius function. So we'll just iterate on the integers from greatest to smallest, and while there's a number coprime to x in the stack, we'll keep maximizing the answer, popping, and updating the array cnt. Then, we'll push x to the stack and also update cnt.

The complexity is O(∑i=1nσ0(i)2) where σ0 is the divisor count function. That's because each number enters the routine of calculating the maximum product of a coprime pair σ0 times, and we iterate through its divisors in this routine.

code (mohammedehab2002)

Codeforces Round #612 — Editorial

By 300iq, 3 years ago, In English1287A - Angry StudentsWe will take a look at two different solutions.

First has complexity O(∑i=0t−1ki2). In this solution, we will simulate the events described in the statement. We will simulate every minute. Note that every minute (until we have found the answer) number of angry students will increase by at least 1, but it is bounded by k, so we don't need to simulate more than k+1 minutes.

Assume that ai describe students' states after i minutes. Then a0[j]=1 if initially j-th student is angry. And ai[j]=max(ai−1[j],ai−1[j−1]).

Second solution has complexity O(∑i=0t−1ki). Note that every angry student will make angry every student between him and the next (closest to the right) angry student. Students will become angry one by one. So for every angry student, we should update the answer by number of patient students till the nearest angry student to the right (or till the end of row.).

1287B - HypersetFirstly, we can notice that two cards uniquely identify the third, which forms a set with them. If the i-th feature of two cards is the same, then in the third card also has the same, otherwise, it has a different feature. Thus, we can check all pairs of cards, find their third one, which forms a set with them, and find out if it exists.

Time complexity: O(kn2 logn).

1286A - GarlandThe problem can be solved using a greedy algorithm. Notice that the only information we need is parity of numbers on bulbs. So let's replace numbers by their remainders modulo 2. Than complexity of garland will be the number of pairs of adjacent numbers that are different. Let's call such pairs as bad.

Divide garland into segments of removed bulbs. Let's call number before segment as left border and number after segment as right border. If there's no number before/after the segment than the segment doesn't have left/right border.

Notice that when filling a segment, one should place the same numbers in a row (if any). If the segment has different borders then the optimal way is to place all zeroes near zero-border and all ones near one-border. If the segment has the same borders and we place both numbers in the segment that there will be at least two bad pairs and we will achieve it by placing all zeroes and then all ones. Similarly one could prove cases with the absence of one or two borders.

If the segment has both borders and they are different then this segment always will increase the complexity by 1. If the segment has both borders and they are different then this segment will increase the complexity by 0 or 2. 0 will be in case we fill segment by numbers of the same parity as its borders. Otherwise, it will be 2.

If the segment doesn't have at least one of borders, it will increase the complexity by 0 if all numbers have the same parity as its border (if any) and 1 otherwise.

So in order to minimize the complexity of garland, first of all, we should fill segments with the same borders by the numbers of the same parity. Obviously we should consider such segments in increasing length order.

Then we should fill segments with only one border such that complexity won't increase.

After that, we can place the remaining numbers arbitrary (but inside one segment we should place the same numbers in a row). Because for all remaining segments number of bad pairs is fixed.

Time complexity is O(nlogn).

Also, this problem could be solved using dynamic programming.

1286B - Numbers on TreeThere are several approaches to this problem. We will tell one of them. Note that if ci for some vertex is greater than the number of vertices in its subtree, then there is no answer.

Now we prove that we can always build the answer, so that all ai will be numbers from 1 to n. On those numbers, let's build some structure that supports deleting elements and searching for k-th element. Let's denote by dv the number of vertices in the subtree of vertex v. Now iterate over the subtree of v in the order of the depth first search. Then let's set av = cv-th element in our structure (and after that delete this element). Firstly, such an element will always exist. This is true because when we examine the vertex v, all vertices in the subtree of this vertex are not yet considered  Rightarrow since cv leqdv  Rightarrow in our structure there are at least cv elements. Secondly, the set of all values in the subtree will be a prefix of our structure. If this is true, then the condition that the subtree contains exactly cv elements smaller than ours is guaranteed to be satisfied (because all elements from our structure that are smaller than ours are there, and we specifically took the cv-th element). Let us prove this fact by induction on the size of the tree. For a tree of size 1 this is obvious (we always take the first element). Now for size k, we have the root on which the number cx leqk−1 is written. Then when we throw out cx, and then throw out all the vertices in the subtree, we will remove the prefix of at least k−1 vertices, which means that we will drop all the vertices up to cx, as well as some prefix of vertices after it, thus in total we'll throw out some prefix of vertices.

Now, we have reduced the problem to dfs and searching for k-order statistics. This can be done in a variety of ways - segment tree, Fenwick tree, sqrt decomposition, Cartesian tree, or a built-in c++ tree.

Code of the author solution with this tree.

1286C2 - Madhouse (Hard version)Let's consider the solution that uses 2 queries with the lengths n and n−1 (it asks about too many substrings, so it will not pass all the tests, but it will help us further). Let's ask about substrings [1..n] and [1..n−1]. For convenience, rearrange the letters in all strings in alphabetical order. Then note that all the suffixes of S correspond to those strings that we get in the first case, and do not get in the second. Having found all such strings, we can easily find all suffixes of S by looking at them from smaller ones to bigger.

For a complete solution we should first find the first n/2 characters of the string by the solution described above. Then ask about the whole string. Let cnti,x be the number of times that the symbol x occurs in total in all substrings of length i in the last query. Note that the symbol at position j is counted in cnti,x exactly min(i,j,n−j+1) times. Then for all i from 1 to n/2, the value cnti+1,x - cnti,x is equal to the number of times that x occurs on positions with indices from i+1 to n−i. Knowing these quantities, it is possible to find out how many times the element x occurs on positions i and n−i+1 in sum for each i from 1 to n/2. Since we already know the first half of the string, it is not difficult to restore the character at the position n−i+1, and therefore the entire string.

In total, we asked about the substrings [1..n/2], [1..n/2−1] and [1..n], the total number of substrings received is ≈(n+12)22+(n+12)22+(n+1)22=0.75(n+1)2, and that quite satisfies the limitations of the problem.

1286D - LCCNote, that the first collision will occur between two neighboring particles in the original array. These two particles have 3 options to collide: both particles move to the right, both move to the left, they move towards each other. Let's go through these options and calculate the time of the collision. Let's do this for each pair of neighboring vertices and sort them by the collision time. Then the probability that ith will occur first is equal to the probability that the first (i−1) collisions will not occur minus the probability that the first i will not occur. To find these probabilities we can use the Segment Tree. In each of its vertices, we will maintain an answer for four masks on which way the first and the last particle of the segment are moving. The answer for the mask is the probability that none of the first X collisions will not occur, and the extreme ones move in accordance with the mask. Then to add a ban for the (i+1)th collision, it is enough to make an update at the point. The final asymptotic is O(n⋅24⋅log(n))1286E - Fedya the Potter Strikes BackLet ansi be the answer for the moment after i queries. Then, si=ansi−ansi−1 is equal to the sum of suspiciousness of suffixes of the string after i queries. If we calculate si, ans will be the prefix sums of this array.

Let's maintain the KMP tree of the string. Each vertex of the tree corresponds to a prefix of the string. Let S be the subset of suffixes, which are equal to the corresponding prefixes. We can note that S is exactly the path from the root to the current vertex in the tree.

Let sv be the next character of vertex of KMP, which corresponds to the prefix with length v (the string is indexed from 0). Let's find out what happens after adding a new character to the end of the string. Some suffixes from S can't be extended with this character (keeping the condition about equality to the prefix), so they will be removed from the set. Also, if the new character is equal to s0, a suffix with length 1 will be added to the set. These are the only modifications that will be applied to S.

We want to find all elements of S, which will be removed after a certain query. Let's denote the number of these elements by r. If we find them in O(r), the amortized time will be O(n). A suffix can't be extended if and only if the next character of its vertex is not equal to the new character. We need to find all these vertexes on the way up from the last vertex. Let linkv be the closest ancestor of v with the different next character (we can calculate it for each vertex when it is added). Let's ascend from vertex v. If we are in a vertex with the same next character as in the vertex v, then we will go to the linkv, otherwise, we will handle this vertex as a removing suffix and go to the parent vertex. It's clear that it works in O(r).

Now our task is just adding a suffix with length 1, removing suffixes and adding an element to all suffixes. We can create a segment tree for minimum on w in order to get the minimum on the removing segment. Let's maintain a mulitset of minimums on current suffixes. So, our queries are:

Add element xRemove element xFor each element a make a=min(a,x)Get the sum of the elementsLet's store a map from an element to the number of its occurrences. Queries 1 and 2 can be done obviously. To perform the 3-rd query, we can just iterate through elements, which are bigger than x, remove them from the map, and add as many elements with value x. The amortized complexity of this solution is O(nlogn).

BONUS: solve it when a suspiciousness of a "suspicious" segment is the mex of elements instead of min.

Code (with BigInt realization)

1286F - Гарри ГончарAssume that we have done m queries of the second type. On the ith query we subtracted xi from api and xi+1 from aqi. Let's construct undirected graph on n vertices with edges (pi,qi). Assume we have a cycle c1,c2,...,ck in this graph, then, we can replace queries along this cycle with single queries of the first type to each vertex. Therefore, in an optimal answer queries of the second type form a forest.

Let's call subset good if it size is k and it can be destroyed with k−1 operations of the second type. So, the problem is equivalent to grouping some of the elements of ai into maximal number of disjoint good subsets. Elements that do not belong to any set can be destroyed with operations of the first type.

Let's find out whether a subset S is good or not. Let's forget about + 1 in a query(e.g. we subtract x and x). Consider a sequence of m queries pi, qi, xi that destroys S and (pi,qi) form a connected tree. Let's select an arbitrary vertex of this tree as a root. Then, it is easy to see that for each vertex only its height modulo 2 is matter. Therefore, we can consider only trees of the following structure:

The elements with the even height contribute positive change to the root, the elements with the odd height contribute negative change to the root. So, our problem is equivalent to finding the set T⊂S such that sum(S∖T)−sum(T)=0 and T≠∅,T≠S.

Now we subtract x and x+1. It turns out that it changes the above condition to sum(S∖T)−sum(T)∈{−|S|,−|S|+2,...,|S|−2,|S|} and T≠∅,T≠S.

Such set T can be found with MITM in O((1+2–√)n) time (knapsack in 2n/2 over all subsets).

So, now we know all good subsets. Let Amask=1 if mask is a good subset and 0 otherwise. Let's denote A∗B operation as OR convolution on independent subsets. Suppose p is a minimum integer such that A∗A∗...∗Ap times=0(e.g. all values of the product array are zero). It is clear that n−p is a minimal number of operations required to destroy the array. OR convolution on independent subsets can be done in O(n2⋅2n) time and the minimal power can be estimated in O(logn) time. Also, this part can be done with dynamic programming on subsets in O(3n) time which some participants managed to squeeze.

So, the total time complexity is O((1+2–√)n+logn⋅n2⋅2n).

Codeforces Round #611 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishAll problems were proposed by Mikhail MikeMirzayanov Mirzayanov.

1283A - Minutes Before the New Year

Tutorial1283A - Minutes Before the New YearIn this problem we just need to print 1440−60h−m.

Solution1283B - Candies Division

Tutorial1283B - Candies DivisionFirstly, we can notice that we always can distribute n−n%k (where % is the modulo operation) candies between kids. In this case a=⌊nk⌋ and the answer is at least ak. And then we can add the value min(n%k,⌊k2⌋) to the answer. Why? Because there is only n%k candies remain and the maximum number of kids to whom we can give one more candy is ⌊k2⌋.

Solution1283C - Friends and Gifts

Tutorial1283C - Friends and GiftsIn this problem, we need to print the permutation without fixed points (without values pi=i) but some values are known in advance. Let's consider the permutation as a graph. We know that the permutation is the set of non-intersecting cycles. In this problem, we are given such a graph but some edges are removed. How to deal with it?

Firstly, let's find isolated vertices in the graph. Let its number be cnt. If cnt=0 then all is ok and we skip the current step. If cnt=1 then let's pin this isolated vertex to any vertex to which we can pin it. Otherwise, cnt>1 and we can create the chine consisting of all isolated vertices.

Now cnt=0 and we can finally construct the remaining part of the graph. We can notice that we have the same number of vertices with zero incoming and zero outcoming degrees. And because we got rid of all possible loops in the graph, we can match these vertices as we want.

Time complexity: O(n).

Solution1283D - Christmas Trees

Tutorial1283D - Christmas TreesIn this problem, we first need to consider all points adjacent to at least one Christmas tree, then all points at the distance two from the nearby Christmas tree and so on... What it looks like? Yes, well-known multi-source bfs.

Let's maintain a queue of positions and the set of used positions (and the distance to each vertex, of course). In the first step, we add all positions of the Christmas tree with a zero distance as initial vertices. Let the current vertex is v. If dv=0 (this is the Christmas tree) then just add v−1 and v+1 to the queue (if these vertices aren't added already) and continue. Otherwise, increase the answer by dv and add v to the array of positions of people. When the length of this array reaches m, interrupt bfs and print the answer.

Don't forget about some special cases as using Arrays.sort in Java or using std::unordered_map in C++ because this can lead to the quadratic complexity.

Time complexity: O(nlogn).

Solution1283E - New Year Parties

Tutorial1283E - New Year PartiesAt first treat the two subtasks as completely independent problems.

For both solutions the array of frequences is more convinient to use, so let's build it (cnti is the number of friends living in house i).

1) Minimum

Collect the answer greedily from left to right. If cnti=0 then proceed to i+1, otherwise add 1 to the answer and proceed to i+3.

To prove that let's maximize the number of merges of houses instead of minimizing the actual count of them. It's easy to show that the final number of houses is the initial one minus the number of merges.

So if there are people in all 3 consecutive houses starting from i, then 2 merges is the absolute best you can do with them, skipping any of the merges won't get the better answer. For only 2 of them occupied 1 merge is the best and we can achieve that 1 merge. And a single occupied house obviously will do 0 merges.

2) Maximum

Also greedy but let's process the houses in segments of consecutive positions with positive cnt. Take a look at the sum of some segment of houses. If the sum is greater than the length then you can enlarge that segment 1 house to the left or to the right. If the sum is greater by at least 2, than you can enlarge it both directions at the same time.

Thus the following greedy will work. Let's update the segments from left to right. For each segments check the distance to the previous one (if it was enlarged to the right then consider the new right border). If you can enlarge the current segment and there is space on the left, then enlarge it. And if you still have possibility to enlarge the segment then enlarge it to the right.

Notice that it doesn't matter which of any pair of consecutive segments will take the spot between them as the answer changes the same.

The initial segments can be obtained with two pointers.

Overall complexity: O(n).

Solution1283F - DIY Garland

Tutorial1283F - DIY GarlandFirst of all, we don't like the fact that importance values can be integers up to 2n (it is kinda hard to work with them). Let's rephrase the problem.

The highest bit set to 1 in the importance value denotes the maximum in the subtree rooted at the auxiliary lamp for the wire. So, we sort the wires according to the maximums in their subtrees. To break ties, we could consider the second maximum, then the third maximum — but that's not convenient. We can use something much easier: suppose there are two vertices with the same maximum in their subtrees; these vertices belong to the path from the root to the maximum in their subtrees, and the one which is closer to the root has the greater importance value. So, to get the order described in the problem statement, we could sort the vertices according to the maximum in their subtrees, and use depth as the tie-breaker.

What does this imply? All vertices of some prefix are ancestors of vertex n, so some prefix denotes the path from the root to n (excluding n itself). Then there are some values describing the path from some already visited vertex to n−1 (if n−1 was not met before), then to n−2, and so on.

How can we use this information to restore the original tree? a1 is the root, obviously. Then the sequence can be separated into several subsegments, each representing a vertical path in the tree (and each vertex is the parent of the next vertex in the sequence, if they belong to the same subsegment). How can we separate these vertices into subsegments, and how to find the parents for vertices which did not appear in the sequence at all? Suppose some vertex appears several times in our sequence. The first time it appeared in the sequence, it was in the middle of some vertical path, so the previous vertex is its parent; and every time this vertex appears again, it means that we start a new path — and that's how decomposition into paths is done.

Determining the parents of vertices that did not appear in the sequence is a bit harder, but can also be done. Let's recall that our sequence is decomposed into paths from root to n, from some visited vertex to n−1, from some visited vertex to n−2, and so on; so, each time the path changes, it means that we have found the maximum vertex (among unvisited ones). So we should keep track of the maximum vertex that was not introduced in the sequence while we split it into paths, and each time a path breaks, it means that we found the vertex we were keeping track of.

Overall, this solution can be implemented in O(n).

Solution

Codeforces Round #610 (Div. 2) Editorial

By Stepavly, history, 3 years ago, translation, In English1282A - Temporarily unavailable

Idea: MikeMirzayanov Preparation: MikeMirzayanov

Editorial1282A - Temporarily unavailableTo get an answer, we need to subtract from the whole time the time that we will be in the coverage area. Let the left boundary of the cover be L=c−r, and the right boundary of the cover be R=c+r. Then the intersection boundaries will be st=max(L,min(a,b)), ed=min(R,max(a,b)). Then the answer is calculated by the formula |b−a|−max(0,ed−st).

Solution (MikeMirzayanov)1282B1 - K for the Price of One (Easy Version), 1282B2 - K for the Price of One (Hard Version)

Idea: MikeMirzayanov, unreal.eugene Preparation: Supermagzzz

Editorial1282B2 - K for the Price of One (Hard Version)If you sort the array by costs, it will always be profitable to take segments of length k with the cheapest possible end. It remains only to understand when you need to take gifts without a promotion.

It makes no sense to take k or more gifts without a promotion, so we can combine them and buy together. It also makes no sense to take not the cheapest gifts without a stock, since the total cost from this will only increase.

So the solution to the problem is to iterate over the prefix in a sorted array of length no more than k, and then buy items together for k pieces. This solution works in the linear time since we will always look at elements with a different index by modulo k.

Solution (Supermagzzz)1282C - Petya and Exam

Idea: AdvancerMan Preparation: Supermagzzz

Editorial1282C - Petya and ExamSort all problems by time ti. You may notice that it is profitably to leave the exam at only one of the time points ti−1. ti — a time when the task with the number i becomes mandatory. Leaving at any other time in the range from ti−1 to ti−2 does not make sense since new mandatory tasks cannot appear at this time, and there is always less time to solve than at the moment ti−1.

Then for each such moment, we need to know how many simple and hard tasks have already become mandatory. Then we know the time that we need to spend on solving them. The remaining time can be spent on other tasks. It is more profitable to solve simple at first, and then hard. It remains only to consider all such moments and take the maximum of the tasks solved among them, which will be the answer.

Solution (Supermagzzz)1282D - Enchanted Artifact

Idea: unreal.eugene Preparation: unreal.eugene

Editorial1282D - Enchanted ArtifactFirstly, let's find out the number of letters a and b in the hidden string in two queries. This can be done, for example, using queries aaa ... aaa and bbb ... bbb of length 300. Let the answers to these queries be qa and qb, then the number of letters a and b would be #a=300−qa and #b=300−qb respectively. These answers are explained by the fact that i. e. for string aaa ... aaa it takes 300−#a−#b steps to remove the letters a at the end of the string and then replace #b letters a with b to change the string aaa ... aaa into the string s.

Now we know the length l=#a+#b. Consider an arbitrary string t of length l and let the answer to its query be q. Then if we replace the letter ti with the opposite one (from a to b or from b to a), then we may have one of two situations:

    q decreased by 1, then the letter ti after the change coincides with the letter si.     otherwise the letter ti before the change matches the letter si.Thus, you can loop from left to right and for each position i find out the character ti, starting, for example, from the string aaa ... aaa of length l.

The current algorithm guesses the string in n+3 queries. In order to get rid of one unnecessary query, note that we do not need to make a query to find out the character in the last position. If the number of letters a whose location we know is equal to #a, then the last character cannot be a, which means it is b. Similarly for the symmetric case.

Thus, we can guess the string in n+2 queries.

Similarly, it is possible to solve for an arbitrary alphabet in (|Σ|−1)n+2 queries, where |Σ| is the size of the alphabet. For an arbitrary alphabet, there is also a solution using random which solves the problem on average in |Σ|2n+2 queries, but it will not work in this task, since the chance to spend more than n+2 queries is quite large.

Solution (Darui99)1282E - The Cake Is a Lie

Idea: MikeMirzayanov, AdvancerMan Preparation: AdvancerMan

Editorial1282E - The Cake Is a LieThe problem can be solved in different ways: one can independently find both permutations, or use one to find another.

Firstly, let's find q — the order of cutting cake pieces. Let's take a look at the edges of the first piece. This triangle has a common side with no more than one other piece. If it has no common sides with other triangles — there is only one triangle, the answer is trivial. So we consider that the first triangle is adjacent to exactly one other triangle. After cutting off this triangle, we have a similar problem for a (n−1)-sided cake. Let the first triangle be any triangle adjacent only to 1 another triangle, cut it off, solve the problem recursively. This can be done by building for the polygon dual graph.

The remaining problem is to find the permutation p:

Let's use q to find p. Reverse q to get the order of adding triangles to obtain the desired polygon. This can be done by adding to the doubly-linked list a triangle vertex, that wasn't in the list before, between two existing ones.Let's note that each side of the cake is found exactly once in the input, the other edges are found twice. So we have to find these sides of the polygon, then we get a doubly-linked list, which represents p.Solution (AdvancerMan)

Codeforces Round #609 — Editorial

By 300iq, 3 years ago, In English1269A - УравнениеPrint 9n and 8n.

1269B - Равенство по модулюThere exists some i, such that (ai+x)modm=b1. Let's enumerate it, then x is (b1−ai)modm. Like that you can get O(n) candidates, each of them can be checked in O(nlogn) with sort or in O(n) if you will note that the order is just cyclically shifting.

Also, this problem can be solved in O(n) with some string matching algorithms, I will leave it as a bonus.

1269C - Длинное красивое числоAt first, let's set ai=ai−k for all i>k.

If it is at least the initial a, then you can print it as the answer.

Otherwise, Let's find the last non-nine digit among the first k, increase it by one, and change all 9's on the segment from it to k-th character to 0.

After that, again set ai=ai−k for all i>k.

Then, you can print it as the answer.

1269D - Домино для молодыхLet's color diagram into two colors as a chessboard.

I claim that the Young diagram can be partitioned into domino if and only if the number of white cells inside it is equal to the number of black cells inside it.

If the Young diagram has two equal rows (or columns) you can delete one domino, and the diagram will still have an equal number of white and black cells.

If all rows and columns are different, it means that the Young diagram is a "basic" diagram, i.e have lengths of columns 1,2,…,n.

But in a "basic" diagram the number of white and black cells is different! So, we have a contradiction!

But what if the number of black and white cells are not the same?

I claim that the answer is min( the number of white cells, the number of black cells ).

Just because if you have more white cells (case with more black case is symmetrical), and there are no equal rows and columns, you can take the first column with more white cells than black cells and delete the last cell of this column, in the end, you will have a Young diagram with an equal number of black and white cells, so you can find the answer by algorithm described below.

1269E - K целых чиселAt first, let's add to the answer number of inversions among numbers 1,2,…,k.

After that, let's say that x≤k is one, and x>k is zero.

Then you need to calculate the smallest number of swaps to make segment 1,1,…,1 of length k appear in the permutation.

For this, let's call pi the number of ones on the prefix.

For all si=0 we need to add min(pi,k−pi) to the answer (it is an obvious lower bound, and it is simple to prove that we always can do one operation to reduce this total value by one).

How to calculate this for each k?

Let's move k from 1 to n. You can maintain number of inversions with BIT. To calculate the second value, you can note that you just need to find k2-th number ≤k and add values at the left and add the right with different coefficients. To maintain them, you can recalculate everything when you are moving the median (in heap). But also it is possible to maintain the segment tree by pi and just take some sum.

1268D - Инвертирования в турниреLemma: for n>6 it is always possible to invert one vertex.

Start by proving that for n≥4 in the strongly connected tournament it is possible to invert one vertex so it will remain strongly connected, it is possible by induction.If there is a big SCC (with at least four vertices), invert good vertex in it.If there are at least three strongly connected components, invert random vertex in the middle one.If there are two SCCs, then all of them have size ≤3, so the number of vertices is ≤6.So you can check each vertex in O(n232) with bitset. But also it is possible to check that tournament is strongly connected by degree sequence in O(n). For this, you can note that the degree of each vertex in the rightest SCC is smaller than degrees of all other vertices. So in the sorted by degree order you can check for the prefix of length k, that the number of edges outgoing from them (sum of degrees) is k(k−1)2+k(n−k) if there exists k<n which satisfy this constraint, then it is simple to prove that the graph is not strongly connected.

So, you can solve this problem in O(n2) or in O(n332).

1268E - Счастливый кактусAt first, let's solve for the tree. Let dpv be the number of answer for vertex v.

Let's look at edges in the order of decreasing weight.

How dp is changing when you are looking at edge i?

I claim that dp′v=dpv for v≠aiand v≠bi.

And dp′ai=dp′bi=dpai+dpbi.

Why? I like this thinking about this problem: in each vertex sitting a rat, initially i-th rat is infected by i-th type of infection. After that, rats am and bm, am−1 and bm−1, ..., a1 and b1 bite each other. When two rats bite each other, they have a union of their infections.

I claim that the number of infections of i-th vertex, in the end, is equal to the required value.

So on the tree, it is easy to see that the infections are not intersecting when two rats bite each other, so they just change the number to sum.

But on the cactus, they may have some non-empty intersection.

Now, it is easy to see that:

Let's say that fi is equal to the number of infections of ai (same as the number of infections of bi) after the moment when you meet this edge.Similar to the tree case, when i-th edge connects different connected components, fi is just equal to the sum of the number of infections.When i-th edge connects same connected components, fi is equal to the sum of the number of infections (let's call this value x). Or fi is equal to x−fe where e is some edge on the path between ai and bi (note that it is a cactus, so this path is unique).This e is always the largest edge on the path, and it is subtracted if and only if the path from it to ai and from it to bi is decreasing.So, we can solve the problem in O(n+m).

Codeforces Round 608 — Editorial

By BledDest, history, 3 years ago, translation, In English1271A - SuitsThere are two ways to approach this problem. The first way is to iterate on the number of suits of one type that we will compose and calculate the number of suits of the second type we can compose from the remaining items.

The second way is to use the fact that if e>f, then we have to make as many suits of the first type as possible (and the opposite is true if f>e). So we firstly make the maximum possible number of more expensive suits, and use the remaining items to compose cheaper suits.

1271B - BlocksSuppose we want to make all blocks white (if we want to make them black, the following algorithm still works with a few changes).

The first block has to be white, so if it is black, we have to invert the pair (1,2) once, otherwise we should not invert it at all (inverting twice is the same as not inverting at all).

Then consider the second block. We need to invert it once if it is black — but if we invert the pair (1,2), then the first block becomes black. So we can't invert the pair (1,2), and we have to invert the pair (2,3) (or don't invert anything if the second block is white now).

And so on: for the i-th block, we cannot invert the pair (i−1,i), since it will affect the color of the previous block. So we don't have much choice in our algorithm.

After that, we arrive at the last block. If it is white, we are done with no more than n−1 actions. If it is black, run the same algorithm, but we have to paint everything black now. If it fails again, then there is no answer.

1271C - Shawarma TentSuppose that the point (tx,ty) is the answer. If the distance between this point t and the school is greater than 1, then there exists at least one point (Tx,Ty) such that:

the distance between T and the school is exactly 1;T lies on the shortest path between the school and t.Now we claim that the T can also be the optimal answer. That's because, if there exists a shortest path from the school to some point i going through t, the shortest path from s to t going through T can be extended to become the shortest path to i.

So we only need to check four points adjacent to the school as possible answers. To check whether a point (ax,ay) lies on the shortest path from (bx,by) to (cx,cy), we need to verify that min(bx,cx)≤ax≤max(bx,cx) and min(by,cy)≤ay≤max(by,cy).

1271D - PortalsNote, that for every castle i there is some list of castles x, such that you can defend castle i standing in the castle x.

The key observation is that it's always optimal to defend castle i (assuming we decided to defend it) in the latest possible castle. Since it gives you more warriors in between of i and x (more freedom), it's always optimal.

We will prune all other x's except for the maximum one.

Now our process looks like:

Conquer next castle,Acquire new warriors,Decide whether or not you you defend previous castle i, such that the current castle is x in terms of the paragraph above. There might be several such i to process for the current castle.Since in this process we decide on each castle exactly only once, the process can be simulated as a simple dynamic programming with states "number of castles conquered, number of warriors available", it's possible to compute this dp in O(n⋅C), where C is the total number of warriors.

Or you can use a greedy approach in O(nlog(n)). Just maintain the process above, defending all the castles you can defend. In case it turns out you are lacking few warriors later, just undo several defended castes. To do so, just maintain undoable castles in a Heap or std::set.

1271E - Common NumberLet's introduce a function count(x) — the number of y∈[1,n] such that x∈path(y). The problem is now to find the greatest number x such that count(x)≥k.

How can we calculate count(x)? First, let's consider the case when x is odd. x is contained in path(x); then x is contained in path(2x) (since 2x2=x) and in path(2x+1) (since 2x+1 is odd, f(2x+1)=2x). The next numbers containing x in their paths are 4x, 4x+1, 4x+2 and 4x+3, then 8x, 8x+1, ..., 8x+7, and so on. By processing each segment of numbers containing x in their paths in O(1), we can calculate count(x) for odd x in O(logn).

What about even x? The first numbers containing x in their paths are x and x+1, then 2x, 2x+1, 2x+2 and 2x+3, then 4x, 4x+1, ..., 4x+7, and so on. So the case with even x can also be solved in O(logn).

We can also see that count(x)≥count(x+2) simply because for each number containing x+2 in its path, there is another number that is less than it which contains x in its path. And this fact means that if we want to find the greatest x such that count(x)≥k, we only have to run two binary searches: one binary search over odd numbers, and another binary search over even numbers.

1271F - Divide The StudentsSuppose we have only students of types 1, 4, 6 and 7 (all students attend either all subjects or only one subject). We can divide these students into two subgroups in O(1): the first subgroup can accomodate no more than min(a1,b1,c1) students of the first type; the second subgroup can accomodate no more than min(a2,b2,c2) students of the first type; it does not matter how we distribute them into groups, as long as their number does not exceed the limits. After that, it's easy to distribute three other types.

Okay, we can solve the problem with four types in O(1). How to solve the problem with seven types in O(M3)? Let's iterate on f2, f3 and f5, and check whether we can distribute the remaining types! Though it may seem slow, we will do only 109 iterations, and the time limit is generous enough (model solution works in 1.8 seconds without any cutoffs).

Challenge: solve it in quadratic time.

Codeforces Round #607 Editorial

By kevinsogo, history, 3 years ago, In EnglishI hope you enjoyed the problems! Thanks to the onsite teams and coaches who gave feedback; I'm glad the reception was positive.

Interestingly, in the onsite ICPC round, while "Kirchhoff" got several accepted solutions, "Miss Punyverse" got no accepted submissions at all! It is the reverse here. (Kirchhoff even has a trickier output format in the onsite round compared to the version presented in Codeforces.) It seems the ICPC scoreboard really affects the results greatly; what the top few teams are working on influences what everyone else will be working on.

I am planning on releasing the full, untouched ICPC Manila 2019 problem set in the gym sometime in the future, so you can see which problems you missed. The Intergalactic Sliding Puzzle is not the hardest problem in the round!

1281A - Suffix Three

Solution Sketch1281A - Suffix ThreeThe simplest way to solve it is to use your language's builtin string methods like ends_with. (It might be different in your preferred language.) Alternatively, if you know how to access the individual letters of a string, then you may implement something similar to ends_with yourself.

To print the required output, you can just use something like:

if s.endswith("po"):    print("FILIPINO")

if s.endswith("desu") or s.endswith("masu"):    print("JAPANESE")

if s.endswith("mnida"):    print("KOREAN")Alternatively, notice that you can simply check the last letter since o, u and a are distinct, so it can be simplified slightly. One can even write a Python one-liner (for a single test case):

print({"o": "FILIPINO", "a": "KOREAN", "u": "JAPANESE"}[input()[-1]])Accepted CodeAccepted Submission: 67015948

1281B - Azamon Web Services

Solution Sketch1281B - Azamon Web ServicesThe problem becomes a bit easier if we try to answer a different question: What is the lexicographically smallest string we can form from S? We then simply compare this string with C. This works because if the smallest string we can form is not smaller than C, then clearly no other string we can form will be smaller than C.

To find the lexicographically smallest string we can form, we can be greedy. We sort S and find the first letter that isn't in its correct sorted position. In other words, find the first position where S and sorted(S) doesn't match. We then find the letter that should be in that position and put it in its correct position. If there are multiple choices, it is better to take the one that occurs last, since it makes the resulting string smallest.

A special case is when S is already sorted. In this case, we can't make S any smaller, so we should not swap at all.

The solution runs in O(|S|log|S|), but solutions running in O(|S|2) are also accepted. (There are other, different solutions that run in O(|S|2).) This can be improved to O(|S|) by replacing the sorting step with simpler operations, since we don't actually need the full sorted version of S.

Accepted CodeAccepted Submission: 67049609

1281C - Cut and Paste

Solution Sketch1281C - Cut and PasteLet St be the string S after the tth round, and let S0 be the initial S. We also denote by Si… the suffix of S from the ith character, Si, onwards.

A single round turns St−1 into St by replicating the suffix St−1t+1… exactly St times. Hence, we have the recurrenceSt=St−1+St−1t+1…⋅(St−1t−1),where + represents concatenation, and s⋅n represents replicating s n times. (Note that St−1t is interpreted as an integer.)

In terms of lengths, we have∣∣St∣∣=∣∣St−1∣∣+∣∣St−1t+1…∣∣⋅(St−1t−1).Since |Si+1…|=|S|−i, this is equivalent to∣∣St∣∣=∣∣St−1∣∣+(∣∣St−1∣∣−t)⋅(St−1t−1).This cannot be simulated yet as it is since the length of S could be growing very quickly. But notice that St−1 is always a prefix of St. Therefore, for any two t1 and t2, the ith letters of St1 and St2 are the same (as long as their lengths are at least i). Also, note that we only need to access up to the xth character, Sx. Therefore, we only need to grow S just enough until it contains at least x characters. After that, we can stop modifying S at that point and simply keep track of the length, maintaining it using the recurrence above.

The running time is O(|S|+x). (But in languages where strings are immutable, you should use a dynamically-resizing list instead of appending strings repeatedly, otherwise, you'll get a running time of O(x2).)

Accepted CodeAccepted Submission: 67016113

1281D - Beingawesomeism

Solution Sketch1281D - BeingawesomeismIf everything is P, then it is clearly impossible (MORTAL). Otherwise, you can turn everything into A in at most 4 moves, starting from any single A. Thus, the answer is between 0 and 4. We can exhaust all possibilities:

The answer is 0 if:Everything is an A.Otherwise, at least 1 move is needed.The answer is 1 if:At least one of the edge rows/columns is all As.Otherwise, it can be shown that at least 2 moves are needed, because if every edge has at least one P, then no single move can simultaneously turn all four edges into A. To see this, note that our move must simultaneously touch all four edges. This forces us to select our initial row/column to be an entire edge row/column of the grid. But then, we are forced to have at least one P in our selection, and this P cannot be removed in this move.The answer is 2 if:There is one corner that's an A because in a single move, we can turn an edge into all As.There's a whole column or row of As, because again, in a single move, we can turn an edge into all As. (This case could be tricky to spot.)Otherwise, it can be shown that at least 3 moves are needed. This is because, if we are only allowed 2 moves, then our first move must take us to a configuration where only 1 move is needed. In other words, in a single move, we must ensure that one edge has all As. Now, suppose we have decided which edge to turn into all As. Since all corners are Ps, our move must touch both corners of that edge, and so we are forced to copy an entire row/column up to that edge. But since every row/column has a P, this means that the edge will contain a P after the move, and hence, we have failed to turn that edge into all As. (We cannot also have accidentally turned another edge into all As since the other corners are still Ps.)The answer is 3 if:There is at least one A in one of the edges, because in a single move, we can ensure that one corner becomes an A.Otherwise, it can be shown that at least 4 moves are needed, because we can't turn any corner into A in a single move (because all edges are Ps, and only cells in edges get copied onto corners), and we also can't turn any row/column into all As in a single move (since that requires copying an entire row/column onto it, but again, note that the edges are all Ps).The answer is 4 if:It is not one of the cases above, since 4 moves are always enough.Accepted CodeAccepted Submission: 67016167

1281E - Jeremy Bearimy

Solution Sketch1281E - Jeremy BearimyMaximization

Suppose we're maximizing the sum. Consider a single edge (a,b), and consider the two components on either side of this edge. Then we have an important observation: in the optimal solution, the nodes of one component are all paired with nodes on the other component. This is because otherwise, there will be at least one pair in each component that lies entirely in that component, say (ia,ja) and (ib,jb). But if we switch the pairing to, say, (ia,ib) and (ja,jb), then the cost increases, because we're introducing new edges (namely (a,b), among possibly others) while keeping everything from the previous pairing.

Repeating this, we can construct an optimal solution where all nodes in one component are paired with nodes in the other component.

This means that in the optimal solution, the edge (a,b) is counted exactly min(ca,cb) times, where ca is the size of the component on a's side, and cb is the size of the component on b's side. Therefore, the edge contributes exactly weight(a,b)⋅min(ca,cb) to the answer.

But the same is true for all edges! Therefore, we can compute the answer by just summing up all contributions. The only remaining step needed is to compute the sizes of all subtrees, and this can be done with a single BFS/DFS and DP. This runs in O(n).

Minimization

Now, suppose we're minimizing the sum. Consider again a single edge (a,b). Again, we have an important observation: in the optimal solution, at most one pair passes through (a,b). This is because otherwise, if there are at least two such pairs, then we can again switch the pairing (essentially the reverse of maximizing), which decreases the cost, because it doesn't introduce additional edges but it decreases the number of pairs passing through (a,b) by 2.

Repeating this, we can ensure that at most one pair passes through (a,b).

Furthermore, the parity of the number of pairs passing through (a,b) is fixed. (Why?) Therefore, in the optimal solution, (a,b) is counted exactly (camod2) times. (Note that ca≡cb(mod2))

But again, the same is true for all edges! Therefore, we can compute the answer in O(n) as well, by summing up all contributions.

Accepted CodeAccepted Submission: 67020743

1281F - Miss Punyverse

Solution Sketch1281F - Miss PunyverseLet's say a region is winning if there are strictly more wasps than bees. Thus, we're maximizing the number of winning regions.

Tree DP seems natural in this sort of situation. For example, after rooting the tree arbitrarily, you could probably come up with something like f(i,r): Given the subtree rooted at i and the number of regions r, find the maximum number of winning regions if we partition that subtree into r regions. However, this has an issue: we also need to merge our topmost component with the topmost component of some subtrees, so the subtrees' vote advantage at their topmost components matter, and must also be considered in the DP. Unfortunately, if we just naively insert the vote advantage to our DP state (or output), this means that there could potentially be too many states/outputs to fit in the time limit.

Fortunately, we can keep the number of states the same by using the following greedy observation: It is optimal to maximize the number of winning regions first, and then to maximize the vote advantage at the top second. In other words, in a subtree,(x winning regions,−∞ vote advantage)is better than(x−1 winning regions,+∞ vote advantage).This is because the +∞ vote advantage at the top component, at best, can increase the number of winning regions by 1, but we can already guarantee to achieve that with (x,−∞).

So the DP now becomes f(i,r): Given the subtree rooted at i and the number of regions r, find the maximum number of winning regions, and among all such possibilities, find the maximum vote advantage of the top component.

Just be careful that your DP solution doesn't construct size-0 partitions.

Now, what about the time complexity? We have a state that looks like (i,r), where 1≤r≤size(i), and a transition that runs in O(r), so naively it feels like it runs in O(n3) in the worst case. However, if you've seen this before, this is actually the sort of DP pattern that is really O(n2), at least with the right implementation.

Specifically, if we ensure that we only loop across the range where the substates are both valid, then you may check that the total amount of work done in each node is O(size(i)2−∑j is a child of isize(j)2), and such a recurrence can be analyzed to be O(n2).

Accepted CodeAccepted Submission: 67016189

1280E - Kirchhoff's Current Loss

Solution Sketch1280E - Kirchhoff's Current LossInstead of minimizing the integer cost (which feels like a hard number theory problem), let's try to minimize the real number cost first. This is a bit easier, but it should help us solve the integer case by at least giving us a lower bound.

If we're allowed to assign arbitrary real numbers as costs, then we can deduce that the minimum cost to obtain a resistance of r is proportional to r. This is because we can just scale resistances arbitrarily, so if we have an optimal solution for one given r with optimal cost c⋅r, then to get any other target resistance r′, we can simply scale all resistances by r′/r, and we get a circuit with resistance r′ and cost c⋅r′ that should also be optimal.

To prove this more rigorously, define f(r) to be the optimal cost for a target resistance r. Then, the scaling idea above shows that f(r′)≤f(r)⋅(r′/r), which is equivalent to f(r′)/r′≤f(r)/r. By symmetry, f(r′)/r′≥f(r)/r, and so f(r′)/r′=f(r)/r, for any r,r′>0. Therefore, f must be linear in r, i.e., f(r)=c⋅r for some c.

Thus, we just need to find this proportionality constant c for our input circuit. This can be computed inductively.

For a basic resistor, c=1.For k circuits with constants c1,…,ck joined in series, c=min(c1,…,ck).For k circuits with constants c1,…,ck joined in parallel, c√=c1−−√+…+ck−−√.The latter two can be derived with some basic calculus. (For the case of parallel circuits, using Lagrange multipliers is the easiest way, at least for me.)But note that all three statements imply (via induction) that c√ is an integer! Even more, using the formulas above, we can deduce the following stronger statement: for the purposes of minimization, the whole circuit is equivalent to a parallel circuit with c√ resistors. You can also prove this via induction, and it's actually not that hard. The hardest part is knowing what to prove in the first place.

Once we have this statement, we can now turn its proof into a recursive algorithm that actually computes these c√ parallel resistors the whole circuit is equivalent to. (The most straightforward proof of it naturally translates into such an algorithm.) We then assign a resistance of 0 to everything else. Finally, using the same analysis as before, to obtain a resistance of r in a parallel circuit of c√ resistors, the optimal way is to assign c√⋅r to everything.

But if r is an integer, then c√⋅r is an integer as well, and since we're assigning 0 to everything else, it means that the minimum cost to achieve r can be achieved in integers as well!

Accepted CodeAccepted Submission: 67016199

1280F - Intergalactic Sliding Puzzle

Solution Sketch1280F - Intergalactic Sliding PuzzleThe "shortcuts" thing in the output section is basically a way for you to define subroutines, i.e., you can create simpler (useful) operations, and then you can combine them into more complex operations.

Now, to solve the problem, we may represent the grid by the "circular permutation" obtained by going around the grid once, say in a clockwise order, starting from, say, the top-left corner.

Without the middle column, this circular permutation cannot be changed; we can rotate it, but that's it. Thus, to make progress, we must use the middle column. The key insight here is that moving something through the middle column corresponds to one, and only one, kind of operation:

which, on our circular permutation, corresponds to:

Notice that it simply moved 4 a couple of places to the right.

In other words, moving through the middle corresponds to a rotation of 2k+1 elements. Since we can also rotate the whole thing, this (2k+1)-rotation can be performed anywhere in our permutation.

But since (2k+1)-rotations and full rotations (i.e., (4k+1)-rotations) are both even permutations, and these are the only available moves, this means that inputs that are an odd permutation away from the target state are unsolvable! (You can also notice this right away once you realize that this problem is essentially the "sliding picture puzzle" but with even more restricted moves.)

Amazingly, the converse is true: all even permutations are solvable! This follows from the fact that we can produce a 3-rotation from the given operations. You may want to try to come up with it yourself, so instead of giving the sequence of moves directly, I'll just give you a hint: there is a sequence of six (2k+1)-rotations that is equivalent to the 3-rotation (123) or (132), and it only involves moving 1, 2k+2 and 2k+3. (If you still can't find it, you could also write a backtracking program that finds it.)

Once we have any single 3-rotation, it can then be applied anywhere, again using with full rotations. Also, it is a well-known fact that any even permutation is representable by a product of 3-rotations. This means that all even permutations are solvable!

Now, determining which inputs are solvable is one thing, but actually finding the solution is a whole different beast. Fortunately, the "shortcuts" thing is here to make it a bit easier. The most important milestone is being able to come up with a sequence corresponding to a 3-rotation; assign an uppercase letter for such an operation. After that, you will only need 3-rotations and full rotations to solve the rest.

Accepted CodeAccepted Submission: 67026155

Technocup 2020 — Elimination Round 4 + Codeforces Round 606: Editorial

By MikeMirzayanov, 3 years ago, translation, In EnglishMany thanks to cannor147 and geranazavr555 for the help with the translation into English.

1259A - Happy Birthday, Polycarp!Problem Writer: MikeMirzayanov

Editorial1259A - Happy Birthday, Polycarp!It seems that one of the easiest ways to solve this problem is to iterate over all beautiful numbers up to 109 and check each of the numbers to ensure that it does not exceed n. First of all, you can iterate over a length from 1 to 8, supporting a number of the form 11...1 of this length, and inside iterate over a factor for this number from 1 to 9. The main part of a solution might look like this:

cin >> n;int b = 0, ans = 0;for (int len = 1; len <= 9; len++) {    b = b * 10 + 1;                for (int m = 1; m <= 9; m++)        if (b * m <= n)            ans++;}cout << ans << endl;1259B - Make Them OddProblem Writer: MikeMirzayanov

Editorial1259B - Make Them OddConsider the greatest positive value in the set. Anyway, once we will divide it by two. It is always optimal to do it on the first move because the result of the division can be divided again (if needed) later.

So, the optimal way to solve this problem is: as long as there is at least one even value in the set, we need to choose the maximal even number in the set and divide all the numbers equal to it by 2.

For effective implementation, you can use features of the standard library to represent the set as std::set (for C++, in other languages there are alternatives of this data structure or you can modify the solution).

Below is an example of a possible implementation of the main part of the solution:

cin >> n;set<int> a;for (int i = 0; i < n; i++) {    int elem;    cin >> elem;    a.insert(elem);}int result = 0;while (!a.empty()) {    int m = *a.rbegin();    a.erase(m);    if (m % 2 == 0) {        result++;        a.insert(m / 2);    }}cout << result << endl;1259C - As Simple as One and TwoProblem Writer: MikeMirzayanov

Editorial1259C - As Simple as One and TwoConsider each occurrence of substrings one and two. Obviously, at least one character have to be deleted in such substrings. These substrings cannot intersect in any way, except for one case: twone. Thus, the answer is necessarily no less than the value c21+c1+c2, where c21 is the number of occurrences of the string twone and c1 is the number of occurrences of the string one (which are not part of twone) and c2 is the number of occurrences of the string two (which are not part of twone).

Let's propose a method that does exactly c21+c1+c2 removals and, thus, will be optimal.

Delete character o in each occurrence of twone. This action will delete both substrings one and two at the same time.Next, delete character n in each occurrence of one. This action will delete all substrings one.Next, delete character w in each occurrence of two. This action will delete all substrings two.Note that it is important to delete the middle letters in the last two paragraphs to avoid appearing a new occurrence after a line is collapsed.

The following is an example of a possible implementation of the main part of a solution:

string s;cin >> s;vector<int> r;for (string t: {"twone", "one", "two"}) {    for (size_t pos = 0; (pos = s.find(t, pos)) != string::npos;) {        s[pos + t.length() / 2] = '?';        r.push_back(pos + t.length() / 2);    }}cout << r.size() << endl;for (auto rr: r)    cout << rr + 1 << " ";cout << endl;1259D - Let's Play the Words?Problem Writer: MikeMirzayanov

Editorial1259D - Let's Play the Words?For a concrete set of words, it's not hard to find a criteria for checking if there is a correct order of arrangement of words for playing a game. Let's call such sets of words correct. Firstly the set of words is correct if the number of words like 0...1 and the number of words like 1...0 differ by no more than 1. Secondly it's correct if the number of words like 0...0 or like 1...1 is zero, because they have the same characters at the beginning and at the ending, and we can insert them in any position. And finally if words of both kinds 0...0 and 1...1 are present and there is at least one word like 0...1 or 1...0.

It can be easily proved if we note that this problem is equivalent to the Euler traversal of a directed graph with two nodes. But let's prove it without resorting to graph theory:

if there are words of both kinds 0...0 and 1...1, but there is no words of kinds 0...1 and 1...0, starting from a word of one kind you can't go to a word of another kind. Consequently, if words of both kinds 0...0 and 1...1 are present, there should be at least one word like 0...1 or 1...0 — is a necessary condition of the problem;if the number of words like 0...1 and the number of words like 1...0 differ by no more than 1, we can call them alternately starting with a kind that is larger. If these numbers are equal, we can start with any kind. And we can insert words of kind 0...0 and 1...1 at any suitable moment.Reversals only affect the mutual number of lines of the kind 0...1 and 1...0. Therefore, immediately while reading the input data, we can check the necessary condition (first item above).

Without loss of generality we may assume that the number of words like 0...1 equals n01 and like 1...0 equals n10. Also we assume that n01>n10+1. Remember that all words in the current set are unique. Let's prove that we can always choose some words of kind 0...1 and reverse them so that n01=n10+1 (and at the result all words would still be unique).

In fact, the set of words of kind n10 has no more than n10 such words that after the reversing, the word will turn into an existing one (because it will become of type 1...0 and there are only n10 such words). And it means that there is no less than n01−n10 words which we can reverse and get still unique word. So, we can choose any n01−n10−1 of them.

Thus, after checking of the necessary condition (first item above), we need to reverse just n01−n10−1 words of kind that is larger, which reversals aren't duplicates.

Below is an example of a possible implementation of the main part of the solution described above.

int n;cin >> n;vector<string> s(n);set<string> s01;set<string> s10;vector<bool> u(2);forn(i, n) {    cin >> s[i];    if (s[i][0] == '0' && s[i].back() == '1')        s01.insert(s[i]);    if (s[i][0] == '1' && s[i].back() == '0')        s10.insert(s[i]);    u[s[i][0] - '0'] = u[s[i].back() - '0'] = true;}if (u[0] && u[1] && s01.size() == 0 && s10.size() == 0) {    cout << -1 << endl;    continue;}vector<int> rev;if (s01.size() > s10.size() + 1) {    forn(i, n)        if (s[i][0] == '0' && s[i].back() == '1') {            string ss(s[i]);            reverse(ss.begin(), ss.end());            if (s10.count(ss) == 0)                rev.push_back(i);        }} else if (s10.size() > s01.size() + 1) {    forn(i, n)        if (s[i][0] == '1' && s[i].back() == '0') {            string ss(s[i]);            reverse(ss.begin(), ss.end());            if (s01.count(ss) == 0)                rev.push_back(i);        }}int ans = max(0, (int(max(s01.size(), s10.size())) - int(min(s01.size(), s10.size()))) / 2);cout << ans << endl;forn(i, ans)    cout << rev[i] + 1 << " ";cout << endl;1259E - Two FairsProblem Writer: MikeMirzayanov

Editorial1259E - Two FairsThis problem has a simple linear solution (just two depth-first searches) without involving cut points, biconnected components, and other advanced techniques.

Let's reformulate this problem in the language of graph theory: you are given an undirected graph and two vertices a and b, you need to find the number of pairs of vertices (x,y) such that any path from x to y contains both vertices a and b.

In other words, we are interested in pairs of vertices (x,y) such that deleting the vertex a (while going from b) breaks the connection from x to y and deleting the vertex b (while going from a) breaks the connection from x to y.

Let's remove the vertex a and select the connected components in the resulting graph. Similarly, we remove the vertex b and select the connected components in the resulting graph. Then the pair (x,y) interests us if x and y belong to different components both when removing a and when removing b.

Thus, let's find a pair of (αu,βu) for each vertex u. It will be numbers of the connected components when a and b are removed, respectively. The pair (x,y) interests us if (αx,βx)≠(αy,βy).

The total number of vertex pairs is n⋅(n−1)/2. Let's subtract the number of uninteresting pairs from it.

Firstly, these are pairs such that (αx,βx) and (αy,βy) partially equals (in exactly one component). For example, let the equality be on the first component in the common value of α. Let the total number of pairs (αu,βu) such that αu=α be equal to c, then subtract c⋅(c−1)/2 from the current answer. We will do this with all α and β.

Note that some uninteresting pairs were counted twice. These are pairs of vertices such that (αx,βx) and (αy,βy) equals in both components. We can count the number of corresponding vertices c and add c⋅(c−1)/2 to the current answer for each pair.

In the following code, let p be an array of pairs of component numbers for all vertices except a and b. Each pair is the number of the connected component of this vertex if a is removed, and the number of the connected component of this vertex if b is removed. Then the main part of the solution can be like this:

long long ans = (long long)(p.size()) * (p.size() - 1) / 2;{    map<int,int> pp;    forn(i, n - 2)        pp[p[i].first]++;    for (auto kv: pp)        ans -= ((long long) kv.second * (kv.second - 1)) / 2;}{    map<int,int> pp;    forn(i, n - 2)        pp[p[i].second]++;    for (auto kv: pp)        ans -= ((long long) kv.second * (kv.second - 1)) / 2;}map<pair<int,int>,int> pp;forn(i, n - 2)    pp[p[i]]++;for (auto kv: pp)    ans += ((long long) kv.second * (kv.second - 1)) / 2;

cout << ans << endl;    To build the array p we could use the code below:

void dfs(int u, int c) {    if (color[u] == 0) {        color[u] = c;        for (int v: g[u])            dfs(v, c);    }}

vector<int> groups(int f) {    color = vector<int>(n);    color[f] = -1;    int c = 0;    forn(i, n)        if (i != f && color[i] == 0)            dfs(i, ++c);    return color;}

// begin of read input and construct graph g// some code ...// end of read input and construct graph g

vector<pair<int,int>> p(n - 2);{    int index = 0;    auto g = groups(a);    forn(i, n)        if (i != a && i != b)            p[index++].first = g[i];}{    int index = 0;    auto g = groups(b);    forn(i, n)        if (i != a && i != b)            p[index++].second = g[i];}1259F - Beautiful RectangleProblem Writer: MikeMirzayanov

Editorial1259F - Beautiful RectangleFirst, let's formulate the criteria that from the given set of numbers x1,x2,…,xk we can create a beautiful rectangle a×b (where a⋅b=k,a≤b). Obviously, if some number occurs more than a times, then among a rows there will be such row that will contain two or more occurrences of the number (pigeonhole principle).

Let's prove that if all numbers in x[1…k] occur no more than a times, we can create a beautiful rectangle a×b (where a⋅b=k,a≤b).

We will numerate cells from the upper left corner in the order from one, moving diagonally each time. Assume rows are numerated from 0 to a−1 and columns are numerated from 0 to b−1. Let's begin from the cell (0,0) and move right-down each time. If we face to a border, we will move cyclically. Thus, from the cell (i,j) we will move to the cell ((i+1)moda,(j+1)modb) each time (where pmodq is the remainder when divided p by q). If we are going to move to a visited cell, before moving let's assign i:=(i+1)moda.

Example of the numeration for rectangles 3×3 and 4×6.We can also prove that while such numeration each row and each column contain numbers that differ by no less than a−1 (if we are on a row/column, we will make a turn before we will be on the row/column again). Moreover, the difference reaches a−1 (not a) when we move to the previously visited cell and assign i:=(i+1)moda. So, we can prove that the lengths of such orbits are equal lcm(a,b) (lcm is a least common multiple). Consequently, they are divided by a. It means that if we will arrange the numbers from x in the order from the most common (at worst case those that meet a times) to the least common, each row and each column will always contain different numbers.

Thus, we have a plan of the solution: find optimal a and b so that the answer is the largest rectangle a×b (a≤b). For this we will iterate over all possible candidates in a and for each candidate each number v from x we will use it no more than min(cv,a) times where cv is a number of occurrences v in the given sequence. So, if we choose a, the upper bound of a rectangle area is ∑min(cv,a) for all possible different numbers v from the given sequence. Consequently, the maximal value of b is ∑min(cv,a)/a. And let's update the answer if for current iteration a⋅b is larger than previously found answer (still consider that a≤b).

We can maintain the value ∑min(cv,a) while a is incremented by one. For doing this we should each time add geq[a] to this value, where geq[a] is a number of different numbers in the given sequence, which occurs at least a times (we can precalculate this array).

Below is a code which reads the input data and precalculates the array geq.

int n;scanf("%d", &n);

map<int,int> cnts;forn(i, n) {    int x;    scanf("%d", &x);    cnts[x]++;}

vector<vector<int>> val_by_cnt(n + 1);for (auto val_cnt: cnts)    val_by_cnt[val_cnt.second].push_back(val_cnt.first);

vector<int> geq(n + 1);geq[n] = val_by_cnt[n].size();for (int i = n - 1; i >= 1; i–)    geq[i] = geq[i + 1] + val_by_cnt[i].size();Below is a code which finds the optimal sizes of the rectangle by iterating its the smallest side a.

int tot = 0, best = 0, best_a, best_b;for (int a = 1; a <= n; a++) {    tot += geq[a];    int b = tot / a;    if (a <= b && best < a * b) {        best = a * b;        best_a = a;        best_b = b;    }}And below is a code which prints the optimal rectangle sizes, generates the required beautiful rectangle and prints it.

cout << best << endl << best_a << " " << best_b << endl;vector<vector<int>> r(best_a, vector<int>(best_b));

int x = 0, y = 0;for (int i = n; i >= 1; i–)    for (auto val: val_by_cnt[i])        forn(j, min(i, best_a)) {            if (r[x][y] != 0)                x = (x + 1) % best_a;            if (r[x][y] == 0)                r[x][y] = val;            x = (x + 1) % best_a;            y = (y + 1) % best_b;        }

forn(i, best_a) {    forn(j, best_b)        cout << r[i][j] << " ";    cout << endl;}Thus, the total complexity of the algorithm is O(nlogn), where logn appears only thanks for working with std::map (and we can easily get rid of it and make the linear algorithm).

1259G - Tree EliminationProblem Writers: Endagorion

Editorial1259G - Tree EliminationFirst of all, counting different sequences is the same as counting the number of different playbacks of the elimination process (that is, different combinations of which token was removed on each step). Indeed, if we consider any resulting sequence, we can simulate the process and unambiguously determine which endpoint got its token removed on any step, skipping steps when no tokens can be removed.

To count different playbacks, we will use subtree dynamic programming. Let us consider a vertex v, and forget about all edges not incident to any vertex that is not in a subtree of v; that is, we are only considering edges in the subtree of v, as well as the edge between v and its parent p (for convenience, assume that the root vertex has an edge with index n to a "virtual" parent). Note that we assume that p can not be eliminated by means other than considering its edge to v.

As a shorthand, we will say "v was compared with u" to mean "when the edge (v,u) was considered, both its endpoints had their token", and "v was killed by u" to mean "v was compared with u and lost its token on that step".

We will distinguish three types of playbacks in v's subtree:

v was killed before comparing to p (situation 0);v was killed by p (situation 1);v killed p (situation 2).We will write dpv,s the number of playbacks in the subtree of v that correspond to the situation s.

Let u1,…,uk be the list of children of v ordered by increasing of index(ui,v), and let d be the largest index such that index(ud,v)<index(v,p). If index(u1,v)>index(v,p), put d=0.

Let us work out the recurrence relations for dpv,s. For example, for s=0 we must have that v was killed by one of its children ui with i≤d. For a fixed i, the playback should have proceeded as follows:

all children u1,…,ui were either killed before comparing to v, or killed by v (but they could not have survived comparing with v).v was killed by ui;all children ui+1,…,uk were either killed before comparing to v, or "survived" the non-existent comparison to v (but they could not have been killed by v).Consequently, we have the formuladpv,0=∑i=1d(∏j=1i=1(dpuj,0+dpuj,1)×dpui,1×∏j=i+1k(dpuj,0+dpuj,2)).Arguing in a similar way, we can further obtain

dpv,1=∏j=1i=d(dpuj,0+dpuj,1)×∏j=d+1k(dpuj,0+dpuj,2),dpv,2=∑i=d+1k(∏j=1i=1(dpuj,0+dpuj,1)×dpui,1×∏j=i+1k(dpuj,0+dpuj,2))+∏j=1k(dpuj,0+dpuj,1).In all these formulas we naturally assume that empty products are equal to 1.

To compute these formulas fast enough we can use prefix products of dpj,0+dpj,1 and suffix products of dpj,0+dpj,2. Finally, the answer is equal to dproot,0+dproot,1 (either the root was killed, or it wasn't and we assume that it was killed by its virtual parent).

This solution can implemented in O(n) since the edges are already given by increasing of their indices, but O(nlogn) should also be enough.

1276E - Four StonesProblem Writers: Endagorion

Editorial1276E - Four StonesFirst, when is the task impossible? If all ai have the same remainder d modulo an integer g, then it will always be true regardless of our moves. The largest g we can take is equal to GCD(a2−a1,a3−a1,a4−a1). Remark: case when all ai are equal is special. If the GCD's or the remainders do not match for ai and bi, then there is no answer. For convenience, let us apply the transformation x→(x−d)/g to all coordinates, and assume that g=1. We can observe further that parity of each coordinate is preserved under any operation, thus the number of even and odd numbers among ai and bi should also match.

Otherwise, we will divide the task into two subproblems:

Given four stones a1,…,a4, move them into a segment [x,x+1] for an arbitrary even x.Given four stones in a segment [x,x+1], shift them into a segment [y,y+1].Suppose we can gather ai and bi into segments [x,x+1] and [y,y+1]. Then we can solve the problem as follows:

gather ai into [x,x+1];shift the stones from [x,x+1] to [y,y+1];undo gathering bi into [y,y+1] (all moves are reversible).First subproblem. Throughout, let Δ denote the maximum distance between any two stones. Our goal is to make Δ=1. We will achieve this by repeatedly decreasing Δ by at least a quarter, then we will be done in O(logΔ) steps.

Suppose a1≤a2≤a3≤a4, and one of the stones ai is in the range [a1+Δ/4,a1+3Δ/4]. Consider two halves [a1,ai] and [ai,a4], and mirror all stones in the shorter half with respect to ai. Then, ai becomes either the leftmost or the rightmost stone, and the new maximum distance Δ′ is at most 3Δ/4, thus reaching our goal.

What if no stones are in this range? Denote di=min(ai−a1,a4−ai) — the distance from ai to the closest extreme (leftmost or rightmost) stone. We suppose that d2,d3<Δ/4, otherwise we can reduce Δ as shown above. Further at least one of d2,d3 is non-zero, since otherwise we would have GCD(a2−a1,a3−a1,a4−a1)=1=Δ, and the goal would be reached.

Observe that performing moves (ai,aj), (ai,ak) changes ai to ai+2(ak−aj). With this we are able to change di to di+2dj. Repeatedly do this with di≤dj (that is, we are adding twice the largest distance to the smallest). In O(logΔ) steps we will have max(d2,d3)≥Δ/4, allowing us to decrease Δ as shown above.

Finally, we have all ai∈[x,x+1]. To make things easier, if x is odd, move all ai=x to x+2.

Second subproblem. We now have all stones in a range [x,x+1], and we want to shift them by 2d (we will assume that 2d≥0). Observe that any arrangement of stones can be shifted by 2Δ by mirroring all stones with respect to the rightmost stone twice.

Consider an operation we will call Expand: when a1≤a2≤a3≤a4, make moves (a3,a1) and (a2,a4). We can see that if we apply Expand k times, the largest distance Δ will grow exponentially in k. We can then shift the stones by 2d as follows:

Apply Expand until Δ>d.While Δ≤d, shift all stones by 2Δ as shown above, and decrease d by Δ.If Δ=1, exit.Perform Expand−1 — the inverse operation to Expand, and return to step 2.In the end, we will have Δ=1 and d=0. Further, since Δ grows exponentially in the number of Expand's, for each value of Δ we will be making O(1) shifts, thus the total number of operations for this method O(logd).

1276F - Asterisk SubstringsProblem Writers: voidmax

Editorial1276F - Asterisk SubstringsThere are two types of substrings we have to count: with and without the *. The substrings without * are just all substrings of the intial string s, which can be counted in O(n) or O(nlogn) using any standard suffix structure.

We now want to count the substrings containing *. Consider all such substrings of the form "u*v", where u and v are letter strings. For a fixed prefix u, how many ways are there to choose the suffix v? Consider the right context rc(u) — the set of positions i+|u| such that the suffix sisi+1… starts with u. Then, the number of valid v is the number of distinct prefixes of suffixes starting at positions in the set {i+1∣i∈rc(u)}.

For an arbitrary set X of suffixes of s (given by their positions), how do we count the number of their distinct prefixes? If X is ordered by lexicographic comparison of suffixes, the answer is 1+∑i∈X(|s|−i)−∑i,j are adjacent in X|LCP(i,j)|, where LCP(i,j) is the largest common prefix length of suffixes starting at i and j. Recall that LCP(i,j) queries can be answered online in O(1) by constructing the suffix array of s with adjacent LCPs, and using a sparse table to answer RMQ queries. With this, we can implement X as a sorted set with lexicographic comparison. With a bit more work we can also process updates to X and maintain ∑LCP(i,j) over adjacent pairs, thus always keeping the actual number of distinct prefixes.

Now to solve the actual problem. Construct the suffix tree of s in O(n) or O(nlogn). We will run a DFS on the suffix tree that considers all possible positions of u. When we finish processing a vertex corresponding to a string u, we want to have the structure keeping the ordered set X(u) of suffixes for rc(u). To do this, consider children w1,…,wk of u in the suffix tree. Then, X(u) can be obtained by merging ex(X(w1),|w1|−|u|),…,ex(X(wk),|wk|−|u|), where ex(X,l) is the structure obtained by prolonging all prefixes of X by l, provided that all extensions are equal substrings. Note that ex(X,l) does not require reordering of suffixes in X, and simply increases the answer by l, but we need to subtract l from all starting positions in X, which can be done lazily. Using smallest-to-largest merging trick, we can always have an up-to-date X(u) in O(nlog2n) total time.

We compute the answer by summing over all u. Suppose the position of u in the suffix tree is not a vertex, but is located on an edge l characters above a vertex u. Then we need to add l+ans(X(u)) to the answer. Since we know X(u) for all u, the total contribution of these positions can be accounted for in O(1) per edge. If u is a vertex, on the step of processing u we add ans(ex(X(w1),|w1|−|u|−1)∪…∪ex(X(wk),|wk|−|u|−1)), using smallest-to-largest again. Note that we still need to return X(u), thus after computing u's contribution we need to undo the merging and merge again with different shifts.

The total complexity is O(nlog2n). If we compute LCPs in O(logn) instead of O(1), we end up with O(nlog3n), which is pushing it, but can probably pass.

Codeforces Round #605 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishAll ideas except the problem C belong to MikeMirzayanov. The author of C is Rox.

Special thanks to _overrated_ for the invaluable help with the round preparation!

1272A - Three Friends

Tutorial1272A - Three FriendsThis problem can be solved with simple simulation. Let na∈{a−1,a,a+1} be the new position of the first friend, nb∈{b−1,b,b+1} and nc∈{c−1,c,c+1} are new positions of the second and the third friends correspondingly. For the fixed positions you can update the answer with the value |na−nb|+|na−nc|+|nb−nc|. And iterating over three positions can be implemented with nested loops.

Time complexity: O(1) per test case.

Solution1272B - Snow Walking Robot

Tutorial1272B - Snow Walking RobotLet cnt[L] be the number of occurrences of the character 'L' in the initial string, cnt[R] — the number of occurrences of the character 'R', cnt[U] and cnt[D] are the same things for remaining characters.

It is obvious that in every answer the number of 'L' equals the number of 'R' and the same for 'D' and 'U'. The maximum theoretic answer we can obtain has length 2⋅(min(cnt[L],cnt[R])+min(cnt[U]+cnt[D])). And... We almost always can obtain this answer! If there is at least one occurrence of each character, then we can construct some kind of rectangular path: min(cnt[L],cnt[R]) moves right, then min(cnt[U],cnt[D]) moves up, and the completing part.

But there are some corner cases when some characters are missing. If min(cnt[U],cnt[D])=0 then our answer is empty or (if it is possible) it is "LR". The same if min(cnt[L],cnt[R])=0.

Time complexity: O(|s|) per test case.

Solution1272C - Yet Another Broken Keyboard

Tutorial1272C - Yet Another Broken KeyboardLet's replace all characters of s with zeros and ones (zero if the character is unavailable and one otherwise). Then we have the binary string and we have to calculate the number of contiguous segments of this string consisting only of ones. It can be done with two pointers approach.

If we are staying at the position i and its value is zero, just skip it. Otherwise, let's find the leftmost position j such that j>i and the j-th value is zero. Then we have to add to the answer the value (j−i)⋅(j−i+1)2 and set i:=j.

Time complexity: O(n).

Solution1272D - Remove One Element

Tutorial1272D - Remove One ElementFirstly, let's calculate for each i from 1 to n two following values: ri and li. ri means the maximum length of the increasing sequence starting in the position i, and li means the maximum length of the increasing sequence ending in the position i. Initially, all 2n values are 1 (the element itself).

The array r can be calculated in order from right to left with the following condition: if ai<ai+1 then ri=ri+1+1, otherwise it still remain 1. The same with the array l, but we have to calculate its values in order from left to right, and if ai>ai−1 then li=li−1+1, otherwise it still remain 1.

Having these arrays we can calculate the answer. The initial answer (if we don't remove any element) is the maximum value of the array l. And if we remove the i-th element (where i=2…n−1), then we can update the answer with the value li−1+ri+1 if ai−1<ai+1.

Time complexity: O(n).

Solution1272E - Nearest Opposite Parity

Tutorial1272E - Nearest Opposite ParityIn this problem, we have directed graph consisting of n vertices (indices of the array) and at most 2n−2 edges. Some vertices have the value 0, some have the value 1. Our problem is to find for every vertex the nearest vertex having the opposite parity. Let's try to solve the problem for odd numbers and then just run the same algorithm with even numbers.

We have multiple odd vertices and we need to find the nearest even vertex for each of these vertices. This problem can be solved with the standard and simple but pretty idea. Let's inverse our graph and run a multi-source breadth-first search from all even vertices. The only difference between standard bfs and multi-source bfs is that the second one have many vertices at the first step (vertices having zero distance).

Now we can notice that because of bfs every odd vertex of our graph has the distance equal to the minimum distance to some even vertex in the initial graph. This is exactly what we need. Then just run the same algorithm for even numbers and print the answer.

Time complexity: O(n).

Solution1272F - Two Bracket Sequences

Tutorial1272F - Two Bracket SequencesFirstly, notice that the length of the answer cannot exceed 400 (200 copies of ()). Now we can do some kind of simple dynamic programming. Let dpi,j,bal be the minimum possible length of the prefix of the regular bracket sequence if we are processed first i characters of the first sequence, first j characters of the second sequence and the current balance is bal. Each dimension of this dp should have a size nearby 200+ε.

The base of this dp is dp0,0,0=0, all other values dpi,j,bal=+∞.

Transitions are very easy: if we want to place the opening bracket, then we increase i if the i-th character of s exists and equals '(', the same with the second sequence and j, the balance increases by one, and the length of the answer increases by one. If we want to place the closing bracket, then we increase i if the i-th character of s exists and equals ')', the same with the second sequence and j, the balance decreases by one, and the length of the answer increases by one. Note that the balance cannot be greater than 200 or less than 0 at any moment.

Don't forget to maintain parents in this dp to restore the actual answer!

The last problem that can be unresolved is how to write this dp? The easiest way is bfs, because every single transition increases our answer by one. Then we can restore answer from the state dp|s|,|t|,0. You can write it recursively, but I don't sure this will look good. And you also can write it just with nested loops, if you are careful enough.

Time complexity: O(|s|⋅|t|⋅max(|s|,|t|)).

If you know the faster solution, please share it!

Solution

Codeforces Round #604 Editorial

By chemthan, history, 3 years ago, In English1265A - Beautiful StringIf string s initially contains 2 equal consecutive letters ("aa", "bb" or "cc") then the answer is obviously -1.

Otherwise, it is always possible to replacing all characters '?' to make s beautiful. We will replacing one '?' at a time and in any order (from left to right for example). For each '?', since it is adjacent to at most 2 other characters and we have 3 options ('a', 'b' and 'c') for this '?', there always exists at least one option which differ from 2 characters that are adjacent with this '?'. Simply find one and replace '?' by it.

Time comlexity: O(n) where n is length of s.

Python SolutionAuthor: isaf27, prepare laoriu, I_love_Hoang_Yen

1265B - Beautiful NumbersA number m is beautiful if and only if all numbers in range [1,m] occupies m consecutive positions in the given sequence p. This is equivalent to posmax−posmin+1=m where posmax,posmin are the largest, smallest position of 1,2,…,m in sequence p respectively.

We will consider m in increasing order, that its m=1,2,…,n. For each m we will find a way to update posmax,posmin so we can tell either m is a beautiful number or not in constant time. Denote posi is the position of number i in the sequence p. When m=1, we have posmax=posmin=pos1. When m>1, the value of posmax,posmin can be updated by the following formula:

new_posmax=max(old_posmax,posm)new_posmin=min(old_posmin,posm)So we can update them in constant time. The correctness of above formula is based on the definition of posmax,posmin.Total time comlexity: O(n)C++ solutionAuthor: isaf27, prepare isaf27

1265C - Beautiful Regional ContestTo solve this problem, we have to make the following observations:

All participants who solved the same number of problems must be either not awarded at all or all are awarded a same type of medal.All g+s+b awarded participants are the first g+s+b participants.They can be proved based on the rules that the number of problems solved by a gold medalist > ones solved by a silver medalist > ones solved by a bronze medalist > ones solved by un-awarded participants.Suppose we have an optimal solution with g gold medals, s silver medals and b bronze medals where g+s+b is maximized. We can make the followings changes that resulted in another valid (and still optimal) solution:

Only keep gold medalist who solved most problem. For others, we change their medal types from gold to silver. After this change, g+s+b is unchanged and other rules are still satisfied.Similarly, only keep a minimized number of silver medalist who solved most problems among all silver medalist and the number of kept silver must strictly larger than the number gold medals. For others, we change their medal types from silver to bronze. After this changed, g+s+b is unchanged and other rules are still satisfied.Therefore, there exists an optimal solution where: g is minimized then s is minimized next. We can determine them greedily. When g and s are fixed, b should be maximized such that all rules are still satisfied.Time complexity: O(n)C++ solutionAuthor: MikeMirzayanov, prepare MikeMirzayanov

1265D - Beautiful SequenceFirstly, let's arrange even numbers. It is optimal to arrange those numbers as 0,0,0,…,0,2,2,…2. Because we can place number 1 anywhere while number 3 only between two numbers 2 or at the end beside a number 2. So we need to maximize the number of positions where we can place number 3. The above gives us an optimal way. The next step is to place the remaining numbers 1,3. Inserting them in internal positions first then at the ends later.

Base on the above argument, we can do as following way that eliminates corner case issues:

Starting from a number (try all possible value 0,1,2,3). At any moment, if x is the last element and there is at least number x−1 remains, we append x−1 otherwise we append x+1 or stop if there is no x+1 left. If we manage to use all numbers then we have a beautiful sequence and answer is 'YES'.

C++ SolutionAuthor: laoriu, prepare laoriu, I_love_Hoang_Yen

1265E - Beautiful MirrorsLet pi be the probability that the i-th mirror will answer YES when it is asked. That is, this pi equals to pi in the problem statement divide by 100.

Let ei be the expected number of days until Creatnx becomes happy when initially he is at the i-th mirror. For convenient, let en+1=0 (because when Creatnx is at (n+1)-th mirror he is happy already). The answer of the problem will be e1.

By the definition of expectation value and its basic properties, the following must holds for all 1≤i≤n:

ei=1+pi⋅ei+1+(1−pi)⋅e1Let explain this equation for those who are not familiar with probability. Expectation value is just average of all possible outcomes. The first number 1 in the right hand side means Creatnx spends 1 day to ask the i-th mirror. With probability of pi the i-th mirror will answer YES and Creatnx will move to the (i+1)-th mirror in the next day. At the (i+1)-th mirror, Creatnx on average needs to spend ei+1 days more to become happy. The second term pi⋅ei+1 explains this case. Similarly, the third term (1−pi)⋅e1 represents the case where the i-th mirror answers NO.

To find e1 we need to solve n equations:

(1) e1=1+p1⋅e2+(1−p1)⋅e1(2) e2=1+p2⋅e3+(1−p2)⋅e1…(n) en=1+pn⋅en+1+(1−pn)⋅e1We can solve this system of equations by using substitution - a common technique. From equation (1) we have e2=e1−1p1. Substituting this in (2) we obtained e3=e1−1p1⋅p2−1p2. See the pattern now? Similarly by substituting to that last equation we have:

0=en+1=e1−1p1⋅p2⋅…⋅pn−1p2⋅p3⋅…⋅pn−…−1pne1=1p1⋅p2⋅…⋅pn+1p2⋅p3⋅…⋅pn+…+1pne1=1+p1+p1⋅p2+…+p1⋅p2⋅…⋅pn−1p1⋅p2⋅…⋅pnWe can compute e1 according to the above formula in O(n).

C++ SolutionAuthor: chemthan, prepare laoriu, I_love_Hoang_Yen

1265F - Beautiful Bracket Sequence (easy version)We calculate the depth of a sequence as follow:

Let two pointers at each end of the sequence.If character at the left pointer is ')', we move the left pointer one position to the right.If character at the right pointer is '(', we move the right pointer one position to the left.If the character at the left pointer is '(' and the right pointer is ')' we increase our result and move the left pointer to the right and the right one to the left each with one position.We repeat while the left one is at the left of the right one.After that, we can use dynamic programming to solve the problem. Let dp[l][r] be total number of depth of all sequences induced by subsequence alal+1…ar. We have following transitives:dp[l][r]+=dp[l+1][r] if al≠ '('.dp[l][r]+=dp[l][r−1] if ar≠ ')'.dp[l][r]−=dp[l+1][r−1] if al≠ '(' and ar≠ ')'.dp[l][r]+=dp[l+1][r−1]+2k if al≠ ')' and ar≠ '(', where k is the number of '?' character in sl+1sl+2…sr−1.C++ SolutionAuthor: chemthan, prepare laoriu, I_love_Hoang_Yen

1264C - Beautiful Mirrors with queriesAssuming that currently there are k checkpoints 1=x1<x2<…<xk≤n, the journey becoming happy of Creatnx can be divided to k stages where in i-th stage Creatnx "moving" from mirror xi to mirror at position xi+1−1. Denote the i-th stage as (xi,xi+1−1). These k stages are independent so the sum of expected number of days Creatnx spending in each stage will be the answer to this problem.

When a new checkpoint b appear between 2 old checkpoints a and c, stage (a,c−1) will be removed from the set of stages and 2 new stages will be added, they are (a,b−1) and (b,c−1). Similarly, when a checkpoint b between 2 checkpoints a and c is no longer a checkpoint, 2 stages (a,b−1) and (b,c−1) will be removed from the set of stages and new stage (a,c−1) will be added. These removed/added stages can be fastly retrieved by storing all checkpoints in an ordered data structure such as set in C++. For removed/added stages, we subtract/add its expected number of days from/to the current answer. We see that when a query occurs, the number of stages removed/added is small (just 3 in total). Therefore, if we can calculate the expected number of days for an arbitrary stage fast enough, we can answer any query in a reasonable time.

From the solution of problem Beautiful Mirror, we know that the expected number of days Creatnx spending in stage (u,v) is:

1+pu+pu⋅pu+1+…+pu⋅pu+1⋅…⋅pv−1pu⋅pu+1⋅…⋅pv=ABThe denominator B can be computed by using a prefix product array — a common useful trick. We prepare an array s where si=p1⋅p2⋅…⋅pi. After that, B can be obtained by using 1 division: B=svsu−1.

For numerator A, we also use the same trick. An array t will be prepare where ti=p1+p1⋅p2+…+p1⋅p2…⋅pi. We have tv−1=tu−2+p1⋅p2⋅…⋅pu−1⋅A so A=tv−1−tu−2p1⋅p2⋅…⋅pu−1=tv−1−tu−2su−1.

C++ SolutionAuthor: chemthan, prepare laoriu, I_love_Hoang_Yen

1264D2 - Beautiful Bracket Sequence (hard version)By the way calculate the depth in easy version we can construct a maximal depth correct bracket S. At i-th position containing '(' or '?' we will count how many times it appears in S.

Let x be the number of '(' before the i-th position, y be the number of ')' after the i-th position, c be the number of '?' before the i-th position and d be the number of '?' after the i-th position. The i-th position appears in S iff the number of '(' before the i-th position must less than the number of ')' after the i-th position.

So we can derive a mathematics formula:

∑a+i<b+jC(c,i)⋅C(d,j)=∑a+i<b+jC(c,i)⋅C(d,d−j)=∑i+j<b+d−aC(c,i)⋅C(d,j).

Expanding both hand sides of indentity (x+1)c+d=(x+1)c⋅(x+1)d, the above sum is simplified as: ∑0≤i<b+d−aC(c+d,i). Notice that c+d doesn't change much, it only is one of two possible values. So we can prepare and obtain O(N) complexity.

C++ SolutionAuthor: chemthan, prepare laoriu, I_love_Hoang_Yen

1264E - Beautiful LeagueFirstly, Let's calculate the number of non-beautiful triples given all result of matches. It is obvious that for each non-beautiful triple (A,B,C) there exactly is one team that wins over the others. So if a team A wins k other teams B1,B2,…,Bk then team A corresponds to k⋅(k−1)2 non-beautiful triple (A,Bi,Bj). If we define (p1,p2,…,pn) as the number of wins of n teams. Then the number of non-beautiful triples will be p1⋅(p1−1)+p2⋅(p2−1)+…+pn⋅(pn−1)2. Notice that p1+p2+…+pn=n⋅(n−1)2. So we only need to minimize the square sum: p21+p22+…+p2n.

The remain can be solved easily by Mincost-Maxflow:

Creating source S, sink T, each 'match node' for each match haven't played yet, each 'team node' for each team.Add an edge between source S and each 'match node' with capacity 1 cost 0.Add an edge between each 'match node' and each of two 'team nodes' with capacity 1 cost 0.Assuming, after m matches played, i-th team wins qi matches. We add n−qi−1 edges between the i-th 'team node' and sink T with capacity 1 and costs 2⋅qi+1,2⋅qi+3,…,2⋅n−1. The min cost after run Mincost-Maxflow plus q21+q22+…+q2n will give us the minimal square sum.Base on Mincost-Maxflow idea, we can solve in more sophisticated way. At any moment, we will try to pick a team with minimal number of wins. Then we try to give it one more win by setting result of a match (that haven't used so far) and possibly changing results of a path of matches to keep the number of win of others. If not pick next one and so on.

Complexity: O(N4).

C++ SolutionAuthor: chemthan, prepare laoriu, I_love_Hoang_Yen

Another cool problem: WEICOM.

1264F - Beautiful Fibonacci ProblemIntuitively, we want to a formula for Fm+n. This is one we need: Fm+n=Fm⋅Fn+1+Fm−1⋅Fn.

Denote n=12⋅10k, one can verify that Fi⋅n≡0 modulo 10k (directly calculate or use 'Pisano Period').

So we have following properties:

F2⋅n+1=F2n+1+F2n ⇒F2⋅n+1=F2n+1 modulo 102⋅k.F3⋅n+1=F2⋅n+1⋅Fn+1+F2⋅n⋅Fn ⇒F3⋅n+1=F3n+1 modulo 102⋅k.So on, Fu⋅n+1=Fun+1 modulo 102⋅k.Notice that Fn+1=8⋅10k⋅t+1, where gcd(t,10)=1.

So Fu⋅n+1=(8⋅10k⋅t+1)u=8⋅u⋅t⋅10k+1 modulo 102⋅k.

Let u=125.a.t−1 modulo 10k, v=125.d.t−1 modulo 10k. Then we choose b=u⋅n+1,e=v⋅n.

Python SolutionAuthor: chemthan, prepare laoriu, I_love_Hoang_Yen

Bonus: another beautiful problem.

Codeforces Round #603 (Div. 2) Editorial

By AdvancerMan, 3 years ago, translation, In English1263A - Sweet Problem

Idea: MikeMirzayanov

Tutorial1263A - Sweet ProblemSort the values of r, g, b such that r≥g≥b. Now consider two cases.

If r≥g+b, then Tanya can take g candies from piles r and g, and then — b candies from piles r and b. After that there may be a bunch of candies left in the pile r that Tanya won't be able to eat, so the answer is g+b.

Otherwise, we need to achieve the equality of the piles r, g, b. First, we make equal r and g by eating r−g from the piles r and b (this can always be done since r<g+b). Then we make equal the piles g, b by eating g−b from the piles r and g. After that, r=g=b, and we can get three different cases.

r=g=b=0 — nothing needs to be done, Tanya has already eaten all the sweets;r=g=b=1 — you can take candy from any of two piles so in the end there will always be one candy left;r=g=b≥2 — we reduce all the piles by 2, taking, for example, a candy from piles r and g, g and b, r and b. With such actions, Tanya eventually reaches the two previous cases, since the sizes of the piles are reduced by 2.Since with this strategy we always have 0 or 1 candy at the end, Tanya will be able to eat candies for ⌊r+g+b2⌋ days.

Solution (MikeMirzayanov)1263B - PIN Codes

Idea: Stepavly

Tutorial1263B - PIN CodesGroup all the numbers into groups of equals PIN-Codes. Note that the size of each such group does not exceed 10. Therefore, in each PIN-Code we need to change no more than 1 digits. If the group consists of 1 element, then we do nothing, otherwise, we take all the PIN-codes except one from this group and change exactly one digit in them so that the new PIN-code becomes unique.

Solution (Stepavly)1263C - Everyone is a Winner!

Idea: unreal.eugene

Tutorial1263C - Everyone is a Winner!There are two approaches to solving this problem.

Mathematical Solution

Note that the answer will always contain the numbers 0≤x<⌊n−−√⌋. You can verify this by solving the equation ⌊nk⌋=x, equivalent to the inequality x≤nk<x+1, for integer values ​​of k. The solution to this double inequality is the interval k∈(nx+1;nx], whose length is nx2+x. For x<⌊n−−√⌋ nx2+x>1, and on an interval of length greater than 1 there is always a whole solution k=⌊nx⌋, so all integers 0≤x<⌊n−−√⌋ belong to the answer.

Note that we no longer need to iterate over the values ​​of k>⌊n−−√⌋, because these numbers always correspond to the values ​​0≤x<⌊n−−√⌋. Thus, it is possible, as in a naive solution, to iterate over all the values ​​of k upto ⌊n−−√⌋ and add x=⌊nk⌋ to the answer. It remains only to carefully handle the case k=⌊n−−√⌋.

Total complexity of the solution: O(n−−√logn) or O(n−−√)Algorithmic Solution

In the problem, it could be assumed that there are not so many numbers in the answer (after all, they still need to be printed, which takes the majority of the program execution time). Obviously, n always belongs to the answer. Note that as k increases, the value of x=⌊nk⌋ decreases. Thus, using a binary search, you can find the smallest value of k′ such that nk′<x. Value x′=nk′ will be the previous one for x in the answer.

Total complexity of the solution: O(n−−√logn)Solution (unreal.eugene)1263D - Secret Passwords

Idea: Stepavly

Tutorial1263D - Secret PasswordsThis problem can be solved in many ways (DSU, bipartite graph, std::set and so on). A solution using a bipartite graph will be described here.

Consider a bipartite graph with 26 vertices corresponding to each letter of the Latin alphabet in the first set and n vertices corresponding to each password in the second set. Connect each password and the letters that are part of this password with an edge. From the definition of equivalence of passwords, it is easy to understand that the answer to the problem is the number of connected components in this bipartite graph.

Total complexity: O(n).

Solution (Stepavly)1263E - Editor

Idea: Supermagzzz

Tutorial1263E - EditorTo respond to requests, you need two stacks. The first stack will contain all the brackets at the positions left than the cursor position, and the second one all the remaining ones.

Also, for each closing bracket in the first stack, we will maintain the maximum depth of the correct bracket sequence (CBS) ending with this bracket. Similarly, in the second stack, we will maintain the maximum depth of CBS that starting in this bracket. Since the brackets are added to the stack at the end and one at a time, you can easily recalculate this value.

Even in the left stack, you need to maintain the number of opening brackets that do not have a pair of closing brackets, and in the right stack the number of closing brackets that do not have a pair of opening brackets.

If the previous two values are equal, then the current line is CBS. Otherwise, there is either one non-closed bracket or one bracket that does not have an opening one.

The answer to the problem, after each query, will be a maximum of three values - the maximum depth in the left stack, the maximum depth in the right stack and the number of non-closed brackets (the number of non-opened brackets in the right stack does not need to be taken into account, since if the line is CBS, then it is the number of open brackets in the left).

Total complexity is O(n).

Solution (Supermagzzz)1263F - Economic Difficulties

Idea: AdvancerMan

Tutorial1263F - Economic DifficultiesWe assume that the leaves of the trees are numbered in the same way as the devices to which these leaves are connected.

Let's calculate costl,r (l≤r) for each tree (let's call them upperCostl,r and lowerCostl,r) — the maximum number of edges that can be removed so that on the segment [l,r] exists a path from each leaf to the root of the opposite tree. Let's calculate costl,r for some fixed l. Let's call 'bamboo' the connected set of ancestors of the node v such that each node has at most 1 child, and the node v itself is in this set. Obviously, costl,l is the maximum length of l's 'bamboo'.

Suppose we have already calculated costl,r−1. Let's calculate costl,r−1. Obviously, we can remove all edges counted in costl,r−1. We can also remove the resulting 'bamboo' of the leaf r (because we do not need to have paths from the leaves [l,r] to the root in the tree, for which we are calculating cost). Let's prove that we cannot remove more edges. For each tree exists a depth-first search from the node 1, that visits leaves in order of connection to devices, so for each node v the set of leaf indices in its subtree is a segment. If there is r in the segment for the node v, then the r-th leaf is in the subtree of the node v.

Let's have a look at the nodes whose subtree does not contain leaf r. If in their subtree there are nodes not from the segment [l,r], then we cannot remove edge to the parent of this node, because we don't want to lose the path to the root for the nodes out of the segment [l,r] (we are calculating the answer only for the segment [l,r]). So in the v's subtree leaves are only from the segment [l,r]. Leaves from the segment [l,r−1] were calculated in costl,r−1. Then the segment for the v's nodes is [i,r],l≤i. So we can remove the edge from each such node to its parent. And the set of these nodes is a 'bamboo' from the leaf r because we have already removed all 'bamboos' on [l,r−1] segment.

So to calculate costl,r it is enough to know costl,r−1 and the maximum length of r's 'bamboo'. This can be calculated in O(n(a+b)) time complexity.

Let's calculate dpi — the answer for the i-th prefix. Let's take a look at the answer: some suffix of leaves has a path to the root in only one tree, and the rest of prefix has a maximum answer (if not, then we take the maximum answer for the prefix, which will improve the answer). Then we get the formula dpi=max0≤j<i(dpj+max(upperCostj,i−1,lowerCostj,i−1)) (and dp0=0), which can be calculated in the O(n2) time complexity. Then the answer is dpn.

Challenge: Can you solve this problem with linear time complexity (for example, O(n+a+b))?

Solution (Rox)

Technocup 2020 — Elimination Round 3 + Codeforces Round 602: Editorial

By mystery, 3 years ago, In English1262A - Math ProblemWriter: RDDCCD

Tutorial1262A - Math ProblemFind the left most right point for all segments, call it rmin. The right most left point for all segments, call it lmax. It's easy to see that the answer is max(0,lmax−rmin).

1262B - BoxWriter: RDDCCD

Tutorial1262B - BoxObviously, if qi≠qi−1 then pi=qi. We assume q0=0. Other positions can be filled with the left numbers in increasing order. Then check whether the permutation is correct or not.

1261A - MessyWriter: RDDCCD

Tutorial1261A - MessyIt's easy to construct a valid bracket sequence, for example "()()()() ... (((...(())...))))".

Now let the initial bracket sequence be s, the target one be t. For each position, if si=ti then we needn't do anything, otherwise find a position j which j>i and sj=ti (it exists), and reverse the segment [i…j].

The number of operations is at most n, and the solution works in O(n2).

1261B1 - Optimal Subsequences (Easy Version)Writer: MikeMirzayanov

Tutorial1261B1 - Optimal Subsequences (Easy Version)Please, read the tutorial for the Hard Version.

1261B2 - Optimal Subsequences (Hard Version)Writer: MikeMirzayanov

Tutorial1261B2 - Optimal Subsequences (Hard Version)Let's first solve the simplified version (Easy Version) without paying attention to the efficiency of the algorithm.

It is clear that the sum of the elements of the optimal subsequence is equal to the sum of k maximal elements of the sequence a. Let the smallest (the k-th) of k maximal elements be x. Obviously, all elements of a that are greater than x and several elements that are equal to x will be included in the optimal subsequence. Among all the elements that are equal to x you need to choose those that are located to the left. Thus, a simplified version solution might look like this:

in order to build an optimal subsequence of length k, take an array a and construct its copy b sorted by non-increasing: b1≥b2≥⋯≥bn;let x=bk;we take the following subsequence from a: all the elements ai>x and several leftmost occurrences of ai=x (you need to take such occurrences in order to get exactly k elements in total).To solve the complicated version, we note that the solution above is equivalent to sorting all elements of a first of all by value (non-increasing), and secondly by position (ascending). The desired optimal subsequence is simply k first elements of a in this order.

To quickly process requests, we will use the opportunity to read all requests in the program, sort them by kj and process them in that order. Then, in order to answer the request kj, posj you need to take kj elements in this order and choose the posj-th from them (just in the order of indices). Thus, the problem is reduced to finding the pos-th element in a set, where only elements are added. This can be solved using a wide range of data structures (a tree of segments, a Fenwick tree, even sqrt-compositions), and using a non-standard tree built into g++ that supports the operation "quickly find the pos th element of a set". Below is the solution code:

#include <bits/stdc++.h>

#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp>

using namespace std;using namespace __gnu_pbds;

#define forn(i, n) for (int i = 0; i < int(n); i++)

typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

int main() {    int n;    cin >> n;    

    vector<int> a(n);    vector<pair<int,int>> b;    forn(i, n) {        cin >> a[i];        b.push_back({-a[i], i});    }    sort(b.begin(), b.end());

    int m;    cin >> m;    vector<pair<pair<int,int>,int>> req(m);    forn(i, m) {        cin >> req[i].first.first >> req[i].first.second;        req[i].second = i;    }    sort(req.begin(), req.end());

    vector<int> ans(m);    ordered_set pos;    int len = 0;    forn(i, m) {        while (len < req[i].first.first)            pos.insert(b[len++].second);        ans[req[i].second] = a[*pos.find_by_order(req[i].first.second - 1)];    }

    forn(i, m)        cout << ans[i] << endl;}1261C - Arson In Berland ForestWriters: BledDest, adedalic

Tutorial1261C - Arson In Berland ForestLet's note that if there is a possible configuration in which the forest burnt T minutes then there is a configuration when the forest burnt T−1 minutes. So we can binary search the answer.

Now we need to check the existence of the configuration for a fixed time T. Let's find all trees that can be set on fire. There are two equivalent conditions for such trees: either the square of length 2T+1 with a center in this cell contains only X-s or a distance between the current cell and any cell with "." (or border) is more or equal to T.

We can use any of the conditions. The first condition can be checked with prefix sums on 2D - we can precalculate them one time and use them to take a sum on a rectangle. The second condition can be checked by running bfs from all "."-s or borders (or from X-s which are neighboring to "."-s or to the borders) also one time before the binary search.

The second step is to check that it's possible to cover all burnt trees starting from all set-on-fire trees. We can check it either with "add value on a rectangle" (using prefix sums) since each set-on-fire tree will burn a (2T+1)×(2T+1) square with center in it. Or, alternatively, we can run bfs from set-on-fire trees.

Anyways, both algorithms have O(nm) complexity. And, since all damaged trees are shown on the map, the answer can't be more than min(n,m). So, the total complexity is O(nmlog(min(n,m))).

1261D1 - Wrong Answer on test 233 (Easy Version)Writer: RDDCCD

Tutorial1261D1 - Wrong Answer on test 233 (Easy Version)First of all, special judge for k=1, where the answer is zero.

Let d be the difference between the points for latest answer suit and the previous one. An valid answer suit means d>0.

For positions satisfying hi=hi mod n+1, the answer for this position will not affect d. Assume there's t positions which hi≠hi mod n+1.

For a fixed position i which hi≠hi mod n+1, let your answer for this position is ai . If ai=hi, then the d value will decrease by 1. We call this kind of position as a decreasing position. If ai=hi mod n+1, then the d value increase by 1. We call this kind of position as a increasing position. Otherwise d value will not be affected, we call this kind of position zero position.

Obviously the number of increasing position should be exact larger then the decreasing position. So let's enumerate the number of zero positions. We can find the answer is equal to kn−t×∑0≤i≤t−1[(k−2)i×(ti)×∑[t−i2]+1≤j≤t−i(t−ij)]. i represent the number of zero positions and j represent the number of increasing positions.

The only problem is how to calculate ∑[t−i2]+1≤j≤t−i(t−ij) quickly. Due to (nx)=(nn−x), we can tell that when t−i is odd, ∑[t−i2]+1≤j≤t−i(t−ij)=2t−i−1. Otherwise it is equal to 2t−i−(t−it−i2)2.

1261D2 - Wrong Answer on test 233 (Hard Version)Writer: RDDCCD

Tutorial1261D2 - Wrong Answer on test 233 (Hard Version)First of all, special judge for k=1, where the answer is zero.

Let d be the difference between the points for latest answer suit and the previous one. An valid answer suit means d>0.

For positions satisfying hi=hi mod n+1, the answer for this position will not affect d. Assume there's t positions which hi≠hi mod n+1.

For a fixed position i which hi≠hi mod n+1, let your answer for this position is ai . If ai=hi, then the d value will decrease by 1. We call this kind of position as a decreasing position. If ai=hi mod n+1, then the d value increase by 1. We call this kind of position as a increasing position. Otherwise d value will not be affected, we call this kind of position zero position.

Obviously the number of increasing position should be exact larger then the decreasing position. So let's enumerate the number of zero positions. We can find the answer is equal to kn−t×∑0≤i≤t−1[(k−2)i×(ti)×∑[t−i2]+1≤j≤t−i(t−ij)]. i represent the number of zero positions and j represent the number of increasing positions.

The only problem is how to calculate ∑[t−i2]+1≤j≤t−i(t−ij) quickly. Due to (nx)=(nn−x), we can tell that when t−i is odd, ∑[t−i2]+1≤j≤t−i(t−ij)=2t−i−1. Otherwise it is equal to 2t−i−(t−it−i2)2.

1261E - Not SameWriters: mystery, RDDCCD

Tutorial1261E - Not SameThe solution can be inspired by the output format :)

First of all, sort all numbers in decreasing order. Let them be A1,A2…,An. We will construct the answer column by column. Let us use a set of binary string to represent a series of operations. For example {10,10,10,11} represent operations for {4,1}(invalid, however).

Then we compress the same operations in a operation set as the number of this operation occurs. For example, {10,10,10,11} can be compressed as {3,1} as there's three 10 and one 11. Note we do not care whether the operation is, we only care how many times it occurs.

Now, as we construct the answer column by column, new numbers will be added. A new number can split some elements in the compress set. For example, we add a new 1 in {4,1} as it becomes {4,1,1}. We can turn the operation set {10,10,10,11} into {100,100,101,11}, while the compress set turns {2,1,1} from {3,1}. In general, we can turn {X} into {Y,X−Y} uses a number X(1≤Y<X). Special condition: {Y} can keep same but use number Y.

Special judge for A1=1, thus we use one operation to erase all numbers.

Obviously the first compress set is {A1}, represent operation set {1,1,1,1,…,1}.

If A1=A2, turn the second compress set as {1,A1−1,1}, otherwise turn it as {A2,A1−A2}.

Then we maintain the compress set by keeping the sum of the elements same but the number of the elements strictly increasing. For a current compress set, let X be the minimal element, and Y be the new number added. If Y<X, split X into {Y,X−Y}. Otherwise split X into {1,X−1}, the left number (Y−X+1) can be randomly placed.

The left number can be randomly placed if and if only the sum of the elements is larger then Y. Obviously the sum of the elements equals to A1 or A1+1. If the sum of the elements equals to A1, then Y≤A2<A1.

After all split operations, the compress set must be {1,1,1…,1}, which means all operation differ from each other. We can construct the final answer now in O(n2) .

1261F - Xor-SetWriter: mystery

Tutorial1261F - Xor-SetConsider a segment tree over the interval [0,260−1], a node representing a segment of length 2n would represent all numbers with the first 60−n bits same, with all possible last n bits. In other words, the binary representation of any number in the segment would be a1a2a3…a59−na60−nx1x2x3…xn, where all ai and xi is either 0 or 1. a1 to a60−n would be fixed and all xis can be arbitrarily chosen.

We can observe that if we have two segments A and B in the tree, all possible numbers that equals the xor sum of a number in A and a number in B also forms a segment in the tree, with the length of max(|A|,|B|), and the unchanging bits is equal to the xor sum of the two segment's unchanging bits.

Using this observation we would get an O((n2log21018)log(n2log21018)) or O(n2log21018) algorithm, depending on the sorting method. First, we get all segments that compose the intervals in A and B, we can get O(n2log21018) resulting segments. Then we are left with evaluating the sum in the combination of segments. We can sort these segments to get the answer. This algorithm will get an MLE in practice since the number of resulting segments could easily exceed 108.

To improve this algorithm, we can make another observation that when segments of different sizes are combined as described above, the smaller segment is equivalent to the ancestor of the same size as the bigger segment. Let's call all the segments in the decomposition of the input the "real" segments, and all segments with a "real" segment in the subtree as "auxiliary" segments. Then we could iterate over 60 possible values of the size of the segment, and for each value, we could iterate over the "real" segments of set A and "auxiliary" segments of set B and add the results to the set. We can prove that the number of both "real" and "auxiliary" segments of any size is not greater than 4n. Thus, the solution runs at O((n2log1018)log(n2log1018)) or O(n2log1018) algorithm, depending on the sorting method.

Codeforces Round #601 Editorial

By I_love_tigersugar, 3 years ago, In English1255A - Changing Volume

Author: UncleGrandpa. Prepared by UncleGrandpa

Tutorial1255A - Changing VolumeNotice that if at some moment we increase the volume and at some moment we decrease the volume, we can remove those two actions and replace them with at most two new actions that are both increasing or decreasing (for instance, +5 −1 can be replaced with +2 +2; +2 and −2 can be replaced with nothing and +2 and −1 can be replaced with +1). We can see that replacing like this will not make the volume goes below zero at any moment. So, we will increase the volume all the time, or decrease all the time.

Assume that we only increase the volume. It can be proved that for any set consists of only 1s and 2s and the sum of its elements is greater than or equal to 5, it has a subset which its elements sums to 5. This means that if we use +1 and +2 to increase the volume by at least 5, we can replace some of those actions with a +5. Hence, it is optimal to increase the volume by 5 until the gap between a and b is less than 5, then the remaining job is trivial.

1255B - Fridge Lockers

Author: I_love_tigersugar ft. MikeMirzayanov. Prepared by UncleGrandpa

TutorialModelize the problemWe modelize the problem as graph, where each fridge is a vertex and each chain is an edge between two vertexes. The problem is now equivalent to: Given a graph with n vertexes, each vertex has a value ai≥0. We have to add m edges to the graph such that each vertex is connected to at least two different vertexes and the total cost of edges added is minimum. The cost of an edge is the sum of value of its two end-points.

Observe some basic properties of graphNow, each edge added will increase the sum of degree of all vertexes by 2. So adding m edges will make the sum of degree equal to 2×m. Since each vertexes must be connected to at least 2 other vertexes, the minimum sum of degree is 2×n.

Case 1: 2×m<2×n⇔m<nIn this case, it is obvious that the answer is −1.

Case 2: 2×m=2×n⇔m=nIn this case, it is easy to see that the degree of each vertex will be exactly 2. As a result, no matter what edges we add, the result is still 2×(a1+a2+...+an). But please take note that if n=2, then the answer will be −1 since for each vertex we have at most 1 different vertex to connect to.

Case 3(Of the original, pre-modified version of the problem): 2×m>2×n⇔m>nPlease read this excellent answer by Um_nik. All credit goes to him for the excellent proof.

1255C - League of Leesins

Author: MikeMirzayanov. Prepared by UncleGrandpa

Tutorial1255C - League of LeesinsThere will be exactly 2 numbers that appear only once in the input and they are the first and the last element of the permutation. Let p1 be any of them and start with the only triple that contains p1. If x,y are the other members of the mentioned triple, there exists a unique triple that contains x,y but not p1. We can easily find that triple by searching through every triple that contains x (and there are at most 3 such triples). By repeating doing this, we can get a list r that ri=perm(pi,pi+1,pi+2).

From r, we can construct a permutation that satisfies the problem. Assume we know p1 and p2, then we can find the rest of the permutation easily. To determine which number is p2, we can use the fact p2 is the only number that only appears in r1 and r2.

1254A - Feeding Chicken

Author: I_love_tigersugar. Prepared by I_love_tigersugar

Tutorial1254A - Feeding ChickenFirst, we will try to solve the problem when our rectangle is an array (or an 1⋅n rectangle).

Let r be the number of rice cells. It's not hard to see that the difference between the maximum and the minimum number of cells with rice assigned to a chicken is either 0, when r mod k=0, or 1 otherwise. Turns out, there is an easy way to assign: for the first r mod k chicken, we will assign to the current chicken a prefix of the current array that contains exactly ⌈r/k⌉ rice cells, and delete that prefix. The same for the others k−(r mod k) chicken, we will assign to the current chicken a prefix of the current array that contains exactly ⌊r/k⌋ rice cells.

Notice that there exists a path that goes through every cell exactly once and every two consecutive cells on the path share a side. One such path is (1,1),(1,2),...(1,c),(2,c),(2,c−1),...,(2,1),(3,1),(3,2),... By thinking the path as an array, we can assign regions on the path according to the above paragraph. Such an assignment is also a valid assignment for the original rectangle.

Source code1254B1 - Send Boxes to Alice (Easy Version)

Author: MofK. Prepared by UncleGrandpa

TutorialThe problem asked you to move chocolate pieces between adjacent boxes so that the number of chocolate pieces in all boxes is divisible by k (k>1).

How to solve the problem for a specific kNow, it's clear that we will divide the array into segments, such that the sum of each segment is divisible by k, and move all chocolate pieces in that segment to a common box. Here we take notice of 2 things:

First, in each segment, let A be the array of all position with 1, then the position that we move all the 1 to is the median of that array A (easy to prove).

Second, the sum of each segment should be all equal to k. It's easy to see that if there exists some segment of sum x∗k, then separating them into x segments of sum k will improve the result.

With that two observations, we can iterate from 1 to n, push each position with value 1 into a temp array, and whenever the size of array become k, we add to our result the sum of |ai−median| and clear the array.

Knowing how to solve for a specific k, how to solve the problem?It is clear that k must be a divisor of the total number of chocolate pieces. So we iterate through all possible k and minimize our answer with the number of steps to make all numbers divisible by k. A number ≤105 has at most 128 divisors, and each calculation take O(n) so the solution should pass easily.

Source code1254B2 - Send Boxes to Alice (Hard Version)

Author: MofK. Prepared by MofK and UncleGrandpa

TutorialThe problem E2 is different from the problem E1 in some ways. Now all Ai is at most 106, and so is the number n. That makes our solution on E1 simply not usable in this problem.

A cute observation:Let Si be the sum of a1+a2+...+ai. Now we see that:

if we move a chocolate piece from box i to box i+1, it is equivalent to decrease Si by 1.

if we move a chocolate piece from box i+1 to box i, it is equivalent to increase Si by 1.

Wow, now each moving steps only affect one number. Next, we can see that if every ai is divisible by k, then so is every Si. Thus, our problem is now transformed to: Given an array S. At each turn, you can choose one Si and increase (or decrease) it by one (except for Sn). Find the minimum number of steps to make all Si divisible by k.

How to solve the problem for a specific kAn intuitive approach is to try to increase (or decrease) each Si to the nearest multiple of k. If such a configuration can be achieved then it will obviously be the best answer. The only concern is that: is there any scenario when there exists some i such that Si>Si+1, which is indeed a violation? Fortunately, the answer is no. We can enforce the solution to iterate each Si from 1 to n−1 and always choose to decrease if there is a tie. This way, the sequence S will remain non-decreasing throughout the process.

So, the solution is as follows. Just iterate from 1 to n−1 and for each i, add to our result min(Si%k,k−Si%k).

Knowing how to solve for a specific k, how to solve the problem?Again, like E1, it is clear that k must be a divisor of the total number of chocolate pieces. But now the total number of chocolate pieces is at most 1012, which an iteration through all divisors will not be fast enough to fit in 1 second. (In fact, we did make just one single test case to block this solution. Nevertheless, on random testcases it runs super fast).

But if you have solved the problem to this phase already, you can easily realize that we only need to consider prime k, because if k is composite then picking any prime divisors of it will lead to either a better result or an equal result.

That's it, there will be at most 12 distinct prime divisors. Each calculation takes O(n). So the solution will also pass easily.

Source code1254C - Point Ordering

Author: ngkan. Prepared by ngkan

Tutorial1254C - Point OrderingLet's start by choosing vertices 1 and 2 as pivots.

Recall that if the cross product of two vectors A⃗  and B⃗  is positive, point B lies to the left of A⃗ ; if the product is negative, point B lies to the right of A⃗ ; and if the product is zero, the 3 points (0,0), A, B are collinear.

With n−2 queries of type 2, we can know which vertices lie to the left or to the right of edge 1−2 and then solve the two sides separately.

Consider the left side and there are a vertices lie to the left, we can use a queries of type 1 to calculate the distance from those vertices to edge 1−2 (the distance from vertex X to edge 1−2 is twice the area of the triangle forms by 1, 2, X, divides by the length of edge 1−2).

Let Y be the farthest from 1−2 (there can be at most 2 such vertices). We can use a−1 queries of type 2 to see if the others vertices lie between 1,Y or between Y,2, then sort them counter-clockwise with the asked distances.

So we will use n−2 queries to calculate the distances from vertices 3,4,..n to edge 1−2 and at most n−3 for the latter step. This solution uses at most 3n−7 queries.

Another solution is to find the vertex that is consecutive to 1 in n−2 queries and do the same as the solution above.

Source code1254D - Tree Queries

Author: I_love_tigersugar Prepared by I_love_tigersugar

Tutorial1254D - Tree QueriesDisclaimer: Our other authors and testers have found better solutions; our best complexity is O(n×log2(n)). However, since this solution is the theoretically worst complexity that we intended to accept, I decided to write about it. Feel free to share your better solution in the comment section :)

Consider two distinct vertices u, v, the number of vertices r such that the path from r to u passes through v is n−|Tree(v,u)|, where Tree(v,u) is the subtree we get by cutting the first edge on the path from v to u, then keep the part with vertex u. If u=v then this value will be n. By linearity of expectation, we can see that adding d to a[v] will add to the expected value of a[u] an amount equal to 1n×d×(n−|Tree(v,u)|). Note that this value is the same for all u that lies on the same "subtree branch" of v. To update it efficiently, we can split the vertices into 2 groups: those which has degree greater than T (there are no more than nT of them), and those which does not. When we update a "light" vertex v, we iterate over the neighbors of v and update the subtrees accordingly. When we get the value of a vertex v, we already have the sum of contributions from all "light" vertices to v, hence we can iterate over all "heavy" vertices and calculate the contribution from each of them to v.

If we use range-update point-query data structures such as Fenwick Trees then the complexity will be O(Q×log(n)×(nT+T))=O(Q×n−−√×log(n)) if we choose T=O(n−−√).

Source code1254E - Send Tree to Charlie

Author: MofK Prepared by: MofK

Tutorial1254E - Send Tree to CharlieLet's solve an easier version of this problem first: when all ai is equal to 0. Let P[1..n−1] be some order of edges. If n=2 then the answer is clearly 1. Otherwise, consider any leaf u and its neighbor v. The label of u in the end will depend solely on the relative position of the edge (u,v) compared to other edges incident to v in P. We can also prove that if that relative position is fixed then the final configuration will be the same. Therefore, if we add u to the tree, the answer will be multiplied by deg(v). It follows that the answer in this case will be ∏u=1ndeg(u)!. We can also see that each configuration can be obtained by ordering the edges incident to u for each vertex u.

Now, let's consider some constraint of the form a[u]=v. If u=v then clearly there's no such configuration. Otherwise, it will create some conditions of the orderings in each vertex. Formally, let B(u) be the ordering of edges incident to u, and u,t1,…,tk,v be the path from u to v, we have the following conditions:

(u,t1) is the first edge in B(u).(ti,ti−1) must be followed immediately by (ti,ti+1) in B(ti), for all 1≤i≤k.(v,tk) is the last edge in B(v).Another thing to note is that in the final configuration, the sum of distance between u and the vertex that contains label u will be exactly 2n−2 because each swap increases the sum by exactly 2. Therefore, we can quit immediately upon finding out that the sum is larger than 2n−2, and by that we ensure the total number of conditions will be O(n).

Now, we can solve each vertex independently. For each vertex, there will be no possible configurations iff at least one of the following holds:

Some edge follows or is followed by more than one edge.The conditions create some cycles.The conditions create a path from the first edge to the last edge, but there exists some edge not in it.Otherwise, the conditions create some chains. We then multiply the answer by k!, where k is the number of such chains, excluding those that contain the first edge or the last edge.

Time complexity: O(n).

Source code



