Codeforces Round #800 Editorial

By Keshi, 8 months ago, In English1694A - ЖутьIdea: AmShZ

Solution1694A - CreepDefine the minimum possible creepiness of the string as ans. We want to show that ans is equal to max(1,|a−b|).

Creepiness of S[1…1] is equal to 1 and creepiness of S[1…n] is equal to |a−b| so max(1,|a−b|)≤ans.The way to make a string with creepiness equal to max(1,|a−b|):while 0<a,b holds, add 01 to the end of the string. After that, add the remaining character to the end of the string. Now we know ans≤max(1,|a−b|).

So ans=max(1,|a−b|).complexity: O(a+b)Implementation1694B - Параноидальная строкаIdea: AmShZ

Solution1694B - Paranoid StringWe want to show that a binary string T of length m is paranoid if and only if m=1 or (1<m and S[m]≠S[m−1]).

In the case of S[m−1]=S[m]: We can never delete the last two characters because they will always remain equal. So S is not paranoid.In the case of S[m−1]≠S[m]: If m=2, we can reach our goal by one operation. Otherwise assume that the last character is 0. Now the last three characters are either 010 or 110. In the first case perform the operation on [Sm−2,Sm−1] and in the second case perform the operation on [Sm−1,Sm]. Then the last two characters will be 10 and we can continue this algorithm on the new string until we reach m=1.The number of paranoid substrings of length 1 is equal to n. To count the number of longer substrings, we can fix r from index 2 to n. if S[r]≠S[r−1] holds, we should add r−1 to the answer.

complexity: O(n)Implementation1693A - Ориентированное увеличениеIdea: alireza_kaviani

Solution1693A - Directional IncreaseFirst of all the sum of the elements has to be 0 because the pointer has to end up on the first element.

Denote the number of times you do the first operation while the pointer is on the i-th element as bi. And the number of times you do the second operation while the pointer is on the i-th element as ci.

ai=bi−ci and ci=bi−1 because the pointer has to end up on the first element.

So ai=bi−bi−1→bi=ai+bi−1 and b1=a1.

Now that we have calculated b, we need to determine whether it's possible to perform the operations like so.

There are two conditions.

bi≥0 (1≤i≤n).If bi=0 for each j, i<j, bj=0. Because the pointer couldn't reach the j-th element.You can always construct a if these two conditions hold.

Proof by induction. Perform the first operation and the second operation b1−1 times in a row. Then perform the first operation. Construct the rest by induction and then perform the second operation.

Time complexity: O(n)Implementation1693B - Фейковые пластиковые деревьяIdea: AmShZ, alireza_kaviani

Solution1693B - Fake Plastic TreesLemma 1. You won't perform the operation on a particular vertex more than once. Because you could merge the operations.

Lemma 2. If you perform the operation on some vertex v, you can do it with ck=rv. If there is another operation that helps this vertex, you can cut the operation into two pieces and merge one with the operation that starts at v. And you can just increase ck if it's not equal to rv.

Define dpv as the minimum number of operations needed to satisfy the conditions on the vertices in the subtree of vertex v.

We claim that there is a way to achieve our goal with minimum number of operations in which for each vertex v there are exactly dpv operations done in the subtree of vertex v.

Imagine there is a vertex v that there are more than dpv operations on vertices in the subtree of vertex v. We can instead satisfy the subtree by dpv operations and make sure that we perform the operation on vertex pv.

Denote mxv as the maximum value that vertex v can pass to its ancestors if exactly dpv operations are performed in the subtree of vertex v.

We need to perform the operation on a vertex v if and only if ∑u|pu=vmxu<lv.

If we need to perform the operation on vertex v then mxv=rv, otherwise mxv=min(rv,∑u|pu=vmxu).

Time complexity: O(n)Implementation1693C - Keshi ищет AmShZIdea: AmShZ

Solution1693C - Keshi in Search of AmShZDefine disv as the minimum number of days needed to reach city n from city v. disn=0.

We have to assume that Keshi will always choose the worst reachable city, that is the city with maximum dis.

For each node v we kind of have to choose nxtv and block all neighbors(outgoing edges) with a distance more than disnxtv.

We will use Dijkstra's algorithm.

Note that in Dijkstra's algorithm we mark the nodes in increasing order of dis.

At each step get the node v with the minimum dis. For each node u that there is an edge from u to v, calculate disu if nxtu was v. You know the number of edges you have to block since the neighbors with greater dis are the ones that are not marked yet.

Time complexity: O(nlogn)Implementation1693D - Разбиение на возрастающую и спадающуюIdea: AmShZ

Solution 11693D - Decinc DividingLet's solve the problem for a single subarray.

Assume the i-th element belongs to the increasing subsequence. Define dpl,i for the interval [l,i] as the maximum value the last element of the decreasing subsequence can have. It's +∞ in case the decreasing subsequence is empty. It's −∞ if the array is not possible.

Assume the i-th element belongs to the decreasing subsequence. Define pdl,i for the interval [l,i] as the minimum value the last element of the increasing subsequence can have. It's −∞ in case the increasing subsequence is empty. It's +∞ if the array is not possible.

The interval [l,r] is not Decinc if and only if dpl,r=−∞ and pdl,r=+∞.

Iterate over l from n to 1 and keep the dp and pd values updated (shown in the implementation).

We claim that each dp or pd value will change at most three times throughout the algorithm.

For some index i assume j is the largest index smaller than i such that aj>aj+1.

dpi can only be one of these four values: −∞,+∞,aj,aj+1.

Because the last element of the decreasing subsequence can't be before the j-th element. And if it's some k that lies on the interval [j+2,i−1] you can simply move it to the increasing subsequence since both (k−1)-th and (k+1)-th elements belong to the increasing subsequence.

The same applies for pdi.

So the upd function is called O(n) times in total.

Time complexity: O(n)Thanks to Koosha_Mv

Solution 2It can be proven that a permutation is Decinc if and only if it's 3412-avoiding and 2143-avoiding.

Implementation 1Implementation 21693E - Крайние максимумыIdea: Keshi

Solution1693E - Outermost MaximumsLet's calculate for each element of the array, the minimum number of times it needs to change throughout the process.

Let's take a look at the first time the i-th element is changing. We know that ai is the maximum number and the elements smaller than ai haven't changed yet.

Denote the maximum element on its left as l and the maximum element on its right as r.

So l is equal to the largest number among a1,a2,…,ai−1 that is smaller than ai. Likewise for r.

We can change ai to either l or r. It's better to change it to the smaller one. (We'll get into the details of why this is correct later.)

Let ci be the minimum number of times the i-th element needs to change. The following greedy algorithm works in ∑ci operations.

Let x be the number the leftmost maximum becomes if we do the first operation and y be the number the rightmost maximum becomes if we do the second operation.

Do the first operation if x≤y and do the second operation otherwise. If x≤y then for the leftmost maximum, the maximum element on its left is smaller than the maximum element on its right. That means we are making the right choice for this element.

Let's assume the array is a permutation of numbers from 1 through n for simplicity.

For some element ai make string S of length n such that

Sai = "O".for any j<i, Saj = "L".for any j>i, Saj = "R".Imagine Yeri is initially standing on the ai-th character of S (which is "O") and she is facing the beginning of the string.

In each step she either jumps to the nearest "L" or jumps to the nearest "R". And her goal is to jump out of the string in minimum number of jumps. We know it's always better to jump to the further one, but we won't need this fact.

We will use a segment tree. For each node maintain 4 values. What is the minimum possible number of jumps made in this interval in case

we enter it looking for an "L" and leave it looking for an "L"we enter it looking for an "L" and leave it looking for an "R"we enter it looking for an "R" and leave it looking for an "L"we enter it looking for an "R" and leave it looking for an "R"It's easy to update this. Just fix which character you are looking for when moving from the node's one child to the other. And you can find these values for intervals of length 1.

Now if you iterate over i from 1 to n. At each step at most 2 characters of the string are changing, hence you can keep your segment tree updated.

But there are still some details we need to sort out. The array is not necessarily a permutation. To fix this, first get rid of the "O". Then for each number see if it appears on the left side and see if it appears on the right side. Now there are 4 different states for each number but the same segment tree can handle this too. We just need to find the 4 values for each of the 4 states of a single number.

Time complexity: O(nlogn)ImplementationCheck out this solution by ecnerwala

1693F - Я могу ошибатьсяIdea: AmShZ

Thanks to antontrygubO_o for proof

Solution1693F - I Might Be Wrong- It's trivial that we only sort with segments with balance 0.

Proof: Imagine we have sorted interval [l,r] and it has d more zeros than it has ones. So this operation costs d+1 coins. Sl has to be 1 otherwise we could just sort [l+1,r] with d coins.

Now that we know Sl is 1 there exists some k≤r that the interval [l,k] has equal number of zeros and ones. Because the interval [l,l] has more ones but the interval [l,r] has more zeros.

Sort [l,k] with cost 1 and then sort [l+1,r] with cost d. And we know we can sort [l+1,r] such that we only sort segments with balance 0.

- If everything is sorted cool. Suppose now the number of ones is greater than the number of zeros.

- Replace 0 by −1, 1 by 1, draw prefix sums. We have n+1 points (i,ai), (initially ai=prefi), where a0=0, an>0, and the operation is: choosing i, j such that ai=aj and making points between them first decrease then increase.

Denote by AmShZ strategy the following procedure: while S isn't sorted,

Let i be the smallest such that numbers from ai to an increase.If ai≤0, we sort in 1 operation.Otherwise, let j be the smallest such that aj=ai. Apply operation to [j,i].We have to show that AmShZ strategy is optimal.Let's denote by f(S) the smallest number of operations required for the current configuration. We will prove that AmShZ strategy ends in f(S) iterations by induction over n and over number of inversions in S. (Clearly any non-identical operation decreases number of inversions so that's useful).

Denote by Sk string S in which suffix of length k is sorted.

Lemma 1: If k1>k2, then AmShZ strategy for Sk1 uses at most as many operations as for Sk2. Proof: trivial

Suppose now that we have proved our statement for all strings with the number of inversions less than in S.

Now, let i be the smallest such that numbers from ai to an increase and j be the smallest such that aj=ai.

Suppose that there is a sorting sequence that uses fewer operations than AmShZ strategy. Let's denote its first operation by [l,r].

Consider several cases:

r≥i. This means that we basically end up in string Sn−l. But we could have ended up in string Sn−j, which uses at most the same number of operationsr≤j. Clearly, after operation [l,r] ai can only decrease, so j will still be the smallest index with aj=ai. By induction hypothesis, AmShZ strategy is optimal for resulting string, so the next operation in resulting string will be opertion [j,i]. But then we could have done [j,i] first and then [l,r].j≤l. As r<i, the smallest index i such that ai… an are increasing hasn't changed. Numbers from a0 to aj also haven't changed, so j remains the same. So the next move according to AmShZ strategy will be operation [j,i], so operation [l,r] was uselessLast case. l<j<r<i. Note that all numbers up to ar will be strictly smallest then ai now. So we will have some new smallest j1>r such that aj1=ai. Then according to AmShZ strategy in the next move we will do operation [j1,i].But then we could instead do [j1,i] first, and then [l,r]. But this is not optimal, as AmShZ strategy sorts Sn−j1 at least as fast as Sn−i.

Implementation by Um_nikThanks to Um_nik

Codeforces Round #799 (Div. 4) Editorial

By flamestorm, 9 months ago, In EnglishThanks for participating!

1692A - Marathon

Idea: mesanu

Tutorial1692A - MarathonWe can re-word the problem to count the number of numbers from b,c,d that are larger than a. A possible way to do this is by keeping a variable that gets incremented every time we checked using the if statement whether a number is larger than a. The complexity is O(1).

Solution1692B - All Distinct

Idea: mesanu

Tutorial1692B - All DistinctNote that the size of the array doesn't change parity, since it always decreases by 2. Let's count the number of distinct elements, call it x.

If x is the same parity as n (the length of the array), then we can make sure all of these x distinct elements stay in the array by removing two elements at a time.

Otherwise, x isn't the same parity as n. Then x−1 is the same parity as n, and we can make sure x−1 distinct elements stay in the array by removing two elements at a time. So the answer is x if x and n have the same parity, and x−1 otherwise.

For example: [15,16,16,15] has x=4, n=2. So x and n have the same parity, and we can get all distinct numbers [15,16] by removing i=3, j=4.

Time complexity: O(nlogn) or O(n), depending on the implementation.

Solution1692C - Where's the Bishop?

Idea: flamestorm

Tutorial1692C - Where's the Bishop?There are many ways to solve the problem. One way is to look for the following pattern:X.X.X.X.XThere can only be one such pattern if there is one bishop and it's not on the edge of the board. We can iterate through all cells and see if we can match this pattern, and if we can we output the centre cell.

You can also look at the positions of the two diagonals and intersect them, but it requires more implementation.

Time complexity: O(1) per testcase.

Solution1692D - The Clock

Idea: SlavicG

Tutorial1692D - The ClockNote that Victor looks at the clock forever, but there are only at most 1440 different times the clock can show (because there are 1440 different minutes in a day). So we only have to check the first 1440 times Victor sees, and count the palindromes (you can check a few more just to be safe, but they will repeat anyways).

Now we just have to implementing adding x minutes to a clock. There are several ways to do this. One of the slower ways might be writing functions converting a number of minutes into a time for a clock, or you can just compute all palindrome times in terms of minutes and that way you don't have to convert from clock time to number of minutes.

The complexity is O(1) per test case, since you only have to check a constant number of times.

Solution1692E - Binary Deque

Idea: flamestorm

Tutorial1692E - Binary DequeNote that the remaining array is a subarray of the original array. There are many ways to approach the problem. Here is one solution, which the main solution uses:

Compute prefix sums on the array, so we can find out the value of al+⋯+ar quickly. Let's iterate through the left endpoint l from 1 to n. Afterwards, we can binary search on the smallest value of r such that al+⋯+ar=s, since this sum is strictly increasing.

The time complexity is O(nlogn).

Solution1692F - 3SUM

Idea: flamestorm

Tutorial1692F - 3SUMSince we only care about the last digit of the sum ai+aj+ak, we can ignore all numbers other than the last digits of the elements of a. (For example, we can consider [20,22,19,84] to be the same as [0,2,9,4].)

Now note that if a number appears more than 3 times in the array, we can ignore all copies that occur more than 3 times, since our sum ai+aj+ak only involves three numbers. (For example, we can consider [1,1,1,1,2] to be the same as [1,1,1,2].)

Using these observations, note that there are only 10 digits, and each digit can occur at most 3 times. So we can always reduce the array to one of length 30. Since 30 is very small, we can brute force all triples ai+aj+ak, which runs quickly enough.

Time complexity: O(n+min(n,30)3).

Solution1692G - 2^Sort

Idea: flamestorm

Tutorial1692G - 2^SortNote that 2x⋅ai<2x+1⋅ai+1 is the same as ai<2ai+1, since we can divide by 2x. This means that we only need to check whether ai<2ai+1 for each pair of adjacent elements.

Let's consider as an example [20,22,19]. Note that 20<2⋅22 and 22<2⋅19, so if you multiply the first element by 1, the second by 2, and the third by 22, the array is sorted.

So let's make a new array b where bi=1 if ai<2ai+1 and bi=0 otherwise. Then we know that the whole chain of inequalities holds true if all values in a subarray of length k in b have all their values equal to 1.

For example, if a=[9,5,3,2,1], b=[1,1,1,0]. Say k=2. Then [9,5,3] works, since [9,5⋅2,3⋅22] is sorted. We can write this as 9<2⋅5 and 5<2⋅3. This is equivalent to b1=1 (since a1<2a2) and b2=1 (since a2<2a3).

So the problem is equivalent to counting the number of subarrays of length k in b whose elements are all equal to 1. There are many ways to do this. For example, you can compute prefix sums and then find the sum of all subarrays of length k, and count the number whose sum is k. The model solution uses a sliding window and updates the number of ones in the current subarray as we move from left to right.

Time complexity is O(n).

Solution1692H - Gambling

Idea: mesanu

Tutorial1692H - GamblingThere are several solutions. Here is one.

If we fix the value of a, then let's make a new array b as follows: bi=1 if roundi=a, and bi=−1 otherwise. Then the total amount of money earned will just be 2bl+⋯+br, so we only need to maximize bl+⋯+br. In other words, we need to find the maximum sum of a subarray. This is a standard problem that can be solved using segment tree.

Note that we need to iterate over all values of a, of which there are n possibilities. So we have to update elements of the segment tree O(n) times and query once for each a, which means overall the solution runs in O(nlogn).

Solution

Editorial for Codeforces Round #798 (Div. 2)

By n0sk1ll, history, 9 months ago, In English1689A - Lex StringAuthor: wxhtzdy

HintSolutionWe can't take the smallest character in both strings when we've already took k elements from the string we chose. Denote A as the number of characters we've took from string a in the last few consecutive moves and denote B the same for b. If A=k, then we have to take the smallest character in string b instead of possibly a. If B=k, then we have to take the smallest character in string a instead of possibly b.

Remember to reset A to 0 when you take a character from b. Similarly, reset B to 0 when you take a character from a.

C++ Code1689B - Mystic PermutationAuthor: n0sk1ll

Hint 1Hint 2SolutionThe exception is the last two elements. We can always take the smallest available number for each qi satisfying i<n−1. To do this we maintain an array of bools of already taken numbers, and then iterate over it to find the smallest available number satisfying pi≠qi which is also not checked in the array, and then check it (we took it).

Now consider (pn−1,pn) and we want (qn−1,qn) to be lexicographically minimal while satisfying pn−1≠qn−1 and pn≠qn. Let a and b be the last two unused numbers in the array of bools with a<b. We try to take (qn−1,qn)=(a,b). If a=pn−1 or b=pn, then we take (qn−1,qn)=(b,a). If (a,b) isn't valid, then (b,a) is. The proof is left as an exercise to the reader.

This solution runs in O(n2) and can be optimized to O(n log n).

C++ Code (Main solution)C++ Code (O(n) solution)Riblji_Keksic found the O(n) solution.

1689C - Infected TreeAuthor: n0sk1ll

Hint 1Hint 2SolutionLet u1,u2,...,uk be the sequence of removed vertices such that the infection cannot spread anymore. If vertex ui was never directly connected to an infected vertex, then we could have deleted its parent instead of ui and we would have got a better solution. Hence, we may assume we always delete a vertex directly connected to an infected one.

Now, we may use some dynamic programming ideas. Let dpi be the maximum number of vertices we can save in the subtree of vertex i if that vertex is infected and we use operations only in the subtree. We can assume the second as the tree is binary and we have two choices — save the subtree of one child by deleting it and infect the other, or the other way around. In each case, the infection will be "active" in at most one subtree of some vertex.

If c1 and c2 are the children of vertex i, the transition is

dpi=max(dpc1+s2−1,dpc2+s1−1)where si denotes the number of vertices in the subtree of i.

The answer to the problem is dp1. Complexity is O(n).

C++ Code1689D - Lena and MatrixAuthor: n0sk1ll

HintSolutionConsider this algorithm: iterate over all squares in the matrix and find the most distant black square.

Let's find out how to do that efficiently. In fact, only 4 (not necessarily distinct) black squares will be useful: one square which minimizes i−j, one square which maximizes i−j, one square which minimizes i+j and one square which maximizes i+j, where (i,j) denotes the black cell's coordinates. In other words, we would like to find the most distant "border".

 

Let's look at the example above. The cell we choose to recolour to yellow creates four regions (the top-left rectangle, the top-right rectangle, the bottom-left rectangle and the bottom-right rectangle, which are created by two lines parallel with coordinate axes passing through our yellow point). The most distant border will be fully contained inside one region, hence we should find the distance from our yellow cell to any cell on that border, and that is the maximum possible distance.

The complexity is O(n⋅m).

C++ Code1689E - ANDfinityAuthor: wxhtzdy

Stupid HintHint 1Hint 2Hint 3SolutionFirslty, let's understand how to check whether the graph induced by some array b is connected in O(n log max bi). We create a graph over bits. Let's take all elements bi and add an edge between their adjacent bits (all bits of a single bi will be connected). To quickly access the lowest bit we will use bi & −bi in code. Now we just check whether the graph over bits is connected.

We check whether the graph for initial array a is connected. If it is, the answer is 0.

Then, we wonder if the answer is 1. Check if at least one of the graphs for arrays a1,...,ai−1,ai−1,ai+1,...,an for every 1≤i≤n is connected. Do the same for arrays a1,...,ai−1,ai+1,ai+1,...,an. If none of the graphs is connected, the answer is 2 and otherwise 1.

Now let's see how the answer will be at most 2. Let i1,i2,...,ik be the sequence of indices denoting that aij has the highest lowest bit (the highest value of ai & −ai). if k=1 then we can just decrease ai1 by 1 and connect everything. If k≥2 and we do the same we might disconnect that number from other numbers having the highest lowest bit, thus an additional operation of adding 1 to ai2 is needed to keep everything connected. The answer is 2 in this case.

Complexity of this solution is O(n2 log max ai).

C++ Code

Codeforces Round #797 (Div. 3) Editorial

By Aris, history, 9 months ago, In English1690A - Print a Pedestal (Codeforces logo?)

Idea: MikeMirzayanov

Tutorial1690A - Print a Pedestal (Codeforces logo?)In the n≤105 constraints, the problem can be solved by brute force: we will go through the value for h1 (the height for the first place), and then select suitable values for h2 and h3. Since h2>h3, we divide the remaining n−h1 blocks equally between h2 and h3. If it turns out that h2=h3, then we try to decrease h3 by 1 and increase h2 by 1. If we get the right answer (h1>h2>h3>1), output the heights and stop the process. We will go through the value of h1 in order of increasing.

Solution1690B - Array Decrements

Idea: MikeMirzayanov

Tutorial1690B - Array DecrementsFor all elements of the arrays to become equal after subtraction of units, ai>=bi for 1≤i≤n must be satisfied. In addition, if there exists bi>0, then the equality ai=bi can be obtained only by subtracting exactly ai−bi units from ai. Since the equality ai=bi must be satisfied for all i, the problem is reduced to checking that for bi>0 all differences ai−bi=dif are equal and for bi=0 the difference does not exceed dif.

Solution1690C - Restoring the Duration of Tasks

Idea: MikeMirzayanov

Tutorial1690C - Restoring the Duration of TasksAccordingly, as it was said in the task, we put all tasks into the queue in the order of their arrival, then we fix the time at the beginning as cur_time=0. So, while there is a task in the queue, we proceed as follows:

Take the task from the queue.Take as time the maximum from the current and from the arrival time of the task (cur_time=max(cur_time,s)).We subtract the current time from the time when the task was done (f=d−cur_time).Replace the current time with the time the task was done (cur_time=d)If there is a task in the queue, go to item 1.Solution1690D - Black and White Stripe

Idea: MikeMirzayanov

Tutorial1690D - Black and White StripeTo obtain a segment of k cells of black color, we need to paint all the white cells of the segment black. Then go through all the segments of length k (there are only n−k) and choose such a segment among them that the number of white cells on it is minimal. You can quickly find out the number of white cells in the segment by prefix sums.

Solution1690E - Price Maximization

Idea: Vladosiya, Aris

Tutorial1690E - Price MaximizationNote that we do not need to consider the numbers x≥k, we are only interested in the remainder of the division of x by k, and we simply add the value ⌊xk⌋ to the answer.

We get an array a, where ai<k. Let's sort it and greedily type index pairs i<j such that ai+aj≥k. This can be done with two pointers. Then add the number of matching pairs to the answer counter. This will be the answer to the problem.

Solution1690F - Shifting String

Idea: MikeMirzayanov

Tutorial1690F - Shifting StringTo begin with, let's understand why the string will return to its original form. In fact, the graph that the permutation sets consists of simple cycles and it turns out that after a certain number of operations, each character will return to its place.

Consider each cycle as a string that is cyclically shifted every turn. It may seem that the answer is  — lcm (the smallest common multiple) of the cycle lengths, but to become equal to the initial string, it is not necessary to go through the entire cycle. The constraints allow us to calculate the length of the minimum suitable shift kj in O(len2), where len is the length of the cycle, so just iterate over the desired shift. Note that after kj operations, the cycle will return to its original form and this will happen again after kj operations.

The answer will be lcm of all kj, since each cycle individually comes to its original form after the number of operations is a multiple of its kj.

Solution1690G - Count the Trains

Idea: Aris

Tutorial1690G - Count the TrainsIn the set we will keep the indices that start the trains. That is, if the array v — the real speeds of the carriages, then we will store in the network such values 2≤i that v[i]<v[i−1]. As well as the value of 0. Thus, the size of the set —is the answer to the problem.

Consider now the operation to reduce the speed of the carriage: find such maximal index j≤k in the set, if the value ak<aj, then we should add the value k to the set, since it will start a new train. Then we should remove all subsequent indexes j from the set such that ak<aj. Thus, for all operations we will add no more than n elements to the array, and remove in total no more than 2⋅n elements from the set. We obtain the asymptotic O(m⋅logn).

Solution

Editorial of Codeforces Round 796

By huangzirui, history, 9 months ago, In English
1688A - Cirno's Perfect Bitmasks Classroom

Idea: huangzirui. Solution: huangzirui. Preparation: huangzirui.

Good problem  852
Average problem  86
Bad problem  69
Did not solve  75

Hint
Solution
Let pi
 be the i
-th bit of x
, qi
 be the i
-th bit of y
 (both indexed from 0
).

x and y>0⇔∃i, pi=qi=1
.

x xor y>0⇔∃i, pi≠qi
.

To satisfy the first condition, find the minimum integer k
 satisfying pk=1
, and assign 1
 to qk
.

If x≠2k
, the second condition is satisfied now. Otherwise, find the minimum integer j
 satisfying pj=0
, and assign 1
 to qj
.

The time complexity is O(1)
.

Code (C++)
Code (Python)
Apology
1688B - Patchouli's Magical Talisman

Idea: Yakumo_Ran. Solution: Yakumo_Ran. Preparation: SSerxhs.

Good problem  646
Average problem  82
Bad problem  46
Did not solve  38

Hint1
Hint2
Solution
Let g(x)
 be the maximum integer satisfying 2g(x)|x
.

A greedy solution is to make one integer odd integer, and plus it to other even integers. Let f(a)
 be the answer of an sequence an
.

We can find that:

f(a)={∑[g(ai)>0]−1+min{g(ai)}∑[g(ai)>0]∀i, g(ai)>0otherwise=∑[g(ai)>0]+max{0,min{g(ai)}−1}
It can be shown that it is the optimal strategy.

We can prove that f(a)
 decreases by at most 1
 with one operation.

For the first operation, assuming we choose ai
 and aj
, let ak=ai+aj
. Obviously g(ak)≥ming(ai),g(ai)
 holds, so ∑[g(ai)>0]
 decreases by at most 1
, and ming(ai)
 does not decrease. So f(a)
 decreases by at most 1
.
For the second operation, assuming we choose aj
. If g(aj)=ming(ai)>1
, max0,ming(ai)−1
 decreases by 1
 and ∑[g(ai)>0]
 remains unchanged. Otherwise max0,ming(ai)−1
 does not change and ∑[g(ai)>0]
 decreases by at most 1
. So f(a)
 decreases by at most 1
.
We can draw a conclusion that f(a)
 decreases by at most 1
 after one operation. Since f(a)=0⇔
 ai
 are odd integers, the strategy is proved to be optimal.

The time complexity is O(n)
.

Code (C++)
Spoiler
1688C - Manipulating History

Idea: Yakumo_Ran. Solution: Yakumo_Ran, SSerxhs. Preparation: SSerxhs.

Good problem  448
Average problem  25
Bad problem  844
Did not solve  180

Hint1
Hint2
Hint3
Hint4
Hint5
Solution
Let t
 be the unshuffled operation sequence.

Consider a single letter c
 that has ever appeared in s
 (there are 1+∑i=1n|t2i|
 letters). There are two possible situations:

c
 is in the initial string. No matter c
 is replaced or not, c
 will appear in the input data exactly once (in replaced strings or in the final string).
c
 is not in the initial string. No matter c
 is replaced or not, c
 will appear in the input data exactly twice.
So the answer is the only letter appearing odd times in the input data.

The time complexity is O(∑|si|+|t|)
.

Code (C++)
Code (Python)
1687A - The Enchanted Forest

Idea: Yakumo_Ran, SSerxhs. Solution: Yakumo_Ran. Preparation: SSerxhs.

Good problem  579
Average problem  102
Bad problem  108
Did not solve  118

Hint1
Hint2
Hint3
Solution
If k≤n
:

Consider how to maximize the initial mushrooms she collects. Obviously she will not walk into one position more than one times, and the answer is maxk≤i≤n∑j=i−k+1iaj
.

Consider how to maximize the additional mushrooms she collects. Obviously she will not walk into one position more than one times, and the answer is k(k+1)2
.

We can find that maximizing the two parts shares the same strategy. So add up the answers of the two parts.
If k>n
:

Consider how to maximize the initial mushrooms she collects. Obviously she can collect all of them. The answer is ∑i=1nai
.
Consider how to maximize the additional mushrooms she collects. Let bi
 be her position on minute k−i
 (0≤i<n
). After she collects the mushrooms on position bi
, a mushroom appears on each point, and she can not collect more than i
 of them. In other words, she leaves at least ∑i=0n−1(n−i)=n(n+1)2
 mushrooms in the forest. Let bi=i+1
, she will leave exactly ∑i=0n−1(n−i)=n(n+1)2
 mushrooms in the forest.
We can find that maximizing the two parts shares the same strategy. So add up the answers of the two parts.
The time complexity is O(n)
.

Code (C++)
Code (Python)
1687B - Railway System

Idea: Yakumo_Ran. Solution: Yakumo_Ran, huangzirui. Preparation: SSerxhs.

Good problem  300
Average problem  22
Bad problem  38
Did not solve  80

Hint1
Hint2
Hint3
Solution
We can get the lengths of each edge using m
 queries by asking the maximum capacity of each edge separately.

Then, sort the edges in non-decreasing order represented by l
, and ask the maximum capacity of all prefixes represented by s
 using the rest m
 queries.

Consider the process of Kruskal's algorithm. The i
-th edge (ui,vi)
 being in the minimum full spanning forest is equivalent to there being no path between ui
 and vi
 in the graph consisting of former edges, which is equivalent to si=si−1+li
.

Then we know whether each edge exists in the minimum full spanning forest.

The time complexity is O(m2)
.

Code (C++)
Code (Python)
1687C - Sanae and Giant Robot

Idea: Yakumo_Ran. Solution: Yakumo_Ran. Preparation: huangzirui, SSerxhs.

Good problem  171
Average problem  7
Bad problem  28
Did not solve  150

Hint1
Hint2
Solution
Let si=∑k=1iak−bk
. The task can be described as:

Given an array s
. For some given interval [l,r]
 if sl−1=sr
, we can assign sr
 to si
 (l≤i<r
). The goal is to make si=0
 (0≤i≤n
).

Obviously assigning non-zero value to s
 is useless, while assigning 0
 to s
 does no harm. Therefore, we can repeatedly choose any interval [l,r]
 satisfying sl−1=sr=0
, and assigning 0
 to all non-zero si
 (l≤i<r
) until there is no such interval. We can use set in C++ or disjoint set or segment tree to find such i
.

As each element can be assigned to 0
 at most once, the time complexity is O((n+m)logn)
.

Code (C++)
Spoiler
1687D - Cute number

Idea: Yakumo_Ran. Solution: huangzirui. Preparation: SSerxhs, huangzirui.

Good problem  73
Average problem  6
Bad problem  18
Did not solve  97

Hint1
Hint2
Solution
For any integer x
, iff we can find w
 satisfying x∈[w2,w2+w]
, we have x−w2<(w+1)2−x
, which means x
 is beautiful. Define f(x)=w
.

It is easy to find that k≤a2n
, and there are only an
 useful w
 because w≤an
.

Enumerate f(a1+k)
 (f(a1+k)≤an
), and calculate the range of ai+k
 in order. It can be shown that the range is an interval for all 1≤i≤n
. So we can solve this problem in O(nan)
.

We call i
 a jump if f(ai+k)≠f(ai−1+k)
. Assuming f(a1+k)=w
, there is no more than anw
 jumps. We only need to enumerate jumps to calculate the ranges. We can use linked list or set in C++ to maintain it.

The time complexity is O(∑w=1ananw=anlogan)
.

Code (C++)
1687E - Become Big For Me

Idea: xiaoziyao. Solution: xiaoziyao, SSerxhs. Preparation: SSerxhs, xiaoziyao.

Good problem  35
Average problem  2
Bad problem  9
Did not solve  80

Hint
Solution
Let fp(x)
 be the maximum integer satisfying pfp(x)|x
.

For each prime p
, WLOG, assuming fp(ai)≤fp(ai+1)
 (1≤i<n
) then fp(gcdaiaj)=fp(a1)+fp(a2)
.

Consider the Inclusion-Exclusion Principle:

k-thminS=∑∅≠T⊆S(−1)|T|−k(|T|−1k−1)maxT
.

So

fp(gcd{aiaj})=∑∅≠T⊆{fp(a)}((−1)|T|−1+(−1)|T|(|T|−1))max{T}=∑∅≠T⊆{fp(a)(−1)|T|(|T|−2)max{T}
Then gcdaiaj=∏∅≠T⊆alcmT(−1)|T|(|T|−2)
.

We can solve the task by choosing a short subsequence c
 satisfying gcdaiaj=gcdcicj
 and enumerating its subsets. To fit in the constraint, the length of c
 should be no longer than 14
.

Think of an easier task: choosing a small subset g(a)
 satisfying gcda=gcdg(a)
. If we can solve it, we can construct c
 by choosing g(a)∪g(a−g(a))
 if |g(a)|
 does not exceed 7
.

First, choose an arbitrary element x
 in a
 as the only element of S
, and factorize x
 into ∏i=1ω(x)pkii
 (pi<pi+1
). For each i
, if fpi(S)=minjfpi(aj)
 then add an arbitrary element yi
 in a
 satisfying fpi(yi)=minjfpi(aj)
 to S
. Now obviously gcdS=gcda
, but |S|≤ω(x)+1≤8
. We can prove that |S|=8
 and gcd(S−x)≠gcda
 do not hold at the same time, then we can solve the task by choosing

g(a)={SS−{x}(|S|<8)(|S|=8)
.

Consider the necessary condition of |S|=ω(x)=8∧gcd(S−x)≠gcda
:

∃d∈Prime,fd(x)<miny∈S−xfd(y)
. According to how we choose yi
, d≠pi
, d∏i=27pi|y1
, so d∏i=17pi|y1p1
. Since 2×3×5×7×11×13×17×19=9699690
 and y1≤106
, p1≥11
. But x≥11×13×17×19×23×29×31>106
, causing a conflict. So |S|=ω(x)=8∧gcd(S−x)≠gcda
 does not hold.

The time complexity is O(nlogmaxai+2maxω(ai)maxω(ai)+nmaxω(ai))
.

Worth mentioning, with this conclusion (such small set exists), we can solve it much more easier. Just choose a small set by greedy, and enumerate its subset of size 14
.

Code (C++)
Spoiler
1687F - Koishi's Unconscious Permutation

Idea: huangzirui. Solution: Elegia. Preparation: huangzirui, SSerxhs.

Good problem  29
Average problem  5
Bad problem  18
Did not solve  115

Hint
Solution
We call a permutation p
 of length n−s
 is good if ∀i∈[1,n−s−1],pi+1≠pi+1
.

If we can calculate

ansk=∑p is good[∑i=1n−s−1[pi<pi+1]=k]
then, we can get the answer easily by Binomial inversion. So we only need to focus on how to calculate ansk
. For convenience, let n→n−s
. We have:

ansk=∑i=0k(n−1i)(−1)i⟨n−in−k−1⟩
where

⟨nm⟩
is the Eulerian number. As is known to all, the generating function of Eulerian number is:

⟨nm⟩=[xmyn]n!(x−1)x−e(x−1)y
So we have:

ansk=∑j=0k(n−1j)(−1)j⟨n−jn−k−1⟩=[xn−k−1]∑j=0k(n−1j)(−1)j[yn−j](n−j)!(x−1)x−e(x−1)y=[xn−k−1]∑j=0k(n−1)!j!(−1)j(n−j)[yn−j]x−1x−e(x−1)y=[xn−k−1]∑j=0k(n−1)!j!(−1)j[yn−j−1]ddyx−1x−e(x−1)y=(n−1)![xn−k−1]∑j=0k(−1)jj![yn−j−1](x−1)2e(x−1)y(x−e(x−1)y)2=(n−1)![xn−k−1]∑j=0k[yj]e−y[yn−j−1](x−1)2e(x−1)y(x−e(x−1)y)2=(n−1)![xn−k−1][yn−1](x−1)2e(x−2)y(x−e(x−1)y)2=(n−1)![xn−k−1][yn−1](x−1)2exy(xey−exy)2=(n−1)![xn−k−1][yn−1](x−1)2e−xy(xe(1−x)y−1)2
Consider how to calculate [yn−1](x−1)2e−xy(xe(1−x)y−1)2
. Let u=(1−x)y
 and we have:

[yn−1](x−1)2e−xy(xe(1−x)y−1)2=(1−x)n+1[un−1]e−xu1−x(xeu−1)2=(1−x)n+1[un−1]e−xu1−x(1−xeu)2
And:

[un−1]e−xu1−x(1−xeu)2=[un−1]∑i=0(i+1)xie(i−x1−x)u=[un−1]∑i=0(i+11−x+−x1−x)xie(i−x1−x)u=[un−1]∑i=0(i−x1−x)xie(i−x1−x)u+[un−1]11−x∑i=0xie(i−x1−x)u=[un]∑i=0nxie(i−x1−x)u+[un−1]11−x∑i=0xie(i−x1−x)u=[un]ne−xu1−x1−xeu+[un−1]11−xe−xu1−x1−xeu
So we just need to focus on how to calculate [un]e−xu1−x1−xeu
. Let w=eu−1
, we have:

[un](w+1)−x1−x1−x(w+1)=∑m=0n[un](eu−1)m[wm](w+1)−x1−x1−x(w+1)=∑m=0n[un](eu−1)m[wm]∑i=0wi(−x1−xi)1−x(w+1)=∑m=0n[un](eu−1)m[wm]∑i=0wi(−x1−xi)1−xw−x=11−x∑m=0n[un](eu−1)m[wm]∑i=0wi(−x1−xi)1−x1−xw=11−x∑m=0n[un](eu−1)m∑i=0m(−x1−xi)(x1−x)m−i
Let

s=x1−x
.

Try to calculate

11−x∑m=0n[un](eu−1)m∑i=0m(−si)sm−i
.

We know [un] (eu−1)m
 is the Stirling numbers of the second kind. We can calculate it in O(nlogn)
 or O(nlog2n)
. Build a 2×2
 matrix to get ∑i=0m(−si)sm−i
. Let

Mm=[−s−mm+10−s−mm+1s]
And we have

[(−sm)∑i=0m(−si)sm−i]×[−s−mm+10−s−mm+1s]=[(−sm+1)∑i=0m+1(−si)sm+1−i]
So we can divide and conquer to calculate it in O(nlog2n)
.

Code (C++)

Editorial for CodeCraft-22 and Codeforces Round #795 (Div. 2)

By rahulgoel, history, 9 months ago, In English1691A - Beat The OddsVideo EditorialIdea: amul_agrawalProblem Setting: menavlikar.rutvij JadeReaper rahulgoel amul_agrawalEditorial: menavlikar.rutvij rahulgoelVideo Editorial: rahulgoel

Hint 1Hint 2Solution1691A - Beat The OddsThe sum of an odd integer and an even integer is an odd integer. So, you can't have both even and odd elements in the array for the sum of every two consecutive elements to be even.

Hence, the final array should only contain all even or all odd elements. Hence, we will remove either all odd elements or all even elements, whichever takes lesser number of operations. Therefore, the answer is:min(count of odd elements,count of even elements).

C++ Code1691B - Shoe ShufflingVideo EditorialIdea: amul_agrawalProblem Setting: rahulgoel menavlikar.rutvij JadeReaperEditorial: menavlikar.rutvij rahulgoelVideo Editorial: JadeReaper

Hint 1Hint 2Solution1691B - Shoe ShufflingWe can observe that the number of pairs of shoes greater than their size is limited for any student. So if student j wears shoes that are greater than their size, then some student i who has a size greater than student j will compromise their size. So say a valid shuffling exists where a student gets shoes of size greater than their own, i.e., student j got shoes of student i where si>sj. Then, for all pairs of shoes of size sj, one pair will go to a student whose size is smaller than sj. This chain will continue until a student with shoe size s1 gets a pair of shoes greater than theirs, and then there will exist a pair of shoes of size s1 that no student can wear. Thus, if a valid shuffling, every student must get shoes of the same size as their own.

Hence, a valid shuffling exists if more than one student has the same size shoes for all shoe sizes. A valid shuffling can be generated by rearranging students' shoes with the same shoe size such that no one gets their shoes. This can be done in multiple ways, for example, cyclic rotation.

C++ Code1691C - Sum of SubstringsVideo EditorialIdea: amul_agrawalProblem Setting: rahulgoel amul_agrawalEditorial: amul_agrawal rahulgoelVideo Editorial: amul_agrawal

Hint 1Hint 2Solution1691C - Sum of SubstringsWe can observe that for any string s, F(s) can also be written as:F(s)=10×s1+11×s2+11×s3…11×sn−1+1×snIn the above equation, si is the integral face value of the ith character of the string s. We came to this equation by observing what ith character is contributing to the value of F(s). If the ith character is a '1', it will contribute a value of 1 to di−1 and a value of 10 to di.

Now, in order to minimize the value of F(s), we would want to put the 1s at position n first, then at position 1 and then anywhere in the middle of the string. In order to achieve the best configuration in at max k operations, we will try to move the last '1' at position n first, then with the remaining operations, we will try to move the first '1' at position 1. The remaining 1s can stay where they are as they will anyways be contributing a value of 11 no matter which position they take.

C++ Code1691D - Max GEQ SumVideo EditorialIdea: amul_agrawalProblem Setting: fangahawk amul_agrawal rahulgoel keyurchd_11Editorial: fangahawk rahulgoelVideo Editorial: fangahawk

Hint 1Hint 2Solution1691D - Max GEQ SumLet's look at the problem from the perspective of each ai. We want to check whether the sum of the subarrays, where ai is the maximum element, exceeds ai or not.

Firstly, we must find out in which subarrays is ai the maximum. This involves finding the previous greater element index and the next greater element index of i, which can be done for all indices in O(n) using stacks. Take these indices as xi, yi. After computing this for every index, we'll know that ai is max in subarrays with starting index [xi+1,i] and ending index [i,yi−1].

Take (j,k), which represents the sum of a subarray which starts at index j and ends at index k, where j∈[xi+1,i], k∈[i,yi−1]. If (j,k)>ai, then (j,i−1)+(i,i)+(i+1,k)>ai, giving us (j,i−1)+(i+1,k)>0. Hence, at least one of the subarrays, (j,i−1) or (i+1,k) has a sum greater than 0, which implies that one of subarrays (j,i), (i,k) has sum greater than ai, so only checking subarrays which start or end at index i suffices.

Therefore, for an index i, we need to check subarrays (xi+1,i),(xi+2,i),…,(i−1,i), and subarrays (i,i+1),(i,i+2),…,(i,yi−1). Since we just care if any one of them exceed ai, finding the max of them is enough. This reduces to making a range query over the prefix sums and one over the suffix sums. The query on prefix sums would look like

max(i,yi−1)−prefix[i−1]>aiWhere max(i,yi−1) returns the max prefix sum in the given range. This query can be done using a segment tree in O(logn). If any of the queries is true, then we just have to output "NO", else output "YES".

With this we get the time complexity of the solution as O(nlogn).

C++ Code1691E - Number of GroupsVideo EditorialIdea: amul_agrawalProblem Setting: akcube keyurchd_11 rahulgoel amul_agrawalEditorial: akcube rahulgoel keyurchd_11Video Editorial: akcube

Hint 1Hint 2Hint 3Solution1691E - Number of GroupsWe will be using the starting and ending points of different segments to count the final answer. We maintain a Union-Find data structure (DSU) on size n corresponding to the n segments given as input. We store all the starting and ending points in a set. (example: If 2 segments are (0,10) and (11,12), we store 0,10,11,12 in a set irrespective of the color of the segment). We now iterate through these points in ascending order.

We maintain 2 running sets corresponding to the 2 colors. In these sets, we will store the segments for which the starting point has been reached while iterating through the set of points but the ending point hasn't been reached (ie: we store the segments that have started but not ended).

The algorithm works as follows:

If we are at a point x:

If it corresponds to a segment's starting point:We add that segment to the set corresponding to its colorWe merge (DSU merge) this segment with all segments present in the set corresponding to the other color (since their ending point hasn't been reached yet).We also erase all segments in the set corresponding to the other color except the one with the largest closing point value.If the point corresponds to a segment's ending point:We delete the segment from the set corresponding to its color.Why can we delete the segments of color except for the one with the largest ending point if we encounter a starting point of the other color?

We are able to greedily pick the segment with the furthest ending point value because all segments of the same color in that set have been connected together by the segments of the other color. Hence, we can just work with the segments with the largest ending point value of both colors for each component that exists.

C++ Codedarkkcyan's solution without using sets in python.

Python codeTheScrasse's nlog3n solution for E using Boruvka and Mergesort tree :D

Code1691F - K-Set TreeVideo EditorialIdea: ltc.groverkssProblem Setting: ltc.groverkss amul_agrawal rahulgoelEditorial: rahulgoelVideo Editorial: rahulgoel

Hint 1Hint 2Hint 3Solution1691F - K-Set TreeOur task is to calculate∑R∈V∑S⊆V,|S|=kf(R,S)over all possible R,S. Let us first focus on all possible S just for a particular root R=r i.e. let us root our tree at r and try to find the sum ∑S⊆V,|S|=kf(R,S) just for that root.

We will calculate our answer using dynamic programming over the trees. In this technique, we will calculate some properties for each sub-tree and eventually get those properties for the entire tree.

The first property that we want to calculate for each sub-tree with node v as the sub-tree root is — cnt(v) which is the number of subsets of size k such that sub-tree of v is the minimum-size sub-tree covering it entirely. This can be calculated using combinatorics — first we calculate the total number of subsets of size k in this sub-tree and then from it we can subtract the number of subsets of size k which don't have sub-tree of v as the minimum size sub-tree.cnt(v)=(size(v)k)−∑u∈children(size(u)k)Here, u are all the children of v and size(x) represents the size of the sub-tree of x.

This first property that we calculated is very important for us:

If we take the sum of cnt(v) over every node, we will get the total number of subsets of size k.When the tree is rooted at r, cnt(v) represents the number of subsets where sub-tree of v is the smallest sub-tree containing a set S with k vertices.Conclusively, f(R=r,S)=∑v=1ncnt(v)×size(v).The second property that we want to find for each sub-tree is the size(v) — the size of the sub-tree of v.

The third property that we want to find for each sub-tree is cntsz(v)=cnt(v)×size(v).

Now, we have f(R=r,S) (as explained above) i.e. the contribution to the final answer when the root of the entire tree is fixed at r. We can calculate the final answer by fixing other nodes as roots and then summing these value up.

Notice what happens when we try to change the root from r to one of it's children. The properties that we calculated for each sub-tree remain the same except for the old root and the new root. We can recalculate the properties for these two nodes using some clever arithmetic and get the new answer with a new root. This is known as re-rooting technique. The method to calculate the new properties are:

Note: We use OR to represent Old Root. and NR to represent New Root.

sizenew(OR)=sizeold(OR)−sizeold(NR). (Subtracting the size of this branch.)sizenew(NR)=n. (This is the main root.)cntnew(OR)=cntold(OR)−(sizeold(OR)k)+(sizenew(OR)k)+(sizeold(NR)k). (Removing contribution of old size and putting contribution of new size. Removing contribution of the branch.)cntnew(NR)=cntold(NR)−(sizeold(NR)k)+(sizenew(NR)k)−(sizenew(OR)k). (Removing contribution of old size and putting contribution of new size. Putting contribution of new brach.)cntsznew(OR)=cntnew(OR)×sizenew(OR) (By definition.)cntsznew(NR)=cntnew(NR)×sizenew(NR) (By definition.)ansnew=ansold−cntszold(OR)−cntszold(NR)+cntsznew(OR)+cntsznew(NR) (Subtracting old contribution and adding new contribution.)The final answer is given by:finalans=∑v=1nansvC++ Code

Editorial of Codeforces Round 794

By antontrygubO_o, 9 months ago, In EnglishI hope you enjoyed the round.

While problem D1B was good for balance in Div1, it was too hard for balance in Div2. I apologize for this.

Problem D1B = D2D is by dario2994. Other problems are mine.

D2A1686A - Everything Everywhere All But OneSuppose that we did one operation and not all numbers are equal. Let's say that we have n−1 numbers x and 1 number y now, with x≠y.

In the next operation, we have two options: to make operation with n−1 numbers x, or with n−2 of x and one y. If we go with the first option, we will still have n−1 of x and one y: numbers won't change. If we go with the second option, we will have one number x and n−1 numbers (n−2)x+yn−1, where (n−2)x+yn−1=x+y−xn−1≠x. So, we again are in a state where we have n−1 copies of one number and one different number.

So, if after the first operation not all numbers are equal, they will never be all equal. Therefore, it's enough to check each possible operation in O(n2) (which can be clearly optimized to O(n)).

And go watch the movie Everything Everywhere All At Once, it's fantastic!

D2B1686B - Odd SubarraysConsider any optimal splitting.

Clearly, for any subarray [b1,b2,…,bm] which is not odd, we can just split it into [b1],[b2],…,[bm],

For any odd subarray [b1,b2,…,bm] with m≥3, there exists an 1≤i≤m−1 such that bi>bi+1 (otherwise b is sorted and has no inversions). Then, we can split b into [b1],[b2],…,[bi−1],[bi,bi+1],[bi+2],…,[bm], where we also have one odd subarray.

So, if we can split p into several subarrays such that there are k odd subarrays, we can split it into several subarrays of length ≤2 so that there are k odd subarrays too. Then, let dpi denote the largest number of odd subarrays we can get from splitting p[1:i]. Then, dpi=max(dpi−1,dpi−2+(pi−1>pi)). This dp can be calculated in O(n).

It's also easy to show that the following greedy algorithm works: traverse the permutation from left to right, whenever you see two elements pi−1>pi, make a subarray [pi−1,pi], and proceed from pi+1.

D2C/D1A1685A - Circular Local MiniMaxLet's call bi local minimum if bi−1>bi<bi+1 and local maximum if bi−1<bi>bi+1. It's clear that in the arrangement satisfying the conditions from the statement, if bi is a local minimum, bi+1 is a local maximum, and vice versa. Local minimums and local maximums will be alternating.

Then it's easy to see that such an arrangement can't exist for odd n. Indeed, suppose that the conditions from the statement are satisfied for b1,b2,…,bn. If we suppose that b1 is local minimum, we get that b2 is local maximum, b3 is local minimum, …,, bn is local minimum, b1 is local maximum. Clearly, b1 can't be a local maximum and a local minimum at the same time, leading to a contradiction.

Let's now consider the case of even n=2m. Sort the array a, so that a1≤a2≤…≤a2m. Let's show that if ai=ai+m−1=x for some 2≤i≤m−1, then there is no arrangement satisfying the conditions from the statement. Indeed, consider such an arrangement: we have m numbers x, and no two of them can be adjacent, so they occupy every second position. In addition, as local maximums and local minimums are alternating, we get that all x are local maximums or all x are local minimums. The first would imply that a2m<x, which isn't possible. The second would imply that a1>x, which isn't possible.

It turns out that if there is no such i, the arrangement exists. Indeed, we can arrange numbers on the circle in the following order: (a1,am+1,a2,am+2,…,am,a2m). Here ak<am+k>ak+1 for 1≤k≤m−1, am+k>ak+1<am+k+1 for 1≤k≤m−1, a2m>a1<am+1 and am<a2m>a1.

D2D/D1B1685B - LinguisticsFor the answer to be YES the frequency of the character A in the a+b+c+d words must coincide with its frequency in the sentence s, which is equivalent to the condition a+c+d=#{i:si=A}. From now on we may assume that this is true.

Notice that the answer to the problem is YES if and only if it is possible to tile the string s with c copies of AB and d copies of BA so that all the c+d substrings are disjoint. Indeed one can simply fill the remaining characters of s with the a copies of A and the b copies of B (we are sure that the number of characters A and B is correct because of the initial check). Moreover, if si=si+1, then clearly any tiling with AB and BA of s cannot cover with a single tile both si and si+1; therefore we can split the string s between si and si+1 and try to tile the two resulting substrings. By repeating this argument we will end up with many alternating strings (a string t is alternating if ti≠ti+1 for all 1≤i<|t|). So, we have reduced the problem to the following one:

Subproblem: You are given many alternating strings, can you find in these strings c substrings equal to AB and d subtrings equal to BA such that all the c+d substrings are disjoint?

In order to solve the problem let us analyze what happens when only one alternating string is present. Given an alternating string t, we say that the pair (x,y) is valid if we can find in t x substrings equal to AB and y substrings equal to BA so that the x+y substrings are disjoint. Let us consider various cases:

If |t|=2k+1, then (x,y) is valid if and only if x+y≤k. Let f(k):={(x,y):0≤x,y and x+y≤k}.If |t|=2k and t1=A, then (x,y) is valid if and only if x+y≤k−1 or (x,y)=(k,0). Let fAB(k):={(k,0)}∪f(k−1).If |t|=2k and t1=B, then (x,y) is valid if and only if x+y≤k−1 or (x,y)=(0,k). Let fBA(k):={(0,k)}∪f(k−1).Loosely speaking, the alternating strings of type 2. and 3. have a bonus if they are tiled only with one of the strings AB and BA.We will provide a proof for the correcteness of the following greedy algorithm.

Greedy algorithm: Sort the strings of type 2 by length and fill them, starting from the shortest, only with AB (i.e., find as many disjoint copies of AB as possible) until you reach c or you finish them (a string of length 2k is filled with k AB). Do the same for the strings of type 3 for the word BA. At this point there are no more bonuses to use and you can just fill the remaining strings with AB and BA in the only reasonable way. If in the end, if you have found c strings AB and d strings BA then the answer is YES, otherwise it is NO.

Let us provide a proof of the correctness of this algorithm. Let us remark that the proof of the correctness is in fact rather easy, but a bit cumbersome to write down. The strategy of the proof is to start from a solution and to show that the one constructed by the greedy algorithm is "better".

Proof of the correctness of the greedy algorithm: Let U,V,W be the multisets of lengths of strings of the first, second and third type respectively (according to the case division above). Then the problem is equivalent to understanding if(c,d)∈∑u∈Uf(u)+∑v∈VfAB(v)+∑w∈WfBA(w).Assume that the answer is YES and consider a solution of the problem, i.e. a choice of a valid pair for each of the |U|+|V|+|W| alternating strings. Let V=V′⊔V′′ where V′ corresponds to the lengths of the strings in V where the valid pair of the solution is given by (k,0) (k is the length of the string). Partition W=W′⊔W′′ analogously. Then we have(c,d)∈∑u∈Uf(u)+∑v′∈V′(v′,0)+∑v′′∈V′′f(v′′−1)+∑w′∈W′(0,w′)+∑w′′∈W′′f(w′′−1).Let us make a couple of observations:

For any k1,k2 it holds f(k1)+f(k2)=f(k1+k2).If k1≤k2, then f(k1)+(k2,0)⊆(k1,0)+f(k2) and also f(k1)+(0,k2)⊆(0,k1)+f(k2).Thanks to the second observation we know that we may assume (up to changing the solution to a better one) that V′ contains the smaller elements of V (i.e., v′≤v′′ for each v′∈V′,v′′∈V′′), and W′ contains the smaller elements of W. Then, applying the first observation, we reduce the problem to understanding if there is prefix V′ of V (prefix in the sorted by length order) and a prefix W′ of W such that(c,d)∈f(∑u∈Uk+∑v′′∈V∖V′(v′′−1)+∑w′′∈W∖W′(w′′−1))+(∑v′∈V′v′,0)+(0,∑w′∈W′w′).(⋆)It remains to show that we may assume that V′ is the largest prefix so that ∑V′:=∑v′∈V′v′≤c (and the analogous result for W′) as this implies the correctness of the greedy algorithm (i.e., if there is a valid solution then the one constructed by the algorithm is a solution). Assume, by contradiction, that there is v′′∉V′ such that v′′+∑V′≤c. By (⋆) we know(c−∑V′,d−∑W′)∈f(s),where s=∑u∈Uk+∑v′′∈V∖V′(v′′−1)+∑w′′∈W∖W′(w′′−1). Thus, we deduce(c−(∑V′+v′′),d−∑W′)∈f(s−(v′′−1)),which is equivalent to saying that (⋆) holds also if we replace V′ with V′∪{v′′} which is exactly what we wanted to proveD2E/D1C1685C - Bring BalanceLet's denote ( by 1 and ) by −1. Then we need to achieve a sequence in which all prefix sums are nonnegative.

Let our sequence be a1,a2,…,a2n, and denote prefi=a1+a2+…+ai for each 0≤i≤2n.

Key observation: It's always possible to get a balanced sequence in at most 2 operations.

Proof: Let 0≤i≤2n be the index for which the value of prefi is the largest (if there are several such i, choose any). Let's reverse segments a[1:i] and a[i+1:2n], getting sequence ai,ai−1,…,a1,a2n,a2n−1,…,ai+1.

It's easy to show that this sequence is balanced. ai+ai−1+…+aj=prefi−prefj−1≥0 for any j≤i, and aj+aj−1+…+ai+1=prefj−prefi≤0 for any j≥i, so ai+ai−1+…+ai+a2n+…+aj+1=−(aj+aj−1+…+ai+1)≥0 for any j≥i. So, all prefix sums are nonnegative, as desired.

It remains to check if we can make our sequence balanced in less than 2 operations.

Checking if 0 operations are enough is trivial: just check if the initial sequence is balanced. Now, let's check if we can make the sequence (which initially isn't balanced) balanced in exactly one operation.

Let l be the smallest index for which prefl<0, and r be the largest such index. Suppose that we will reverse the segment a[L:R]. Clearly, L≤l, as otherwise, we would have a negative prefix sum. Similarly R>r. After reversing, we need to worry only about the i-th prefix sum for each i from L to R−1, all others will be nonnegative.

The i-th prefix sum for such i will be equal to prefL−1+(prefR−prefR+L−1−i). So, segment [L,R] will be good iff prefL−1+prefR≥prefi for all L−1≤i≤R.

It's easy to show that if any such segment [L,R] works, then also the segment [L1,R1] works, where L1 is the index from [0,l] for which prefL1 is the largest, and R1 is the index from [r+1,2n] for which prefR1 is the largest. Indeed, suppose that there is some L1≤i≤R1 such that prefL1+prefR1<prefi. If i≤l, then prefi<prefL1, contradiction. If i>r, then prefi<prefR1, contradiction. If l<i≤r, then i is inside any such segment [L,R], and prefi>prefL+prefR for any choice of L,R.

So, it's enough to choose segment [L1,R1] and to check if the sequence becomes balanced after reversing it.

D2F/D1D11685D1 - Permutation Weight (Easy Version)Let's first understand what is the minimum possible weight of q. When can it be 0?

Only when qi=pqi+1 for each i. Clearly, such q exists only when p is just one cycle. This gives a hint that we should look at cycles.

Consider splitting of p into cycles (where a cycle is an array [a1,a2,…,am] such that pai=aimodm+1 for 1≤i≤m). Let's say there are k of such cycles. I claim that the answer is 2(k−1). You can see the proof in the tutorial of the hard version of this problem.

Now, let's provide an example. We will construct a permutation p′ as follows:

Initially, it's equal to pThen, for each x from 1 to n−1, if x and x+1 are in different cycles in p′ currently, swap them.One such swap reduces the number of cycles by exactly 1, so we will do exactly k−1 such swaps and p′ will consist of exactly one cycle.

Next, construct q by the rule qi=p′qi+1 (it's possible as p′ is just one cycle). As |qi−pqi+1|=|p′qi+1−pqi+1|, the weight of q is just the sum of |pi−p′i|. Clearly, one swap increases this value by at most 2, so in the end it will be at most 2(k−1), as desired.

D1D21685D2 - Permutation Weight (Hard Version)We will start by proving that the weight is at least 2(k−1) (where k is the number of cycles), and understanding the structure of optimal permutations in the process.

Again, consider splitting of p into cycles (where a cycle is an array [a1,a2,…,am] such that pai=aimodm+1 for 1≤i≤m). Let's say there are k of such cycles.

Now, consider a graph G on n nodes, and draw an edge from qi to pqi+1 for each i from 1 to n (there may be self-loops and multi-edges here). Each node has one incoming and outgoing edge, so the entire graph is split into several cycles. Consider any such cycle (b1,b2,…,bm), where all bi are distinct. Its contribution to the answer is |b1−b2|+|b2−b3|+…+|bm−b1|. We will show that:

This value is at least 2(m−1).

Proof: Wlog bi is the smallest among b and bj is the largest, with i<j. Then |b1−b2|+|b2−b3|+…+|bm−b1|=(|bi−bi+1|+…+|bj−1−bj|)+(|bj−bj+1|+…+|bi−1−bi|)≥ ≤2|bi−bj|≥2(m−1).

It's 2(m−1) only when the numbers on the cycle are some m consecutive numbers and are increasing on the path from the smallest number to the largest and decreasing on the way back.

Proof: It's just the case when all the inequalities in the expression above become equalities.

Now, assign each cycle of p a number from 1 to k and consider the graph G1 on k nodes, draw an edge between the nodes corresponding to the cycles where qi and pqi+1 belong. As qi and pqi are in the same cycle for each i, we get that every two consecutive edges we draw share a node. As we will draw an edge from every cycle, the graph is connected.

Each edge in G1 corresponds to an edge in G (edge between qi and pqi+1 in G corresponds to an edge in G1 between the nodes corresponding to the cycles where qi and pqi+1 belong).

Now, consider any spanning tree in graph G1. Clearly, any cycle of length m in G1 can contain at most m−1 edges from it (if it contained m edges from it, we would have a cycle in G1). So, the total sum of (m−1) over all cycles in G is at least k−1, and therefore the total contribution to the weight is at least 2(k−1).

Now let's give a characterization of all permutations q which have the weight 2(k−1). It turns out, that they are in correspondence with graphs G on n nodes which satisfy the following conditions:

Each node has one incoming and one outgoing edge (and therefore graph is split into cycles).

In G, if a cycle has length m, then it consists of m consecutive integers, where numbers go up from the smallest number to the largest and down on the way back

The sum of m−1 over all cycles is precisely k−1.

If we draw an edge between two cycles of p if an element of the first cycle is connected to the element of the second cycle in G, this graph on k nodes is connected.

Each such graph is a corresponding graph of some optimal permutation q. The proof is left for the reader as an exercise.

Now, how to solve our problem? Let's build q element by element. The weights of all cyclic shifts of the same permutation are the same, so we start with q1=1. Now, the only subproblem we have to be able to solve is to check if the current prefix q of length l is a prefix of some permutation with weight 2(k−1). So, we have to check if our current l−1 edges qi→pqi+1 can be a subset of some graph G satisfying all the conditions above.

Denote these edges (u1,v1),…,(ul−1,vl−1). If edge has ui<vi, consider segment [li,ri]=[ui,vi], and call it right segment. If edge has ui>vi, consider segment [li,ri]=[vi,ui], and call it left segment. If ui=vi, call ui loop node.

We can show that the following criteria are sufficient:

No two right segments intersect internally.

No two left segments intersect internally.

No right/left segment contains a loop node.

Consider a graph on k nodes, corresponding to the cycles of p. For each 1≤i≤n−1, if [i,i+1] is contained in some segment, draw an edge between the corresponding cycles in which i, i+1 are. Then, this graph can't have a cycle (has to be a forest).

Consider a graph on k nodes, corresponding to the cycles of p. For each 1≤i≤n−1, unless i or i+1 are loop nodes, or i is the right end of two segments, or i+1 is the left end of two segments, draw an edge between the corresponding cycles in which i, i+1 are. Then, this graph must be connected.

These conditions may sound complicated but they are very simple implications of the conditions on G above. The proof that if these conditions are satisfied then edges form a subset of some valid G is left to the reader as an exercise too (tutorial is already too long, sorry).

Total complexity is O(n3), as we can do up O(n2) checks, and each check takes O(n) time.

D1E1685E - The Ultimate LIS ProblemConsider element n+1. Replace for a while n+1 by 0, each element ≤n by −1, and each element ≥n+2 by 1. It's well-known that for an array of n of 1 and n of −1 there exists a cyclic shift such that all its prefix sums are nonnegative (which is equivalent to the sequence of these 1s and −1s being balanced). Consider such cyclic shift for our array.

It's easy to see now that in this cycle there is no increasing subsequence of length at n+1 of element distinct from n+1. Indeed, in such a subsequence we would have t of −1s, and then n+1−t of 1s, which would mean that t-th 1 goes after the t-th −1, meaning that the subsequence isn't balanced.

So, if there is an increasing subsequence of length n+1 in this shift, n+1 is in it.

Let's say there are t elements ≤n before n+1 in this subsequence and n−t elements ≥n after n+1 in this subsequence. As t-th 1 goes before t-th −1 in this shift, we get that there are exactly t elements ≥n+2 in this shift before n+1, and (similarly) exactly n−t elements ≤n in this shift after n+1. In addition, these two parts form (as ones and minus ones) two separate balanced sequences.

Now, consider a shift in which n+1 is the first element. It's easy to see that if the condition above holds, then in this shift ones and minus ones also form a balanced subsequence. If LIS of this shift is n+1, it must be the case that n+1 and n ones form it, which implies that elements n+1,n+2,…,2n+1 go clockwise in this permutation.

Similarly, after considering a shift in which n+1 is the last element, we get that elements 1,2,…,n+1 go clockwise in this permutation.

It turns out that if all the conditions above hold, then all shifts have LIS≥n+1. Indeed, consider any shift, elements to the left of n+1 smaller than n+1, n+1, and elements to the right of n+1 larger than n+1 form an increasing subsequence. From the fact that 1s and −1s are balanced we get that numbers smaller than n+1 take at least half of the space before n+1, and larger than n+1 take at least half of the space after n+1, so its length is at least n+1.

With all this knowledge, how do we solve the problem?

We will keep track of all the 1s and −1s with a segment tree, with queries "smallest prefix sum on the subsegment". When we need to provide the answer after the update, we will do the following:

Check if the circular segment from n+1 to n+1 is balanced. If not, find the shift that makes 1s and −1s balanced, its LIS is at most n.

Then, check if n+1,n+2,…,2n+1 go clockwise in the permutation. If not, then the shift in which n+1 is the first element has LIS≤n.

Then, check if 1,2,…,n+1 go clockwise in the permutation. If not, then the shift in which n+1 is the last element has LIS≤n.

Otherwise, output −1.

We check if 1,2,…,n+1 go clockwise by saving the following sum:∑i=1n(pos(imod(n+1)+1)−pos(i))mod(2n+1)If it's 2n+1, they go clockwise, else not. We can update this sum in O(1) per query.

Total complexity is O(log(n)) per query.

Codeforces Round #793 (Div. 2) Editorial

By rivalq, 9 months ago, In EnglishI hope you all liked the round. Please share your feedback in the comments section.

1682A — Palindromic IndicesHintTutorialLet's remove some index i from the first half of s and check whether the resulting string is a palindrome or not, the other half has the same approach. The prefix of length i−1 already matches with the suffix of the same length because the initial string was a palindrome, so we just need to check if t=s[i+1…n−i+1] is a palindrome.

For t to be a palindrome, sn−i+1 should be equal to si+1 which was initially equal to sn−i, again which should be equal to si+2 and this goes on. Here we can see that si=si+1…=sn−i+1. So the answer is simply equal to the number of contiguous same characters in the center of the string which can be calculated in O(n).

Solution1682B — AND SortingHintsTutorialWe always have to make at least one swap for the elements which are not at their correct positions. Hence an upper bound of answer would be the bitwise AND of those elements. Let the value be X. It turns out that the given permutation is X-sortable.

Proof:

First, notice that X would always be present in p. Let posx be the position of X in p initially. Let's say at some point we want to swap two values pi and pj, then pi and pj would always be a supermask of X i.e. pi & X=X and pj & X=X. We can make the following moves to swap pi and pj without disturbing any other element.

Swap values at indices i and posx.Swap values at indices i and j.Swap values at indices j and posx.It can be seen that in every swap the bitwise AND of two values which we are swapping is always X. Hence we can swap any two values which were not at their correct positions, therefore we can sort the permutation p.

Overall Complexity: O(n).

Solution1682C — LIS or Reverse LIS?HintTutorialLet's make a small observation:

There can be at most one index common to both LIS(a) and LDS(a).If some element x occurs ≥2 times, then one of its occurrences can be included in LIS(a) and another one in LDS(a), and all the remaining occurrences are of no use because none of them can contain 2 equal elements.

If some element x is a singleton i.e. the frequency of x in a is 1, then it can have 3 positions

In LIS(a) only.In LDS(a) only.The only common element of LIS(a) and LDS(a).It can be seen that it is always optimal to choose some singleton as the only common element (if available) because those with frequency ≥2 can easily contribute 1 to both LIS(a) and LDS(a) easily.

Let t be the number of elements having frequency ≥2 and s be the number of singletons in a. The singletons should be divided equally among LIS(a) and LDS(a) with one of them given to both, if available.

Hence, the answer is t+⌈s2⌉.

The values s and t can be found using some data structure like std:map in C++ in O(nlog(n)).

Solution1682D — Circular Spanning TreeHintsTutorialLet's check some cases when it is not possible to construct the answer-

When all vertices have an even degree, then there is no way to generate a tree because every tree contains at least 2 leaves.When there are an odd number of vertices with odd degrees, then there is no tree possible because the sum of degrees must be even.It turns out that it is always possible to construct a tree if none of the above is true.

The following construction works -

Select some vertex i such that the previous vertex of i (assumed cyclically) has an odd degree i.e. si−1=1. Clearly, such a vertex always exists.

Now left rotate s, i−1 times such that the selected vertex is now at index 1. Note that after the rotation sn will become 1. Now we can see that s[2…n] can be divided into several segments such that each segment ends with some vertex having an odd degree. And each segment should contain exactly one vertex with an odd degree. So s[2…n]=[0…1][0…1]…[0…1] where 0 may appear 0 times. Connect vertex 1 to the starting vertex of each segment and connect adjacent vertices inside each segment. It can be clearly seen that edges will never intersect internally. The only thing we need to verify is the degree constraints.

Proof:

The degree condition is valid for each segment, as each vertex with an even degree is connected with 2 other vertices and the last vertex with an odd degree will be connected to only one vertex i.e it's previous one or vertex 1 if it was only on its segment.Let cnt1 be the number of vertices with odd degree. If s1=1, then there will be cnt1−1 segments which is an odd number, hence vertex 1 will be connected to odd number of vertices. If s1=0, then there will be cnt1 segments which is an even number, hence vertex 1 will be connected to even number of vertices.Note that we renumbered the vertices during rotation which should be handled in implementation.

The intuition for the above approach comes from the case when all si are 1 in which we create a star network.

Overall complexity: O(n).

Solution1682E — Unordered SwapsTutorialOne way of solving permutation problems is to look at permutation cycles. Let's decompose our permutation into cycles, then it's easy to see that each cycle can be solved independently because we have to sort the permutation in a minimum number of moves which isn't possible if two cycles are merged at any instant.

Let's look at one cycle only, whose vertices are numbered from 1 to n in the orientation of cycle i.e the cycle is 1→2→…→n→1. Also assume that we only have swaps (x,y) that are relevant to this cycle.

It is known that we can sort a cycle of size n in n−1 moves and it is the minimum number of required moves.

Claim 1: The set of swaps if considered as edges (x,y) form a tree on the n vertices of the cycle.

ProofSo we must use all the n−1 edges of the tree in some order to get n cycles each of size 1.

Let's consider any element u having adjacency list as [x1,x2,...,xk] in the order they appear on the cycle if we start moving from u in the orientation of cycle i.e u→u+1→...→n→1→...→u.

Claim 2: We can never make the swap (u,xj) before swap (u,xi) if j>i.

ProofUsing above claim, for every element u the order of edges is fixed i.e x1, then x2, ..., and finally xk.

Let's build a directed graph on n−1 vertices (representing the swaps) where for every element u we add directed edges (u,x1)→(u,x2), ..., (u,xk−1)→(u,xk).

Since it is guaranteed that the answer will exist i.e a valid sequence of moves exist, hence the topological sorting of the above graph must exist, any of which represents a correct sequence of swaps.

Note that whenever we make a swap that is not violating claim 2 for any element u, then there will be no cross edge in two smaller cycles that are going to be formed and those smaller cycles can be further solved independently. Also the order of edges i.e [x1,x2,...,xk] is not going to change for any element which ensures that the directed graph we built remains correct even if we remove some appropriate edge.

Hence the answer is simply the topological sort of the graph we built.

Overall Complexity: O(nlog(n)), nlog(n) for sorting the edges according to cycle's orientation to get the order [x1,x2,...,xk] for every vertex.

Some other interesting things about this problemGeneratorReview by Anton SirSolution1682F — MCMF?TutorialLet us suppose we need to calculate the answer for only one query, say complete array i.e a[1:n].

The scary flow structure in the problem can be reduced as-

Let's replicate each vertex i, |bi| times. Then we can see that there will be an equal number of vertices on the left and right side. Now the problem reduces that we have to match these vertices with minimum cost such that the cost of matching i and j is |ai−aj|.

There are only 2 type of elements (left side and right side) and the following greedy algorithm to match the elements works.

Algorithm: Sort the type 1 and 2 elements independently and match them in the sorted order.

ProofSince the array a is given in sorted order, let's use it!!

Let's assume-

Type 1 elements are those having bi<0.

Type 2 elements are those having bi>0.

Now instead of replicating elements |bi| times and sorting them independently, let's iterate on array a from left to right and add the contribution of each element independently. Say we are at index i, and prefix sum of bi so far is psumi, then the following cases arise-

bi>0, psumi≥0 — There is no unmatched type 1 element on the left, so we just add this element's contribution to the answer i.e −bi⋅ai.

bi>0, psumi<−bi — There are more than bi unmatched type 1 elements on the left, so we match bi of them to ai, adding a contribution of ai⋅bi to the answer.

bi>0, psumi<0 and psumi>−bi — There are less than bi unmatched elements (=|psumi|) on the left, so we match those with equal number of ai and remaining are propagated further, adding a contribution of |psumi|∗ai−(bi−|psumi|)∗ai, where the positive term comes from those matching with previous unmatched elements and the negative term comes from those that are going to be left unmatched.

Similar cases are there for bi<0.

Ok so now we can easily solve the problem for one query in O(n).

Main idea:

Let's simulate the above algorithm for every suffix and record the obtained answer in ansi for ith suffix. Note that the value ansi doesn't denote any answer for some suffix because the sum of bi over that suffix might or might not be zero. One important observation here is that-

Let some subarray a[l:r] for which sum of bi is 0, then ansl−ansr+1 do have a good meaning, it's the answer for that query indeed.ProofBut still, we can't simulate for every suffix, right? It would go O(n2) again.

Let's iterate from left to right and for every i try calculating it's contribution in 1st, 2nd, ..., (i−1)th suffixes which is easy because it depends only on psumi, bi (which are constant for a given i) and psuml for contribution to lth suffix. This is pretty standard using 2 fenwick trees.

How to calculate ansi?

Let's solve bi>0 and bi<0 independently, say bi>0 for now. Other case is similar.

Let psumi=∑ij=1bj.

Consider the contribution of index i to ansl for l<i, from three cases described above the contribution is different for different l with different psuml. We can build a fenwick tree on compressed prefix sums. Case 1 and 2 above add a constant value to a range of prefix sums that can be maintained in one fenwick tree and Case 2 gives some linear function of psum to be added in a range that can be maintained in other fenwick tree. Add contribution of each i from 1 to n first, and let's start calculating ansi.

For i=1, ans1 can be obtained by querying at psum1 in both fenwicks.

Then we remove the contribution of i=1 from the two fenwick trees (simply the negative of which we added above), because i=1 won't be contributing to any suffix other than 1st one.

Similarly we move from left to right and calculate ansi by querying at psumi and then remove the contribution of ith element.

Solution

Codeforces Round #792 (Div. 1 + Div. 2) Editorial

By shishyando, 9 months ago, In EnglishWe know about FST and we are really, really sorry about it. Even though we still hope that you liked the problems.

A: Digit Minimization1684A - Digit Minimization

Editorial1684A - Digit MinimizationLet k be the length of n. Let ni be the i-th digit of n (1-indexation from the left).

k=1The game ends immediately so the answer is n itself.

k=2Alice should make the first move and she has to swap n1 and n2. After that Bob removes n1 and in the end there is only n2.

k≥3Alice can make swaps in such way that when there are only two digits left the second digit will be the maximal digit of n. Then she will make a swap and the maximal digit will be on the first position. The other one will be removed by Bob. This way she can always get the maximal digit of n in the end of the game.

ImplementationB: Z mod X = C1684B - Z mod X = C

Editorial1684B - Z mod X = CIn this problem it is enough to find a contstruction that works for all a<b<c. For example:

x=a+b+cy=b+cz=c

In this case

xmody=(a+b+c)mod(b+c)=a since a<b<b+cymodz=(b+c)modc=b since b<czmodx=cmod(a+b+c)=c since c<(a+b+c).

ImplementationC: Column Swapping1684C - Column Swapping

Editorial1684C - Column SwappingAt first, let's check wether the given table is good. If it is not then there is a row that has elements that should be replaced.

Let's say that this row is a and b is the sorted row a. Then let's find the set of positions i that ai≠bi. If there are at least 3 such positions then the answer is −1 because by making a swap we remove at most 2 such bad positions. If there are no more than 2 such positions then let's swap the corresponding columns and check whether each row is sorted. If the table is good we found the answer. If it is not then the answer is −1 because we can not sort a and get a good table after that.

ImplementationD: Traps1684D - Traps

Editorial1684D - TrapsFirstly, let's notice that it is always better to use all k jumps. If we jumped over less than k traps then we can jump over the last trap and the total damage will be less.

Secondly, let's say that we immediately get n−i damage if we jump over i-th trap. This way the first trap that we jump over will cause k−1 damage more than it should (because of k−1 traps that we jump over next), the second will cause k−2 damage more, ..., the last one will cause 0 damage more. So the total damage only increases by k(k−1)2 which does not depend on the traps that we choose. That's why the traps that we have to jump over in this problem are the same.

Now let's consider an array b:bi=ai−(n−i). This array denotes the amount of damage we dodge if we jump over i-th trap (dodge ai because we don't take the trap's damage but get n−i because of the immediate damage we take). Here a simple greedy works: let's just chose k maximal values of this array, these will be the traps that we have to jump over so the total damage that we dodge is maximized. These traps will be the answer to the original problem.

ImplementationE: MEX vs DIFF1684E - MEX vs DIFF

Editorial1684E - MEX vs DIFFLet's consider all possible MEX after all operations. It is from 0 to n and we can check them all in the increasing order. Now let's fix some MEX=m. There should be all numbers from 0 to m in the array, so there are some "holes" in the array that should be covered. The hole is an integer from 0 to m which is not present in the array. If there is at least one hole in the end it is not possible to obtain MEX=m.

Now let's see how we should cover the holes. We will do it greedily. Firstly, we will need to use integers that are greater than m. It is easy to see that they are always not worse to use than the integers which are already from 0 to m. Moreover, we should start from those integers that occur less times in the array. It is because each time we cover a hole we increase MEX at least by one (we cover the holes in increasing order) and the value of DIFF increases at most by 1 and it does not increase when we change the last element of the same value.

After that if we used all integers that are greater than m we should use those integers that are from 0 to m but only those that occur more than once. By doing these operations we increase MEX at least by 1 and increase DIFF exactly by 1 (because we cover a hole).

Now let's notice that when considering each MEX value in the increasing order we can simply maintain some information about the current state of the array: a set that helps us find the elements greater than m which occur less times in the array, the amount of not covered holes, the number of "bonus" elements from 0 to m (the number of integers from 0 to m minus DIFF from those elements that are from 0 to m) and it is easy to see how it is changed when we increase MEX. So in total we can calculate the answer for each MEX for all MEX from 0 to n.

ImplementationF: Diverse Segments1684F - Diverse Segments

Editorial1684F - Diverse SegmentsLet's say the answer is [L,R]. Let's consider all given segments. There should be no two equal elements that are in the same given segment and are not in [L,R], i.e. at least one of them should be in the answer. Let's find such segment of minimal length for L=1. To do that let's for each r find such minimal l that on segment [l,r] all elements are distinct. Let's say that l=f(r). This could be done using two pointers, maintaining current set of elements and checking whether the considered element is not in the set. Let's say we are given a segment [lj,rj]. If f(rj)≤lj then this segment is already fine. Else for L=1 this condition holds R≥f(rj)−1. Minimal R that meets all the inequalitites will be the answer.

Now let's find out how to find R while increasing L by 1. If we increase L then R can not decrease. Also if [L+1,R] can not be the answer then in some of given segments there are two equal elements aL and aj. If j<L then the left endpoint can not be greater than L. Else j>R. Then we have to make R=j and this j should be minimal. This j could be found, for example, by binary search in cnt array. To check whether two elements are in the same segments it is possible to use a segment tree or a Fenwick tree. It is possible to store for each i such maximal rj that there is a given segment [lj,rj] and lj≤i.

The final answer will be the minimal length of [L,R] for all L.

ImplementationG: Euclid Guess1684G - Euclid Guess

Editorial1684G - Euclid GuessLet's consider some pair (a,b) and consider a sequence of remainders that is induced by this pair: amodb=x1, bmodx1=x2, ..., xp−2modxp−1=xp, where xp=gcd(a,b).

If xi≤m3 then we can just add a pair (3xi,2xi) and we will get the only remainder xi so these values will not be a problem.

If x1>m3 (if i>1 then xi≤m3) then a=b+x1 because if a≥2b+x1 then a>m which is impossible. b=x1+x2 because if b≥2x1+x2 then a≥3x1+x2>m. Then a=b+x1=2x1+x2≥2x1+xp because xp<xp−1<…<x2<x1.

It means that for each xi>m3 there should be such xj that 2xi+xj≤m and xj is a divisor of xi. For such values we can consider a bipartite graph where in the left part there are only xi>m3 and in the right part there are only xj≤m3 and two integers are connected ⟺ the integer on the right divies the left one. This graph can be built in O(n2). After that we just have to find such matching that covers each integer in the left part and add all unused integers from the right part using the method above.

ImplementationH: Hard Cut1684H - Hard Cut

Editorial1684H - Hard CutLet's say that there are k ones in the given string.

We will build the answer for all k>0. k=0 is the only case when the answer does not exist.

k=1, k=2, k=4 — cut into single digits.

k=3 — described later.

Let's consider k=5:

If all ones are in a row, then we should cut them into 11112+12=1610.

Else there will be either 1012 or 1002 and the other part of the string may be cut into single digits so the sum will be 810.

Now let's consider k>5 (here we will also consider k=3):

Let's describe the function solve(l,r,k,n) for cutting the susbtring from l to r with k ones to get the sum n.

Let's use the "divide and conquer" technique: we have a string with k ones and we want to get the sum n=2⌈log2(k)⌉, and for big enough k we can just cut the whole string into two substrings with almost equal number of ones, run the algorithm for them and get the sum 2⌈log2(⌊k/2⌋)⌉+2⌈log2(⌈k/2⌉)⌉=2⌈log2(k)⌉=n. Now let's show how to make such cut for all strings that have from 6 to 11 ones and after that for all k≥12 we will be able to run the method decribed above.k=nJust cut into single digits.

k<n≤⌊3k2⌋Let's consider the first two ones. If they are consequent then we will cut them into a single substring. It costs us only two ones but it increases the sum by 3. If these two ones are not consequent then we will cut out the segments 102 and 12. This way we spend two ones again and the sum increases by 3 as well. Also it is always possible to cut off a single digit so it is easy to see that we can get any sum n from k to ⌊3k2⌋. This way we got the answer for k=6,7,8,11. Now we only need to show how to make the cut for k=9,10.

k=9Let's consider a substring of length 3 that starts in the leftmost one, there are 4 possible cases:

t=100, then we need to use k′=8 ones to get the sum n′=1610−1002=12, which we know how to do.t=101, then we need to use k′=7 ones to get the sum n′=11, we will show it in the end.t=110, then we need to use k′=7 ones to get the sum n′=10, which we know how to do.t=111, then we need to use k′=6 ones to get the sum n′=9, which we know how to do.k=10To do that let's cut a substring with k1=4 ones from the left and get the sum n1=8 and a remaining substring with k2=6 ones and get the sum n2. We already know how to get the second sum so now there is only k1=4 and n1=8 left.

Let's consider the last two cases for full solution:k=4,n=8:

Let's do the same thing as we did for k=9, cut off a substring of length 3 that starts from the leftmost one. Then we have two substrings and for both of them we know how to cut them properly.

k=7,n=11:

Let's cut off the first four ones and use the previous technique we will get the sum 8. The remaining three ones we will use to get the sum 3.

This shows how to cut the string for any k>0.

Implementation

Codeforces Round #791 (Div. 2) Editorial

By DishonoredRighteous, history, 10 months ago, In English1679A - AvtoBus

Author: iakovlev.zakhar

Preparation: DishonoredRighteous

Editorial: DishonoredRighteous

Editorial1679A - AvtoBusLet the number of buses with two axles is x and the number of buses with three axles is y. Then the equality 4x+6y=n must be true. If n is odd, there is no answer, because the left part of the equality is always even. Now we can divide each part of the equality by two: 2x+3y=n2.

Let's maximize the number of buses. Then we should make x as large as possible. So, we will get 2+…+2+2=n2 if n2 is even, and 2+…+2+3=n2 otherwise. In both cases the number of buses is ⌊n2⌋.

Now let's minimize the number of buses. So, we should make y as large is possible. We will get 3+…+3+3+3=n2 if n2 is divisible by 3, 3+…+3+3+2=n2 if n≡2(mod3), and 3+…+3+2+2=n2 if n≡1(mod3). In all cases the number of buses is ⌈n3⌉.

Also don't forget the case n=2 — each bus has at least four wheels, so in this case there is no answer.

Time complexity: O(1).

1679B - Задача каменного века

Author: Kon567889

Preparation: Kon567889

Editorial: DishonoredRighteous and Kon567889

Editorial1679B - Stone Age ProblemAs we want to perform queries fast, we will store some variables: current sum of all elements in the array sum, index of the last query of the second type lastSecondQuery and its value lastSecondQueryValue. For each element of the array we will also store index of the last query of the first type that changed this element lastFirstQuery[i] and its value lastFirstQueryValue[i].

Now let's answer the queries. If we are going to perform a query of the first type, we have to know, what the number ai equals now. If lastSecondQuery>lastFirstQuery[i], then ai=lastSecondQueryValue now, and ai=lastFirstQueryValue[i] otherwise. Now let's subtract ai from the sum, change lastFirstQuery[i] and lastFirstQueryValue[i], and add the new value ai to the sum.

If we are going to perform a query of the second type, we have to update values lastSecondQuery and lastSecondQueryValue. The new sum of all elements of the array is n⋅lastSecondQueryValue.

Time complexity: O(n+q).

1679C - Ладьи-защитники

Author: Kon567889

Preparation: Kon567889

Editorial: DishonoredRighteous and Kon567889

Editorial1679C - Rooks DefendersConsider some subrectangle. Note that each its cell is attacked by some rook if and only if there is at least one rook in each row x (x1≤x≤x2) or in each column y (y1≤y≤y2).

Now we will solve the problem using this criterium. Let's create a set freeRows where we will store indices of rows in which there are no rooks. Similarly, we will store indices of columns in which there are no rooks in a set freeCols. If we have to answer the query of the third type, we have to check if there is at least one x in the freeRows set such that x1≤x≤x2 or there is at least one y in the freeCols set such that y1≤y≤y2. If we will store these two sets sorted, we can perform this type of query in O(logn) using binary search.

Now we're going to answer queries of the first and the second types. Let's store for each row and column, how many rooks are there in this row or column. When we add a new rook we should increment this counters for the corresponding row and column and remove the row from freeRows set and the column from freeColumns set. When we remove a rook we should decrement counters for its row and column and if there is no more rooks in the row or in the column, we should add their indices to freeRows or freeCols.

Time complexity: O(qlogn).

1679D - Граф? А... А я думал, барон...

Author: Kon567889

Preparation: Masha237

Editorial: DishonoredRighteous

Editorial1679D - Toss a Coin to Your Graph...Note that the function of existence of the answer relatively to the minimum value of the maximum in the path is monotonous. If we were able to construct the path with maximum, not greater than x, we are able to construct the path with maximum, not greater than x+1. This leads to the idea of binary search the answer.

Let binary search to fix some integer x. We have to check, if there is a path in the graph, that consists of k−1 edges and the maximum on this path is not greater than x. In the beginning let's leave in consideration only vertices which values are not greater than x. Now we need to check if the needed path exist in the resulting graph.

If there is a cycle in the graph, there is a path of every length in it, so there is a path of length k−1. Otherwise we have a directed acyclic graph. Let's find a longest path in it and compare its length with k−1. Let's sort the graph topologically and calculate dp[v] — the length of the longest path in the graph that begins in vertex v, it's a well-known classical problem.

Time complexity: O((n+m)logMAX).

1679E - Типичная вечеринка в общаге

Author: andr1y and welleyth

Preparation: andr1y and welleyth

Editorial: andr1y and welleyth

Editorial1679E - Typical Party in DormWe are given a string s, we need to count the number of palindromes in all possible versions of it if the characters "?" can be replaced by some letters of the English alphabet, which are set by queries.

Let us solve the problem initially for a 1 query.

First, we can see that instead of counting the number of palindromes in each possible version of string s, we can count the number of strings in which a substring [l;r] would be a palindrome.

Consider the substring [l;r]. Suppose the set of allowed characters in this query is Q. What would be the effect of the substring on the answer? Divide the characters of the substring into pairs: first with last, second with penultimate, and so on. If the length of the substring is odd, pair the central character with itself. Now let's consider each pair separately:

If two characters of the pair are equal and they are not question marks, then this pair does not affect the answer.If two characters of the pair are equal and they are question marks, then this pair multiplies the answer by |Q|, where |Q|  — the number of possible characters to replace in this query. (Let's call the number of such pairs f).If two characters of the pair are not equal and there is no question mark among them, then this substring will never be a palindrome.If two characters of a pair are not equal and there is a question mark among them, you must check if the letter that is not a question mark belongs to the set Q, if not, then in this query this substring will never be a palindrome.Those pairs that cause this substring not to be a palindrome will be called blocking. Thus, we got the number of possible ways to replace question marks in substring [l;r] with valid characters such that substring [l;r]  — a palindrome  — is |Q|f, or 0 if we have a blocking pair. To get the total number of lines in which [l;r] is a palindrome, just multiply the previous value by |Q|d, where d  — is the number of question marks that not lie within [l;r].Thus, to get the answer for the substring [l;r] it is enough:

Check for blocking pairs  — if they exist, the answer is 0 by definition.Otherwise, the answer is |Q|d+f, where d and f are defined above.Let's assign to each possible set of letters a binary mask of size α, where α  — the size of the alphabet in the problem. In the future, we will assume that mask and set are the same.

Consider possible blocking pairs of some substring [l;r], they are of two kinds:

If two characters of the pair are not equal and there is no question mark among them, then this substring will never be a palindrome and we do not consider it.If two characters of the pair are not equal and there is a question mark between them, a character that is not a question mark must be in the query for us to consider this substring.Thus, from the characters in pairs of the second type, we can create a set of "necessary" characters, let's call it P.Next, let us note the following fact: d+f does not depend on the query Q, because d depends only on l and r, and f  — on the number of pairs where both characters are question marks.

It follows that every substring of the form [l;r]:

Or is simply ignored if it has a blocking pair of the first type. (These substrings will not be mentioned further in the tutorial  — when we say substrings, we automatically mean the one described below).Either is characterized by a pair of numbers (P; d+f).Consider an arbitrary query Q, how to calculate the answer for it? We need to go through all substrings, check whether P⊆Q and if so, add |Q|d+f to the answer.

The values of P and d+f for the substring [l;r] can be found quickly by knowing the same values for the substring [l+1;r−1]. Thus, by iterating over the parity of the palindrome length, then its center, and then its length itself, we can quickly find these values for all the substrings.

Thus, our solution has asymptotics so far O(n2 + q⋅n2), which is obviously too slow.

But first, let's figure out how to solve the problem if we have |Q|  — fixed? Let's create an array of size 2α (let's call it R). For each substring, let's add to RP value |Q|d+f. What does this give us? We will then have in Ri the sum of answers from all the substrings P of which is equal to i. To find the answer in this case we have to sum all Ri where i⊆Q.

Actually, we have reached the asymptotics O(n2 + q⋅2α) or O(n2 + 3α).

But! The problem of finding the sum of subset values is a well-known one and solves our subproblem for O(α ⋅ 2α). In more detail: https://codeforces.com/blog/entry/45223

Well, here we have reached the asymptotics of O(n2 + α⋅2α), which is enough.

Let us return to the original problem. First, note that we don't have many different |Q|  — just α. So we create α different arrays of size 2α. When processing the current substring, we add id+f to each of the α arrays at position P, where i  — the index of the current array. Thus, it is as if we α times solved the problem for a fixed |Q|. We need to take the sum over subsets of Q from the |Q|th array to get the answer.

The final asymptotic of the solution  — O(α⋅n2 + α2⋅2α).

Applied optimizations in the author's solution:

Power optimization: we will often need different values of numbers from 1 to α in powers from 0 to n, so to remove log from the asymptotic, a precalculation of these values is used. This optimization is necessary to guarantee a full score on the problem.Addition optimization: we do not need to add a subset (P; d+f) to arrays whose index is less than |P|. This is since they will not affect the answer in any way. (Since the sets from which the answer will be taken in this array have fewer elements than P, they cannot, by definition, be P supersets.) This optimization is unlikely to have much effect on runtime. It is written here for a clearer understanding of the author's solution.Modulo optimization: The take modulo operation is slower than other operations, so it is worth avoiding. Here we often use the sum modulo of two numbers that do not exceed 998244353, so we will replace it by using (a+b >= M ? a+b-M : a+b) instead of (a+b)%M1679F - Формализм ради формализма

Author: iura

Preparation: iura

Editorial: DishonoredRighteous

Editorial1679F - Formalism for FormalismIf you carefully read the problem statement, it becomes clear that we can do some transformations some numbers into others and we have to calculate the number of equivalence classes of all numbers consisting of n digits. Let's say that the representative of some equivalence class is the lexicographically minimal number in this class. Now the problem is to calculate the number of distinct integers that are representatives of some equivalence classes.

For convenience let's build an undirected graph which vertices will be digits and an edge will connect some digits u and v if and only if we are given a pair of digits (u,v) or a pair of digits (v,u).

It's easy to see that the number is a representative of some class if and only if it doesn't have a substring of kind [x,d1,d2,…,ds,y], where x>y, and there are edges (y,ds),(y,ds−1),…,(y,d1),(y,x) in the graph.

Now, knowing the criterium, let's calculate dp[suff][mask] — the number of equivalence classes if we have added suff digits from right to left in our number and now we can move to front only digits from the mask. Let's go over the next digit c that will be added to the left. If there is a digit i in the mask such that c>i and there is an edge (c,i) in the graph, we cannot add digit c, because it will break our criterium. Otherwise we can add digit c, it remains to calculate the new mask. Firstly, there will be a digit c in the new mask. Secondly, all digits i>c such that digit i was in the old mask and there is an edge (c,i) in the graph, will be in the new mask too. After that let's perform a transition from state (suff,mask) to state (suff+1,newMask).

The time complexity of this solution is O(n⋅2Σ⋅Σ2), where Σ is the size of the alphabet — 10 for this problem.

It's slow a bit, so we will optimize this solution. We can precalculate the newMask for each pair (c,mask) using the algorithm described above. After that, using this information, we can recalculate dp faster.

Time complexity: O(2Σ⋅Σ2+n⋅2Σ⋅Σ).

Codeforces Round #790 (Div. 4) Editorial

By SlavicG, history, 10 months ago, In EnglishThank you for participating!

1676A - Lucky?

Idea: mesanu and SlavicG

Tutorial1676A - Lucky?We need to check if the sum of the first three digits is equal to the sum of the last three digits. This is doable by scanning the input as a string, then comparing the sum of the first three characters with the sum of the last three characters using the if statement and the addition operation.

Solution1676B - Equal Candies

Idea: Errichto

Tutorial1676B - Equal CandiesBecause we can only eat candies from boxes. The only way to make all boxes have the same quantity of candies in them would be to make all candies contain a number of candies equal to the minimum quantity of candies a box initially has. So, we should find this minimum number, let's denote it as m, and then for each box, there should be eaten ai−m candies. So the answer would be the sum of ai−m over all i-s (1≤i≤n).

Solution1676C - Most Similar Words

Idea: MikeMirzayanov

Tutorial1676C - Most Similar WordsFirstly, given any pair of strings of length m, we should be able to tell the difference between them. It's enough to find the sum of absolute differences between each character from the same position. Now, we should go through all possible pairs and pick the minimum value over all of them using the function we use to calculate the difference.

Solution1676D - X-Sum

Idea: mesanu

Tutorial1676D - X-SumThe solution is to check the sum over all diagonals for each cell.

For a cell (i,j) we can iterate over all elements in all its diagonals. This will be in total O(max(n,m)) elements.

The complexity will be O(n⋅m⋅max(n,m)).

O(n⋅m) solutions involving precomputation are also possible but aren't needed.

Solution1676E - Eating Queries

Idea: mesanu

Tutorial1676E - Eating QueriesLet's solve the problem with just one query. Greedily, we should pick the candies with the most sugar first, since there is no benefit to picking a candy with less sugar.

So the solution is as follows: sort the candies in descending order, and then find the prefix whose sum is ≥x. This is O(n) per query, which is too slow for us.

To speed it up, notice that we just need to find a prefix sum at least x. So if we compute the prefix sums of the reverse-sorted array, we need to find the first element that is at least x.

Since all elements of a are positive, the array of prefix sums is increasing. Therefore, you can binary search the first element ≥x. This solves the problem in logn per query.

Total time complexity: O(qlogn+n).

Solution1676F - Longest Strike

Idea: MikeMirzayanov

Tutorial1676F - Longest StrikeLet's call a value good if it appears at least k times. For example, if a=[1,1,2,2,3,4,4,4,5,5,6,6] and k=2, then good values are [1,2,4,5,6].

So we need to find the longest subarray of this array in which all values are consecutive. For example, the subarray [4,5,6] is the answer, because all values are good and the length of the array is longest.

There are many ways to do this. For example, we can see when the difference between two elements is more than 1, and then break the array into parts based on that. For instance, [1,2,4,5,6]→[1,2],[4,5,6]. You can also iterate from left to right and keep track of the size of the current array.

Time complexity: O(n).

Solution1676G - White-Black Balanced Subtrees

Idea: MikeMirzayanov

Tutorial1676G - White-Black Balanced SubtreesLet's run a dynamic programming from the leaves to the root. For each vertex store the values of the number of balanced subtrees, as well as the number of white and black vertices in it.

Then from a vertex we can count the total number of white vertices in its subtree as well as the black vertices in its subtree, and update our total if they are equal. Remember to include the color of the vertex itself in these counts. The answer is the answer at the root.

Therefore the problem is solved in O(n) time.

Solution1676H1 - Maximum Crossings (Easy Version)

Idea: flamestorm

Tutorial1676H1 - Maximum Crossings (Easy Version)Let's look at two wires from i→ai and j→aj.

If ai<aj, there can never be any intersection.If ai>aj, there has to be an intersection.If ai=aj, it is possible that there is an intersection or not, depending on how we arrange the wires on the bottom terminal.In the last case, if there are multiple wires that go to the same segment ai, we can make all pairs of them cross by arranging the points in which they hit this segment from right to left. For example, if a=[1,1,1,1], then we can make all pairs of segments cross as shown.

Since we want to maximize the number of intersections, we just need to count the number of pairs (i,j) such that ai≥aj. You can brute force all pairs in O(n2).

Solution1676H2 - Maximum Crossings (Hard Version)

Idea: flamestorm

Tutorial1676H2 - Maximum Crossings (Hard Version)Read the solution of the easy version.

We want to count the number of pairs (i,j) such that i<j and ai≥aj. This is a standard problem, and we can do this we can use a segment tree or BIT, for example. Insert the aj from j=1 to n, and then for each aj count the number of ai≤aj using a BIT.

It is also related to the problem of counting inversions, so you can solve it using a modification of merge sort.

Either way, the solution is O(nlogn).

Solution

Codeforces Round #789 Editorial

By tokitsukaze, 10 months ago, In English1678A - Tokitsukaze and All Zero Sequence

Idea: tokitsukazePrepare: tokitsukaze

TutorialWe observe that when there is 0 in the sequence, it is optimal to choose 0 and any number other than 0 for each operation.

Therefore, when there is 0 in the sequence, let cnt be the number of 0s, the answer is n−cnt.

Otherwise, when 0 does not exist in the sequence, there are two situations:

When there exist two equal numbers in the sequence, we can perform the operation 1 time to convert it into the situation of having 0 in the sequence. So the answer must be n.

When all numbers in the sequence are distinct, we can perform the operation 2 times to convert it into the situation of having 0 in the sequence. So the answer must be n+1.

SolutionFeedback1678B1 - Tokitsukaze and Good 01-String (easy version) and 1678B2 - Tokitsukaze and Good 01-String (hard version)

Idea: qsmcgogo-B1, 74TrAkToR-B2Prepare: tokitsukaze

Tutorial(greedy)Obviously, the operation is, for each pair of adjacent and unequal characters, change both of them to 0 or 1. In other words, the string is divided into many adjacent binaries with length of 2. If the binary is "01" or "10", it needs 1 operation, otherwise the operation is not required.

If you want to minimize the number of "contiguous segments", a simple greedy way is to change each "binary requiring operation" (i.e. 01 or 10) into the form of the previous or next "binary requiring no operation" (i.e. 11 or 00). For example: "0010" change to "0000" and "1101" change to "1111". In this way, this "binary requiring operation" has no contribution to the final number of contiguous segments. We only need to count the number of contiguous "11" and "00" binaries.

In particular, if all binaries are "01" or "10", the final contribution to the number of final contiguous segments is 1 in total.

Tutorial(DP)Obviously, the operation is, for each pair of adjacent and unequal characters, change both of them to 0 or 1. In other words, the string is divided into many adjacent binaries with length of 2.

Consider the recursion from the front to the back, it can be observed that the previously maintained prefix must end with "00" or "11". Therefore, it's necessary to convert each divided binary into "00" or "11" by enumerating the cost of changing the current binary into "00" and "11". Maintain the minimum number of operations in the process of DP, try to make the current string consistent with the end of the prefix subsegment.

dp[n][2], set the first dimension as the maintained length of prefix and the second dimension as the suffix state of the prefix.

Then the DP transfer equation is:

dp[i][0]=min(dp[i−2][0]+{c0,0},dp[i−2][1]+{c0,1})dp[i][1]=min(dp[i−2][0]+{c1,1},dp[i−2][1]+{c1,0})where ck represents the cost of converting the current binary to "kk".

Solution(greedy)Solution(DP)Feedback-B1Feedback-B21677A - Tokitsukaze and Strange Inequality

Idea: tokitsukazePrepare: tokitsukaze

TutorialWe can calculate the answer in two steps.

The first step, for each b, let fb represents the number of pd where pb>pd in the interval [b+1,n]. We can calculate f in O(n2).

The second step, calculate the answer. First we enumerate c from 1 to n, and then enumerate a from 1 to c−1. When pa<pc, add fb in the interval [a+1,c−1] to the answer. Before enumerating a, we can calculate the prefix sum of f first, so we can add the fb in the interval to the answer in O(1). The time complexity of this step is O(n2). However, this will add the result of d in the interval [a+1,c−1] to the answer, which is illegal because c<d is required. So we need to maintain f while enumerating c: enumerate b from 1 to c−1, if pb>pc, fb minus 1. pc is actually regarded as pd, that is, subtract the case where c is equal to d, so as to subtract the illegal case. The time complexity of this step is also O(n2).

Time complexity:O(n2).

By the way, use Fenwick Tree or Segment Tree can also pass, the time complexity is O(n2log n)SolutionFeedback1677B - Tokitsukaze and Meeting

Idea: funerPrepare: tokitsukaze, funer

TutorialObviously, we can calculate the answers of rows and columns separately.

For the answers of columns, we can observe that since there are only n⋅m students in total, no students will leave, and every time a new student entering the meeting hall, all columns will move one step to the right circularly, so the answer will not decrease. If the i-th student is a serious student, for all the previous students with subscript j where 0<j<i, and j%m=i%m are naughty students, the answer in the column will increase by 1.

For the answer of rows, we can transfer it from the answer of i−m, which is equivalent to adding a new row to the answer of i−m. Suppose the last serious student is the j-th student. If i−j<m, the answer will increase by 1, otherwise the answer will be the same as that of when the i−m student enters the meeting hall.

SolutionFeedback1677C - Tokitsukaze and Two Colorful Tapes

Idea: qsmcgogo, winterzz1Prepare: winterzz1

TutorialFirst, find the cycle directly, take out all the cycles, and then fill each cycle in the order: maximum, minimum, maximum, minimum ….

Note that when you encounter an odd cycle, the last one should be empty and fill in the middle value.

For example, in a ternary cycle, if the first and the second position are filled with 1 and 9, it can be observed that the contribution of the ternary cycle to the answer remains unchanged no matter which number between 2∼8 is filled in the middle. So this situation can be left out first, and finally fill in whatever number is left. The same to the cycles with odd sizes such as self cycles and five membered cycles, because the last number does not provide any contribution. In this way, you can directly construct a solution with the maximum score.

We notice that if we take out the numbers that has already been filled in each cycle and put them into a new cycled array h, in fact, the numbers providing contribution are only at the "peak" and "valley" points of the array. We define "peak" as the point with subscript i where hi>hi−1 and hi>hi+1, and "valley" is the point with subscript i where hi<hi−1 and hi<hi+1. Obviously, each "peak" will provide contribution of 2⋅hi, each "valley" will provide contribution of −2⋅hi. For the points which are neither "peak"s nor "valley"s, they do not provide any contribution.

In order to maximize the score, we make the larger number in the permutation "peak" and the smaller number "valley". There are ⌊CircleSize2⌋ "peak"s and "valley"s for a circle with a length of Circlesize.

So the expression of the final answer can be derived from the summation formula of the arithmetic sequence:

Let c=∑⌊CircleSize2⌋, N represents the size of the permutation, score=2c⋅(N−c).

SolutionFeedback1677D - Tokitsukaze and Permutations

Idea: dark_light, FreshP_0325Prepare: dark_light

TutorialConsider finding out the relationship between sequence v and permutation p. It can be observed that the permutation p have bijective relationship with sequence c. That is to say, sequence c will only correspond to one permutation p, as it can be proved:

Let S=1,2,…,n, and find that the last number can be determined through cn, because there is no number after this position. We observe that pn is the (cn+1) largest number in S, then delete pn from S, we can get pn−1. So repeat the process, we can get the whole permutation.

Consider counting v, we observe that each bubble sort will first make vi=max(vi−1,0), then the whole v moves left, v1 is directly covered, vn is set to 0. Because each valued vi is preceded by a number larger than the current position, then it will definitely be exchanged and moved forward, vi minus 1.

For example, if the current v=[0,0,2,1,1], after once bubble sort, v=[0,1,0,0,0].

To avoid confusion, the V array below is the v in the input. It's easy to count after knowing the above conclusion.

For the position i(i≤k), it can be observed that after k times of bubble sort , it is directly covered, so just multiply the answer by ∏ki=1i.

For the position i(k<i≤n), if Vi−k≠−1, then obviously vi is uniquely determined; If Vi−k=−1, then vi has i possible values, multiply the answer by i; If Vi−k=0, then vi−k≤0, multiply the answer by k+1.

Note that for the position i(i≥n−k+1), Vi should be 0 or −1, otherwise the answer must be 0.

Complexity:O(n).

SolutionFeedback1677E - Tokitsukaze and Beautiful Subsegments

Idea: Frank_DDPrepare: Frank_DD

TutorialLet's sort the queries [l,r] with r in ascending order.

Let's move R from 1 to n, and answer queries [l,r] when r=R.

Use segment tree to solve this problem, each leaf node [ul,ul] in the segment tree maintenance the number that how many intervals [ul,R] are beautiful, then answering queries is to get sum.

Use monotone stack to maintain the maximum number. When moving R one step right, the monotone stack will pop some and push one.

Let's think about the number x in monotone stack, which means the maximum number of the intervals [lp,R] (l1≤lp≤l2) is x. If there exist a ll in [l1,l2] which satisfies all∗aR=x, then before x is poped, intervals [l,rr] are beautiful(l∈[l1,l2],l≤ll ,R≤rr).

So we can assume that x will not be poped when it is pushed in the monotone stack, and do something like difference algorithm in the segment tree, by using the current R as the time stamp. Each node in the segment tree has to maintain a∗R+b,which like a linear function.

So when moving R right step, let's enumerate the factor of aR to update old intervals in monotone stack, enumerate the multiple of aR to update the new interval in monotone stack and update the intervals which are poped.

Time complexity: O(nlognlogn+qlogn).

SolutionFeedback1677F - Tokitsukaze and Gems

Idea: dark_lightPrepare: dark_light

TutorialFirst, consider how to calculate the contribution of a legal path. It can be found that the contribution of a legal path is equivalent to the following formula, where bi indicates the number of the i-th gems on the path.

∑b1i1=0∑b2i2=0…∑bnin=0(∑nj=1(Pijikj)×∑nj=1[ij≠0])This formula seems impossible to calculate, but it can be observed that there is a chain structure behind it. Consider dynamic programming, try to calculate the 1∼(i+1)-th gems' answer by only considering the 1∼i-th gems' answer. Consider maintenance these:

dpn,1=∑b1i1=0∑b2i2=0…∑bnin=0(∑nj=1(Pijikj)×∑nj=1[ij≠0])dpn,2=∑b1i1=0∑b2i2=0…∑bnin=0∑nj=1(Pijikj)dpn,3=∑b1i1=0∑b2i2=0…∑bnin=0∑nj=1[ij≠0]dpn,4=∑b1i1=0∑b2i2=0…∑bnin=01It can be observed that if we enumerate how many the (n+1)-th gem are selected, this can actually be transferred, for example:

dpn+1,1=∑bn+1p=0∑b1i1=0∑b2i2=0…∑bnin=0((∑nj=1Pijikj+Pppk)×(∑nj=1[ij≠0])+[p≠0])Then spread.

A=∑bn+1p=0∑b1i1=0∑b2i2=0…∑bnin=0(∑nj=1Pijikj×∑nj=1[ij≠0])=(1+bn+1)dpn,1B=∑bn+1p=0∑b1i1=0∑b2i2=0…∑bnin=0∑nj=1Pijikj[p≠0]=bn+1dpn,2C=∑bn+1p=0∑b1i1=0∑b2i2=0…∑bnin=0Pppk×∑nj=1[ij≠0]=dpn,3×∑bn+1p=0Pppk=dpn,3×∑bn+1p=1PppkD=∑bn+1p=0∑b1i1=0∑b2i2=0…∑bnin=0(Pppk)×[p≠0]=dpn,4×∑bn+1p=1PppkNow it can be transferred. The main problem is how to calculate ∑ni=1ikxi quickly, ensuring that x>1.

Let hk,n represent ∑ni=1ikxi.

Calculate the sum according to the proportional sequence, h0,n=xn+1−xx−1.

xhk,n−hk,n=∑ni=1xi+1ik−∑ni=1xiik=xn+1nk+∑ni=1xi((i−1)k−ik)=xn+1nk+∑ni=1xi([∑kj=0(−1)k−j(kj)ij]−ik)=xn+1nk+∑k−1i=0(−1)k−j(kj)hi,nFinally we get

hk,n=xn+1nk+∑k−1i=0(−1)k−j(kj)hi,nx−1According to this recurrence formula, we can get

h0,n=xn+1(1x−1)−x×(1x−1)h1,n=xn+1(nx−1−1(x−1)2)−x(−1(x−1)2)When k is constant, there exist a k-degree polynomial gk(x) about n, making hk,n=xn+1gk(n)−xgk(0). This conclusion can be proved by mathematical induction.

Consider how to use interpolation to get this polynomial, we only need to find gk(0)∼gk(k).

Consider difference method, hk,n−hk,n−1=xn+1gk(n)−xngk(n−1)=nkxn.

So xgk(n)−gk(n−1)=nk. But we still can't get C. There is a conclusion: the (n+1)-th difference of the n-degree polynomial f(x) is 0. That is to say, ∑n+1i=0(−1)n+1−i(n+1i)f(i)=0.

So we can get gk(0), then use polynomial fast interpolation, and then polynomial multipoint evaluation to get the value of every point we need.

It can be observed that the DP transfer can be replaced by matrix, so there are matrices each position, the problem is equivalent to get the sum of the matrix products of all intervals. It's easy to solve. You can solve it in the way you like.

Overall complexity: O(klog2k+n).

SolutionFeedback

Codeforces Round #788 (Div. 2) Editorial

By Ahmed_Hosssam, history, 10 months ago, In EnglishHere is the editorial. Please provide your feedback on each problem so that we can improve upon them the next time.

1670A - Prof. SlimTutorial1670A - Prof. SlimWe can notice that to make the array sorted we must move all the negative signs to the beginning of the array. So let's say the number of negative elements is k. Then we must check that the first k elements are non-increasing and the remaining elements are non-decreasing.

Complexity is O(n).

Solution1670B - Dorms WarTutorial1670B - Dorms WarLet's consider the non-special characters as '0' and special characters as '1' since they are indistinguishable. So now the problem is that we have a binary string, where each '1' character removes the character before it each time the program is run.

The trivial case is when there is only one '1' character, the answer then is just the number of '0' characters before it.

But what if there is more than one '1' character? lets take for example when there are two '1' characters as follows: 00000010001→000001001→0000101→00011→001→01→1The observation here is that when the first '1' character from the right reached the second '1', it acts as if it just replaced its place, so we can say that each '1' character replaces another '1' as soon as it reaches it.

So we can partition the binary string into small partitions where each partition contains only one '1' character that is the rightmost character in the partition.

For example, the string 00010000001011 can be partitioned into: (0001),(0000001),(01),(1)We first calculate the amount of time each partition requires to remove all the '0' characters before it, which is basically the number of '0' characters before it. Each partition except for the first partition requires one more second to replace the '1' character in the previous partition.

So the answer is the maximum time required among all the partitions.

Solution1670C - Where is the Pizza?Tutorial1670C - Where is the Pizza?Let's first solve the version where the array d is filled with 0's (in other words there is no constrain on the permutation c that needs to be formed).

Let's say we have the permutation [1,2,3,4] as a and the permutation [3,1,2,4] as b.

Suppose that we have chosen the first element of the array c to be the first element of array a, this way we can't choose the first element of array b. Since we want array c to be a permutation, we will have to get the first element of b from a (which is 3). If we search for 3 in array a and add it to array c, we wont be able to choose the element of b in the corresponding index (which is 2), so we again search for 2 in array a and add it to c. This time, the element in b at the corresponding index is 1, which is already included in the array c, so we are not obliged to select another element from array a.

We observe that the elements that we were obliged to choose from a along with the initial element we selected [1,2,3] are a permutation of the elements at the corresponding indices of b [3,1,2], and for each group that has a size bigger than one we have 2 options, either we select the whole group from a, or we select the whole group from b.

So the answer to this version is to just count the number of groups of size bigger than 1 (let's say the number of groups is p) and print 2p.

Now what if array d is not filled with 0's? We just have to make sure that each group we count has 0's in all the corresponding indices of the group we are considering, otherwise this group has only one option and we don't count it.

This solution can be implemented in many ways, but using DSU to union each group together is the most elegant way to implement it in my opinion.

Solution1670D - Very SuspiciousTutorial1670D - Very SuspiciousWe can notice that there are 3 different slopes in which we can draw a line, and we can also notice that drawing the lines exactly on the edges of the hexagons will result in the creation of 2 equilateral triangles at each intersection of 2 lines, so we can say that:

Number of equilateral triangles = 2 *( number of intersections at center of some hexagon).

Now we only need to find a way to draw the lines such that it maximizes the number of intersections. The best way to do that is to keep the number of lines on all 3 slopes as close as possible (the proof will be explained at the bottom). One way to do so is to add the lines once at each slope then repeat.

Let's say that slopes are numbered 1, 2, and 3, so we will add the lines as follows 1,2,3,1,2,3, and so on. The increase in the intersection will be the number of lines in the other two slopes added together. It will be as follows : +0,+1,+2,+2,+3,+4,+4,+5,+6,+6,+7,+8,…If we separate that into groups of 3 we will get {0,1,2},{2,3,4},{4,5,6},…The sum of the groups is 3,9,15,21,…To get the sum of the first X groups it will be 3X2. So, to get the number of intersections using N lines we will first find the number of complete groups which is ⌊N3⌋ and then loop over the last group to find the total number of intersections.

Now that we have a way to find the number of equilateral triangles created by N lines we can find the number of lines needed to get X equilateral triangles by using binary search.

The proof that the best way to maximize the number of intersections is to keep the number of lines on all 3 slopes as close as possible:

Imagine a case in which the difference between the lines in two slops is more than 2 lines, now we can see that if we moved one line from the larger group to the smaller we will obtain more intersections because after moving, the intersections with the 3-rd line will be the same and will not be affected and the intersection between the slopes will decrease by the size of the smaller group and increased by the size of the larger group minus 1 so overall the intersections will increase by at least 1 so that proves that we can't have any difference more than 1 and the groups must be as close as possible.

Solution1670E - Hemose on the TreeTutorial1670E - Hemose on the TreeLet's look at the minimum maximum value that we can get if we have an array of numbers from [1,2(p+1)−1] and we are trying to get any prefix xor, the answer will be 2p because you can stop at the first integer that will have the bit p so the answer will be ≥2p.

We can apply the same concept here, for any arrangement we can start at the root and stop at the first node/edge that has the bit p on. Let's try to find a construction that will make our answer always 2p. This is one of the valid ways.

Select an arbitrary root.Put 2p at the root.Create 2p−1 pairs from the remaining numbers of the form (x,x+2p) where x<2pFor every node we will do the following:If its parent has the bit p in its value the node will take the value x and the edge to the parent will take x+2p.If its parent doesn't have the bit p in its value the node will take the value x+2p and the edge to the parent will take x.Using this construction you will find that the xor value form the root will alternate between 0 and 2p and x which is always ≤2p .

Solution1670F - Jee, You See?Tutorial1670F - Jee, You See?Let's put aside the XOR constraint and only focus on the sum constraint.

let G(X) be the number of ways to construct n integers such that their sum is at most X.

We will construct each bit of the n integers at the same time, we want to guarantee that the contribution of the sum of the bits generated at each position plus the sum of the previous bits wont exceed X we only have to know the difference between the previous bits of X (add 1 if the current bit is on) and the sum of the generated bits.

However we know for sure that at each position we can generate at most n bits which will sum to n at most, so for the next position the difference will be the 2 * (current difference - the sum of the bits at the cur position). we can see that if the current difference has a value ≥ 2n we can place any number of bits at the remaining positions.

Let's define dp[m][k] as the number of ways to construct the first m bits of the n integers such that their sum doesn't exceed X, where k is min between (the difference between the previous bits and X) and 2n.

We can have count from 0 to min(k,n) ones placed at the current bit and for each count we have (ncount) ways to distribute them.

Formally dp[m][k]=∑min(n,k)count=0(ncount)⋅dp[m+1][2(k−count+currentBit)] where currentBit is one if the limit have the bit m on.

For the XOR constraint we only have to make sure that count is even if the current bit of Z is 0 or odd if the current bit is 1.

The answer of the problem will be G(R)−G(L−1).

Solution

Codeforces Round #787 (Div. 3) Editorial

By Vladosiya, history, 10 months ago, translation, In English1675A - Food for Animals

Idea: MikeMirzayanov

Tutorial1675A - Food for AnimalsObviously, the best way to buy food for every pet is to buy maximum possible food for dogs and cats, then max(0,x−a) dogs and max(0,y−b) cats will not get food. We will buy universal food for these dogs and cats. Then the answer is YES, if max(0,x−a)+max(0,y−b)≤c, and NO else.

Solution1675B - Make It Increasing

Idea: MikeMirzayanov

Tutorial1675B - Make It IncreasingWe will process the elements of the sequence starting from the end of the sequence. Each element ai (1≤i≤n−1) will be divided by 2 until it is less than ai+1. If at some point it turns out that ai+1=0, it is impossible to obtain the desired sequence.

Solution1675C - Detective Task

Idea: Gol_D

Tutorial1675C - Detective TaskFirst, let's note that we will have a transition from 1 to 0 only once, otherwise it turns out that first the picture disappeared, then it appeared and disappeared back, but we can consider that a friend in the middle, who answered 1 lied to us, but this is not true, because even before him the picture disappeared.

So we need to find this transition. Since we can also meet ?, we find the index of the leftmost 0 (in case of absence, we take n−1) and mark it as r0, and the index of rightmost 1 (in case of absence, we take 0) and mark as l1. Answer – the number of indices between them (inclusive), because only they could lie. r0−l1+1There could not be a thief to the left of l1, since either the friend under the index l1 lied, or the picture was not stolen before l1. There could not be a thief to the right of r0, since either the painting had already been stolen in the presence of r0's friend, or it was he who lied.

Solution1675D - Vertical Paths

Idea: MikeMirzayanov

Tutorial1675D - Vertical PathsLet's find a set of leaves of a given tree. From each leaf we will climb up the tree until we meet a vertex already visited. Having met such a vertex, start a new path from the next leaf.

The sequence of vertices in the found paths must be deduced in reverse order, because the paths must go from bottom to top. It also follows from this solution that the number of paths will always be equal to the number of leaves in the tree.

Solution1675E - Replace With the Previous, Minimize

Idea: myav

Tutorial1675E - Replace With the Previous, MinimizeGreedy idea. To minimize the string, we will go from left to right and maintain a variable mx = maximal character, from which we will reduce everything to 'a'. Initially it is 'a' and we spend 0 of operations on it. Then, at the next symbol, we can either reduce it to 'a' in no more than k operations, or reduce to 'a' the prefix we have already passed and minimize the next character in the remaining operations.

Solution1675F - Vlad and Unfinished Business

Idea: Vladosiya

Tutorial1675F - Vlad and Unfinished BusinessTo begin with, we will hang the tree by the vertex x. In fact, we want to go from the root to the top of y, going off this path to do things and coming back. At one vertex of the path, it is advantageous to get off it in all the necessary directions and follow it further. So we will go 1 once for each edge leading to y and 2 times for each edge leading to some of the cases, but not leading to y.

Let's match each vertex with an edge to its ancestor. If the edge of a vertex leads to y, then y is in the subtree of this vertex, similarly with vertices with cases. It is necessary for each vertex to determine whether there is a vertex y in its subtree and whether there is a vertex from the array a, this can be done using a depth-first search, then we will calculate the answer according to the rules described above.

Solution1675G - Sorting Pancakes

Idea: Vladosiya

Tutorial1675G - Sorting PancakesFor convenience, we will calculate the prefix sums on the array a, we will also enter the array b containing the indexes of all pancakes and calculate the prefix sums on it.

Let's use dynamic programming. Let's define dp[i][last][sum] as the required number of operations to correctly lay out the i-th prefix, with the final ai=last, and ∑ij=1aj=sum. Then you can go to dp[i][last][sum] from dp[i−1][last+j][sum−last] (the previous number must be greater, and the sum is fixed). To dp[i−1][last+j][sum−last], it will be necessary to add a certain number of actions necessary to get ai=last, let's call it add (all the terrible prefix sums are needed to count it). Since add depends only on last and sum, we only need to choose the minimum dp[i−1][last+j][sum−last], the choice can be optimized by suffix minima. As a result, the solution works for O(n∗m2), that's how many states need to be processed.

Solution

Codeforces Round #786 (Div. 3) Editorial

By vovuh, history, 10 months ago, translation, In English1674A - Number Transformation

Idea: BledDest

Tutorial1674A - Number TransformationThe process in the statement can be rephrased as "multiply x by ba". x⋅ba will be divisible by x, so if y is not divisible by x, there is no answer. Otherwise, a=1 and b=yx can be used.

Solution (BledDest)1674B - Dictionary

Idea: BledDest

Tutorial1674B - DictionaryThere are many different ways to solve this problem:

generate all Berland words with two for-loops and store them in an array, then for each test case, go through the array of words to find the exact word you need;generate all Berland words with two for-loops and store them in a dictionary-like data structure (map in C++, dict in Python, etc), using words as keys and their numbers as values. This allows to search for the index of the given word quickly;for each test case, run two for-loops to iterate over the words, count the number of words we skipped, and stop at the word from the test case;try to invent some formulas that allow counting the number of words before the given one.Solution (BledDest)1674C - Infinite Replacement

Idea: BledDest

Tutorial1674C - Infinite ReplacementLet's consider some cases.

If there are letters 'a' in string t, then the moves can be performed endlessly. If t itself is equal to "a", then the string won't change, so the answer is 1. Otherwise, the length of t is least 2, so string s will be increasing in length after each move, and the answer is -1.

If there are no letters 'a' in string t, then the resulting string is only determined by whichever letters 'a' we chose to replace with t. That's because once we replace a letter 'a' with string t, we can do nothing with the new letters anymore.

We can actually imagine that t is equal to "b", and the answer won't change. Now it's easy to see that the answer is equal to the number of strings of length n, consisting only of letters 'a' and 'b'. There are two options for each position, and there are n positions, so the answer is 2n.

Overall complexity: O(|s|+|t|) per testcase.

Solution (awoo)1674D - A-B-C Sort

Idea: BledDest

Tutorial1674D - A-B-C SortLet's look at elements an and an−1. After the first step, they will always move to positions b1 and bn (it's up to you to choose: an→b1 and an−1→bn or vice versa) because all remaining ai for i<n−1 will be placed between an and an−1.

After the second step, elements b1 and bn will always be placed at positions cn−1 and cn (it's also up to you to decide the exact order) because it's easy to see that you first take all bi for 1<i<n and only after that — b1 and bn.

In other words, elements an−1 and an are moved to positions cn−1 and cn. We can analogically prove that each pair (an−2i−1,an−2i) is moved to a pair of positions (cn−2i−1,cn−2i): you first take all elements aj for j>n−2i and place them at positions [b1,…,bi] and [bn−i+1,…,bn]; then you move an−2i and an−2i−1; finally you move all remaining elements from a between bi+1 and bn−i. Step 2 just does everything in "reverse" order to step 1.

It means that array c is basically array a, but you can swap elements in pairs (an−2i−1,an−2i) for i≥0. And to make a (c) sorted, we can try to sort each pair and check — is it enough to sort the whole array or not.

Solution (adedalic)1674E - Breaking the Wall

Idea: BledDest

Tutorial1674E - Breaking the WallLet's analyze three cases based on the distance between two sections we are going to break:

break two neighboring sections (i and i+1);break two sections with another section between them (i and i+2);break two sections with more than one section between them.Why exactly these cases? Because the damage from the shots and the possibility to hit both sections with the same shot depends on the distance between them.

If there is more than one section between the two we want to break, then any shot hits only one of these sections, so each shot should be aimed at one of those sections, and we break them independently. Let's pick two sections with minimum durability and calculate the number of shots required to break them; if these sections are i and j, then the required number of shots is ⌈ai2⌉+⌈aj2⌉. It actually does not matter if the distance between them is less than 3; if it is so, these sections will be analyzed in one of the other cases.

Okay, now let's deal with two sections having exactly one section between them. We can iterate on all combinations of these sections (iterate on i from 1 to n−2 and pick sections i and i+2). Let's analyze how can we damage them. If we shoot at the section between them, we deal 1 damage to both sections; if we shoot at one of those sections, we deal 2 damage to it and 0 damage to the other section. So, each shot distributes 2 damage between these two sections the way we want to distribute it, and the number of shots required to break these two sections is ⌈ai+ai+22⌉.

The case when we try to break two adjacent sections is the trickiest one. Let's say that these sections are i and i+1, x=max(ai,ai+1), and y=min(ai,ai+1). If we target one of these sections, we deal 2 damage to it and 1 damage to the other section. Let's try to run the following algorithm: shoot at the section with higher durability, until both of them break. It can be slow, but we can see that after the first x−y shots, the durabilities of the sections become equal, and each pair of shots after that deals 3 damage to both sections. So, we can model the first x−y shots, subtract 2(x−y) from x and (x−y) from y, and then we'll need ⌈x+y3⌉ shots. The only case when this doesn't work is if we break both sections before we equalize their durabilities; it means that 2y≤x and we need to do only ⌈x2⌉ shots.

Solution (fcspartakm)1674F - Desktop Rearrangement

Idea: vovuh

Tutorial1674F - Desktop RearrangementI've seen a lot of data structures solutions for this problem, but author's solution doesn't use them and works in O(nm+q).

Firstly, let's change our matrix to a string s, because it will be easier to work with a string than with a matrix. The order of characters will be from top to bottom, from left to right (i. e. the outer cycle by columns, and the inner by rows). Then, let's calculate sum — the number of icons on the desktop (the number of '*' in s). Then the answer will be, obviously, the number of dots on the prefix of s of size sum.

Now let's deal with queries. It can be shown that one query changes our answer by no more than 1.

Let p=ny+x be the position of the cell that is being changed in s (zero-indexed). Then, if p<sum, there are two cases. If sp is '.', then we have one more icon on our prefix, so the answer decreases by one (because we filled one empty space in the good desktop). Otherwise, it increases by one (because this icon is outside our prefix).

Then let's change the corresponding character by the opposite. After that, we should move our right border (sum) accordingly to the new number of icons. Note that this border is exclusive. If sp becomes '*', then we will increase the variable sum. But before that, if ssum is '.', then there should be an icon, and it is not here yet, so the answer increases. Otherwise, our border will decrease. Then, if ssum−1 is '.', then the answer decreases (because there was a place for an icon, and now it is not needed anymore).

Time complexity: O(nm+q).

Solution (vovuh)1674G - Remove Directed Edges

Idea: BledDest

Tutorial1674G - Remove Directed EdgesLet's solve the problem in reverse.

Imagine we have already removed some edges, so that the conditions hold. When is some set of vertices considered cute? Since the graph is acyclic, we can topologically sort the vertices in the set. The vertices are reachable from each other, so there exists a path from the i-th vertex in the set to the (i+1)-st vertex. Thus, there exists a path that goes through all chosen vertices.

However, we can make this conclusion even stronger. In the optimal answer, not just the path goes from the i-th vertex to the (i+1)-st one, but a single edge. That can be shown by contradiction. Let there be some vertices v and u that are adjacent in the chosen cute set. There exists a path between them, but not a single edge. We want to show that this set is not optimal and can be made larger.

The vertices on that path don't belong to the set. If they did, they would be between v and u in the set (because of the topological order). We can add them to the set. Every vertex that can reach v, can reach them too, and every vertex that can be reached from u, can be reached from them. Thus, it will still be a cute set. Now every vertex from v to u has an edge between them and the size of the set is larger.

Thus, we showed that the maximum set in the answer is always some path in the graph.

So the task is to choose some path, then remove some edges so that this path still exists and the conditions hold. Note that if the conditions hold for some set of remaining edges, then we can remove any edge from it, and the conditions will still be met. Thus, we can only leave this path.

Let's look closer into the conditions. What they actually tell is the following. If a vertex has incoming edges, then remove at least one of them. The same for the outgoing edges.

Since we are looking for a path, it's enough to leave one outgoing edge for all vertices except the last one and leave one incoming edge for all vertices except the first one.

In order to achieve that, every vertex except the last one should have at least two outgoing edges and every vertex except the first one should have at least two incoming edges.

We can see that this condition is not only necessary, but sufficient as well. Just remove the outgoing edges which don't go to the next vertex and the incoming edges which don't go from the previous vertex.

Now we can wrap this up into the dynamic programming. Initialize the answer with 1, since you can always remove all edges, and get a set with one vertex.

Then let dpv be the longest path such that it starts in vertex v, all vertices in it have at least two incoming edges and all vertices except maybe the final one have at least two outgoing edges.

Initialize the dp for the vertices that can be the final in the path (have at least two incoming edges) with 1. Then update dpv for all v that can be internal vertices (have at least two outgoing and two incoming edges) with dpu+1 for all outgoing edges (v,u).

Finally, update the answer from the vertices that can be the first one in the path. For each vertex v that has at least two outgoing edges, take the value of dpu+1 for all outgoing edges (v,u).

Overall complexity: O(n+m).

Solution (awoo)

Codeforces Round #785 (Div. 2) Editorial

By JaySharma1048576, 10 months ago, In EnglishI am sorry for the weak tests in B, for C being a little standardish and for misjudging the relative difficulties of E and F. Nevertheless, I hope you enjoyed the round. Here is the editorial. Do provide your feedback on each problem so that I can improve upon them the next time.

A. Subtle Substring SubtractionHint 1Hint 2TutorialThe problem can be solved greedily. Let n be the length of the given string.

If the n is even, it is always optimal for Alice to remove the whole string.If the n is odd, it is always optimal for Alice to remove either s1s2…sn−1 or s2s3…sn based on which gives the higher score and then Bob can remove the remaining character (sn or s1 respectively). This is optimal because if Alice chooses to remove a substring of even length 2k such that 2k<n−1 then Bob can remove the remaining n−2k≥3 characters, one of which will always be either s1 or sn, thus increasing Bob's score and decreasing Alice's score.Bonus tasksSolutionFeedbackB. A Perfectly Balanced String?Hint 1TutorialLet the number of distinct characters in s be k and length of s be n. Then, s will be perfectly balanced if and only if si,si+1,…,si+k−1 are all pairwise distinct for every i in the range 1≤i≤n−k+1.

Proof why this condition is necessaryProof why this condition is sufficientBonus taskSolutionFeedbackC. Palindrome BasisHint 1Hint 2TutorialFirst, we need to observe that the number of palindromes less than 4⋅104 is relatively very small. The number of 5-digit palindromes are 300 (enumerate all 3-digit numbers less than 400 and append the first two digits in the reverse order). Similarly, the number of 4-digit, 3-digit, 2-digit and 1-digit palindromes are 90, 90, 9 and 9 respectively, giving a total of M=498 palindromes.

Now, the problem can be solved just like the classical partitions problem which can be solved using Dynamic Programming.

Let dpk,m= Number of ways to partition the number k using only the first m palindromes. It is not hard to see that dpk,m=dpk,m−1+dpk−pm,m where pm denotes the mth palindrome. The first term corresponds to the partitions of k using only the first m−1 palindromes and the second term corresponds to those partitions of k in which the mth palindrome has been used atleast once. As base cases, dpk,1=1 and dp1,m=1. The final answer for any n will be dpn,M.

The time and space complexity is O(n⋅M).

Bonus TaskSolutionFeedbackD. Lost Arithmetic ProgressionHint 1Hint 2Hint 3TutorialIf all elements of C are not present in B, then the answer is 0. It is sufficient to check the following 4 conditions to check if all elements of C are present in B or not -

The first term of B≤ The first term of C, i.e., b≤c.The last term of B≥ The last term of C, i.e., b+(y−1)q≥c+(z−1)r.The common difference of C must be divisible by the common difference of B, i.e., rmodq=0.The first term of C must lie in B, i.e., (c−b)modq=0.Now suppose the following conditions are satisfied. Let's denote an Arithmetic Progression (AP) with first term a, common difference d and n number of terms by [a,d,n].

If b>c−r then there are infinite number of progressions which can be A like [c,r,z], [c−r,r,z+1], [c−2r,r,z+2] and so on. Similarly, if b+(y−1)q<c+zr, there are infinite number of progressions which can be A like [c,r,z], [c,r,z+1], [c,r,z+2] and so on.

Otherwise, there are a finite number of progressions which can be A. Let's count them. Let A be the AP [a,p,x] and l=a+(x−1)p. It can be seen that lcm(p,q)=r, (c−a)modp=0, a>c−r and l<c+rz for any valid A. The first two conditions are trivial. The third condition is necessary because if a≤c−r then c−r will always be present in both A and B contradicting the fact that C contains all the terms common to A and B. Similarly, the fourth condition is also necessary.

The only possible values p can take according to the first condition are factors of r which can be enumerated in O(r√). The lcm condition can be checked in O(logr). For a particular value of p, there are rp possible values of a satisfying conditions 2 and 3 and rp possible values of l satisfying conditions 2 and 4. Thus, the answer is ∑lcm(p,q)=r(rp)2.

Time complexity: O(tr√logr)SolutionFeedbackE. Power or XOR?Hint 1Hint 2Hint 3Hint 4TutorialLet's consider a subsegment [Al∧Al+1∧Al+2∧…∧Ar]. Let all the ∧ symbols in this segment be replaced by Power and the ∧ symbols before Al and after Ar be replaced by XOR. Then the value of this segment will not be affected by the rest of the expression. Moreover, out of all the expressions in which this segment appears as above, it will contribute the same value to the final answer. Since the final answer is also a XOR, if the segment [l…r] appears in the above mentioned form in odd number of valid unambiguous expressions, it will contribute (…((AAl+1l)Al+2)…)Ar to the final answer else it will contribute nothing. We can find the contribution of each segment [l…r] independently for all values of 1≤l<r≤n.

Now, there are two things we need to find out:

How much (…((AAl+1l)Al+2)…)Ar will contribute to the final answer, modulo MOD=21048576.What is the parity of the count of valid unambiguous expressions, in which the segment [l...r] appears as ...⊕(…((AAl+1l)Al+2)…)Ar⊕….Part 1: Notice that since all the elements of A are powers of 2, S(l,r)=(…((AAl+1l)Al+2)…)Ar will also be a power of 2. It means that XOR-ing it with answer will flip not more than 1 bit in the answer. The rest of the calculations is pretty straightforward. S(l,r)=2Bl⋅Al+1⋅Al+2⋅…⋅Ar by properties of exponents. So, if it contributes to the answer, it will flip the Bl⋅Al+1⋅Al+2⋅…⋅Ar−th bit of the answer. Now, note that if S≥21048576, it will have no effect on the answer because S(l,r)mod21048576 will then be 0. So, we care only for those (l,r) for which S(l,r)<21048576. Since Bi≥1, Ai≥2 and so, r−l≤20 because 220=1048576. Thus, it is sufficient to calculate S(l,r) for only 20 values of r per value of l.

Part 2: We have used r−l ∧ operators as Power and 0, 1 or 2 ∧ operators as XOR. Let's say that out of the m unused operators, we need to use at least q of them as XOR. Then the number of ways to do this is (mq)+(mq+1)+(mq+2)+…+(mm). Infact, instead of finding this value, we are only interested in finding whether it is even or odd. So, we need the value of [(mq)+(mq+1)+(mq+2)+…+(mm)]mod2= [(m−1q)+(m−1q−1)+(m−1q+1)+(m−1q)+(m−1q+2)+(m−1q+1)+…+(m−1m−1)+(m−1m−2)+(mm)]mod2= [(m−1q−1)+(m−1m−1)+(mm)]mod2= (m−1q−1)mod2 as (a+a)mod2=0 and (xx)=1 by definition. (m−1q−1)mod2 can be found using Lucas' Theorem. It turns out that (nr) is odd if and only if r is a submask of n, i.e., n|r=n. Note that there are also many other ways to find this value (like Submasks DP or using the fact that r−l≤20 for precomputation) but this is the easiest one.

Some final notes -

We can maintain the final answer as a binary string of length 1048576. Find the value X=Bl⋅Al+1⋅Al+2⋅…⋅Ar and if the required parity is odd and X<1048576, flip the $X-$th bit of the string.We need to be careful while calculating Bl⋅Al+1⋅Al+2⋅…⋅Ar since Ai can be as large as 21048575. But since we are interested in values that evaluate to something smaller than 1048576, we will never try to multiply Ai for anything with Bi>20.Calculating the parity of (nr) in O(logn) may time out. The constraints are strict enough.Total time Complexity — O(nloglogMOD)Bonus TaskSolutionFeedbackF. Anti-Theft Road PlanningHint 1Hint 2TutorialFor now, lets ignore n<=32 and assume n=32.

Let's try to build the roads in such a way that no matter what path the thief takes to reach building Bi,j, the tracker will always return a fixed value Ai,j such that all Ai,j are distinct. Then by knowing the values returned by the tracker, one can easily find which building the theft occurred in. The main problem here is not to choose the lengths of the roads, since by choosing the length of road between buildings Bx1,y1 and Bx2,y2 as Ax1,y1⊕Ax2,y2, one can always achieve this property. But there is a constraint which needs to be satisfied: The total length of all roads must not exceed 48000. This is, in fact, a tight constraint (model solution uses 47616) due to which one needs to choose the values of Ai,j very efficiently.

Consider this problem — Find a permutation of numbers from 0 to 2m−1 such that the sum of XOR of consecutive integers is minimized. The answer to this is Gray Code or Reflected Binary Code. In the standard Gray Code, bit 0 is flipped 2m−1 times, bit 1 is flipped 2m−2 times, bit 2 is flipped 2m−3 times, …, bit m−1 is flipped 1 time. The idea is to use small bits more number of times compared to the larger ones.

Our task is to implement this idea in 2-dimensions. Let's look at the algorithm used to build Gray Code. If we have the Gray Code for k bits, it can be extended to k+1 bits by taking a copy of it, reflecting it and appending 1 to the beginning of the reflected code and 0 to the beginning of the original one. Here, if we have the Gray Code for 2k×2k matrix, it can be first extended to a Gray Code for 2k×2k+1 matrix and this can further be extended to a Gray Code for 2k+1×2k+1 matrix. If we build a 2m×2m matrix using this algorithm, the total length of roads used will be 32⋅(4m)⋅(2m−1). In this problem, m=5. So, total length of roads used = 32⋅1024⋅31=47616.

Once this construction is complete, finding the buildings where thefts occurred is elementary since there can now be only one building corresponding to each value returned by the tracker.

Now, coming back to the original problem, we can simply take the first n rows and the first n columns from the constructed matrix. The cost won't increase and the properties still hold.

SolutionFeedback

Codeforces Round #784 (Div. 4) Editorial

By flamestorm, 10 months ago, In EnglishThanks for participating!

1669A - Division?

Idea: SlavicG

Tutorial1669A - Division?For this problem you just need to implement what it asks you. To be able to implement it you need to know about the "if" statement.

Solution1669B - Triple

Idea: Errichto

Tutorial1669B - TripleApproach 1:

Sort the array using an efficient sorting algorithm. For every element check if the next two in the array are equal to it. If you find such an element output it. Time complexity is O(nlogn).

Approach 2:

Notice that elements have an upper bound of n, you can use an auxiliary array to store the count of each value. Go through each value and see if its count is bigger than or equal to 3. Time complexity is O(n).

Solution1669C - Odd/Even Increments

Idea: mesanu

Tutorial1669C - Odd/Even IncrementsNote is that after doing two operations of the same type, they are "cancelled out" in terms of parity, since we would change the parity of all elements once, then change it back again.

So, we know that we will do each operation exactly 0 or 1 time. It is possible to check all possible cases just by simulating, or we can notice that all elements on all indices of the same parity must have the same parity and if they do we can always find an answer, by doing just a single type of operation a single time (in case the array doesn't already contain all elements of the same parity).

The time complexity is O(n).

Solution1669D - Colorful Stamp

Idea: flamestorm

Tutorial1669D - Colorful StampFirst note that parts of the picture separated by W are independent. That is, any stamps used on one part doesn't have any impact on the other, since a character W means no stamp has been placed on that cell. So let's split the string by Ws (for example, with split() method in Python), and consider the resulting strings containing only R and B. Call one of these parts p.

In the final stamp we place on p, we must have placed RB, so it should have both the characters R and B. Therefore, if the string has only R or only B, the answer is NO.

Otherwise, the answer is YES. Let's show it. As we have just shown, we must have R next to B for the string to be possible. Consider the way to make RBRRBBBB. The final stamp can be RBRRB–––BBB. For the rest of the cells, we can make them one by one as below.WWWWWWWW→RB–––WWWWWW→RBR–––WWWWW→RBRB–––WWWW,so now we have made the prefix of the string before the final stamp. Similarly:RBRBWWWW→RBRBWWRB–––→RBRBWRB–––B→RBRBRB–––BB.Now we have made the prefix and the suffix by stamping "one character" at a time (actually, we stamp two characters, but then cover it up with another stamp).

Finally, we can put the final stamp to make the whole string.RBRBRBBB→RBRRB–––BBB.This method easily generalizes to any string. We can find the final stamp and then make the prefix and suffix one by one. The solution runs in O(n).

Solution1669E - 2-Letter Strings

Idea: SlavicG

Tutorial1669E - 2-Letter StringsOne solution is to go through all given strings, generate all strings that differ in exactly one position, and count the number of times these strings occur in the array. A possible way to count them is by using either the map/dictionary data structure or even simpler — a frequency array. Depending on the implementation, you may need to divide the answer by 2 because of overcounting pairs.

The solution runs in O(nlogn) or O(n) depending on the implementation.

Solution1669F - Eating Candies

Idea: MikeMirzayanov

Tutorial1669F - Eating CandiesWe can solve the problem with a two pointers technique. Let i be the left pointer, initially at 1, and j be the right pointer, initially at n. Let's store Alice and Bob's current totals as a and b.

Let's iterate i from the left to the right. For each i, we should do the following.

Increase a by ai (Alice eats the i-th candy).Move j leftwards until Bob's total is at least Alice's total, and update b every time we move.If the two pointers have crossed, then both Alice and Bob took the same candy, which is not possible. So we should exit and output the current answer.Otherwise, if a=b after this step, we should update the current answer to be the value that is equal to Alice and Bob.Both i and j move at most n times in total, so the solution runs in O(n).

Solution1669G - Fall Down

Idea: MikeMirzayanov

Tutorial1669G - Fall DownNote that the columns don't affect each other, so we can solve for each column by itself.

For each column, go from the bottom to the top, and keep track of the row of the last obstacle seen; call it last. Note that initially, last=n+1, since we treat the floor as the n+1th row of obstacles. Whenever we see a new obstacle, we should update last.

Now, if we ever see a stone, we should move it to row last−1, since it will be one row above the last obstacle seen (it will fall on top of it). Afterwards, we should also decrease last by 1, because if any future stones fall on top of it, they will land on the row above this stone.

This solution works in O(nm). We also accepted slower solutions that run in O(n2m) that simulate each stone falling.

Solution1669H - Maximal AND

Idea: SlavicG

Tutorial1669H - Maximal ANDThe optimal strategy is to greedily take the highest bit we have enough operations to set in every array element. To do this, we maintain a count for each bit with the number of elements that have it set already. The cost to set the i-th bit will be n−counti.

We go from the highest bit to the lowest:

If we have enough operations left, we set the bit, subtract its cost from the operations and move to the next lower bit.If we don't have enough operations, we move on to the next lower bit and don't modify the operations.We stop once we processed bit 0.The time complexity is O(nlogai).

Solution

Codeforces Round #783 Editorial

By peti1234, 10 months ago, In EnglishHope you enjoyed the problems.

Direction Change1668A - Direction Change

SolutionThe moves are symmetrical, so we can assume that n≥m. There is no solution if m=1 and n≥3, because one can only move up and down, but two consecutive down moves is required to reach (n,1).

Otherwise, there is a solution.

One should move downwards at least n−1 times, and it is forbidden to do that twice in a row, so another n−2 move is necessary (1 between each pair). So at least n−1+n−2=2⋅n−3 moves required. If n+m is even, then one more, because the parity of a+b changes after every move, and the parity is even before the first and after the last move, so the total number of moves should be even.

There is a construction for that lower bound:

Move alternately down and right. After reaching the m-th column, repeat the following sequence of moves: down, left, down, right. With this 4 move long sequence, one can move down two times.

So we will reach (n−1,m), then one more move is required, or we will reach (n,m). If we add all of these moves, we get the formula: if n+m is even then: 2⋅(m−1)+4⋅(n−m)/2=2⋅n−2,and if n+m is odd then: 2⋅(m−1)+4⋅(n−m−1)/2+1=2⋅n−3.

ImplementationfeedbackSocial Distance1668B - Social Distance

SolutionIf there is no one between the i-th and j-th person then max(ai,aj) free chairs should be between them.

So we should find a permutation p of the array a, when max(p1,p2)+max(p2,p3)...+max(pn−1,pn)+max(pn,p1) is minimal.

We can assume that the array is non-decreasing (ai≤ai+1). For each i (1≤i<n) the i largest elements from a (an−i+1 ... an) will appear in the formula at least i+1 times. Every element occurs in two segments, and we only can count i−1 segments twice. So we get a lower bound for the number of free chairs: a2+a3+...+an−1+2⋅an.

This lower bound is reachable for the empty chairs if the permutation of p is sorted. Because max(p1,p2)=p2, max(p2,p3)=p3, ... max(pn−1,pn)=pn, and max(pn,p1)=pn.

They also sit on n chairs. If we add all of these, we get that the answer is YES if: n+∑ni=1(ai)−min(ai)+max(ai)≤m. (ai={a1,a2,...an})

Implementation (C++)feedbackMake it Increasing1668C - Make it Increasing

SolutionIf the final array, is b1, b2 ... bn, than the solution is surely unoptimal if there is an 2≤i≤n, when bi>0, and bi−ai>bi−1, or b1>0. Because there was one unnecessary move on bi or on b1.

Similarly it is unoptimal, if bi<0 and bi+ai or bn<0.

We can see, that there will be a 0 in the final array. If we fix the position of the 0 element, than we can set the other values greadily: find the smallest value for each element, which is bigger than the previous one, and similarly before that element.

We can fix each element, and calculate the answer for that in O(n) time. The minimum of these values will be the final answer. So the final complexity is O(n2).

Implementation (C++)feedbackOptimal Partition1668D - Optimal Partition

SolutionLet dpi be the answer for the first i elements, and v(i,j) the value of the subarray [i,j]. With prefix sums it is easy to calculate v(i,j) quickly. With this we can get a n2 solution: dpi=max(dpj+v(j+1,i)) for j<i.

Lets call a segment winning, drawing, or losing, if the value of it is positive, 0, or negative respectively. There is an optimal solution if the length of the drawing and losing segments are 1. (The task is solvable without this observation, but it is harder to implement.) Proof: For a losing segment in the worst case we can get two losing segments with the same total length (the same value).

For a drawing segment with length k if k is even than the answer is the same if we split it into two segments with length k/2. For odd k if the sum in the first (k−1)/2 or last (k−1)/2 elements is negative, than it is possible to increase the answer, otherwise one can split the segment into (k−1)/2, 1, and (k−1)/2 long segments, and the answer for the new partition can't lessen.

So there is an optimal solution when only winning segments might be longer than 1. It is easy to handle the 1 long segments. For each i (1≤i≤n) we have to find j, 0<=j<i, where v(j+1,i)>0, and dpj+v(j+1,i) is maximal (dp0=0).

If we store the prefix sums, and assign a permutation according to the prefix sums, than we can get all the positions 1≤j<i, where v(j+1,i)>0.

Than v(j+1,i)=i−j.

So when we calculate dpi, we should update with dpi−i. This way, finding the optimal j for each i is just a prefix maximum. One can solve the problem with Fenwick tree or segment tree.

Final complexity is O(n⋅log(n)).

Implementation (C++)feedbackHalf Queen Cover1668E - Half Queen Cover

SolutionLet's assume that there is a solution for k half-queens. There are at least n−k rows, and columns, which contains no half-queen.

If the uncovered rows are r1,r2,...ra, and the columns are c1,c2,...cb, (in increasing order), each diagonal (when the difference is a constant) contains at most one of the following a+b−1 squares: (ra,c1),(ra−1,c1),...(r1,c1),(r1,c2),...(r1,cb). So a different half-queen attacks these cells.

We know that: a+b−1≤k,n−k≤a,n−k≤b, so 2⋅n≤3⋅k+1. We have a lower bound for k. It turns out, that there is a consturction, for this k.

For n=3⋅x+2, k=2⋅x+1, and we can place x+1 in the top left corner, diagonally, and x half queens in the bottom right corner diagonally.

For n=8 an optimal construction could be: (1,3), (2,2), (3,1), (7,8), (8,7).

If n=3⋅x, or n=3⋅x+1 we can put one or two half-queens, in the bottom right corner, and use the previous construction.

Implementation (C++)feedbackEdge Elimination1668F - Edge Elimination

SolutionWhen an edge is removed, the two neighbouring vertex have the same parity of edges. We say that an edge is odd, if the parity is odd, and the edge is even otherwise.

One can see, that a vertex with even degree will have the same amount of odd and even edges. For a vertex with odd degree, there will be one more odd edge.

Starting from the leaves, we can decide the parity of each edge (an edge connected to a leaf is odd).

If there is a contradiction somewhere than the answer is NO.

Otherwise, there is a construction.

In each vertex decide the removal order of the outgoing edges. Any order is good, when it always changes parity, and ends with an odd edge. Consider the directed graph with these conditions. One can see, that this graph is acyclic, so there is a topological order of that graph which will satisfy all the conditions.

Also, it is possible to solve it recursively.

Implementation (C++)feedbackCentroid Probabilities1667E - Centroid Probabilities

SolutionLet S=n+12, binomi,j=i!j!⋅(i−j)!, dpi the result of some precalculation (see below) and ansi the final answer for the i-th vertex.

Root the tree in vertex 1. It is easy to see that in the possible trees the parent of vertex 2≤i≤n is smaller than i. The cetroid will be the largest vertex, where the size of its subtree is at least S.

For each i first calculate: how many times the subtree of vertex i will be at least S (dpi).

If i=1, then dpi=(n−1)!. If i>S then the dpi=0. Otherwise (2≤i≤S) dpi=∑n−ij=S−1binomn−i,j⋅j!⋅(n−j−2)!⋅(i−1)Proof: Let's assume that the size of the subtree is j+1. Color the subtree of vertex i except i red. Color every other vertex except the first and the i-th one to blue. We have binomn−i,j differnt colorings, because we have to choose j values between i+1 and n. (binomn−i,j)

There are k possibilities for the parent of the k-th smallest blue or the k-th smallest red vertex. (j!⋅(n−j−2)!)

The parent of the i-th vertex can be anything. (i−1)

If we multiply all of these, we get the described formula.

Then ansi=dpi−∑nj=i+1ansjiProof: if the subtree of i is at least S, and the centroid is not i, than the centroid is in the subtree of i. If j is the centroid, there is exactly 1i chance, that the path from j to 1 will cross vertex i. So we have to subract ansji for each j>i.

This gives us an O(n2) solution, which is slow because of the two sum formulas.

∑n−ij=S−1binomn−i,j⋅j!⋅(n−j−2)!⋅(i−1)=∑n−ij=S−1(n−i)!⋅j!⋅(n−j−1)!⋅(i−1)j!⋅(n−i−j)!=∑n−ij=S−1(n−i)!⋅(n−j−2)!⋅(i−1)(n−i−j)!(n−i)!⋅(i−1) is a constant (for fixed i), and the difference between n−j−2 and n−i−j is i−2, is also a constant for fixed i. If we reverse the inv array, then we can calculate ∑n−ij=S−1(n−j−2)!(n−i−j)! in n⋅log(n) time for 2≤i≤S with ntt.

We can do the calculation of ansi in linear time if we store the suffix sums of the latter values.

This gives us the final complexity: O(n⋅log(n)).

Implementation (C++)feedbackYin Yang1667F - Yin Yang

SolutionBorder: cells in the first or last row or first or last column. One can see that on the border both the black and the white part is connected. So there is no solution if there is a BWBW subsequence on the border.

Otherwise there is a solution.

Solve an easier task first. Assume that there is no colored cell on the border.

Then there is a nice construction. Color white all cells in the first column, and in the 4∗k+2-nd and 4∗k+3-rd row, which is not in the last column.

One can see that the stripes (2 consequtive white rows) are connected, because no two initially colored cell shares a corner. Also different stripes are connected to each other because of the left column. If there is a white cell in the middle of a black stripe, then it must be orthogonally adjacent to a white stripe.

Similarly the black cells will be connected too.

If there are colored cells on the border, than it is impossible to do exactly this. But the most of the cells might be the same: the white stripes, and the white column on the left side. In this way, the white part is connected. For the black part, there might be 3 issues: the border is not connected to the black stripes, there are isolated black cells in the 2-nd or n−1-th row, and different black stripes might be unconnected. All of these issues is solvable locally with changing the color of some cells from white to black and vice versa.

Implementation

Codeforces Round #782 (Div. 2) Editorial

By Newtech66, 11 months ago, In EnglishThank you everyone for your participation. Do vote under the Feedback section, and feel free to give your review of the problems in the comments.

1659A - Red Versus Blue

Idea: TimeWarp101Editorial: TimeWarp101

HintsSolution1659A - Red Versus BlueWe have b B's which divide the string into b+1 regions and we have to place the R's in these regions. By the strong form of the pigeonhole principle, at least one region must have at least ⌈rb+1⌉ R's. This gives us a lower bound on the answer.

Now, we will construct a string whose answer is exactly equal to the lower bound.

We place the B's so that they are not adjacent. Then we equally distribute the R's in the b+1 regions.

Let p=⌊rb+1⌋ and q=rmod(b+1).

We place p R's in each region and an extra R in any q regions. Hence, our answer for the construction is ⌈rb+1⌉, which is equal to the lower bound.

Importantly, r>b, so none of the B's will be consecutive.

Time complexity: O(n).

Implementation (C++)Implementation (Python)Feedback1659B - Bit Flipping

Idea: Newtech66Editorial: Newtech66

HintsSolution1659B - Bit FlippingLet's see how many times a given bit will get flipped. Clearly, a bit gets flipped whenever it is not selected in an operation. Therefore, the i-th bit gets flipped k−fi times. We want to select a bit as few times as possible. Now we can handle a few cases.

k is even, bit i is 1 ⇒ fi=0 (even number of flips don't change the bit)k is even, bit i is 0 ⇒ fi=1 (odd number of flips toggle the bit from 0 to 1)k is odd, bit i is 1 ⇒ fi=1 (even number of flips don't change the bit)k is odd, bit i is 0 ⇒ fi=0 (odd number of flips toggle the bit from 0 to 1)Process the string from left to right until you can't anymore. If you still have some remaining moves at the end, you can just give them all to the last bit. Then you can construct the final string by checking the parity of k−fi.

Time complexity: O(n)Implementation (C++)Implementation (Python)Feedback1659C - Line Empire

Idea: Newtech66Editorial: Newtech66

HintsSolution1659C - Line EmpireClearly, we should always move from left to right. Also, assume x0=0 for simplicity.

Let us analyze what our cost would look like. It will be composed of a part due to moving capitals, and a part due to conquering kingdoms. If we shift our capital from xi to xj, the cost is a⋅(xj−xi). If we conquer kingdoms from (i,j] with capital xi, the cost is b⋅((xi+1−xi)+(xi+2−xi)+…+(xj−xi)), which can be written as b⋅(pj−pi−(j−i)⋅xi), where pi=x0+x1+…+xi.

Now, notice that xj−xi and pj−pi are linear. Also, if we isolate the parts involving xj−xi, the sum will be like (xj1−x0)+(xj2−xj1)+…+(xjf−xjf−1)=xjf−x0. This means we can simply write the final sum of this part as a⋅xf, where xf is the final position of the capital. We can say the same thing about pj−pi, except that the final kingdom conquered is always xn. So the final sum of this part is always b⋅pn (x0=p0=0, so they weren't written explicitly).

Our final cost, then, looks like T=a⋅xf+b⋅(pn−C), where C is composed of terms like (j−i)⋅xi. If we want to minimise T, we want to maximise C. That is achieved if we always increase xi! Then we can writeC=x0+x1+…+xf−1+xf+…+xfn−f times=pf+(n−f−1)⋅xfWe cannot increase beyond xf since that is the final position of our capital.

Hence, our final answer is given byminf∈[0,n](a⋅xf+b⋅(pn−pf−(n−f−1)⋅xf))Time complexity: O(n)Implementation (C++)Feedback1659D - Reverse Sort Sum

Idea: Newtech66Editorial: Newtech66

HintsSolution1659D - Reverse Sort SumThe first thing to notice is that any 1 in the initial array A, will contribute to the sum of elements of array C exactly n times. That means, if S=c1+c2+...+cn, S must be divisible by n.

Let k=Sn be the number of 1s in the initial array A.

Observation: The 1s in Bn form a suffix of it.

We'll process the array C from right to left.

Assume an was 1. Then, it is clear that cn=n. Then, we can place a 1 there. Now assume an was 0. Then, it is clear that if there were any 1s in A (in other words, if k>0), then cn=1. Otherwise cn=0. If this is the case, we can place a 0 there and move on. Finally, we must subtract 1 from each of the last k elements provided k>0. Decrement k if a 1 was placed. In essence, we simulated removing Bn from the elementwise sum.

Once we've processed cn, we can forget about it and continue solving the problem assuming there are n−1 elements, and so on.

The last thing is to handle subtracting 1 from the last k elements. It is possible to do it using a segment tree/BIT, but that is overkill for this problem. A simpler way is to maintain a left border for the suffix, and keep track of when the border crosses an element (say ti) and when we reach it. Then we can get a simple formula for the value of the element that looks something like ci−(ti−i).

Time complexity: O(n) or O(nlogn)Implementation (C++)FeedbackChallenge1659E - AND-MEX Walk

Idea: Newtech66Editorial: TimeWarp101

HintsSolution1659E - AND-MEX WalkObservation: The MEX can only be 0, 1, or 2.

Proof: Suppose the MEX is greater than 2. We know that on using the bitwise AND function, some on bits will turn off and the sequence will be non-increasing.

This would imply that we have 2, 1 and 0 in our sequence. However, going from 2 (10) to 1 (01) is not possible as an off bit gets turned on. Hence, 2 and 1 can't both be in our sequence.

Case 1: MEX is 0.

For MEX to be 0, there must be a walk from u to v such that the bitwise AND of the weights of all the edges in that walk is non-zero. This implies that there exists some bit which is on in all the edges of that walk.

To check this, we can loop over all possible bits, i.e. i goes from 0 to 29, and construct a new graph for each bit while only adding the edges which have the i-th bit on. We can use DSU on this new graph and form connected components. This can be processed before taking the queries.

In a query, we can go through all bits from 0 to 29 and if we get u and v in the same component for some bit, then we're done and our answer is 0.

Case 2: MEX is 1.

If we didn't get the MEX to be 0, then we know that 0 is in our sequence.

Now, in our walk, if we ever get a node which has an even edge (let's say this is the first even edge so far) and our bitwise AND so far is greater than 1 (it would also be an odd number since there's no even edges), then including this edge in our walk would guarantee a MEX of 1 since the even edge has the 0-th bit off. Taking the bitwise AND with this edge guarantees that the last bit stays off until the end of our walk and we never get 1 in the sequence. Let us call this node x. For a given u, if an x exists, then an answer of 1 is possible.

This also shows us that the value of v is not relevant, since after we get the even edge, our MEX is guaranteed to be 1 and the subsequent weights do not matter.

For the bitwise AND of the walk to be an odd number greater than 1, all edges on the walk from u to x must have the 0-th bit on and the i-th bit on for some i in [1,29].

Similar to the previous case, we now loop i from 1 to 29 and make a new graph for each bit while only adding edges which have the 0-th and the i-th bits on, and use DSU to form connected components. Within a component, if any node has an even edge, then every node in that component can be the starting point of a walk to get the answer as 1. Then, we go through all the nodes. If the current node, say, y has an even edge, then we can mark the parent node of y's component indicating that this component has an even edge.

In the queries, we can go through all the 29 graphs and if the parent of u in a graph has been marked, then we know that it's possible to have the MEX as 1.

If not, the answer must be 2 since MEX cannot exceed 2.

Time complexity: O(nlogw+(m+q)α(n)logw)Implementation (C++)FeedbackChallenge1659F - Tree and Permutation Game

Idea: Newtech66Editorial: Newtech66

Bench0310 has written another proof for the solution to this problem here and here. Many thanks to him!

HintsSolution1659F - Tree and Permutation GameLet us call all such i that satisfy pi≠i as marked. If pi=i, it is called unmarked. Also, a notation like XY means "swap X and Y in the permutation".

We are going to show that it is always possible for Alice to win if the diameter of the tree is ≥3.

First of all, it should be obvious that no matter what moves are made, we will eventually end up at a state where we have just 2 marked vertices and the token is either on one of them or neither of them (with Alice having to move). In the latter case we have a trivial win.

Proof:

As long as there are >2 marked numbers, you can always find a pair of numbers to swap that will unmark one of the numbers. One can imagine this in terms of the cycle decomposition of the permutation.

—————

Next, let us show that from the former state, we can also force a state where the two marked vertices are adjacent to each other (with Alice having to move).

Proof:

If the two marked vertices are already adjacent, we don't need to do anything. Else, let's say we have A and B where B is the vertex with the token on it. Now, consider two cases. If A is at distance ≥3 from B, we can choose any adjacent vertex to B. Let it be C. Swap C and A. Now Bob has the option of moving the token onto C or not. It wouldn't be optimal to move it away from C, because then we can force the sequence BC CA and Bob won't be able to cover any vertex with his token. So Bob must move his token onto C. Swap A and B, which puts A in its right place. Now Bob must move this token onto B, so we did it. If A is instead at distance 2 from B, pick the vertex between B and A as C, and we can repeat the same analysis as above.

—————

Now, let's say we have A and B with B being the vertex with the token on it. Let us show that, if possible, we can always move A over B and B over A (effectively "jumping" over the opposite vertex).

Proof:

For the first one, pick some vertex adjacent to B (not A). Let it be C. Swap A and C. Now Bob has the option of moving to either C or A. If he moves to A, we can force BC CA and win. If he moves to C, we swap AB (putting A in the right place) and Bob has to move his token to B. Now we can see that the marked vertex which was A, "jumped" over B to reach C.

For the second one, pick some vertex adjacent to A (not B). Let it be C. Bob must move his token to A. Swap B and C (putting B in the right place). Bob must move his token to C. Now we can see that the marked vertex with a token which was B, "jumped" over A to reach C.

—————

Like this, we can move all over the tree. Now let's move such that both of the marked vertices lie on a diameter of the tree and one of them is at one end of it.

Consider a tree with diameter ≥3. That means we have a line of at least 4 vertices taking the two marked vertices at one end. Let's consider just the first 4 vertices, and show that we can always win here.

Proof:

Say we have a configuration like A-B-C-D where A and B are marked and A has the token on it. If B has the token on it instead, we can use the moving strategy explained before to first move A to C and then B to D and then it is equivalent to the first configuration. Swap B and D. Now Bob must move his token to B. Swap A and D (putting A in its right place). Now no matter where Bob moves, after his turn no vertex will be covered and we can force BD and win.

—————

Therefore, if the diameter of the tree is ≥3, we always win.

If the diameter of the tree is 2, it is a star graph, and this is a more problematic case.

First of all, we must check if the permutation is already sorted, or we can win in the first move. We can only win in the first move if only 1 swap is required to sort the permutation, and the token is on neither of the numbers we need to swap.

If the above is not possible, several cases follow.

Let us make the following observation first. If Bob is at the center of the star and the center is a marked vertex, Bob can infinitely stall Alice.

Proof:

Let's call the center A, and suppose we need to swap the number B with it to put it in its right place. B is definitely at a leaf and 1 vertex away because of the structure of the star graph. So when Bob's turn comes he can simply move the token to where B is and alternate this way between A and B, infinitely stalling Alice. Obviously, even if we try swapping B with a different number C, we can just move to where C is next until there are just two vertices left, the center and a leaf. So Bob wins.

—————

In light of this, it never makes sense to mark the center in our turn if it is unmarked and not covered by the token.

So we have 4 cases to think of now:

- Token on center and center is marked vertex: As explained before, Alice loses here.

Before discussing the rest of the cases, let us define d as the minimum number of swaps required to sort the permutation and x is 0 if the token is on the center and 1 if it is on a leaf.

Now I claim that the parity of d+x is invariant. The magnitude of x changes by exactly 1 every turn and we can say the same about d. So considering all possible changes (−1,−1) (−1,+1) (+1,−1) (+1,+1) we can see the sum of the changes is always 0mod2. Hence proved.

Consider the possible end states for the game: (all with 2 marked vertices and with Alice having to move)

Token at center, center markedToken at unmarked leaf, center markedToken at marked leaf, center markedToken at center, center unmarkedToken at unmarked leaf, center unmarkedToken at marked leaf, center unmarkedObserve that end states 2 and 5 will never occur if the game lasts longer than 1 turn because if you go back by 1 turn, Bob would have a more optimal move. Therefore, in states 2 and 5 we can win in the very first move. Further observe that states 1 and 2 will never occur if the center was initially unmarked or we could unmark it in the first move. The only other possibility would be us being unable to unmark the center in the first move, which is a losing state. So we only care about states 4 and 6 now.

Observe that state 4 is a winning position while state 6 is a losing position. Also observe that state 4 has d+x odd but state 6 has d+x even. Now let us continue with the cases and use these facts.

- Token at center and center is unmarked vertex: Check the parity of d+x here. If it is odd, we win, otherwise we lose (follows from the invariance of d+x).

- Token at leaf and center is marked vertex: If we cannot unmark the center vertex in our very first move, we'll reach a losing position. If we can, check parity of d+x. Odd is win, even is lose. When can we not unmark the center vertex? Only if the token is on pcenter. Otherwise it is always possible.

- Token at leaf and center is unmarked vertex: Check parity of d+x. Odd is win, even is lose.

This completes the solution.

Time complexity: O(n) or O(nlogn) (depending on whether you use cycles or inversions to find the parity of d)

Implementation (C++)Feedback

Codeforces Round #781 (Div. 2) Editorial

By shishyando, 11 months ago, In EnglishAgain, I hope that you liked all the problems. Share your ideas and solutions in the comments, because there are always different ones! So, the editorial:

A: GCD vs LCM1665A - GCD vs LCM

EditorialIn this problem it is enough to print n−3, 1, 1, 1. It is easy to see that this answer is correct for any n≥4.

Implementation (C++, shishyando)B: Array Cloning Technique1665B - Array Cloning Technique

EditorialWe will use a greedy technique. Let's find the most common element in the array. Let it be x and let it occur k times in the array. Then let's make a copy where all elements are x. To do that we can make a copy of the given array and put all x in one array. Now we will repeat the algorithm for the new array until we get a copy with n numbers x.

Implementation (C++, shishyando)C: Tree Infection1665C - Tree Infection

EditorialFirstly, we can see that for any two different vertices, their children are independent. It means that infection can not spread from children of one vertex to children of another. Also it does not matter how the infection spreads among the children of some vertex, so we only need to know the amount of vertices with the same parent.

Using this knowledge we can reduce the problem to this one: You are given an array of k positive integers, each integer denotes the amount of healthy vertices with the same parent. Each second you can infect an integer in this array (by injection). Also each second all infected integers decrease by 1 (because of spreading).

Let's now use a greedy algorithm. We will sort this array in the decreasing order and infect all integers one by one. These injections are always needed because the integers are independent. After that each second all numbers decrease by 1 and we can choose one number to be decreased once more in the same second. This should be the max number.

This problem can be solved by simulating the whole process, because the sum of all integers in the beginning is n.

Implementation (C++, shishyando)D: GCD Guess1665D - GCD Guess

EditorialSolution 1

Let's iteratively find the remainder of xmod each power of 2. Initially, we know that xmod20=xmod1=0. If we know that xmod2k=r, then how do we find xmod2k+1? To do that let's ask gcd(x+2k−r,2k+1)=gcd(x+2k−r,x+2k−r+2k+1). If gcd=2k+1, then xmod2k+1=r+2k−1 else xmod2k+1=r. Using this algorithm we will find xmod230 which is just x. It takes exactly 30 queries.

Solution 2

Let's consider a set of pairwise coprime numbers 23,19,17,13,11,9,7,5,4. Their lcm>109 that's why xmodlcm=x. Let's find xmod each of these numbers. To do that, for each 1≤i≤23 we can ask gcd(x+i,x+lcm+i) (the query is (i,lcm+i)). If the gcd is a multiple of some number from our set then xmod this number is −i. After that we can use the chinese remainder theorem to find x that gives the same remainders for numbers from the set. This solution asks only 23 queries.

Observation 1: It's enough to make only 22 queries, because if we did not find anything for 1≤i≤22 then we can guarantee that i=23 will do.

Observation 2: All moduli are small, that's why it is possible to use a simplified CRT (check the implementation).

Implementation (C++, Artyom123)Implementation with CRT (C++, TheScrasse)E: MinimizOR1665E - MinimizOR

EditorialThe key idea for the solution is that the answer always lies among no more than 31 minimal numbers. According to this idea, it is possible to build a segment tree for minimum on a segment. After that we only need to find no more than 31 minimums on the segment (each time we find one we change it to ∞) and, finally, we can find all $OR$s pairwise among these 31 numbers.

It is also possible to use the Merge Sort Tree and the same idea.

Now let's prove the key idea: let's prove by induction that if all numbers are less than 2k then it's enough to consider k+1 minimal numbers.

Base case: k=1, all numbers are from 0 to 1 and the proof is obvious.

Inductive step:

Let's show that for any k≥1 if for k the statement is true then it's true for k+1.

If all numbers have 1 in k-th bit then the k-th bit of the answer is also 1, that's why we only have to minimize the remaining bits. For these bits we can apply the induction hypothesis that k+1 minimal numbers are enough. If at least two numbers have 0 in their k-th bit then the k-th bit in the answer is also 0. That's why we only consider only numbers with 0 in k-th bit and we have to minimize the remaining bits. Again applying the induction hypothesis, k+1 minimal numbers are enough. If there is exactly one number with 0 in k-th bit then the k-th bit in the answer is 1 and we have to find k+1 minimal numbers over k bits. They are among k+2 minimal numbers over k+1 bits, so k+2 minimal numbers are enough.

Implementation (C++, Artyom123)Other solutions (?)Who did what?Problem AIdea: shishyandoPolygon: shishyandoProblem BIdea: shishyandoPolygon: shishyandoProblem CIdea: shishyandoPolygon: shishyandoProblem DIdea: Artyom123Polygon: shishyandoProblem EIdea: Kirill22Polygon: shishyandoEnglish translation: shishyandoSpecial thanks: KAN for coordinating the coordinator and double checking everythingAnother special thanks: NEAR for supporting the Codeforces Community!Yet another special thanks: everyone who participated and tested!

Codeforces Round #780 (Div. 3) Editorial

By Gol_D, history, 11 months ago, In English1660A - Vasya and Coins

Idea: MikeMirzayanov

Tutorial1660A - Vasya and CoinsIf Vasya has b coins of 2 burles, then he can collect amounts of 2,4,…,2∗b burls. If Vasya does not have 1 burles coins, then he cannot collect the amount of 1 burle. If he has at least one coin in 1 burl, he can score odd amounts up to 2∗b+a. The following 1burl coins increase the maximum amount he can make. If Vasya has a coins for 1 burle, he can make up the amount of 2∗b+a burles, and 2∗b+a+1 - not anymore.

Solution1660B - Vlad and Candies

Idea: Vladosiya

Tutorial1660B - Vlad and CandiesThere will be three cases in total, let's consider them on two types of candies:

a1=a2, then we will eat candies in this order [1,2,1,2, dots,1,2]a1=a2+1, then we will eat a candy of the type 1, and then we will eat in this order [2,1,2,1,…,2,1] (almost as in the case above)a1>=a2+2, then we will eat a candy of the type 1, but there will still be more of them than candies of the type 2 and we will have to eat a candy of the type 1 again. So the answer is "NO".Now we prove that it is enough to check these conditions on two maximums of the array a. If the third condition is true, the answer is obvious "NO". Otherwise, we will by turns eat candies of the two maximum types until their number is equal to the third maximum, after which we will by turns eat candies of these three types and so on.

Solution1660C - Get an Even String

Idea: MikeMirzayanov

Tutorial1660C - Get an Even StringWe will act greedily: we will make an array prev consisting of 26 elements, in which we will mark prev[i]=true if the letter is already encountered in the string, and prev[i]=false otherwise. In the variable m we will store the length of the even string that can be obtained from s. We will go through the string by executing the following algorithm:

if prev[i]=false, mark prev[i]=true.if prev[i]=true, then we already have a pair of repeating characters to add to an even string — add 2 to the number m and clear the array used.Clearing prev is necessary because both characters that will make up the next pair must be in the s string after the current character. In other words, if the last character in the current pair was st, then the first character in the new pair can be sk, where t<k<n.

Then we calculate the answer as n−m.

Solution1660D - Maximum Product Strikes Back

Idea: Aris

Tutorial1660D - Maximum Product Strikes BackFirst, we can always get a product value equal to 1 if we remove all elements of the array. Then we need to know what maximal positive value of the product we can get. Consequently, the remaining array (after removing the corresponding prefix and suffix) should have no 0 elements. We can find maxima in all sections between zeros. Now we are left with a set of nonzero numbers. If the value of the product on the current segment is positive, it makes no sense to remove any more elements. Otherwise, the product is negative, then we must remove one negative number from the product (either to the left or to the right). Compare the values of the product on the prefix and suffix to the nearest negative value, and remove either the suffix or the prefix, respectively.

Solution1660E - Matrix and Shifts

Idea: myav, MikeMirzayanov

Tutorial1660E - Matrix and ShiftsCount to the variable sum the number of all ones in the matrix.

Then consider pairs of diagonals, one of which starts in cell A[i][0], and the other — in cell A[0][n−i] (for 1≤i≤n−1). Using cyclic shifts, we can assemble the main diagonal from this pair. Then among all such pairs (and the main diagonal), find the one that contains the maximal number of ones, and store this number in the variable Max.

The number of zeros on the main diagonal, which should be turned into ones, is equal to n−Max.

The number of ones to be turned into zeros, because they are not on the main diagonal, is calculated as sum−Max.

The total answer is calculated as n−Max+sum−Max=n+sum−2Max.

Solution1660F1 - Promising String (easy version)

Idea: MikeMirzayanov

Tutorial1660F1 - Promising String (easy version)Note the fact that if the number of minus signs is greater than the number of plus signs by at least 2, then there is sure to be a pair of standing next to minus signs (according to the Dirichlet principle). When we apply the operation of replacing two adjacent minus signs with a plus sign, the balance (the difference of plus signs and minus signs) increases by 3. Then we need to find the number of subsections such that the balance on them is a multiple of 3 and non-positive (then we can apply the operations until the balance is 0). The balance value on the segment equals the balance value on the right boundary minus the balance value on the left boundary, i.e. we can find O(1) by prefix sums.

Solution1660F2 - Promising String (hard version)

Idea: MikeMirzayanov

Tutorial1660F2 - Promising String (hard version)Now we need to quickly find for a given balance value (on the prefix), the number of matching left boundaries. The boundary is suitable if the balance on the boundary is comparable modulo 3 to the current balance and the current balance is less than the balance on the boundary, since we need the balance on the segment to be non-positive. That is, we need to be able to find a number of numbers for each value of the balance that is not less than ours. This can be done either by data structure, or notice that the balance takes only 2n+1 different values, then you can find the number of numbers not less on the prefix for O(1).

Solution

Codeforces Round #779 (Div. 2) Editorial

By _FireGhost_, 11 months ago, In EnglishThank you for participating in the contest! We hope you enjoy the problems. You can also give feedback on each problem, it will help us much in future problem settings. By the way, feel free to share your solution!

1658A - Marin and Photoshoot

Hint 1Hint 2TutorialIt is easy to see, in a beautiful picture, there must be at least 2 female cosplayers between 2 consecutive male cosplayers. It is also the sufficient condition, as if there are x male cosplayers in a subsegment, there are at least 2(x−1)=2x−2≥x for all x≥2.

SolutionFeedback1658B - Marin and Anti-coprime Permutation

Hint 1Hint 2TutorialWe can prove that g≤2.

ProofTherefore:

If n is odd, the answer is 0 since the number of odd is greater than the number of even.Otherwise, we will match odd with even and vice versa. For odd number in even position, we have (n2 )! ways. According to the multiplicative rule, the answer will be ((n2 )!)2.SolutionFeedback1658C - Shinju and the Lost Permutation

Hint 1Hint 2Hint 3TutorialIn the i-th cyclic shift, if p1>p2 then ci+1≤ci, otherwise ci+1−ci=1, so if there exists a position i such that ci+1−ci>1, the answer is NO.

This is the sufficient condition. It can be shown that, if ci+1−ci≤1 for all 1≤i<n, then there exists a permutation that satisfies.

Here is a sketch of the construction: https://codeforces.com/blog/entry/101302?#comment-899523

SolutionFeedback1658D1 - 388535 (Easy Version)

TutorialLet's look at the binary representation of numbers from 0 to 7:

000001010011100101110111Let us look at the i-th bit only (maybe i=2), we will get a sequence like [0,0,1,1,0,0,1,1]. Notice that the number of zeroes equals the number of ones in a prefix only when the length of the prefix is a multiple of 2i. Otherwise, there will be more zeros than ones.

So, we will count the number of flipped and unflipped bits for each bit position.

If the number of ones is greater than the number of zeros, the i-th bit of x must be 1.If the number of zeros is greater than the number of ones, the i-th bit of x must be 0.If the number of ones is equal to the number of zeros, that i-th bit of x can either be 0 or 1.However, if the number of ones is equal to the number of zeros, we can assign the i-th bit anything we like. The rough sketch of the proof is that if x is inside a then x⊕2i is also inside a.

Solution1658D2 - 388535 (Hard Version)

Hint 1Hint 2TutorialThere are two solutions to this problem.

If l is even and r is odd, we can skip the last bit and divide the range by two, then recursively solve it. Otherwise, we will pair ai with ai⊕1, and we will left with at most 2 candidates for x to check.

There is also another solution: we can iterate all possibilities of x (by assuming ai is l⊕x for all 1≤i≤n). If x is the hidden number, l≤ai⊕x≤r for all 1≤i≤n, so the problem reduce to "count the number of ai that l≤ai⊕x≤r", which can be solved with binary trie.

SolutionFeedback1658E - Gojou and Matrix Game

Hint 1Hint 2TutorialSuppose that Marin places a token at (a,b). If Gojou places a token at (c,d) where Vc,d<Va,b, then Gojou would not have any advantage as Marin can play at (a,b) again. After a very huge number of turns, Marin will have more points than Gojou. Generally, if a player is forced to play in a cell where they get fewer points than the previous move, they would instantly lose.

Therefore, we can rephrase the problem as such:

Apart from the first move, the token placed by a player must be more than Manhattan distance k away from the previous token placed on the matrix.Apart from the first move, the token placed by a player must be on a cell with more points than the cell with the token placed by the previous player.The player who plays the last token is the winner.This turns out to be a standard dynamic programming.

Let dp[i][j] return 1 if the player who places a token at (i,j) wins.

Let Va,b=n2, then we have dp[a][b]=1 as a base case.

Then we will fill the values of dp in decreasing values of Vi,j. dp[i][j]=1 if for all (i′,j′) such that |i−i′|+|j−j′|>k, we have dp[i′][j′]=0. Note that by taking the contrapositive, this is equivalent to for all (i′,j′) such that dp[i′][j′]=1, we have |i−i′|+|j−j′|≤k.

Let us maintain a set S that stores the pairs (i′,j′) such that dp[i′][j′]=1, then our operations are:

adding point (i,j) to Sgiven (i,j), check if for all (i′,j′) in S, |i−i′|+|j−j′|≤kNotice that |i−i′|+|j−j′|≤k⇔max(|(i+j)−(i′+j′)|,|(i−j)−(i′−j′)|)≤k.

Checking max(|(i+j)−(i′+j′)|,|(i−j)−(i′−j′)|)≤k is very simple as we only need to store the minimum and maximum of all (i+j) and (i−j).

SolutionFeedback1658F - Juju and Binary String

Hint 1Hint 2TutorialThe answer will be impossible if m is not a multiple of b+wgcd(b,w) .

Otherwise, it is proved that k≤2 is needed.

Since we need to select a minimum k, let's first check if there is a solution with k=1SpoilerOtherwise there must be an answer with k=2, and it is simple too

SpoilerBoth can be done in linear O(n) with the sliding window technique or prefixsum.

SolutionFeedback

Editorial of Codeforces Round #778 (Div. 1 + Div. 2, based on Technocup 2022 Final Round)

By TheScrasse, 12 months ago, In English1654A - Maximum Cake Tastiness

Author: TheScrassePreparation: TheScrasse

Hint 1SolutionThe answer is the sum of the 2 maximum weights.

You can always pick the 2 maximum weights: if they are ai and aj (i<j), you can flip the subsegment [i,j−1] to make them adjacent.

The result can't be larger, because the sum of the weights of any 2 pieces of cake is never greater than the sum of the 2 maximum weights.

Iterating over all pairs of pieces of cake is enough to get AC, but you can solve the problem in O(nlogn) by sorting the weights and printing the sum of the last 2 values, or even in O(n) if you calculate the maximum and the second maximum in linear time.

Complexity: O(t⋅n2), O(t⋅nlogn) or O(t⋅n)Official solution: 150288088

1654B - Prefix Removals

Author: emorgan5289Preparation: TheScrasse

Hint 1Hint 2Hint 3SolutionLet a be the initial string. For a string z, let's define z(l,r)=zlzl+1…zr, i.e., the substring of z from l to r. The final string is a(k,n) for some k.

In the final string, x=0, so the first character doesn't appear anywhere else in s. This means that ak≠ak+1,ak+2,…,an. In other words, ak is the rightmost occurrence of a letter in s.

Can you ever remove ai, if ai≠ai+1,ai+2,…,an? Notice that you would need to remove a(l,r) (l≤i≤r): this means that there must exist a(l′,r′)=a(l,r) for some l′>l. So, ai+l′−l=ai, and this is a contradiction.

Therefore, k is the smallest index such that ak≠ak+1,ak+2,…,an.

You can find k by iterating over the string from right to left and updating the frequency of each letter. Indeed ai≠ai+1,ai+2,…,an if and only if the frequency of the letter ai is 0 up to now (in the iteration from right to left we are performing). The value of k is the minimum such index i.

Complexity: O(n)Official solution: 150288210

1654C - Alice and the Cake

Author: emorgan5289Preparation: TheScrasse

Hint 1Hint 2Hint 3Hint 4SolutionFirst, let's find the initial weight. When a piece of cake is split, the sum of weights is ⌊w2⌋+⌈w2⌉:

if w is even, ⌊w2⌋+⌈w2⌉=w2+w2=w;if w is odd, ⌊w2⌋+⌈w2⌉=w−12+w+12=w.Therefore, the sum of weights is constant, and the initial weight is the sum of the final weights.

Now let's start from a cake b of weight b1=∑ni=1ai, split it (into pieces of weight bi) and try to make it equal to a. At any moment, it's convenient to consider the largest bi, because you can determine if you can split it or not.

More specifically,

if bi is not in a, you have to split it;if bi=aj for some j, you can only match aj with bi or with a bk such that bk=aj=bi (because there doesn't exist any larger bk): that's equivalent to removing aj and bi from a, b, respectively.Notice that, if at any moment the maximum element of b is smaller than the maximum element of a, the answer is NO.

If can keep a and b in any data structure that supports inserting an integer, asking for the maximum and removing the maximum (e.g., multiset or priority queue), the following algorithm works.

While either a or b is not empty,

if the maximum element of b is smaller than the maximum element of a, print NO and break;if the maximum element of b is equal to the maximum element of a, remove it from both a and b;if the maximum element m of b is larger than the maximum element of a, remove it from b and split the piece of cake (i.e., insert ⌊w2⌋ and ⌈w2⌉ into b).If a or b are both empty at the end, the answer is YES.

Complexity: O(nlogn)Official solution: 150288232

1654D - Potion Brewing Class

Author: emorgan5289Preparation: TheScrasse

Hint 1Hint 2Hint 3Hint 4Hint 5SolutionRead the hints. The rest is just implementation.

Start a DFS from node 1. Keep an array f such that fp is the exponent of p in the amount of ingredients of the current node. Keep also vi=ci/dimod998244353. At the beginning, the amount of ingredients (of node 1) is 1, so fp=0 for each p. Whenever you move from node i to node j, and ri/rj=x/y,

for each pk such that pk∣x and pk+1∤x, decrease fp by k;for each pk such that pk∣y and pk+1∤y, increase fp by k.Notice that there exist O(logn) such values of pk for each edge, and you can find them by precalculating either the smallest prime factor (with the sieve of Eratosthenes) or the whole factorization of every integer in [2,n].

Let gp be the minimum value of fp during the DFS. Then, for every p, you have to multiply the amount of ingredients of node 1 by p−gp.

The answer is the sum of vi, multiplied by the amount of ingredients of node 1.

Complexity: O(nlogn)Official solution: 150288255

1654E - Arithmetic Operations

Author: emorgan5289Preparation: TheScrasse

Hint 1Hint 2Hint 3SolutionAs explained in the hints, instead of computing the fewest number of operations, we will compute the largest number of elements that don't have an operation on them, and we will create a piecewise algorithm with final complexity O(nm−−√) , where m is the upper bound on ai.

Let d be the common difference between elements in our final sequence. First of all, I will assume that d≥0, since solving the problem for negative d is as simple as reversing the array and running the solution again. If d is fixed beforehand, we can solve the problem in O(n) by putting element i into bucket ai−d⋅i and returning n minus the size of the biggest bucket.

For d<m−−√, we can use the above algorithm to handle all of these d in O(nm−−√) time. We can keep a hashmap from bucket index → number of elements in the bucket, or we can just keep an array since the bucket indices have a range of at most O(nm−−√) which is not enough to exceed the memory limit.

For d≥m−−√, we observe that if we have two indices i,j such that j>i+m−−√, then at least one of them definitely has to have an operation performed on it, because the difference between them would have to be aj−ai≥m−−√⋅d>m which is not possible. In other words, if we consider the set of elements which are not edited, that set will have gaps between pairs of elements of size at most m−−√.

So, we can build a graph between indices with an edge i→j with label x if i<j≤i+m−−√ and aj−aij−i=x. This graph has at most nm−−√ edges. Then we just have to find the longest path in the graph where all edges have the same label. You can do this with dynamic programming -- let dpi,d be the length of the longest path ending at index i, where all edges have label d. For each i, we only need to check edges to j where i−m−−√<j<i. This means the time complexity is O(nm−−√). To store the values dpi,d sparsely, we can use either a hash map or a rotating buffer (where we only store dpi,d for i in a sliding window of width m−−√).

Complexity: O(nm−−√)Official solution: 150288285

1654F - Minimal String Xoration

Author: dario2994, emorgan5289Preparation: dario2994, TheScrasse

Hint 1Hint 2Hint 3SolutionLet f(s,x) be the string t such that ti=si⊕x.

The solution is inspired by the standard method to construct a suffix array. Let ak be an array containing the integers 0,1,2,…,2n−1, sorted according to the lexicographic ordering of the prefixes of length 2k of the strings f(s,0),f(s,1),…,f(s,2n−1) (i.e., the prefix of length 2k of f(s,ak[i]) is lexicographically smaller or equal than the prefix of length 2k of f(s,ak[i+1])). We can construct ak using ak−1, and a0 is easy to construct as a base case.

In order to construct ak from ak−1, we will first construct an auxiliary array of integers v using ak−1, where vi<vj iff f(s,i)0..2k−1<f(s,j)0..2k−1. Then, we will sort the array ak according to the comparison of tuples (vi,vi⊕2k−1)<(vj,vj⊕2k−1).

Once we have an, then we just print f(s,an,0). In total, the solution takes O(2nn2) time, which can be optimized to O(2nn) using the fact that tuples of integers in the range [0,m] can be sorted using radix sort in O(m) time. This optimization was not required to get AC.

Official solution: 150288326

1654G - Snowy Mountain

Author: emorgan5289Preparation: dario2994, emorgan5289, TheScrasse

Hint 1Hint 2Hint 3Hint 4SolutionRead the hints. The rest is just implementation.

For each set of flippable vertices of the same height, we can calculate the set of starting vertices which are able to reach at least one vertex in that flippable set. To do this, split the graph up into layers of equal height. Let cv be the minimum required energy to reach a vertex in the flippable set. cv can be computed via shortests paths, where edges in the same layer have weight 1 and edges from layer i to i+1 have weight −1. We can use bfs to relax the costs of vertices in a single layer, and then easily transition to the next layer. We do this for O(n−−√) different starting heights, so the total complexity is O(nn−−√).

Official solution: 150288345

1654H - Three Minimums

Author: dario2994, TheScrassePreparation: dario2994, TheScrasse

Hint 1Hint 2Hint 3Hint 4Hint 5SolutionFirst of all, let us state the following lemma (which is sufficient to solve the problem in O(n2) if one ignores the constraints given by the string s). We omit the proof as it is rather easy compared to the difficulty of the problem as a whole.

Lemma: The following statements hold for a permutation p1,p2,…,pn.

p is good if and only if p[1:i] and p[i:n] are good, where pi=1.If p1=1, then p is good if and only if p[1:i] and p[i:n] are good, where pi=2.If p1=1 and pn=2, then p is good if and only if it is bitonic, i.e., p1<p2<p3<⋯<pi>pi+1>⋯pn−1>pn, where pi=n.Given 1≤l<r≤n, we say that a permutation q1,q2,…,qr−l+1 of 1,2,…,r−l+1 is [l,r]-consistent if for any l≤i≤min(r,m−1):

qi−l+1<qi−l+2 if si=<;qi−l+1>qi−l+2 if si=>.Informally speaking, a permutation is [l,r]-consistent if it satisfies the constraints given by s when it is written in the positions [l,r].

For 1≤l<r≤n, let a∗∗(l,r), a1∗(l,r), a∗1(l,r), a12(l,r), a21(l,r) be the the number of good permutations which are [l,r]-consistent and, respectively,

No additional conditions;Start with 1;End with 1;Start with 1 and end with 2;Start with 2 and end with 1.For 1≤i<n and c∈<,>, let q(i,c):=[i>m or si=c]. Informally speaking, q(i,<) is 1 if and only if it can be pi<pi+1 and q(i,>) is 1 if and only if it can be pi>pi+1.

Thanks to the Lemma, one has the following relations:

a∗∗(l,r)=∑ri=la∗1(l,i)a1∗(i,r)(r−li−l).a1∗(l,l)=1. For l<r, a1∗(l,r)=∑ri=l+1a12(l,i)a1∗(i,r)(r−l−1i−l−1).Analogous formula for a∗1.a12(l,l)=0 and a12(l,l+1)=q(l,<) and a12(l,l+2)=q(l,<)⋅q(l+1,>). For l<l+1<r, a12(l,r)=q(l,<)a21(l+1,r)+q(r−1,>)a12(l,r−1).Analogous formula for a21.The problem asks to compute a∗∗(1,n). Thanks to the formulas stated above, it is straightforward to implement an O(n2) solution. Now we will tackle the hard task of optimizing it to O(nm+nlog(n)).

In order to compute a∗∗(1,n), we will compute a∗1(1,k) and a1∗(k,n) for all 1≤k≤n.

We have the recurrence relation (for k≥2)

a∗1(1,k)=∑ki=1a∗1(1,i)a21(i,k)(k−2i−1)(1)Setting xk−1:=a∗1(1,k)/(k−1)!, (1) is equivalent to (for k≥1, and also for k=0!)

k⋅xk=∑k−1i=0xia21(i+1,k+1)(k−1−i)!.(2)This looks very similar to an identify between generating functions (a derivative on the left, a product on the right); but for the fact that a21 depends on two parameters. To overcome this issue let us proceed as follows.

Notice that, if we set b to any of the functions a∗∗, a∗1, a1∗, a12, a21, it holds b(l,r)=b(l+1,r+1) whenever l>m. Hence, let us define b∗∗(k)=a∗∗(n+1,n+k) and analogously b1∗(k), b∗1(k), b12(k), b21(k).

With these new definitions, (2) becomes (for k≥0)

k⋅xk=∑k−1i=0xib21((k−1−i)+2)(k−1−i)!+∑min(k−1,m−1)i=0xia21(i+1,k+1)−b21(k+1−i)(k−1−i)!.(3)Let ui:=b21(i+2)i! and vk−1:=∑min(k−1,m−1)i=0xib21(k+1−i)−a21(i+1,k+1)(k−1−i)!. So, (3) simplifies to

k⋅xk=vk−1+∑k−1i=0xiuk−1−i.(4)We precompute in O(nm) the values of a12(l,r) and a21(l,r) for 1≤l≤m, l<r≤n. We can also precompute in O(n) the values of b12(k),b21(k) for 1≤k≤n. In O(m2) we compute also xi for all 0≤i≤m−1. Thus, in O(nm) we can compute, for all 0≤k<n, the values uk.

It is now time to start working with generating functions. Let X(t):=∑k≥0xktk, U(t):=∑k≥0uktk, V(t):=∑k≥0vktk. We know U(t) and V(t) (at least the first n coefficients) and we want to compute X(t). Since x0=1, we know X(0)=1. Moreover (4) is equivalent to the ordinary differential equation X′=V+U⋅X. This ODE is standard and its (unique) solution is given by

X=exp(∫U)(1+∫Vexp(−∫U)).Since the product of generating functions and the exponential of a generating function can be computed in O(nlog(n)), we are able to obtain the values of xk for all 0≤k<n and thus the values of a∗1(1,k).

Now, let us see how to compute a1∗(k,n). Since a1∗(k,n)=b1∗(n−k+1) for all m<k≤n, let us first compute b1∗(k) for all 1≤k≤n. By repeating verbatim the reasoning above, we get that the generating function Y(t):=∑k≥0yktk, where yk−1:=b1∗(k)/(k−1)!, is given by (V=0 in this case) Y=exp(∫U). So, it remains only to compute a1∗(k,n) for 1≤k≤m. This can be done naïvely in O(nm).

The overall complexity is O(nm+nlog(n)).

Official solution: 150306974

Codeforces Round #777 Editorial

By FairyWinx, 12 months ago, translation, In EnglishTask A. Idea FairyWinx

Hint 1Hint 2SolutionSince we want to maximize the number we need, we will first find the longest suitable number. Obviously, it is better to use only the numbers 1 and 2 for this. Therefore, the answer always looks like 2121… or 1212…. The first option is optimal when n has a remainder of 2 or 0 modulo 3, otherwise the second option is optimal.

Below is an example of a neat implementation.

CodeЗадача B. Idea FairyWinx

Hint 1Hint 2SolutionNote that the answer to the problem is "YES" if and only if the picture is a certain number of disjoint rectangles. Now, in this case, let's look at all squares of size 2×2, note that there cannot be exactly 3 filled cells in each of them.

It is also clear that if there are 3 such cells, then there will be two intersecting rectangles. Therefore, you just need to check if there is a 2×2 square in which there are exactly 3 colored cells.

CodeЗадача C. Idea FairyWinx

Hint 1Hint 1Hint 2SolutionAccording to the condition, if the upper left cell is painted black, then we cannot paint it that way. Otherwise it is possible. Let's colour the cells in the following order: (n,m),(n,m−1),…,(n,1),(n−1,m),…(1,1).

Let the cell (i,j) be colored black, then if j>1, then just paint the rectangle (i,j−1), (i,j). Otherwise, if j=1, then we will color the rectangle (i−1,j).

After such an operation, no cells that we painted before will be repainted, since they have one coordinate larger than ours, and the cell itself will be painted black.

Thus, we are able to paint the table for a maximum of n⋅m−1 operations.

CodeЗадача D. Idea FairyWinx

An important factHint 1.1Hint 1.2Hint 1.3Solution 1Let's solve a more complex problem: calculate the number of partitions into such multipliers.

This is easily solved by dynamic programming. Let dpn,d be the number of factorizations, if we have a number left to decompose the number n, and before that we divided by the number d. Let's go through all such beautiful numbers i≥d that divide n, then dpn/i,i+=dpn,d.

Note that in this case, we took into account each option exactly once, since we count the divisors in the order of their increase.

Let C be the number of divisors of the number x, and V be the number of beautiful divisors of the number x. Then it works for O(C⋅V) or O(C⋅V2⋅log) depending on the implementation (since n is always a divisor of the number x), but it all comes easily, since V is no more 700.

CodeHint 2.1Solution 2 (which almost everyone wrote)Let x=da⋅b. Where b is not a multiple of d.

Then consider a few cases:

a=1. Then a is a beautiful number, since any number multiple of d2 can be decomposed into d⋅(a/d), each of which is colored, and a number multiple of only d, obviously, cannot be decomposed. So in this case there is exactly one option.

b is composite, then obviously we can decompose in several ways if a≠1.

d is simple. If b is prime, then the statement — we have only one option to decompose the number. Since every beautiful multiplier of the form d⋅k. But since d is simple, there are no other ways to decompose it, except to add a multiplier from b, and since b is simple, then all these options will be equal before the permutation.

d is composite and is not a power of prime. If a≤2, then this case is no different from the past, since we still have to get two beautiful multipliers and they will all just be equal to d. Otherwise, let d=p⋅q, where gcd(p,q)=1. Then we can make the number p⋅qb−1 and pb−1⋅q. And also q⋅p,q⋅p,…,q⋅p, in this case we have a different number of divisors, so these options will be different, which means we have several options in this case.

d is the power of a prime number. Then d=pk. The statement, if d=p2, and x=p7, then it cannot be decomposed in several ways, otherwise, if a>2 and k>1, then let's look at the partition of p2k−1,pk+1,pk,…,pk, it is clear that if k>2, then even if b=p, then the multiplier of pk+2 will still be beautiful, so it does not differ from the composite d in last case. Otherwise, if k=2, then if a=3 and b=p, then nothing can be added, otherwise we will have the opportunity to choose 3 of the multiplier pk, and somehow decompose the rest (since in this case a>3, then at least one more multiplier will be) and add b there. And we can decompose these 3 multipliers into 2 or 3 multipliers, as written above. Therefore, the only unique case when d is the degree of a prime is d=p2,x=p7.

РеализацияЗадача E. Idea FairyWinx

Hint 1Hint 2Hint 3Hint 4Hint 5SolutionAfter each lesson, the person's number increases from the maximum number by the number of desks where no one goes. Therefore, it is easy to calculate how much time has passed since the very beginning, let it be the number k.

Then let's imagine that schoolchildren are not expelled, but at any given time we are simply interested in a student with a minimum number. Obviously, the answer in this case will not change in any way.

Let toi be the desk to which the student will move after k transfers, who originally sat at i desk. This is a standard problem that can be solved using binary lifts or not the most pleasant dfs with cycle allocation and the like. (but we do not recommend you to write the latter), we define the set Vi as the set of all numbers j, where toj=i.

Let the starting placement of the student be a permutation of b, then we will understand that if someone is transferred to the i desk after k operations, then the value in it is the minimum value in Vi. And if no one changes seats for it, then a student with the same number will always sit in it, regardless of the initial seating arrangement. After that, it is not difficult to guess the optimal starting seating of schoolchildren.

Let s be a lot of schoolchildren for whom we have not yet chosen the desk at which they are sitting. We will iterate over i from 1 to n in ascending order. Then you need to understand who should sit at the i desk.

If we know that there is a desk for which min(Vi)=i must be performed, then we must put a student with the minimum number of Vi at i, and we can put the remaining people at any desks with a number greater than i, so we will add all the other students to the set s. Otherwise, we just need to take a person from s with the minimum number and put him in a place under the number i, and then just remove him from the set of s.

РеализацияЗадача F. Idea Igorbunov

Hint 1Hint 2Hint 3Hint 4Hint 5SolutionThe inflection of the sequence is the maximum number in the subsequence. Then note that in the first subsequence, the inflection will be the maximum number in our array, let its position in the array be ind.

Then let's say for convenience that the inflection of the second subsequence will be to the right of the maximum element. (then expand the array and run the solution one more time).

In this case, we will have 3 states: both subsequences increase, the first decreases, and the second increases, or both subsequences decrease.

Let's solve the first case first:

Let dp1i be the minimum possible maximum element in a subsequence that does not contain an i element. It is considered not difficult. If dp1i−1<ai, then dp1i=min(dp1i,ai−1), since in this case we can add an i element to a subsequence that does not contain an element of i−1. Similarly, if ai−1<ai, then dp1i=min(dp1i,dp1i−1).

The third case is considered anologically, but only it needs to be counted from the end. (This array will be dp3)

Now let's deal with the second case:

Let dp2i,0 be the minimum possible last element in the second subsequence if the i element belongs to the first subsequence. And dp2i,1 is the maximum possible last element in the first subsequence if the i element belongs to the second subsequence. There are several options. If i and i−1 lie in the same and different subsequences. And we will count for i≤ind, since before this section both sub-sequences increase, and this is another calculated case. And then it is not difficult to get the conversion formulas:

dp2ind,0=dp1ind, by definition dp2ind,0If ai−1>ai, then dp2i,0=min(dp2i,0,dp2i−1,0).If dp2i−1,1>ai, then dp2i,0=min(dp2i,0,ai−1).If ai−1<ai, then dp2i,1=max(dp2i,1,dp3i−1,1).If dp2i−1,0<ai, then dp2i,1=max(dp2i,1,ai−1).Now let's understand that the element with the number i can be an inflection of the second subsequence if i>ind, as well as dp2i,1>dp3i. That is, we can move from the second state to the third.

Реализация

Codeforces Round #776 (Div. 3) Editorial

By Vladosiya, history, 12 months ago, translation, In English1650A - Deletions of Two Adjacent Letters

Idea: MikeMirzayanov

Tutorial1650A - Deletions of Two Adjacent LettersThere will be one character left in the end, so we have to delete all the characters going before and after it. That is, delete some prefix and suffix. Since we always delete some substring of length 2, we can only delete the prefix and suffix of even length, it means the answer is YES in the case when there is an odd position in s with the character c and NO otherwise.

Solution1650B - DIV + MOD

Idea: Vladosiya

Tutorial1650B - DIV + MODConsider fa(r). Note that ⌊ra⌋ is maximal over the entire segment from l to r, so if there is x in which fa gives a greater result, then xmoda>rmoda.

Note that numbers from r−rmoda to r that have an incomplete quotient when divided by a equal to ⌊ra⌋ do not fit this condition (and are guaranteed to have a value fa less than fa(r)). And the number x=r−rmoda−1:

Has the maximum possible remainder xmoda=a−1;Has the maximum possible ⌊ra⌋ among numbers less than r−rmoda.So there are two candidates for the answer — these are r and r−rmoda−1. The second candidate is suitable only if it is at least l. It remains only to compare the values of fa and select the maximum.

Solution1650C - Weight of the System of Nested Segments

Idea: myav

Tutorial1650C - Weight of the System of Nested SegmentsWe create a structure that stores for each point its coordinate, weight, and index in the input data. Sort the points array by increasing weight. The sum of weights of the first 2⋅n points will be minimal, so we use them to construct a system of n nested segments. We save the weights of the first 2⋅n points in the variable sum and remove the remaining m−2⋅n points from the array.

Now sort the points in ascending order of coordinates and form a system of nested segments such that the endpoints of ith segment are points[i] and points[2⋅n−i+1] for (1≤i≤2⋅n). Thus, the endpoints of the first segment are points[1] and points[2⋅n], the endpoints of the nth segment are points[n] and points[n+1].

For each test case we first output sum, then — n pairs of numbers i, j (1≤i,j≤m) — the indices under which the endpoints of the current segment were written in the input data.

Solution1650D - Twist the Permutation

Idea: MikeMirzayanov

Tutorial1650D - Twist the PermutationThe first thing to notice — the answer always exists. For n numbers 1⋅2⋅3…n=n! answer choices, as well as n! permutation combinations. It remains only to restore the answer from this permutation.

We will restore by performing reverse operations. On the i-th (i=n, n−1, …, 2, 1) operation will be selectd the first i elements of the array and rotate them d[i] times to the left ( elements with numbers i+1 and more remain in their places).

Where d[i] is equal to 0 if i=1, otherwise d[i]=(index+1)modi, and index – is the index of the number i.

Thus, for each i from right to left, performing a left cyclic shift operation, we move the number i at index i.

As a result, we move O(n) numbers n times. The time complexity O(n2).

Solution1650E - Rescheduling the Exam

Idea: DmitriyOwlet

Tutorial1650E - Rescheduling the ExamTo begin with, we will learn how to find the optimal place for the exam that we want to move. Let's imagine that it is not in the schedule, in this case we have two options:

Put the exam at the end of the session so that there are d−an−1 days before it.Put it in the middle of the largest break between exams ((let its length be mx), so that between it and the nearest one there is ⌊mx−12⌋, because this is no worse than putting it in any part of any other break.That is, the answer for such an arrangement is  — the minimum of the larger of these options and the minimum break, in schedule without the moved exam.

Now note that the minimum break in most variants is the same — minimum in the initial schedule. So in order to reduce μ, you need to move exactly one of the two exams that form it and you need to check which of the two options is better.

Solution1650F - Vitaly and Advanced Useless Algorithms

Idea: Aris

Tutorial1650F - Vitaly and Advanced Useless AlgorithmsNote that it is always advantageous for us to complete the task that has an earlier deadline first. Only then will we proceed to the next task. Then we can solve each problem independently for each exam. Then it remains to score 100 percent on the task on the available options. This is a typical knapsack problem with an answer recovery.

Solution1650G - Counting Shortcuts

Idea: MikeMirzayanov

Tutorial1650G - Counting ShortcutsNote that in any shortest path, we cannot return to the previous vertex. Since if the current vertex v, the previous u. The current distance dv=du+1 (the shortest distance to vertex v), the shortest distance to vertex t — dt. Then, if we return to the vertex u, the shortest distance from it to t is dt−du=dt−dv+1. If we add to the current distance, we get: (dv+1)+(dt−dv+1)=dt+2. Thus, we get a path at least 2 longer than the shortest one. Thus, our answer consists of only simple paths.

If the answer consists only of simple paths, then we will simply add vertices to the queue when traversing bfs twice (on the first visit, and on the next visit, when the distance to the vertex is equal to the shortest +1). And we will also count the number of ways to get to that vertex. Then we can output the answer as soon as we get to the vertex t the second time for processing. After that we can terminate the loop. The asymptotic will be O(n+m) since we only need bfs.

Solution

Codeforces Round #775 Editorial

By ch_egor, 12 months ago, translation, In EnglishThanks for the participation!

1649A - Game was authored by Jeffrey and prepared by DmitryGrigorev

1649B - Game of Ball Passing was authored by low_ and prepared by low_ and DmitryGrigorev

1648A - Weird Sum was authored and prepared by cookiedoth

1648B - Integral Array was authored by grphil and prepared by shishyando

1648C - Tyler and Strings was authored and prepared by Tikhon228

1648D - Serious Business was authored and prepared by ligaydima

1648E - Air Reform was authored and prepared by grphil

1648F - Two Avenues was authored by I_love_myself and prepared by isaf27

1649A - GameIt is easy to see that if there are no water locations, the answer is 0. Otherwise, we should jump from the last accessible from the start land location to the first land location from which the finish is accessible. In order to find these locations, one can use two consecutive while loops, one increasing l from 1 until al+1=0, and the other one decreasing r from n until ar−1=0. After the loops finish, we know that we should jump from the l-th location to the r-th at the cost of r−l.

1649B - Game of Ball PassingIf max(a)⋅2≤sum(a), we can always prove that we can only use one ball.

For other cases, the number of balls is determined by 2⋅max(a)−sum(a).

1648A - Weird SumWe note that the manhattan distance between cells (r1,c1) and (r2,c2) is equal to |r1−r2|+|c1−c2|. For each color we will compose a list of all cells (r0,c0),…,(rk−1,ck−1) of this color, compute the target sum for this color, and sum up the answers for all colors. The sum is equal:

∑i=0k−1∑j=i+1k−1|ri−rj|+|ci−cj|=(∑i=0k−1∑j=i+1k−1|ri−rj|)+(∑i=0k−1∑j=i+1k−1|ci−cj|)We will compute the first sum, the second sum is analogous. Let an array s be equal to r, but sorted in increasing order. Then:

∑i=0k−1∑j=i+1k−1|ri−rj|=∑i=0k−1∑j=i+1k−1sj−si=(∑i=0k−1∑j=i+1k−1sj)+(∑i=0k−1∑j=i+1k−1−si)The value sj occurs in the first double sum exactly j times, the value −si occurs in the second sum exactly k−1−i times. Then, the value is equal to:

∑j=0k−1jsj+∑i=0k−1−(k−1−i)si=∑i=0k−1(2i+1−k)siThe last sum can be computed in O(k), the time complexity to sort an array is O(klogk). The overall complexity is O(nmlog(nm)). We can also sort arrays of coordinates by adding cells to lists in the right order. This yields an O(nm) solution.

1648B - Integral ArrayLet's consider x,y∈a and r∉a. If y⋅r≤x<y⋅(r+1) then ⌊xy⌋=r, but r is not in a, so the answer is "No". Let's suggest that y and r are already given. We can check if there exists such x∈a from the mentioned segment in O(1). It is done by considering array cntx — the amount of occurrences of x in a, and prefix sums for that array. Now we only need to run this check for each r and y. To do that we can iterate through all r∉a and y∈a in increasing order. If r⋅y>c then there is definitely no such x so we can consider the next r. This optimization speeds up the process and makes the whole solution work in O(ClogC).

1648C - Tyler and StringsLet K be the size of the alphabet, that is, the number of the maximum letter that occurs in it.

First, let's calculate how many different strings can be composed if we have c1 letters of the 1th type, c2 letters of the 2th type, …, cK letters of the K type. This is the school formula:

P(c1,c2,…,cK)=(c1+c2+…+cK)!c1!⋅c2!⋅…⋅cK!to quickly calculate it for different c1,c2,…,ck pre-calculate all factorials and their reciprocals modulo C=998244353 in O(n⋅logC)

In order for the string x to be less than the string t, they must have the same prefix. Let's iterate over the length of this matching prefix from 0 to min(n,m). If strings x and t have the same first i characters, then we know exactly how many letters we have left. To support this, let's create an array cnt, at the i-th position of which there will be the number of remaining letters of type i.

Let's iterate over the letter that will appear immediately after the matching prefix. For the resulting string to be less than t, this letter must be strictly less than the corresponding letter in t, and all subsequent letters can be arranged in any order. Let's calculate the number of rows x considered in this way according to the formula above.

The only case where the resulting string x can be lexicographically less than t, which we will not count, is when it is a prefix of the string t, but has a shorter length. We will separately check whether we can get such a string, and if so, add 1 to the answer.

Since at each of at most min(n,m) steps we need to go through at most K options for the next letter, and we calculate each option in O(K) - we get the asymptotics O(min(n,m)⋅K2+n⋅logC)

To speed up the resulting solution, let's create an array add, in the i-th cell of which we store how many ways it will be possible to arrange the remaining letters if the letter i is put in the current position. In fact addi=(cnt1+cnt2+…+cntK−1)!cnt1!⋅cnt2!⋅…⋅(cnti−1)!⋅…⋅cntK!If we learn how to maintain this array, then at each step we only need to take the sum of the elements at some of its prefix. Let's see how it changes if the next letter in the string t is i, i.e. cnti should decrease by 1.

For all cells j≠i addj is replaced by addj⋅cnticnt1+cnt2+…+cntK−1. To apply modifications to the entire array, let's create a separate variable modify, by which we need to multiply the value in the cell to get the value that should be there.

For cell i, addi will be replaced by addi⋅cnti−1cnt1+cnt2+…+cntK−1. And taking into account the fact that we applied a modifier to all cells, it is enough to multiply the value of addi by cnti−1cntiWith this optimization, we now spend only O(K) actions at each step to calculate the prefix sum, and O(log(C)) to calculate what to multiply the array cells by. We get the asymptotics O(min(n,m)⋅(K+log(C))) To get rid of K asymptotically, note that the only thing we want to do with the add array is take the sum at the prefix and change the value at the point. This can be done in O(log(K) using the Fenwick Tree or the Segment Tree. Applying them, we get the final asymptotic O(min(n,m)⋅(log(K)+log(C))).

In fact, log(C) in the asymptotics can be eliminated by precalculating modulo reciprocals for all numbers from 1 to n faster than O(n⋅log(C)), but in this task was not required.

1648D - Serious BusinessLet's denote pref[i][j]:=∑j−1k=0a[i][k]. Then define s and t as follows:

s[i]=pref[0][i+1]−pref[1][i]f[i]=pref[1][i+1]−pref[2][i]+pref[2][n]Now we can transform the problem to following: compute max0≤i≤j<ns[i]+f[j]−cost(i,j) where cost(i,j) is the minimal cost of unlocking segment [i,j].

Let's define dp[i] as the maximum profit for going from (1,1) to (2,i), if the rightmost segment that we have used ends in i (so it's s[j] for some j minus cost of covering segment [i,j], when we know that there's a segment ending at i).

The calculation of dp is as follows: for all i look through each segment, which ends at i, and relax dp[i] with maxl−1≤j<idp[j]−k. It can be calculated using segment tree.

Now consider the optimal usage of segments. Fix the rightmost segment. The profit for this segment usage should be dp[i]+f[j]+k for some i,j on this segment. So we can bruteforce the rightmost segment in our answer and relax the overall answer with maxl≤i≤j≤rdp[i]+f[j]−k. Also there's a case where taking only 1 segment is optimal, then we should relax the answer with maxl≤i≤j≤rs[i]+f[j]−k. We can calculate all of this using segment tree.

Overall complexity is O(qlogn).

1648E - Air ReformThe formal statement of this problem is that we have a weighted graph, for which we build it's complement, where the weight of an edge between A and B equals to minimal maximum on path from A to B in initial graph. The same way we calculate edge weights of initial graph, and we have to output them.

We can notice, that the path where maximum wight is minimal goes directly through the minumum spanning tree. That means that in order to get the final edges weights we need to calculate the minimum spanning tree on the graph complement and to get the final weights of initial edges we need to get the maximum on the tree path, which we can do in O(mlogn) time with binary jumping pointers.

In order to build the minimum spanning tree of graph complement, we will do something like Kruskal algorithm. We will sort the edges of initial graph by their weights and store sets of connected vertices by edges of weights less than last added. The same way we will store the sets of connected vertices in graph complement by edges of weights less than last added. These complement components will form subsets of initial components.

While adding a new edge, some connected components of initial graph can be merged. That means that some complement components can be merged. We can merge only those complement components, that are subsets of different initial components that became merged after adding an edge. These complement components become merged only if there exists some edge between two vertices of complement components in complement graph. In other words, between some pair of vertices in different complement components there is no edge in initial graph.

So when two initial components S and T become merged, we can iterate over all pair of complement components, such that first one is subset of S and second one is subset of T. For each two vertices in them we should check that there is an edge between them in initial graph. Only in this case we can not merge these two complement components. For each of this unsuccessful attempt of merging two complement components, we do as much iterations, as there are edges between them in initial graph. So the total number of iterations in unsuccessful merges is O(m). And for successful merges the complement components are merged and a new edge is added to complement minimum spanning tree. So the total number of successful merges is O(n) and the total time if O(mlogm) for edges sorting and O(m) for complement MST build. After that we can find weights of initial edges in O(mlogn) time.

1648F - Two AvenuesLet's consider two edges from the answer e1, e2. At least one of them should lie on dfs tree, otherwise the graph will be connected after removing e1, e2 and the answer will be 0.

Let the answer be e1, e2, where e1 lies on dfs tree. What cases can be for edges e1, e2? The edge e2 should be a bridge of the graph without edge e1 (otherwise e2 can be any). Using this we can highlight possible cases:

Both edges e1, e2 are bridges of the graph.The edge e1 is the bridge of the graph, the edge e2 does not matter.The edge e1 lies on dfs tree, the edge e2 is the only outer edge covering the edge e1.Both edges e1, e2 lies on dfs tree, sets of outer edges covering e1, and covering e2 are equal.For each case let's find the maximum answer.

For each of k pairs of vertices let's consider the path between vertices in the pair.

For each edge e of dfs tree let's calculate three values:

ce — the number of paths, containing the edge e.fe — the number of outer edges, covering the edge e.he — the hash of all outer edges, covering the edge e. For each outer edge let's give random 64-bit integer, the hash will be equal to the sum of values.In the first case, the answer for two bridges e1, e2 is equal to ce1+ce2. So we should find two brides with maximum value ce.

In the second case, the answer for one bridge e1 is equal to ce1. So we should find the bridge with maximum value ce.

In the third case, we consider edges e1, such that fe1=1. The answer is ce1. So we should find edge e1 of dfs tree, such that fe1=1 with maximum value ce1.

The fourth case is very hard. We consider two edges e1, e2, such that he1=he2. The answer is equal to the number of paths, containing exactly one edge from e1, e2. We can divide each path into two vertical paths, the answer won't change.

The plan of the solution will be: let's make a dfs of the dfs tree and maintain the segment tree with operations add on segment, and maximum on segment. The prefix of the segment tree corresponds to edges on the path from the root to the current edge e2. The value in the cell corresponding to the edge e1 is equal to the answer for the pair of edges e1, e2.

It is possible to recalculate this segment tree with O(n+k) updates during the dfs tree traversal.

The unsolved problem now is how to consider only edges e1, such that he1=he2 in the maximum on segment. Let's call a cluster all edges with equal hash. All edges from one cluster lie on the vertical path. Let's consider the vertical path for each cluster: from the first occurrence of edge from the cluster to the last occurrence of edge from the cluster. Any two paths for two clusters either do not intersect or nested into each other.

When making a traversal let's add −∞ on the segment from the last edge with hash he2 to the edge e2. This move will exclude edges from the maximum. This won't interfere the values, because all hashes from the segment won't be found later in the traversal (due to the clusters structure). After that, let's find the maximum on the segment from the first edge with hash he2 to the edge e2. In that maximum all edges with the hash he2 will participate.

The total solution has the complexity O(m+(n+k)logn).

Codeforces Round #774 (Div. 2) Editorial

By MateoCV, history, 12 months ago, In EnglishThanks for participating in the round! I hope you enjoyed the problems!

1646A - Square Counting

Solution1646A - Square CountingLet the number of elements in the sequence equal to n2 be x and let the sum of all other numbers be u. Then, s=x⋅n2+u. If an element of the sequence is not equal to n2, then its value is at most is n−1. There are n+1 numbers in the sequence, so u≤(n−1)×(n+1)=n2−1. Thus, ⌊sn2⌋=⌊x⋅n2+un2⌋=⌊x+un2⌋=x, which is the value we want to find. So, to solve the problem it is enough to compute the value of ⌊sn2⌋.

Intended complexity: O(1) per test case.

Code1646B - Quality vs Quantity

Solution1646B - Quality vs Quantity Suppose Count(Red–––––)=k. If a solution exists, then there is one with Count(Blue¯¯¯¯¯¯¯¯¯¯¯)=k+1, because if there are more than k+1 numbers painted blue, we can remove some of them until we have exactly k+1 numbers, and the sum of these numbers will be smaller.

As we want Sum(Red–––––)>Sum(Blue¯¯¯¯¯¯¯¯¯¯¯) to hold, the optimal way to paint the numbers is to paint the k largest numbers red, and the k+1 smallest numbers blue.

So, to solve the problem it is enough to sort the sequence, iterate over the value of k and for each of them compute the sum of the k largest numbers, the sum of the k+1 smallest numbers and compare them. This can be done efficiently by computing the sum of every prefix and suffix of the sorted sequence in linear time. This way, we can make a constant number of operations for each k.

Intended complexity: O(nlogn)Additional commentCode1646C - Factorials and Powers of Two

Solution1646C - Factorials and Powers of TwoIf the problem asked to represent n as a sum of distinct powers of two only (without the factorials), then there is a unique way to do it, using the binary representation of n and the number of terms will be the number of digits equal to 1 in this binary representation. Let's denote this number by ones(n).

If we fix the factorials we are going to use in the sum, then the rest of the terms are uniquely determined because of the observation above. Note that 1 and 2 will not be considered as factorials in order to avoid repeating terms.

So, to solve the problem it is enough to iterate through all possibilities of including or not including each factorial (up to 14!) and for each of them calculate the number of terms used in the sum. If we used f factorials and their sum is s, then the number of terms can be calculated as f+ones(n−s). The minimum of all these numbers will be the answer.

Intended complexity: O(2k) where k is the biggest positive integer such that k!≤nAdditional commentCode1646D - Weight the Tree

Solution1646D - Weight the TreeIf n=2, we can assign w1=1 and w2=1 and there is no way to get a better answer because all vertices are good and the sum of weights cannot be smaller because the weights have to be positive.

If n>2, two vertices sharing an edge cannot be both good. To prove this, we are going to analyze two cases. If the two vertices have distinct weights, then the one with a smaller weight cannot be good, because the one with a larger weight is its neighbor. Otherwise, if both vertices have the same weight, then none of them can have another neighbor, as that would increase the sum of their neighbors by at least 1. So, the only way this could happen is if n=2, but we are assuming that n>2.

Thus, the set of good vertices must be an independent set. We will see that for each independent set of vertices in the tree, there is an assignment of weights where all the vertices from this set are good. We can assign a weight of 1 to each vertex that is not in the set, and assign its degree to each vertex in the set. Because all neighbors of a vertex in the set are not in the set, then all of them have a weight of 1 and this vertex is good.

Therefore, the maximum number of good vertices is the same as the maximum size of an independent set in this tree. For a fixed independent set of the maximum size, the construction above leads to a configuration with the minimum sum of weights. This is because all vertices must have a weight of at least 1, and the vertices in the set must have a weight of at least its degree.

So, to solve the problem it is enough to root the tree in an arbitrary vertex and solve a tree dp. Let's call f(x,b) to the pair (g,s), where g is the maximum number of good vertices in the subtree of vertex x assuming that x is good (if b=1) or that it is not good (if b=0), and s is the minimum sum of weights for that value g.

The values of f(x,b) can be computed with a dp, using the values of f in the children of node x. If b=1, then for each child c you must sum f(c,0). If b=0, for each child c you can choose the best answer between f(c,0) and f(c,1). The answer to the problem will be the best between f(root,0) and f(root,1)To construct the assignment of weights, you can do it recursively considering for each vertex if it has to be good or not, in order to keep the current value of the answer. In case both options (making it good or not) work, you have to choose to not make it good, as you do not know if its father was good or not.

Intended complexity: O(n)Code1646E - Power Board

Solution1646E - Power BoardIt is easy to see that the first row only contains the number 1 and that this number doesn't appear anywhere else on the board.

We say that an integer is a perfect power if it can be represented as xa where x and a are positive integers and a>1. For each positive integer x which is not a perfect power, we call R(x) to the set of all numbers which appear in rows x,x2,x3,….

Claim: If x≠y are not perfect powers, then R(x) and R(y) have no elements in common. Proof: Suppose there is a common element, then there exist positive integers a,b such that xa=yb. This is the same as x=yba. Because y is not a perfect power, ba has to be a positive integer. If ba=1 then x=y, which cannot happen. So then ba>1, which cannot happen as x is not a perfect power. Thus, this common element cannot exist.

Based on the observation above, for each not perfect power x we can compute the size of R(x) independently and then sum the results. For a fixed x, let k be the number of rows that start with a power of x. Then R(x) contains all numbers of the form xi⋅j where 1≤i≤k and 1≤j≤m. But, the size of this set is the same as the size of the set containing all numbers of the form i⋅j where 1≤i≤k and 1≤j≤m. Note that the number of elements in this set does not depend on x, it just depends on k.

Thus, the size of R(x) is uniquely determined by the value of k. As xk≤n, then we have that k≤log(n). Then, for each k=1,2,…,⌊log(n)⌋ we just need to compute the number of distinct elements of the form i⋅j where 1≤i≤k and 1≤j≤m. We can do this using an array of length m⋅log(n), and at the i-th step (for i=1,2,…,⌊log(n)⌋) we mark the numbers i,2i,…,mi as visited in the array, and add one to the value we are computing for each number that was not visited before. After the i-th step we have computed this value for k=i.

So, to solve the problem it is enough to compute for each not perfect power x, how many rows in the matrix start with a power of x and using the values we calculated in the last paragraph we can know how many distinct numbers are there in R(x).

Intended complexity: O(mlogn+n)Additional commentCode1646F - Playing Around the Table

Solution1646F - Playing Around the TableFor each player, we say it is diverse if all his cards have different numbers. For each player, we will call a card repeated if this player has two or more cards with that number. Observe that a player is diverse if and only if he has no repeated cards.

To construct the answer we are going to divide the process into two parts, each of them using at most n×(n−1)2 operations. In the first part, we are going to reach a configuration where everyone is diverse. In the second one, we will reach the desired configuration.

To do the first part, in each operation we will choose for each player a repeated card to pass. We will repeat this until all players are diverse. If some player is already diverse, he will pass a card with the same number as the card he will receive in that operation. This way, if a player was diverse before the operation, he will still be diverse after the operation.

We will prove that the above algorithm ends. If it does not end, at some point some non-diverse player will pass a card he already passed (not a card with the same number, the exact same card). At this point, all other players have at least one card with this number and this player has at least two (because it is non-diverse), but this implies that there are at least n+1 cards with this number, which cannot happen.

Now, we will prove that this algorithm ends in at most n×(n−1)2 operations. Consider all cards having the number c, and for each of them consider the distance it moved, but when a player is diverse, we will consider his cards as static and that the card he received (or a previous one, if there are multiple diverse players before him) moved more than once in a single operation. For each x, such that 1≤x≤n−1, consider all cards having the number c that moved a distance of x or more, and look at the one that reaches its final destination first. The first x players that passed this card already had a card with the number c on it, and for each of them, one of these cards will not move anymore (remember that once the player is diverse, his cards are static) and it moved less than x, as we are considering the first card. So, there are at most n−x cards that moved a distance of x or more. Thus, the maximum sum of distances of all cards containing the number c is 1+2+…+(n−1)=n×(n−1)2 and the maximum sum of distances of all cards is n2×(n−1)2. In each operation, the sum of all distances is increased by n so there will be at most n×(n−1)2 operations in this part.

To do the second part, for each j=1,2,…,n−1 (in this order) the i-th player will pass a card with the number ((i−j)modn)+1 a total of j times. It is easy to see that after 1+2+…+(n−1)=n×(n−1)2 operations, all players are solid.

Implementing the first part naively will result in an O(n4) algorithm, which is enough to solve the problem. However, it is possible to divide the complexity by n maintaining a stack of repeated cards for each player.

Intended complexity: O(n3)CodeAdditionally, ak2006 has made video editorials for problems B, C and D.

Codeforces Round #773 editorial

By ilyakrasnovv, 12 months ago, In EnglishHello, codeforces!

We deeply apologize for the weak pretests in the problem 1642C - Great Sequence. Anyway, we believe that you liked at least one problem from the contest :)

Thanks to Mangooste for the problem 1641E - Special Positions!

1642A - Hard WayIf the triangle's side is not parallel with the line y=0, all points on this side are safe because we can intersect it with y=0 and there will be a point from which we can reach any point on this side of our triangle.

All points on the side, which is parallel with y=0 line contains are also safe if the third point has a greater y:

Thus, a point can be unreachable if and only if it is the "upper" horizontal side of our triangle, because it is impossible to draw such line which would intersect with y=0 line and would not intersect with the inner part of our triangle:

Solution: 147513897

1642B - Power WalkingIt is quite easy to understand that every multiset's power is at least 1. The final answer is at east the number of distict integers in the multiset. It is possible to proof that the answer to the problem for k is equal to max(k,cnt), where cnt is the number of distinct integers.

Proof.If the number of distinct interest is equal to c≤k, is is obvious that we can create c multisets, i-th multiset Will only contain integers which are equal to i. We can create k−c multisets of size 1. The answer in this case is equal to k.

If the number of distinct integers is at least k, we can divide the integers into groups in such way that for each x all occurrences of x are located in the same multiset. The answer in this case is equal to cnt.

In the first case the answer is k, in the second case — cnt. Thus, the answer is equal to max(k,cnt).

Video-tutorial by ak2006

Solution: 147513934

1642C - Great SequenceLet's look at the minimal integer in our multiset. Since it can be matched with only one integer, we need to create such pair. Thus, we can maintain the current multiset. We need to take the minimal element out of it (and delete it from it), find a pair for it, and delete it from the multiset if such pair exists, or add 1 to the answer if there is no such pair.

Video-tutorial by ak2006

Solution: 147513962

Vector solution: 147513974

1642D - Repetitions DecodingLet's prove that we can turn the array into a concatenation of tandem repeats using the operations given if and only if every letter occurs an even number of times

If there is such letter x that it occurs an odd number of times there is no such sequence of operations, since the parity of the number of occurrences if letter x stays the same. If we insert a different letter, the number of occurrences of letter x does not change, if we insert letter x, we add 2 occurrences of it. Thus, it will be impossible to split the array into tandem repeats.

If we have an array s1s2...sn, and we want to reverse its prefix of length k≤n, we can insert a pair of letters equal to s1 after the k-th symbol, a pair of letters equal to s2 after (k+1)-th symbol and etc.

s1s2...sksk+1...sns1s2...sks1s1sk+1...sns1s2...sks1s2s2s1sk+1...sn...s1s2...sks1s2...sksk...s2s1sk+1...snIt is obvious that the first 2k symbols of the array form a tandem repeat. We can add it to our division and cut it out from the array. The array will now have its prefix of length k reversed. Thus, we can move any element to the beginning of the array, so we can simply sort it. Since every element occurs an even number of times, the resulting string will be a concatenation of tandem repeats consisting of the same letters.

O(2n2) insertions solution: 147514019

O(n2) insertions solution: 147514028

1642E - Anonymity Is ImportantIf i-th person is not ill, the following query exists: 0 l r 0, such that l≤i≤r.

Otherwise, the person's status is either unknown or they are ill.

If i-th person is ill, the following query exists:0 l r 1, such that l≤i≤r, and every person i such that l≤j≤r are not ill. If there is such person j that they are not ill, and j≠i,l≤j≤r. In this case, it is impossible to determine if i-th person is ill or not.

Let's maintain the indices of the people who might be ill using set. When we get a query 0 l r 0, we can find the first possible ill person with an index of at least l using lower_bound, after that, we need to delete this person from our set, find the next one and do the same thing until we find the first index greater than r. This works in O(nlogn).

If a person is not in the set, he is totally healthy. Otherwise, we can use a segment tree to store such index j that there is a query 0 i j 1 and store it in the i-th slot of our segment tree. We can update it when we get a new query. When we understand that the i-th person might be ill, we can find the first elements to the left (l) and to the right (r) of i, which might be ill using our set. The i-th person is ill when the minimal element on segment [l+1;i] is <r.

The solution works in O(nlogn+qlogn).

Solution: 147514055

Set solution: 147514064

1642F - Two ArraysLet's maintain a set of arrays of length m, add new arrays there, delete arrays from this set and understand if the set has a suitable pair for some array. To do this, let's consider a pair of sorted arrays a and b of length m. Let's write out all subsets of the array a. Then we start a counter count, and for each subset of the array b we add one to count, if the subset occurs in a and contains an odd number of elements, and subtract one if the subset occurs in a and contains an even number of elements. Note that if a and b have at least one element in common, then count will be equal to 1, otherwise it will be equal to 0. Thus, we can maintain a trie that contains all the subsets of each array in the set. Now any request to this trie is trivially done for 2m.

Now let's sort the arrays by w and use our structure to find the first array that has a suitable pair. We can simply find the pair and maintain 2 pointers, l is equal to the first array in the pair, r is equal to the second array in the pair. Note that now we are only interested in pairs l1,r1 such that l<l1<r1<r. Therefore, we will move l to the left only. When we moved it once again, we will see if there is a pair for it among l<i<r. If so, then we will move r to the left until there is a pair for l among l<i≤r. After that we can update the answer with wl+wr. The solution works in O(n⋅2m).

It is also possible to solve this problem in O(n2⋅m32) using std::bitset.

Solution: 147514090

Bitset solution: 147514108

1641E - Special PositionsFirst of all, calculate for each index the total sum of distances among all subsets if the closest selected position is to the left. Let sufi=2cnti, where cnti — the number of cpecial positions at i or to the right of i (if i>n then cnti=0).

Let speciali=1 if position i is special, otherwise speciali=0.

It's not hard to see, that the value for the position pos in this case equals to ∑pos−1i=1∑j+i=2∗posspeciali⋅sufi⋅(pos−i).

Then for each pos calculate two values:

∑pos−1i=1∑j+i=2∗posspeciali⋅sufi⋅i∑pos−1i=1∑j+i=2∗posspeciali⋅sufiSince j>i we can find first value using DNC (the second value we will find similary): we want to consider every l≤i<j≤r. Then halve this segment: m=l+r2. Then create two polynomials:

The polynomial P of size m−l+1, where Pi=speciall+i⋅(l+r).The polynomial Q of size r−m, where Qi=sufm+1+i.By multiplying this two polinomials we can recalculate the values for positions from l+m+1 to m+r and then solve two parts recursively.

Thus we can find for each index the total sum of distances among all subsets if the closest selected position is to the left. To find for each index the total sum of distances among all subsets if the closest selected positions is to the right we can do the same stuff but in inverse order.

Note, that we need to consider the case where the closest selected position to the left and the closest selected position are at the same distance from pos. It can be done by changing cnti in one of the cases by the number of special positinos strickly to the right of i.

It can be implemented in O(nlog2n) using FFT.

Solution: 147514167

1641F - Накрывающая окружностьIf the answer is r let's consider n circles C1,C2,…,Cn with centers A1,A2,…,An and radius r. If a required circle with radius r exists it should be true, that k circles Ci1,Ci2,…,Cik has non empty intersection for some i1<i2<…<ik and ik−i1<l. For some 1≤h≤k we can find intersection point of these circles on circle Cih. Let's define j=ih.

Let's define f(j) as the minimal possible r, such that there exists k circles Ci1,Ci2,…,Cik and ik−i1<l, such that j=ih for some 1≤h≤k and these circles intersect on circle Cj. Then the answer to the problem is min1≤j≤nf(j).

Let's make a procedure to check, that f(j)≤x for some x. To check that let's consider circles Cj−l+1,…,Cj,…,Cj+l−1 with centers Aj−l+1,…,Aj,…,Aj+l−1 and radius x. Each of them intersect with Cj with some arc (circular segment). We can find all these arcs. Let's now make scanline and mantain all indices of arcs covering the current point. With segment tree with lazy propagation we can check if there exists k−1 indices with difference at most l−1. The complexity of this check is O(slogn), where s is the number of arcs.

Let's iterate j from 1 to n and maintain the current answer r. Initially let's initialize r with 2–√⋅108⋅l−1√k−1√ (it's easy to prove that the answer can't be bigger than these constant for any points). Now if we have some j let's firstly check, that f(j)≤r (if not — the answer won't be updated), if it is true — let's make a binary search to find a new answer. The only problem is — the number of arcs can be big. Let's note, that Ci makes an arc on Cj if and only if |AiAj|≤2x. So let's make an infinite grid with step 2r and maintain a set of points in each square. Also, we should maintain points from the segment [j−l+1,j+l−1]. After that, we can only check indices, that are in the same square as the point Aj and in 8 neighboring squares. It's easy to prove, that if r≤2–√⋅108⋅l−1√k−1√ the expected number of points in each grid square is O(k). In practice, the average number of points to check is around 4k∼5k. So we can find these candidate points and then use in procedures to check, that f(j)≤x, which will work in O(klogn). If r is changed we can reconstruct all grid in O(l).

Due to all points are random the expected number of times when r will change is O(logn) (famous Blogewoosh #6 idea). So the complexity of this solution is O(nklogn+klognlogε−1).

Solution: 147662463

Codeforces Round #772 Editorial

By dannyboy20031204, history, 12 months ago, In English1635A - Min Or Sum

Tutorial1635A - Min Or SumThe answer is a1|a2|⋯|an. Here is the proof:

Let m=a1|a2|⋯|an. After an operation, the value m won't change.

Since, a1|a2|⋯|an≤a1+a2+⋯+an, the sum of the array has a lower bound of m. And this sum can be constructed easily: for all i∈[1,n−1], set ai+1 to ai|ai+1 and ai to 0.

Solution1635B - Avoid Local Maximums

Tutorial1635B - Avoid Local MaximumsLet's check all elements in a from the left.

Once we find that ai is a local maximum, then we should perform an operation to fix it. There are many ways to do this, but the optimal way is to set ai+1 to max(ai,ai+2), because we can avoid ai and ai+2 from being local maximums at the same time.

Proof: Let's take all indices of local maximums in the initial array and append them to an empty array b with their corresponding order. For example, if a=[1,2,1,3,1,1,3,1,4,1,2,1], we obtain b=[2,4,7,9,11]. Then, we devide b into subarrays, such that bi and bi+1 are in the same subarray if and only if bi+1−bi=2. Using the same example above, we will devide b into [2,4],[7,9,11]. To finish our proof, we need two important observations.

1. Any operation would cancel at most two local maximums.

2. Any operation won't cancel two local maximums whose indices are in different subarrays of b.

So for a fixed subarray, we need at least ⌈length2⌉ operations to cancel all corresponding local maximums, and the lower bound of the answer is the sum of ⌈length2⌉ for all subarrays.

Since the strategy described above could achieve this lower bound, our proof has completed.

Solution1635C - Differential Sorting

Tutorial1635C - Differential SortingFirst of all, if an−1>an, then the answer is −1 since we can't change the last two elements.

If an≥0, there exists a simple solution: perform the operation (i,n−1,n) for each 1≤i≤n−2.

Otherwise, the answer exists if and only if the initial array is sorted.

Proof:

Assume that an<0 and we can sort the array after m>0 operations.

Consider the last operation we performed (xm,ym,zm). Since all elements should be negative after the last operation, so azm<0 should hold before the last operation. But axm=aym−azm>aym after this, so the array isn't sorted in the end. By contradiction, we have proved that we can't perform any operations as long as an<0.

Solution1635D - Infinite Set

Tutorial1635D - Infinite SetFirst of all, let's discuss the problem where n=1 and a1=1.

For every integer x, there is exactly one integer k satisfying 2k≤x<2k+1. Let's define f(x)=k.

Then, it's quite easy to find out f(2x+1)=f(x)+1 and f(4x)=f(x)+2.

This observation leads to a simple dynamic programming solution: let dpi be the number of integer x where x∈S and f(x)=i. The base case is dp0=1 and the transition is dpi=dpi−1+dpi−2.

After computing the dp array, the final answer will be ∑i=0p−1dpi.

For the general version of the problem, in order not to compute the same number two or more times, we need to delete all "useless" numbers. A number ai is called useless if there exists an index j such that aj can generate ai after a series of operations (setting aj to 2aj+1 or 4aj). After the deletion, we can simply do the same thing above, only changing the transition a little bit: dpi=dpi−1+dpi−2+g(i), where g(i) = number of j satisfying f(aj)=i.

The final problem is how to find all the useless numbers. For every integer x, there are at most O(logx) possible "parents" that can generate it. Also, such "parent" must be smaller than x.

So, let's sort the array in increasing order. Maintain all useful numbers in a set, and for each ai, we will check whether its "parent" exists or not. Once we confirm that its parent doesn't exist, we will append it to the set of useful numbers. This works in O(nlognlogC).

Total Complexity: O(nlognlogC+p).

Solution1635E - Cars

Tutorial1635E - CarsFirst of all, let's discuss in what cases will two cars be irrelevant or destined.

If two cars are in the same direction, they can either share the same coordinate at some moment or not, depending on their speed.

In the picture above, if we set the speed of the blue car to ∞ and the red car to 1, they won't meet each other. But if we set the speed of the blue car to 1 and the red car to ∞, they will meet each other.

If two cars are irrelevant, they must look something like this:

If two cars are destined, they must look something like this:

In conclusion, if there is a relationship between car i and car j, their direction must be different. So let's build a graph: if there is a relationship between car i and car j, we'll add an undirected edge between vertices (i,j). Note that this implies any valid set of relations must form a bipartite graph.

After that, let's run dfs or bfs to make a bipartite coloring. If the graph isn't bipartite, the answer is obviously "NO". Otherwise we can get information about the cars' direction.

The next part is how to know where the cars are located. If car i and car j have a relationship and the orientation of the car i is left, we can know the following restriction:

1. if two cars are irrelevant, xi<xj must be held.

2. if two cars are destined, xj<xi must be held.

Let's build another graph. for every restriction xi<xj, add a directed edge from i to j. After that, if the graph has one or more cycles, the answer is obviously "NO". Otherwise, we can do topological sort and the ordering is one possible solution of x in decreasing order.

Total Complexity: O(n+m).

Solution1635F - Closest Pair

Tutorial1635F - Closest PairFirst of all, let's solve the problem for the whole array.

Define Li as the biggest j satisfying j<i and wj≤wi, and Ri as the smallest j satisfying j>i and wj≤wi.

Then, we consider 2n pairs of points: (Li,i) and (i,Ri) for each 1≤i≤n. In conclusion, the closest pair (the pair with the minimum weighted distance) must be among them.

Proof: Assume that (a,b) is the closest pair and a<b. If wa≤wb holds, then a=Lb must holds, otherwise (a,Lb) would obviously be a better pair.

Similarly, if wa>wb holds, then b=Ra must holds, otherwise (Ra,b) would obviously be a better pair.

The lemma above also applies to range queries by the exact same proof. So now, we first need to find Li and Ri for each 1≤i≤n, this could be simply done with a stack. Then, imagine we draw lines between the endpoints of each pair, and the problem could be reduced to: given 2n weighted segments, for each query i find the one with the minimum weight that is totally covered by [li,ri]. This is actually a classic problem, which could be solved by sweep line trick + any data structure able to maintain prefix-minimum with single point updates, like BIT or segment tree.

Total Complexity: O((n+q)logn).

Solution

Codeforces Round #771 Editorial

By atodo, 12 months ago, In EnglishI hope you enjoyed the problems! You can give feedback on each problem and also choose your favourite below. This could help me and other problemsetters understand what type of problems you want to see on Codeforces.

1638A - Reverse

Hint 1Hint 2Hint 3TutorialLet pi be the first element such that pi≠i. For the prefix of elements p1=1,p2=2,…,pi−1=i−1 we do not need to change anything because it is already the minimum lexicographic, but we would like to have i instead of pi on that position. The solution is to reverse segment [i,j], where pj=i.

Notice that i<j since pk=k for every k<i, so pk<pj=i for every k<i.

Time complexity: O(n).

Feedback1638B - Odd Swap Sort

Hint 1Hint 2Hint 3Hint 4Hint 5TutorialThe condition "ai+ai+1 is odd" means that we can only swap elements of different parity. If either the order of even elements or the order of odd elements is not non-decreasing, then it is impossible to sort the sequence. Otherwise, let's prove that it is always possible to sort the sequence. We can for example perform Bubble Sort algorithm. Note that this algorithm only swaps elements ai and ai+1 if ai>ai+1, so it will never swap two elements of the same parity (given our assumption on their order).

Time complexity: O(n).

Feedback1638C - Inversion Graph

Hint 1Hint 2Hint 3Tutorial1638C - Inversion GraphThe key idea is to start merging from the beginning using a stack. Assume that the connected components are always segments in the permutation (this solution also proves this by induction).

We will iterate the prefix and maintain in our stack the minimum/maximum element of all the segments in order. When we increase the prefix adding the next position i, we add (pi,pi) to the top of the stack. Then, we merge the top two segments while we are able to. If the top two segments have their minimum/maximum elements (min1,max1) and (min2,max2), in this order from the top, we will merge them only if max2>min1, because this means that an edge exist between the two.

When we reach the end, our stack contains all connected components. Note that merging two adjacent intervals forms a new interval, so we have proven by induction that our first assumption is correct.

Time complexity: O(n).

Feedback1638D - Big Brush

Hint 1Hint 2Hint 3Hint 4Hint 5Hint 6Tutorial1638D - Big BrushLet's try to build the solution from the last operation to the first operation. The last operation can be any 2×2 square painted in a single color. If there is no such square, it is clearly impossible. Otherwise, this square being the last operation implies that we could previously color its cells in any color, multiple times, without any consequences. We will name these special cells.

What happens when we run out of 2×2 squares painted in a single color? Well, we can use the special cells described above. The next operation considered can be any 2×2 square such that all its non-special cells are painted in the same color. If there is no such square, it is clearly impossible.

We now have a correct solution. It consists of at most nm operation because at each step we turn at least one non-special cell into a special one and there are nm cells. We can implement this solution similar to BFS. First, insert all 2×2 squares painted in a single color into a queue. Then, at each step take the square in the front of the queue, add it to the solution and make all its non-special cells special. When making a cell special, check all 2×2 squares that contain it and if some of them meet the condition after the current step, insert them into the queue. Note that there are at most 9 such squares.

Time complexity: O(nm).

Feedback1638E - Colorful Operations

Hint 1Hint 2Hint 3Hint 4Tutorial1638E - Colorful OperationsIn the first part, let's consider that for all update operations l=r. The idea is not to update each element in an Add operation and instead, keeping an array lazy[color] which stores for each color the total sum we must add to it (because we didn't do it when we had to).

Lets's discuss each operation:

Update l r c:We will use the notation l=r=i. In this operation we change the color of element i from c′ to c. First, remember that we have the sum lazy[c′] that we haven't added to any of the elements of color c′ (including i), so we better do it now because the color changes: a[i]:=a[i]+lazy[c′]. Now we can change the color to c.

But wait, what about lazy[c]? It says that we will need to add some value to element i, but this is obviously false, since now it is up to date. We can compensate by subtracting now lazy[c] from element i, repairing the mistake we will do later: a[i]:=a[i]−lazy[c]. Finally, don't forget to set color[i]:=c.

Add c x:This is as simple as it gets: lazy[c]:=lazy[c]+x.

Query i:The query operation is also not very complicated. We print the value a[i] and don't forget about lazy[color[i]]: print(a[i]+lazy[color[i]]).

The time complexity is O(1) per query.

Now we get back to the initial problem and remove the restriction l=r. Let's keep an array of maximal intervals of elements with the same color. We will name them color intervals. By doing so, we can keep the lazy value for the a whole color interval. When we change the color of all elements in [l,r], there are two kinds of color intervals that interest us in our array:

[l′,r′]⊆[l,r]:In this case the whole interval changes its color. First, we add the lazy values to each interval. Then, after changing the color of all these intervals into the same one, we can merge them all. Now we update the resulting interval similar to how we would update a single element.

l∈[l′,r′] or r∈[l′,r′] (or both):These are the two (or one) intervals that contain the endpoints l and r. Here we will first split the color interval into two (or three) smaller ones: outside and inside [l,r]. Then, we just update the one inside [l,r] as before.

Notice that in contrast to the solution for l=r, here we have to add some value on a range. We can do this using a data structure such as Fenwick tree or segment tree in O(log2(n)). Also, for storing the color intervals we can use a set. This allows insertions and deletions, as well as quickly finding the range of intervals modified in a coloring.

The time complexity is a bit tricky to determine because at first it might seem like it is O(q⋅n), but if we analyze the effect each update has on the long term, it turns out to be much better.

We will further refer to the number of intervals in our array as the potential of the current state. Let's consider that in our update we found k color intervals contained in the update interval, the potential decreases by k−1 and then it grows by at most 2 (because of the two splits). The number of steps our program performs is proportional to the total changes in potential.

In one operation, the potential can decrease by a lot, but luckily, it can only grow by 2. Because the potential is always positive, it decreases in total at most as much as it increases. Thus, the total change in potential is O(q).

Although not described here, there exists another solution to this problem using only a segment tree with lazy propagation. In this solution, our data structure stops only on monochrome segments. The time complexity is the same.

Time complexity: O(n+q⋅log2(n)).

Feedback1638F - Two Posters

Hint 1Hint 2Hint 3Hint 4Hint 5Hint 6Hint 7Tutorial1638F - Two PostersThere are many ways in which two posters can be positioned, therefore, we split the problem into multiple sub-problems. Consider the following cases.

The two posters share no common panel.The two posters share a range of common panels. Here, there are two sub-cases.The second poster does not share all its panels with the first.The second poster shares all its panels with the first.Let's find the maximum total area for each of these cases. The answer will be the maximum over them.

The important element to analyze in an optimal positioning of the two posters is the bottleneck. This is the panel (or one of them) which is completely covered by the posters and doesn't allow the area to be any larger.

The two posters share no common panel.Since the two posters cover disjoint ranges of panels, there is a left poster and a right poster. Thus, we can choose a position somewhere between the two posters and move up to the maximum all panels to the left of this position.

So, a correct solution is to consider all possible split positions. For each of them, solve the standard skyline problem for both left and right sides or, for an easier implementation, use a trivial precomputation.

Time complexity: O(n2).

The two posters share a range of common panels.In the following two subcases we will deal with pairs of posters that share some panels. So, let's make some observations before going any further.

Consider the height of the first poster (red) to be h1 and the height of the second poster (blue) to be h2. Now, let's find all panels i such that hi<hl+hr. We will color these panels yellow and the rest of them gray. Because of the condition we imposed on the heights of yellow panels, they can't be shared by the two posters. On the other hand, gray panels can.

Now we can make one more observation. The range of common panels lies between two yellow panels. Moreover, since we try to maximize the total area and the two heights are fixed, the range of common panels is one of the maximal gray ranges.

Now comes the tricky part. We can't iterate over all the maximal gray ranges. There are O(n) such ranges for any h1 and h2. And even worse, the two heights are up to 1012. The problem is that we are looking from the wrong perspective. Instead of iterating h1 and h2 and then finding the yellow panels, let's consider some possible maximal intersection range and then find all pairs of h1 and h2 influenced by this range.

Ok, but there are O(n2) ranges to consider, right? Well, there are actually only O(n).

Please note that the yellow/gray notation only works after fixing some h1 and h2, but we refer to as a maximal intersection range to those ranges that could meet the conditions for some suitable h1 and h2.

Let the smallest panel inside a maximal intersection range be its representative (if there are multiple, take the leftmost one). Now consider some panel i. For which maximal intesrection ranges is it the representative?

Start with the range [i,i] and extend to the left and to the right, while at least one of the bounding panels is larger or equal to hi. We are doing this because we search for maximal intersection ranges, and this means that they are contained between two yellow panels of smaller size. Now we stopped at some range [x,y], where hj>hx−1 and hj>hy+1 for any j∈[x,y]. Can we extend even more? No, we considered panel i to be the representative and thus, the smallest in the range, extending it any further would contradict this. We now have O(n) possible maximal intersection ranges, each having a unique representative.

Let the prefix of panels before the range be colored red and the suffix of panels after the range be colored blue. Now, let's look at the two remaining cases and solve them.

The second poster does not share all its panels with the first.This means that the first poster covers all gray panels and some of the red ones, and the second poster covers all gray panels and some of the blue ones. Consider the following example.

These are all the ways two posters can be positioned in this case. Some of them are marked as useless because they can be transformed into better configurations. How do we tell if a configuration is useful? Well, in a useful configuration, the two posters should meet one of the following two conditions.

They touch (the representative panel being a bottleneck) and one of them also has its own bottleneck. If none of them had its own bottleneck, it would be possible to stretch the wider one, while shrinking the other, in order to increase the total area. This way, a bottleneck could be formed in a better configuration.Each of them has its own bottleneck.So, let's sum up. First, we choose a representative panel. Then, we find the range it represents. Next, solve each of the above cases separately. Some prefix/suffix precomputation and two pointers algorithm should be enough.

Time complexity: O(n2).

The second poster shares all its panels with the first.This means that the second poster covers all gray panels and the first poster covers all gray panels, some of the red ones and some of the blue ones (here, we will replace blue and red with pink). Consider the following example.

This is obviously the simple subcase of the two. We only need to keep track on the left and right pink panels while we gradually decrease the height of the second poster. We will use the two pointers algorithm again.

Note that the blue poster should touch the end of the representative panel. You might argue that braking this restriction could result in a larger total area, but don't forget that we will handle those cases using other representative panels and their respective gray ranges.

Time complexity: O(n2).

FeedbackNow you can choose your favourite problem from the ones you solved during the contest or upsolved after it.

Problem A  43Problem B  155Problem C  557Problem D  177Problem E  157Problem F  43UPD: Don't forget to check out ak2006's video tutorials on his channel.

Codeforces Round #770 (Div. 2) editorial

By sevlll777, history, 13 months ago, translation, In EnglishThank you for participating, we hope you enjoyed the problems! We kindly ask you to rate each of the round's problems in the corresponding spoiler in order to improve the quality of future contests.

You can also check video editorials of problems B and C on ak2006 Youtube channel.

All problems were prepared by Alexdat2000 with the help of coauthors.

Why didn't AI participate

1634A - Reverse and ConcatenateIdea: sevlll777

Hint 1Hint 2Tutorial1634A - Reverse and ConcatenateIf k=0, the answer is 1. Otherwise, consider two cases:

The string is a palindrome (that is, s=rev(s)). Then rev(s)+s=s+rev(s)=s+s, so both operations will replace s by the string s+s, which is also a palindrome. Then for any k the answer is 1.Otherwise s≠rev(s). Then after the first operation we get either s+rev(s) (which is a palindrome) or rev(s)+s (also a palindrome). Also note that if we apply the operation to two different palindromes of length x any number of times, they cannot become equal, since they do not have the same prefix of length x. So, after the first operation from a non-palindrome 2 different strings will be obtained, and after all following operations 2 unequal strings will be obtained. So the answer is — 2.SolutionRate the problem1634B - Fortune TellingIdea: crazyilian and antontrygubO_o

Hint 1Hint 2Hint 3Tutorial1634B - Fortune TellingNotice that the operations + and ⊕ have the same effect on the parity: it is inverted if the second argument of the operation is odd, and stays the same otherwise. By induction, we conclude that if we apply the operations to some even number and to some odd number, the resulting numbers will also be of different parity.

Therefore, we can determine whether the parity of the input is the same as the parity of the output or the opposite: if the sum of a is even, then the parity does not change, otherwise it does. Thus we can find out the parity of the original number from the parity of the result, and this is enough to solve the problem because the numbers x and x+3 have different parity.

SolutionRate the problem1634C - OKEAIdea: sevlll777

Hint 1Hint 1.1Hint 2Tutorial1634C - OKEAIf k=1, you can put items on the shelves in any order.

Otherwise, there are at least 2 items on each shelf. If there are items of different parity on the shelf, it is obvious that there are two neighboring items of different parity, but then the arithmetic mean of these two items won't be whole, which is against the constraints. Therefore, all items on each shelf are of the same parity.

Notice that if the number of shelves n is odd, we cannot arrange the items correctly because the number of shelves with even and odd items must be the same (that is, if k≥2).

Let us show that for even n there is always an answer. On i-th shelf we will place items with prices i,i+n,i+2⋅n,…,i+n⋅(k−1). We can use the formula for the sum of an arithmetic progression to compute the sum of prices of a subsegment with coordinates i,l up to i,r:

sum=i⋅(r−l+1)+n(l−1)+n(r−1)2⋅(r−l+1)= =i⋅(r−l+1)+n2⋅(l+r−2)⋅(r−l+1)= =(r−l+1)⋅(i+n2⋅(l+r−2))The length of the segment (r−l+1) always divides this sum, since n is even. Therefore, this arrangement fits the requirements of the problem.

SolutionRate the problem1634D - Finding ZeroIdea: sevlll777

Hint 1Hint 2Hint 2.1Hint 3Tutorial1634D - Finding ZeroNotice that for any four numbers a,b,c,d we can locate at least two numbers among them that are certainly not zeroes using only four queries as follows.

For each of the four numbers, compute it's complement, that is, the difference between the maximum and the minimum of the other three numbers: a¯=max(b,c,d)−min(b,c,d) and so on. This takes exactly four queries.

Now, consider what happens if one of the four numbers was a zero. For instance, if a=0,b≤c≤d, then:

a¯=d−bb¯=dc¯=dd¯=cd>d−b,d≥c, so the two largest complements (b¯=c¯=d in this example) are always complements of non-zeroes. Of course, the order of the values could be different, but the numbers with the two largest complements will always be guaranteed non-zeroes.

If there is no zero among these numbers, then we can still run this algorithm because it doesn't matter exactly which numbers it will yield — they are all non-zero anyway.

Now let's learn how to solve the problem using this algorithm. Start with a "pile" of the first four numbers, apply the algorithm and throw two certain non-zeroes away. Add the next two numbers to the "pile" and drop two non-zeroes again. Repeat this until there are two or three numbers left in the "pile", depending on the parity of n. If there are three elements left, add some number that we have already dropped to the pile again and apply the algorithm the last time.

If n is even, we have made n−22⋅4=2n−4 queries.If n is odd, we have made n−32⋅4+4=2n−2 queries.The complexity of this solution is O(n), and the solution uses no more than 2n−2 queries.

SolutionRate the problem1634E - Fair ShareIdea: sevlll777

Hint 1Hint 2Hint 3Hint 4Tutorial1634E - Fair ShareIf there is a number that occurs an odd number of times in total, there is no answer.

Otherwise, let us construct a bipartite graph as follows. The left part will denote the arrays (m vertices) and the right part will denote the numbers (up to ∑ni vertices). Each array vertex is connected to all the numbers contained in the array, counted with multiplicity. That is, a vertex a from the left part is connected to a vertex b from the right part x times, where x is the count of occurrences of the number b in the a-th array.

Notice that all vertices in both parts are of even degree because the length of each array is even and the number of occurrences of each number is even. Therefore we can find a directed Eulerian circuit of this graph. Then for edges like a→b (going from the left to the right) let us add the number b to L, and for edges like a←b (going from the right to the left) add b to R.

This partitioning will obviously be valid. For each vertex on the left, the indegree equals the outdegree and hence each array is split in half, and for each vertex on the right the same condition holds, so each number occurs in L and R the same number of times and thus L=R.

SolutionRate the problem1634F - Fibonacci AdditionsIdea: Mangooste

Hint 1Hint 2Hint 3Tutorial1634F - Fibonacci AdditionsLet Ci=Ai−Bi. Consider another auxiliary array D, where D1=C1, D2=C2−C1, and Di=Ci−Ci−1−Ci−2 for i>2. Notice that arrays A and B are equal if and only if all elements of D are equal to 0.

Let's analyze how Fibonacci addition affects D. If Fibonacci addition is performed on array A on a segment from l to r, then:

Dl will increase by 1,Dr+1 will decrease by Fr−l+2, andDr+2 will decrease by Fr−l+1.Fibonacci addition on B can be handled in a similar way.

Fibonacci numbers modulo MOD can be easily precomputed, and therefore the problem can be solved in linear time.

SolutionRate the problem

Editorial of Codeforces Round #769

By Vladithur, history, 13 months ago, In EnglishYou can also find video editorials for problems B-D on ak2006's Youtube channel!

1632A — ABCHint 1Hint 2SolutionLet n≥3 and the resulting string be a. For there to be no palindromes of length greater than 1, at least all of these inequalities must be true: a1≠a2, a2≠a3, and a1≠a3. Since our string is binary, this is impossible, so the answer is "NO".

For n≤2, there are 4 strings that have the answer "YES": 0, 1, 01, and 10; as well as 2 strings that have the answer "NO": 00 and 11.

Time complexity: O(n)Solution codes1632B — Roof ConstructionHint 1Hint 2SolutionLet k be the highest set bit in n−1. There will always be a pair of adjacent elements where one of them has the k-th bit set and the other one doesn't, so the cost is at least 2k. A simple construction that reaches it is 2k−1, 2k−2, …, 0, 2k, 2k+1, …, n−1.

Time complexity: O(n)Bonus: count the number of permutations with the minimum cost.

Solution codes1632C — Strange TestHintSolutionIt is optimal to apply the third operation at most once, because is does not decrease a and always makes b≤a. This means that after we use it, we can only apply the second operation.

If we don't apply the third operation, the answer is b−a.

Suppose we do apply it. Before that, we used the first and second operations some number of times, let the resulting values of a and b be a′ and b′ respectively (a≤a′,b≤b′). The answer in this case will be (a′−a)+(b′−b)+((a′ | b′)−b′)+1 = a′+(a′ | b′)+(1−a−b). This is equivalent to minimizing a′+(a′ | b′), since (1−a−b) is constant.

To do that, we can iterate a′ from a to b. For a fixed a′, we have to minimize a′ | b′, the optimal b′ can be constructed like this:

Set b′ to zero and iterate over bits from highest to lowest. There are 4 cases:

If current bit of a′ is 0 and b is 1, set the current bit of b′ to 1.If current bit of a′ is 0 and b is 0, set the current bit of b′ to 0.If current bit of a′ is 1 and b is 1, set the current bit of b′ to 1.If current bit of a′ is 1 and b is 0, set the current bit of b′ to 1 and stop.This works in O(logb) and can also be sped up to O(1) using bit manipulation.

Time complexity: O(b) or O(blogb)Bonus 1: solve the problem in O(logb) or faster.

Bonus 2: prove that is optimal to have either a′=a or b′=b.

Solution codes1632D — New Year ConcertHint 1Hint 2Hint 3SolutionRead the hints above.

Let's find all of the bad segments. For a fixed l, let's find the largest r that has gcd(al…ar)≥r−l+1. This can be done with binary search and a sparse table / segment tree. If gcd(al…ar)=r−l+1, then the segment [l,r] is bad.

If we change ai into a big prime, no new bad segments will appear. And all bad segments that have i inside of them will disappear. So we have to find the minimum number of points to cover all of them. This is a standard problem, which can be solved greedily: choose the segment with the smallest r, delete all segments that have r in them, and repeat. In our case, this is easy to do because our segments are not nested.

Time complexity: O(nlognlogA) with a sparse table, where A is the maximum value of ai.

Notes:

There are many different modifications to the previous solution, some of them use two pointers (since segments are not nested) and some of them update the answer on the fly while searching for the bad segments. Using a segment tree and two pointers you can get the complexity O(n(logn+logA)).

You can also use the fact that for a prefix, there at most O(logA) different suffix gcd values. This leads to another way to find the bad segments.

Solution codes1632E2 — Distance Tree (hard version)Hint 1Hint 2Hint 3Hint 4SolutionRead the hints above.

Let fans be the maximum distance between two nodes that have depthv>ans. If for some x the answer is at most ans, then either ans≥depth or ⌈fans2 ⌉+x≤ans, since we can add an edge (1,u) where u is in the middle of the path connecting the two farthest apart nodes with depthv>ans. Since fans decreases as ans increases, we can use binary search. Also note that we can use two pointers and increase ans as we increase x.

How to calculate fans? Let's find for each node its two children with the deepest subtrees. Let av and bv be the depths of their subtrees (av≥bv). If there are not enough children, set this values to depthv. If bv>0, do fbv−1:=max(fbv−1,av+bv−2⋅depthv). After this, iterate i from n−2 to 0 and do fi=max(fi,fi+1).

Time complexity: O(n) or O(nlogn) with binary search.

Note: To solve E1, it is enough to calculate fans in O(n) or O(nlogn) for each ans. One way to do that is to find the diameter of the resulting tree after repeatedly deleting any leaf that has depthv≤ans (1 is also considered a leaf).

Solution codesP. S. Solution codes will be published a little later.

P. P. S. Do not forget to evaluate the problems in the announcement.

UPD: Solution codes have been posted.

Editorial of Codeforces Round #768

By BrayanD, history, 13 months ago, In English1631A - Min Max SwapAuthor: humbertoyusta

Hint 1Hint 2SolutionLet m1=max(a1,a2,...,an,b1,b2,...,bn). The answer will always be m1⋅m2 where m2 is the maximum of the array that does not contain m1.

Since m1 is fixed, the problem can be reduced to minimize m2, that is, minimize the maximum of the array that does not contain the global maximum.

WLOG assume that the global maximum will be in the array b, we can swap elements at each index x such that ax>bx, ending with ai≤bi for all i. It can be shown that the maximum of array a is minimized in this way.

Time complexity: O(n)Code1631B - Fun with Even SubarraysAuthor: humbertoyusta

Hint 1Hint 2SolutionFor simplicity, let b1,b2,...,bn=an,an−1,...,a1 (let b be a reversed). The operation transforms to select a subarray [l,r] of length 2⋅k, so k=r−l+12, then for all i such that 0≤i<k, set bl+k+i=bl+i.

b1 can not be changed with the given operation. That reduces the problem to make all elements equal to b1.

Let x be the rightmost index such that for all 1≤i≤x, bi=b1 holds.

The problem will be solved when x=n.

If an operation is applied with l+k>x+1, bx+1 will not change and x will remain the same.

The largest range with l+k≤x+1 is [1,2⋅x], applying an operation to it will lead to bx+1,bx+2,...,b2⋅x=b1,b2,...,bx, so x will become at least 2⋅x and there is not any other range that will lead to a bigger value of x.

If 2⋅x>n, it is possible to apply the operation on [x−(n−x)+1,n], after applying it bx+1,...,bn=bx−(n−x)+1,...,bx and all elements will become equal.

The problem can now be solved by repeatedly finding x and applying the operation on [1,2⋅x] or on [x−(n−x)+1,n] if 2⋅x>n.

Since x will become at least 2⋅x in each operation but the last one, the naive implementation will take O(nlogn), however, it is easy to implement it in O(n).

Code O(nlogn)Code O(n)1630A - And MatchingAuthor: humbertoyusta

Hint 1Hint 2SolutionConstructive approach (easier)Let's define c(x), the compliment of x, as the number x after changing all bits 0 to 1 and vice versa, for example c(1100102)=0011012.

It can be shown that c(x)=x⊕(n−1). Remember that n−1=11...112 since n is a power of 2.

We will separate the problem into three cases.

Case k=0:

In this case it is possible to pair x with c(x) for 0≤x<n2, getting ∑x=0n2−1x&c(x)=0.

Case 0<k<n−1:

In this case it is possible to pair each element with its compliment except 0, k, c(k) and n−1, and then pair 0 with c(k) and k with n−1, 0&c(k)=0 and k&(n−1)=k.

Case k=n−1:

There are many constructions that work in this case, if n=4 there is no solution, if n≥8 it is possible to construct the answer in the following way:

It is possible to pair n−1 with n−2, n−3 with 1, 0 with 2 and all other elements with their compliments.

(n−1)&(n−2)=n−2, for example 11112&11102=11102(n−3)&1=1, for example 11012&00012=000120&2=0, for example 00002&00102=00002All other elements can be paired with their complements and x&c(x)=0Note that (n−2)+1+0+0+...+0=n−1.

Each case can be implemented in O(n).

CodeGreedy approach (harder)Let's define a such that ai=i−1 for 1≤i≤n2 and b such that bi=c(ai) for 1≤i≤n2.

For example, for n=16 they are:

a=[00002,00012,00102,00112,01002,01012,01102,01112]b=[11112,11102,11012,11002,10112,10102,10012,10002]1st element to swap	2nd element to swap	∑i=1n/2ai&bi after swapnone	none	0b1b21b2b33b3b41b4b57b5b61b6b73b7b81All swaps are independent and are applied to the original a and b.

After swapping two adjacent elements of b (that have not been swapped) the sum will change in 2x−1 for some positive integer x.

Then it is possible to solve the problem by repeatedly swapping the pair that maximizes ∑i=1n/2ai&bi after the swap such that ∑i=1n/2ai&bi≤k is held and none of its elements have been swapped yet.

However, this only works for all values of k if n≥32, the case n≤16 can be handled with brute force.

Randomized approach (harder)Please read the previous solution. Arrays a and b from it will also be used here.

It is possible to start with a and b and repeatedly select and index x randomly and swap bx with bx+1 if ∑i=1n/2ai&bi≤k holds until ∑i=1n/2ai&bi=k.

We have no proof of this solution but it was stressed against each possible input to the problem and it worked quickly for n≥16, the case n≤8 can be handled with brute force.

1630B - Range and PartitionAuthor: humbertoyusta

Hint 1Hint 2Hint 3Hint 4SolutionFocus on how to solve the problem for a fixed interval [x,y]:

Let us define an array b such that bi=1 if x≤ai≤y or bi=−1 otherwise, for all 1≤i≤n.

Let's define psumi as b1+b2+...+bi.

We need to find a partition on k subarrays with positive sum of bi.

The sum of a subarray [l,r] is bl+bl+1+...+br=psumr−psuml−1. Then a subarray is valid if psumr>psuml−1.

We need to find an increasing sequence of psum of length k+1 starting at 0 and ending at n.

Let's define firstoccx to be the first occurrence of the integer x in psum.

If psumn<k there will be no valid sequence, otherwise the sequence 0,firstocc1,firstocc2,...,firstocck−1,n will satisfy all constraints.

Note that, since |psumi−psumi−1|=1, for i>0, then firstoccv exists and firstoccv<firstoccv+1 for 0≤v≤psumn.

This solves the problem for a fixed interval.

It remains to find the smallest interval [x,y] such that psumn≥k.

For a given interval [x,y], since psumn=b1+b2+...+bn, psumn will be equal to the number of elements of a inside the interval minus the number of elements outside.

Then for each x, it is possible to find the smallest y such that psumn≥k using binary search or two pointers.

It is also possible to note that:

psumn≥k∑i=1nbi≥k∑i=1n(−1+2⋅[x≤ai≤y])≥k∑i=1n[x≤ai≤y]≥⌈k+n2⌉We need to find the smallest interval with at least ⌈k+n2⌉ inside, let A be the array a sorted, the answer is the minimum interval among all intervals [Ai,Ai+⌈k+n2⌉−1] for 1≤i≤n−⌈k+n2⌉+1.

Complexity: O(nlogn) if solved with the previous formula or binary search, or O(n) is solved with two pointers.

Code (with the previous formula)1630C - Paint the MiddleAuthor: humbertoyusta

Hint 1Hint 2Hint 3SolutionFor each x such that all the elements a1,a2,...,ax are different from ax+1,ax+2,...,an it is impossible to apply an operation with some indices from the first part, and some other from the second one.

Then it is possible to split the array in subarrays for each x such that the previous condition holds, and sum the answers from all of them.

Let's solve the problem independently for one of those subarrays, let's denote its length as m, the values of its elements as a1,...,am and their colors as c1,...,cm:

For every tuple (x,y,z) such that 1≤x<y<z≤m and ax=ay=az it is possible to apply an operation with indices x,y and z. Then only the first and last occurrences of each element are important.

For all pairs (x,y) such that 1≤x<y≤m, ax=ay, ax is the first occurrence and ay the last occurrence of that value, a segment [x,y] will be created.

Let's denote the left border of a segment i as li and the right border as ri.

Let's say that a set of segments S is connected if the union of its segments is the segment [min(li,∀i∈S),max(ri,∀i∈S)].

Instead of maximizing ∑i=1mci, it is possible to focus on minimizing ∑i=1m[ci=0].

Lemma 1: If we have a connected set S, it is possible to apply some operations to its induced array to end up with at most |S|+1 elements with ci=0.

ProofLet X be a subarray that can be obtained by applying the given operation to the initial subarray any number of times.

Let S(X) be the set of segments that includes all segments i such that c[li]=0 or c[ri]=0 (or both), where c[i] is the color of the i-th segment of the subarray X.

Lemma 2: There is always an optimal solution in which S(X) is connected.

ProofFinally, the problem in each subarray can be reduced to find the smallest set (in number of segments), such that the union of its segments is the whole subarray. This can be computed with dp or sweep line.

DP solutionSweep line solution1630D - Flipping RangeAuthor: humbertoyusta

Hint 1Hint 2Hint 3SolutionIf we have x,y∈B (assume x>y), since all elements of B are at most ⌊n2⌋, it is possible to multiply all intervals of size x−y by either multiplying an interval of size x that starts at the position of the interval of size x−y, and an interval of size y that ends at the same position as the interval x, or multiply an interval of size x that ends at the same position as the interval of size x−y and another interval of size y that starts at the same position as the interval of size x.

For two elements x,y∈B (x>y), it is possible to add x−y to B, repeatedly doing this it is possible to get gcd(x,y).

Let g=gcd(b1,b2,...,bm:bi∈B), by applying the previous reduction g is the smallest element that can be obtained, and all other elements will be its multiples, then the problem is reduced to, multiplying intervals of size g by −1 any number of times, maximize ∑i=1nai.

Let's define the string s=000...00 of size n (0-indexed) such that si=0 if the i-th element is not multiplied by −1 or si=1 otherwise. The operation flips all values of s in a substring of size g.

Let's define fx as the xor over all values si such that imodg=x, note that fx is defined for the values 0≤x≤g−1.

In any operation, all values of f change simultaneously, since they are all 0 at the beginning only the states of s such that all fi are equal are reachable.

To prove that all states of s with all fi equal are reachable, let's start with any state of s such that f=000...00 and repeatedly select the rightmost i such that si=1 and i≥g−1 and flip the substring that ends in that position, after doing that as many times as possible, si=0 for g−1≤i≤n−1. If si=1 for any 0≤i<g, then fi=1 which is a contradiction since fg−1=0 and all fi change simultaneously, then s=000...00. The case with all values of f equal to 1 is similar.

After this, it is possible to solve the problem with dp.

Let dpi,0 be the maximum sum of ai,ai−g,ai−2⋅g,...,ai−k⋅g such that i−k⋅g≡i(modg) and ⨁k≥0,i−k⋅g≥0fi−k⋅g=0 and dpi,1 be the same such that ⨁k≥0,i−k⋅g≥0fi−k⋅g=1.

The answer to the problem is max(∑i=n−gn−1dpi,0,∑i=n−gn−1dpi,1) (0-indexed).

This dp can be computed in O(n).

Code1630E - Expected ComponentsAuthor: BrayanD

Hint 1Hint 2Hint 3SolutionThe problem can be solved by applying Burnside's lemma.

The number of different permutations of the cyclic array a is equal to the sum of number of fixed points for each permutation function divided by the number of permutations functions.

Let's focus on two parts.

First part (find the number of different permutations of a):

Let's define a permutation function Fx(arr) as the function that cyclically shifts the array arr by x positions.

In this problem for an array of size n we have n possible permutations functions and we would need to find the sum of the number of fixed points for each permutation function.

To find the number of fixed points for a permutation function Fx() we have that arri must be equal to arr(i+x)%n, if we add an edge (i,(i+x)%n) for each position i then by number theory we would obtain that gcd(n,x) cycles would be formed and each one of size ngcd(n,x), then we can note that each position i will belong to the (i%gcd(n,x))-th cycle, so we can say that the problem can be transformed into counting the number of permutations with repetition in an array of size gcd(n,x).

Let us denote cnt[v] as the number of values equal to v in array a, when we are processing the function Fx() and we reduce the problem to an array of size gcd(n,x) we should also decrease cnt[v] to cnt[v]n/gcd(n,x) since each component is made up of ngcd(n,x) values, also we must observe that for solving a problem for an array of size x, then nx should be a divisor of gcd(cnt[1],cnt[2],…,cnt[n]).

Let us denote cntx[v]=cnt[v]n/gcd(n,x)So to count the number of permutations with repetition for Fx() that can be formed with the frequency array cntx we can use the formula n!x1!⋅x2!⋅…⋅xn!Let us denote Gall=gcd(cnt[1],cnt[2],…,cnt[n])Let us denote fdiv(val) as the number of divisors of val.

Let us denote totsz as the number of permutations with repetition for an array of size sz, from what has been said before we have that nsz must be divisible by Gall so we only need to calculate the permutations with repetition for fdiv(Gall) arrays.

Now suppose that the number of different values of array a is k then Gall must be at most nk because the gcd of several numbers is always less than or equal to the smallest of them.

Now to calculate the permutations with repetition for a cntx we do it in O(k), for that we need to precalculate some factorials and modular inverses before, and since we need to calculate them fdiv(Gall) times, then we have that in total the complexity would be O(fdiv(Gall)⋅k) but since Gall is at most nk and fdiv(nk) is at most nk, substituting it would be O(nk⋅k) equal to O(n)So to find the sum of the number of fixed points we need the sum of totgcd(n,x) for 1≤x≤n and ngcd(n,x) divides to Gall, at the end of all we divide the sum of the number of fixed points by n and we would obtain the number of different permutations of a.

To find the gcd(n,x) for 1≤x≤n we do it with the Euclid's algorithm in complexity O(n⋅log) so in total the complexity is O(n⋅log)Second part (find the expected value of components of different permutations of a):

Here we will use the Linear Expectation property and we will focus on calculating the contribution of each component separately, the first thing is to realize that the number of components is equal to the number of different adjacent values, so we only need to focus on two adjacent values, except if it is a single component, this would be a special case. If we have k different values we can use each different pair of them that in total would be k⋅(k−1) pairs, we can realize that when we put a pair its contribution would be equal to the number of ways to permute the remaining values, which if we are in an array of size nx and we use the values val1 and val2 it would be equal to:

totn/x⋅1(n/x)⋅(n/x−1)⋅cntx[val1]⋅cntx[val2]because we removing a value val1 and another value val2 from the set, so if we have the formula:

n!x1!⋅x2!⋅…⋅xn!and val1 and val2 are the first two elements then it would be:

(n−2)!(x1−1)!⋅(x2−1)!⋅…⋅xn!which would be equivalent to:

n!x1!⋅x2!⋅…⋅xn!⋅1n⋅(n−1)⋅x1⋅x2Now to calculate the contribution of the k⋅(k−1) pairs we can realize that taking common factor totn/x⋅1(n/x)⋅(n/x−1) in the previous expression it only remains to find the sum of cntx[i]⋅cntx[j] for all i≠j, this can be found in O(k) easily by keeping the prefix sum and doing some multiplication. Then at the end we multiply by n since there are n possible pairs of adjacent elements in the general array.

Let us define sumsz as the contribution of components of the permutations with repetition for an array of size sz, then:

sumn/x=totn/x⋅1(n/x)⋅(n/x−1)⋅(sum of (cntx[i]⋅cntx[j]) for i≠j)⋅nNow for each possible permutation with repetition we have by the Burnside's lemma that in the end we divide it by n, so we should also divide by n the contribution of each component.

Let's define tot′x=totxn and sum′x=sumxnLet's define totall as the sum of tot′gcd(n,x) for 1≤x≤n and ngcd(n,x) divide to Gall.

Let's define sumall as the sum of sum′gcd(n,x) for 1≤x≤n and ngcd(n,x) divide to Gall.

The final answer would be:

res=sumalltotallThe final complexity then is O(n⋅log)Code1630F - Making It BipartiteAuthor: BrayanD

Hint 1Hint 2Hint 3SolutionFirst of all, let's analyze what happens when there are 3 vertices x, y and z such that ax|ay, ax|az and ay|az, if this happens then the graph cannot be bipartite because there would be a cycle of size 3, therefore there cannot be such a triple (x, y, z), this condition, besides to being necessary, is sufficient since we can separate the graph into two sets, set A: vertices that have edges towards multiples, set B: vertices that have edges towards divisors, keep in mind that a vertex cannot exist in two sets at the same time if the condition is fulfilled, now note that there are no edges between elements of the same set because if this happens it would mean that they belong to different sets and it would be a contradiction, then the problem is to find the minimum number of vertices to remove such that in the remaining vertices there is no such triple of numbers (x, y, z). Now instead of minimizing the number of vertices to remove, let's try to maximize the number of vertices that will remain in the graph.

Let us define the directed graph G as the graph formed by n vertices, and directed edges (u, v) such that av|au, now the problem is reduced to finding the maximum number of vertices such that in the graph formed among them, no vertex has ingoing edges and outgoing edges at the same time, formally for each vertex x the following property must be kept indegreex=0 or outdegreex=0, in this way we guarantee that there is no triple (x, y, z) such that ax|ay, ax|az and ay|az.

Now let's define the graph G′ as a copy of the graph G. Formally for each directed edge (u, v) in the graph G there is an directed edge (u′, v′) in the graph G′. On the other hand, let's define the graph H=G+G′ and we will also add new directed edges (u′, u), this graph H is a DAG, it is easy to see that the edges always go from a vertex u to a vertex v only if au>av, except for the edges (u′, u), which in this case au′=au, these edges are the ones that connect G′ to G, but since they always go in one direction pointing towards G, the property of DAG is still fulfilled.

Now the only thing we have to do is find the largest antichain in the graph H, this can be done using the Dilworth's Theorem, modeling the problem as a bipartite matching, we can use some flow algorithm such as Dinic's Algorithm, or Hopcroft Karp's Algorithm, which is specific to find the maximum bipartite matching.

Proof:First of all we realize that the graph G is a special graph since if there is an indirect path from a vertex u to a vertex v then there is always a direct edge between them, this is true because if we have 3 vertices x, y and z such that ax|ay and ay|az then always ax|az. With this we can say that two elements are not reachable with each other if and only if there are no edges between them. Now let's say that all the vertices in the graph G are white and all the vertices in the graph G′ are black, let us denote f(x) a function such that f(u′)=u, where the vertex u from the graph G is the projection of the vertex u′ from the graph G′. Now let's divide the proof into two parts.

First part:Lemma 1: Every antichain of H can be transformed into a valid set of vertices such that they form a bipartite graph.

Proof of Lemma 1: Let's divide the antichain of H into two sets, white vertices and black vertices, Let us define the set of white vertices as W and the set of all black vertices as B, now we will create a set S = {f(x) | x∈B}. It is easy to see that no element in S belongs to W since if this happens it would mean that there is an element x such that x belongs to B and f(x) belongs to W and by the concept of antichain that would not be possible. It is also easy to see that the elements of the set S are an antichain since the set S is a projection of vertices from the set B of the graph G′ on G. Now we have that there are no edges between the vertices of the set S and there are no edges between the vertices of the set W, with this it is proved that the graph is bipartite.

Second part:Lemma 2: Every valid set of vertices such that they form a bipartite graph can be transformed into an antichain of H.

Proof of Lemma 2: Let us denote f−1(x) a function such that f−1(u)=u′, where vertex u from graph G is the projection of vertex u′ from graph G′. Let us denote the set A as all vertices that have indegree greater than 0 and B to all vertices that have outdegree greater than 0, now we will create a set C = {f−1(x) | x∈A}, It is easy to see that set B is an antichain since if one vertex has an edge to another vertex then some of them would have indegree greater than 0 and would contradict the definition of set B, we can also see that the elements in set A are an antichain since all the elements have outdegree=0 so no vertex point towards any other vertex, with this we can define that all the elements in C are an antichain since they are a projection of vertices of the set A from the graph G on G′, Now we want to proof that the union of set B and C is an antichain, this is very simple to see since the vertices of set B belong to G and the vertices of C belong to G′, therefore there is no edge from any vertex in B to a vertex in C since there are no edges from G to G′. Now it only remains to proof that from set C no vertex of set B can be reached, this is proved taking into account that the vertices reachable from the set C in the graph G are the same that the vertices reachable from the set A in the graph G, and as no vertex of A has edges towards B, this cannot happen. Therefore the union of the sets B and C is an antichain of H.

Then we can say that the two problems are equivalent and it is shown that finding the maximum antichain we obtain the largest bipartite graph.

The graph G contains n vertices and around n⋅log(n) edges (since the numbers ax are different and the sum of the divisors from 1 to n is around n⋅log(n)). The graph G′ is a duplicate of G then we would have n⋅log(n)⋅2+n edges and 2⋅n vertices, if we use the Hopcroft Karp algorithm we would obtain a time complexity of O(n⋅log(n)⋅sqrt(n)) and a space complexity of O(n⋅log(n)).

Code

Editorial of Codeforces Round #767

By magnus.hegdahl, 13 months ago, In EnglishThanks for participating in the round! We hope you enjoyed it.

In addition to the usual text-editorial below, namanbansal013 will explain Div. 2 solutions on his stream, and ak2006 has made video explanations for Div. 2 B, C, D, and E.

1629A - Download More RAMUsing some software is never bad. It always ends up increasing your RAM if you can use it. And for any possible order to use a set of software in, they all result in the same amount RAM in the end. So we can greedily go through the list, using software if you have enough RAM for it. After going through the list, your RAM may have increased, so maybe some of the software you couldn't use at the start is now usable. Therefore we have to go through the list again (now with the used software removed) until the RAM doesn't increase anymore. This results in time complexity O(n2), which is fine for these constraints.

It turns out we don't actually need to go through the list of software more than once if we sort it by a. This results in O(nlogn) time complexity.

1629B - GCD ArraysFor the GCD of the whole array to be greater than 1, each of the elements must have a common prime factor, so we need to find the prime factor that's the most common in the array and merge the elements that have this prime factor with those who don't, the answer being the size of the array - number of occurrences of the most frequent prime factor. And, because the numbers are consecutive, the most common prime factor is always 2. So, the minimum number of moves we need to do is the count of odd numbers in the given range, which is (r−l+1)−(r/2−(l−1)/2). Now. the answer is "YES" when the minimum number of moves we need to do is less than or equal to k and "NO" otherwise.

The extra cases we should take care of are the ones where l=r, in which the answer is always "YES", or "NO' only when l=r=1.

1628A - Meximum ArrayThe splitting points can be picked greedily. Firstly, find the MEX of all suffixes, this can be easily done in O(n⋅log(n)) or O(n). Instead of removing elements, we consider that we need to split the array into some number of subarrays.

Let p be the index we are currently at and MEX(l,r) — the MEX of the set formed from the numbers [al,al+1,...,ar].

Start the process by looking at the first element, so p=1 initially. Then do the following process as long as p≤n: find the first position j(p≤j≤n) such that MEX(p,j) = MEX(p,n), add this MEX to the array b and do the same process starting from position j+1, so p=j+1.

This process always produces the optimal answer because if for each element in b we choose to remove the minimum amount of elements from a to obtain the maximum element bi, so we have more elements in the future to do the same optimal choices.

Complexity: O(n⋅log(n)) or O(n) depending on implementation.

1628B - Peculiar Movie PreferencesBecause of the low constraints on the lengths of the strings, we can prove that it's enough to pair at most 2 strings to form a palindrome.

<proof only checking pairs is enough>

Let's assume there is a awesome subsequence of the form xyz where x and z are single strings from s, and y is anything. If x and z are the same length, they clearly have to be reverses of each other for xyz to be a palindrome, so y is not needed to make it a palindrome. If they are not the same length, one of them is of length 3 and the other is of length 2. Assume x is the string of length 3 and y is the string of length 2. The first two characters of x must be the reverse of z. If x and z are concatenated, the third character of x is in the middle, so it doesn't matter. So in this case too, y is not needed. This proves that if any awesome subsequence exists, there also exists an awesome subsequence of 1 or 2 strings.

<proof ends>

So, we first check if there exists a palindrome already, if there is, we found a solution! If not, checking for each pair would take too long, but we can do it much more efficiently. We can assume that all strings are of length 2 or 3 since if there was a string of length 1 it would be a palindrome and we would have found the solution earlier.

For each string of length 2 it's enough to check if before it, we have seen a string of the following 2 forms: its reverse or its reverse with a character appended to it (so a string of length 3), since the last character of a string of length 3 would be the middle character of the palindrome obtained after concatenation.

For each string of length 3 it's enough to check if before it, we have seen a string of the following 2 forms: its reverse or the reverse of the string without considering the first character (so a string of length 2), since the first character of a string of length 3 would be the middle character of the palindrome obtained after concatenation.

All this can be checked using a frequency matrix, map, set or other data structures.

1628C - Grid XorLet's denote count(i,j) the amount of times the cell (i,j) contributed in queries. We notice that count(i,j) must be odd for all cells (i,j).

There are multiple possible solutions for this problem. In the editorial we will describe two of them.

<first solution>

The following construction satisfies the condition: Iterate Through all rows from row 2 to n. For each row, traverse all its cells and query cell (i,j) if the cell above it if cell (i−1,j) was contributed (count(i−1,j) =0 (mod 2)) an even amount of times and XOR curent_answer with aij (curent_answer initially being 0)

Everule gave a proof of correctness of this approach.

<first solution>

<second solution>

Let's try making some pattern that takes all cells exactly once:

Something like this would work if the board was a triangle instead of a square. But it turns out we can actually completely cover the square by using 4 copies of such a triangle rotated:



<second solution>

1628D1 - Game on Sum (Easy Version)What is the answer for n=2, m=1?

Let's call the number Alice picks on the first turn x.

If x is small, Bob can add it, and then Alice will have to pick 0 on the last turn since Bob will definitely subtract it from the score if it isn't 0, meaning the score ends up being x.

If Alice picks a big number, Bob can subtract it. Then Alice will pick the biggest number she can on the last turn, ending up with a score of k−x.

Since Bob tries to minimize the score of the game, Alice should pick an x such that it maximizes the value of min(x,k−x). x and k−x are both linear (straight line) functions on x. The x value that maximizes the minimum of two lines is their intersection. The intersection of the lines x and k−x is at x=k/2. So Alice should pick x=k/2 in the optimal game where n=2, m=1.

To generalize the solution to arbitrary n and m, we can use DP. Let DP[i][j] what the score would be if n=i, m=j.

Our base cases will be

DP[i][0]=0 since if Bob doesn't have to add anything, Alice has to always pick 0.DP[i][i]=i⋅k since if Bob always has to add, Alice can just pick k every time.When Bob adds to the score, the rest of the game will be the same as a game with 1 fewer turns and 1 fewer forced adds, except the game score is offset by Alice's number. When Bob subtracts from the score, the rest of the game will be the same as a game with 1 fewer turns except the game score is offset by negative Alice's number.

Bob will take the minimum of these, so the DP transition will be

DP[i][j]=min(DP[i−1][j−1]+x,DP[i−1][j]−x) for x that maximizes this value.

This is the same problem as the n=2 case resulting in the intersection between lines. The score at this intersection simplifies nicely to DP[i][j]=(DP[i−1][j−1]+DP[i−1][j])/2This O(n⋅m) solution is fast enough to pass the easy version of this problem.

1628D2 - Game on Sum (Hard Version)We have base cases

DP[i][0]=0DP[i][i]=k⋅iAnd transition DP[i][j]=(DP[i−1][j−1]+DP[i−1][j])/2Check the explanation for the easy version to see why.

This DP can be optimized by looking at contributions from the base cases.

If we draw the DP states on a grid and ignore the division by 2 in the transition, we can see that the number of times states DP[i][i] contributes to state DP[n][m] is the number of paths from (i,j) to (n,m) in the grid such that at each step, both i and j increase, or only j increases, except we have to exclude paths that go through other base cases. The number of such paths is (n−i−1m−j ). Since the number of steps in all of these paths is the same, we can account for the division by 2 in each transition by dividing by 2n−i in the end.

To find the value of DP[n][m] we sum the contribution form every base case DP[i][i] for 1≤i≤n.

1628E - Groceries in Meteor TownConsider the edge with the greatest weight. Any path going through that edge will have weight equal to the weight of that edge. If we delete that edge from the tree, a path going through that edge in the original tree has one endpoint in each component that results from the removal of the edge.

Consider some query x with some set of open stores. If the component not including x has an open store, then the answer is the deleted edge. If it does not have an open store, then we recursively solve the problem for the component of x.

Observe that the structure of this is the same as for finding LCA of a set of nodes in a tree. When asking for the LCA of some set, we can pick an in-order traversal, ignore all nodes except the leftmost and rightmost ones, and still get the same LCA.

The solution outline then looks like this:

Create the binary tree that arises from making a node representing the edge with the greatest weight, and then doing the same for the two components resulting from deleting the greatest weight making them left and right subtrees of the above tree.Order the nodes by in-order traversal in this tree.Use a segment tree or another data structure to maintain what is the leftmost and rightmost open store in the in-order traversal.Find the LCA of the leftmost and rightmost open store in the created tree.1628F - Spaceship Crisis ManagementThe exit position at a specific segment is always the same, only the exit direction changes depending on which angle the spaceship comes in at. Therefore, if we know the set of directions that are good to hit a segment at, we know if a path that hits the segment is good or not. Note that it's only useful to consider directions that are either the direction from the closest point on some segment to the target, or from some starting position to the target. Let's call these directions relevant directions.

Slow solution: We can use DP to determine the set of useful directions for each segment: Sort the segments by distance to the target, and for each segment try shooting a ray in every relevant direction that is within 45 degrees of the direction of the segment itself, and see if it either hits the target or a segment where that direction is good. The comparison with 45 degrees can be done exactly using e.g. properties of the dot product. Then for each starting position query, the same ray shooting can be done. This is O((n+q)2⋅n) because there are O(n+q) relevant directions, O(n+q) positions from which to shoot rays, and O(n) segments to check intersection with. This is too slow.

We found two different ways to optimize this:

1. Since we need to know what a ray hits for many different directions from the same origin, we could do some preprocessing at each origin. A Li-Chao tree traditionally finds the minimum y-value at a certain x-coordinate among a set of line segments. But it doesn't have to contain line segments. It can contain any set of functions such that any pair of them intersect at most once. This includes distance to 2D line segments from a fixed origin as a function of angle. Using this, we can for each origin do O(n⋅log(n+q)) time precomputation to get O(log(n+q)) time per query to a single direction, resulting in the time complexity O((n+q)2log(n+q))2. Solution by Maksim1744: If we fix the floating direction, the movement between space junk forms edges in a functional graph. We can use a sweep to build the graph and then for each starting position and determine if it reaches the target in the graph. Doing this for all relevant directions also results in a time a complexity of O((n+q)2log(n+q))

Codeforces Round #766 (Div. 2) Editorial

By saarang, history, 13 months ago, In EnglishThank you for participating in our contest! We hope you enjoyed it.

1627A - Not Shading

Hint 1Hint 2Solution1627A - Not ShadingThere are several cases to consider:

If all the cell are white, then it is impossible to perform any operations, so you cannot make any cell black. The answer is −1.If the cell in row r and column c is already black, then we don't need to perform any operations. The answer is 0.If any of the cells in row r are already black (that is, the cell we need to turn black shares a row with a black cell), then we can take this black cell and make row r. The same is true if any of the cells in column c are already black. The answer is 1.Otherwise, we claim the answer is 2. Take any black cell and make its row black. This means that every column contains a black cell, so now we can take column c are turn it black. Thus the answer is 2.This can be easily implemented in O(nm) time per test case.Implementation (C++)Implementation (Java)Implementation (Python)Video Editorial1627B - Not Sitting

HintHint SolutionSolution1627B - Not SittingLet's denote Rahul's seat as (a,b) and Tina's seat as (c,d). Notice that the in the distance between their seats, |a−c|+|b−d|, |a−c| and |b−d| are independent of each other, i.e. both the x-coordinate and y-coordinate of Tina's seat are independent. From the answer to the hint above, we can see that the optimal seat for Tina in a 1-dimensional classroom is one of the edge seats, and combining this with the previous observation means that the optimal seat for Tina is always one of the corner seats.

Since Rahul chooses seats optimally, he will know that Tina will choose one of the corner seats, so he will choose a seat such that the maximum distance from it to one of the corner seats is minimised. As Tina also chooses which seats to paint optimally, the best strategy for her is to paint the k seats with minimum maximum distance to one of the corner seats pink.

We can implement this by calculating for each seat the maximum distance to one of the corner seats from it, and storing these values in an array. After sorting this array in non-decreasing order, we can simply print the first n⋅m−1 values of the array, as the i-th value of the array (0-indexed) is the optimal answer for k=i.

This can be implemented in O(nmlog(nm)) time per test case.

Implementation (C++)Implementation (Java)Implementation (Python)Video Editorial1627C - Not Assigning

HintSolution1627C - Not AssigningLet us first see when a valid assignment does not exist.

Claim. If any vertex has 3 or more edges adjacent to it, no valid assignment exists.

Proof. Consider a graph where a vertex has edges to three other vertices with weights x, y and z respectively. For a valid assignment, x, y and z need to be primes themselves. Also, x+y, y+z and x+z need to be primes too.

Since x,y,z≥2 (as 2 is the smallest prime), thus x+y,x+z,y+z≥4, so they must be odd primes. This implies:

x and y have opposite parity.y and z have opposite parity.x and z have opposite parity.As all the three conditions cannot hold together, hence we have a contradiction.

Proven.

So, we have a tree where every vertex has either one or two edges adjacent to it. Such a tree will have exactly two leaf nodes for n≥2 and have the following structure, where V1 and Vn are the leaf nodes.

V1⟷V2⟷V3⋯⟷Vn−1⟷VnThus, starting a DFS from any leaf node, we can assign weights 2 and 3 (or 2 and the first number of any twin prime pair) alternatingly to form a prime tree, as 2, 3 and 2+3=5 are all primes.

Expected time complexity: O(n)Implementation (C++)Implementation (Java)Implementation (Python)Video Editorial1627D - Not Adding

HintSolution1627D - Not AddingNote that the gcd of two numbers cannot exceed their maximum. Let the maximum element of the array be A. So for every number from 1 to A, we try to check whether that element can be included in the array after performing some operations or not.

How to check for a particular number x?

For x to be in the final array, either:

It already exists in the initial array.Or, the gcd of all multiples of x present in the initial array equals x.Proof

For x to be added after some operations, there must be some subset of the array which has a gcd equal to x. We can perform the operations by taking the current gcd and one element from the subset at a time and at the end we will obtain x.

Note that such a subset can only contain multiples of x. So it is enough to check that the gcd of all multiples is equal to x.

Thus, the overall solution takes O(n+AlogA).

Implementation (C++)Implementation (Java)Implementation (Python)Video Editorial1627E - Not Escaping

HintHint 2Hint 3Solution1627E - Not EscapingThe building plan of the input consists of n⋅m rooms, which in the worst case is 1010 however, most of these rooms are unimportant to us. We can instead use a much reduced version of the building consisting of at most 2k+2 rooms, both endpoints of each ladder, as well as our starting and target rooms.

As every ladder connects a lower floor to a higher floor and is one-directional, we can process the rooms floor by floor, from floor 1 to floor n. On each floor, let's sort all the rooms in non-decreasing order. Now, we can use dynamic programming, as well as the compression previously mentioned to calculate the minimum distance to get to all important rooms. First, we calculate the minimum cost to get to each room using a room on the same floor as an intermediate. We can do this by iterating over the rooms on a floor twice, once from left to right, and then once from right to left. Then, for each room on the floor, if it has a ladder going up from it, we can update the dp value of the room where the ladder ends.

Our answer is the dp value of the target room.

This can be implemented in O(klog(k)) time per test case.

Implementation (C++)Implementation (Java)Implementation (Python)1627F - Not Splitting

Hint 1Hint 2Hint 3Solution1627F - Not SplittingClaim. Any cut that splits the square into two congruent parts is rotationally symmetric about the center by 180∘.

Proof. It is a special case when the cut is a vertical or horizontal line. Assume otherwise. Then:

One piece has a row containing more than k2, but less than k squares.One piece has a column containing more than k2, but less than k squares.Both exactly pieces contain two of the corners of the grid.Now consider the isometry of the plane bringing one piece to the other. Then the corners of the grid of one piece must map to the corners of the grid of the other piece, since there has to be a straight edge connecting them with length k, which only exists between two corners. There are precisely two such isometries that fit within the bounds of the square: a reflection and a 180∘ rotation, pictured below, respectively.

However if one piece has a row containing more than k2 but less than k squares, then in the first case the number of squares in that row is greater than k. The same holds in the case of a vertical reflection. Hence the cut must be rotationally symmetric.

Now we can turn the problem into a graph problem. Consider the graph whose vertices are vertices of the grid and whose edges are edges of the grid. We need to minimize the number of pairs of squares that we "split up" in our cut. Note that each pair of squares shares an edge. Thus, we want to minimize the number of these edges we pass through. Let's initially weight all edges with 0, and increase the weight by 1 for each edge given.

Since each cut is rotationally symmetric about the center, we can just consider finding a minimal-weight path from the boundary to the center, and then rotating this path 180∘ to find a valid cut. However, there are three details we need to iron out:

The cut may pass through other weighted edges when rotated.We need to find an efficient way to find the shortest path from each boundary point to the center.The cut may be self-intersecting.The first point can be accounted for by weighting each edge and its rotated counterpart, so both the path and its rotation will be counted when finding the shortest path.The second point can be accounted for by noticing that the boundary of the square has all edges of weight 0, so we can just run single source shortest paths from any single point on the boundary.

For the third point, consider some path that intersects itself when rotated. Suppose we build the path edge-by-edge, along with its mirror copy. At some point we will hit the mirror copy. But that means that there is a way with strictly fewer edges to reach the same point: just take the path from this intersection to the start of the mirror copy. See the image below.

Instead of taking the long path (in blue/orange), we can take the shorter path (in green/purple).So now all our details are successfully ironed out. We can just run Dijkstra's algorithm from any vertex and find the length of the shortest path, solving the problem in O(n+k2logk).

Implementation (C++)Implementation (Java)Implementation (Python)Author Notes

Editorial of Codeforces Round #765 (Div. 2)

By gepardo, history, 13 months ago, translation, In English1625A - Ancient CivilizationNote that the problem can be solved independently for each bit, as the bits don't influence each other. Set the ith bit to zero if the numbers in the array contain more zeros than ones in the ith bit. Otherwise, set it to one.

1625B - Elementary ParticlesNote the following fact. For each optimal pair of harmonious strings, it's true that the right string ends on the last character.

Proof: suppose it's wrong. Then, we can expand the strings to the right by one character, and they will remain harmonious.

Now, prove the following statement, that will help us to solve this problem. The statement is as follows: the answer is n−min(v−u) where minimum is over all u and v such that u<v and au=av.

Proof: consider two elements u and v such that u<v and au=av. Suppose that they are on the same position in a pair of harmonious substrings. What maximal length these substring may have?

From what was proved above, we know that we can expand the strings to the right. Take the first string starting in u and the second string starting with v. Then, we get the strings of length n−v+1 after expanding them.

Still, it's not enough. So, we will also expand the strings to the left. So, the total length of the strings will become n−v+u, which is equal to n−(v−u). The smaller v−u, the larger the length.

To solve the problem, we need to find a pair of nearest equal elements quickly. We can do the following: store all the positions of each element (i. e. all the positions with ai=1, with ai=2 etc.), and then we iterate over ai, go through the pairs of neighboring positions and calculate the minimum.

1625C - Road OptimizationFirst you need to understand that this problem must be solved with dynamic programming. Let dpi,j is the minimum time to drive between the two cities, if we consider first i signs and have already removed j signs. We also assume that the ith sign is taken.

Then, the initial state is: dp0,0=0, dpi,0=dpi−1,0+bi−1⋅(ai−ai−1). So, we don't need to drive to the first sign (as it takes 0 seconds), and if we don't remove any signs, it's easy to calculate the time.

Initially, fill dpi,j=∞ for all i=1…n,j=1…k.

Then, the answer is min(dpn,j) over all j=0…k.

Consider which transitions can we make. Calculate our DP from bottom to top, so we go from smaller states to larger ones. Consider all the i=0…n−1 and all the j=0…k in the loop order, i. e:

for (int i = 0; i < n; i++)

for (int j = 0; j <= k; j++)If we see dpi,j=∞, then there's no answer and we'll just skip this state. For example, it may mean that i<j.

Now, iterate over the positions of the next sign we'll put. Call this position pos. The transitions are as follows: dppos,j+pos−i−1=min(dppos,j+pos−i−1,dpi,j+bi∗(apos−ai)).

Why such formula? After removing all the signs between [i+1,pos−1] we will stay on the sign pos, remove pos−i−1 signs, and the time to go from i to pos will depend on the sign i and the distance between i and pos.

So, we get the solution in O(n3).

There also exists a solution in O(n2⋅logn), which uses Convex Hull Trick. We don't describe it here, as it's not required to solve the problem.

1625D - Binary SpidersTo solve the problem, we need the following well-known fact. Suppose we have a set of numbers and we need to find minimal possible xor over all the pairs. It is true that, if we sort the numbers in non-descending order, the answer will be equal to minimal xor over neighboring numbers.

We need the minimal xor to be not less than k in this problem. For a quadratic solution, we can just sort the numbers and consider dpi — largest good subset such that the greatest element in it is equal to ai. Then, dpi=max(dpj+1), where aj⊕ai≥k. To make this solution faster, we can use a trie over the bits of numbers. In each vertex of the trie, we store the size of the largest good subset whose greatest element lies in this subtree. When we want to get the answer for i, we descend in the tree and get the answer for all the subtrees where we don't go, if the corresponding bit in k is equal to zero.

Time complexity is O(n⋅logmaxai).

1625E1 - Cats on the Upgrade (easy version)First, we need to make the input string an RBS. Consider one of the possible ways to do it.

First, we keep the stack of all the opening brackets. We remove the bracket from the stack if we encounter the corresponding closing bracket. If there is an unpaired closing bracket or an opening bracket which is not removed, they must be replaced with a dot. So, the input string becomes an RBS. It's not hard to see that there are no queries that pass through dots we put in this step.

Now, build a tree from the brackets. We will do it in the following way. Initially, there is one vertex. Then, if we encounter an opening bracket, we go one level below and create a new vertex, and if we encounter a closing bracket, then we go to the parent.

It's now clear that each vertex corresponds to an RBS. The root of the tree corresponds to the entire string, and leaf nodes correspond to empty RBSes.

Now, note that we can obtain all the RBSes if we take all the subsegments from the children of vertices. Each subsegment from the children looks like (RBS)(RBS)...(RBS), i. e. it's a concatenation of RBSes that correspond to children, where each one is put into brackets.

Now, we can make a simple DP. Indeed, the amount of all RBSes in a vertex is the sum of RBSes of its children plus k⋅(k+1)2, where k is the number of children. The amount of RBSes on the segment is calculated in a similar way. When we calculate such DP and can carefully find a vertex in the tree, we can answer the queries on the segment.

The time complexity is O(qlogn) or possibly O(n+q) if we manage to find the vertices corresponding to indices fast.

1625E2 - Cats on the Upgrade (hard version)Now, we need to see how to handle removal queries in this task. Build an SQRT decomposition in the following way. We will rebuild the entire tree after each n−−√ queries and recalculate the DP. Between the rebuilds, we hold a list of removed leaves.

Now look how we can recalculate the answer if some leaves are removed.

First suppose that the leaf is not a direct child of the vertex we are interested in. Then the removal of this leaf decreases the answer by q, where q is the number of children of this leaf's parent. Why so? The parent of this leaf had the answer as sum of answers in its children plus q⋅(q+1)2. The answer in the leaf is equal to zero, so the new answer became sum plus q⋅(q+1)2, thus decreased by q.

When we build the DP, the modification of answer in a vertex is passed to its parents unchanged. So, the answer decreases by q on the entire path from this leaf to the root.

We can easily check if we are affected by this removal. It must be applied only if the removed leaf lies strictly inside our query of the second type.

We also need to handle the case where our leaf is a direct child of the vertex we consider, as the removal described above doesn't fully apply to this case. This is an exercise left to the reader.

So, we get the solution in O((n+q)⋅n−−√).

There is also a solution in O((n+q)logn). We consider it very shortly.

Let's hold just k⋅(k+1)2 in each vertex, not the sum over children plus k⋅(k+1)2, as we did before. Then the answer for each vertex is the sum in the subtree.

We can keep a Fenwick tree, as we can calculate sums in the subtree with it, using Eulerian tour over the tree. It's not hard to see that each update must be applied only once to the direct parent.

Codeforces Round #764 (Div. 3) Editorial

By Vladosiya, history, 14 months ago, translation, In English1624A - Plus One on the Subset

Idea: MikeMirzayanov

Tutorial1624A - Plus One on the SubsetLet's sort the numbers in ascending order. It becomes immediately clear that it is not profitable for us to increase the numbers that are equal to the last number (the maximum of the array). It turns out that every time you need to take such a subset of the array, in which all the numbers, except the maximums. And once for each operation, the numbers in the subset are increased by one, then how many times can the operation be performed on the array? Accordingly max(a)−min(a).

Solution1624B - Make AP

Idea: DmitriyOwlet

Tutorial1624B - Make APLet's iterate over the number that we want to multiply by m.

How can we check that we can multiply the current number so that an AP is formed?

Note that those 2 numbers that we do not touch should form an AP themselves. For instance, let at the current operation we want somehow multiply the number c. Then a=x1, and b=x2=x1+d.

Note that b−a=x1+d−x1=d. Thus, we know what d is. Also we know that c=x1+2⋅d=a+2⋅d. Let's check if a+2⋅d is divisible by c. If yes, then we have found the answer, if not, then move on to the next number.

We do the same for a and b.

Be careful with non positive numbers, integer divisions and other edge cases.

Solution1624C - Division by Two and Permutation

Idea: MikeMirzayanov

Tutorial1624C - Division by Two and PermutationLet's sort the array a in descending order of the values of its elements. Then let's create a logical array used, where used[i] will have the value true if we already got element i of the permutation we are looking for, and the value false otherwise.

We loop through the elements of the array a and assign x=ai. We'll divide x by 2 as long as it exceeds n or as long as used[x] is true.

If it turns out that x=0, then all the numbers that could be obtained from ai have already been obtained before. Since each element of the array a must produce a new value from 1 to n, the answer cannot be constructed — output NO.Otherwise, assign used[x] a value of true — this means that the number x, which is an element of the permutation, we will get exactly from the original number ai.After processing all elements of the array a we can output YES.

Solution1624D - Palindromes Coloring

Idea: DmitriyOwlet

Tutorial1624D - Palindromes ColoringWe will solve the problem greedily. First, we will try to add pairs of identical characters to palindromes. As long as there are at least k pairs, let's add them. After that, it is no longer possible to add a couple of characters, but you can try to add one character in the middle. This can be done if there are at least k characters left. There is no need to paint other characters.

Solution1624E - Masha-forgetful

Idea: Aris

Tutorial1624E - Masha-forgetfulThe key idea is that any string of length greater than 3 can be obtained by concatenating strings of length 2 or 3. Then when reading the data, remember all occurring substring of length 2 and 3. There are at most 104.

Now we will count the dynamics on the prefix: dp[i]=true if we can get the prefix of length i of phone s by segments of length 2 and 3 of the known phones Masha. Then for the transition we need to look through the lengths 2 and 3, then take a substring of the corresponding length and find out whether such a string occurred in the phones known to Masha.

Then it will take O(m) or O(mlogm) time to recalculate the dynamics, depending on the implementation. But it will still take more time to read the data, so the final asymptotic will be O(nm) or O(nmlogm).

Solution1624F - Interacdive Problem

Idea: Vladosiya

Tutorial1624F - Interacdive ProblemAfter each query we know the ⌊xn⌋ value, then we need to find xmodn to find the current x value. To find it, we will use a binary search.

Suppose xmodn is in the [l,r) half-interval, in order to understand which half it is in, we will make a query, select the middle m of the half-interval and make a + n−m query. After that, ⌊xn⌋ will either change, which means that xmodn was in the [m,r) half-interval, or not, then it was in the [l,m) half-interval. Now you just need to properly shift the half-interval to accommodate the query change.

Solution1624G - MinOr Tree

Idea: Vladosiya

Tutorial1624G - MinOr TreeWe need to minimize the result of the bitwise operation, so for convenience, we represent the answer as a mask. Firstly, let's assume that this mask is composed entirely of ones.

Let's go from the most significant bit to the least significant one and try to reduce the answer. To understand whether it is possible to remove the j-th bit, remove it and check if the graph, in which all the weights are submasks of the current answer, is connected, for this, you can use depth-first search or a disjoint sets union. If the graph is connected, then the bit can obviously be thrown out, and if not it cannot and must be returned.

Solution

Codeforces Round #763 (Div. 2) Editorial

By darkkcyan, 14 months ago, In EnglishIn my opinion, all of the problems have a very simple solution and actually require no special data structure at all. To demonstrate the point, I will also use EvErYoNe'S fAvOrItE lAnGuAgE: Pascal.

I will also include some notes, which are not related to the solution at all, but I find them interesting, so I will also include them in.

A. Robot CleanerObviously, the problem is solvable using simulation. But it is solvable in O(1) time as well, and I will discuss it.

Tutorial1623A - Robot CleanerLet's consider the 1-D problem of this problem: there are n cells, lying in a row. The robot is at the x-th cell, and the dirty cell is at the y-th cell. Each second, the robot cleans the cell at its position. The robot initially moves by 1 cell to the right each second. If there is no cell in the movement direction, its direction will be reflected. What is the minimum time for the robot to clean the dirty cell?

There are two cases needed to be considered:

If x≤y, then the answer is y−x. The robot just goes straight to the dirty cell.Otherwise, if x>y, then the robot needs to go to the right endpoint first, and then go back to the dirty cell. Going to the right endpoint takes n−x seconds, and going from that cell to the dirty cell takes n−y seconds. Therefore, the answer for this case is 2⋅n−x−y.Going back to our original problem, we can solve it by dividing it into two 1-D versions. This is done by projecting the position of the robot and the dirty cell onto the Ox and Oy axis as follows.

By doing so, we can see that we can clean the dirty cell, if and only if one of the projections of the robot can reach the dirty cell. Therefore, the answer is the minimum between the answers of the two sub-problems.

Problem notePascal solution: 140968868. C++ solution: 140968900

B. Game On RangesThere are a lot of solutions to this problem. The solution I described below might be the simplest in my opinion.

Tutorial1623B - Game on RangesIf the length of a range [l,r] is 1 (that is, l=r), then d=l=r. Otherwise, if Bob picks a number d, then Alice has to put the sets [l,d−1] and [d+1,r] (if existed) back to the set. Thus, there will be a moment that Alice picks the range [l,d−1] (if existed), and another moment to pick the range [d+1,r] (if existed) as well.

Using the above observation, for each range [l,r], we can iterate the number d from l to r, check if both range [l,d−1] (if d>l) and [d+1,r] (if d<r) existed in the Alice's picked ranges. Or in other words, check if these ranges are given in the input.

For checking, we can either use set data structures supported in most programming languages or simply use a 2-dimensional array for marking the picked ranges. The time complexity is, therefore, O(n2).

This problem can be solved in O(nlogn) as well, and even O(n) with some black magic like counting sort, but that is not required during the contest.Problem notePascal solution: 140968967. C++ solution: 140968942

C. Balanced Stone HeapsTutorial1623C - Balanced Stone HeapsThe answer can be binary searched. That is, we can find the biggest number x, such that we can make all heap having at least x stones. So our job here is to check if we can satisfy the said condition with a number x.

Let's consider a reversed problem: we go from 1 to n−2, pick a number d (0≤3⋅d≤hi), move d and 2⋅d stones from the i-th heap to the i+1 heap and i+2-th heap respectively. In this problem, we can greedily move the stones: since x is the minimum required stones, if at some moment, we have hi<x, then we can not satisfy the condition for x anymore. Otherwise, it is always the best to use as many stones as we can, that is, choose d=⌊hi−x3⌋, and move d and 2⋅d stones to the i+1 and i+2 heaps respectively. In the end, if all the heap are not less than x, we can conclude that we can make all heaps having not less than x stones with this process.

Going back to our original problem, it seems like we can solve it by doing the process in the reversed order, as discussed above. But there is a catch! The number of stones that can be moved must not exceed the number of the stones in the original heap! So, if we call hi — the original heap size, and h′i — the current modified heap size, then the number of stones that we should move is d=⌊min{hi,h′i−x}3⌋ at each step.

There is not much to note about this problem.

Pascal solution: 140968985 C++ solution: 140969004

D. Robot Cleaner RevisitTutorial1623D - Robot Cleaner RevisitIn order to see how my solution actually works, let's solve this problem, the math way! You can skip to the "In general, ..." part if you don't really care about these concrete examples.

First of all, let p¯¯¯ be the probability of not cleaning, that is, the probability that the robot will not be able to clean. So p¯¯¯=1−p100.

Let's revisit the first example again.

In this example, the robot has 2 states: when it was at position (1,1), and when it was at (2,2). Let x be the answer for this problem when the robot started at (1,1), and y be the answer for this problem when the robot started at (2,2).

Let's consider the first state. If the robot can clean, it spends 0 seconds to clean the dirty cell. Otherwise, it will spend 1+y seconds. Therefore, we have an equation: x=p¯¯¯(1+y).

Similarly, we also have the an equation: y=p¯¯¯(1+x), since these two states are symetrical. Subtituding y=p¯¯¯(1+x) into x=p¯¯¯(1+y), we have

x=p¯¯¯(1+p¯¯¯(1+x))By substituting p¯¯¯ in, we can find the value of x.

Let's consider the other example.

In this example, the robot has 4 states: when it is at (1,1), when it is at (2,2) but going to the right, when it is at (1,3), and when it is at (2,2) but going to the left. Let the answer for these states be x1,x2,x3, and x4. Similar to the previous example, we can write down the equations:

⎧⎩⎨⎪⎪⎪⎪⎪⎪x1=1+x2x2=p¯¯¯(1+x3)x3=p¯¯¯(1+x4)x4=p¯¯¯(1+x1)(because at (1,1) the robot cannot clean the dirty cell)Substituting these equations back to back, we can have the following equation:x1=1+p¯¯¯(1+p¯¯¯(1+p¯¯¯(1+x)))And again, if we substitute p¯¯¯ in, the answer can be found easily.

In general, the path that the robot takes will form a cycle, containing the initial position. If we call x the answer to the problem at the initial position, the equation we need to solve will have the following form:

x=a1(1+a2(1+a3(1+…ak(1+x)…)))where k is the number of states in the cycle, and ai is some coefficient. ai=p¯¯¯ if, at the i-th state in the cycle, we have an opportunity to clean the dirty cell, and 1 otherwise.

The equation can easily be solved by expanding the brackets from the innermost to the outermost, by going through the cycle in the reverse order. After the expansion, the equation will be a very simple linear equation with the form x=u+vx, and the solution will be x=u1−v.

To construct the equation, we can first find the cycle by either DFS or BFS, and go through the cycle in the reverse order for expansion. Or, we can do the reverse simulation, maintaining the coefficient u and v right away. And even better, we can just forget about the cycle and iterate exactly 4(n−1)(m−1) times (not 4nm though), since 4(n−1)(m−1) will always be the multiple of k — the cycle length. The time complexity of this solution is O(nm).

Using the O(1) solution in problem A, this problem is solvable in O(n+m) as well, but that is not required.Problem notePascal solution: 140969014 C++ solution: 140969025

E. Middle DuplicationTutorial1623E - Middle DuplicationFirstly, we need to determine if a label should be duplicated at all. For example, in the string "bac", the characters 'b' and 'c' should never be duplicated, since duplicating them always make the result worse ("bbac" and "bacc" are both lexicographically greater than "bac"). This is because, next to the character 'b' is 'a', and 'a' is smaller than 'b'. For the case of 'c', after it there is no more characters, thus we should not duplicate it as well. Let's call a node good if duplicating its label will make the result better (lexicographically smaller). To find good nodes, we can find the initial string representation of the tree using DFS. A node is good if the next different character in the string representation must exist and is smaller than the label of the node.

After finding the good nodes, let's find the first label that we should duplicate. This label must be from a good label and must lie as close to the start of the string as possible. We can find this label, also by DFS. We still do DFS in the in-order, and the first good node having depth not exceed k will be the first node to have the label duplicated. And by duplicating this node, we must duplicate the labels of its ancestors as well. Note that during the DFS process, if we don't duplicate a node, we should not go to the right sub-tree.

Let's call the cost of duplicating a node the number of its ancestors that is not duplicated before. The cost of the first duplicated node is its depth, which can be calculated while doing DFS. The cost of the other nodes can also be maintained while doing DFS as well: if a node is duplicated, the root going to the right sub-tree will have a cost of 1.

So overall we will have the following DFS algorithm on the node u:

If u=0, then we do nothing.If cost[u]>k , we do nothing.Assign cost[l[u]]←cost[u]+1 and do DFS on l[u].If l[u] has it label duplicated, we duplicate the label of u.Otherwise, if u is good, we duplicate the label of u as well, and decrease k by cost[u].If u is duplicated, then assign cost[r[u]]←1, do DFS on r[u].For implementation, we can pass the variable cost together with u to the DFS function, and don't need to declare a global array.

The overall time complexity of this solution is O(n).

Problem notePascal solution: 140969053 C++ solution: 140969037

Codeforces Round #762 (Div. 3) Editorial

By Gol_D, history, 14 months ago, In English1619A - Square String?

Idea: MikeMirzayanov

Tutorial1619A - Square String?If the length of the given string s is odd, then the answer is NO, since adding two strings cannot do that. Otherwise, let n be the length of the string. Let's go through the first half of the string, comparing whether its first and n2+1 characters are equal, its second and n2+2 characters are equal, and so on. If the characters in any pair are not equal, the answer is NO, otherwise — YES.

Solution1619B - Squares and Cubes

Idea: MikeMirzayanov

Tutorial1619B - Squares and CubesWe'll search for positive integers not larger than n, and add their squares or cubes to the set if they don't exceed n. If n=109, the maximum number Polycarp will like is 316222=999950884, so the running time will be within the time limit.

The answer to the problem is the length of the resulting set.

Solution1619C - Wrong Addition

Idea: MikeMirzayanov

Tutorial1619C - Wrong AdditionLet's compute the answer to the array b, where bk is the digit at the k position in the number we are looking for. Let i be the position of the last digit in number a, j be the position of the last digit in number s. Then denote x=ai, y=sj, and consider the cases:

if x≤y, then the sum of ai+bi was exactly si, then bi=y−x.if x>y, then the sum ai+bi was greater than 9 and we need to look at the next digit of the number s. If there isn't one, we can't get the answer — we'll output -1. Otherwise we recalculate y=10⋅sj−1+sj and reduce j by one.if now y≥10 and y≤18, then bi=y−x. Otherwise, we deduce -1, since we cannot get more than 9+9=18 when adding two digits, and the cases where ai+bi<10 have already been considered before.After considering the cases, reduce i and j by one and repeat the checks as long as i>0 or j>0. In the situation where j=0, but i>0, we will still have uncheked digits of number a, so we will also output -1. Otherwise, we output an array with the answer without leading zeros.Solution1619D - New Year's Problem

Idea: Vladosiya

Tutorial1619D - New Year's ProblemNote that if we cannot get joy x, then we cannot get x+1, and if we can get at least x, then we can get at least x−1. These facts allow us to use binary search to find the answer.

Now we need to understand how exactly we can recognize whether we can gain joy at least x or not. We can enter at most n−1 shops, so we always need to take two gifts from some store, which means there must be a store in which we can find two or more gifts with pleasure at least x. Also, each friend should receive a gift, which means that we should be able to buy each gift with pleasure at least x. It takes O (nm) to check that both of these conditions are met. The total solution works in O (nm ∗ log (nm)).

Solution1619E - MEX and Increments

Idea: DmitriyOwlet

Tutorial1619E - MEX and IncrementsFirst, let's sort the array. Then we will consider its elements in non-decreasing order. To make MEX equal to 0, you need to increase all zeros. To make MEX at least n, you first need to make MEX at least n−1, and then, if the number n−1 is missing in the array, you need to get it. If there are no extra values less than n−1, then this and all subsequent MEX values cannot be obtained. Otherwise, you can use the maximum of the extra array values. To do this, you can use a data structure such as a stack. If an element occurs more than once in the array, put its extra occurrences on the stack.

Solution1619F - Let's Play the Hat?

Idea: MikeMirzayanov

Tutorial1619F - Let's Play the Hat?For each game, we want to seat n people at m tables, nmodm of them will be big and B=⌈nm⌉ will sit at them, and m−nmodm will be small. Each round p=nmodm∗B people will sit at the big tables.

Let's put people with numbers 0,1,2…p−1 at large tables in the first round (for convenience we index from zero), and the rest for small ones, in the second round we will seat people at large tables with numbers pmodn,(p+1)modn…(2p−1)modn and so on.

We cycle through the players from 1 to n in blocks of p. Since p<n, no one person can be ahead of any other by 2 or more large tables.

Solution1619G - Unusual Minesweeper

Idea: Gol_D

Tutorial1619G - Unusual MinesweeperOur first task is to separate mines into components. We will store in the hashmap mapx at the x coordinate all the y coordinates where there is a mine. Let's do the same with the mapy hashmap. Thus, going through the available arrays in mapx and mapy, we connect adjacent elements into one component, if |mapx[x][i]−mapx[x][i+1]|<=k, also with mapy.

As a result, we have components, where if you detonate one mine in the j's component, then all the mines belonging to this component will also explode.

Further, we find a mine with a minimum timer in each component. Finding the minimum for each component, we store it conditionally in the array a. Now we know at what minimum time some component will explode if it is left unaffected.

To answer, it remains to find in the sorted array a such a minimum index i (0≤i≤a.size−1) that max(a[i],a.size−i−2) is min.

And the general asymptotic behavior is O(nlog(n)).

Solution1619H - Permutation and Queries

Idea: Brovko

Tutorial1619H - Permutation and QueriesLet's compute an array a of n integers — answers to all possible second-type queries with k=Q, Q≈n−−√. Now, if we have to perform any second-type query, we can split it into at most n/Q queries with k=Q and at most Q−1 queries with k=1.

Let's also compute an array r of n integers — reverse permutation. If pi=j, then rj=i.

To perform any first-type query, we should recompute p, r and a. We can swap px and py in the array p and rpx and rpy in the array r. No more than 2⋅Q elements will be changed in the array a. These are elements with indexes x,rx,rrx,…(Q elements) and y,ry,rry,…(Q elements). We can recompute ax and then assign arx=rax and x=rx Q−1 times. Similarly for y.

Time complexity: O((n+q)n−−√).

Solution

Editorial for Codeforces Round #761 (Div. 2)

By dbsic211, 14 months ago, In EnglishThanks for participating, hope you enjoyed the problems! Implementations for the problems are chosen randomly among testers, and I made some changes to their codes (for example, deleted meaningless comment lines). Please do not hesitate to provide feedback in the comments, so I can improve in setting problems next time.

UPD: Sorry but there is a checker bug in problem E. All submissions of problem E will be rejudged soon.

UPD2: Rejudge done, the round remains rated.

Statistics1617A - Forbidden Subsequence

HintSolutionIf there are no occurrences of a, b or c in S, sort S and output it.

Else, if T≠ abc, sort S and output it.

Else, output all a, then all c, then all b, then the rest of the string sorted.

Implementation (C++, I_Love_YrNameCouldBeHere)Fun fact1617B - GCD Problem

HintSolutionKey observation: there always exists a solution with c=1 under the given constraints. We set n≥10 because there is no solution when 1≤n≤5 or n=7.

Solution 1: Brute force from a=2,3,4,… and calculate the value of b (b=n−a−1), then check whether gcd(a,b)=1. It works, because you will find a prime number p≤29 such that n−1 does not divide p.

Solution 2: Randomly choose a and calculate b (b=n−a−1). Repeating that for enough times will eventually get you a pair of (a,b) such that gcd(a,b)=1.

Solution 3: Constructive solution.

When n≡0(mod2), output (n−3,2,1).

When n≡1(mod4), output (⌊n2⌋−1,⌊n2⌋+1,1).

When n≡3(mod4), output (⌊n2⌋−2,⌊n2⌋+2,1).

Implementation (Solution 1, Java, SecondThread)Implementation (Solution 2, C++, dbsic211)Implementation (Solution 3, C++, anthony123)1617C - Paprika and Permutation

Hint 1Hint 2SolutionKey observation: xmody<x2 if x≥y, and xmody=x if x<y.

Notice that the bigger the x, the bigger the range of values that can be obtained after one mod operation. So, intuitively, we want to assign smaller ai to smaller numbers in the resulting permutation.

However, if ai satisfies 1≤ai≤n, we can just leave it there and use it in the resulting permutation (if multiple ai satisfy 1≤ai≤n and have the same value, just choose one). Let's suppose in the optimal solution, we change x to y and change z to x for some z>x>y (x, y, z are values, not indices). Then changing x to x (i.e. doing nothing) and changing z to y uses 1 less operation. And, if it is possible to change z to x, then it must be possible to change z to y. However, if it is not possible to change z to x, it might still be possible to change z to y.

Therefore, the solution is as follows: Sort the array. For each element i in the sorted array:

If 1≤ai≤n and it is the first occurrence of element with value ai, leave it there.

Else, let the current least unassigned value in the resulting permutation be m, if m<ai2, we can assign the current element to value m and add the number of operations by 1. Else, output −1 directly.

The solution works in O(nlogn).

Implementation (C++, physics0523)1617D1 - Too Many Impostors (easy version)

Hint 1Hint 2Hint 3SolutionKey observation: if result of query (a,b,c) ≠ result of query (b,c,d), since b and c are common, players a and d have different roles. Additionally, if result of query (a,b,c) = 1 then player a is a crewmate (and player d is an impostor), vice versa.

The first step is to query players (1,2,3), (2,3,4), …, (n−1,n,1), (n,1,2).

If the results of any two adjacent queries (or queries (1,2,3) and (n,1,2)) are different, we instantly know the roles of the two players that are only included in one query — one is a crewmate, one is an impostor. Since the number of impostors k and crewmates n−k satisfy k>n3 and n−k>n3, there must be one pair of adjacent queries that are different.

After we know one crewmate and one impostor (let's call them a, d), we can query these two players with each one of the rest of the players. If a query (a,d,x) (1≤x≤n, x≠a and x≠d) returns 0, player x is an impostor, else player x is a crewmate.

In total, 2n−2 queries are used.

Implementation (C++, dbsic211)1617D2 - Too Many Impostors (hard version)

Thanks must be given to arvindf232 and generic_placeholder_name for the solution.

Hint 1Hint 2Solution (Step 1)Firstly query (1,2,3), (4,5,6), …, (n−2,n−1,n). Due to the constraint n3<k<2n3, among the results of these n3 queries, there must be at least one 0 and one 1. Now, let's call a tuple (a,b,c) that returns 0 a 0-majority tuple, and vice versa.

From the easy version, notice that finding one crewmate and one impostor is very helpful in determining the roles of the remaining players. Let's make use of the above observation, and pick one adjacent 0-majority tuple and 1-majority tuple.

Let's say we picked (i,i+1,i+2) and (i+3,i+4,i+5). Then, we query (i+1,i+2,i+3) and (i+2,i+3,i+4). Among the four queries (i,i+1,i+2), (i+1,i+2,i+3), (i+2,i+3,i+4), (i+3,i+4,i+5), there must be a pair of adjacent queries with different results. From the easy version, we can directly find the index of an impostor and a crewmate.

In all the above cases, we end up knowing an impostor and a crewmate using n3+2 queries, including the first step.

Hint 3Hint 4Solution (Step 2)It remains to figure out how we can find the roles of the remaining players using 2n3 queries. For each tuple (i,i+1,i+2) queried in the first step, let's assume the tuple is 0-majority (because the other case can be solved similarly). Then, there are only four possibilities:

All players i, i+1, i+2 are impostors.

Player i is a crewmate, players i+1, i+2 are impostors.

Player i+1 is a crewmate, players i, i+2 are impostors.

Player i+2 is a crewmate, players i, i+1 are impostors.

Earlier, we found the index of a crewmate and an impostor, let the index of the crewmate be a and the impostor be b.

If the tuple (i,i+1,a) is 1-majority, either player i or player i+1 is a crewmate. So, we reduced the number of possibilities to 2. To check which player is the crewmate, query it with a and b like we did in the easy version.

Else, either there are no crewmates or player i+2 is a crewmate. So, we reduced the number of possibilities to 2. To check the role of player i+2, query it with a and b like we did in the easy version.

In both cases, we use 2 queries for each initial tuple (i,i+1,i+2). So, we used n+2 queries in total, but we gave you a bit more, in case you used some more queries to find a crewmate and an impostor.

There is one corner case we should handle: if the tuple (i,i+1,i+2) contains a or b, we can just naively query for each unknown role in the tuple, since we won't use more than 2 queries anyway.

Implementation (C++, dbsic211)1617E - Christmas Chocolates

Hint 1Hint 2Hint 3Solution (Step 1)In graph terms, the problem is as follows: in a graph with infinite nodes, two nodes x and y are connected if x+y=2k for some k≥0. Among n special nodes, find the pair of nodes (i,j) with maximum shortest distance.

Here comes the key observation: For any i≥1, there exists only one j (0≤j<i) such that i+j=2k for some k≥0.

The proof is as follows: let's say that 0≤j1,j2<i, j1≥j2, i+j1=2k1, i+j2=2k2. Then, j1−j2=2k2⋅(2k1−k2−1). So, j1≡j2(mod2k2). Since i≤2k2, j1=j2.

Then, we realize we can build a graph as follows: add an edge between x and y (x,y≥0) if x+y=2k for some k≥0. Because of the first key observation, the graph must be a tree. We can root the tree at node 0.

Our problem is equivalent to finding the pair of nodes which have maximum distance in a tree, which can be solved using the diameter of tree algorithm.

Hint 4Solution (Step 2)Since 0≤ai≤109, it is impossible to build the entire tree. A final observation is that: Consider any node v with degree ≥2 in the tree, then v>pv and pv>ppv, therefore v+pv>pv+ppv (px denotes the parent of node x in the tree).

Hence the depth of the tree is ⌈log(max(ai))⌉=30, since there are only ⌈log(max(ai))⌉ possible k (0≤k<30) for the sum of two nodes connected by an edge.

So, there are two ways to do it: the first way is to build parts of the tree: only the n given nodes and the ancestors of the n nodes. There will be at most O(nlogmax(ai)) nodes, which should fit into the memory limit. The second way is to not build the tree at all, and calculate the LCA (Lowest Common Ancestor) of two nodes to find their distance. Since the depth of the tree is 30, LCA of two nodes can be computed by simply checking every ancestor of both nodes.

In both ways, the time complexity is O(nlogmax(ai)).

Implementation (C++, physics0523)

Codeforces Round #760 (Div. 3) Editorial

By BledDest, 14 months ago, In English1618A - Polycarp and Sums of Subsequences

Idea: Brovko, preparation: Brovko

Tutorial1618A - Polycarp and Sums of SubsequencesThe order of elements in a doesn't matter. If there is at least one correct array a, then we can sort it and get the answer in which a1≤a2≤a3. Therefore, we can always find a sorted array. Suppose that a1≤a2≤a3. Then b1=a1, b2=a2, b7=a1+a2+a3. We can find a3 as b7−a1−a2.

Solution (Brovko)1618B - Missing Bigram

Idea: BledDest, preparation: awoo

Tutorial1618B - Missing BigramConsider a full sequence of bigrams for some word. The first bigram consists of letters 1 and 2 of the word. The second bigram consists of letters 2 and 3. The i-th bigram consists of letters i and i+1.

After one bigram is removed, there becomes two adjacent bigrams such that one consists of letters i and i+1 and the other consists of letters i+2 and i+3. Thus, we can find the position of the removed bigram by looking for a pair of adjacent bigrams such that the second letter of the first one differs from the first letter of the second one.

If there is no such pair, then the sequence of bigrams represents a valid word of length n−1. We can append it with any bigram that starts with the second letter of the last bigram to make it a valid word of length n.

If there exists such a pair, then all letters of the word can be recovered. We can find the position of the removed bigram, determine the letters it consisted of and insert it into the sequence.

After that, we have a full sequence of bigrams and we can restore the word from it.

Overall complexity: O(n) per testcase.

Solution (awoo)1618C - Paint the Array

Idea: BledDest, preparation: BledDest

Tutorial1618C - Paint the ArrayWhat does it mean that no pair of adjacent elements should have the same color? It means that either all elements on odd positions are blue and all elements on even positions are red, or vice versa. So, we need to check these two cases.

Let's try to solve a case when we have to find a number d such that a1,a3,… are divisible by d, and a2,a4,… are not. What does it mean that d divides all of the numbers a1,a3,…? It means that d divides the gcd(a1,a3,…), where gcd represents the greatest common divisor. Let's calculate this gcd using Euclidean algorithm or some built-in functions in O(n+logA).

Okay, now we need to check all divisors of the gcd(a1,a3,…) and find if any of them does not divide a2,a4,…. So, we have to factorize gcd and generate all of its divisors... or do we? In fact, if gcd(a1,a3,…) divides any of the numbers a2,a4,…, then every divisor of gcd also divides that number. So, the only two numbers we have to check as canditates for the answer are gcd(a1,a3,…) and gcd(a2,a4,…).

Solution (BledDest)1618D - Array and Operations

Idea: BledDest, preparation: BledDest

Tutorial1618D - Array and OperationsIt's kinda obvious that we have to choose the k greatest elements of the array as the denominators in the operations: suppose we haven't chosen one of them, but have chosen a lesser element as a denominator; if we swap them, the total score won't decrease.

It is a bit harder to prove that the numerators of the fractions should be the next k greatest elements (the elements on positions from n−2k+1 to n−k in sorted order). It can be proved as follows: each fraction we will get in such a way rounds down to either 1 or to 0, and if we choose a lesser element as a numerator, we can decrease a fraction from 1 to 0, but we'll increase the sum of elements that remain in the array, so this is not optimal.

All that's left is to pair the numerators and denominators. A fraction with numerator equal to denominator rounds down to 1, any other fraction will round down to 0, so our goal is to minimize the number of fractions having the numerator equal to the denominator. It can be done by pairing the numbers into fractions in the following way: an−2k+1an−k+1, an−2k+2an−k+2, ..., an−kan (assuming a is sorted).

So, the solution of the problem is the following: sort the array a, then calculate ∑i=1n−2kai+∑i=1k⌊an−2k+ian−k+i⌋.

Solution (BledDest)1618E - Singers' Tour

Idea: shnirelman, preparation: shnirelman

Tutorial1618E - Singers' TourFirst, bi=ai+2⋅ai−1+⋯+i⋅a1+(i+1)⋅an+…n⋅ai+1.

Consider the sum b1+b2+⋯+bn. If we substitute the formula of bi then for every i=1,2,…,n the coefficient at ai will be equal to n⋅(n+1)2, so we can find the sum S of all ai: S=a1+a2+⋯+an is equal to 2⋅(b1+b2+⋯+bn)n⋅(n+1). If the sum of bi isn't divisible by n⋅(n+1)2, then the answer is NO.

Now let's consider the difference between two neighboring towns: bi−b(i+n−2)modn+1=ai−1+ai−2+⋯+aimodn+1−(n−1)⋅ai=S−ai−(n−1)⋅ai=S−n⋅ai, so ai=S−bi+b(i+n−2)modn+1n. If the value of ai we found isn't a positive integer, then the answer if NO. Otherwise, we can find a single value of ai for every i=1,2,…n. It's easy to see that these values are correct.

Overall complexity: O(n) per testcase.

Solution (shnirelman)1618F - Reverse

Idea: Lankin, preparation: Lankin

Tutorial1618F - ReverseThere are two main approaches to this problem.

Approach 1. Let's analyze how the binary representation of x changes after the operation. If there are no zeroes at the end of it, appending 0 just reverses the binary representation; if there are any trailing zeroes, we remove them and reverse the binary representation. If we append 1, we just reverse the binary representation and add 1 at the beginning. No matter which action we choose on the first step, the resulting binary representation will have 1 at its beginning and 1 at its end, so no bits can be removed from it (no zero from the resulting binary representation can become leading). It means that every number we can obtain from x will have the following form: several ones (maybe none), then s, then several ones (again, maybe none), where s is one of the following four strings:

the binary representation of x after appending 1 in the first operation;the binary representation of x after appending 0 in the first operation;one of the aforementioned representations, but reversed.We can check that y meets one of these four templates, but since we only considered the case when we apply at least one operation, we also have to verify if x=y.

Approach 2. Run something like implicit BFS or DFS to generate all possible values you can obtain, pruning when the length of the binary representation we get becomes too large (say, greater than 100). Why does this work fast? As we have shown in our first approach, the numbers we can get from x have a very specific form, and if we limit their lengths to 100, we will consider only about 400 different numbers. Note that if you try this approach, you have to store the obtained numbers in some associative data structure (I use a set of strings in my solution).

Solution (awoo)Solution (BledDest)1618G - Trader Problem

Idea: BledDest, preparation: BledDest

Tutorial1618G - Trader ProblemSuppose we have fixed the value of k, so we can trade an item with price i for an item with price j if j∈[0,i+k]. We can see that it's never optimal to trade an item with higher price for an item with lower price, and we could just simulate the trading process as follows: try to find an item owned by Polycarp and a more expensive item owned by the other character which can be traded, repeat until we cannot find any suitable pair.

Unfortunately, it is too slow. Instead, let's try to analyze: for a given value of k, how to verify that an item of price x can be traded for an item of price y (maybe not right away, but with intermediate trades)?

You can build a graph of n+m vertices representing items, where two vertices representing items with prices x and y are connected by an edge if and only if |x−y|≤k. Then, the edges of the graph represent possible trades, and the paths in the graph represent sequences of trades. So, one item can be traded for another item (possibly with intermediate trades) if the vertices representing the items belong to the same component.

For a fixed value of k, we can build this graph, find all of its components, calculate the number of Monocarp's items in each component and add this number of most expensive vertices from the component to the answer. There are two problems though.

The first one is that the graph may have up to O((n+m)2) edges. But if we sort all items according to their prices, we are only interested in edges between vertices which represent adjacent items in sorted order, so the size of the graph is decreased to O(n+m).

Another problem is that there are multiple queries for different values of k. To handle it, we can sort the values of k in ascending order and go in sorted order while maintaining the graph for the current value of k. A data structure like DSU or a method like small-to-large merging can be helpful to update the components as they merge.

The last trick: to quickly recalculate the number of items Monocarp has in a component and the sum of most expensive several items, you can build two prefix sum arrays — one over the array storing the costs of the items, and another one over the array which stores values 1 or 0 depending on who owns the respective item (the items should still be considered in sorted order). Since each component is a segment of costs of items, prefix sums allow us to calculate the required values in O(1).

By the way, knowing that each component is a segment, we can get rid of the graph and the structure that stores it altogether and just maintain a set of segments of items representing the components.

Solution (awoo)Solution (BledDest)

Codeforces Round #759 (Div. 2, based on Technocup 2022 Elimination Round 3) Editorial

By antonis.white, history, 15 months ago, In EnglishProblems were authored and prepared by:

A: KAN, dimatimoshin23, kirill.grachoff, antonis.white

B: kirill.grachoff

C: napstablook

D: antonis.white

E: antonis.white

F: Denisson

G: antonis.white

1585A - Life of a FlowerIterating through array and looking on our element and previous element, there is possible 4 variants:

ai==1 and ai−1==1 — k += 5ai==1 and ai−1==0 — k += 1ai==0 and ai−1==1 — k += 0ai==0 and ai−1==0 — k = -1, break1585B - Array EversionLemma: If x is max element of the array then eversion doesn't change the array.

Proof: In spite of the fact that division is stable, all elements will be passed to the left part. Their order won't be changed.

Lemma: The lastest element after eversion is the rightest element of the array which is greater than x and lefter than x in the array.

Proof: Look at all elements that are greater than x. This is the right part of the division. Due to stable division, the right element that is greater will be new x. There're no elements greater than x and righter than x because of eversion definition.

Let's build a sequence xa,xa−1,…x0, where x0=an, xi+1 — the rightest element lefter than xi and greater than xi. The answer is equals to a because {xi} is a sequence of last elements overall eversions.

Example:6 10 4 17 9 2 8 1Sequence {xi} — is 1,8,9,17. Answer is 3.

1585C - Minimize DistanceThis problem can be solved with a greedy approach. First, we note that it makes sense to solve positive points xp and negative points xn separately since we would like the minimize the number of times we move across the origin. Second, when we move to the farthest depot to which we haven't delivered a bag yet, we can cover k−1 other depots. Thus we can also deliver bags to the k−1 next farthest depots from the origin. Thus to solve the positive set, we can just sort the positive points and take the sum of the distance of points starting from the farthest point, jumping k points at each step. Thus we can sort xp and xn and find the answer through the following equations:

sumpos=∑i=0|pos|−ki>=0xp|pos|−kisumneg=∑i=0|neg|−ki>=0xn|neg|−kiThe final answer will be 2(sumpos+sumneg) minus the maximum distance of a positive or negative depot since we do not have to return to the origin in the end.

1585D - Yet Another Sorting ProblemSet of all 3-cycles generates a group of even permuations An. So the answer is "YES" if and only if there is an even permutation that sorts array a.

If all elements of a are distinct, then there is unique sorting permutation that has the same parity as a.

If there are identic elements in a, let's look at arbitrary sorting permutation. If it's odd, then we can add transposition of identic elements to it, after this permutation remains sorting, but becomes even. So in this case, even sorting permutation always exists.

Overall, we need to check if all elements of a are distinct. If it's not true, then answer is "YES". Otherwise, we need to check that permutation a is even. This can be done in many ways, including some with O(n) complexity.

1585E - Frequency QueriesLet's traverse through the tree with depth-first-search from the root and maintain counting array (cntx := "number of occasions of x in the sequence"). When dfs enters vertex v, it increases cntav by 1, then it proceeds all queries correspondent to v. When dfs leaves the vertex, it decreases cntav by 1.

Let's maintain this quantities:

Sorting permuation p of cnt, initially — 1,2,…,n.Inverse permuation p−1.For each x∈{0,1,…,n}, "lower_bound" lbx in sorted array. More formally, minimal i such that cntpi≥x.When we want to increase cntx by 1:

Move x in the end of block of same values in sorted array. So we need to swap (p−1i)-th and (lbcntx+1−1)-th positions of p.Change p−1 accrodingly to the change of p.Decrease lbcntx+1 by 1. Note: that's the only lb value that after during this operation.Increase cntx.Operation of decreasing cntx by 1 can be done symmetrically.

Note: if answer exists, then one of possible answers is plbl+k−1.

Total complexity: O(n+q).

1585F - Non-equal NeighboursLet's solve the problem using the inclusion-exclusion formula. Let the i-th property mean that the elements bi and bi+1 are the same. Then for each k=1,…,n−1 the array is divided into n−k consecutive segments, where all the numbers in each of the segments are equal.

Next, we will use the dynamic programming method dp[i][j] − we have already split the prefix of the array b of length i into a number of segments, where j denotes the parity of the number of segments.

We will iterate over the index i=1,…,n. Now for each j (1≤j<i) we have to make an update dp[i][0]+=dp[j−1][1]⋅f(j,i), where f(j,i) is the minimum of the numbers in the array a on the segment [j,i]. Similar to dp[i][1]+=dp[j−1][0]∗⋅f(j,i).

We get the solution with time complexity O(n2). To speed it up to O(n), it is enough to maintain a stack of minimums on the prefix and recalculate dp[i][0/1] with it.

1585G - PoachersSolution below uses Sprague–Grundy theory. Make sure you understand this concept before reading the editorial.

We can note that every position that appears in the game is subtree of one of initial trees or their combinations. This shows that it's sufficient to find grundy-values for all subtrees of initial trees.

Dynamic programming on subtrees will be applied here. We will identify subtree by its root. In each node we will store array of grundy-values for each of possible moves in the game on correspondent subtree. Length of this array is numerically equal to the rank of subtree. We will arrange moves in decreasing by cutting depth order. We will also store grundy-value for subtree itself, it's equal to MEX of grundy-values over all moves.

DP is recalculated in this way:

If node is a leaf it has one move leading to empty game.If node has exactly one child, then we should add grundy-value of child in the end of its array and copy this array in current node. We will recalculate MEX of grundy-values in array explicitely here. We must use the fact that MEX can only increase at this point.Suppose that node has multiple children. We will choose one with the smallest rank (shortest array). Let's imagine here, that we cut all arrays by the length of the shortest, as we cannot make moves with cutting depth greater than rank. In the array of current node we will put array, in each position of which lies XOR of grundy-values in correspondent positions over all arrays of children. We should also add in the end of this array XOR of all grundy-values over all children. We should also calculate MEX of grundy-values in constructed array, we will do it explicitly and starting from 0, calculated value will be equal to grundy-value of current node.Why this work fast? We will use coin method of amortyzed analysis. We will remain the invariant that on each array that we track lie at least (3⋅ LENGTH − MEX) coins:

Each time we calculate MEX explicitly we can use one coin, so this operation is completely paid off.In leaf-case we create one array with length 1 and put 3 coins on it.In other cases we will track one of arrays of children as array of current node and stop tracking arrays of other children.In there is exactly one child, we extend arrays length by 1 and put 3 extra coins on it. Remember, we have already showed that MEX recalculation is paid off.In case of multiple children: let's fix h — length of shortest array of chidlren. We will track this array as array of current. There are (≥2⋅h) coins on this array. As all other arrays are not shorter, they also have (≥2⋅h) coins each. Let's move h coins from them to the shortest one, now it has (≥3⋅h) coins. For each of array (except shortest) we will spend h coins to recalculate grundy-value in the shortest one, we do XOR= operation here. In the moment we extend array by adding XOR of grundy-values over children we put extra 3 coins on it. Note that we lose track of all arrays used here except the shortest one. Note, that there are enough coins to pay off MEX calculation on the shortest array.Note, that we add 3⋅n coins in total. As we paid off each of heavy operations, there ≤3⋅n of those.The only problem left is that when we are trying to recalculate MEX of some array we have to check if number appears in the array. We can maintain set of all elements of the array, each node should contain set for its array. Number of insert/erase/exist queries to all sets are bounded by 4⋅n, as we pay off each operation except failed attempt to increase MEX, but this happens ones in each node.

Total complexity: O(n⋅log(n)).

Editorial of Codeforces Round #758 (Div.1 + Div. 2)

By TadijaSebez, history, 15 months ago, In EnglishAuthor: TadijaSebez

1608A - Find ArrayNotice that x is never divisible by x−1 for x≥3, so we can output 2,3,…,n,n+1.

Author: oversolver

1608B - Build the PermutationFirst, answer does not exists if a+b+2>n.

Second, answer exists if and only if |a−b|≤1.

It happens because between every two consecutive local maximums must be exactly one local minimum. And vice versa, between two consecutive minimums must be exactly one maximum. First case gives b≥a−1, second — a≥b−1, both in total gives a−1≤b≤a+1.

Lets build answer considering a≥b. Otherwise we can build inverse answer: swap a and b, and perform replace pi=n−pi+1.

Lets take a+b+2 biggest numbers (i. e. from n downto n−a−b−1) and put them consequentially, such numbers on first position and on each second position from first are less then other numbers. It gives that every number, except first and last, are local maximum or local minimum. Rest of the numbers needed to be placed before this sequence in increasing order.

Author: TadijaSebez

1608C - Game MasterLet's look at the fights in the reversed order. If player x is the winner, then he won against some player y in the last fight. In (n−2)-th fight either x or y won against some player z, and so on.

We always expand the set by adding a player that can lose against at least one player in the set, so if we can start from x and end up with the set of all players, x can win the tournament.

If we construct a directed graph where we add an edge from player u to player v if and only if u can win against v in a fight, the problem is equivalent to finding the set of nodes from which we can reach all the other nodes.

To reduce the number of edges to 2n−2, we can sort players descending by ai and by bi and add only edges from i-th to (i+1)-th player in these orders.

Notice that x can win the tournament if and only if there is a path from x to the player with maximum ai. To find the set of such nodes, we can run DFS from the player with maximum ai on the graph with each edge reversed, or do two pointers technique on arrays of players sorted by ai and bi.

Author: TadijaSebez

1608D - DominoesIf domino coloring is valid we can split cells into n pairs of cells with opposite colors, so there is exactly n cells of each color.

Let CB and CW be the number of black and the number of white cells in the input, respectively. If CB>n or CW>n, then the answer is 0. Otherwise, the number of colorings with exactly n cells of each color is (2n−CW−CBn−CW). Unfortunately, some of these colorings are invalid, so we need to subtract them.

If there is at least one completely white or completely black domino we can first rearrange them and easily insert multicolored dominoes in between. If all the dominoes are colored in WB or BW the coloring is valid if and only if all dominoes are colored in the same pattern.

We have to subtract the number of colorings where each domino is multicolored and they are not all colored in the same pattern. This can be easily done by finding the number of ways to color each domino in WB or BW, multiplying these numbers and possibly subtracting the cases when all the dominoes are colored in the same pattern.

Author: oversolver

1608E - The Cells on the PaperRectangles in optimal answer always arranged in one of the following ways:

horizontally from left to right;divided by «T»: first rectangle is upper than second and third, and the second is to the left of the third;rotations of previous ways.Lets consider all four rotations and find best answer for arrangements 1 and 2. Additionally, fix the order of colors, they will be 3!=6.

Arrangement 1 can be found by binary search on k. Greedily take k leftmost points of first color and k rightmost points of third. Check if rectangles does not cross and it is enough points of seconds color between rectangles.

Arrangement 2 is binary search on k too. Take k uppermost points of first color, in remaining area take k leftmost points of second color, check if is enough points of third color in remaining area.

Considering the constant factor, in total solution works in O(36nlogn).

Bonus. Task can be solved in O(36n+nlogn). In first, sort all points once by x and once by y. Arrangement 1 can be solved by two pointers in O(n). For arrangement 2 let first (upper) rectangle be empty, and all points be divided into two noncrossed rectangles in such way that difference between sizes is minimal possible. Now lets move bottom of first rectangle and remove points of second and third colors from their rectangles keeping difference as minimum as possible. It can be achieved with linked list in O(n).

Author: Um_nik

1608F - MEX countingLet's count dp[pos][mex][big] — the number of ways to assign first pos elements in a way that:

|MEX([a1,a2,…,ai])−bi|≤k for each i from 1 to pos.

MEX([a1,a2,…,apos])=mexThere are exactly big distinct elements among a1,a2,…,apos, which are bigger then mex. Let's call them large.

We don't care about the exact values of large elements, we care only about their positions and who of them is equal to who. For example, arrays [3,3,4,0,1],[4,4,5,0,1],[5,5,3,0,1] would all be equivalent. We care about the exact values of all other elements.

We only need to consider at most 2k+1 possible values of mex for each pos. Now, let's learn how to transition from pos to pos+1.

Let's say that now we are at state (pos,mex,big). Where can we transition after assigning apos+1?

There are two cases.

MEX doesn't change.It happens when apos+1≠mex. Then, if apos+1 is among those big large elements or is less than mex, the number of large elements won't change. Otherwise, the number of large elements increases by 1 (but we don't care about its value other than it being bigger than mex).

So, we need to add (mex+big)dp[pos][mex][big] to dp[pos][mex][big], and dp[pos][mex][big] to dp[pos][mex][big+1].

MEX becomes mex1>mex.It happens only when apos+1=mex, and all numbers from mex+1 to mex1−1 appear among those big large elements. There are big!(big−(mex1−mex−1))! ways to choose their positions there, and all of them will stop being large, so there will be only big−(mex1−mex−1) elements remaining.

So, we have to add big!(big−(mex1−mex−1))!⋅dp[pos][mex][big] to dp[pos+1][mex1][big−(mex1−mex−1)] for all valid pos,mex,big,mex1.

This already gives O(n2k2) solution, as we have n iterations and O(nk2) transitions on each of them. However, this TLEs. So, let's try to optimize our transitions. We will process cases when MEX doesn't change as before, as it's only O(nk) transitions. So consider only transitions where MEX changes.

Note that mex+big increases exactly by one in such transitions. Also note that we have to multiply by big! when number of large elements previously was big and divide by (big−(mex1−mex−1))! when the number of large elements now becomes big−(mex1−mex−1).

Then let's only consider states with mex+big= some fixed T for now, then we have transitions of sort (mex,T−mex)→(mex1,T+1−mex1) with coefficients (T−mex)!(T+1−mex1)!. So, to find what we have to add to dp[pos+1][mex1][T+1−mex1], we have to find sum of dp[pos][mex][T−mex]⋅(T−mex)! over all valid mex<mex1, and to divide this sum by (T+1−mex1)!. This is easy to do with prefix sums.

So, the final complexity is O(n2k).

Author: TadijaSebez

1608G - Alphabetic TreeLet's concatenate the m input strings, separated by some character not in the input, into a string S, and build the suffix array over it. If we could lexicographically compare str(u,v) to some suffix of S, we could use binary search to find the left and right boundary of suffixes that start with str(u,v) in the suffix array.

Knowing how to find the longest common prefix of a path in the tree and a suffix of S would help us in comparing them, since we would know the first position where these string differ.

Letters on the tree are still unrelated to the letters in concatenated string, so let's append them to S in some helpful way. Let's split the tree into chains using heavy-light decomposition and append the chains and reversed chains to the string S. This way every path in the tree can be split into O(logn) parts which are substrings of S.

Let's build LCP array of S from it's suffix array, and then sparse table over the LCP array, to be able to answer queries for longest common prefix of two suffixes of S in O(1). With such queries we can get longest common prefix of a path and a suffix of S in O(logn) by querying LCP for O(logn) parts of the path and corresponding suffixes of S.

Now we know how to find the range of suffixes which have str(u,v) as a prefix. Out of these suffixes we have to count only these for which first position belongs to a string with index in the set {l,l+1,…,r}.

We can do the counting offline, sweeping through strings from the first to the last and maintaining binary indexed tree over suffix array. In iteration i we store 1 for suffixes of strings with indices 1,2,…,i, and 0 for the rest. A query can be solved by taking the difference of sums on suffix array range in iteration r and in iteration l−1.

Building suffix array can be done in O(nlog2n), O(nlogn) or O(n) depending on the chosen algorithm, LCP array can be constructed from the suffix array in O(n) using Kasai's algorithm, while the sparse table construction works in O(nlogn) and uses O(nlogn) memory. Searching for the ranges can be done in O(qlog2n) as described above, and the last offline sweeping part takes O((n+q)logn) time. The overall time complexity is O((n+q)log2n), with O(nlogn) memory.

Codeforces Round #757 (Div. 2) Editorial

By 4qqqq, 15 months ago, In EnglishA. Divan and a Store

SolutionTo solve this problem, let's use the following greedy algorithm.

Let's sort the prices of chocolate bars in increasing order, after which we will go from left to right and take chocolates that have a price not less than l, but not more than r until we run out of money.

The number of chocolate bars that we took will be the answer to the problem.

The resulting asymptotics in time: O(nlogn).

B. Divan and a New Project

SolutionObviously, the more often we have to go to the i building, the closer it should be to the main office.

This implies a greedy algorithm. Let's put the main office at 0 and sort the rest by ai. Then we put the most visited building at a point with a coordinate of 1, the second at −1, the third at 2, etc.

The resulting asymptotics in time is O(nlogn).

C. Divan and bitwise operations

SolutionLet's count for each bit how many times it will be included in the answer.

Let us now consider the i-th bit. Note that if no number contains the included i-th bit, then such a bit will never be included in the answer. Otherwise, each of the subsequences contains i-th bit even or odd number of times. If a bit enters an even number of times, then we should not count such a subsequence, because the bitwise exclusive OR for this bit will be zero. If the bit enters an odd number of times, then we must count such a subsequence, because the bitwise exclusive OR for this bit will be equal to one.

It is stated that the number of subsequences in which the i-th bit enters an odd number of times is equal to 2n−1. Let's prove it.

Divide the numbers into two sets A and B. In the set A there will be numbers whose ith bit is off, in the set B there will be numbers whose i-th bit is on.

Note that the numbers from the set A do not affect the answer in any way, because xXOR0=1. Thus, whichever subset of A we take, the i-th bit will not change its parity. There will be 2|A| in total of such subsets.

Let k=1 if |B| is even, or k=0 if |B| is odd. In order for the i-th bit to enter the subsequence an odd number of times, you need to take an odd number of elements from the set B. This number is equal to C1|B|+C3|B|+…+C|B|−k|B|=2|B|−1.

Thus, the i-th bit is included in exactly 2|A|⋅2|B|−1=2n−1 subsequences, which was required to be proved.

Then the solution to this problem turns out to be very simple: let x be equal to the bitwise OR of all elements of the sequence (or, the same thing, bitwise OR of all given segments), then the answer will be equal to x⋅2n−1 modulo 109+7.

The resulting asymptotics in time: O(n).

D1. Divan and Kostomuksha (easy version)

SolutionLet's solve the dynamic programming problem. Let dpi be the maximum answer for all arrays, the last element of which is divisible by i. Let's calculate the dynamics from C to 1, where C is the maximum value of ai. Initially, dpi=cnti⋅i, where cnti is the amount of ai=i. How do we recalculate our dynamic programming? dpi=max(dpi,dpj+i⋅(cnti−cntj)), for all j such that j mod i=0 (i.e. j is divisible by i). In this dynamic, we iterate over the past change of our gcd on the prefix, and greedily add all possible elements.

The resulting asymptotics in time is O(ClogC).

D2. Divan and Kostomuksha (hard version)

SolutionTo solve D2, we can notice that to recalculate the dynamics, we can iterate over all such j that differ from i by multiplying exactly 1 prime number. Also, to speed up the solution, we can use the linear sieve of Eratosthenes to find primes and factorization.

The resulting asymptotics in time: O(CloglogC).

E. Divan and a Cottage

SolutionLet anstemp the current answer for temperature temp. Before all days, anstemp is considered equal to temp.

In order to respond to a request with a temperature of x, we will just need to output the value of ansx. But how to maintain ans? With the help of an implicit tree of segments, at the vertices of which the minimum and maximum will be stored, as well as the variable add, which will contain the value that needs to be added to the current vertex (that is, such a variable that is needed to perform lazy operations on the segment tree).

At the beginning of the next day you get the temperature T. Now we need to change the current answer for some temp. We need to find such anstemp that anstemp<T and add +1 to them, and then find such anstemp that anstemp>T and add −1 to them. All this is not difficult to do, just starting from the root of the segment tree and stopping at the moments when:

the maximum of the current vertex is less than T — here we add +1;the minimum of the current vertex is greater than T — here we add −1;the minimum of the vertex is equal to the maximum of the vertex (and, therefore, the T itself) — here we do not add anything.The resulting asymptotics in time: O(nlogT).

Codeforces Round #756 (Div. 3) Editorial

By Gol_D, history, 15 months ago, In English1611A - Make Even

Idea: MisterGu

Tutorial1611A - Make EvenIf the number is already even, then nothing needs to be done, so the answer in this case is 0.

Now let's recall the divisibility by 2: a number is divisible by 2 if and only if its last digit is divisible by 2.

It follows that if there are no even digits in our number, then the answer is -1.

Let's take a look at our operation. What is going on? The first digit always changes with the digit numbered l. In particular, when we reverse the entire number, the first digit is swapped with the last. Note that no other digit, except for the first one at the current moment, can't be the last.

Therefore, you can do this: if the first digit of a number is divisible by 2, then we reverse the whole number. The first digit will become the last, and the number will become even. Therefore, you only need to do one operation.

Now, what if the first digit of a number is odd? In this case, we can find the first even digit in the number (let it be at position x), and reverse the prefix of length x (in one operation). Now the first digit of our number has become even, and we can use the previous case (one more operation). Thus, we will do only 2 operations.

Solution1611B - Team Composition: Programmers and Mathematicians

Idea: MikeMirzayanov

Tutorial1611B - Team Composition: Programmers and MathematiciansIf necessary, change the values of a and b so that a≤b is always true. Consider two cases.

1. Let a≤a+b4. Then:

4a≤a+b, 3a≤b.

This means that the set b is at least 3 times larger than a, and we can form a teams of the form (1,3), where one participant will be a programmer and three will be mathematicians.

2. Let a+b4≤a. Then assume that b=a+d. Let's substitute this value into the inequality:

2a+d4≤a, 2a+d≤4ad≤2a, d2≤aThen we compose d2 commands of the form (1,3). Since making such a command decreases the value of d by 2. The new value a′=a−d2, b′=a′+d−2∗(d2). The condition a′≤b′ still holds. Then make a′2 commands of the form (2,2).

The total number of commands is a′2+d2=2∗a′+2∗d4=2∗a−d+2∗d4=a+(a+d)4=a+b4. That's what we wanted to get.

Solution1611C - Polycarp Recovers the Permutation

Idea: MikeMirzayanov

Tutorial1611C - Polycarp Recovers the PermutationThe maximum element is always added last, so if it is not in the first or last position, then there is no answer.

Let us prove that if the permutation has its maximum element in the first or last position, then after n actions we can get an expanded permutation. Indeed, the maximum element will be added last at the desired end, and all the others will be added in reverse order.

Then, if the answer exists, it is sufficient to simply unfold the permutation.

Solution1611D - Weights Assignment For Tree Edges

Idea: MikeMirzayanov

Tutorial1611D - Weights Assignment For Tree EdgesConsider the cases when it is impossible to form a given permutation p:

1. The first vertex in the permutation is not the root of the tree. For root u it is true that dist[u]=0. For any other vertex i the value of dist[i] will be positive, since there is at least one edge of positive weight on the path to it.

2. The distance to the child is less than to the parent. In a rooted tree there is exactly one path from the root to any vertex i, and it goes through its parent bi, so it must always be true dist[b[i]]<dist[i].

Let us start filling the array dist, where dist[p[1]]=0. Consider a vertex p[i], (2≤p[i]≤n). The vertex whose distance at the current time is maximal is p[i−1]. Then dist[p[i]] is at least dist[p[i−1]]+1. We assign a value to dist[i], remembering to check that dist[b[i]] has already been counted.

After counting all dist[i] values, we can output the lengths of the edges: w[i]=dist[i]−dist[b[i]].

Solution1611E1 - Escape The Maze (easy version)

Idea: Vladosiya

Tutorial1611E1 - Escape The Maze (easy version)First, we need to understand when it is not possible to get to some exit e. Let's fix a friend who is at the vertex f and try to understand if he can interfere with us. The paths from 1 to e and from f to e have a common part, let it start at the vertex v. Then, if the path from f to v is not more than from 1 to v, it can prevent us from reaching this exit by blocking the vertex v. Since the path from v to e is common, the previous condition is equivalent to the condition that the path from f to e is not greater than from 1 to e. Note that if there is more than one such vertex e, then f can overlap each of them, simply by going as close to the root as possible.

Thus, Vlad can win if there is such a leaf (which, by condition, exits) for which the distance to the root is less than the distance to any of the friends.

By running a breadth-first search at the same time from each vertex with a friend, we can find the shortest distance to any friend from each vertex and by running from the root — the distance to the root. Now let's just go through all the leaves and check if there is one among them that the distance to the root is less.

We can also run from the vertices with friends and from the root at the same time, assigning them different colors, then the color will correspond to what is closer: the root or some friend. this solution is attached to the tutorial.

There is also another solution, which is a simplified version of the one we will use in E2.

Solution1611E2 - Escape The Maze (hard version)

Idea: Vladosiya

Tutorial1611E2 - Escape The Maze (hard version)Let's learn how to find an answer for the subtree rooted in vertex v. At first, it is obvious from E1 tutorial that if the nearest to v vertex with a friend from this subtree is no further from it than the root of the entire tree from v, then the answer for the entire subtree is 1 since a friend can come to v and catch Vlad in it not allowing him to go to any leaf of this subtree. Else we will find the answer leaning on its children. If a solution does not exist for at least one child, then it does not exist for the entire subtree, because after reaching v Vlad will be able to go to such child and reach any exit. Otherwise, the answer for v is the sum of the answers of its children, since we need to beat it in each subtree to win, and for each subtree, we have found the minimum answer.

Solution1611F - ATM and Students

Idea: Gol_D, MikeMirzayanov

Tutorial1611F - ATM and StudentsAt first glance, this is a standard problem for ST (Segment Tree). Let's solve the problem in that way.

First, we find the prefix sums of the a array and store them in p. Let's build an ST on the prefix array and store the min in it.

For each index l (1≤l≤n), we'll make a query in ST and will find such a minimum index r (l≤r) that the sum on the subsegment [l,r] of the array a and s will be negative, in other words s+(p[r]−p[l−1])<0 or s−p[l−1]<−p[r], the sum of s is obtained and the subsegment [l,r) of the array a will be non-negative, in other words, s+(p[r−1]−p[l−1])≥0. Accordingly, the correct response to the request will be l and r−1. Of all such pairs of indices l and r−1, we take such that the distance between them is maximal. If for all pairs l==r, then the answer is −1.

The hardest part here is the querys. Actually, here's a query that returns r−1 for index l or −1 if l==r:

int lower_bound_s(int v, int tl, int tr) {    if (tr < l || (tl == tr && s - p[l - 1] < -segment_tree[v])) {        return -1;    }    if (tl == tr || -segment_tree[v] <= s - p[l - 1]) {        return tr;    }    int m = (tl + tr) / 2;	    if (m < l) {        return lower_bound_s(2 * v + 1, m + 1, tr);    }    if (s - p[l - 1] < -segment_tree[2 * v]) {        return lower_bound_s(2 * v, tl, m);    }    int res = lower_bound_s(2 * v + 1, m + 1, tr);    return (res == -1) ? m : res;}Btw, after each request for l do not forget to change in ST the element that corresponds to p[l] to MAX_INT, so that it does not interfere with us.

Time complexity is O(n⋅log(n)).

Solution1611G - Robot and Candies

Idea: MikeMirzayanov

Tutorial1611G - Robot and CandiesNote first that we can solve the two subtasks independently if we consider the coloring as on a chessboard, since at any move of the robot the parity of x+y does not change.

Now replace the moves (x+1,y−1), (x+1,y+1) with moves (x+1,y), (x+1,y+1) respectively. This can be done because we simply shifted the rows by some value, with the Robot walking on the same cells it walked on in the original board.

Let's look at the even numbered (gray) cells:

Changed field

Then we'll go through the columns from left to right, keeping the minimum(by size) set of cells the Robot should be in. Then the transition to the next column will be as follows. Go through the cells from bottom to top, which contain the candy. For each cell, find the closest cell of our set (find the Robot) that is above the current cell. Then we change the square from the set to the current square. If there is no robot for the square in the array, then we need to increase the answer by 1 and add the robot to our current square (you can think of it as adding the robot to the very top square in the column and getting all the candies that were above).

In the picture, the red circles indicate the cells where we will put the robot as needed. The pink cells mean that this cell is contained in the set.

The final asymptotic depends on the implementation (you can use a set as data structure, or you can use a vector with two pointers): O(n∗m∗log(n)) and O(n∗m), respectively.

Solution

Editorial for Technocup 2022 — Elimination Round 2 and Codeforces Round #755 (Div. 1, Div. 2)

By isaf27, history, 15 months ago, In English1584A - Mathematical AdditionWe have the equation: xu+yv=x+yu+v.Let's multiply the left and right parts by u∗v∗(u+v).

Received: x∗v∗(u+v)+y∗u∗(u+v)=(x+y)∗u∗v.

After opening the brackets and simplifying, we have: x∗v2+y∗u2=0.

One of the solutions to this equation is x=−u2, y=v21584B - Coloring RectanglesRectangles after cutting will be painted in a chess coloring. So, if the area is even, then the number of cells of different colors is the same, and if it is odd, then it differs by exactly 1.

Let's find out what part the colored cells occupy in relation to all of them. For an even area, this ratio is always 12. For odd S−12⋅S. The smaller the odd area, the smaller the ratio. An area equal to 1 cannot be obtained, so the best ratio is 13 and is achieved with an area equal to 3.

Then we get the lower estimate for the answer: answer≥n⋅m⋅13. Great!

We know that the answer is integer, so if we manage to construct such a cut that it is necessary to color exactly such a cnt of cells thatn⋅m3≤cnt<n⋅m3+1, then cnt will be the answer. After all, cnt is the minimum integer value satisfying the estimate.

If one of the sides is divisible by 3, then it is obvious how to cut into 1×3 rectangles and get the perfect answer.

If the remains of sides 1 and 1 or 2 and 2, then you can cut into 1×3 rectangles and one rectangle with an area of 4, in which you need to paint over 2 cells. Then the answer also fits the assessment.

If the remains of sides 1 and 2, then after cutting into 1×3 rectangles, a rectangle will remain 1×2, in which you need to paint one cell. The answer also fits the assessment.

For all pairs of remains, there is a way to construct an answer satisfying the inequality. Therefore, the answer is ⌈n⋅m3⌉1584C - Two ArraysLet's sort the arrays first.

Let's check the two smallest elements in the arrays and investigate their behavior. First, obviously, if a1+1<b1 (as nothing can be matched with a1) or a1>b1 (as nothing can be matched with b1) the answer is No. Then, it's possible that a1=b1=x. In this case, we have to have at least one x in the array a at the end. Hence, we can leave a1 untouched, as it already suits to b1. It's also possible that a1+1=b1. Here we have to increase a1 by 1. In both cases, the task is reduced to the smallest one.

Going to the exact solution from this logic, we just have to sort both arrays and check that for each 1≤i≤n it's ai=bi or ai+1=bi.

The complexity of the solution is O(nlog(n)).

1584D - Guess the PermutationNote that the number of inversions on decreasing sequence of length l is (l2).

As we reversed two non-overlaping subsegments, the number of inversions on each subsegment is equal to sum of number of inversions of parts of reversed subsegments, which are decreasing.

First of all, let's find A:=(k−j+12)+(j−i2) — total number of inversions in sequence. We use 1 question for that.

Now let's look on the number of inversions on subsegment [x, n]. If this number is less than A, then not both reversed subsegments fit entirely, so i<x, otherwise i≥x.

Now we can apply binnary search to find i. We use log2(n) questions here.

Now let's ask the number of inversions on subsegment [i+1, n], let's call this number B. We use 1 question here. From the structure of sequence: A−B = |{x|x>i,ax<ai}| = |[i+1,j−1]| = j−i−1.

Now we can find j−i, j and (j−i2), due to the definition of A, we find (k−j+12).

Finaly, we can solve quadratic equation for k−j+1 and get k.

Overall, we used log2(n)+2≤32 questions, but we gave you a bit more, in case your solution uses few more questions on some stage.

1584E - Game with StonesThis game has greedy strategy: look at first pile, all its stones have to be matched with stones from next pile, because it is its only adjacent pile. If pile is non-empty and there are no next pile, or next pile is smaller than current, Bob loses. Otherwise, Bob makes current pile empty, and remove corresponding number of stones from next pile. Now Bob plays the same game as if had one pile less, we can remove first pile without changing game. Bob wins if at the moment he reduced game to one pile it's already empty.

Now let's iteratively define array c, where ci — number of stones left in the i-th after removing 1,…,i−1 piles, according to greedy strategy. Let c0=0, then ci=ai−ci−1.

If array contains only positive numbers, then it means that Bob is able to remove piles all the way over. Otherwise, let t be the first moment with ct<0, this means that Bob was able to remove piles until he meet t-th pile and ct−1>at happened, so Bob loses. To check that last pile is empty, we need to check if cn=0.

So we have criteria of winning subsequence: ci≥0 for all i, cn=0.

Let's expand recursive notation of ci: ci=ai−ai−1+ai−2−…+(−1)i−1⋅a1.

We will solve problem separately for different l — left bound of subsegment. Let's define sequence al:=al,al+1…an, ali=al+i−1. It has similar array cl. We will find first position of negative number in cl —t (clt<0). And then count how may zeros are on prefix [1, t−1]. This will give us number of winning subsegemtns with form [l,r], sum over all l will give us answer for the problem.

Note, that cli=ali−ali−1+…+(−1)i−1⋅al1=al+i−1−al+i−2+…+(−1)i−1⋅al=cl+i−1+(−1)i−1⋅cl−1.

Note, that cli<0 if and only if cl+i−1<(−1)i−1⋅cl−1. Let's divide problem by parity of indexes. Now to find first position of negative number in cl we should find first position of "number less than x" on suffix of c. This can be done many ways, for example, by descending through segment tree (segment tree for each parity).

Note, that cli=0, if and only if cl+i−1=(−1)i−1⋅cl−1. Same division of problem by parity. Now to count number of zeros on subsegment of cl we should count number of "equals to x" on subsegment of c. This can be done by storing all positions of each ci in some container (one for each parity) and binnary search.

Overall complexity of the solution : O(n⋅log(n))

1584F - Strange LCSLet's define efinegraph with vertexes (c, msk), where chr denoting some character, ans mask is n-bit mask of occasions (i-th bit is set to 1 if and only if we consider second occasion of c in i-th string). Not all mask are possible for some c since there could be less than 2 occasions. Note: vertex define choise of character and positions of this character in all strings.

Note, that graph has O(|Σ|⋅2n) vertices.

Let's define strict comparison (<) of vertices:(chr1, msk1) < (char2, msk2) if and only if positions chosen by first vertex are stricly lefter than ones chosen by second (for all strings). Let's define another comparison (≤) the same way, but allow some position to be equal. Note: strict comparison is anti-reflexive, both comparison are transitive and this stands (a ≤ b < c ⇒ a < c).

Graph contains directed edges from one vertex to another, if and only if first is smaller by defined comparison. Note: graph is acyclic, because of transitivity of pair comparison.

Note: that for every common subsequence there is unique corresponding path in defined graph and vice versa. So we need to find longest path in this graph. Vertex-length of path will be equal to the length of corresponding subsequence.

We want to calculate dp(c, msk) – length of longest path starting from this vertex. This dp is easy to calulate on DAG, but number of edges is too big. We want to remove some edges without changing values of dp. Note: if removal of edge doesn't change dp of its starting point, when it doesn't change dp at all.

Let's look at arbitrary vertex (c,msk), that has at least one outgoing edge and some longest path starting from it (it has at least one edge): [(c,msk)→(c2,msk2)→…]. Suppose there exists mask MidMsk≠msk2, such that: (c, mask) < (c2, MidMsk) ≤ (c2, msk2). By the qualities of defined comparisons, we can change second vertex in longest path to (c2, MidMsk).

Now let's find mask for fixed c2 which correspond to choise of leftmost positions righter than positions chosen by (c, msk). It can be found in O(n) time. As we notices earlier, without loss of generality, longest path (with fixed c2) goes through this vertex , so we can harmlessly remove all edges going from current vertex to the vertices with character c2, but diffrent mask. This can be done for every character.

Now graph each vertex has O(|Σ|) outgoing edges, so dp can be calculated fast enough. Subsequence itself can be easily found now.

Note: there is no need for graph in solution, it's just abstraction for better understanding.

Note: we don't have to calculate dp for all vertices, we only need to find dp(c,0) for all c, it can be proven by applying same logic.

Overall complexity: O(n⋅|Σ|2⋅2n)1584G - Eligible SegmentsThe distance from point P to segment [AB] is equal to the maximum of the distance from point P to ray [AB) and the distance from point P to ray [BA).

Let's fix a point Pi. Now we have to find all points Pj such that distance from every point Pk(1≤k≤n) to the ray [Pi,Pj) is less than R.

For every point Pk let's build two tangents from point Pi to the circle with the center in the point Pk and radius R. These tangents form an angle Ak. The distance from the point Pk(1≤k≤n) to the ray [Pi,Pj) is less than R iff the ray [Pi,Pj) lies inside the angle Ak. So we can build all these angles Ak and intersect them, after that, we only have to check that the ray [Pi,Pj) lies inside the intersection of all angles for all 1≤j≤n.

Time complexity: O(n2).

1588F - Jumping Through the ArrayLet's call B=⌊n−−√⌋.

Let's divide an array a into consecutive blocks of size B.

To answer the query we will have to sum O(B) ai near the segment's bounds and O(nB) sums on blocks. Let's try to calculate them fast.

There are two types of cycles:

small: with length <Bbig: with length ≥BIf there is a second type query for the small cycle it is easy to make it in O(B) time: let's iterate over cycle's elements and add x into its ai and into its array's block sum.

It is harder to deal with big cycles. Let's divide each big cycle into blocks, each having the size in [B,2B−1]. Initially, it is possible. After each query of type 3 it is possible to reconstruct this division fast:

Let's split two blocks with i and j. After that, it is possible to reconstruct the divisions of each new cycle into blocks.After that, we should avoid small blocks (with size <B). Let's merge two consecutive blocks if one of them has the size <B. After that, if the total block has size ≥2B let's split it into two equal blocks.Someone calls this method split-rebuild.So, maintaining this structure we will have at most nB cycle blocks at any moment. If there is a second type query for the big cycle let's add x to the cycle blocks for this cycle. To consider these values while answering the first type query let's maintain the last structure:

For each cycle block t let's calculate the values preft,0,preft,1,…,preft,⌈nB⌉, where preft,i is the number of elements from the t-th cycle block in the first i array's blocks.Using these values it is easy to consider additions to the cycle blocks in the subsegments sums queries.

And the values of pref can be recalculated during the cycle's updates because we make O(1) splits and merges. During each split or merge we should recalculate pref for O(1) rows (and this can be done in O(nB) for one t). Also during each split or merge we should zero additions to blocks in operations just pushing the added value into the elements of the block (their number is smaller than 2B).

The total complexity of the solution is O(nn−−√).

Codeforces Round #754 (Div. 2) Editorial

By ExplodingFreeze, 16 months ago, In English
Thank you for participating! We hope you enjoyed the contest.

1605A - A.M. Deviation

Authored and prepared by JeevanJyot

Hint 1
Hint 2
Hint 3
Solution
1605A - A.M. Deviation
→
 Applying the operation on a1
 and a3
 (irrespective of which element is incremented and which one is decremented) does not change the value of a1+a3−2⋅a2
.

→
 Incrementing a1
 (or a3
) by 1
 and decrementing a2
 by 1
 causes the value of a1+a3−2⋅a2
 to increase by 3
.

→
 Decrementing a1
 (or a3
) by 1
 and incrementing a2
 by 1
 causes the value of a1+a3−2⋅a2
 to decrease by 3
.

This effectively means that we can add or subtract any multiple of 3
 by performing some number of operations. Also, the value of a1+a3−2⋅a2
 will never change modulo 3
. Thus,

If a1+a3−2⋅a2≡0
 mod3
, then the minimum value of d(a1,a2,a3)=|0|=0
If a1+a3−2⋅a2≡1
 mod3
, then the minimum value of d(a1,a2,a3)=|1|=1
If a1+a3−2⋅a2≡2
 mod3
, then the minimum value of d(a1,a2,a3)=|2−3|=|−1|=1
In simpler words, if a1+a3−2⋅a2
 is divisible by 3
 the answer is 0
, otherwise it is 1
.

Time Complexity: O(1)
Solution [c++] (JeevanJyot)
Solution [Kotlin] (ExplodingFreeze)
Solution [Python] (AshishGup)
1605B - Reverse Sort

Authored by Ashishgup and prepared by JeevanJyot.

Hint 1
Hint 2
Solution
1605B - Reverse Sort
Any binary string s
 can be sorted in at most 1
 operation!

Let the number of 0
s in s
 be cnt0
 and the number of 1
s in s
 be cnt1
.

The first cnt0
 positions of the final sorted string will be 0
 and the remaining cnt1
 positions will be 1
 (since it is sorted in non-decreasing order).

Key observation: For every 1
 that is in the first cnt0
 positions of s
, there is a 0
 that is in the last cnt1
 positions of s
 (Why?).

If the string is not already sorted, in one operation pick the subsequence consisting of all 1
s among the first cnt0
 positions of s
 as well as all 0
s among the last cnt1
 positions of s
. It can be shown that this will correctly sort the string since the number of such 0
s and 1
s are equal.

Time complexity: O(n)

Solution [c++] (JeevanJyot)
Solution [Kotlin] (ExplodingFreeze)
Solution [Python] (AshishGup)
1605C - Dominant Character

Authored by Ashishgup and prepared by JeevanJyot.

Hint 1
Hint 2
Hint 3
Solution
1605C - Dominant Character
Tl;dr: The following are all the possible minimal substrings (there aren't that many) which satisfy the given conditions: "aa", "aba", "aca", "abca", "acba", "abbacca", "accabba". Any other string that satisfies the condition contains at least one of these as a substring, and hence is not the optimal substring for the answer.

Claim: If a substring exists which satisfies the given conditions, then the length of the shortest such substring is at most 7
. Otherwise the solution does not exist.

Proof: Let us consider that the solution exists. We will try to prove this by breaking this into the following cases:

Case 1: There exist two such "a" whose distance is less than or equal to 2
, where distance is the absolute difference of their indices.

In this case where there are two such "a" whose distance is less than 2
, then either these two "a" are present consecutive or there is only one single letter between these two "a". All these minimal substrings are "aa", "aba" and "aca"which satisfies all the given conditions.
Hence we can say that the shortest length of such substring that satisfies the given conditions is at most 3
 in this case.

Case 2: There exists no two such "a" whose distance is less than or equal to 2
.

In this case all the consecutive occurrences of "a" are present at a distance at least 3
. Then in order for the number of "a" to be bigger than that of "b" and "c" the string must look like "a??a??a??a??a".
Let us define "??" as a block. Now if there is any block consisting of different characters i.e
 "bc" or "cb" then the substring "a??a" will satisfy all the given conditions and hence the minimal length will be 4
.
Notice that there must be at least one block of "bb" and atleast one block of "cc", otherwise "a" will not be in a majority. Hence, there must exist 2 consecutive blocks equal to "bb" and "cc" or "cc" and "bb" in the string (otherwise all blocks would be of the same character). Hence we can pick the substring "abbacca" or "accabba" which satisfies the given conditions. The minimal length is, therefore, 7
 in this case.
Therefore we can say that the shortest length of such substring that satisfies the given conditions is at most 7
 in this case.

Thus, it suffices to only check all substrings of length up to 7
 and find the smallest among them that satisfies the given conditions (or report that it does not exist).

Time Complexity: O(7⋅n)
Solution [c++] (AshishGup)
Solution [Kotlin] (ExplodingFreeze)
1605D - Treelabeling

Authored and prepared by the_hyp0cr1t3.

Hint 1
Hint 2
Hint 3
Hint 4
Hint 5
Solution
1605D - Treelabeling
If the most significant bits (MSBs) of two integers x
 and y
 are the same, say MSBx=MSBy=b
, then the b
-th bit will be unset in x⊕y
. Since min(x,y)
 will have this bit set, it will be greater than x⊕y
. Thus, if MSBx=MSBy
 then x⊕y≤min(x,y)
.

If a node in the tree is adjacent only to nodes whose MSB differs from its MSB, then the player who plays this node will win.

It turns out that not only is it always possible to make it such that no two nodes sharing an edge have the same MSB, it is also necessary to do so in order to maximize the number of winnning starting nodes for Eikooc. Consequently, starting at any node will guarantee a win for her.

Why is it necessary if it is always possible?Assume there exists at least two nodes in the tree that are adjacent to each other, having the same MSB. We prove that there will be at least one losing node for Eikooc to start on, which is suboptimal.Consider a connected component of nodes in the tree of size at least two, all having the same MSB. Since this connected component also forms a tree, it must have at least one leaf node. Any node in the component which is adjacent to at least one of these leaf nodes will be losing for Eikooc (since Sushi can just move the token to a leaf node and Eikooc will have no moves to play).

How do you construct it and is it always possible to do so (if so, why)?We aim to relabel the nodes of the tree in such a way that for every node v
 in the tree and all nodes u
 adjacent to it, MSBv≠MSBu
.Think bipartite. In the bipartite colouring of a tree, no two adjacent nodes have the same colour. If we are able to relabel the nodes in such a way that all nodes with the same MSB belong to the same colour, we are done.Key observation: There are 2i
 occurrences of integers from 1
 to n
 with the i
-th bit as MSB (0-indexed) for each i
 from 0
 to MSBn−1
, and all such groups of integers are disjoint (since each integer has exactly one MSB).Let the number of white and black nodes be w
 and b
 respectively and WLOG let w≤b
 (we can swap the colours otherwise). Since all nodes are coloured either white or black, w+b=n
. Under these constraints, it is then easy to show that w≤n2
. Consequently, MSBw<MSBn
. Since MSBw<MSBn
, w
 can possibly only have those bits set which lie in the range [0,MSBn−1]
. Can you connect the dots?Consider the binary representation of w
. We can assign all integers from 1
 to n
 having the i
-th bit as MSB to a white node if the i
-th bit is set in w
, and assign all the remaining integers to black nodes. In doing so, no two nodes having the same MSB will belong to different colours. This ensures that no such pair is adjacent. This is also guaranteed to always be possible since the binary representation of w
 only spans the first MSBn−1
 bits and we also have access to groups of sizes comprising all powers of two upto MSBn−1
.

Time complexity: O(n)
Solution [c++] (the_hyp0cr1t3)
Solution [c++] (AshishGup)
Solution [Kotlin] (ExplodingFreeze)
1605E - Array Equalizer

Authored and prepared by JeevanJyot.

Hint 1
Hint 2
Hint 3
Solution
1605E - Array Equalizer
Firstly let's observe that only the differences bi−ai
 matter, and not the individual values of ai
 and bi
. So let us create two more arrays A
 and B
 where initially Ai=0
 and Bi=bi−ai
 for all i
. The problem reduces to making A
 equal to B
.

Let's have a few definitions for ease of explanation. We define operation "add" k
 to i
 as: perform the increment operation at i
 (and multiples of i
), k
 times, if k>0
, otherwise perform the decrement operation at i
 (and multiples of i
), k
 times. In both cases, the number of operations performed is |k|
.

Let's first solve the problem for only one value of B1
. We notice that problem can be solved using a simple greedy approach. We iterate over the elements from left to right. Let the index of the current element be u
.

Initial arrays:
-	1	2	3	4	5	6	⋯
A
0
0
0
0
0
0
⋯
B
B1
B2
B3
B4
B5
B6
⋯
add	-	-	-	-	-	-	⋯
At u=1
: Applying the operation at i=1
 alone can change the value of A1
. Thereby we "add" B1
 at i=1
 to make A1=B1
. The remaining array also gets modified accordingly. Resulting arrays:
-	1	2	3	4	5	6	⋯
A
B1
B1
B1
B1
B1
B1
⋯
B
B1
B2
B3
B4
B5
B6
⋯
add	B1
-	-	-	-	-	⋯
At u=2
: Applying the operation at i=1
 and i=2
 only can change the value of A2
. But since we have already made A1=B1
, we will only apply operations at i=2
. We "add" B2−B1
 at i=2
. Resulting arrays:
-	1	2	3	4	5	6	⋯
A
B1
B2
B1
B2
B1
B2
⋯
B
B1
B2
B3
B4
B5
B6
⋯
add	B1
B2−B1
-	-	-	-	⋯
At u=3
: Applying the operation at i=1
 and i=3
 only can change the value of A3
. But since we have already made A1=B1
, we will only apply operations at i=3
. We "add" B3−B1
 at i=3
. Resulting arrays:
-	1	2	3	4	5	6	⋯
A
B1
B2
B3
B2
B1
B3+B2−B1
⋯
B
B1
B2
B3
B4
B5
B6
⋯
add	B1
B2−B1
B3−B1
-	-	-	⋯
At u=4
: Applying the operation at i=1
, i=2
 and i=4
 only can change the value of A4
. But since we have already made A1=B1
 and A2
 = B_2, we will only apply operations at i=4
. We "add" B4−B2
 at i=4
. Resulting arrays:
-	1	2	3	4	5	6	⋯
A
B1
B2
B3
B2
B1
B3+B2−B1
⋯
B
B1
B2
B3
B4
B5
B6
⋯
add	B1
B2−B1
B3−B1
B4−B2
-	-	⋯
And so on...
So we iterate from left to right and at every index u
, we "add" (Bu−
 current value of Au)
 at i=u
. The final answer will be summation of absolute value of these values (i.e. the values written in the "add" row).

However, in the original problem, we have to solve the problem for multiple values of B1
. So let us assume the value of B1
 to be equal to some variable, say x
. Let us try to use the same approach with the variable x
.

Initial arrays:
-	1	2	3	4	5	6	⋯
A
0
0
0
0
0
0
⋯
B
x
B2
B3
B4
B5
B6
⋯
add	-	-	-	-	-	-	⋯
At u=1
: We "add" x
 at i=1
. Resulting arrays:
-	1	2	3	4	5	6	⋯
A
x
x
x
x
x
x
⋯
B
x
B2
B3
B4
B5
B6
⋯
add	x
-	-	-	-	-	⋯
At u=2
: We "add" B2−x
 at i=2
. Resulting arrays:
-	1	2	3	4	5	6	⋯
A
x
B2
x
B2
x
B2
⋯
B
x
B2
B3
B4
B5
B6
⋯
add	x
B2−x
-	-	-	-	⋯
At u=3
: We "add" B3−x
 at i=3
. Resulting arrays:
-	1	2	3	4	5	6	⋯
A
x
B2
B3
B2
x
B3+B2−x
⋯
B
x
B2
B3
B4
B5
B6
⋯
add	x
B2−x
B3−x
-	-	-	⋯
At u=4
: We "add" B4−B2
 at i=4
. Resulting arrays:
-	1	2	3	4	5	6	⋯
A
x
B2
B3
B4
x
B3+B2−x
⋯
B
x
B2
B3
B4
B5
B6
⋯
add	x
B2−x
B3−x
B4−B2
-	-	⋯
And so on...
Every cell in the "add" row here will be of the form: c⋅x+d
. The final answer will be the summation of absolute values of these values written in the "add" row.

Also we know,

|c⋅x+d|={c⋅x+d−(c⋅x+d)x≥−dcx<−dc
Note that the above equalities hold only when c>0
. So if c
 is negative in any term, then we can multiply the entire term with −1
 to make it positive since |c⋅x+d|=|−c⋅x−d|
.

Now, we can store the values of −dc
 for each index in sorted order. And for each query, we can find out, using binary search, which of the absolute value terms will have a positive sign and which of those will have a negative sign. So we can finally calculate the answer using prefix and suffix sums.

Bonus: It turns out that the value of coefficient of x
 in the "add" value for the u
-th index is cu=μ(u)
 where μ
 is the mobious function. So −1≤cu≤1
.

Time Complexity: O(nlogn+qlogn)
⋯
Solution [c++] (JeevanJyot)
1605F - PalindORme

Authored by ExplodingFreeze and antontrygubO_o and prepared by ExplodingFreeze.

Hint 1
Hint 2
Hint 3
Hint 4
Hint 5
Solution
1605F - PalindORme
Solution Outline:
For any bad array, there is exactly one
 maximum even length good subsequence (possibly the empty subsequence).

It can be proven that there exists at most one element in the bad array that doesn't belong to this subsequence, but is a submask of its OR. If such an element exists, we add it to the subsequence. After performing this step if needed, we have a good subsequence of this bad array such that all other elements of this array have one or more bits active which aren't present anywhere in this subsequence. We will call this the "best" subsequence from now on. Clearly a bad array also has exactly one
 best subsequence.

By noting that the best subsequence is still a good array (place the extra element in the middle of the PalindORme of even length), we can use dp to count the number of bad arrays of length n
 with exactly k
 bits on in total using its best subsequence of length n′<n
 with exactly k′<k
 bits on in total in O(n4)
.

Full Editorial:
Let S
 be the multiset of elements of the initial array a1,a2,…,an
. We want to check if we can construct a PalindORme from these elements.

Out of the n
 conditions of the form b1
 |
 b2
 |
 …
 |
 bi=bn−i+1
 |
 …
 |
 bn−1
 |
 bn
, it intuitively makes sense to tackle them in increasing order of i
, so we will try to do that.

For i=1
, we want to find two elements x,y
 in S
 such that x=y
. We place these elements as b1
 and bn
 and erase them from S
.
For i=2
, we want to find two elements x,y
 in S
 such that b1
 |
 x
 =
 b1
 |
 y
. We place these elements as b2
 and bn−1
 and erase them from S
.
Generalizing, for any i
, we want to find two elements x,y
 in S
 such that b1
 |
 b2
 |
 …
 |
 bi−1
 |
 x
 =
 b1
 |
 b2
 |
 …
 |
 bi−1
 |
 y
. We place these elements as bi
 and bn+1−i
 and erase them from S
.
But what if there exists multiple pairs (x1,y1),(x2,y2),…(xk,yk)
 that satisfy the property in a given step, which do we take?

It is optimal to take any of them. Clearly if mask
 |
 xj
 = mask
 |
 yj
, then mask
 |
 z
 |
 xj
 = mask
 |
 z
 |
 yj
 is also true for any z
. So regardless of which of these pairs we take, all other pairs will remain good in future steps.

So we obtain the following simple algorithm to check if a PalindORme is good:


mask = 0
good = true
while |S| > 1:
    if there exists any two elements x, y in S such that mask | x = mask | y
        mask = mask | x
        erase x and y from S
    else
        good = false
        break
end while
This algorithm is equivalent to placing elements at positions i
 and (n+1−i)
 of the PalindORme in the i
-th iteration of the loop. Taking any two elements is optimal since a pair that satisfies the property for mask
 will also clearly satisfy it for mask
 |
 x
.

Let us consider the multiset S
 corresponding to the elements of a bad array:

This algorithm will fail to find any such pair of elements after some number of steps.
The pairs which have been selected till this point will constitute a good array (possibly of length 0).
For the given bad array, the number of pairs taken as well as the bits on in the mask will always be the same when the algorithm fails regardless of the two elements selected in each step.
Since we cannot add any two more elements to this good array, this is the longest even length good subsequence of the bad array. Due to the previous point, we can also see that it is the only good subsequence of this length.
There can exist at most one element among the remaining elements not in the subsequence which is a submask of mask
, otherwise there would exist a pair such that mask
 |
 x
 =
 mask
 |
 y
 =
 mask
.
If such an element exists, we can add it to the subsequence. The best subsequence still remains a good array since we can place this element in the center position of resulting PalindORme.
After performing this step if needed, we have a good subsequence of this bad array such that all elements of this array not in the subsequence have one or more bits active which aren't on in mask
 and therefore not present in the subsequence. We will call this the "best" subsequence from now on. Clearly a bad array also has exactly one
 best subsequence (possibly of length 0).
So every bad array of length n
 with k
 bits on in total can be mapped to a best subsequence (which is a good array) with length n′<n
 with k′<k
 bits on in total. The remaining n−n′
 elements will then need to be chosen such that they have the remaining k−k′
 bits on in total while possessing distinct values when OR'd with mask
.

So we obtain a dp to count the number of bad arrays −
 cnt_badlength,bits on in total
, where cnt_badi,j=∑i′=0i−1∑j′=0j−1f(i,j,i′,j′)⋅(cnt_goodi′,j′)
.

Here f(i,j,i′,j′)
 is the number of bad arrays of length i
 with exactly j
 bits on in total, that have a good array of length i′<i
 with exactly j′<j
 bits on in total as their best subsequence.

Since the total number of arrays of length x
 with exactly y
 bits on in total can be easily calculated using some basic combinatorial formulas and inclusion exclusion, we can rewrite this as:

cnt_badi,j
 =
 ∑i′=0i−1∑j′=0j−1f(i,j,i′,j′)⋅(cnt_totali′,j′−cnt_badi′,j′)

giving us a dp with O(n2)
 states and O(n4)
 transitions.

f(i,j,i′,j′)
 is made of the following components:

The number of ways of placing the best subsequence in the bad array.
Since there are no values in common between the best subsequence and the remaining values of the array, the answer is just (nn′)
.
The number of ways of choosing which j′
 of the j
 bits were from the good array.
All ways are possible, so it is just (jj′)
The number of different arrays of length i−i′
 with the remaining j−j′
 bits set in total such that each element has one or more of the j−j′
 bits set and all elements have distinct values when OR'd with mask
, i.e, the remaining j
 bits.
We can observe that the second can be broken into the product of two easier parts:
The number of different arrays of i−i′
 distinct positive numbers with exactly j−j′
 bits set in total. We can first find the number of ways of permuting i−i′
 positive numbers with up to
 k
 bits set in total as 2k−1Pi−i′
. Then we just need to perform simple inclusion-exclusion to get the answer for exactly k
 bits set in total.
The number of ways of setting the remaining j′
 bits for these numbers. Since mask
 is effectively the OR of all elements in the good array, all the j′
 bits are already set in mask
. So any setting of these j′
 bits for these numbers doesn't doesn't affect the values when OR'd with mask
. So the number of ways is just 2(i−i′)⋅(j′)
.
Since these three components are independent of each other, f(i,j,i′,j′)
 is just the product of them.

However, as you may have observed, the "bad" arrays counted by this dp doesn't line up with the actual definition of bad arrays in one case - When a "bad" array has an even length best subsequence and a single remaining element with one or more bits that aren't set in this subsequence. This is clearly a good array but is counted as bad by our dp. (Example: good array [1, 1] combined with remaining element array [2] resulting in [1, 2, 1] (or [1, 1, 2] / [2, 1, 1]) which is clearly a good array but is counted as bad by our dp.)

This is however necessary since this is the only type of good array that is never the best subsequence of any bad array. Counting it as a good array in our dp would lead to overcounting when it was used as a best subsequence.

But then how do we then recover the correct number of actual bad arrays of length n
 with exactly j
 bits set? We can notice that this case occurs for best subsequences of length i−1
 when i
 is odd. So when counting the number of bad arrays of length n
 we can just skip best subsequences of length n−1
 if n
 is odd. Since n
 is the largest array size we are concerned with, good arrays of size n
 will never be a best subsequence of a larger bad array and as such won't lead to overcounting.

As a final note, remember that we have the number of bad arrays for n
 with exactly
 j
 bits set while we need the number of bad arrays with up to
 j
 bits set. This can be easily obtained by multiplying the answer for a given j
 with the number of ways of choosing j
 of the k
 bits and summing these values up for each j
. In short, we want ∑kj=0(kj)⋅cnt_goodn,j
.

Time Complexity: O(n4)
⋯
Solution [c++] (ExplodingFreeze)
Solution [c++] (antontrygubO_o)
Solution [Kotlin] (ExplodingFreeze)

Codeforces Round #753 (Div. 3) Editorial

By doreshnikov, history, 16 months ago, In EnglishShort informationSorry for another delayed editorial, I know I promised that it will come out sooner the previous time, but I wasn't feeling well today, so the work was slower than usual.

About problem F:

I am once again sorry for the inconveniences caused by tight ML in this problem. It was not the intended behavior since we relied too much on the main solution and didn't assume most of the solutions using DFS will fail. In this editorial I attach the code of the main solution that we expected from the beginning, it uses ~75MB of memory.

I guess, Div. 3 Rounds are not only for participants to learn but also can serve as educational for authors as well. I'll try not to repeat the same mistakes the next time :) Thanks to everyone for participating and hope to see you again!

The editorial1607A - Linear Keyboard

Idea: doreshnikov, MikeMirzayanov

Tutorial1607A - Linear KeyboardSince it does not take time to place your hand over the first letter, you need to calculate the sum of the distances between the keyboard keys corresponding to each pair of adjacent letters of the word, that is∑i=2n|pos(si)−pos(si−1)|where pos(c) is the position of the keyboard key corresponding to the letter c.

In order to calculate this sum, let's just iterate through the word s with the for loop and find the differences between the positions of si and si−1 on the keyboard.

To find the position of a character on the keyboard, you could either use the built-in strings functions (such as str.index in Python or string::find in C++) or precalculate each letter's position on the keyboard into a separate array using another loop over a keyboard.

Solution1607B - Odd Grasshopper

Idea: doreshnikov

Tutorial1607B - Odd GrasshopperConsider the first four actions that the grasshopper will perform, starting at a point with coordinate 0:

coordinate 0 is even, jumping left to 1 leads to −1coordinate −1 is odd, jumping right to 2 leads to 2coordinate 1 is odd, jumping right to 3 leads to 4coordinate 4 is even, jumping left to 4 leads to 0If you look closely at the next four jumps, they follow the same pattern: jump to the left, two jumps to the right, jump to the left. In general, making jumps with numbers 4k+1…4k+4, the grasshopper will start from coordinate 0 and move as0⟶ −(4k+1)−(4k+1)⟶ +(4k+2)1⟶ +(4k+3)4k+4⟶ −(4k+4)0Thus, if x0 were always zero, the answer would be

−n if n≡1mod41 if n≡2mod4n+1 if n≡3mod40 if n is divisible by 4Let's find an answer for the cases when x0≠0. But if x0 is even, then all steps will follow the same directions, and the answer will be x0+D, where D is the answer for the same n and starting point 0 (described above). And if x0 is odd, then all steps will have opposite directions, and the answer will be x0−D.

Solution1607C - Minimum Extraction

Idea: doreshnikov

Tutorial1607C - Minimum ExtractionNote that the order of numbers in the array does not affect anything. If you swap two elements in the original array, the set of elements at each step will not change in any way. Let's sort the original array a and denote it by a0.

We denote by ai the state of array a0 after applying i operations of minimum extraction. The minimum element in a0 is a01, so the elements of array a1 will be equal to a1i=a0i+1−a01, and therefore the minimum of them will be a02−a01.

Constructing an array a2, we can notice that its elements are equal to a2i=a1i+1−a11. We know that the elements of a1 are the difference between corresponding elements of the array a0 and a01, soa2i=a1i+1−a11=(a0i+2−a01)−(a02−a01)=a0i+2−a02Thus, the elements of the array a2 are the differences between elements of a0 starting with third and a02, the minimum of which is a03−a02. It is not difficult to show in a similar way (for example by induction) that the elements of ac are equal to aci=a0i+c−a0c, the minimum of which is a0c+1−a0c.

So the "candidates" for the answer are simply differences of adjacent elements of the array a0. Indeed, if we look at a0=[1,4,6,12,13], it will undergo changes as follows: [1,4,6,12,15]→[3,5,11,14]→[2,8,11]→[6,9]→[3]. You can notice that the minimum elements starting with after the first operation are exactly 4−1, 6−4, 12−6 and 15−12, respectively.

Thus, to solve the problem, it was sufficient to sort the array in ascending order, then take the maximum of the original first element and the differences of all adjacent elementsmax(a01,maxi=2n(a0i−a0i−1))Solution1607D - Blue-Red Permutation

Idea: MikeMirzayanov

Tutorial1607D - Blue-Red PermutationNote the following fact: if a number x in a permutation was obtained from a blue number and a number y in a permutation was obtained from a red number, and x>y, then by decreasing the blue number and increasing the red number exactly x−y times each, we will obtain the same permutation in which the two numbers have swapped places. Thus, if a permutation can be obtained at all, some permutation can be obtained by making all the red numbers equal to n,n−1,…,n−k+1, and the blue ones equal to 1,2,…,n−k, where k is the total count of red numbers.

Now consider separately two red numbers ai and aj such that ai>aj. If x is produced by increasing ai and y is produced by increasing aj, and in the same time x<y then y>x⩾ai>aj, and the following is also true: x>aj and y>ai. So we just showed that if an answer exists, it also exists if greater numbers are produced by greater values from the input. The same holds for the blue numbers.

Let us sort all elements ai by the key (ci,ai), where ci the color of i-th element (and blue comes before red). It remains to check that for any t from 1 to n we can get the number t from the t-th element of the obtained sorted array. To do this, we iterate through it and check that either ct='B' and at⩾t so it can be reduced to t, or, symmetrically, ct='R' and at⩽t.

Solution1607E - Robot on the Board 1

Idea: MikeMirzayanov

Tutorial1607E - Robot on the Board 1Let's look at the answer (r,c). Let's see how many commands the robot can execute. Since the robot breaks as soon as goes outside the field, if any command causes it to break, it either leads to its total shift relative to (r,c) of exactly c to the left or exactly m−c+1 to the right, or, similarly, of exactly r up or exactly n−r+1 down.

Denote by d[↔] and d[↕] the sum of the maximum positive (right, down) and maximum negative (left, up) shifts in the corresponding direction. By adding up the above constraints, we get the fact that the robot will not fall off the board only if d[↔]⩽(c−1)+((m−c+1)−1)=m−1 and d[↕]⩽(r−1)+((n−r+1)−1)=n−1.

Note that the reverse is also true: if both these conditions are satisfied, then starting from the point (max[←]+1,max[↑]+1) where max[dir] is the maximum shift along the direction dir, the robot will not pass any of the board's edges. Thus, it is sufficient to find the number of commands which, when executed, hold the following invariant:d[↔]⩽m−1∧d[↕]⩽n−1The horizontal shift can be calculated as the difference between the number of letters 'R' and the number of letters 'L' encountered. Similarly, the vertical shift — as the difference of the numbers of 'D' and 'U'. Let's iterate over the sequence of commands, maintaining relevant values of max[dir] for all dir∈[←,→,↑,↓]. After executing each command, if the robot goes farther in some direction than ever before, we update the corresponding max.

Either we reach the end of s, or we meet a command after which either d[↔]=max[←]+max[→] becomes equal to m, or d[↕]=max[↑]+max[↓] becomes equal to n and the robot breaks, so the previous command was the last one successfully executed. The possible answer is (max[←]+1,max[↑]+1), where the max values are calculated one command before the robot broke.

Solution1607F - Robot on the Board 2

Idea: doreshnikov

Tutorial1607F - Robot on the Board 2Let's start moving from an arbitrary cell of the table, for example, from (1,1). Movement from each cell is specified by the direction given in that cell, so you can run a loop with a stopping condition "exit from the board border or get to the already visited cell". Create a separate array d[r][c] — how many commands the robot will execute, starting the movement from the cell (r,c); we will also use it to check whether the cell has already been visited or not (not visited if d[r][c] is not yet positive).

Finishing the movement from (1,1) let's consider two cases.

Either we have gone beyond the boundary of the array, then we can say for sure that for the i-th cell from the end of the sequence (ri,ci) the answer is d[ri][ci]=i.Or we came to the already visited cell, let it be the t-th from the end in our path. Then at the end of the path, there is a cycle of length t: starting the movement at any cell of this cycle, the robot will walk exactly t steps until it arrives at the already visited cell. Thus, for i⩽t distance will be equal to d[ri][ci]=t, and for all others it will be, as in the first case, d[ri][ci]=i.Let us run the same algorithm from the next cell, which we have not yet considered. There will be three cases of robot stopping the execution of the commands: the first two repeat those already considered above, and the third case is that the robot will come to the cell (r0,c0) already visited on some of the previous iterations of our algorithm. In this case we know that starting from (r0,c0), the robot will make exactly d[r0][c0] steps, so for the i-th cell from the end on the current path d[ri][ci]=d[r0][c0]+i will hold.

The first two cases are handled completely in the same way as described above. Each of the cases is eventually reduced to another iteration over the cells visited in the current path. Let's visit all the cells in reverse and mark all values of d.

Such algorithm is enough to repeat until each cell is processed, after which for each cell of the table its d will be known and we'll only have to choose the maximal value of d[r][c] among all (r,c).

Solution1607G - Banquet Preparations 1

Idea: doreshnikov

Tutorial1607G - Banquet Preparations 1Let's find how much meat and fish a taster can eat at most. Note that a taster can eat no more than min(ai,m) of fish from the i-th dish (since he can't eat more than m or more than there is at all). Similarly, he can eat no more than min(bi,m) of meat. Let's sum the obtained values over all i and denote the resulting sums by A and B —the maximum total amount of fish and meat that can be eaten.

Let's denote by balance* T the value ∑i=1nai−∑i=1nbi, that is the balance without module. If the taster eats as much fish as possible, he will eat A of fish and nm−A of meat, and change the balance* by −A+(nm−A)=nm−2A. Similarly, if he eats the maximum amount of meat, the balance* will change by 2B−nm. Note that the taster can achieve any balance* between 2B−nm and nm−2A of the same oddity as both of these numbers. To do this, just take the way of eating the maximum fish and substitute eating a gram of fish for a gram of meat several times.

Thus, the final balance Tres can be found as min|x| over all x between T+(2B−nm) and T+(nm−2A) with same oddity. To do this, just check the boundaries of the resulting segment — if they have the same sign, then it's the boundary with the smallest absolute value, otherwise we can take one of the numbers −1, 0, 1 present in said set (depending on the parity of nm).

All that remains is to find how much of what type to eat from each dish. Having obtained the answer in the previous paragraph (the final balance), we can reconstruct how much fish and how much meat the taster has to eat to achieve it. The expected amount of fish to be eaten can be found as eA=T+nm−Tres2.

Note that the taster must eat max(m−bi,0) of fish from the i-th dish, since if meat bi<m, then at least m−bi of fish is guaranteed to be eaten. Let's break down eA into the sum of nm−B (how much total fish will have to be eaten anyway) and the remaining value gA=eA−(nm−B). Let's go through all the dishes and collect the first summand as just the sum of max(m−bi,0) over all i, and the second summand with greedy algorithm, each time giving the taster as much fish beyond what he must eat anyway until the sum of such "additions" reaches gA. And knowing for each dish how much fish will be eaten from it, the amount of meat eaten can be calculated by subtracting the fish eaten from m.

Solution1607H - Banquet Preparations 2

Idea: MikeMirzayanov

Tutorial1607H - Banquet Preparations 2Note that dishes can become equal if and only if they have equal values of ai+bi−mi, that is, how much fish and meat remain in them in total after "tasting". Let's calculate this value for each dish and group all the dishes with equal calculated values.

The minimum amount of fish that can remain in the i-th dish is amini=max(0,ai−mi) in case where the maximum possible mass of fish is eaten. Similarly, the maximum amount of fish that can remain is amaxi=ai+min(0,bi−mi) in case where the maximum possible mass of meat is eaten.

Consider one of the groups g in which there are all the dishes with equal values G=ai+bi−mi. We sill assign each dish a corresponding segment on the coordinate line between amini and amaxi. This segment specifies all possible values of the remaining mass of fish in the dish; any value on it is achievable by replacing eating some mass of fish with the same mass of meat. And since G is common, the same amount of remaining fish will imply the same amount of remaining meat, thus, equality.

Let us solve the problem for each group independently. Within a group, the problem is reduced to choosing as few points as possible that "cover" all the segments described in the last paragraph (that is, that there should be a point inside each segment). Each selected point will correspond to the resulting dish, and it being inside a segment will mean that such a resulting dish can be obtained from the corresponding starting one. Such a problem is solved as follows:

we choose a segment with the minimal right end; because it must contain at least one chosen point we'll greedily choose it equal to its right end;there's no point in choosing a point to the left from it, since it will not cover more segments than the right end of the segment in question;we'll mark all segments containing this point as covered, and repeat the algorithm for the next unprocessed segment with the minimal right end.For this algorithm, it is sufficient to sort the segments by their right ends within each group and iterate through the segments, greedily selecting points in the manner described above. The set of points obtained at the end will be the answer, and its size and the information about the point selected within each segment should be printed in the output. If for a dish (ai,bi,mi) a point x is chosen inside its corresponding segment, then there should be exactly x of fish left in it, that is, you should output the numbers ai−x and mi−(ai−x) in the answer.

Solution

Editorial of Codeforces Round #752

By YouKn0wWho, 16 months ago, In EnglishThanks for participating in my contest blobheart. I hope you liked the problems. I would love to hear your feedback in the comments.

If you find anything wrong in the editorial which is more likely to happen because I have written a rather long editorial to make you understand the solutions better, then comment below.

Also, don't forget to upvote to pay for the editorial. See you in my next contest!

1604A - EraIf ai>i for some position i, then we need to insert at least ai−i new small elements before this position. Let m=max(0,maxi=1n(ai−i)). So we need at least m operations. But its not hard to see that m operations are enough. For example, you can insert m 1s at the beginning of the sequence. This way, all elements will be shifted by m positions, and consequently, will satisfy that ai≤i for each valid i.

Code1604B - XOR Specia-LIS-tWhat happens if we split the sequence into subarrays of length 1?.

Yes, if n is even, the bitwise XOR will be 0 as there will be an even number of 1s.

If n is odd we can't do the same. But what if there is an index i such that ai≥ai+1?

What if we use these two indices as a single subarray as it has LIS of length 1 and take other indices as single subarrays? Yeah, again, there will be an even number of 1s which will yield a bitwise XOR of 0.

What we are left with are strictly increasing sequences of odd lengths. Notice that any subarray of length l has LIS of length l here. So we need to find a sequence b1,b2,…,bk such that b1+b2+…+bk=n and b1⊕b2⊕…⊕bk=0 where n is odd. Is it possible to find such a sequence? Pause and think.

Hint: think about the last bit of each bi.

If XOR is 0, then there will be an even number of bis such that its last bit is 1. But then the sum will be even. But here the sum n is odd, which produces a contradiction.

So in the last case, it is not possible to find such a split.

Code1603A - Di-visible ConfusionNotice that we can erase ai at positions from 1 to i. So for each i, there should be at least one integer from 2 to i+1 such that ai is not divisible by that integer. If it is not satisfied for some integer i, then there is no solution for sure. Otherwise, it turns out that a solution always exists.

Why?

We can prove it by induction. Let's say it is possible to erase the prefix containing n−1 elements. As an can be erased at some position from 1 to n(let's say k), then while erasing the prefix of n−1 elements, when the prefix contains k−1 elements, then an is at the k-th position, so we can erase it at that position and erase the rest of the sequence accordingly.

So we just have to check for all integers i from 1 to n, if ai is not divisible by at least one integer from 2 to i+1. Notice that if ai is divisible by all integers from 2 to i+1, then it means that ai is divisible by LCM(2,3,…,(i+1)). But when i=22, LCM(2,3,…,23)>109>ai. So for i≥22, there will always be an integer from 2 to i+1 which doesn't divide ai. So we don't have to check for them. For i<22, use bruteforce.

Complexity: O(n+212).

Code1603B - Moderate Modular ModeIf x>y, then x+y works, as (x+y)modx=ymodx=y and ymod(x+y)=y.

The challenge arrives when x≤y. The later part of the editorial assumes that x≤y.

Claim 1: n can't be less than x.

Proof: Assume that for some n<x, nmodx=ymodn is satisfied. Then nmodx=n but ymodn<n. So nmodx can't be equal to ymodn which is a contradiction.

Claim 2: n can't be greater than y.

Proof: Assume that for some n>y, nmodx=ymodn is satisfied. Then nmodx<x but ymodn=y≥x. So nmodx can't be equal to ymodn which is a contradiction.

So n should be in between x and y. But what is the exact value of n? Let's solve this intuitively.

Consider a line on the X axis. Imagine you are at position 0. You will start jumping from 0 to y with a step of length x. So there will be a position from where if you jump one more time it will exceed y. This position is p=y−ymodx. From this position let's go to y in exactly 2 steps! Notice that y−p is guaranteed to be even as x and y both are even. So we need to jump with a length of y−p2 and we will jump to the position t=p+y−p2. And voila! t is our desired n because tmodx=y−p2 and ymodt=(y−p)−y−p2=y−p2. To be precise, n=t=y−ymodx2.

Here is a cute illustration for you:

Code1603C - Extreme ExtensionLet's find out how to calculate the extreme value of an array a of n integers. It turns out that a greedy solution exists!

Consider the rightmost index i such that ai>ai+1. So we must split ai into new (let's say k) elements 1≤b1≤b2≤…≤bk≤ai+1 such that b1+b2+…+bk=ai . Notice that k≥⌈aiai+1⌉ because bk≤ai+1. But it is always optimal to make b1 as large as possible. It is not hard to see that the smaller the k, the bigger the b1 we can achieve. So let's set k=⌈aiai+1⌉. Now, notice that b1≤⌊aik⌋. So let's set b1=⌊aik⌋=⌊ai⌈aiai+1⌉⌋. So we have performed k−1=⌈aiai+1⌉−1 operations and will solve the problem analogously for the previous indices after replacing ai by [b1,b2,…,bk].

To sum it all up, we can calculate the extreme value in the following procedure:

Iterator from i=n−1 to 1.Add ⌈aiai+1⌉−1 to the answer.Set ai=⌊ai⌈aiai+1⌉⌋.Pretty elegant! Let's call it elegant procedure from now on.

So we can calculate the extreme value of an array of n integers in O(n).

To solve it for all subarrays in O(n2), we need to fix a prefix and solve each suffix of this prefix in a total of O(n) operations. We can do that easily because the procedure to calculate the extreme values starts from the end, so we can sum up the contributions on the run.

How to solve the problem faster?

Think dp.

Let dp(i,x) be the count of subarrays a[i;j] such that i≤j and after the elegant procedure x becomes the first element of the final version of that subarray.

We only care about the xs for which dp(i,x) is non-zero. How many different x is possible?

Well, it can be up to 105, right?

Wrong!

Let's go back to our elegant procedure once again. For the time being, let's say for all x=1 to 105, dp(i+1,x) is non-zero. So for each x, we will add dp(i+1,x) to dp(i,⌊ai⌈aix⌉⌋).

But there can be at most 2m−−√ distinct values in the sequence ⌊m1⌋,⌊m2⌋,…,⌊mm⌋. Check this for a proof.

So there can be O(105−−−√) distinct xs for which dp(i,x) is non-zero. So we can solve this dp in O(n⋅105−−−√). To optimize the space-complexity we can observe that we only need the dp values of i+1. So we can use only two arrays to maintain everything. Check my solution for more clarity.

To get the final answer, we will use the contribution technique. To be precise, for each (i+1,x) we will add i⋅dp(i+1,x)⋅(⌈aiai+1⌉−1) to our answer and its not hard to see this. Here, i⋅dp(i+1,x) is the number of arrays where the i-th element will be set to x in the elegant procedure and ⌈aiai+1⌉−1 is the number of operations that will be performed for the same.

Overall time complexity will be O(n⋅105−−−√) and space complexity will be O(n).

Code1603D - Artistic PartitionFor now, let c(l,r) denote the number of integer pairs (i,j) such that l≤i<j≤r (instead of i≤j) and gcd(i,j)≥l. So we can add n to f(n,k) in the end.

We can construct a straightforward dp where f(n,k)=mini=1n(f(i−1,k−1)+c(i,n)). As a straightforward implementation of c(l,r) takes O(n2log2n) time, the total complexity of finding f(n,k) will be O(n5log2n) which is quite shameful.

Let's see how to do better.

Tiny Observation: c(x,2⋅x−1)=0. It's easy to see why it holds.

Cute Observation: f(n,k)=0 when k>log2n.

Proof: Let L=log2n. Following the tiny observation, we can split the numbers as [1,1],[2,3],[4,7],…,[2L−1,2L−1],[2L,n] without spending a single penny.

Now we can solve f(n,k) in O(n4log22n) which is still shameful.

So we just have to find f(n,k) for 1≤n≤105 and 1≤k≤17.

Let's optimize the calculation for c(l,r) .

c(l,r)=∑i=lr∑j=i+1r[gcd(i,j)≥l]=∑k=lr∑i=lr∑j=i+1r[gcd(i,j)=k]=∑k=lr∑i=l,k|ir∑j=i+1,k|jr[gcd(i,j)=k]=∑k=lr∑i=1⌊rk⌋∑j=i+1⌊rk⌋[gcd(i⋅k,j⋅k)=k]=∑k=lr∑i=1⌊rk⌋∑j=i+1⌊rk⌋[gcd(i,j)=1]=∑k=lr∑i=1⌊rk⌋ϕ(i)=∑k=lrp(⌊rk⌋)Here, p(x)=∑i=1xϕ(i). We can calculate p(x) for all x≤n in O(nlog2n) and calculate c(l,r) in O(n). So currently we can solve our problem in O(n3) which is still not to be proud of.

But notice that there can be at most 2m−−√ distinct values in the sequence ⌊m1⌋,⌊m2⌋,…,⌊mm⌋. Check this for a proof. So we can calculate c(l,r) in O(n−−√) which improves our solution to O(n2n−−√).

But notice that as c(l,r)=∑k=lrp(⌊rk⌋) we can precalculate the suffix sums for each r=1 to n over all distinct values of ⌊rk⌋ and then calculate c(l,r) in O(1). This preprocessing will take O(nn−−√) time and O(nn−−√) memory. That means we can solve our problem O(n2+nn−−√) which is promising.

Critical Observation: c(l,r) satisfies quadrangle inequality, that is c(i,k)+c(j,l)≤c(i,l)+c(j,k) for i≤j≤k≤l.

Proof: Let f(i,j,r)=∑k=ijp(⌊rk⌋). Here,c(i,l)+c(j,k)=f(i,l,l)+f(j,k,k)=(f(i,j−1,l)+f(j,l,l))+(f(i,k,k)−f(i,j−1,k))=f(i,j−1,l)+c(j,l)+c(i,k)−f(i,j−1,k)=c(i,k)+c(j,l)+f(i,j−1,l)−f(i,j−1,k)But clearly f(i,j−1,l)≥f(i,j−1,k) as l≥k. So c(i,k)+c(j,l)≤c(i,l)+c(j,k).

You can learn more about quadrangle inequality and how it is useful from here. Read it because I won't describe why it helps us here.

This suggests that we can solve this problem using Divide and Conquer DP or 1D1D DP which will optimize our O(n2) part to O(nlog22n).

To solve for multiple queries we can just precalculate f(n,k) for 1≤n≤105 and 1≤k≤17.

Overall complexity: O(nlog22n+nn−−√) where n=105.

This problem can also be solved using Divide and Conquer DP and by calculating c(l,r) in O(r−l−−−−√) in each level which runs pretty fast in practice (for n=5⋅105, it takes less than 3s) but I don't have a rigorous upper bound on the time complexity. Check out my solution for more clarity.

Code (1D1D DP)Code (D&C DP)1603E - A Perfect ProblemLet's go deeper into the properties of perfect sequences.

Observation 1: If a sorted sequence a1,a2,…,an is perfect then all its permutations are also perfect.

Actually, it's very easy to see that as the order doesn't matter. So we will work on the sorted version of the sequence.

Observation 2: The sorted sequence a1,a2,…,an is perfect iff all its subarrays are good.

Proof: Let's fix the min and max of a subsequence. As min⋅max is fixed, the worst case happens when we insert as many elements as possible in this subsequence which are in between min and max as we are comparing min⋅max with the sum, and the worst case is a subarray of this sorted sequence!

Now we will go one step further.

Observation 3: The sorted sequence a1,a2,…,an is perfect iff all its prefixes are good.

Proof: The condition essentially means that a1⋅ai≥a1+a2+…+ai for all 1≤i≤n. Imagine that its true. Now we will prove that the sequence is perfect. Consider a subarray [i;j]. ai⋅aj≥a1⋅aj ≥a1+a2+…+aj ≥ai+ai+1+…+aj. That means all subarrays are good. And following observation 2, it indicates that the sequence is perfect. And it is necessary that all the prefixes should be good because they are subarrays after all which proves the iff condition.

Now let's exploit the fact that all ai are ≤n+1.

Let's remind again that we are considering the sorted sequences for now.

Observation 4: ak≥k is required for any k.

Proof: If ak<k, a1+a2+…+ak≥a1+a1+…+a1≥a1⋅k>a1⋅ak (as k>ak) which violates the good condition.

Observation 5: If ak=k, then all ai=k for i≤k.

Proof: a1⋅ak=a1⋅k≥a1+a2+…+ak. This means (a1−a1)+(a2−a1)+…+(ak−a1)≤0. But as all ai≥a1, this can only happen when all ai=a1. But as ak=k, consequently, all ai should be k.

So an can be either n or n+1. If an=n then according to observation 5 there is only one such sequence. From now on, let's consider an=n+1.

So a1⋅(n+1)≥a1+a2+…an. But this formulation is a bit hard to work on. So now we will make a move which I would like to call a programmer move. That is, the equation is equivalent to (a1−a1)+(a2−a1)+…+(an−a1)≤a1.

Following observation 3, its necessary that a1⋅ai≥a1+a2+…+ai for all i.

Observation 6: if an=n+1 and ai≥i+1, then the prefix a1,a2,…,ai is automatically good if the whole sorted sequence a1,a2,…,an is good.

Proof: If the whole sequence is good then, (a1−a1)+(a2−a1)+…+(an−a1)≤a1. Now, (a1−a1)+(a2−a1)+…+(ai−a1)≤(a1−a1)+(a2−a1)+…+(an−a1)≤a1. So, a1+a2+…+ai≤a1⋅(i+1)≤a1⋅ai So the prefix is good!

Let's recap that ai≥i is required(observation 4), if ai≥i+1, then a1,a2,…,ai is automatically good (observation 6) and ai=i is only possible when i=a1(observation 5).

So the necessary and sufficient conditions for the sorted sequence a to be perfect assuming an=n+1 are -

For i≤a1, a1≤ai≤n+1For i>a1, i+1≤ai≤n+1(a1−a1)+(a2−a1)+…+(an−a1)≤a1Notice that we need the answer considering all such sequences, not only sorted sequences, but it is not hard to track that using basic combinatorics. So let's fix the smallest number a1 and subtract a1 from everything. So we need to count the number of sequences b1,b2,…,bn such that -

0≤bi≤n+1−a1b1+b2+…bn≤a1There is at least 1 number ≥n+1−a1, at least 2 numbers ≥n−a1, …, at least n−a1 numbers ≥2 (this condition is basically the intuition of when i≤a1, a1≤ai≤n+1 and when i>a1, i+1≤ai≤n+1).Let's formulate a dp in top-down manner. We will choose bi going from n+1−a1 to 0. Let dp(i,sum,k)= number of sequences when we already chose i elements, the total sum of the selected elements =sum and we will select k now. So if we choose cnt numbers of k, then the transition is something like dp(i,sum,k) += dp(i+cnt,sum+cnt⋅k,k−1)cnt!. And at the base case, when i=n, return n!. The factorial terms are easy to make sense of because we are considering all perfect sequences, not only sorted ones. Check my solution for more clarity.

This dp will take O(n4⋅log2n) for each a1 (log2n term is for harmonic series sum as cnt≤a1k) yielding a total of O(n5⋅log2n).

Observation 7: If a1<n−2⋅n−−√, then no perfect sequences are possible.

Proof: Assume that a1<n−2⋅n−−√, or n−a1>2⋅n−−√, or n−a1>2⋅n−−√. But because of the condition 3, there will be at least at least 1 number ≥n−2⋅n−−√+2, at least 2 numbers ≥n−2⋅n−−√+1, …, at least n−2⋅n−−√+1 numbers ≥2. But that clearly means that b1+b2+…bn>n+1>a1 which is a contradiction.

So we need to traverse O(n−−√) a1s which also means in the dp k is also O(n−−√). So the total time complexity will be O(n3n−−√log2n) or faster but with very low constant that it will work instantly!

Phew, such a long editorial. I need to take a break and explore the world sometimes...

Code1603F - October 18, 2017Idea: [user:YouKn0wWho], [user:Alpha_Q], [user:antontrygubO_o]

Thanks to Anton for writing editorial for this problem.

When x=0, we need to count the number of sequences (a1,a2,…,an), such that the ais are linearly independent. Clearly, for n>k there are no such sequences, and for n≤k, the answer is (2k−1)⋅(2k−2)⋅…⋅(2k−2n−1), as ai can be any element not generated by the elements a1,a2,…,ai−1, and they generate exactly 2i−1 elements.

Now, let's deal with the case x>0. It's easy to see that the exact value of x doesn't matter here, it's easy to construct a bijection between such sequences for this problem and such sequences for the case x=1, by change of basis from the one which has x as the first element to one which has 1 as the first element. So from now on x=1.

We will show that the answer for given n,k is(2k)n⋅2k−1−(2k−1)n⋅(2k−1−1)⋅2k−2+(2k−2)n⋅(2k−1−1)(2k−2−1)⋅2k−3…More generally, it's

∑i=0k((−1)i⋅(2k−i)n⋅∏j=0i−1(2k−j−1−1)2k−i−1)This is easy to calculate in O(k+logn), by calculating prefix products Pi=∏i−1j=0(2k−j−1−1) in O(k), and finding 2n in O(logn) and its powers in O(k). Now, let's prove the formula.

It's possible to prove the formula by some inclusion-exclusion arguments, but here we will present a bit more combinatorial approach. Let's just look at (2k−i)n⋅∏i−1j=0(2k−j−1−1)2k−i−1 and find some combinatorial interpretation for it.

Let's consider a linear space of dimension t (with 2t elements), containing 1. Consider all its subspaces of dimension t−1. Firstly, how many of them are there? Exactly 2t−1, each corresponding to the only nonzero element of the orthogonal complement of the subspace. It's easy to see that exactly 2t−1−1 of them will contain 1, and other 2t−1 won't.

Then, there is a natural representation of the number ∏i−1j=0(2k−j−1−1)2k−i−1 — it's the number of sequences of spaces (S0,S1,S2,…,Si−1,Si), where:

S0 is the whole space of our problem, of dimension k,

For j from 1 to i−1, Sj is a subspace of Sj−1 of dimension k−j, containing 1.

Si is a subspace of Si−1 of dimension k−i, not containing 1.

Then, (2k−i)n⋅∏i−1j=0(2k−j−1−1)2k−i−1 is the number of sequences (S0,S1,S2,…,Si−1,Si,a), where sets S are described as above, and all elements of a lie in Si (as there are 2k−i ways to choose each of them).

This starts to resemble what we need... As in such structure, space generated by a won't be able to contain 1, and it's exactly the kind of arrays we are interested in.

So, we want to show that the actual number of arrays from the statement is equal to the number of tuples (S0,S1,S2,…,Si−1,Si,a), where the tuple is counted with a plus sign for even i and with a minus sign for odd i.

It's enough to prove that each array a will be counted exactly once this way (meaning that it will be in tuples taken with plus one more time than in tuples taken with a minus). Fine, let's consider an array a such that subspace spanned by it doesn't contain 1 and look at the sequences of sets (S0,S1,S2,…,Si−1,Si) such that a is contained in Si. If the subspace generated by a is T, we just need all spaces to contain T. If size of T is t, there is a bijection between such sequences and sequences (S0,S1,S2,…,Si−1,Si), where

S0 is the space orthogonal to subspace T, of dimension k−t,

For j from 1 to i−1, Sj is a subspace of Sj−1 of dimension k−t−j, containing 1.

Si is a subspace of Si−1 of dimension k−t−i, not containing 1.

But the number of such sequences for a fixed i is precisely ∏i−1j=0(2k−t−j−1−1)⋅2k−t−i−1! So, we need to show that the sum of this (with correspondent signs) over i from 0 to n−t is 1. Let's replace n−t by n, we need to show that∑i=0k((−1)i⋅2k−i−1⋅∏j=0i−1(2k−j−1−1))=1This is easy to prove by induction, as after moving 2k−1 to the right side it's equivalent to∑i=1k((−1)i⋅2k−i−1⋅∏j=0i−1(2k−j−1−1))=(1−2k−1), and we can cancel (1−2k−1) from both sides and get the same equation, but now for k−1.

Code

Codeforces Round #751 Editorial

By ch_egor, 17 months ago, translation, In EnglishThanks for the participation!

1602A - Two Subsequences was authored and prepared by napstablook

1602B - Divine Array was authored and prepared by Anti-Light

1601A - Array Elimination was authored and prepared by isaf27

1601B - Frog Traveler was authored and prepared by KiKoS

1601C - Optimal Insertion was authored and prepared by isaf27

1601D - Difficult Mountain was authored and prepared by Tikhon228

1601E - Phys Ed Online was authored by jury and prepared by fedoseev.timofey

1601F - Two Sorts was authored by cdkrot and prepared by cdkrot, LHiC

1602A - Two SubsequencesNote that taking a as minimum character in s is always optimal (a starts with minimum possible character and is prefix of any other longer string). In such case, b is just all characters from s except character from a.

1602B - Divine ArrayIt can be shown that after at most n steps of transformation, array a becomes repetitive. There is even a better lower bound: it can be shown that after at most log(n) steps a becomes repetitive, so we use either of these two facts to simulate the process and answer the queries.

1601A - Array EliminationLet's note, that in one destruction for any bit i (0≤i<30) we either change all k-th non-zero bits into zero bits, or nothing changes. So, the number of i-th non-zero bits in the array either decreases by k or doesn't change. In the end, all these numbers will be equal to 0. So, to be able to destruct the array, the number of i-th non-zero bits in the array should be divisible by k for all bits i.

Let's prove, that it is enough to destruct the array. Let's make operations with non-zero AND, while we can make them. In the end, there is at least one non-zero element, if we have not destructed the array. So, there is at least one bit i, for which the number of i-th non-zero bits in the array is non-zero, so this number is at least k (because it is divisible by k). So we can select k numbers with i-th non-zero bit to the next operation and make the new destruction, which is impossible.

So the resulting solution is: for each bit i (0≤i<30) let's find the number of array's elements with non-zero i-th bit. Let's find all common divisors k (1≤k≤n) of these numbers.

Time complexity is O(nlogC), where C=109  — upper limit on all numbers in the array.

1601B - Frog TravelerLet's denote sequence of moves i⇒i−ai⇢i−ai+bi−ai as jump.

We will use dpi — minimal number of moves needed to travel from i to 0.

It can be calculated dpi=1+min(dpj+bj), with i−ai≤j≤i. We expected calculations to use bfs-style order. So, if there is a jump to 0, dp is 1. If there is no jump to 0, but there is a jump to position with dp=1, then dp is 2, and so on.

What happens, when we know all dp's with values from 0 to d? We'll take position v (dpv=d) and all u with condition u+bu=v. Then all j that has j−aj≤u≤j we know for sure dpj=d+1. For every i we will save in minimum segment tree value i−ai. So, all j's are just elements from a suffix with value not greater than u.

We can iterate through all j's, because every of them is used only once — right after we know dpj, we can use any neutral value (infinity in our case).

Time complexity is O(nlogn)Bonus. Try to solve it in linear time :)

1601C - Optimal InsertionLet's sort array b.

Let's define pi as the index of the array a, before which we should insert bi. If bi should be inserted at the end of the array a, let's make pi=n+1.

Let's note, that all inserted elements should go in the sorted order in the optimal answer. If it is false and there exists pi>pj for i<j, let's swap bi and bj in the answer. The number of inversions will decrease, a contradiction.

So p1≤p2≤…≤pm. If we will find their values we will be able to restore an array after inserting elements.

Let's use "Divide and conquer" to find them. Let's write a recursive function solve(li,ri,lp,rp), that will find pi for all li≤i<ri, if it is known, that pi∈[lp,rp] for all such i. To find all values of p we should call the function solve(1,m+1,1,n+1).

Realization of solve(li,ri,lp,rp):

If li≥ri, we shouldn't do anything.Let mid=⌊li+ri2⌋. Let's find pmid. The number of inversions with bmid will be (the number of ai>bmid for i<pmid) + (the number of ai<bmid for i≥pmid). This sum differs by a constant from: (the number of ai>bmid for lp≤i<pmid) + (the number of ai<bmid for pmid≤i<rp). For this sum it is simple to find the minimal optimal pmid in O(rp−lp).Let's make two recursive calls of solve(li,mid−1,lp,pmid), solve(mid+1,ri,pmid,rp), that will find all remaining values of p.The complexity of this function will be O((n+m)logm), because there will be O(logm) levels of recursion and we will make O(n+m) operations on each of them.

In the end, using the values pi we will restore the array and find the number of inversions in it.

Total complexity: O((n+m)log(n+m)).

Also, there exist other correct solutions with the same complexity, using segment tree.

1601D - Difficult MountainFirst, discard all i such that si<dInstead of climbers, we will consider pairs (si,ai), and also say that the set of pairs is correct if there is a permutation p1…pn such that for every i:max(d,ap1,…api−1)≤spi, which means that there is an order in which all climbers can climb.

We will call a pair of indices i,j incompatible if i≠j and sj<ai and si<aj. - this means that the i-th climber cannot climb after the j-th and vice versa. Note that if the set does not have an incompatible pair of indices, then it is correct. The suitable order for pairs (si,ai) can be reached by sorting them in increasing order of pairs min(si,ai),max(si,ai). After sorting either i-th climber can go after (i−1)-th or the pair (i−1),i is incompatible.

 Let's solve the problem with an additional restriction first, namely: for each i:si<ai, In this case, you can use the following greedy solution:

Let D=d, find among the pairs (si,ai) such that D≤si, and among such pairs - the pair with the smallest ai - it will be the next in our order. Replace D by ai, increase the answer by 1 and repeat the algorithm. If the pair with D≤si does not exist, terminate the algorithm. The correctness of such an algorithm is proved by induction.

To effectively implement this solution, let's sort all the pairs (si,ai) in increasing order of aiLet's go through the indices i from 1 to n If D≤si, then add 1 to the answer and replace D with ai.

 Let's get back to the main problem:

Consider a pair of indices i,j such that si<aj≤sj<aiSuch a pair of indices is incompatible, and if the optimal answer contains i, then it can be replaced with j and the sequence will not break.

 si<sj⇒ for any value of D that matches i it matches j.  aj<ai⇒ for any D:max(D,aj)≤max(D,ai)Therefore, for any such pair i,j, the i-th can be excluded from the set of climbers and the answer will not worsen.

 To effectively remove all such (si,ai) pairs, we use the two-pointer method:

Let's take out all such pairs that ai≤si into the b array. Let the remaining pairs be in the c array. Let's sort the array b in increasing order of ai and the array c in increasing order of si. Let's create an ordered set M, which can store the pairs (si,ai) in decreasing order of ai. Let's create a pointer j=0.

Let's go through the elements of the b array with index i.

 For this item:

 While cj.s<bi.a we will add cj to the set M Now while bi.s<M1.a we will delete the first element M.

Among the elements of the b array, the M set and the remaining elements in the c array, there are no more required pairs.

Note that among the remaining pairs (si,ai), any pair of indices i,j such that ai≤si or aj≤sj is not incompatible.

Now, if we find the maximum correct subset of the pairs (si,ai), such that si<ai and combine it with the set of pairs (si,ai), such that ai≤si, we get the correct set, moreover, for obvious reasons – it has maximum size. Therefore, we will get the answer to the problem.

1601E - Phys Ed OnlineObserve that we need to buy a subscription at day one, then we need to buy the cheapest subscricption among first k+1 days, ..., then the cheapest among the first tk+1 days. Let's denote bi as a minimum on a segment [i−k,i−k+1,...,i], bi can be calculated in a linear time using monotonic queue. So the answer for query is al+bl+k+min(bl+k,bl+2k)+...+min(bl+k,bl+2k+...+bl+tk), where l+tk≤r.

Observe that such a sum is independent of the remainder of the division of l by k, so we can solve an easier problem instead: we are given with an array c, and we need to calculate a sum of prefix minimums on a segment. To solve this, let's calculate an array nxti — the minimum position nxti>i such that cnxti<ci. Let dpi be a sum of minimums on prefixes of i-th suffix. Observe that dpi=dpnxti+ci⋅(nxti−i). To calculate a sum of prefix minimums on the segment [l,r], find a position p, such that ap is a minimum on the segment [l,r], then the answer is dpl−dpp+(r−p+1)⋅cp.

So we have a solution in O(n+qα−1(n)), where α−1 is the inverse Ackermann function, if we use a Tarjan's algorithm for offline rmq. It was enough to use any logarithmic data structure to solve a problem.

1601F - Two SortsSuppose b is an inverse permutation of a, that is abi=bai=i, that is bi is an index of i in the lexicographical sorting. Rewrite desired sum replacing i→bi: ∑i=1…n((i−ai)modp)=∑i=1…n((bi−abi)modp)=∑i=1…n((bi−i)modp).

First, we need to understand how to calculate bi's. Observe that bi equals 1 plus number of integers x (1≤x≤n) so that x<lexi. These integers are of two possible kinds: own prefixes of i (the number of such x depends only on the length of i) and integers x having a common prefix with i of some length t and a smaller digit c in (t+1)-th index.

If we fix values of t, c, length of x, we have a "mask" of the following kind: "123???", and we are interested in the number of x matching this mask. This number almost always depends on the number of "?" with minor exceptions concerning n. E. g. consider n=123456 for the example above.

So in the desired sum, we group summands by the following markers of i (brute force the value of these markers):

Length of i,Position of first digit different in i and n (cases, where i is an own prefix of n, shall be considered separately).The value of this digit.So we know description of i of the following kind: i=c1c2…ckx1…xl¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯, where cj are fixed, and x1,…,xl are arbitrary integer variables in [0,9]. Observe that both bi and i are linear combination of variables xj and 1, so bi−i is also a linear combination of them. The only issue is computing bi−i modulo p.

To do summing over all x1,…,xl we use the meet-in-the-middle method: bruteforce separately the values for the first half and the second half, and then match one with another.

If n≤10L, the solution works in O(10L2poly(L)), or O(n−−√poly(logn)).

Codeforces Round #750 (Div.2) Editorial

By AlFlen, 16 months ago, translation, In English1582A - Luntik and Concerts

Idea: 74TrAkToR

Tutorial1582A - Luntik and ConcertsLet S be the sum of durations of all songs, that is S=a+2⋅b+3⋅c.

Let's notice that since a,b,c≥1, it is possible to make a concert of any duration from 0 to S (indeed, if we just execute a greedy algorithm and take three-minute songs while possible, then take two-minute songs, and then one-minute ones, we can get any duration we need).

Now, the answer is the remainder of S modulo 2, because if S is even, then it's possible to from the first concert with duration S2, and the second one will be left with duration S−S2=S2, and the difference between the durations will be 0. If S is odd, then the smallest possible difference is equal to 1, let's form the first concert with duration ⌊S2⌋, and the second one is left with duration ⌈S2⌉Solution (74TrAkToR)1582B - Luntik and Subsequences

Idea: AlFlen

Tutorial1582B - Luntik and SubsequencesIt can be noticed that all subsequences with sum s−1 appear if we erase some 0-es from the array and also erase exactly one 1. We can independently calculate the number of ways to erase some 0-es from the array (that way the sum will remain the same), then calculate the number of ways to erase exactly one 1 from the array (that way the sum will become equal to s−1), and then multiply these two numbers. Therefore, the answer is equal to 2c0⋅c1, where c0 is the number of 0-es in the array, and c1 is the number of 1-s.

Solution (74TrAkToR)1582C - Grandma Capa Knits a Scarf

Idea: AlFlen

Tutorial1582C - Grandma Capa Knits a ScarfLet's iterate over the letter that we will erase from the string (from 'a' to 'z'), and for each letter independently find the minimal number of erased symbols required to make the string a palindrome.

Let's say we are currently considering a letter c. Let's use the two pointers method: we will maintain two pointers l, r, initially l points at the beginning of the string, and r points at the end of the string. Now we will form a palindrome: each time we will compare sl and sr, if they are equal, then we can add both of them to the palindrome at corresponding positions and iterate to symbols l+1 and r−1. If sl≠sr, then we need to erase one of these symbols (otherwise, we won't get a palindrome), if sl=c, let's erase it (we'll add to the number of erased symbols 1 and iterate to l+1-th symbol), similarly, if sr=c, we'll add to the number of the erased symbols 1 and iterate to r−1-th symbol. And the last case, if sl≠c and sr≠c, then it's impossible to get a palindrome from s by erasing only letters equal to c.

The asymptotic behaviour of this solution is O(|C|⋅n), where |C| is the size of the alphabet, i.e. 26.

Solution (74TrAkToR)1582D - Vupsen, Pupsen and 0

Idea: AlFlen

Tutorial1582D - Vupsen, Pupsen and 0Let's consider two cases: when n is even, and when n is odd.

If n is even, let's split all numbers into pairs: let a1 and a2 be in one pair, a3 and a4 in one pair as well and so on. In the pair ai, ai+1, let bi=ai+1 and bi+1=−ai, then the sum ai⋅bi+ai+1⋅bi+1 in every pair will be equal to 0 (ai⋅ai+1+ai+1⋅(−ai)=0), so the overall sum a1⋅b1+a2⋅b2+…+an⋅bn will be equal to 0 as well. Notice that the sum of the |bi| is equal to the sum of |ai|, therefore the sum |b1|+|b2|+…+|bn| does not exceed MAXA⋅MAXN=109.

If n is odd, then let's cut off the last 3 numbers and calculate b for the array a1,a2,…,an−3 the way we did it for even n (n−3 is even since n is odd). Then for the last 3 numbers an−2,an−1,an let's find two numbers with sum not equal to 0 (by the Dirichlet principle, there will always exist two numbers out of three not equal to 0, which are both positive or both negative, and the sum of those two numbers cannot be equal to 0), let them be ai, aj, and the third one ak. Then let bi=−ak, bj=−ak, bk=(ai+aj), the sum of ai⋅bi+aj⋅bj+ak⋅bk=0, and numbers of b are not equal to 0. The sum |b1|+|b2|+…+|bn−3| does not exceed MAXA⋅(MAXN−1−3) (since MAXN is even, and we consider a case with odd n) and the sum bn−2+bn−1+bn does not exceed MAXA+MAXA+2⋅MAXA=4⋅MAXA, so the overall sum of |bi| does not exceed MAXA⋅MAXN=109.

Solution (AlFlen)1582E - Pchelyonok and Segments

Idea: 74TrAkToR

Tutorial1582E - Pchelyonok and SegmentsLet's notice that k can be the answer, only if the sum of lengths of the segments does not exceed the number of elements in the array, that is k⋅(k+1)2≤n. From this inequation we can get that k is less than 2n−−√, and when n hits its maximal value, it does not exceed 447.

Let dpi,j be the maximal sum on the segment of length j, with that we have already considered all elements on the suffix i (that is, elements with indices i,i+1,…,n) and have already chosen segments with lengths j,j−1,…,1, in which the sums increase. Let's learn to recalculate the values of dynamics. We can either not include the i-th element in the segment of length j, then we need refer to the value of dynamics dpi+1,j, or include the i-th element, and then we are interested in the value of dynamics dpi+j,j−1 — if it's greater than the sum on the segment i,i+1,…,i+j−1, then we can take j segments with lengths from j to 1 on the suffix i, answ otherwise we cannot take such segments on the suffix i. We need to take the maximum among these two cases in order to maximize the sum. To calculate the sum on a segment you can use prefix sums.

Asymptotic behavior of this solution — O(n⋅n−−√).

Solution (74TrAkToR)1582F2 - Korney Korneevich and XOR (hard version)

Idea: 74TrAkToR

Tutorial1582F2 - Korney Korneevich and XOR (hard version)Let's iterate over all numbers of the array and for each number t maintain a list gt of all numbers y, such that it's possible to choose an increasing subsequence on the current prefix, in which xor of numbers is equal to y, and the last number of that increasing subsequence is less than t.

Let us currently consider the element ai. Then let's consider elements of gai — there will be all values of xor-s of the subsequences to which we can append the element ai. If gai contains a value f, then it's possible to get a value f⊕ai, then let's add the value f⊕ai to all lists g from ai+1 to the maximal value of a (if the value that is being added is already in some g-s, it's unnecessary to add it there again).

Let's perform some optimizations for this solution.

Let's stop considering the values gt that have already been considered. That is, if we have already considered gt at some iteration, then let's erase it, but remember that we never need to add the values of xor, that are being erased. That optimization is sufficient to get the asymptotic behaviour O((max_a)3), where max_a is the greatest one among all numbers of the array a (for every number t and its possible value of xor f we will pass over the value t⊕f to all states t+1,…,max_a; the amount of different t is O(max_a), the amount of f is O(max_a) as well, and the passing of the value each time is performed in O(max_a)).Let's notice that when we pass some value of xor equal to f to elements t+1,…,max_a, and find the element r, in which that value of xor has already been, then the value f is already in all elements greater than r, and that's why we don't have to add the value f any further. Using this optimization we can finally get a solution in O(max_a2), since for every value of xor (the amount of them is O(max_a)), we perform O(max_a) operations.In total (considering all optimizations), the asymptotic behaviour of the solution is O(n+(max_a)2).

Solution (74TrAkToR)1582G - Kuzya and Homework

Idea: 74TrAkToR

Tutorial1582G - Kuzya and HomeworkNotice that the segment is simple, if for any prime number we will get a bracket sequence, which has the minimal balance greater of equal to 0. The bracket sequence is formed the following way: we will iterate over the segment and add an opening bracket if we multiply by that number, and a closing bracket, if we divide by that number.

Let's consider the elements of the array a and calculate the array nxti, wich contains the greatest left bound, such that we can do the i-th operations in integer numbers with every l≤nxti. To calculate such bounds, for each prime number let's maintain all indices of its occurences in the numbers of a in a stack (if the prime numbers occurs in a number several times, we need to store the index several times). If the i-th operation is the operation of multiplying, then nxti is equal to i, and for all prime divisors of the number ai we need to add the index i, and if it's the operation of division,then for all prime divisors of ai we need to delete indices (in the same amount as the prime divisor occurs in ai) and save the smallest erased index in nxti. If for any prime divisor we had to erase an index from an empty stack, then we got a non-integer result, so nxti=−1.

Now that we know the values of the array nxt, we need to calculate the number of segments 1≤l≤r≤n, such that l≤min(l,r), where min(l,r) is the minimal value of nxti on segment l,r.

We can do that using segment tree on minimum in O(nlog2n) (iterate over the left bound and traversing the tree from the root find the greatest right bound for current left one) or using linear algorithms with a stack (to do that, let's iterate over all left bounds in decreasing order and maintain a stack on minimum on the array nxt).

Solution (74TrAkToR)

Editorial for Technocup 2022 — Elimination Round 1 and Codeforces Round #749 (Div. 1+Div. 2)

By Tlatoani, 16 months ago, In EnglishWe hope all of you enjoyed the round! This round has been a long time in the making -- the oldest problem in it is H, which was actually originally proposed for the rounds that eventually became Codeforces Round #655 (Div. 2) and Codeforces Global Round 10.

The tutorial for E and implementations for all problems are now available.

A - Windblume OdeProblem author: MagentaCobra

Preparation: MagentaCobra

Implementation in Java by MagentaCobra

1586A - Windblume OdeLet s be equal to the sum of array a. If s is composite then a is the largest composite subset of itself. Otherwise, since n≥3, s must be a prime number greater than 2, meaning s must be odd. Now notice that because all elements of a are distinct, if we remove any one number from a, the remaining sum must be strictly greater than 2. This leads us to the following solution: if s is prime, removing any odd number from a will give a composite subset of size n−1. This is because that since s is assumed to be odd, an odd number must exist in a, and the difference of two odd numbers is always even. Since we claim that this difference is at least 4, the new sum will always be composite.

B - Omkar and Heavenly TreeProblem author: golions

Preparation: golions

Implementation in Java by golions

1586B - Omkar and Heavenly TreeBecause the number of restrictions is less than n, there is guaranteed to be at least one value from 1 to n that is not a value of b for any of the restrictions. Find a value that is not b for all of the restrictions and construct a tree that is a "star" with that value in the middle. An easy way to do this is to make an edge from that value to every other number from 1 to n.

C - Omkar and DeterminationProblem author: Tlatoani

Preparation: Tlatoani and rabaiBomkarBittalBang

Implementation in Kotlin by Tlatoani

Implementation in Java by rabaiBomkarBittalBang

1586C - Omkar and DeterminationFirst notice that in a determinable grid, for any cell, it can't be that both the cell above it and the cell to its left are filled. If that were the case, then the cell wouldn't be exitable regardless of whether it was filled or not, and so we couldn't determine whether it was filled.

Now notice that in any grid with the above property, namely that from each cell you can move either up or to the left into an empty cell (or both), every empty cell must be exitable  — just keep moving either up or to the left, whichever is possible, until you exit the grid.

It follows that for any grid satisfying that property, given only which cells are exitable, starting from the outermost cells you will be able to determine that the nonexitable cells are filled, which implies that the next cells satisfy the property, which further implies that the nonexitable ones there are filled, and so on. This allows you to determine the entire grid (since the exitable cells are obviously empty).

Therefore, a grid being determinable is equivalent to all of its cells having an empty cell immediately above and/or to the left of it. You can check this for arbitrary subgrids by precomputing two dimensional prefix sums of the cells that violate this property, then checking whether the sum for a given subgrid is 0. This solution is O(nm+q).

The actual problem only asked for subgrids that contained every row, which allows for a somewhat simpler implementation.

D - Omkar and the Meaning of LifeProblem author: Tlatoani

Preparation: Tlatoani

Implementation of Solution 1 in Kotlin by Tlatoani

Implementation of Solution 2 slightly modified in Java by MagentaCobra

1586D - Omkar and the Meaning of LifeSolution 1

We will determine for each j, the index nextj such that pnextj=pj+1.

For each index j, perform a query with all 1s except that aj=2. If the result k exists, then we should set nextk=j.

Also, for each index j, perform a query with all 2s except that aj=1. If the result k exists, then we should set nextj=k.

For each j such that pj≠n, either nextj>j, in which case the first set of queries will find nextj, or nextj<j, in which case the second set of queries will find nextj. Therefore we will fully determine the array next.

To compute p, note that the index j such that pj=1 will not appear in the array next. Therefore, find this j, and set pj=1. Then set j to nextj, and set pj=2, and so on.

The total number of queries used is 2n, which is exactly the limit.

Solution 2

We will first determine qj=pj−pn for all j.

For each value of x from −(n−1) to n−1 (these are the only possible values of pj−pn), if x is nonnegative, then make a query where all of a+1 is x except that an=1; otherwise, make a query where all of a is 1 except that an=1−x. If the result k exists, then qk=x.

Note that there is at most one k such that qk=x for each x, so we will fully determine q this way (obviously we need to manually set qn=0).

pn is then equal to the number of j such that qj≤0. Using this, we can determine the rest of p as pj=qj+pn.

The total number of queries used is 2n−1, which is 1 below the limit.

Bonus question: Optimize this solution to use n queries.

E - Moment of BloomProblem author: MagentaCobra

Preparation: MagentaCobra

Implementation in Java by MagentaCobra

1586E - Moment of BloomLet fv be the number of times v appears in the q queries. If fv is odd for any 1≤v≤n, then there does not exist an assignment of paths that will force all even edge weights. To see why, notice that one query will correspond to exactly one edge adjacent to v. If an odd number of paths are adjacent to v, this implies that at least one edge adjacent to v will have an odd degree.

It turns out that this is the only condition that we need to check. In other words, if fv is even for all v, then there will exist an assignment of paths that will force all edge weights to be even.

Let's assume all fv is even. We can find a solution by doing the following: take any spanning tree of the graph and assign each query to be the path from a to b in this tree.

An intuitive way of thinking about this is the following. Consider the case if the spanning tree is a line. Then each query becomes a range and we're checking if all points in this range are covered an even number of times. For all points to be covered an even number of times, every point should occur an even number of times in the queries. To generalize this to a tree, when the first path a1 to b1 is incremented, in order to make these values even again, we will need later paths to also overlap the segment from a1 to b1. One way this can be done is if we use two paths a1 to c and c to b1. Notice that even if a new segment that makes the a1 to b1 path even makes some other edges odd, the later queries will always fix these edges.

F - Defender of Childhood DreamsProblem author: MagentaCobra

Preparation: MagentaCobra

Implementation in Java by MagentaCobra

1586F - Defender of Childhood DreamsThe minimum number of colors that you need is ⌈logkn⌉.

To achieve this, you can divide the nodes into k contiguous subsegments of equal size (or as close as possible). Any edge between nodes in different subsegments, you color with 1 for example. Then you recursively solve those subsegments excluding the color that you used.

Any path of the same color is between same size subsegments inside a single bigger subsegment (or the whole array). Since there would be only k such subsegments, the path could only have length at most k−1.

The highest recursion depth is ⌈logkn⌉, so this is the number of colors used as desired.

We will now prove that ⌈logkn⌉ colors are necessary. We will do this by equivalently proving that if you have a valid coloring using c colors, then n is at most kc. This, in turn, we will prove by induction on c.

The base case is c=0. If you have no colors, then you can't color any edges, so n must be at most 1=k0.

For the inductive step, we assume that any valid coloring using at most c−1 colors can have at most kc−1 nodes, and we desire to show that any valid coloring using at most c colors can have at most kc nodes. To do this, we will choose an arbitrary color, then partition all our nodes into at most k groups such that inside each group, there are no edges of that color. It follows that each group is colored using at most c−1 colors and so can have at most kc−1 nodes, so overall we can have at most k⋅kc−1=kc nodes.

The partition is defined as follows: we will partition the nodes into the sets s0,s1,…,sk−1 where sj contains all nodes a such that the length of the longest path ending in a using only edges of our chosen color is exactly j. This length is at most k−1 since our coloring can't have paths of length k of a single color. Furthermore, there can't be edges of our chosen color inside a set sj, because otherwise the endpoint of such an edge would be the end of the longest path to the start point of the edge plus the edge itself, which would be of length j+1.

Therefore, any valid coloring using c colors can have at most ck nodes, and so we must use at least ⌈logkn⌉ colors in our construction, which we have already seen how to do.

G - Omkar and Time TravelProblem author: Tlatoani

Preparation: Tlatoani and MagentaCobra

Implementation in Kotlin by Tlatoani

Implementation in C++ by AmShZ

1586G - Omkar and Time TravelEach time travel that Okabe performs creates a new set of completed tasks. We will take this as given, but it can be proven using ideas from the rest of the proof.

It thus suffices to count the number of distinct sets of task that come before the first one that contains s as a subset. We should first figure out what kinds of sets will ever appear as a set of completed tasks at all; we will call these sets valid.

We will represent tasks below as intervals [ak,bk].

First note that clearly not all sets are valid. If you have the intervals [1,2] and [3,4], clearly the set {[3,4]} is not a valid set. You can actually see that the same is true for the intervals [1,3] and [2,4] ({[2,4]} is not a valid set) by working through Okabe's activities.

This generalizes in a very important way: if there are two intervals [a,b] and [c,d] with a<c and b<d, then any valid set that contains [c,d] must also contain [a,b]. This is because if d is reached to complete the task [c,d], then b will already have been reached to complete the task [a,b] (since b<d), and any time travel that undoes [a,b] must also undo [c,d] (since a<c).

The above property is actually equivalent to being a valid set; we have already seen that it is necessary, and from the next part of the tutorial we will have way to prove that it is sufficient, but you should have some intuition for why this is true.

In order to solve the problem, we want to think about how to determine, given two valid sets, which one Okabe will encounter first. First, for any two valid sets, consider their last interval (i. e. interval with greatest value of b). If these are different, then the one with largest interval having greater b will come later.

This is because for any valid set, the largest value of b in any interval in that set is equal to the largest value of b that Okabe has ever encountered. You can see this by noticing that the only way to undo a task is to perform a task with greater value of b; any task with smaller b is either contained inside the first task, in which case it won't undo it, or also has a smaller value of a, in which case by the above property of valid sets it must already be completed.

Since the maximum value of b that Okabe has ever encountered will only get larger as his activities continue, it follows that the valid set with larger maximum value of b must occur later.

We can further see that for any two valid sets where the interval with largest b is equal, we can discard that interval and consider the next largest interval from both valid sets.

This gives us an ordering of the valid sets. We can prove that the aformentioned property is sufficient for being a valid set by showing that at any valid set, the next valid set encountered is the immediately next one in the ordering. The details are left to the reader.

In order to use this to finally solve the problem, it is useful to represent valid sets in a different way. Specifically, we can represent a valid set v as the set u of intervals that aren't implied to be in v by any other element of v. By thinking about the above property, you can see that u is actually a set of recursively containing intervals; i. e. it contains an interval, then another interval inside that one, then another interval inside that one, etc.

We will consider the above representation to be ordered, so that the last interval is the one that contains all the others, and the first interval is the one inside of all the others.

We can now solve the problem. For the given set s, first determine its above representation; this can be done easily using sorting, discarding any redundant interval. The valid sets, also in their above representation, that come before s are thus the ones that, excluding their common suffix with s, have a last interval whose b is smaller than the b for the last interval in s excluding the common suffix.

We can therefore solve this as follows. We will count the number of above sets for each possible common suffix. For each suffix, let the last interval in s not included in the suffix be x, and let the first interval in the suffix be y. The amount of sets for this suffix is equal to the amount of recursively containing sets that have a largest interval that is contained in y whose value of b is less than the value of b for x.

We can compute this follows. We will maintain a range sum query data structure such as binary index tree. The data structure will have at each a, the number of recursively containing subsets whose largest interval is the one with that a (once that interval has been processed). We will process the intervals in increasing order of b.

For each interval x, to put it into the data structure, we can simply perform a range query of literally the interval x, and add 1 to the result. That will be equal to the number of recursively containing sets with x as the largest interval, so we simply insert that into the data structure at the value of a of x.

Before putting x into the data structure, if it is in the representation of s, then we can find the answer for the suffix of s that contains all intervals to the right of x as follows. Since the intervals currently in the data structure are precisely the ones with value of b less than x, the answer for that suffix is simply the range query of y where y is the immediately next interval after x in s. We therefore perform this range query then add it to our answer.

Note that all of this computation doesn't count s itself, but it does count the empty set which doesn't need to be counted, so our answer is correct.

The runtime of this solution is O(nlgn).

H - Omkar and ToursProblem author: qlf9

Preparation: qlf9, Tlatoani, and MagentaCobra

Implementation in Java by qlf9

Implementation in Kotlin by Tlatoani

Implementation in C++ by Tlatoani

1586H - Omkar and ToursFirst, note that we can process all the queries offline. We can sort the queries by the number of vehicles in the tour group and process them in decreasing order.

Now, consider solving a version of the problem with distinct enjoyment values. Then, there will always be exactly one reachable city with the maximum enjoyment value. To solve this, we can maintain a DSU that stores, for each connected component, the maximum enjoyment value and the index of the node with the maximum enjoyment value, which we denote as enj[u],mxi[u] for a connected component u. When merging two connected components u, v, we simply take enj[u]=max(enj[u],enj[v]),mxi[u]=argmax(mxi[u],mxi[v]). Now, consider processing a query with starting node a and number of vehicles x, we denote its "connected component" u as the connected component of a in the graph that contains only edges with capacity ≥x. Finding the maximum enjoyment value that can be reached from a is simple; we can just output enj[u]. To compute the second value, because there is only one node with the maximum enjoyment value (mxi[u]), we can find the maximum edge on the path from a to mxi[u] using binary lifting. (Denote this as maxEdge(a,mxi[u]).)

We now consider the original problem, with non-distinct enjoyment values. However, here we make the key observation: for each query, the maximum toll edge always lies on either all the paths from node a to any node with maximum enjoyment value, or on a path between two nodes with maximum enjoyment value. To show this, ℓ be the node with maximum enjoyment value whose path to a contains the maximum toll edge, and let m be an arbitrary node with maximum value. The path from ℓ to a is completely contained in the union of the path from m to a and the path from ℓ to m. Therefore, the maximum toll edge lies on at least one of these path as desired.

Using this observation, we can modify our DSU to handle the general case. First, we now let mxi[u] to be the index of any maximum enjoyment value node in u. We also add a new variable, tol[u], which denotes the maximum toll cost among all paths between nodes of maximum enjoyment value in connected component u. Now, when merging components u and v, if enj[u] is not equal to enj[v], then we can simply take all the above values from the component with a larger enj. However, if enj[u]=enj[v], we will only need to update tol[u]. To do this, we need to consider edges that could possibly connect the two components along with ones within the components, so we let tol[u]=max(tol[u],tol[v],maxEdge(mxi[u],mxi[v])). Again, maxEdge can be computed using binary lifting.

Now, to process the queries, we will make use of our observation. For a query with starting node a and connected component u, the maximum enjoyment value is again enj[u]. However, the second value can now be more easily computed by max(maxEdge(a,mxi[u]),tol[u]).

As the preprocessing necessary for binary lifting takes O(nlogn) time, and all the queries can be answered in O((n+q)logn) time, the overall complexity is O((n+q)logn), which is fast enough.

I - Omkar and MosaicProblem author: rabaiBomkarBittalBang

Preparation: rabaiBomkarBittalBang

Implementation in Java by rabaiBomkarBittalBang

Implementation in Kotlin by Tlatoani

Implementation in C++ by 244mhq

1586I - Omkar and MosaicThe first main observation to make is that the possible mastapeeces don't just have square "loops" of the same color. A counterexample to this is shown below:

Instead, observe that, in a mastapeece: a) The two cells adjacent to corner cells must be the same color as the corner. b) Any cell not on the border must be adjacent to two sinoper tiles and two glaucous tiles If we then start at two cells adjacent to some corner and keep applying b) to cells on the long diagonal with the corner, we find that the long diagonals starting at the adjacent cells must be identical and tiled alternately with glaucous and sinoper tiles, like so:

From here, we can show that no mastapeece exists for odd n. Note that the two sets of such diagonals, for odd n, intersect in 4 cells like so:But then this forces us two have two consecutive diagonals of the same color on the untiled set of diagonals, which is impossible given that we've shown they must alternate. From here, if we apply b) to the red diagonals, we find that the yellow diagonals must alternate in a similar fashion:and if we keep applying this argument, we find that each diagonal where every cell is the same color in the image below must alternate between glaucous and sinoper in a similar way:From here, consider the following yellow diagonal:We know its cells must alternate, so due to parity we have that the ending cells of the diagonal must be the same color. Since we know each cell must be surrounded by two of the same color, this also fixes the following red cells:which must also be the same color. This gives that the following yellow diagonals must be identical (as they must alternate):repeating this kind of argument shows that a mastapeece must be symmetric about both of its main diagonals. Finally, note that since the yellow diagonal alternates, and each cell must be adjacent to 2 of the same color, the red cells must be the same color:Repeating this kind of argument gives that the cells in each pair of adjacent red cells and each pair of adjacent yellow cells must be the same color:Finally, applying the symmetry, alternating diagonals, and the pairs of same colored cells gives that in the following grid, fixing a cell of one color fixes all of the cells of that color:Finally, due to our conditions on alternating diagonals, each cell in the middle of the grid will be adjacent to two cells of the same color, and due to our conditions on the pairs of cells on the diagonal that must be the same color, each border cell will be adjacent to two cells of the same color. In other words, if we pair up the cells on the leftmost column and color each pair arbitrarily, there will be exactly one mastapeece that has the column colored this way. For example, if we color the leftmost column like so:then if we go down and color in the cells fixed by each pair in the left most column, we find that the final mastapeece will look like so:

From here, it's pretty easy to figure out how to implement the problem.

Some examples of what mastapeeces look like are shown below:

Editorial for Codeforces Round #748 (Div.3)

By MrPaul_TUser, history, 16 months ago, In English1593A - Elections

Idea: MikeMirzayanov

Tutorial1593A - ElectionsLet's solve the problem for the first candidate. To win the election, he needs to get at least 1 more votes than every other candidate. Therefore, the first candidate needs to get at least max(b,c)+1 votes. If a is already greater than this value, then you don't need to add any votes, otherwise, you need to add max(b,c)+1−a votes. So the answer for the first candidate is max(0,max(b,c)+1−a).

Similarly, the answer for the second candidate is max(0,max(a,c)+1−b), and, for the third one, the answer is max(0,max(a,b)+1−c).

Solution1593B - Make it Divisible by 25

Idea: MikeMirzayanov

Tutorial1593B - Make it Divisible by 25A number is divisible by 25 if and only if its last two digits represent one of the following strings: "00", "25", "50", "75".

Let's solve for each string the following subtask: what is the minimum number of characters to be deleted so that the string becomes a suffix of the number. Then, choosing the minimum of the answers for all subtasks, we solve the whole problem.

Let's solve the subtask for a string "X Y" where 'X' and 'Y' are digits. We can do it using the following algorithm: let's delete the last digit of the number until it is equal to 'Y', then the second to last digit of the number until it is equal to 'X'. If it is not possible, then this subtask has no solution (i.e. its result will not affect the answer).

Solution1593C - Save More Mice

Idea: ITMO student team

Tutorial1593C - Save More MiceLet's solve the problem using a linear search. Let m be the number of mice we are trying to save. Then it is more efficient to save m mice such that they are the closest ones to the hole. Let ri be the distance from the i-th mouse to the hole (ri=n−xi). Denote R:=∑i=1mri. Let's prove that these mice will be saved if and only if R<n.

The necessary condition. Suppose we can save the mice and R≥n. Since only one mouse can be moved in one second, the following will happen: m−1 of mice will already be saved and one mouse will have to be saved. When it's been q seconds, then the distance from the cat to the hole will be equal to n−q, and the distance from the mouse to the hole will be equal to R−q (since all other mice are already in the hole, their distances to the hole are equal to 0, so the sum of the distances from all mice to the hole at the current time is exactly equal to the distance to the hole from one remaining mouse). Since R−q≥n−q, the distance from the mouse to the hole is greater than or equal to the distance from the cat to the hole. But this cannot be, because both the mice and the cat move only to the right, and all mice met by the cat are eaten. So, R<n.

Sufficient condition. Suppose R<n. If R=0, then all the mice are already in the hole, i.e. they are saved. Suppose R>0. Let's move any mouse, then the cat. Suppose the cat ate at least one of the mice. This mouse is definitely not the one that was moved. Then the distance from it to the eaten mouse was equal to 1, i.e. the distance from it to the hole was equal to the distance from the eaten mouse to the hole plus 1. The distance from the moved mouse to the hole was at least 1. So, R≥rs+rm, where rs=n−1 is the distance from the eaten mouse to the hole, rm≥1 is the distance from the moved mouse to the hole. So, R≥n−1+1=n, but it's false. Therefore, none of the mice will be eaten on the first move. Then the distance from the cat to the hole will be equal to n−1, the total distance from the mice to the hole will be equal to R−1. R−1<n−1, i.e. now we have to solve a similar problem for smaller R and n. So R will be gradually decreased to 0, while no mouse will be eaten. So, if R<n, all the mice will be saved.

Thus, to solve the problem, we need to find the maximum m such that the sum of the distances from the m nearest mice to the hole is less than n.

Solution1593D1 - All are Same

Idea: MikeMirzayanov

Tutorial1593D1 - All are Samek can be arbitrarily large if and only if all numbers in the array are the same. In this case, we can choose any number k and subtract it from all the numbers, for example, exactly once.

Suppose we fix some k. Let qi be the number of subtractions of the number k from the number ai. In this case, all numbers will be equal if and only if, for any two numbers ai and aj from the array, ai−k⋅qi=aj−k⋅qj. Let qi0 be the minimum of qi. Then all numbers in the array become the same if for each index i we subtract from ai k not qi, but qi−qi0 times. Then we will never subtract k from the element ai0. This means that there is always an element in the array from which we can never subtract k. This element is the minimum on the array. Then from ai we will subtract k exactly ai−ai0k times.

Thus, with the current k, it is possible to make all elements equal if and only if for all elements ai the value ai−ai0 (where ai0 is the minimum on the array) is divisible by k. So, the maximum k is the greatest common divisor of all values of ai−ai0, i=1,n¯¯¯¯¯¯¯¯.

Solution1593D2 - Half of Same

Idea: MikeMirzayanov

Tutorial1593D2 - Half of Samek can be arbitrarily large if and only if at least half of the numbers in the array are the same. In this case, we can choose any number k and subtract it from all numbers, for example, exactly once.

Let's iterate over the element ai0, it will be the minimum among the numbers that we want to make the same. Let's calculate the number of numbers in the array that are equal to this element. If this number is at least n2, then the answer is -1. Otherwise, we will iterate over numbers ai which are strictly greater than the selected minimum, and, for each number, we will iterate over the divisors of the number ai−ai0. For each of the found divisors, let's calculate the number of ai for which this divisor was found. Among all such divisors for which the sum of the found number and the number of numbers equal to ai0 is greater than or equal to n2, we will choose the maximum one. The greatest found divisor will be the desired k. This solution works in O(n2×A−−√) (where A is the absolute value of the maximum on the array).

Solution1593E - Gardener and Tree

Idea: MikeMirzayanov

Tutorial1593E - Gardener and TreeLet's create two arrays of length n. The element of the array layer will contain the operation number at which the vertex which is the index of the array will be deleted. The rem array will contain the number of neighbors of a given vertex at a certain time. This array must be initialized with the number of neighbors in the original tree.

Initially, we will suppose that the gardener performs an infinite number of operations, and we will simply calculate for each vertex the number of the operation on which it will be deleted. Let's create a queue q, which will store the order of deleting vertices. The queue will contain only those vertices whose neighbors, except, maybe, one, have been removed (i.e. rem[v]≤1). Let's add all leaves of the original tree to it, for each of them let's store the value 1 in the array layer (because all original leaves will be removed during the first operation).

Next, we will take sequentially one vertex from the queue and update the data about its neighbors. Consider the neighbors. Since we are deleting the current vertex, we need to update rem of its neighbors. If the neighbor's rem is equal to 1, then it's already in the queue and it doesn't need to be considered right now. Otherwise, we will decrease the neighbor's rem by 1. If it becomes equal to 1, then the neighbor must be added to the queue. The number of the operation during which the neighbor will be deleted is equal to the number of the operation during which the current vertex will be deleted plus 1.

After we calculate the numbers of operations for all vertices, we need to select among them those that will not be deleted during operations with numbers 1,2,…,k. Thus, the answer is the number of vertices v such that layer[v]>k.

Solution1593F - Red-Black Number

Idea: MikeMirzayanov

Tutorial1593F - Red-Black NumberThe number x is divisible by the number y if and only if x≡0 modulo y.

To solve this problem, let's use the concept of dynamic programming. There will be four states: the number of considered digits of the number x, the number of such considered digits that we have colored red, the remainder from dividing the red number by A and the black one by B. The value corresponding to the state will be described by three parameters: the possibility of a situation described by the states, the color of the last digit, and the parent state. Let's assume that the number that contains 0 digits is equal to 0.

Initially, let's mark the state in which 0 digits are considered, of which 0 are red digits, and both remainders are equal to 0, as possible. Next, let's iterate over all states in the following order: first by the number of considered digits, then by the number of considered red digits, then by the remainder of the division by A and by B. From the current state, if it is possible (i.e. the corresponding mark is set), you can make two transitions to new states. At the first transition, we paint the last digit in red, at the second one in black. We need also to store the current state in the new states as the previous one.

A solution exists if and only if some state in which exactly n digits are considered, of which at least 1 and at most n−1 red digits, and the remainders are equal to 0, is marked as possible. Let's find such a state. Using the stored information about the color of the last digit and the previous state, we can restore the colors of all digits of the number x.

Solution1593G - Changing Brackets

Idea: nastya_ka

Tutorial1593G - Changing BracketsConsider a substring t=s[l…r]. Let's call square brackets located in odd positions in the substring odd brackets, and square brackets located in even positions even brackets. Let cntodd be the number of odd brackets, cnteven be the number of even brackets, cntall=cntodd+cnteven be the number of all square brackets. Let's prove that the string t can be turned into a correct bracket sequence for 0 burles if and only if cntodd=cnteven.

Let's prove the necessary condition. Suppose the initial substring has been turned into a correct bracket sequence. Since we have paid 0 burles, there's no bracket which form has been changed. Therefore, cntodd for the new sequence is the same as cntodd for the initial sequence, the similar situation happens with cnteven.

Let's say that two square brackets form a pair if the left one is an opening bracket and the right one is a closing bracket and the substring between them is a correct bracket sequence. A pair can be formed only by one odd bracket and one even bracket because between them is placed an even number of brackets (since it's a correct bracket sequence) so the difference between their indices is odd. In a correct bracket sequence, each square bracket has a pairwise bracket. Therefore, a correct bracket sequence contains cntall2 pairs of brackets so cntodd=cnteven=cntall2.

Let's prove the sufficient condition. Suppose the initial substring contains equal numbers of odd and even brackets. Let's prove by induction that the substring may be turned into a correct bracket sequence for 0 burles.

Suppose cntodd=cnteven=0. So the initial substring contains only round brackets. Let's make the first r−l+12 brackets opening and the other brackets closing. The resulting sequence is a correct bracket sequence whereas we haven't changed the form of any bracket so the cost is equal to 0.

A correct bracket sequence has two important properties:

after deleting its substring being a correct bracket sequence, the resulting string is a correct bracket sequence;after inserting at any place any correct bracket sequence, the resulting string is a correct bracket sequence.These properties can be applied to an incorrect bracket sequence, too: after deleting a substring being a correct bracket subsequence from an incorrect bracket sequence or inserting a correct bracket sequence into an incorrect one, the resulting sequence is an incorrect bracket sequence.

Consider a substring t such that cntodd=cnteven>0. Suppose we have proved before that each substring t having cntodd=cnteven decreased by 1 can be turned into a correct bracket sequence for 0 burles. Let's find two square brackets such that one of them is odd and another one is even and there are no square brackets between them. There's an even number of round brackets between them that can be turned into a correct bracket sequence for 0 burles. Let's make the left found bracket opening and the right one closing. Then the substring starting at the left found bracket and ending at the right found bracket is a correct bracket sequence. Let's remove it from t. The resulting string contains cntodd−1 odd brackets and cnteven−1 even brackets so, by the assumption of induction, it can be turned into a correct bracket sequence for 0 burles. Let's do it and then insert the removed string into its place. Since we insert a correct bracket sequence into a correct bracket sequence, the resulting string is a correct bracket sequence.

Actually, the operations of inserting and removing are not allowed, they have been used for clarity, the string can be turned into a correct bracket sequence without these operations as follows: let's turn the substring we have removed into a correct bracket sequence (as it was described above), then change the other brackets of the string the same way as it was done with the string that was the result after removing. The resulting string is a correct bracket sequence. Therefore, the illegal operations of inserting and removing are not necessary, all other operations cost 0 burles so the substring t can be turned into a correct bracket sequence for 0 burles.

Therefore, to turn a substring into a correct bracket sequence, we need to get a sequence such that cntodd=cnteven. Suppose, initiallly, cntodd>cnteven. Let's pay cntodd−cnteven burles to replace cntodd−cnteven odd brackets with round brackets. If cntodd<cnteven, let's replace cnteven−cntodd even brackets with round brackets. Anyway, we must pay |cntodd−cnteven| burles. We cannot pay less than this value because for a correct bracket sequence, cntodd=cnteven. But there's no need to pay more than this value, because, if we turn the initial substring into a sequence with cntodd=cnteven, we can turn it into a correct bracket sequence for free. Therfore, the answer for a given question is |cntodd−cnteven|.

Since we must answer the queries fast, let's use a concept of prefix sums. If the given string s contains n brackets, let's create arrays psumOdd and psumEven with the length n+1. psumOdd[i] will contain the number of odd brackets on the prefix of the string s with the length i, psumEven[i] — the same value for even brackets. Let's initialize psumOdd[0]=psumEven[0]=0 and then iterate i from 1 to n. Let's initialize psumOdd[i]=psumOdd[i−1] and psumEven[i]=psumEven[i−1]. If the i-th bracket is round, then the current values are correct. Otherwise, let's find out what bracket is it. If i is odd, the bracket is odd so we must increase psumOdd[i] by 1. If i is even, the bracket is even so we must increase psumEven[i] by 1.

To get the answer for a current l and r, let's calculate cntodd and cnteven. cntodd is a number of odd brackets that belong to the prefix with the length r but not to the prefix with the length l−1 so cntodd=psumOdd[r]−psumOdd[l−1]. Similarly, cnteven=psumEven[r]−psumEven[l−1]. The remaining thing is to output |cntodd−cnteven|.

Solution

Codeforces Round #747 (Div. 2) Editorial

By Theo830, 17 months ago, In English1594A - Consecutive Sum Riddle

HintSolution1594A - Consecutive Sum RiddleYou can take (−n+1)+(−n+2)+…+(n−1)+n, so the sum will be n. Thus, l=−n+1 and r=n.

Code (C++)1594B - Special Numbers

HintSolution1594B - Special NumbersThe problem is the same as finding the k-th number that in base n has only zeros and ones.

So you can write k in binary system and instead of powers of 2 add powers of n.

Code (C++)1594C - Make Them Equal

HintSolution1594C - Make Them EqualIf the whole string is equal to c then you don't need to make any operations.

In order to find if it is possible with exactly 1 operation, we can pass through every x and count all the letters c that are divisible by x. This takes O(|s|log|s|) time complexity.

If for some x all its multiples are c then the answer is 1 operation with that x.

If all the above conditions don't hold you can always make 2 operations and make all the elements equal.

One possible way is with x=|s| and x=|s|−1.

After the first operation only the last element of s is not c thus if we use x=|s|−1 since gcd(|s|,|s|−1)=1 then |s| is not divisible by |s|−1 and it will become equal to c.

Time complexity: O(|s|log|s|) per test case.

Code (C++)1594D - The Number of Imposters

HintSolution1594D - The Number of ImpostersIf person A said in a comment that person B is a crewmate then A and B belong to the same team (either imposters or crewmates).

If person A said in a comment that person B is an imposter then A and B belong to different teams.

Solution 1:

You can build a graph and check if all its components are bipartite.

If person A said that B is an imposter then we add an edge from A to B.

If person A said that B is a crewmate then we add an edge from A to a fake node and from the same fake node to B.

For each component, we check if it's bipartite and take the maximum from the two colours.

If a component is not bipartite then the answer is −1.

Solution 2:

We can build the graph in the other way:

If A and B are in the same team then we add edge with weight 0, otherwise with weight 1.

Then you can use dfs and colour the nodes either 0 or 1 maintaining the property that u⊕v=w(u,v).

Code 1(C++)Code 2(C++)1594E1 - Rubik's Cube Coloring (easy version)

HintSolution1594E1 - Rubik's Cube Coloring (easy version)You have 6 choices for the first node and 4 for each other node. Thus, the answer is 6⋅42k−2.

Code (C++)1594E2 - Rubik's Cube Coloring (hard version)

HintSolution1594E2 - Rubik's Cube Coloring (hard version)Let's define a node as marked if it has a predefined node in its subtree. There is always at least 1 marked node since all predefined nodes are definitely marked.

You can see that marked nodes form a path for the root to any predefined node. Thus there are at most n⋅k marked nodes and we can run a standard dp[i][j] on them (node i is colored with j). Depending on the implementation the dp can have time complexity O(n⋅k⋅6⋅4) or O(n⋅k⋅log(n⋅k)⋅6⋅4) if you use map.

You multiply the result with 4m where m is the number of unmarked nodes. This holds because if their parent has a fixed color they always have 4 choices and so on.

Code (C++)1594F - Ideal Farm

Solution1594F - Ideal FarmThe problem is the same as:

We have an array a of length n where every element of it is a positive integer and the sum of the whole array is s. If no matter how we construct the array a, we can find a non-zero length subarray which has sum equal to k print "YES" else print "NO".

If s=k then the answer is obviously "YES" and if s<k then the answer is obviously "NO".

Let pre[i]=∑j<=ij=1a[j] (1 - indexed)

All the elements of array pre are different as all a[i] are positive integers. Let b[i]=pre[i]+k but we also have b[0]=k.

Again all the elements of b are different because all a[i] are positive integers.

Array pre has size n and array b has size n+1.

If and only if an element from pre is equal to an element from b then it means that pre[i]=pre[j]+k or pre[i]=k. If it is the second case then obviously there is a subarray with sum equal to k.

If it's the first case then pre[i]−pre[j]=k so the subarray [j+1,i] has sum k.

But when do we have an equation in these two arrays?

There are n+(n+1)=2n+1 elements and they can be values from 1 to s+k.

If the maximum number of distinct elements that we can take is less than 2n+1 the answer is "YES" else the answer is "NO".

Let m be the maximum number of elements that we can take.

We go through the last k elements ([s−k+1,s]) and we count the number of elements that have the same modulo k.

For each element in this range, if there are odd elements that have the same modulo, we can't take all of them because for every element x that we add in pre that we also add x+k to b. Thus one element would have a x+k out of range.

Therefore we count all the elements that have odd elements with the same modulo k and subtract them from s+k to find m.

Code (C++)

Codeforces Round #746 Editorial

By Bakry, history, 17 months ago, In English1592A - Gamer HemoseIt's always optimal to use two weapons with the highest damage value and switch between them.

Let x be the highest damage value of a weapon, and y be the second-highest damage value of a weapon. we will decrease monster health by x in the first move, and by y in the second move and so on.

ans=⎧⎩⎨⎪⎪⎪⎪2⋅Hx+y,2⋅⌊Hx+y⌋+1,2⋅⌊Hx+y⌋+2,if H mod (x+y) =0if H mod (x+y) ≤xotherwise1592B - Hemose ShoppingThe answer is always "YES" If n≥2∗x because you can reorder the array as you want.

Otherwise, You can swap the first n−x elements and the last n−x elements, so you can reorder them as you want but the rest have to stay in their positions in the sorted array.

So if elements in the subarray [n−x+1,x] in the original array are in their same position after sorting the array then the answer is YES, otherwise NO.

1592C - Bakry and PartitioningThe most important observation is: If you can partition the tree into m components such that the xor of every component is x, Then you can partition the tree into m−2 components by merging any 3 adjacent components into 1 component, and the xor of the new component will equal x, since x xor x xor x = x.

Notice that the answer is always YES if the xor of the array is 0. Because you can delete any edge in the tree, and the 2 components will have the same xor.

Otherwise, We need to partition the tree into 3 components that have the same xor. Let x be the xor of all node values in the tree, then The xor of every component will equal x.

We need to search for 2 edges to delete from the tree and one of them such that the xor every component equals x and if we found them and K≠2 then the answer is "YES" otherwise "NO".

To search on the 2 edges, We will first root the tree on node 1, then we will search on the deepest subtree such that xor value of subtree equals x, then erase the edge and search again for the 2nd edge.

1592D - Hemose in ICPC ?The maximum gcd of a path equals the maximum weight of an edge in the tree. Let x be the value of the maximum weight of an edge in the tree, We need to find u, v such that there's an edge between u and v with weight equals x.

Let's find x by putting all the n nodes in the same query, Now we need to find u, v.

If we have an array of edges such that for any consecutive subarray: The component of nodes inside the subarray is connected using the edges inside the subarray. Then we can binary search on this array to find the edge with the maximum weight.

If we put the edges in the array using the order of Euler tour traversal, the array will satisfy the condition above, and we can solve the problem.

Total number of queries is 1+log(2∗(n−1)).

1592E - Bored BakryLet And(l,r) denotes the bitwise and of the elements in subarray [L,R] in the array and Xor(l,r) denotes the bitwise xor of the elements in subarray [L,R] in the array.

If subarray [L,R] length is odd then it can't be a good subarray because And(l,r) is a submask of Xor(l,r) since every bit in And(l,r) occurs odd times so it will be set in Xor(l,r).

If subarray [L,r] length is even then every bit in And(l,r) will be unset in Xor(l,r) so we only care about the most significant bit in And(l,r).

Let's solve for every bit k, Let's call bit m important bit if m>k. For every r in the array, We need to find the minimum l such that [l,r] is even, k is set in And(l,r) and all the important bits are unset in Xor(l,r).

Since we only care about the important bits, We can make a prefix array where prefi is the prefix xor till the index i considering only the important bits.

So for every r, we need to find the minimum l that satisfy these conditions:

1 - r−l+1 is even.

2 - k is set in all elements in subarray [l,r].

3 - prefr xor prefl−1 =0.

which can be solved easily in O(NlogN).

1592F1 - Alice and Recoloring 1We will transform favorite coloring to the all-white coloring instead.

Let's denote W by 0 and B by 1.

First observation is that it doesn't make sense to do operations of type 2 and 3 at all. Indeed, each of them can be replaced with 2 operations of type 1:

Instead of flipping subrectangle [x,n]×[1,y], we can flip subrectangles [1,n]×[1,y] and [1,x−1]×[1,y], and similarly for [1,x]×[y,n]. So, from now on we only consider first and last operations.

Let's create a grid a of n rows and m columns, where a[i][j] denotes the parity of the sum of numbers in those of cells (i,j),(i+1,j),(i,j+1),(i+1,j+1) of favorite coloring, which are present on the grid. Clearly, all numbers in a are 0 if and only if current coloring is all 0, so we will want to just make the grid a all 0.

Let's look at how first and last operations affect the grid a. If we flip the subrectangle [1,x]×[1,y] with the operation of the first type, in grid a the only value that changes is a[x][y]. If we flip the subrectangle [x,n]×[y,m], clearly x,y>1 (otherwise we could have instead used 2 operations of the first type). Then, it's easy to see that the only cells that will change are a[x−1][y−1],a[n][y−1],a[x−1][m],a[n][m].

So, now we have the following problem: we have a binary grid n×m. In one operation, we can change some 1 to 0, with cost of 1 coin, or to select some 1≤x≤n−1,1≤y≤m−1, and flip the numbers in cells a[x][y],a[n][y],a[x][m],a[n][m] with cost of 3 coins. What's the smallest cost to make all numbers 0?

Now, it's easy to see that it doesn't make sense to apply second operation more than once, as instead of doing it twice, we can apply the operation of the first type at most 6 times (as cell a[n][m] will be flipped twice). Moreover, it only makes sense to apply the second operation if there exist such 1≤x≤n−1,1≤y≤m−1 for which all cells a[x][y],a[n][y],a[x][m],a[n][m] are 1. So, the algorithm would be to calculate the grid a, to calculate the total number of ones in it ans, and substract 1 from ans if there exists such 1≤x≤n−1,1≤y≤m−1 for which all cells a[x][y],a[n][y],a[x][m],a[n][m] are 1.

Complexity O(nm).

1592F2 - Alice and Recoloring 2Everything from the editorial of the first part of the problem stays the same, except one thing: now the second operation on the modified grid costs only 2 coins. Sadly, now it's not true that it's not optimal to use the second operation more than once.

Let's denote the second operation on a by op(x,y) (meaning that we invert numbers at a[x][y],a[n][y],a[x][m],a[n][m]). New claim is that it's not optimal to make operations which have the same x or the same y.

Indeed, suppose that we made op(x,y1) and op(x,y2). Then cells a[x][m] and a[n][m] haven't changed, so we only flipped 4 cells with cost of 2×2=4 coins. We could have done this with operations of the first type.

Another observation: it doesn't make sense to make op(x,y), unless all the cells a[x][y],a[x][m],a[n][y] are 1. Indeed, no other operation of this type will affect any of these cells. If some cell here is 0, and we still make op(x,y) in 2 coins, then we will have to spend one additional coin on reverting it back to 0 with the operation of the first type. Instead, you could have just flipped 3 other cells from a[x][y],a[x][m],a[n][y],a[n][m] with the operations of the first type in the same 3 coins.

How many such operations can we make then? Let's build a bipartite graph, with parts of sizes n−1 and m−1, and connect node x from the left part with node y from the right part iff a[x][y]=a[x][m]=a[n][y]=1. Find the maximum matching in this graph with your favorite algorithm (for example, in O(mnm+n−−−−−√) with Hopcroft–Karp), let its size be K. Then, for each 0≤k≤K, we can find the number of ones that will be left in the grid if we make exactly k operations of the second type. Then the answer to the problem is just the minimum of (ones_left+2k) over all k.

Codeforces Round #745 Editorial

By interlude, history, 17 months ago, In EnglishI'm very sorry about all the inconvenience, and I would like to bear the blame. Much thanks to those who help me prepare this round. It's not their fault. And much thanks to your participation.

1581A - CQXYM Count Permutationsidea: interlude

preparation: CQXYM

tutorial: CQXYM

Assume a permutation p, and ∑2ni=2[pi−1<pi]=k. Assume a permutaion q, satisfying ∀1⩽i⩽2n,qi=2n−pi. We can know that ∀2⩽i⩽2n,[pi−1<pi]+[qi−1<qi]=1. Thus,∑2ni=2[qi−1<qi]=2n−1−k, and either p should be counted or q should be counted. All in all, the half of all the permutaions would be counted in the answer. Thus, the answer is 12(2n)!. The time complexity is O(∑n). If you precalulate the factors, then the complexity will be O(t+n).

solution1581B - Diameter of Graphidea: CQXYM

preparation: CQXYM

tutorial: CQXYM

If m<n−1, the graph can't be connected, so the answer should be No.

If m>n(n−1)2, the graph must contaion multiedges, so the answer should be No.

If m=n(n−1)2, the graph must be a complete graph. The diameter of the graph is 1. If k>2 the answer is YES, otherwise the answer is NO.

If n=1, the graph has only one node, and its diameter is 0. If k>1 the answer is YES, otherwise the answer is NO.

If m=n−1, the graph must be a tree, the diameter of the tree is at least 2 when it comes to each node has an edge with node 1. If m>n−1∧m<n(n−1)2, we can add edges on the current tree and the diameter wouldn't be more than 2. Since the graph is not complete graph, the diameter is more than 1, the diameter is just 2. If k>3 the answer is YES, otherwise the answer is NO.

The time complexity is O(t).

solution1580A - Portalidea: CQXYM

preparation: CQXYM

tutorial: CQXYM

We can enumerate the two corner of the submatrix, calculate the answer by precalculating the prefix sums. The time complexity is O(∑n2m2). When we enumerated the upper edge and the lower edge of the submatrix, we can calculate the answer by prefix sum. Assume the left edge of the submatrix is l, and the right edge is r. The part of anwer contributed by upper and lower edge are two segments, we can calculate the answer by prefix sums. The middle empty part is a submaxtrix, and we can use prefix sums too. Since we have enumerated the upper edge and lower edge, the left edge part is just about l, and the right part is just about r. Then we enumerate l, the answer of the best r can be calculated by precalculating the suffix miniums. The time complexity is O(∑n2m), space complexity is O(nm).

solution1580B - Mathematics Curriculumidea: interlude

preparation: interlude

tutorial: CQXYM

Define the dp state fl,s,d as the number of the permutaion length of l with exactly d such numbers that all the subsegments containing them have exactly s different maxima in total. We enumerate the position of the bigest number in the permutaion. We call the position is a. The numbers before a and after a are independent. Then we transform the statement (l,s,d) to (a−1,x,d+1) and (l−a,y,d+1). We also have to distribute the numbers to two parts, so the dp transformation is:

fl,s,d=∑la=1(l−1a−1)∑sx=0fa−1,x,d+1fl−a,s−x−[d=k],d+1In addition, the answer of the problem is fn,m,k. Actually, the dp proccess is just like a cartesian tree. The time complexity is O(n2m2k), space complexity is O(nmk). However, it's enough to pass the tests.

solution1580C - Train Maintenanceidea: interlude

preparation: interlude

tutorial: interlude and CQXYM

Let's distinguish the trains according to xi+yi.

If xi+yi>m−−√, the total times of maintenance and running don't exceed mm√=m−−√. So we can find every date that the train of model i begin or end maintenance in O(m−−√), and we can maintain a differential sequence. We can add 1 to the beginning date and minus 1 to the end date, and the prefix sum of this sequence is the number of trains in maintenance.

If xi+yi≤m−−√, suppose the train of model i is repaired at si day. For a date t that the train of model i is in maintenance if and only if (t−si) mod (xi+yi)≥xi. Thus for each a≤m−−√, we can use an array of length a to record the date of all trains that satisfy xi+yi=a are in maintenance modulo a. And for one period of maintenance, the total days aren't exceed m−−√. So we can maintain (t−si) mod (xi+yi) in O(m−−√).

Thus the intended time complexity is O(mm−−√) and the intended memory complexity is O(n+m).

Tutorial by CQXYMFinished reading the statement, you may have thought about this easy solution as followed. Maintain an array to count the trains in maintenance in each day. For add and remove operations, traverse the array and add the contribution to the array. The algorithm works in the time complexity of O(nm). Besides, we can use the difference array to modify a segment in O(1). However, we can optimize this solution. For the trains of x+y>m−−√, we can modify every period by brute force because the number of periods is less than m−−√. For the trains of x+y⩽m−−√, the number of the periods can be large. In this case, we set the blocks, each of them sizes O(m−−√). We can merge the modifies which are completely included in the same block, with the same length of period and the same start position in the block. It's fine to use an array to record this. Number of segments are not completely included in the block is about O(m−−√). The total complexity is O(mm−−√).

solution1580D - Subsequenceidea: interlude

preparation: interlude

tutorial: interlude and CQXYM

First we can change the way we calculate the value of a subsequence. We can easily see the value of a subsequence ab1,ab2,…,abm is also ∑mi=1∑mj=i+1abi+abj−2×f(bi,bj), which is very similar to the distance of two node on a tree. Thus we can build the cartesian tree of the sequence, and set the weight of a edge between node i and j as |ai−aj|. Then we can see what we are going to calculate turns into follows : choosing m nodes, maximize the total distance between every two nodes. Thus we can solve this task using dynamic programming with the time complexity O(n2).

Tutorial by CQXYMFrom the statement, we'd calculate the sums like ai+aj−Minjk=iak. When we put this on a cartesian tree, it turns out to be ai+aj−aLCA(i,j). Set the weigth of the edge x→y as ay−ax, ai+aj−aLCA(i,j) equals to the distance between node i,j on the tree. Define the dp state fi,j as the maxium answer in the subtree rooted at node i, and we choose j of the nodes in the subtree. Enumerate how many nodes we choose in the subtree of left-son of node i, number of nodes of right-son, and whether node i is chose. The contribution made by the edge is its weight times the number of nodes are chose. Since a pair of node will contribute time complexity only when we are calculating the dp state of their LCA, the total time complexity is O(n2).

solution1580E - Railway Constructionidea: interlude

preparation: interlude

tutorial: interlude

For convenience, we first define dis[u] as the length of the shortest path between node 1 and node u and "distance" of node u as dis[u], and call node u is "deeper" than node v if and only if dis[u]>dis[v]. Similarly, we call node u is "lower" than node v if and only if dis[u]<dis[v]. We will use u -> v to denote a a directed edge staring at node u and ending at node v, and use u --> v​ to denote an arbitrary path staring at node u and ending at node v. We call two paths "intersect" if and only if they pass through at least 1 same node.

First let's focus on several facts.

Since all edges' weights are positive, and we have to make sure that the distance of every node does not change, for any node u​, we can only add edges starting at a node whose distance is strictly less than dis[u]. Besides, we can always add edge 1 -> u, but we can never add edge u -> 1.Since the distance of every node does not change and the train only pass through the shortest path, if an edge is not on the shortest path at first, however we add edges it won't be on any shortest path. Thus we can first calculate the shortest path and then remove all edges which are not on the shortest path. We can easily see that the new graph is a DAG (Directed Acyclic Graph). And in this graph the topological order is also the ascending order of nodes' distances. In the following part of this tutorial, we will use the new graph instead of the original graph.After we add all edges, every node except node 1 must have at least 2 incoming edges.Then let's prove a lemma: if every node except node 1 exactly has 2 incoming edges, the graph will meet the requirement.

We will use mathematical induction method to prove the lemma. For an arbitrary node u, we suppose that all nodes whose distance is less than u's has met the requirement, and we only need to prove that node u​ also meets the requirement. Suppose the start of the 2 incoming edges is separately s and t.

First, if s or t is node 1, we can simply choose 1 --> u and 1 --> t -> u as the two paths and obviously they don't intersect. Thus it meet the requirement.

Second, if s and t are not node 1. We choose an arbitrary path 1 --> s and call it path 0. According to our assumption, we can choose two different paths starting at node 1 and ending at node $t$​, and the two paths don't intersect. We call them path 1 and path 2 separately.

If path 0 and path 1 (or path 2) doesn't intersect, then we can choose path 0 and path 1 to meet the requirement. Thus we only need to consider the situation that path 0 intersect with both path 1 and path 2.

In this case, we first find the lowest and deepest node where path 0 and path 1 or path 2 intersect, and call them a and b separately.

If the both are the intersect points of path 0 and path 1, like the case below, we can choose path (1 -> a -> (through path 1, i.e. blue path) b -> s) and path 2.

 

Otherwise, like the case below, we can choose path (1 -> a -> t) and path (1 -> b -> s).

 

Both cases are meet the requirement.

Thus we've proved the lemma. So we only need to make sure that every node except node 1 has at least 2 incoming edges. Then we can get the following solution if w is fixed:

For every node which has only 1 incoming edge, we record the start point of the incoming edge in an array. Then We scan all nodes in the ascending order of nodes' distances, and maintain the previous minima and second minima of w​ in an array val​, adding edges greedy. Note that we only need to maintain the index of w instead of its real value. This solution consumes O(n) to calculate for a fixed w, so the total complexity is O(nq).

To accelerate the solution, let's try maintaining array val while changing w. And we will apply all the changes in reverse order. That is, we only consider the case that w is decreasing.

According to the value of val, we can separate the sequence into many subsegments, and we can use std::set to maintain those subsegments. For one change in wk, it will affect a particular suffix of val​, so we can first find the suffix. Then we consecutively change the array val​​ until wk​ is greater than current subsegment's second minima. Next we will prove that the solution works in O((n+q)logn).

When we change a particular subsegment, we separate the operation into 3 types according to the relationship between wk and the subsegment's val.

If wk​​ is exactly the minima of the subsegment. This kind of operation may be done many times, but we will find that it won't change val at all. So we can do them at a time using segment tree. Thus in one change we will only do it at most 1 time.If wk is the second minima of the subsegment. Note the fact that every subsegment must has different second minima, so this kind of operation will be also done at most once in one change.If wk is neither the minima nor the second minima of the subsegment. Note the fact that each time we do it, except the first time, will make the number of subsegments decrease by 1. Thus this kind of operation will be done no more than n+q times.Using std::set and segment tree, all of these operations could be done in O(logn) at a time. Thus the total complexity is O((n+q)logn).

In conclusion, we can solve this task in O(mlogm+(n+q)logn).

solution1580F - Problems for Codeforcesidea: CQXYM

preparation: CQXYM

tutorial: CQXYM

If two numbers a,b satisfying a+b<m, there can only be one number not less than ⌈m2⌉. Consider that cut the cycle to a sequence at the first position p satisfying max(ap,ap+1)<⌈m2⌉. When we minus all the numbers that are not less than ⌈m2⌉ by ⌈m2⌉, we can get a sub-problem. However, If n is an even number, we may not find such a position p, but we can still get a sub-problem easily. For this problem on a sequence, we can divide the sequence into many segments, and each of them can not be cut by us anymore. There may be only 1 segment, and the first, last element of the segment are not less than ⌈m2⌉. There may be many segments, the length of the first one and last one are even, and the rest of them are odd. To solve the problem, we define the GF A,B. A is the GF of the length of the segments are odd situation, and B is the even one. If m is odd, the segment with only a number [m2] exists, and the GF of number of the sequence should be:

B2(∑i=0(A+x)i)+A=B21−x−A+AOtherwise, it is:

B2(∑i=0Ai)+A=B21−A+A.

To solve this problem, use NTT and polynomial inversion algorithm is just ok. Each time we transform a problem with limit m to m2, so the time complexity is O(nlognlogm).

solutionUPD: Chinese editorial can be found here.

Codeforces Round #744 (Div. 3) Editorial

By doreshnikov, history, 17 months ago, In English1579A - Casimir's String Solitaire

Idea: MikeMirzayanov

Tutorial1579A - Casimir's String SolitaireNote that no matter which action is chosen, after this action is performed

exactly one letter 'B' is erased from the stringexactly two letters in total are erased from the stringLet's denote the length of the string s by n. If n is odd, then described turns can not erase all the characters from the strings, because if he is deleting two letters on each turn, the length will always remain odd. For example, if the original length of the string is 5, then after one turn it will be equal to 3, and after two moves it will be equal to 1 in which case the next turn is impossible. Thus, if the length of the row is odd, the answer is NO.

If n is even, it will take exactly n2 steps to erase all characters from the string. Since each action removes exactly one letter 'B' from the string, the string can become empty only if there are exactly n2 letters 'B'.

Let us show that this condition is sufficient, that is, if a string has exactly half of the letters equal to 'B', then there always exists a sequence of actions leading to an empty string. Indeed, if a string of length n has exactly n2 letters 'B', exactly x letters 'A' and exactly y letters 'C', then x+y=n−n2=n2. Then Casimir can make x moves of the first type, each time removing the first occurrence of 'B' and the first occurrence of 'A', and y moves of the second type, each time removing the first occurrence of 'B' and the first occurrence of 'C'. After x+y=n2 such moves, the string will become empty.

Thus, checking that the number of letters 'B' in the string is exactly half of its length was enough to solve the problem.

Solution1579B - Shifting Sort

Idea: doreshnikov

Tutorial1579B - Shifting SortIn this problem, it was enough to implement an analogue of standard selection sort or insertion sort. Here is an example of a solution based on selection sort.

Let's find the minimum element in the array by simply iterating over it. Let's denote its index in the array by p1. If we apply a shift "1 p1 (p1−1)" to it, the following happens:a→[ap1,a1,a2,…,ap1−1,ap1+1,…,an]Once again, please note that all shifts are made in the left direction, so shifting by p1−1 to the left will put the element that was previously at index p1 in the first place.

Let us perform a similar shift for the second-largest element of the array, putting it in second place, for the third-largest element of the array, putting it in third place, and so on. More formally, let's describe the i-th iteration as follows:

At the beginning of the i-th iteration, the first i−1 elements of the array are its i−1 minimal elements, already in their correct places in sorted order.During the i-th iteration, the i-th largest element of the array is placed in the i-th place in the array.Since the first i−1 minimal elements are already in their places, the i-th largest element of the array is simply the smallest element among [ai,ai+1,…,an]. Let's find it by iterating over these elements and denote its index in the array a by pi.Make a shift "i pi (pi−i)". The first i−1 elements will not change, and the element from the pi-th place in the array will move to the i-th:a→[a1,…,ai−1,api,ai,ai+1,…,api−1,api+1,…,an]It is worth noting that the output format forbids shifting segments with l=r. Regarding this case, we should check the equality i=pi separately. If these two indexes coincide, then the i-th element is already in its place, and no shift should be done on this iteration.

Let us repeat this algorithm for i=2, i=3, ..., i=n−1. At each iteration, the new element will be shifted into its place in sorted order, and each iteration performs no more than one shift operation. Thus, in strictly less than n shifts, the array will be completely sorted.

The time complexity is O(t⋅n2).

Solution1579C - Ticks

Idea: MikeMirzayanov

Tutorial1579C - TicksFor each painted cell, we will determine whether it can be part of some tick of the allowed size. If some of the cells cannot be a part of any tick, the answer is obviously NO. Otherwise, let's match each colored cell with an arbitrary valid (entirely contained in the field under consideration and of size ≥k) tick containing it. Let's draw all such ticks, then the following holds:

no empty (white) cell of the field will be painted, since only ticks that do not contradict the field in question have been considered;every colored cell of the field will be covered by at least one drawn tick (at least the one we matched it with).Basically, this process gives us a field in which the set of painted cells matches the data in the input, which means that the field given in the input could have been obtained, in particular, in the way described above, and the answer is YES.In order to check that all painted cells are parts of some ticks, let's go through all possible ticks of size d≥k and for each tick mark all the cells included in it. If there is at least one unmarked painted cell in the end, it can't be a part of any valid tick, and the answer is NO.

To consider all possible ticks, we can iterate through all their possible center cells, that is, all the painted cells. Since smaller ticks are subsets of larger ticks with the same center cell it is sufficient to find the maximal size tick that can be constructed from that center cell. So for each painted cell we aim to find the maximal possible size of a tick with its center in this very cell.

Let us now consider a painted cell (i,j) as a possible center of some tick. By the definition of a tick, this cell can be a center of a tick of size d if for all h from 0 to d both cells (i−h,j−h) and (i−h,j+h) exist (are not out of bounds) and are painted. Let's iterate through h from 1 to i, and stop when the described condition is no longer satisfied. The largest h for which the condition is still satisfied gives us di,j — the maximum possible size of a tick with its center in (i,j). Now if di,j≥k, then such a tick is valid, and all the cells included in it should be marked. Otherwise, it could not have been drawn, and none of its cells should be marked.

After a complete check of all possible ticks in a given field, either there will be no unchecked painted cells and then the answer is YES, or at least one painted cell is not covered by any valid checkbox and then the answer is NO.

The time complexity is O(t⋅n2m).

Solution1579D - Productive Meeting

Idea: doreshnikov

Tutorial1579D - Productive MeetingFor the first conversation let's choose two people i and j with maximal values of sociability. Note that after this conversation takes place, we move on to a similar problem, but in which ai and aj are decreased by 1. After decreasing ai and aj by 1, we repeat the choice of the two people with the maximum values of sociability. Let us repeat such iterations while at least two people with positive sociability parameters remain.

Let us prove that this solution leads to the optimal answer. Let's denote the sum ∑i=1nai by S and consider two fundamentally different cases:

The maximal element a is greater than or equal to the sum of all remaining elements. That is, there exists i such that ai≥∑i≠jaj=S−ai. In this case, note that the i-th person can not possibly have more than S−ai conversations, because by that point all other people already reached their sociability limits and left the meeting.Thus, if ai≥S−ai, the answer cannot be more than (S−ai)+∑j≠iaj=2⋅(S−ai). Note that this estimation is accurate since an example exists in which i-th person talks to all other people as many times as possible (that is, aj times with j-th person for all j). And the algorithm described above will just choose the ith person as one of the participants of a conversation every time, because for every conversation both ai and ∑j≠iaj decrease by exactly 1, so the inequality holds and it follows that∀k≠i:ai≥∑j≠iaj≥ak.Otherwise, we can prove that the maximum number of conversations is always ⌊S2⌋. Obviously, it is impossible to get more than this number, since each conversation requires exactly two units of sociability (one from two people), while a larger answer would mean thatS=∑i=1nai≥2⋅(⌊S2⌋+1)>S,which is obviously wrong.Let us prove that this answer is achieved by the described algorithm. Let's look at the last conversation held. If there are at least two more people left in the meeting after it, we can hold another conversation, which means there is a more optimal answer. If there are zero people left in the meeting, then an estimate of S2 of conversations has been achieved. And if there is one person with a remaining sociability =1, then an estimate of S−12 of conversations has been achieved.

If there is exactly one remaining person i with a sociability residual >1, then we can guarantee that this person has participated in all previous conversations. Indeed, let's look at the last conversation — it was held between two people with the maximum parameters of the remaining sociability. But the i-th person has at least 2 sociability remaining, so it couldn't have been the other two people with residuals of 1 who left right after that. Thus, analyzing all conversations in reverse order, we can prove that at any time ai>∑j≠iaj, which means that it is in fact the case considered above.

We have proven that the described greedy algorithm works. This algorithm can be implemented by using any balanced search tree, such as std::set. By storing pairs of elements (ai,i) in it, we could for O(logn) each time choose the next two people to talk to and update the sociability values.

The time complexity is O(Slogn).

Solution1579E1 - Permutation Minimization by Deque

Idea: MikeMirzayanov

Tutorial1579E1 - Permutation Minimization by DequeWe'll process the permutation elements one by one.

For the first element, it doesn't matter which side of the deque we add it to, the result of its addition will be the same — there will be a sequence of one element (equal to the first permutation element) in the deque.

Now let's consider adding the i-th element of a permutation to the deque. First i=2 will be considered, then i=3, and so on up to i=n. Let us describe the general algorithm for choosing the side of the deque for each step. Note that if the elements [d1,…,di−1] are now in the deque, then all final permutations that can be obtained in the deque from the current state can be broken down into pairs of the form[…,ai,d1,…,di−1,…][…,d1,…,di−1,ai,…],where the beginning and the end of the final permutations, hidden behind "…", are obtained by the same sequences of all the following choices and thus are equal between the first and the second.

Note that when ai<d1 the first permutation will always be lexicographically smaller than the second one, and vice versa. Therefore, regardless of the following choices, if ai<d1 then the second permutation will never be minimal, and if ai>d1 then the first permutation will never be minimal.

This means that we can make a choice about the side of the deque to add the i-th element to based only on its relation to d1: if ai<d1, then ai is added to the beginning of the deque, otherwise — to the end.

The time complexity is O(n). Alternative solutions, which also fit in the time limit, involved finding a lexicographically minimal increasing sequence in the reversed original permutation and could be implemented either with O(nlogn) time complexity or with O(n) time complexity if the permutation's definition was taken into consideration.

Solution1579E2 - Array Optimization by Deque

Idea: doreshnikov

Tutorial1579E2 - Array Optimization by DequeLet's process the array elements one by one.

For the first element, it doesn't matter which side of the deque we add it to, the result of its addition will be the same — there will be a sequence of one element (equal to the first array element) in the deque.

Now let's consider adding the ith element of an array into the deck. First i=2 will be considered, then i=3, and so on up to i=n. Let us describe the general algorithm for choosing the side of the dec for each step. Note that if the elements [d1,…,di−1] now lie in the deck, then all final sequences that can be obtained in the deck from the current state can be broken down into pairs of the form[…,ai,d1,…,di−1,…][…,d1,…,di−1,ai,…],where the beginning and the end of the final sequences hidden behind "…" are obtained by the same sequences of all the following choices and, respectively, coincide.

Note that since the prefix and suffix hidden behind the dots completely coincide in the two sequences under consideration, as well as the set of numbers in the central part coincides, the numbers of inversions also coincide:

inside the prefix and inside the suffix;between elements of the prefix and elements of the suffix;between elements of the prefix or suffix and elements of the central part.The difference between the number of inversions in the first and second sequence consists only of the difference between the number of inversions in their central part. So, we can determine at the stage of adding ai to the deque, which direction of its addition is guaranteed not to lead to the optimal answer and choose the opposite one.

If ai is added to the beginning of the deque, the number of inversions in the central part will increase by the number of elements in the deque strictly smaller than ai, and if we add it to the end of the deque, it will increase by the number of elements in the deque strictly larger than ai. Let us make a choice such that the number of inversions increases by the minimum of these two values.

To quickly find the number of elements smaller or larger than ai, we will store all already processed array elements in a structure that supports the element order search operation, such as __gnu_pbds::tree. Besides using this structure specifically, you can

write any balanced binary search tree (such as a Cartesian tree);sort all numbers in the input array and compress them to values [1,n], preserving the "≤" relation, then build a segment tree on them, storing in the node [l,r) the number of array numbers already processed by the deque with values between l and r.Requests to update and get an order in such structures take O(logn) time, and the construction takes at worst O(nlogn), so the time complexity of the algorithm is O(nlogn).

Solution1579F - Array Stabilization (AND version)

Idea: doreshnikov

Tutorial1579F - Array Stabilization (AND version)We'll consider an arbitrary index of the array i and see what changes happen to ai during several steps of the described algorithm. Let's denote by ak the value of the array after k steps of the algorithm and prove by induction that aki is the logical "AND" of k+1 elements of the array a, starting from i with step d to the left, that isaki=ai&a(i−d)modn&…&a(i−kd)modnBase of induction: for k=0 the element of the original array a0i is ai. For clarity we can also show that the statement is true for k=1: during the first step ai is replaced by ai&a(i−d)modn by the definition of cyclic shift by d to the right.

For simplicity, we will omit the "modn" operation in the following formulas but will keep it in mind implicitly. That is, ai−kd will imply a(i−kd)modn.

Induction step: let the above statement be true for k−1, let us prove it for k. By the definition of cyclic shift aki=ak−1i&ak−1i−d. And by the induction assumption, these two numbers are equal toak−1i=ai&…&ai−(k−1)dak−1i−d=ai−d&…&ai−kdSince the logical "AND" is an idempotent operation, that is, it does not change its result when repeatedly applied to any argument, then aki that is equal to their logical "AND" is also equal toaki=ai&ai−d&…&ai−kd,which is what we wanted to prove.

It follows from this formula that ai turns to zero after the k-th step if and only if ai=1, ai−d=1, ..., ai−(k−1)d=1, and ai−kd=0. Up to the k-th step all elements will be equal to 1, and so their logical "AND" will also be equal to 1. As soon as 0 appears in the sequence in question, the logical "AND" will also become zero.

Thus, we reduced the problem to finding the maximal block of elements equal to 1 of the pattern ai=ai−d=ai−2d=…=ai−(k−1)d=1. Note that by shifts of d the array splits into gcd(n,d) cyclic sequences of this kind, each of length ngcd(n,d). Let's look at these cyclic sequences independently from each other and iterate over each of them in linear time complexity to find the maximal block of consecutive elements equal to 1 — this will be the answer to the problem.

Remember to check that if at least one of these sequences consists entirely of elements equal to 1, its elements will never zero out, and the answer in such case is -1.

The time complexity is O(n).

Solution1579G - Minimal Coverage

Idea: doreshnikov, MikeMirzayanov

Tutorial1579G - Minimal CoverageOne possible solution involves the method of dynamic programming. As a state of DP we will use the number of already placed segments i, and the distance l from the "end" of the last segment to the current left boundary of the coverage, and in the DP we will store the minimal possible distance from the "end" of the last segment to the current right boundary of the coverage.

We can prove that the answer never exceeds 2⋅lmax, where lmax=max(a) is the maximal length of the segments. To do this, let us define a region of length 2⋅lmax, specifically the segment [−lmax,lmax]. If the "end" of the last segment has a coordinate x>0, we put the next segment to the left, otherwise, we put it to the right. With this algorithm, none of the "end" endpoints of the segments will go beyond the marked boundaries, because to do so, the segment must be placed from the coordinate of one sign beyond the boundary of the opposite sign, and thus must have a length greater than lmax which contradicts how we defined lmax.

Using this fact, we will consider the DP dpi,l for 0≤i≤n and 0≤j≤2⋅lmax as the minimum distance between the "end" of the i-th segment and the right boundary of the axis coverage of the first i segments when the distance to the left boundary of the coverage equals to l. The "end of the 0-th segment" here is the "beginning" of the first one, that is, the point 0.

The base of DP is dp0,0=0, since when no segments are placed, the coverage boundaries and the current point 0 are all coincident. Next, we consider the forward dynamic programming relaxation: for every (i,l) there are two cases to consider, the case of the next segment being placed to the left and the case of it being placed to the right (value r below refers to the distance to the right boundary of the coverage and is an alias for dpi,l):

If a segment of length ai+1 is placed to the left side, then the new distance to the left boundary will be equal to max(0,l−ai+1), and distance to the right boundary will always be r+ai+1, which gives us the relaxation formuladpi+1,max(0,l−ai+1)←dpi,l+ai+1If a segment of length ai+1 is placed to the right side, then the new distance to the right boundary will be equal to max(0,r−ai+1), and distance to the left boundary will always be l+ai+1, which gives us the relaxation formuladpi+1,l+ai+1←max(0,dpi,l−ai+1)The values in array dp can be calculated in ascending order by i. Then the answer for the problem can be found as the minimum sum of l and r in the last row of dp, that is minll+dpi,l.

The time complexity is O(n⋅lmax).

Solution

Codeforces Round #743 Editorial

By Asymmetry, 17 months ago, In English1573A - CountdownLet s be the sum of all digits. In one operation we can decrease s by at most 1 and we are finished iff s=0. This leads us to a conclusion that it is always unoptimal to decrease the number on the clock, when the least significant digit shows 0, since it will cost us at least 9 more operations.

Using this observation, the following strategy turns out to be optimal:

if the least significant digit is positive, decrease the number by 1if the least significant digit equals 0, swap it with some positive digitLet p be the number of digits that are positive and aren't the least significant digit. Our answer will be s+p. This can be computed in O(n).

Prepared by Asymmetry

1573B - SwapsSince the array a has odd numbers and array b has even numbers, then they will differ at the first position no matter how we perform the operations. It follows that in order to make the first array lexicographically smaller than the second one we need to make the first element of a smaller than the first element of b. To move the i-th element of an array to the first position we can perform the operation on elements i−1, i−2, ..., 2, 1, which is optimal. The answer is then the minimum of i+j−2 over all ai, bj such that ai<bj.

Now we will think how to calculate this effectively. Let pi be the position of number i in its respective sequence (a for odd and b for even). We will go through the numbers from biggest to smallest. Let l be the position of the leftmost number in sequence b that was already considered. If i is even we will set l to min(l,pi). If i is odd we will set answer to min(answer,pi+l).

Our total time complexity is then O(n).

Prepared by Markadiusz1572A - BookThere are two main solutions in this task.

The first solution simulates the process of reading the book. Let ri be the number of chapters that need to be understood in order to understand i-th chapter. We will keep this array updated during the simulation. Now we will simulate the process by keeping a set of chapters that are ready to be understood. Suppose we have just understood chapter x. We will update array r by iterating over all chapters that require x to be understood. If some chapter becomes ready to be understood, we will insert it to the set. Then, we will lowerbound on our set to the next chapter that can be understood and when we hit the end, the answer increases by one and we come back to the beginning.

The entire process runs in O(nlogn).

The second solution is more graph based. We will construct a graph, where there is a directed edge from a to b if chapter b is needed to understand chapter a. This edge has weight 0 if a>b and 1 otherwise. The answer is the length of the longest weighted path in this graph incremented by 1. If there exists a cycle we should output −1. If the graph is a DAG, we can use toposort and a simple DP to calculate the answer.

This solution works in O(n)Prepared by Asymmetry1572B - Xor of 3If the xor of all numbers in the array equals 1 it is impossible to make everything equal to 0, since the parity of all numbers doesn't change after an operation. From now on we will assume that the xor of all numbers equals 0.

Lets consider the case when n is odd. We can perform operations on positions 1,3,...n−4,n−2. After this for every even i, ai−1=ai. Additionally, an=an−1=an−2=0. Second one is true since the xor of all numbers equals 0. Now we can perform operations on positions n−4,n−6,...3,1. This will make the array equal to 0.

In the case of even n we will find a prefix of odd length and even xor of numbers and call the above solution on it and its respective suffix. If there is no such prefix, the solution doesn't exist. Here is a proof of it. Assume that every prefix of odd length has an odd xor. This means that a1=an=1 and for every even i<n, ai=ai+1. Consider an operation on an even position i (odd is analogous). We know that ai=ai+1 so after this operation ai and ai+1 will be set to ai+2. This means that after every operation for every even i<n, ai=ai+1 still holds. Thus we will never be able to make a1 equal to 0 since performing an operation on it won't change it.

Summing up, we perform no more than n operations and our solution runs in O(n)Prepared by Markadiusz, Monogon and Asymmetry1572C - PaintFirstly, we can notice that when we modify a segment of the form [a,b,a] and change it to [a,a,a] by performing the operation on the second element, as opposed to performing the operation first on the third element and then on the second element (like so [a,b,a]→[a,b,b]→[a,a,a]) we avoid using one unnecessary operation. In our solution we will try to maximize the number of operations that we didn't have to perform.

Let dp[i][j] be the maximum number of operations that we can avoid on the interval from i to j, while making all of its elements have the same color. Then the answer to the problem will be n−1−dp[1][n]. For i≥j we have dp[i][j]=0 and for i<j dp[i][j] will be the maximum of dp[i+1][j] and max(1+dp[i+1][k−1]+dp[k][j]) over i<k≤j such that a[i]=a[k]. It's because we can either not save any operations on the i-th element and just take the answer from the interval [i+1,j] or we can save one operation while coloring the segment from i to k and take the answer from segments [i+1,k−1] and [k,j]. Because each color occurs in a at most 20 times, we can calculate this dp in O(20n2) which is also our final time complexity.

Prepared by Markadiusz1572D - Bridge ClubLet's make a graph in which the vertices are the players and there is an edge of weight ai+aj between the i-th and the j-th player if they can play together. We can notice that the problem can then be solved by finding a matching of size at most k with the biggest sum of weights in this graph.

To solve this problem efficiently we can make the following observations:

1. The graph is bipartite.

This stands from the fact that if two players disagree at exactly 1 topic then the numbers of positive views that they hold have different parities.

2. We can limit ourselves to considering only the (2n−1)(k−1)+1 edges with the biggest weights.

We can prove this with a proof by contradiction. Firstly, we can notice that if we use a particular edge in the matching then we prohibit ourselves from using at most 2(n−1) other edges with each of the matched vertices being incident to exactly n−1 of those edges, because each vertex has degree n in this graph. Now we can see that if we were to use an edge that's not one of those (2n−1)(k−1)+1 best ones, then we can just replace it with one of those best ones, because we know that at least one of them will not be prohibited.

Combining those two observations we are left with a bipartite graph with O(nk) edges and O(nk) vertices in which we can find a matching with maximum cost and size at most k with for example one of the standard min cost max flow algorithms (we can look for a matching of size k because all edges have non-negative weights).

The only problem that's left for us to solve is efficiently selecting those best edges. Because there are O(n2n) edges in total we cannot use a standard sorting algorithm as that would run in O(n22n). Instead we can for example use the quick select algorithm which solves this problem in O(n2n).

Our final time complexity is then O(n2n+nk2log(kn)).

Prepared by Markadiusz1572E - PolygonWe are going to binary search the answer.

Lets say that we want to check whether we can obtain k+1 regions with area of at least w. From now on a correct cut means a cut that will cut off a region with area of a least w.

Lets consider some interval of vertices (i,j). We will cut it off virtually using a cut from i to j. We would like to know how many correct regions we can obtain by performing cuts only in this interval. The area next to the virtual cut is considered a leftover. Given two sets of correct cuts in this interval it's always optimal to choose the one with more cuts and if they have the same amount of cuts, the one with the bigger leftover.

This observation leads us to a dynamic programming solution. Let dpi,j be a pair (ri,j,li,j) where ri,j means the biggest amount of regions and li,j the biggest leftover we can obtain by performing cuts in the interval (i,j).

To calculate this dp we will iterate over all vertices k such that i<k<j and consider vertex k as one of the vertices that are included in the leftover region. This is a simple transition from states dpi,k and dpk,j. After we calculate our dp state we can safely cut this interval off if li,j≥w.

Iff r1,n≥k+1 the answer equals at least w.

This solution runs in O(n3log(1016)).

Prepared by Asymmetry and Markadiusz1572F - StationsWe will maintain the array b on a range add/sum segment tree. Queries are done then in O(logn) per query.

Now lets focus on the station rebuilds. Lets maintain an array w, which means how far a station can broadcast information including the fact that some stations might block the signal. When a station is rebuild in city ci we need to perform a min operation on interval (1,ci−1) with value ci−1. Next we have to set wci to gi. These are all changes to array w that happen during a single rebuild.

Now we want to keep array b up to date. We need to know what has been changed and a list of changes to array w is all we need. When setting wci to gi we can add 1 on interval (ci,gi). This is fast enough to do with a single operation on array b, since we do this once for every rebuild. Lets say that wj was decreased as a result of the min operation. To update array b accordingly we should subtract 1 on interval (ci,wj).

Sadly, performing a subtraction on b for every value in array w that has changed during the min operation one by one is too slow and we can't afford it. Thankfully, we can speed this up. First, we will think how to keep array w updated. We can use segment tree beats to perform the min operation. Recall that during the min operation we get to know what elements and how many times have changed. This is traditionally used to update the sum over interval information. Now we are going to use it in a different way. Lets say that value r was decreased p times in a node where we perform a tag. To keep array b updated we only need subrtact p from interval (ci,r).

Lets think about the complexity now. Segment tree beats with min and set point operations run in amortized O((n+q)logn) meaning that we will perform at most this many changes on array b. This leads us to our total time complexity of O((n+q)log2n).

Prepared by Asymmetry

Codeforces Round #742 Editorial

By flamestorm, 18 months ago, In EnglishThank you for participating in our contest! We hope you enjoyed it. UPD: Implementations have been added.

1567A - Domino Disaster

Solution1567A - Доска с доминоIf there is a vertical domino (either U or D) in the current slot, then the corresponding domino half in the other row must be a D or a U, respectively. Otherwise, we can just fill the rest of the row with copies of LR.

Time complexity: O(n).

Implementation (C++)Video Solution1567B - MEXor Mixup

Solution1567B - MEXor массиваFirst consider the MEX condition: the shortest array with MEX a is the array [0,1,…,a−1], which has length a. Now we'll consider the XOR condition. Let the XOR of the array [0,1,…,a−1] be x. We have three cases.

Case 1: x=b. Then we don't need to add any elements to the array, so the answer is a.

Case 2: x≠b and x⊕b≠a. Then we can add the element x⊕b to the array since x⊕b≠a, so the MEX will still be a. The XOR of the array will then be x⊕x⊕b=b. The answer is a+1.

Case 3: x≠b and x⊕b=a. Then we cannot add the element x⊕b to the end of the array. We can just add x⊕b⊕1 and 1, so the XOR of the array will be x⊕x⊕b⊕1⊕1=b. The answer is a+2.

Time complexity: O(n) precomputation and O(1) per test case if you precalculate the XOR of the numbers from 0 to n−1, or O(1) if you use the well-known formula for it.

Implementation (C++)Video Solution1567C - Carrying Conundrum

Solution (Observation)1567C - Carrying ConundrumNote that in every other column, the addition Alice performs is correct. Therefore, we can take our number, split it into alternating digits, and then find the answer.

For example, consider n=12345. We split it into alternating digits: 12–34–5→135,24. Now the problem is equivalent to find the number of pairs of numbers which add to 135 multiplied by the number of pairs of numbers which add to 24. It's clear each pair works: for example, 45+90=135 and 9–+15–––=24–––, so 49–5+1–95–0 will be equal to 12345 according to Alice.

Now, how many ways are there to find a pair of non-negative integers whose sum is n? There are clearly n+1 ways: n+0,(n−1)+1,(n−2)+2,…,0+n.

Therefore, suppose we split n into two numbers a and b. Then the answer will be (a+1)(b+1), but we should subtract 2 because those correspond to either the first or second number in the sum being 0. As a result, the answer is (a+1)(b+1)−2.

Time complexity: O(log10n)=O(logn).

Implementation (C++)Video SolutionSolution (DP)There exists a dynamic programming solution to this problem. Let x be the length (number of digits) of n, and dpi,j,k be the number of pairs of integers (x,y) that add up to the digits from position i to x−1 (0-indexed), with j carried over from the addition one place to the right, and k carried over from the addition at position i. Notice that 0≤j,k≤1, as the maximum addition value with carry in a single digit's place is 19, and thus the maximum carry value is ⌊1910⌋=1.

Now, we can iterate from rightmost digit to leftmost, i.e. from digit x−1 to 0. We can further iterate over all pairs of digits in the addition for the current column, as well as the carry values from both one and two columns to the right, and thus, we can find the number of states that contribute to our current state.

Our answer can be found in dp0,0,0, however, we must subtract 2 from this as it includes the invalid pairs (0,n) and (n,0).

Implementation (C++)1567D - Expression Evaluation Error

Solution1567D - Своеобразная система счисленияLet's greedily construct the largest possible sum for Alice, digit by digit. That is, the leftmost position should have the largest value possible, then the second-leftmost position, and so on.

The maximum value of the leftmost digit of Alice's sum is clearly equal to the leftmost digit of the number s, since it cannot be larger. Similarly, the maximum possible value for the second-leftmost digit in Alice's sum cannot be larger than the corresponding digit in s, and so on. In general, Alice's sum cannot be larger than the number s when interpreted as a base-11 number.

So how can we maintain the sum of s when we express it as a sum of n numbers? The idea is to split s into a sum of powers of 10. For example, if s=25, and Bob writes down [10,10,1,1,1,1,1]. Then Alice will not have any carries, and so the answer will just be s interpreted as a base-11 number.

But what if we need to write down more numbers than the sum of the digits of s? Then, we're forced to split a power ten into units. When we split a power of 10, it can be seen that we should split the smallest power of 10 that isn't 1 (call it 10k) as 10k−1 and 9⋅10k−1. We can check all powers of 10, and it can be shown that this is the best way to split.

For example, if s=21 and n=4, then we do the following process: [21] to [20,1] to [10,10,1] to [10,9,1,1]. If s=110 and n=3, we do the following process: [110] to [100,10] to [100,9,1]. Note that, in this last case, splitting 10=9+1 is better than splitting 100=90+10, since the sum of 10011+911+111=10A11, and 9011+1011+111=A111.

Time complexity: O(n2log10(s)) if you lazily iterate over all currently split numbers, or O(nlognlog10(s)) if you use a priority queue.

Implementation (C++)Video Solution1567E - Non-Decreasing Dilemma

Solution1567E - Заурядные запросыNote that if there exists a non-decreasing array of length x, then it contains x(x+1)2 non-decreasing subarrays. Therefore, we can break our solution down to counting the lengths of the non-decreasing "chains" within the queried subarray.

We can solve this problem using a data structure called a segment tree. On each node of this segment tree, we shall maintain four pieces of information:

⋅ the length of the longest non-decreasing prefix.

⋅ the length of the longest non-decreasing suffix.

⋅ a boolean flag denoting if the entire segment is non-decreasing.

⋅ the total number of nondecreasing subarrays not part of the longest prefix or suffix.

I won't explain the merging process here (you can examine the implementation below), but it is not too complex.

Using this, we can traverse the segment tree, from the left of our queried range to the right, while maintaining the number of non-decreasing subarrays in the prefix of the range and the length of the outgoing non-decreasing suffix to get our answer.

Time complexity: O(qlogn).

Implementation (C++)Video Solution1567F - One-Four Overload

Solution1567F - Непереводимое названиеLet's look at the numbers in the grid modulo 5. 1 and 4 are 1 and −1 modulo 5, and by definition each marked cell must be 0 modulo 5. This means that each marked cell must have an even number of unmarked neighbors, and there must be an equal number of 1s and 4s among those neighbors.

In other words, the problem is about two-coloring a grid so each marked square has the same number of red and blue neighbors. If each cell is adjacent to 2 or 4 unmarked cells, then they will form a graph whose faces are two-colorable (the proof of this is below), which will satisfy all conditions, since all cells adjacent to 2 unmarked cells will be adjacent to two cells on opposite faces. However, the tricky case is to deal with cells with 0 unmarked neighbors.

The idea is to put a "mask" on top of the grid, which will also allow the cells with no unmarked neighbors to satisfy the condition while not interfering with already placed cells. That is, in the coloring terminology above, we will two color the grid, and then flip some cells according to the "mask" such that

all cells with 2 or 4 unmarked neighbors still satisfy the condition, andall cells with 0 unmarked neighbors now satisfy the condition.We claim that we should flip all cells in all even-numbered columns; that is, the mask should contain columns alternately colored red and blue. Let's prove this works.

There are four types of marked cells:

a marked cell with no marked neighbors: all four neighbors are in same connected component, so none of them will be "flipped" with respect to the rest, and they will work: they will be the numbers 1,4,1,4 by the mask. For this to hold true, when we make connected components, we need to DFS/BFS diagonally as well.a marked cell with only marked neighors: nothing to check.a marked cell with marked neighbors in the shape of an L tromino: again, these unmarked cells must be part of same connected component, so they will work: they will be the numbers 1 and 4 by the mask. For this to hold true, when we make connected components, we need to DFS/BFS diagonally as well.a marked cell with marked neighbors in the shape of an I tromino: then the cell on one side is necessarily in a different connected component than the other, so one will be flipped by the two-coloring, and they will be the right parities.It suffices to show that the graph formed by edges between connected components of unmarked cells is bipartite.

Consider instead the graph formed by the marked cells, with an edge between orthogonally adjacent cells. Consider each connected component of this graph individually. By the condition all vertices have degree 0, 2, or 4, but none can have degree 0 because the graph is connected. Now by a theorem of Euler this graph must have a Eulerian cycle.

Now we have a more general claim: the face-vertex dual of a Eulerian graph is bipartite. Suppose otherwise. Then the dual has some odd cycle. This means that some face of the dual must be bounded by an odd number of edges, since you can never "split" an odd cycle into only even ones. Also, the dual is planar, because our original graph is obviously planar (we are given an explicit planar embedding of it!).

Now some face of the dual has an odd number of edges. This means that in the dual graph of the dual, some vertex has odd degree. But the dual graph of the dual is the original graph. So the original graph is both Eulerian and has odd degree, which is absurd.

Finally, even though there are many connected components, it is clear that they do not interact: just set the infinite outside face to be one color, and the rest of the faces will be colored automatically.

Therefore this graph is bipartite, so we can two-color as desired, and we are done. Time complexity: O(mn).

Implementation (C++)Video Solution

Editorial of Codeforces Round 741 (Div. 2)

By Wind_Eagle, 18 months ago, In EnglishWill we, will you...Can we, can you, can we change?

1562A - The Miracle and the Sleeper

Hint 1Hint 2Solution1562A - The Miracle and the SleeperIt's not hard to see that if l≤⌊r2⌋+1, then rmod(⌊r2⌋+1)=⌊r−12⌋. It can be shown that the maximal possible answer.

At the same time, let the segment not contain number ⌊r2⌋+1, that is, l>⌊r2⌋+1. Then we can show that the maximal answer is rmodl=r−l.

Asymptotics: O(1) per test case.

Code C++ (Wind_Eagle)1562B - Scenes From a Memory

Hint 1Hint 2Solution1562B - Scenes From a MemoryLet's show that if a number has three digits, you can always remove at least one from it to get a number that is not prime. This can be proved by a simple brute-force search of all numbers with three digits, but we'll try to do it without a brute-force search.

In fact, if a number contains the digits '1', '4', '6', '8' or '9', then that one digit is the answer, because 1, 4, 6, 8 and 9 are not prime numbers.

Now let's see what happens if the number doesn't have those digits. Then, if the number has two identical digits, we have found an answer of size two — the number of two identical digits (22, 33, 55, or 77) is divisible by 11. Also, if the digits 2 or 5 are not at the beginning of the number, we again have found an answer of size two — the number of two digits ending in 2 or 5 is not prime.

If none of the above cases worked, then we find that a three-digit number has one of the following values: 237, 273, 537, 573. It is not difficult to see that these numbers have two digits, which form a number, that is divisible by three.

Thus, the maximum answer is two, that is, you can leave no more than two digits in the number. You can find these digits by considering the above cases, or you can just try.

It can be shown that such a brute-force solution will work for O(k).

Asymptotics: O(k) per test case.

Code C++ (Wind_Eagle)Additional Problem 1Solution of Additional Problem 1Finding an answer consisting of one digit works in O(k). Now let's see how long the loop takes to complete. Indeed, it is easy to see that once the pairs of indexes (0,1), (0,2), and (1,2) are considered, an answer will always be found. This is so because in any number of three digits you can find an answer consisting of two digits (this was proved earlier). So this is equivalent to removing all but the first three digits, and then solving the problem for them (assuming that the length of the optimal answer is two).

Additional Problem 2Solution of Additional Problem 2Let's take the string \t{3737 \ldots 37} as a string. We will search pairs of indices in the following way: first we will search all pairs of indices with different parities, and then all pairs of indices with the same parity. It is easy to see that such a search will work for O(k2) for one test case, because all pairs of indices with different parity will give numbers 37 and 73, which are prime, and there are O(k2) such pairs.

1562C - Rings

Hint 1Hint 2Solution1562C - RingsLet us first consider the boundary case. Let a string (hereafter we will assume that the string length n) consists of only ones. Then we can output the numbers 1 n−1 2 n as the answer, since there will be the same substrings.

Now let's figure out what to do in the other case. Let's call the substring [1 ... ⌊n2⌋] the left half of the string, and the substring [⌊n2⌋+1 ... n] the right half of the string. Then there are two cases:

There is 0 in the left half of the row, and its position is k. Then we can take the numbers k n k+1 n as the answer, since they are the same numbers, just the second number has an extra leading zero.There is 0 in the right half of the row, and its position is k. Then you can take the numbers 1 k 1 k−1 as the answer, since the second number — is the first number multiplied by two (multiplying by two in binary is equivalent to adding one zero to the right).Asymptotics: O(n) per test case.

Code C++ (Wind_Eagle)Additional Problem 1Solution of Additional Problem 1The solution would not change in any way. In fact, in a number system with base k, adding a zero to the left side does not change the number (multiplication by 1), but adding a zero to the right side increases the number k times (multiplication by k).

Additional Problem 2Solution of Additional Problem 2In fact, the problem gets a little more complicated. For example, consider this test: \t{111000000}. In this case, we could not output 4 9 5 9 because zero is not divisible by zero.

We will perform the old solution, but check that we are not trying to divide zero by zero (if we divide something by zero, we will swap the numbers). And if the answer is not found, then either the whole left half of the string consists of zeros, or the whole right half. Let the leftmost unit have position p1, and the rightmost unit ~--- position p2. Then in the first case you can output 1 p2 2 p2, and in the second case~--- p1 n p1 n−1.

It is not hard to see that such a solution will always find the answer.

In fact, we can solve the problem even simpler: when we meet zero in the left half, we additionally check whether there is at least one one among the characters on the right. If there is, we print the answer, otherwise we move on. Similarly, when we encounter zero in the right half, we additionally check if there is at least one one among the characters on the left. We can show that this solution will also always find the answer.

It is interesting that we have solved \textbf{a stronger version of the problem}, since the solution we obtained works correctly for the old problem as well.

1562D1 - Two Hundred Twenty One (easy version)

Hint 1Hint 2Hint 3Solution1562D1 - Two Hundred Twenty One (easy version)Let's prove everything for a particular segment of length n. And at the end, we'll show how to quickly solve the problem for many segments. Let n — the length of the segment, and let a — the array corresponding to the segment (ai=1 if "+" is at the ith position in the segment, and ai=−1 if "-" is at the ith position in the segment).

Introduce a new array b, with bi being equal to the signed sum on the whole array if the i-th element was removed from it.

Then:

The parity of the length of the segment and the parity of the number of elements to be removed from it are the same.It is not difficult to show that |bi−bi+1|=0 if ai=ai+1, or |bi−bi+1|=2 otherwise. Proof of this fact: Let ai=ai+1. Then it is easy to see that when ai is removed, the segment will look exactly the same as when ai+1 is removed. So |bi−bi+1|=0. Now let ai≠ai+1. Denote by f(l,r) the sign-variable sum on the interval l to r, taking into account the sign (i.e. if l is odd, the first number is taken with the plus sign, otherwise with the minus sign). Then it is easy to see that bi=f(1,i−1)±ai+1∓f(i+2,n), and bi+1=f(1,i)∓f(i+2,n). Hence, if we consider the two cases (ai+1=1 and ai+1=−1), we see that |bi−bi+1|=2.If n is odd, then there exists such k that bk=0. Let us prove this: If b1=0 or bn=0, then the statement is proved. Now let b1<0 and bn>0. Then, since the neighboring values in the array b differ by no more than 2, and all elements are even, then there is bound to be zero between the first and last element. The case b1>0,bn<0 is proved similarly. If n>1, then there cannot be such a case that b1>0 and bn>0, and there cannot be such a case that b1<0 and bn<0. In fact, let the sign-variable sum of the whole segment be s. Then b1=−s±1 and bn=s±1. Since b1 and bn are even numbers, therefore either at least one of them is zero, or they are of different signs.Thus the final result is: if the sign-variable sum is already zero, output zero; otherwise, if the segment is of odd length, output 1; otherwise, output 2.

To quickly determine the sign-variable sum, we use the prefix-sum.

Asymptotics: O(n+q) per test case.

Code C++ (Wind_Eagle)1562D2 - Two Hundred Twenty One (hard version)

Hints 1-3Hint 4Hint 5Solution1562D2 - Two Hundred Twenty One (hard version)We will use the facts already obtained, given in the solution of problem D1.

To quickly check the value of the sign-variable sum on the segment with deletion of one element, slightly modify the prefix-sum. We will not concentrate on this in detail; you can see how to make it in the solution.

Now let's see how to search for a matching element inside an odd-length segment. We will do this with a binary search. Suppose initially l=1, r=n, and we know that the numbers b1 and bn are different signs, or one of them is zero.

Now consider the following algorithm:

Find m equal to ⌊l+r2⌋.If bl=0, or bm=0, or br=0, then the answer is found.Otherwise, either the numbers bl and bm have different signs, or the numbers bm and br have different signs. In the first case, assign r to m, in the second case, assign l to m.This algorithm will stop sooner or later and produce an answer, since we know that the matching item exactly exists. This can be shown using the fact that |bi−bi+1|≤2, and all bi are even.

So finally we have the following solution: if the sign-variable sum is already zero, output zero; otherwise, if the segment is of odd length, search for a suitable element by the above algorithm; otherwise, take, for example, the left boundary of the segment as the first element to remove, and search for the second element using the above algorithm on the segment without a left element.

Asymptotics: O(n+q⋅log(n)) per test case.

Code C++ (Wind_Eagle)Interesting question1562E - Rescue Niwen!

Hint 1Hint 2Hint 3Solution1562E - Rescue Niwen!The constraints on the problem were chosen so that solutions slower than O(n2⋅log(n)) would not get AC, or would get with difficulty. The solution could be, for example, to sort all substrings by assigning numbers to them, and then find the largest increasing subsequence in the resulting array.

Let us describe the solution for O(n2). The most important thing required for the solution is to understand what the largest increasing subsequence should look like.

Let s — a string, and n — the length of the string s.

It can be shown that if the largest increasing subsequence has a substring [l ... r], then it also has a substring [l ... n]. I will not give a formal proof, I will only give the key idea. Let the increasing subsequence first have the string [l1 ... r1], and then the substring [l2 ... r2], with r1≠n. It can be understood that if suffixes [l1 ... n] and [l2 ... n] have some common prefix, and it has already been included in the largest increasing subsequence, then we can «drop» the prefixes of the suffix [l1 . . n], and instead of them write exactly the same suffix prefixes of [l2 ... n], and the size of the increasing subsequence will not change, and the condition above will be satisfied. If, however, the suffixes [l1 ... n] and [l2 ... n] have no common prefix, then we could take the suffix itself [l2 ... n] together with its prefixes, and the answer would only improve.

Thus, the largest increasing subsequence looks like this: first comes some substring [l1 ... r1], followed by a substring [l1 ... r1+1], and so on, ending with the suffix [l1 ... n]. After that comes some substring [l2 ... r2], followed by a substring [l2 ... r2+1], and so on, ending with the suffix [l2 ... n], and so on. Moreover, knowing which suffixes are included in this subsequence, we can establish all other substrings. Indeed, let the suffixes [l1 ... n] and [l2 ... n] be included in the sequence, and l1 < l2. Then it is not difficult to see that the suffix prefixes [l2 ... n] can be typed greedily, namely, to take all substring [l2 ... k] such that they are larger than the suffix [l1 ... n].

Note that if the substring [l2 ... m] is larger than the suffix [l1 ... n], then the substring [l2 ... m+1] is also larger than the suffix [l1 ... n]. And so, we can use the following algorithm to find out r2, that is, to find out which suffix prefix [l2 ... n] to start typing the subsequence. Let dl1,l2 — be the size of the largest common prefix of suffixes [l1 ... n] and [l2 ... n]. Then it is easy to see that if the suffix [l2 ... n] is larger than the suffix [l1 ... n], then the appropriate r2 is dl1,l2+l2, which means that you must start typing all substrings, starting from the one that differs from the largest common prefix of the two suffixes.

So now we are left with two problems. The first is — you have to learn to quickly recognize the greatest common prefix of the two suffixes. The second is — to write a DP that would allow you to recognize the answer.

Let's see how to solve the first problem. You can use different string algorties, such as a suffix array. Or we can write a simple DP that calculates an array d of the largest common prefixes over O(n2). The transitions in this DP and its implementation can be seen in the author's solution code (lines 37-48).

Now about the DP that calculates the answer. Let us use the facts above and do the following. Let dpi denote the size of the answer if the last substring in it is the suffix [i ... n]. Let dp1=n, and then dpi=n−i+1. Now let's do the following. We will go through i from 2 to n, doing the following simple steps: for each j from 1 to i−1 (j denotes the previous suffix in the answer) we will check how many substring of the suffix [i ... n] we can take: if the suffix [i ... n] is larger than the suffix [j ... n], we calculate this number with the above described algorithm, using the d array of largest common prefixes. Otherwise, we will not update, because the suffix [i ... n] is less than or equal to the suffix [j ... n], we cannot take it in response. It is not difficult to guess that the answer is maximal in all dpi.

Thus, the problem is solved using two uncomplicated dynamics.

Asymptotics: O(n2) per test case.

Code C++ (Wind_Eagle)Interesting question1562F - Tubular Bells

Hint 1Hint 2Hint 3Hint 4Hint 5Solution1562F - Tubular BellsAs I know, there are simpler solutions to this problem, but I will describe my solution.

We can assume the whole array is randomly permutated, because we can make queries by renumbering it. We also pre-calculate all prime numbers smaller than 200000.

Let us denote something: n — the number of numbers in the array, a — the array itself, l — the smallest value in the array, r — the largest value in the array.

So let's look at three cases:

n<100. We use the following simple solution: find out the lcm of all pairs of numbers. The greatest of these values will give us the pair of numbers r−1 and r. It is easy to find out which number r is: all pairs of lcms of this number with others will be divisible by r. Now exclude r from the array, and exclude all pairwise lcms with it. The highest value will give us a pair r−1 and r−2. Repeat this algorithm until all numbers are found.100≤n<10000. Solve for ⌈3n2⌉ queries. We ask for lcms of pairs of numbers: the first with the second, the third with the fourth, etc. Now we will look for the maximal prime multiplier in each such lcm. We will do it by using pre-calculated prime numbers. Since the array is randomly permutated, this will work in a reasonable amount of time. When we will find a pair of numbers with the greatest prime number, we easily find out which of these two numbers is the greatest prime: ask the lcm of one of the numbers in the pair with any other number and check if that lcm contains that greatest prime number. Finding the largest prime number, we easily find out the remaining array: ai=lcm(ai,p)/p, where p –that prime number.10000≤n≤100000. Let c = 500. This number is chosen so that c2>200000. We will search the array for any prime number that is greater than c. Do the following: randomly ask pairs of numbers until we find one that has only two prime numbers in the factorization of the lcm, and both of these prime numbers are greater than c. Let it be p1 and p2. Then one of the numbers in the pair — p1 and the other  — p2. To find out which number is which, let's ask the lcm of one of them with some numbers chosen at random, and check what all those lcms are divisible by. If they are all divisible by p1, then the chosen number is p1, otherwise it is p2. The chance of us guessing wrong is extremely small, because it requires that all the chosen numbers are divisible by p2, and the chance of that is negligible.We have found a prime number greater than c. Let it be p. Now we can find out all the numbers that are not divisible by p and greater than c. To do this, we ask all the NOCs of the number p and the other numbers. And now, if lcm(p,ai)/p>c, then ai=lcm(p,ai)/p. This is because if ai is divisible by p, then lcm(p,ai)/p=ai/p≤c. If ai is not divisible by p, then by dividing the lcm by p we will find ai, since the number p is prime.

Find the largest prime among the found numbers, and use it to find the remaining numbers as described above. Since we only need to find all numbers divisible by p and all numbers not exceeding c, such queries will be no more than 100000/500+500=700.

Code C++ (Wind_Eagle)

Codeforces Round #740 Editorial

By tourist, 18 months ago, In EnglishHope you enjoyed the round!

1561A - Simply Strange SortThe described sorting algorithm is similar to Odd-even sort.

In this problem, it's enough to carefully implement the process described in the problem statement. Here is one sample implementation in C++:

#include <bits/stdc++.h>

using namespace std;

int main() {  int tt;  cin >> tt;  while (tt–) {    int n;    cin >> n;    vector<int> a(n);    for (int i = 0; i < n; i++) {      cin >> a[i];    }    int ans = 0;    while (!is_sorted(a.begin(), a.end())) {      for (int i = ans % 2; i + 1 < n; i += 2) {        if (a[i] > a[i + 1]) {          swap(a[i], a[i + 1]);        }      }      ans += 1;    }    cout << ans << endl;  }  return 0;}To estimate the complexity of this solution, we need to know the maximum number of iterations required to sort a permutation of length n. It turns out that this number is equal to exactly n, thus the complexity of the algorithm is O(n2). This is intuitive because the algorithm looks similar to bubble sort that requires n iterations too, or you can directly check that sorting [n,n−1,…,1] requires n iterations and reason that "more sorted" sequences can't require more iterations than "less sorted" sequences, and [n,n−1,…,1] is naturally the "least sorted" sequence of them all. For a formal proof see e.g. the linked Wikipedia page. The proof also follows from the editorial of problem F in Div. 1. If you have a simpler proof, please share in comments!

1558A - Charmed by the GameFirst of all, we don't know who served first, but there are only two options, so let's just try both and unite the sets of k's we get.

Assume that Alice served first. Exactly a+b games were played. If a+b is even, both players served exactly a+b2 times, and if a+b is odd, Alice served one more time than Borys.

The simplest way to consider both cases is to say that Alice served p=⌈a+b2⌉ times, and Borys served q=⌊a+b2⌋ times (⌈t⌉ denotes rounding up, and ⌊t⌋ denotes rounding down).

Let x be the number of times Borys broke Alice's serve (0≤x≤p), and let y be the number of times Alice broke Borys' serve (0≤y≤q).

In this case, the number of games Alice won is a=(p−x)+y, and the number of games Borys won is b=x+(q−y).

We know neither x nor y, but let's loop over x=0…p. From a=(p−x)+y, we can calculate y=a−(p−x). If 0≤y≤q, the values of x and y represent a valid scenario of the match with exactly x+y breaks in total.

The case when Borys served first is handled similarly.

Analyzing the formulas further, we can find a "closed-form" solution:

Let d=⌊|a−b|2⌋.If a+b is even, all possible values of k are d,d+2,d+4,…,a+b−d.If a+b is odd, all possible values of k are d,d+1,d+2,…,a+b−d.1561C - Deep Down BelowConsider a single cave i. Suppose that the hero enters the cave with power x. To beat the first monster, x has to be greater than ai,1. After that, the hero's power will increase to x+1, and to beat the second monster, x+1 has to be greater than ai,2. Continuing this reasoning, we can write down ki inequalities:

x>ai,1;x+1>ai,2;x+2>ai,3;...x+(ki−1)>ai,ki.Let bi=max(ai,1,ai,2−1,ai,3−2,…,ai,ki−(ki−1)). The system of inequalities above is equivalent to a single inequality: x>bi.

Thus, the hero can enter cave i with power x if and only if x>bi, and the hero's power will increase by ki.

Armed with this knowledge, can we determine the best order to visit the caves for the hero?

It turns out it's always best to enter the caves in non-decreasing order of bi. Indeed, if the hero can enter cave i, he should always do that because entering a cave never makes things worse. If the hero enters a cave with greater b right before a cave with smaller b, he might enter these caves in reverse order as well.

Let's sort the caves accordingly and assume b1≤b2≤…≤bn. What is the smallest power the hero can start the level with?

We can use the same reasoning that we used for a single cave.

Suppose the hero starts the level with power x. To enter the first cave, x has to be greater than b1. After that, the hero's power will increase to x+k1, and to enter the second cave, x+k1 has to be greater than b2. Continuing this reasoning, we can write down n inequalities:

x>b1;x+k1>b2;x+k1+k2>b3;...x+∑i=1n−1ki>bn.Let p=max(b1,b2−k1,b3−(k1+k2),…,bn−∑i=1n−1ki). The system of inequalities above is equivalent to a single inequality: x>p. Thus, the answer to the problem is p+1.

Alternatively, instead of solving the inequalities, one can use binary search on x.

1558B - Up the StripThis problem was inspired by Blogewoosh #4 a long time ago (Blogewoosh #8 when?).

Pretty clearly, we are facing a dynamic programming problem. Let f(x) be the number of ways to move from cell x to cell 1. Then, f(1)=1, f(x)=∑y=1x−1f(x−y)+∑z=2xf(⌊xz⌋), and f(n) is the answer to the problem. However, a straightforward implementation has O(n2) time complexity and is too slow.

Let's look at the main formula for f(x) again: f(x)=∑y=1x−1f(x−y)+∑z=2xf(⌊xz⌋).

The first sum, ∑y=1x−1f(x−y), is easy to optimize: just maintain the sum of f1…fx−1 and recalculate it by adding f(x). This takes just O(1) time per cell.

For the second sum, ∑z=2xf(⌊xz⌋), note that ⌊xz⌋ can take at most O(x−−√) different values over z∈[2;x]. We can handle this sum as follows:

Find the sum over all z<x−−√ directly.We only need to consider z≥x−−√ now. For any such value, ⌊xz⌋≤x−−√. Let's loop over a cell c≤x−−√, for how many different values of z it's true that c=⌊xz⌋? By definition of the floor function, c≤xz<c+1. Solving this inequality, we get z∈[⌊xc+1⌋+1;⌊xc⌋]. The length of this segment gives us the coefficient of f(c) in the sum.This gives us an O(nn−−√) solution which is enough for the subtask in Division 2.

To get a faster solution, let S(x) denote the multiset of cells where we can go to from cell x (this multiset contains 2x−2 values). How is S(x+1) different from S(x)?

S(x+1) contains an extra occurrence of x because we can subtract 1 from x+1.S(x+1) contains an extra occurrence of 1 because we can divide x+1 by x+1.For each i>1 that is a divisor of x+1, S(x+1) contains an occurrence of i that replaces an occurrence of i−1.We don't need to maintain S(x) itself, but we can maintain the sum of f(i) over all i∈S(x) and recalculate this sum as we go from x to x+1. The total number of changes to S is limited by the total number of divisors of all numbers from 1 to n, that is, n1+n2+…+nn=O(nlogn).

However, if implemented directly, we need to quickly find the divisors of each x, and we can only afford O(n) memory due to the memory limit. We can achieve that by preparing a sieve of Eratosthenes, factorizing x and generating all its divisors.

A better way is do it the reverse way: once we find f(c) for some c, let's traverse x=2c,3c,… and add f(c)−f(c−1) to f(x). This way the time complexity stays O(nlogn) and the memory complexity is O(n).

1558C - Bottom-Tier ReversalsFirst of all, consider what happens when we reverse a prefix of odd length p. Elements ap+1 to an don't move at all, and for each i from 1 to p, ai moves to ap−i+1. Note that i and p−i+1 have the same parity: therefore, no element can ever change the parity of its position. In the final sorted permutation, we need to have ai=i for all i: that is, the parity of each element's position must match the parity of its value.

This leads to the following necessary condition: for each i∈[1,n], aimod2=imod2. If for any i this doesn't hold, the permutation can not be sorted.

It turns out this condition is also sufficient.

Let's devise a procedure to sort a permutation of odd length n. If an=n and an−1=n−1, we don't have to touch an−1 and an ever again, and we can proceed to sorting a permutation of length n−2. Can we actually move n and n−1 to their final positions with a simple sequence of steps?

Indeed we can. Here is one way to do this in exactly 5 steps:

Let ax=n (note that x is odd). Reverse a prefix of length x to move n to position 1.Let ay=n−1 (note that y is even). Reverse a prefix of length y−1 to move n to position y−1.Reverse a prefix of length y+1 to move n−1 to position 2 and n to position 3.Reverse a prefix of length 3 to move n to position 1 (n−1 stays at position 2).Reverse a prefix of length n to move n to position n and n−1 to position n−1, as desired.We can use this procedure n−12 times to first move n and n−1 to their final positions, then n−2 and n−3, and so on. This solution requires exactly 5(n−1)2 steps.

1558D - Top-Notch InsertionsFirst of all, note that the sequence of insertions uniquely determines where each element goes. For example, for n=5 and a sequence of insertions (3,1),(4,1),(5,3), the initial sequence [a1,a2,a3,a4,a5] is always transformed into [a4,a3,a5,a1,a2], no matter what ai are. Thus, instead of counting the initial sequences, we might count the final sequences instead.

Let the final sequence be [b1,b2,…,bn]. From its sortedness, we know that bi≤bi+1 for every i∈[1;n−1].

Consider a single iteration i of the sorting algorithm. If ai≥ai−1, no insertion occurs. This actually doesn't give us any extra information: we know that ai is placed later than ai−1 in the final sequence anyway.

What happens though if ai is inserted into position j?

We know that ai<aj and also, since j is the smallest index with such property, ai≥aj−1. Again, a non-strict inequality doesn't give us anything. However, knowing that ai<aj is actually important.

It turns out that we are interested in elements ai such that we have ever inserted an element right before ai during sorting. For every such element, we know that the previous element in the sorted order is strictly smaller. All other pairs of neighboring elements can either be equal, or the earlier one can be smaller.

All in all, let c be the number of indices i∈[1;n−1] such that bi<bi+1 (for all the other values of i, bi≤bi+1). How many different sequences b with integers from 1 to n satisfy this? This number can be shown to be equal to (2n−1−cn).

(The proof can go as follows: for each i such that bi≤bi+1, increase each of bi+1,bi+2,…,bn by 1. Now for every i we have bi<bi+1, and the maximum possible value of an element increased to n+(n−1−c). Thus, we have built a bijection from the sequences we are searching for to the sequences of n distinct numbers between 1 and n+(n−1−c). The number of the latter sequences is clearly (2n−1−cn).)

How to find c? It can be done by going through the insertions and maintaining a balanced binary search tree of your choice. However, implementation becomes simpler if we process the insertions in reverse order.

Let's maintain a set S of positions in the final sorted order that are not yet filled in. Initially, the set contains all integers from 1 to n. For each insertion (xi,yi) (in reverse order), let p be the yi-th smallest element of S, and let q be the (yi+1)-th smallest element of S. Since we insert p before q, mark position q as "a position such that we have ever inserted an element right before it" (which is important for calculating c). Then, erase p from the set.

As a data structure that can handle finding the k-th smallest element, we can use a balanced binary search tree, a segment tree, or binary search over Fenwick tree (in C++ we can also use a built-in policy-based data structure).

Finally, to solve each test case in O(mlogn) and not O(nlogn), we can have a single data structure instance for solving all test cases, and roll back any changes we apply while solving each test case.

1558E - Down BelowLet's find the smallest possible initial power with binary search. Suppose the initial power is p.

The main idea behind the solution is to maintain a set of caves where we have beaten all the monsters, and try to extend the set by finding "augmenting" paths.

However, we can not just go in an arbitrary unvisited cave and pretend we add it to the set: since we are not allowed to turn back, it might happen that we can not move forward anymore because we don't have enough power. It's important that we must be able to reach any cave inside the set only going through caves belonging to the set itself.

Initially, the set contains just cave 1.

What can an augmenting path look like?

The path can start somewhere inside the set, go out of the set, follow a simple route visiting some new caves (and beating monsters inside them), and go back to a cave belonging to the set. For example, if caves 1 and 2 belong to the set, the route can look like 1→3→4→5→2, and we can add caves 3, 4, and 5 to the set.Alternatively, instead of going back to a cave from the set, the path might go into a cave belonging to the route. For example, if caves 1 and 2 belong to the set, the route can look like 1→3→4→5→6→4, and we can add caves 3, 4, 5, and 6 to the set.How do we find any augmenting path satisfying us?

It turns out that we can use the following property. Suppose we have a path v→u1→u2→…→uk→x (where v is the only cave belonging to the set) that we can follow and beat all the monsters in the caves we visit. Suppose that we have another such path v′→u′1→u′2→…→u′k′→x. Suppose that following the former path, we arrive at x with the same or higher power than following the latter path. In this case, notice that

v→u1→u2→…→uk→x→u′k′→…→u′1→v′is actually a valid augmenting path!Thus, we can simply use BFS or DFS to find all reachable caves. Once we find a path leading back into the set, or we find two different paths leading into the same unvisited cave, we can build an augmenting path, extend the set, and start over, until the set contains all caves (in which case we can try to decrease the initial power level p) or until we can not find any augmenting path (in which case we must increase p).

At each binary search iteration, we can have at most n augmenting paths and we find each of them in O(m). Thus, the time complexity of the solution is O(nmlogamax).

1558F - Strange SortLet's draw a wall of n towers of cubes, with the i-th tower having height ai. For example, for a=[4,5,7,1,3,2,6] the picture will look as follows (1 stands for a cube):

0010000001000101100011110001111010111101111111111When two elements get swapped, their corresponding towers get swapped as well.Note that applying f(i) to the permutation (swapping ai and ai+1 if ai>ai+1) is equivalent to applying f(i) to each row of the above matrix independently (swapping cells i and i+1 if the i-th cell is 1 and the i+1-th cell is 0).

Also note that in the final state, when the permutation is [1,2,…,n], each row of the matrix is sorted in non-descending order too (0's go before 1's), and vice versa — if each row is sorted, the permutation is sorted as well.

Thus, it's enough to find the number of iterations required to sort each row of the matrix, and the maximum of these numbers is the answer for the given permutation.

The rows of the matrix are bi=[ai≥x] for x=1,2,…,n.

How to solve the problem for a sequence of 0's and 1's?

We can assume that the instances of 0's don't change their relative order, and the same for 1's. Let the positions of zeros in the initial sequence be 1≤p1<p2<…<pm≤n. The i-th zero from the left is moving towards position i in the sorted sequence.

Let s(i) be the number of steps it takes the i-th zero from the left to get to its final position i.

If the i-th zero is already in position i, then s(i)=0.

Otherwise, if i>1, note that s(i)≥s(i−1)+1, because the i-th zero can only get to position i after the (i−1)-th zero gets to position i−1.

Moreover, let there be ki ones to the left of the i-th zero in the initial sequence. Then s(i)≥ki+(pimod2), because the 0 has to swap with every 1 to the left of it, and also the first iteration is useless if pi is odd.

It turns out that s(i)=max(s(i−1)+1,ki+(pimod2)) — the i-th zero either gets stuck into the (i−1)-th zero (and then si=s(i−1)+1), or consistently swaps with 1's on each iteration except for maybe the first (in which case si=ki+(pimod2)).

We are interested in s(m). Let the number of 0's at the start of the initial sequence be t. It can be seen that s(m)=maxi=t+1m(ki+(pimod2)+(m−i)), and this is exactly the number of iterations required.

Recall that we need to find the number of iterations for n different binary sequences. However, these binary sequences are very similar to each other.

Let's maintain the values of (ki+(pimod2)+(m−i)) for all zeros in a segment tree (and, say, −∞ for positions containing ones). Start with the sequence bi=[ai≥x] for x=1 — that is, a sequence of all ones. As we increase x by one, a single 1 in b gets replaced with 0. We can handle these changes using a segment tree with "range add" and "range max". The time complexity of the solution is O(nlogn).

(Another equivalent formula is: s(m)=maxi=lrc1([b1,b2,…,bi])+c0([bi+1,…,bn])+(imod2)−1. Here cx(seq) is the number of x's in seq; l is the smallest position such that c1([b1,b2,…,bl])>0; and r is the largest position such that c0([br+1,…,bn])>0. This formula can also be proven using induction. In short, consider this formula applied to the number of remaining iterations — the difference is that instead of (imod2), we sometimes have 1−(imod2), depending on the parity of the current iteration number. Consider all positions i where the value is maximized. Then it can be shown that after one iteration the value for all such positions decreases by 1: if the parity is incorrect, after one iteration the parity becomes correct; otherwise, observe that bi=1 and bi+1=0, which get swapped in the next iteration. Moreover, the value for all other positions has the same parity, increases by at most 1, and thus doesn't become too big either.)

Codeforces Round #740 Editorial

By tourist, 18 months ago, In EnglishHope you enjoyed the round!

1561A - Simply Strange SortThe described sorting algorithm is similar to Odd-even sort.

In this problem, it's enough to carefully implement the process described in the problem statement. Here is one sample implementation in C++:

#include <bits/stdc++.h>

using namespace std;

int main() {  int tt;  cin >> tt;  while (tt–) {    int n;    cin >> n;    vector<int> a(n);    for (int i = 0; i < n; i++) {      cin >> a[i];    }    int ans = 0;    while (!is_sorted(a.begin(), a.end())) {      for (int i = ans % 2; i + 1 < n; i += 2) {        if (a[i] > a[i + 1]) {          swap(a[i], a[i + 1]);        }      }      ans += 1;    }    cout << ans << endl;  }  return 0;}To estimate the complexity of this solution, we need to know the maximum number of iterations required to sort a permutation of length n. It turns out that this number is equal to exactly n, thus the complexity of the algorithm is O(n2). This is intuitive because the algorithm looks similar to bubble sort that requires n iterations too, or you can directly check that sorting [n,n−1,…,1] requires n iterations and reason that "more sorted" sequences can't require more iterations than "less sorted" sequences, and [n,n−1,…,1] is naturally the "least sorted" sequence of them all. For a formal proof see e.g. the linked Wikipedia page. The proof also follows from the editorial of problem F in Div. 1. If you have a simpler proof, please share in comments!

1558A - Charmed by the GameFirst of all, we don't know who served first, but there are only two options, so let's just try both and unite the sets of k's we get.

Assume that Alice served first. Exactly a+b games were played. If a+b is even, both players served exactly a+b2 times, and if a+b is odd, Alice served one more time than Borys.

The simplest way to consider both cases is to say that Alice served p=⌈a+b2⌉ times, and Borys served q=⌊a+b2⌋ times (⌈t⌉ denotes rounding up, and ⌊t⌋ denotes rounding down).

Let x be the number of times Borys broke Alice's serve (0≤x≤p), and let y be the number of times Alice broke Borys' serve (0≤y≤q).

In this case, the number of games Alice won is a=(p−x)+y, and the number of games Borys won is b=x+(q−y).

We know neither x nor y, but let's loop over x=0…p. From a=(p−x)+y, we can calculate y=a−(p−x). If 0≤y≤q, the values of x and y represent a valid scenario of the match with exactly x+y breaks in total.

The case when Borys served first is handled similarly.

Analyzing the formulas further, we can find a "closed-form" solution:

Let d=⌊|a−b|2⌋.If a+b is even, all possible values of k are d,d+2,d+4,…,a+b−d.If a+b is odd, all possible values of k are d,d+1,d+2,…,a+b−d.1561C - Deep Down BelowConsider a single cave i. Suppose that the hero enters the cave with power x. To beat the first monster, x has to be greater than ai,1. After that, the hero's power will increase to x+1, and to beat the second monster, x+1 has to be greater than ai,2. Continuing this reasoning, we can write down ki inequalities:

x>ai,1;x+1>ai,2;x+2>ai,3;...x+(ki−1)>ai,ki.Let bi=max(ai,1,ai,2−1,ai,3−2,…,ai,ki−(ki−1)). The system of inequalities above is equivalent to a single inequality: x>bi.

Thus, the hero can enter cave i with power x if and only if x>bi, and the hero's power will increase by ki.

Armed with this knowledge, can we determine the best order to visit the caves for the hero?

It turns out it's always best to enter the caves in non-decreasing order of bi. Indeed, if the hero can enter cave i, he should always do that because entering a cave never makes things worse. If the hero enters a cave with greater b right before a cave with smaller b, he might enter these caves in reverse order as well.

Let's sort the caves accordingly and assume b1≤b2≤…≤bn. What is the smallest power the hero can start the level with?

We can use the same reasoning that we used for a single cave.

Suppose the hero starts the level with power x. To enter the first cave, x has to be greater than b1. After that, the hero's power will increase to x+k1, and to enter the second cave, x+k1 has to be greater than b2. Continuing this reasoning, we can write down n inequalities:

x>b1;x+k1>b2;x+k1+k2>b3;...x+∑i=1n−1ki>bn.Let p=max(b1,b2−k1,b3−(k1+k2),…,bn−∑i=1n−1ki). The system of inequalities above is equivalent to a single inequality: x>p. Thus, the answer to the problem is p+1.

Alternatively, instead of solving the inequalities, one can use binary search on x.

1558B - Up the StripThis problem was inspired by Blogewoosh #4 a long time ago (Blogewoosh #8 when?).

Pretty clearly, we are facing a dynamic programming problem. Let f(x) be the number of ways to move from cell x to cell 1. Then, f(1)=1, f(x)=∑y=1x−1f(x−y)+∑z=2xf(⌊xz⌋), and f(n) is the answer to the problem. However, a straightforward implementation has O(n2) time complexity and is too slow.

Let's look at the main formula for f(x) again: f(x)=∑y=1x−1f(x−y)+∑z=2xf(⌊xz⌋).

The first sum, ∑y=1x−1f(x−y), is easy to optimize: just maintain the sum of f1…fx−1 and recalculate it by adding f(x). This takes just O(1) time per cell.

For the second sum, ∑z=2xf(⌊xz⌋), note that ⌊xz⌋ can take at most O(x−−√) different values over z∈[2;x]. We can handle this sum as follows:

Find the sum over all z<x−−√ directly.We only need to consider z≥x−−√ now. For any such value, ⌊xz⌋≤x−−√. Let's loop over a cell c≤x−−√, for how many different values of z it's true that c=⌊xz⌋? By definition of the floor function, c≤xz<c+1. Solving this inequality, we get z∈[⌊xc+1⌋+1;⌊xc⌋]. The length of this segment gives us the coefficient of f(c) in the sum.This gives us an O(nn−−√) solution which is enough for the subtask in Division 2.

To get a faster solution, let S(x) denote the multiset of cells where we can go to from cell x (this multiset contains 2x−2 values). How is S(x+1) different from S(x)?

S(x+1) contains an extra occurrence of x because we can subtract 1 from x+1.S(x+1) contains an extra occurrence of 1 because we can divide x+1 by x+1.For each i>1 that is a divisor of x+1, S(x+1) contains an occurrence of i that replaces an occurrence of i−1.We don't need to maintain S(x) itself, but we can maintain the sum of f(i) over all i∈S(x) and recalculate this sum as we go from x to x+1. The total number of changes to S is limited by the total number of divisors of all numbers from 1 to n, that is, n1+n2+…+nn=O(nlogn).

However, if implemented directly, we need to quickly find the divisors of each x, and we can only afford O(n) memory due to the memory limit. We can achieve that by preparing a sieve of Eratosthenes, factorizing x and generating all its divisors.

A better way is do it the reverse way: once we find f(c) for some c, let's traverse x=2c,3c,… and add f(c)−f(c−1) to f(x). This way the time complexity stays O(nlogn) and the memory complexity is O(n).

1558C - Bottom-Tier ReversalsFirst of all, consider what happens when we reverse a prefix of odd length p. Elements ap+1 to an don't move at all, and for each i from 1 to p, ai moves to ap−i+1. Note that i and p−i+1 have the same parity: therefore, no element can ever change the parity of its position. In the final sorted permutation, we need to have ai=i for all i: that is, the parity of each element's position must match the parity of its value.

This leads to the following necessary condition: for each i∈[1,n], aimod2=imod2. If for any i this doesn't hold, the permutation can not be sorted.

It turns out this condition is also sufficient.

Let's devise a procedure to sort a permutation of odd length n. If an=n and an−1=n−1, we don't have to touch an−1 and an ever again, and we can proceed to sorting a permutation of length n−2. Can we actually move n and n−1 to their final positions with a simple sequence of steps?

Indeed we can. Here is one way to do this in exactly 5 steps:

Let ax=n (note that x is odd). Reverse a prefix of length x to move n to position 1.Let ay=n−1 (note that y is even). Reverse a prefix of length y−1 to move n to position y−1.Reverse a prefix of length y+1 to move n−1 to position 2 and n to position 3.Reverse a prefix of length 3 to move n to position 1 (n−1 stays at position 2).Reverse a prefix of length n to move n to position n and n−1 to position n−1, as desired.We can use this procedure n−12 times to first move n and n−1 to their final positions, then n−2 and n−3, and so on. This solution requires exactly 5(n−1)2 steps.

1558D - Top-Notch InsertionsFirst of all, note that the sequence of insertions uniquely determines where each element goes. For example, for n=5 and a sequence of insertions (3,1),(4,1),(5,3), the initial sequence [a1,a2,a3,a4,a5] is always transformed into [a4,a3,a5,a1,a2], no matter what ai are. Thus, instead of counting the initial sequences, we might count the final sequences instead.

Let the final sequence be [b1,b2,…,bn]. From its sortedness, we know that bi≤bi+1 for every i∈[1;n−1].

Consider a single iteration i of the sorting algorithm. If ai≥ai−1, no insertion occurs. This actually doesn't give us any extra information: we know that ai is placed later than ai−1 in the final sequence anyway.

What happens though if ai is inserted into position j?

We know that ai<aj and also, since j is the smallest index with such property, ai≥aj−1. Again, a non-strict inequality doesn't give us anything. However, knowing that ai<aj is actually important.

It turns out that we are interested in elements ai such that we have ever inserted an element right before ai during sorting. For every such element, we know that the previous element in the sorted order is strictly smaller. All other pairs of neighboring elements can either be equal, or the earlier one can be smaller.

All in all, let c be the number of indices i∈[1;n−1] such that bi<bi+1 (for all the other values of i, bi≤bi+1). How many different sequences b with integers from 1 to n satisfy this? This number can be shown to be equal to (2n−1−cn).

(The proof can go as follows: for each i such that bi≤bi+1, increase each of bi+1,bi+2,…,bn by 1. Now for every i we have bi<bi+1, and the maximum possible value of an element increased to n+(n−1−c). Thus, we have built a bijection from the sequences we are searching for to the sequences of n distinct numbers between 1 and n+(n−1−c). The number of the latter sequences is clearly (2n−1−cn).)

How to find c? It can be done by going through the insertions and maintaining a balanced binary search tree of your choice. However, implementation becomes simpler if we process the insertions in reverse order.

Let's maintain a set S of positions in the final sorted order that are not yet filled in. Initially, the set contains all integers from 1 to n. For each insertion (xi,yi) (in reverse order), let p be the yi-th smallest element of S, and let q be the (yi+1)-th smallest element of S. Since we insert p before q, mark position q as "a position such that we have ever inserted an element right before it" (which is important for calculating c). Then, erase p from the set.

As a data structure that can handle finding the k-th smallest element, we can use a balanced binary search tree, a segment tree, or binary search over Fenwick tree (in C++ we can also use a built-in policy-based data structure).

Finally, to solve each test case in O(mlogn) and not O(nlogn), we can have a single data structure instance for solving all test cases, and roll back any changes we apply while solving each test case.

1558E - Down BelowLet's find the smallest possible initial power with binary search. Suppose the initial power is p.

The main idea behind the solution is to maintain a set of caves where we have beaten all the monsters, and try to extend the set by finding "augmenting" paths.

However, we can not just go in an arbitrary unvisited cave and pretend we add it to the set: since we are not allowed to turn back, it might happen that we can not move forward anymore because we don't have enough power. It's important that we must be able to reach any cave inside the set only going through caves belonging to the set itself.

Initially, the set contains just cave 1.

What can an augmenting path look like?

The path can start somewhere inside the set, go out of the set, follow a simple route visiting some new caves (and beating monsters inside them), and go back to a cave belonging to the set. For example, if caves 1 and 2 belong to the set, the route can look like 1→3→4→5→2, and we can add caves 3, 4, and 5 to the set.Alternatively, instead of going back to a cave from the set, the path might go into a cave belonging to the route. For example, if caves 1 and 2 belong to the set, the route can look like 1→3→4→5→6→4, and we can add caves 3, 4, 5, and 6 to the set.How do we find any augmenting path satisfying us?

It turns out that we can use the following property. Suppose we have a path v→u1→u2→…→uk→x (where v is the only cave belonging to the set) that we can follow and beat all the monsters in the caves we visit. Suppose that we have another such path v′→u′1→u′2→…→u′k′→x. Suppose that following the former path, we arrive at x with the same or higher power than following the latter path. In this case, notice that

v→u1→u2→…→uk→x→u′k′→…→u′1→v′is actually a valid augmenting path!Thus, we can simply use BFS or DFS to find all reachable caves. Once we find a path leading back into the set, or we find two different paths leading into the same unvisited cave, we can build an augmenting path, extend the set, and start over, until the set contains all caves (in which case we can try to decrease the initial power level p) or until we can not find any augmenting path (in which case we must increase p).

At each binary search iteration, we can have at most n augmenting paths and we find each of them in O(m). Thus, the time complexity of the solution is O(nmlogamax).

1558F - Strange SortLet's draw a wall of n towers of cubes, with the i-th tower having height ai. For example, for a=[4,5,7,1,3,2,6] the picture will look as follows (1 stands for a cube):

0010000001000101100011110001111010111101111111111When two elements get swapped, their corresponding towers get swapped as well.Note that applying f(i) to the permutation (swapping ai and ai+1 if ai>ai+1) is equivalent to applying f(i) to each row of the above matrix independently (swapping cells i and i+1 if the i-th cell is 1 and the i+1-th cell is 0).

Also note that in the final state, when the permutation is [1,2,…,n], each row of the matrix is sorted in non-descending order too (0's go before 1's), and vice versa — if each row is sorted, the permutation is sorted as well.

Thus, it's enough to find the number of iterations required to sort each row of the matrix, and the maximum of these numbers is the answer for the given permutation.

The rows of the matrix are bi=[ai≥x] for x=1,2,…,n.

How to solve the problem for a sequence of 0's and 1's?

We can assume that the instances of 0's don't change their relative order, and the same for 1's. Let the positions of zeros in the initial sequence be 1≤p1<p2<…<pm≤n. The i-th zero from the left is moving towards position i in the sorted sequence.

Let s(i) be the number of steps it takes the i-th zero from the left to get to its final position i.

If the i-th zero is already in position i, then s(i)=0.

Otherwise, if i>1, note that s(i)≥s(i−1)+1, because the i-th zero can only get to position i after the (i−1)-th zero gets to position i−1.

Moreover, let there be ki ones to the left of the i-th zero in the initial sequence. Then s(i)≥ki+(pimod2), because the 0 has to swap with every 1 to the left of it, and also the first iteration is useless if pi is odd.

It turns out that s(i)=max(s(i−1)+1,ki+(pimod2)) — the i-th zero either gets stuck into the (i−1)-th zero (and then si=s(i−1)+1), or consistently swaps with 1's on each iteration except for maybe the first (in which case si=ki+(pimod2)).

We are interested in s(m). Let the number of 0's at the start of the initial sequence be t. It can be seen that s(m)=maxi=t+1m(ki+(pimod2)+(m−i)), and this is exactly the number of iterations required.

Recall that we need to find the number of iterations for n different binary sequences. However, these binary sequences are very similar to each other.

Let's maintain the values of (ki+(pimod2)+(m−i)) for all zeros in a segment tree (and, say, −∞ for positions containing ones). Start with the sequence bi=[ai≥x] for x=1 — that is, a sequence of all ones. As we increase x by one, a single 1 in b gets replaced with 0. We can handle these changes using a segment tree with "range add" and "range max". The time complexity of the solution is O(nlogn).

(Another equivalent formula is: s(m)=maxi=lrc1([b1,b2,…,bi])+c0([bi+1,…,bn])+(imod2)−1. Here cx(seq) is the number of x's in seq; l is the smallest position such that c1([b1,b2,…,bl])>0; and r is the largest position such that c0([br+1,…,bn])>0. This formula can also be proven using induction. In short, consider this formula applied to the number of remaining iterations — the difference is that instead of (imod2), we sometimes have 1−(imod2), depending on the parity of the current iteration number. Consider all positions i where the value is maximized. Then it can be shown that after one iteration the value for all such positions decreases by 1: if the parity is incorrect, after one iteration the parity becomes correct; otherwise, observe that bi=1 and bi+1=0, which get swapped in the next iteration. Moreover, the value for all other positions has the same parity, increases by at most 1, and thus doesn't become too big either.)

Editorial for Codeforces Round #739 (Div.3)

By MrPaul_TUser, history, 18 months ago, In EnglishIdeas: MikeMirzayanov

1560A - Dislike of Threes

Tutorial1560A - Dislike of ThreesThe solution is simple: let's create an integer variable (initially set to 0) that will contain the number of considered liked integers. Let's iterate over all positive integers starting with 1. Let's increase the variable only when the considered number is liked. If the variable is equal to k, let's stop the iteration and output the last considered number.

Since the answer for k=1000 is x=1666, the count of considered numbers is at most 1666 so the solution will work on the specified limitations fast enough.

Solution1560B - Who's Opposite?

Tutorial1560B - Who's Opposite?The person with the number a looks at the person with the number b so the count of people standing to the left of a between a and b is equal to the count of people standing to the right of a between a and b. Therefore, both counts are equal to n−22, hence n must be a solution of the equation n−22=|a−b|−1. The only solution of the equation is n=2⋅|a−b|.

Let's check that in the circle of n people can occur the numbers a, b and c, i. e. let's check that 1≤a,b,c≤n. If it's false, there's no solution (output −1).

Since the person with the number d looks at the person with the number c, the condition n−22=|c−d|−1 must be met. Let's solve the equation for d. There are two solutions:

d1=c+n2;d2=c−n2.We can output any of di such that 1≤di≤n. It's easy to prove that exactly one of the solutions meets the condition.

Solution1560C - Infinity Table

Tutorial1560C - Infinity TableLet's call a set of cells being filled from the topmost row to the leftmost column a layer. E. g. the 1-st layer consists of the single number 1, the 2-nd layer consists of the numbers 2, 3 and 4, the 3-rd layer consists of the numbers 5, 6, 7, 8 and 9, etc.

The number of cells in layers forms an arithmetic progression. The first layer consists of a1=1 cells, the i-th layer consists of ai=ai−1+2 cells. The minimum number in the i-th layer xi is equal to the sum of sizes of all layers from the 1-st to the (i−1)-th plus 1.

Suppose that k belongs to the i-th layer. Consider the value of m=k−xi+1. Polycarp fills exactly i cells on the i-th layer before he starts filling the cells from the right to the left (i. e. while he goes down). Therefore, if m≤i, the number k belongs to the m-th row and the i-th column. Otherwise, the number belongs to the i-th row and the (i−(m−i))-th column.

Consider a way to find the coordinates of a given number k. Let's iterate by the layer number i to which given the number belongs calculating the values of ai and xi (going to the next layer, let's calculate the next layer parameters as follows: xi+1:=xi+ai; ai+1:=ai+2). The iteration must be stopped if the layer number i is such that xi≤k<xi+1. Using the values of i and xi, we can calculate the given number's coordinates in the described way in O(1). The total time of calculating the coodrinates for one given k is O(ik) where ik is the number of the layer to which the given k belongs.

Let's represent the value of xi as xi=f(i): xi=1+∑j=1i−1aj=1+∑j=1i−1(2j−1)=1+1+2(i−1)−12⋅(i−1)=1+(i−1)2. 1+(ik−1)2=xik≤k<xik+1=1+i2k, hence ik≈(√k). Therefore, the coordinates of one number k may be calculated in O(k−−√). At the same time, as it follows from the formulas, the layer number ik can be calculated as follows: ik=⌈k−−√⌉ (the square root of k rounded up). To avoid accuracy problems, you can calculate the value using a loop.

Solution1560D - Make a Power of Two

Tutorial1560D - Make a Power of TwoSuppose we must turn n into some specific number x. In this case, we can use the following greedy algorithm. Consider the string forms — sn and sx — of the numbers n and x, respectively. Let's make a pointer pn pointing at the first character of the string sn and a pointer px pointing at the first character of the string sx. Let's initialize a variable taken=0 in which we will store a number of selected characters. Until any of the pointers points at the place that is out of the corresponding string, let's do the following procedure: if the characters to which the pointers point are equal, we will take the character (increase taken by 1) and move both pointers 1 character to the right, otherwise, the only action we must perform is to move sn 1 character to the right. The variable taken will contain after the whole process the length of the longest subsequence of sn equal to a prefix of sx, i. e. the maximum number of original characters of sn that we will not erase. We must add to the resulting string all remaining characters of sx to turn it into sx. Therefore, we must erase |sn|−taken digits and add |sx|−taken digits so the answer for this subproblem is ans(n,x)=|sn|+|sx|−2⋅taken where |s| means the length of a string s.

Suppose we have a set X of powers of two such that it's enough to consider to get the problem's answer. The problem can be solved as follows: for each x∈X let's calculate the answer for the subproblem described above and select the value of minx∈Xans(n,x) as the answer.

What set of powers of two we can take? Suppose the number n consists of no more than 9 digits. The answer for each n consisting of d digits doesn't exceed d+1, hence we can get this value by turning the number into 1 in d+1 move adding 1 to the right of the number, and erasing all other d digits. Suppose there's a number x such that ans(n,x)≤d. So it consists of no more than 2⋅d digits — this value can be reached as follows: we must not erase any digit and add d digits. Therefore, if d≤9, each number x such that ans(n,x)≤d consists of no more than 18 digits, hence x<1018.

Suppose n consists of more than 9 digits. Then n=109 because n≤109 according to the input format. The answer for the number doesn't exceed 9 — we can get this answer if we erase all 0 from the number to turn it into 1. Suppose there's a number x such that ans(n,x)≤8. This number can consist of no more than 18 digits (10 digits of n plus 8 digits), hence x<1018.

Therefore, it's enough to consider all powers of two that are less than 1018.

Solution1560E - Polycarp and String Transformation

Tutorial1560E - Polycarp and String TransformationSuppose it's given a string t for which the answer exists. Consider the last non-empty value of s. Only 1 letter occurs in the value and the letter is the last removed letter. At the same time, the value of s is a suffix of t so the last character of t is the last removed letter. Consider the second-last non-empty value of s. It contains exactly 2 distinct letters so that one of them is the last removed letter and the other is the second-last removed letter. The concatenation of the second-last and the last values of s is a suffix of t consisting only of the letters. Therefore, the letter which occurrence is the last of the occurrences of all letters except the last removed one is the second-last removed letter. Considering so other values, we are proving that the order of removing the letters is the order the last occurrences of the letters occur in the string t.

Suppose k is the number of the step in which some letter was removed, ck is the number of occurrences of the letter in the initial value of s. The letter occurs in exactly k different values of s. In each of them, the letter occurs exactly ck times. So the letter occurs in t exactly dk=k⋅ck times. Therefore, using the number of the step (k) in which the letter was removed and the number of the letter's occurrences in t (dk), let's calculate the number of the letter's occurrences in the string s: ck=dkk. If dk isn't completely divisible by k, there's no solution.

The sum of all ck of all letters occurring in t is the length of the initial value of s. Since the initial value is a prefix of t, the possible answer is the prefix of t having the length equal to the sum of all ck.

Before outputting the prefix, check that you can get from the supposed value of the string s the string t. Checking it, you may use the algorithm from the statement. If the resulting string is equal to t, the answer is correct and must be outputted, otherwise, there's no solution.

Solution1560F1 - Nearest Beautiful Number (easy version)

Tutorial1560F1 - Nearest Beautiful Number (easy version)Suppose the number n contains m digits. The desired number x isn't greater than the number consisting of m digits 9. This number is 1-beautiful whereas any 1-beautiful number is at the same time k-beautiful, so x contains at most m digits. At the same time, x≥n so x contains at least m digits. Therefore, the desired number contains exactly m digits.

Suppose k=1. There are exactly 9 k-beautiful numbers containing exactly m digits. To get the answer fast, it's possible to consider all these numbers.

Suppose k=2. If n is already k-beautiful, let's output it. Otherwise, let's initialize the answer by the value as if k=1. Let's iterate two digits a and b such that a<b. Let's search for the answer by considering the strings consisting only of digits a and b. Let's iterate a prefix of n starting from the empty one so that the prefix will be the prefix of x. This prefix must contain only the digits a and b. Consider the leftmost digit that doesn't belong to the prefix. Let's try to increase it. If the digit is less than a, a possible answer is a number such that it has the considered prefix and all other digits are equal to a. Let's update the answer by this number (i.e. if the found number is less than the best previously found answer, let's set the answer to the found number). If the considered digit is at least a and is less than b, let's update the answer by the number such that it has the considered prefix, the digit b follows the prefix, and all other digits are equal to a.

Solution1560F2 - Nearest Beautiful Number (hard version)

Tutorial1560F2 - Nearest Beautiful Number (hard version)Suppose the number n contains m digits and its decimal representation is d1d2…dm. The desired number x isn't greater than the number consisting of m digits 9. This number is 1-beautiful whereas any 1-beautiful number is at the same time k-beautiful, so x contains at most m digits. At the same time, x≥n so x contains at least m digits. Therefore, the desired number contains exactly m digits.

Since we search for the minimum x, we need to minimize first of all the first digit, only then the second digit, etc. Therefore, we need to find a prefix of the decimal representation of n such that is a prefix of the decimal representation of x. Let's do it greedily.

Short solution, works in O(m2)

Let's find the maximum prefix of n such that contains no more than k distinct numbers. Suppose the prefix has the length p. If p=m, then n is already k-beautiful, let's output it. Otherwise, let's increase the prefix like a number by 1, e.g. if n=1294 and p=3, then we increase 129 by 1, the resulting prefix is 130. All other digits (dp+2,dp+3,…,dm), let's set to zeroes (e.g. if n=1294 and p=3, then n will be turned into 1300). The answer for the old n is the answer for the new n. To get the answer for the new n, let's start the described procedure once again preparing the new n.

Long solution, works in O(mk)

Let's find the maximum prefix of n such that contains no more than k distinct numbers. It's possible to do using a map in which for each digit (the key) the number of its occurrences in the prefix is stored. For an empty prefix, the map is empty. If we increase the prefix length by 1, we need to check that map contains no more than k keys and add a new key with the value 1 or increase the value of an existing key. If the length of the found prefix is equal to the length of the whole decimal representation, the given number is already k-beautiful so the answer is n.

Otherwise, the found prefix may not be a prefix of the desired number. Let's change the digits of the decimal representation of n to turn it into the desired number x. Let's start the following procedure: suppose we consider a prefix with the length equal to p. First, let's find out, is it possible to increase the first element out of the prefix (i. e. dp+1). We need to do it because if we consider the length p, then the prefix with the length p+1 cannot be unchanged so the element dp+1 must be changed whereas it cannot be decreased because, in this case, we will get the number which is less than n. If we can increase the element dp+1 so that the prefix with the length p+1 has at most k distinct digits, the only thing that is remained to do is to fill the remaining digits dp+2,dp+3,…dm somehow greedily and output the result. If we cannot increase the element dp+1, let's decrease the length of the considered prefix p by 1 updating the map (let's decrease the value corresponding to the key dp by 1, then, if it's equal to 0, we remove the key dp from the map).

Consider, how and under what conditions we can change dp+1 and the following digits:

If dp+1=9, it's impossible.Suppose the considered prefix contains less than k distinct digits (the number of the keys in the map is less than k). In this case, we can replace the digit dp+1 with the value dp+1+1 so the prefix with the length p+1 will not contain more than k distinct elements because the prefix with the length p doesn't contain more than k−1 distinct elements. If the prefix with the length p+1 still contains less than k distinct numbers, let's replace the remaining digits (dp+2, dp+3, etc) with 0. Otherwise, we can replace them with the minimum digit that occurs in the prefix with the length p+1 (it may be 0).Suppose the considered prefix contains exactly k distinct digits. So let's find the minimum digit that occurs in the prefix with the length p and is greater than dp+1. If such digit exists, let's replace dp+1 with it, and all following digits with the minimum digit that occurs in the prefix with the length p+1. Otherwise, the element dp+1 cannot be increased.The converted by the procedure n is the answer.

Short solutionLong solution

Codeforces Round #738 Editorial

By Bazoka13, history, 18 months ago, In English1559A - Mocha and MathWe assume the answer is x. In its binary representation, one bit will be 1 only if in all the ai's binary representation,this bit is 1. Otherwise, we can use one operation to make this bit in x become 0, which is a smaller answer.

So we can set x=a1 initially. Then we iterate over the sequence and make x=x&ai, the x is the anwser finally.

solution1559B - Mocha and Red and BlueFor a longest period of "?", it is optimized to paint either "RBRB..." or "BRBR...", so the imperfectness it made is only related to the colors of both sides of it.

Choose the one with the lower imperfectness for each longest period of "?" in O(n) is acceptable.

More elegantly, if the square on the left or on the right of a "?" is painted, simply paint "?" with the different color from it. This can be proved to reach the minimum imperfectness by considering the parity.

solution1559C - Mocha and HikingIf a1=1, then the path [(n+1)→1→2→⋯→n] is valid.

If an=0, then the path [1→2→⋯→n→(n+1)] is valid.

Otherwise, since a1=0∧an=1, there must exists an integer i (1≤i<n) where ai=0∧ai+1=1, then the path [1→2→⋯→i→(n+1)→(i+1)→(i+2)→⋯n] is valid.

This is a step to prove that there always exists an Hamiltonian path in a tournament graph.

solution1559D1 - Mocha and Diana (Easy Version)In the final situation, if one forest has more than one tree, we choose two trees from it, such as tree A and tree B. Then we consider node a in A and node b in B, they must be connected in another forest. We can easily find node b is connected with all the nodes in A and node a is connected with all the nodes in B. So nodes in A and B are in the same tree in another forest. If we consider other trees, we can get the same conclusion. Hence nodes in another forest form only one tree.

So we can enumerate every pair (i,j) and check if this edge can be added. When the edge can be added, we can just add it. This can be done in the complexity of O(n2).

solution1559D2 - Mocha and Diana (Hard Version)To have a clearer understanding, let's visualize the problem with a grid where each row is a component in the left forest and each column is a component in the right forest. For example, the cell (i,j) contains vertexes which belongs to ith component in the left forest and jth component in the right tree. (Some cells may be empty.) An operation corresponds to finding two filled cells in different rows and different columns, merging the two rows, and merging the two columns.

Now we need to make operation rapidly. For each row, we maintain a set of the different columns with filled cells in this row. Symmetrically, for each column we maintain a set of the different rows with filled cells in this column.

To merge two rows, we insert the elements of the smaller set into the larger set. The smaller set is now useless, and we delete it from every column in the set and insert the larger one. Since the data structure is symmetric, merging two columns is similar.

Without loss of generality, assume there are fewer rows than columns. If there is a row whose set has more than 1 element, we can pick it and any other row, and find an operation we can make. Otherwise if all rows are singletons, then we know the sets are all disjoint because there are more columns than rows. So we can pick any two sets and make an operation, and then there's a set with more than 1 element. Maintaining which rows have sets with size more than 1 is not hard.

For each operation, we need to output the corresponding vertex in the original two forest. Firstly, choose a vertex as the representative of each cell, because all vertexes in a cell can be seen as equivalent. Then, when merging two rows or columns, we just insert the representative vertexes at the same time.

There can be at most 2n merge operations and the total complexity of them will be O(nlog2n). This is because an element moves to a new row/column O(logn) times and each move is O(logn) time (using STL set in cpp).

Overall, it's O(nlog2n)time and O(nlogn) space.

solution1559E - Mocha and StarsWe firstly ignore the constraint of gcd, let f([l1,l2,…,ln],[r1,r2,…,rn],M) be the number of integers (a1,a2,⋯,an) satisfy the following two conditions:

For all i (1≤i≤n), ai is an integer in the range [li,ri].n∑i=1 ai≤m.We can compute it in O(nM) by Knapsack DP optimized by prefix-sums.

Then we consider about the constraint of gcd, let μ(n) be Mobius function, and g(a1,a2,…,an) be 1 if (a1,a2,⋯,an) satisfies the two conditions we mentioned about (without the constraint of gcd), otherwise it will be 0.

The answer we want is:r1∑a1=l1  r2∑a2=l2 ⋯ rn∑an=ln [gcd(a1,a2,…,an)=1]g(a1,a2,…,an)=	 r1∑a1=l1  r2∑a2=l2 ⋯ rn∑an=ln g(a1,a2,…,an) ∑d∣gcd(a1,a2,…,an) μ(d)=	 r1∑a1=l1  r2∑a2=l2 ⋯ rn∑an=ln g(a1,a2,…,an) ∑d∣a1,d∣a2,…,d∣an μ(d)=	 M∑d=1 μ(d) ⌊r1d ⌋∑a1=⌈l1d ⌉  ⌊r2d ⌋∑a2=⌈l2d ⌉ ⋯ ⌊rnd ⌋∑an=⌈lnd ⌉ g(a1d,a2d,…,and) Since  n∑i=1 aid≤M can be changed to  n∑i=1 ai≤⌊Md ⌋, it equals:M∑d=1 μ(d)f(⌈l1d ⌉,⌈l2d ⌉,…,⌈lnd ⌉,⌊r1d ⌋,⌊r2d ⌋,…,⌊rnd ⌋,⌊Md ⌋) So we can compute it in O(n M∑i=1 ⌊Mi ⌋)=O(nMlogM).

solution

Codeforces Round #737 Editorial

By AhmedEzzatG, 19 months ago, In EnglishHello, Codeforces!

Hope you enjoyed the round! Editorials for all problems are out now. I hope this editorial be informative and helpful.

1557A - Ezzat and Two SubsequencesHint 1SolutionSince the average of a group of numbers always has a value between the minimum and maximum numbers in that group, it can be proved that the best approach to obtain the maximum sum of averages of two subsequences is to put the maximum number alone into one subsequence, and the rest of the numbers into the other subsequence. A proof by contradiction follows.

Assume a sorted array, so a1≤a2≤…≤an. Assume that there exists a bigger answer if you take the two greatest numbers (instead of only one) in one subsequence. Therefore, we need to prove that:

∑n−1i=1ai/(n−1)+an<∑n−2i=1ai/(n−2)+(an−1+an)/2By simplifying the inequality:

an<2/(n−1)⋅∑n−2i=1ai/(n−2)+(n−3)/(n−1)⋅an−1Assume avg1=∑n−2i=1ai/(n−2), so a1≤avg1≤an−2 as stated at the beginning of the tutorial. The inequality becomes:

an<(2⋅avg1+(n−3)⋅an−1)/(n−1)The right-hand side of the inequality is also an average avg2, such that avg1≤avg2≤an−1 (which can be further simplified to a1≤avg2≤an−1).

This means that an is strictly less than avg2. In other words, it states that an is strictly less than a certain number between a1 and an−1. This is a contradiction as we stated at the beginning of the proof that the array is sorted (an≥an−1≥…≥a1). Summing things up, taking at least one number along with the maximum number will never yield a greater answer.

Code1557B - Moamen and k-subarraysHint 1Hint 2SolutionThis problem can be solved for \textbf{at least} k subarrays as it is easy to just add extra subarrays (if needed) to achieve \textbf{exactly} k subarrays. To solve this problem, you need to know what are the numbers that can be grouped into the same subarray. This can be done by maintaining the sorted array along with the non-sorted array.

As the numbers are distinct, we can iterate over the non-sorted array, and just add each element ai to the subarray ending in ai−1 IFF they follow each other in the sorted array, or start a new subarray if they do not follow each other.

For example, if the (non-sorted) array is [ 2, 3, −1, 1], the sorted array will be [ −1, 1, 2, 3 ]. If we iterate over the non-sorted array, we will add 2 to a new subarray, then we will add 3 to the same subarray as they follow each other in the sorted array. After that, we will start a new subarray at −1 as −1 and 3 do not follow each other in the sorted array. Finally, we will add 1 to the subarray containing −1. It should end up like this: { [ 2, 3 ], [ −1, 1 ] }.

Using this approach, you can get the smallest number of subarrays needed. If it is strictly greater than the given k, the answer is ''NO''. Otherwise, it is ''YES''.

Code1557C - Moamen and XORHint 1Hint 2Hint 3SolutionFrom now on, I will use And to describe the result of the bitwise AND operation over all the elements in the array, and Xor to describe the result of the bitwise XOR operation over all the elements in the array.

Let's call the array is valid if the value of And ≥ Xor.

We don't care about the values in the array. We just need to know, for every bit, the number of indices at which this bit is on or off.

So let's build the array from the most significant bit (k−1) to the least significant bit (0) using dynamic programming and combinatorics optimization.

Define an array dp where dpi,equal = the number of ways to build the array from the i-th bit to 0-th bit. equal is true if And = Xor in the previous bits, and false if And > Xor (And < Xor is not a valid state).

Our base case is dp−1,0 = 1, and dp−1,1 = 1.

If equal is false at any moment, then you can choose any subset of indices to contain 1 in the i-th bit.

Therefore, dpi,0 = 2n ⋅ dpi−1,0.

Now if n is odd there are 2 possible choices:

You can make i-th bit = 1 in an even number of indices, then Andi will be 0 and Xori will be 0 too.You can make i-th bit = 1 in all indices, then Andi will be 1 and Xori will be 1 too.You Don't have any other valid choices. So dpi,1 = dpi−1,1 ⋅ ({number of ways to choose number of indices from n} + 1). (+1 for the second choice).

If n is even there are 2 possible choices:

You can make i-th bit = 1 in an even number (less than n) of indices, then Andi will be 0 and Xori will be 0 also.You can make i-th bit = 1 in all indices, then Andi will be 1 and Xori will be 0. and now equal will be false.You Don't have any other valid choices. So dpi,1 = dpi−1,1 ⋅ (number of ways to choose number of indices from n ) + dpi−1,0.

We can precalculate the factorial, to get nCr in O(1), and then calculate the number of ways to choose an even number from n before starting the dp. The total complexity will be O(k+n).

Code1557D - Ezzat and GridHint 1Hint 2SolutionWe can use dynamic programming to get the maximum number of rows that make a beautiful grid.

Define the 2d array, dp, where dpi,j = maximum number of rows (from row 1 to row i) that make a beautiful grid, and has 1 in column j at the last row I have in the biggest beautiful grid. the last row in the biggest beautiful grid is the not necessary to be iForm the definition:

dp0,j = 0.

dpi,j = 1 + maxk∈Ci {dpi−1,k} if gridi,j = 1.

Otherwise, if gridi,j ≠ 1, then dpi,j = dpi−1,j .

where Ci is that set of columns that contain 1 in row i.

As you know, the set Ci contains the intervals, so we just search in some intervals for the maximum, or update some intervals in the previous layer in dp. We can do it faster using Segment tree.

So the algorithm will be as follows:

Define an array prev, where previ = the previous row of i in which maximum beautiful grid end with i-th row. We will use it to get the rows that will not be removed.

Build a segment tree of pairs (value, index) initially with { 0 , −1 }.

Then for each i from 1 to n:

Get the maximum value in all the ranges [lj,rj] that contains 1 at the i-th row. Let's call it mx.Store previ = mx.index.Update all the ranges [lj,rj] of this row like this: segj = max( segj , { mx.value + 1 , i }).Finally, get the rows that have the maximum value using the prev array, and remove the others.The total complexity will be O(n+mlog109) or O(n+mlogm) if you make a coordinate compression to the values.

Code1557E - Assiut ChessHint 1Hint 2SolutionThis is one of many possible solutions. We need to force the king to move into one of the four corners (bottom right or bottom left corner in this solution) to ensure that the king will be trapped (cannot move anymore).

Place the queen on the top row. After the king makes a 1 move, he should be below the queen's row.

Suppose the queen is on the row x with the king below it (row x + i where i > 0).

If i = 1, we cannot move down to the next row as the king may move up and we will not be able to trap it. Otherwise, we can move down by one unit.

To ensure that the king is not on the next row, scan the current row, x, by moving the queen from the leftmost column to the rightmost column one square at a time. Therefore, you can move the queen as follows:

During the scan, if you have visited all 8 squares of the current row and the king never made a vertical or diagonal move, it means that i≥2 and you can go down by one row. It is now guaranteed that the king is still below the queen.

If the king were on row x + 1, he would have been forced to move 1 square down at some point. If he ever goes down, move the queen down by one row.

If the king moves up, start scanning the row again. This can only happen a limited number of times without the king moving into a check.

In total, the queen needs to apply step 2 up to 8 times. At each row, step 1 needs to be applied, so it takes 8 moves. Step 1 also needs to be applied every time step 3 is applied, which can happen at most 8 times. In total, that is 8 ⋅ (8 + 8) = 128 moves.

Code

Codeforces Round 736 Editorial

By Agnimandur, 19 months ago, In EnglishAll the division 2 problems were created by Agnimandur. 1548E - Gregor and the Two Painters was created by Benq. I hope that this hint-based editorial helps you, no matter what your rating is! Solution code is provided in both C++, Java, and Kotlin when available.

Solution Code Repository

1549A - Gregor and CryptographyHint 1SolutionSince P≥5 and is also a prime number, we know that P−1 is an even composite number. A even composite number is guaranteed to have at least 2 unique divisors greater than 1. Let two of these divisors be a and b. It is guaranteed that Pmoda=Pmodb=1, and thus this selection is valid.

For example, we can simply pick a=2 and b=P−1, and we will get a correct solution.

The time complexity is O(Q).

1549B - Gregor and the Pawn GameSolution 1Hint 1Hint 2SolutionThe key insight is that due to the fact that there is only one row of enemy pawns, and those pawns never move, there are only 3 possible columns where one of Gregor's pawns can end up in.

We can solve this problem greedily, going from column 1 to column N. At the current column j, if Gregor has a pawn in this column, then we greedily consider 3 cases.

If there is an uncaptured enemy pawn in column j−1, mark that pawn as captured and increment the answer. Column j−1 will never be looked at again, so this decision is optimal.If there is no pawn in column j, just move Gregor's pawn forward, and increment the answer.If there is an uncaptured enemy pawn in column j+1, mark that pawn as captured and increment the answer.Otherwise, this pawn will not reach the first row.This greedy solution is guaranteed to produce the maximum possible answer.

The time complexity is O(N).

Solution 2Hint 1Hint 2Hint 3Hint 4SolutionEach of Gregor's pawns can end up in one of 3 possible squares. If Gregor has a pawn in column i, it can end up in column i−1 or i+1 if there is an enemy pawn in those columns. Furthermore, it can remain in column i if there is no enemy pawn in that column.

Let's build a graph G, where each edge connects one of Gregor's pawns to a valid destination cell. Since every edge goes from a cell in the bottom row to a cell in the top row, G is clearly bipartite. It's now clear that moving as many pawns to the end is equivalent to finding a maximum matching in G.

The time complexity is O(NN−−√) using the HKK algorithm for maximum matching. (G has at most 2N vertices, and 6N edges)

1549C - Web of LiesHint 1Hint 2SolutionDue to the queries, actually simulating the process each time will be too expensive.

Proof that the Process will End: Assume after round x, xi nobles are killed. If xi=0, then the state of the graph doesn't change, so the process will have ended. If xi>0, then the number of nobles decreases. Thus, the maximum number of rounds the process can last is N, so it must end.

Lemma 1: At the end of the process, no two nobles will still be friends.

Proof by Contradiction: Assume that nobles u and v (assume WLOG that u<v) are still friends and the process is over. In order for u to avoid being killed, there must be a noble w weaker than u that is also a friend of u. The same logic then applies to w, and we have an infinite descent argument. There are only a finite number of nobles weaker than u, so there will be a contradiction.

Lemma 2: If all of a noble's friends are weaker than it, that noble cannot be killed.

Direct Proof: Since none of the noble's friends are stronger than it, it is impossible for all of them to be stronger at any point in the process.

Final Idea: By combining Lemmas 1 and 2, we can prove that if ALL of a noble's friends are weaker than it, that noble survives, otherwise it will die. This leads to the solution.

Maintain in an array the number of nobles weaker than noble i. Since the updates guarantee that the edge being removed/added does/doesn't exist respectively, we only need to keep track of the number of edges of each noble. Essentially, a noble survives if and only if weaker[i]==edges[i]. After linear precomputation, updates and queries take constant time.

The time complexity is O(N+M+Q).

1549D - Integers Have FriendsHint 1Hint 2Hint 3SolutionThe key observation is to construct the difference array D of size N−1, where D[i]=abs(A[i+1]−A[i]). If a given subarray is a friend group, then every difference is a multiple of some m. Since every element of A is distinct, the case when D[i]=0 can be ignored.

We can now convert this into a GCD (greatest common divisor) problem. It follows that A[i…j] is a friend group if and only if gcd(D[i…j−1])>1. Indeed, the value m that we want is equal to this GCD.

To solve the problem, we can use a sparse table or a segment tree to find the largest possible subarray beginning at i, and then max over all subarray answers to get the final answer.

The time complexity is O(NlogNlog1018). The first log is for the sparse table, the second is for computing GCDs.

Note that the de facto time complexity may be closer to O(NlogN+Nlog1018), due to the insights from this blog post.

1549E - The Three Little PigsSolution 1Hint 1Hint 2Hint 3SolutionFor a given x, we want to compute ∑Ni=1(3ix), which can be solved with a combinatorial dynamic programming.

Define the array dp[x][m] (dimensions: N+1×3), which computes the sum ∑N−1i=0(3i+mx). Under this definition, ans[x]=dp[x][0]+(3Nx), where ans is what we want to find.

Under the definition of the dp, we can make the following mathematical observations.

dp[x][0]+dp[x][1]+dp[x][2]=∑3N−1i=0(ix), since term i belongs to the array with m=imod3. This summation can be condensed with the Hockey Stick Identity into (3Nx+1).

By repeated uses of Pascal's Identity, we get equations (2) and (3), giving us a system of 3 equations with 3 new unknowns, which can easily be solved.

∑2m=0dp[x][m]=(3Nx+1).dp[x][1]=dp[x][0]+dp[x−1][0]dp[x][2]=dp[x][1]+dp[x−1][1]The base case is that dp[0][0]=dp[0][1]=dp[0][2]=N. Each query can now be answered trivially.

The time complexity is O(N+Q) with combinatorial precomputation.

Solution 2Hint 1Hint 2Hint 3Hint 4SolutionDefine the polynomial P(k)=(1+k)3+(1+k)6+⋅+(1+k)3N.

The coefficient of kx in P(k) is, by the Binomial theorem on each term of the polynomial, equal to (3x)+(6x)+⋯+(3Nx). This is equal to ans[x] from the previous solution.

The only thing left to do is quickly calculate P(k). Due to the tight time limit, calculating the polynomial using FFT in O(NlogN) is probably too slow.

Instead, we notice that P(k) is a geometric series. Using the geometric series formula, we get that P(k)=(1+k)3N+3−(1+k)3(1+k)3−1.

The numerator and denominator of this fraction can be expanded in linear time. Then all we have to do is a polynomial long division. Once we have P(k), we can answer all the queries trivially.

The time complexity is O(N) with combinatorial precomputation.

1549F1 - Gregor and the Odd Cows (Easy)Hint 1Hint 2Hint 3Hint 4SolutionEvery set of 3 fenceposts forms a lattice triangle We want to find the number of such lattice triangles that have an odd number of interior points. Since all the coordinates are even, the area is automatically even as well. By Pick's Theorem, area=I+B2−1, so 2⋅area=2I+B−2. I is the number of interior points, and B is the number of boundary points, for an arbitrary triangle formed by 3 fenceposts.

Let A=2⋅area, so A=2I+B−2. Since I is odd, taking both sides modulo 4 we get that A≡Bmod4. Since the area is an even integer, A is a multiple of 4, so we get that A≡B≡0mod4.

Let's define the boundary count of a segment to be the number of lattice points on it, minus 1. It can be proven that the boundary count of the segment connecting (x1,y1) and (x2,y2) is gcd(|x2−x1|,|y2−y1|).

In this problem, we only care about what the boundary count is modulo 4. Since all the coordinates are even, the GCD is guaranteed to be even, so the boundary count is either 0 or 2 mod 4. For the segment connecting (x1,y1) and (x2,y2) call its boundary count b.

b≡0mod4 IFF x1≡x2mod4 AND y1≡y2mod4.b≡2mod4 in all other situations.Key Idea: Turn fence post (x,y) into (xmod4,ymod4).

Writing the area of a triangle via the shoelace formula, it becomes obvious that the area mod 4 won't change when the coordinates are modded by 4. Additionally, by our work above, B (the sum of the boundary counts for the 3 sides of the triangle) is entirely dependent on the coordinates mod 4.

Let cnt[x][y] be an array counting the number of points that fall into each category based on the key idea above. Since all coordinates are even, only 4 elements in the cnt array will be nonzero. We can fix each point of the triangle into one of the categories, quickly calculuate A and B, and solve the problem. Be careful not to overcount triangles.

The time complexity is O(N), with a small constant for the counting.

1549F2 - Gregor and the Odd Cows (Hard)Hint 1Hint 2Hint 3Hint 4Hint 5SolutionFirst read (and understand!) the editorial for the easy version of the problem.

Definition: The modularity of a point (x,y) is (x%4,y%4).Definition: The boundary count of a segment is the number of lattice points on that segment, minus 1.Lets precompute the array cnt[i][x][y][b] (dimensions N×4×4×4), which equals the number of other points respective to points[i] with modularity (x,y) and with a boundary count mod 4 equal to b. This precomputation can be done in O(N2log107) time, by iterating over every pair of points. The boundary count of the segment (x1,y1) to (x2,y2) is gcd(|x2−x1|,|y2−y1|).

Consider the number of boundary points on the three sides of a triangle, and call them b1,b2,b3. Clearly, B=b1+b2+b3. The key idea is that since B is even, wlog we can assume that b3 is even, and that b1≡b2mod2. The other key idea is that it is easy to figure out if the boundary count is congruent to 0 or 2 mod 4 based on the modularities of the coordinates alone, but it's impossible if the boundary count is odd.

Let's fix a point, and count the number of triangles that involve this point. Let's also iterate over all the relevant modularities of the other two points in the triangle, which range from (0,0) up to (3,3). Let's also make sure that there are an even number of boundary points on the side opposite the fixed point, which we know almost nothing about. It can be shown that b3≡0mod4 IFF (x1,y1)=(x2,y2), and that b3≡2mod4 IFF x1,x2 have the same parity, and y1,y2 have the same parity, and the previous case doesn't apply. Finally, make sure that the parity of the boundary count of the two sides next to the fixed point are the same.

Using the precomputed array cnt and the formula for b3, we can quickly find B in this case. Using the Shoelace Formula, we can quickly find what A is modulo 4. If A is even and equal to B, then we know that I must be odd (in the easy version of the problem, we found that A≡Bmod4 IFF I is odd), so all triangles in this class are interesting. Thus, we add to the answer a number roughly equal to cnt[i][x1][y1][b1]⋅cnt[i][x2][y2][b2] (it could be lower due to the potential overcount, if two points fall into the same bucket of the array).

Lastly, be sure not to overcount triangles! In my code, I count each of the EEE triangles (b1,b2,b3 all even) 3 times, and the OOE triangles once.

The time complexity is O(N2log107) (the main part of the solution is approximately O(512N)).

Implementation Note: The bottleneck of the algorithm is computing the GCDs. The simplest optimization that is sufficient for AC is to only calculate N22 GCDs instead of all N2 (since the GCD is commutative). Java requires additional optimizations, such as precomputing small GCDs.

1548E - Gregor and the Two PaintersHint 1Hint 2SolutionThis editorial was written by Benq, and inspired by 1392I - Kevin and Grid.

For simplicity let's assume that all ai are distinct (and similarly, all bj). If this is not the case, we may break ties arbitrarily.

Say that two badly painted cells are directly reachable from each other if they are in the same row or column and all cells in between them are also badly painted. Also, define the value of the cell at (i,j) to be ai+bj. Call a badly painted cell a representative if no cell directly reachable from it has a smaller value than it.

Claim: Every connected component of badly painted cells contains exactly one representative.

Proof: Clearly every connected component contains at least one representative; consider the cell(s) with the minimum value contained within it. To show that every connected component contains \textit{exactly} one representative, suppose that we are given a representative (i,j) that is directly reachable from (i′,j) for all il≤i′≤ir and (i,j′) for all jl≤j′≤jr, where ai=minil≤i′≤ir(ai′) and bj=minjl≤j′≤jr(bj′). Then the connected component containing (i,j) is completely contained within the rectangle [il,ir]×[jl,jr], and (i,j) is the unique cell with the minimum value within that rectangle. This implies that a representative is always the unique cell with the minimum value within its connected component.

It remains to count the number of representatives. For each i, let loi be the maximum index less than hii such that aloi<ai and hii be the minimum index greater than i such that ahii<ai. Then define nai to be min(maxi′∈[loi,i]ai′,maxi′∈[i,hii]ai′). Any path from a cell in row i to a cell in the same column with lower value must pass through a row with value at least nai. Define nbj for each j similarly. It can be shown that (i,j) is a representative if and only if the following conditions hold:

ai+bj≤Xnai+bj>Xai+nbj>XComputing na and nb can be done in O(NlogN+MlogM) with any data structure supporting range min/max queries (e.g. sparse tables), or in O(N+M) with a stack.

It remains to count the number of pairs (i,j) that satisfy these conditions given a, na, b, and nb. First initialize two binary indexed trees Ta and Tb. Then sort the pairs (nai−ai,ai),(nbj−bj,bj) in decreasing order. Now for every pair in the order, if it is of the form (nai−ai,ai), then add to the answer the number of elements of Tb that are in the range (X−nai,X−ai], and add ai to Ta. The reasoning for the case (nbj−bj,bj) is similar (query Ta, update Tb).

The time complexity is O(NlogN+MlogM) for sorting the pairs and working with the two BITs.

Editorial of Codeforces Round #735 (Div. 2)

By YouKn0wWho, 19 months ago, In EnglishThe problem names are based on my favorite characters out there. Yes, 1554E - You are my most favorite character UwU.

I have tried to make the editorials as interactive as possible. Enjoy.

1554A - CherryDo we really need to check all the subarrays?

Consider a subarray (ai,ai+1,…,aj). If we add a new element aj+1, when will the new subarray (ai,ai+1,…,aj,aj+1) give a better result? Pause and think.

The minimum of the new subarray can't get better(the minimum of a smaller subarray ≥ the minimum of a larger subarray). So only when aj+1 is greater than the previous maximum, then it will give a better result. But in that case, do we really need to check the whole subarray to get that result? Can we get the same or a better result from a smaller subarray? Think.

Here the maximum is aj+1. So if the minimum is not ai, then the subarray (ai+1,ai+2,…,aj+1) will give the same result. Otherwise, the minimum of (ai+1,ai+2,…,aj+1) will not be smaller which implies that (ai+1,ai+2,…,aj+1) will give a better result!

So if we add a new element, we don't have to check the whole subarray, checking (ai,ai+1,…,aj) and (ai+1,ai+2,…,aj+1) is enough.

What good this observation just brought to this world? Think.

Yes, we don't have to check subarrays with length >2, because according to the observation, (a1,a2,a3) won't give a better result than (a1,a2) and (a2,a3). And subarrays with length 4 won't give a better result than subarrays with length 3 and subarrays with length 3 won't give a better result than subarrays with length 2. You got the idea, right?

Another thing to notice here is that the product of maximum and minimum of two integers is just the product of two integers. So the answer to the problem is the maximum of the products of adjacent elements in a.

Time Complexity: O(n)

Code(C++)Code(Python)1554B - CobbLet f(i,j)=i⋅j−k⋅(ai|aj) for i<j.

Do we really need to check all pairs?

The value of k is small, which is suspicious. There must be something revolving around it. What can that be?

In the equation, i⋅j can be O(n2), but k⋅(ai|aj) is O(n⋅100). That means the value of f(i,j) must be larger for bigger i,j. Can you deduce something from this?

What is the smallest i which can contribute to the result(f(i,j):i<j is the maximum)? Pause and think. Hint: try to maximize f(i,j) and minimize the heaviest pair, that is, f(n−1,n), and compare them.

Let's find it. What is the maximum possible value of a pair containing i?. It's when i pairs with n and ai=an=0. So, f(i,n)=i⋅n−k⋅0=i⋅n.

What is the minimum possible value of the heaviest pair f(n−1,n)? It's when an−1|an is maximum. And, since 0≤ai≤n, the maximum possible of value any ai|aj is ≤2n. So f(n−1,n)=(n−1)⋅n−k⋅2n=n2−2kn−n.

For i to contribute to the result, f(i,n) must be >f(n−1,n). And, when f(i,n)>f(n−1,n), then i⋅n>n2−2kn−n, or i>n−2k−1. So any of f(i,j) such that i<n−2k won't generate a value greater than f(n−1,n)!. This indicates us that we just have to check the pairs f(i,j) such that i,j≥n−2k. And, there are only O(k2) such pairs, so we can brute-force.

We have also allowed O(n⋅k) solutions to pass i.e. brute-forcing over all pairs such that 1≤i≤n and n−2k≤j≤n.

Time Complexity: O(k2)

Code(C++)Code(Python)1554C - MikasaHow can we check if k is present in the sequence n⊕0,n⊕1,...,n⊕m ? Think.

If k is present in the sequence, then there must be some x such that 0≤x≤m and n⊕x=k, right?

Did you know that n⊕k=x is equivalent to n⊕x=k ?

So we can just check if n⊕k≤m or not! Pretty simple!

So the modified problem is to find the smallest non-negative integer k such that n⊕k≥m+1. Can you solve it now?

Think using bits.

Let p=m+1 and ti be the i-th bit of t. We will find the smallest k such that n⊕k≥p.

Let's build k greedily from the highest bit to the lowest bit. Let's say we will find the i-th bit of k and the higher bits have already been generated. Obviously, we will try to make this bit off if possible. When will it be impossible? Think.

If ni=pi, we can set ki=0 as ni⊕0=ni≥pi. If ni=1 and pi=0, we can break here by setting the remaining bits of k off as no matter what the remaining bits of n are, n⊕k will always be greater than p. Finally, if ni=0 and pi=1, we must set ki=1, as we have no other options.

Check my solution for more clarity.

Time Complexity: O(log(n)) per test case.

Code(C++)Code(Python)1554D - DianeConsider the strings of type "aa…a". Which substring occurs in which parity? Observe. Play with them.

Consider the string "aa…a" (k times 'a'). WLOG Let k be an odd integer. In this string "a" occurs k times, "aa" occurs k−1 times and so on. So "a", "aa", "aaa", … occurs odd, even, odd, even, … times, respectively.

Now let's look at the string "aa…a" (k−1 times 'a'). In this string, "a", "aa", "aaa", … occurs even, odd, even, odd, … times, respectively. What can be done now?

Did you know that odd + even = odd?

Pause and think.

Let's merge both strings! If we merge them with "b" in-between i.e. " aaa…aaa⏟ k times b aaa…aa⏟ k - 1 times ", then each substring will occur an odd number of times. Thats because each of "a", "aa", "aaa", … occurs odd + even = odd times, and each newly created substring occurs exactly once.

What will happen if we set k=⌊n2 ⌋?

So here is the solution to the problem: " aaa…aaa⏟ k times +b|bc+ aaa…aa⏟ k- 1 times ", where k=⌊n2 ⌋ and "b" when n is even and "bc" when n is odd. For example, if n=6, answer is "aaabaa" and if n=7, answer is "aaabcaa".

Time Complexity: O(n)

Code(C++)Code(Python)If you are wondering(as you always do ｡^‿^｡) about the checker:

Checker1554E - YouLet's find which sequences of a are possible to obtain by performing the mentioned operations exactly n times in some order.

(Critical) Observation 1: Consider all ai=0 initially. For each edge (u,v), either increase au by 1 (assign (u,v) to u) or increase av by 1 ((assign (u,v) to v). The final sequences are the only possible sequences that a can possibly be. You can observe it by noticing that when we select a node and delete it, the existing edges adjacent to the node gets assigned to it.

Notice that, the final sequences are unique. So there are 2n−1 distinct sequences possible. That's because there are n−1 edges and for each edge (u,v) we have 2 options — either assign it to u or v.

Now for each k from 1 to n, we have to find the number of sequences which has gcd equals to k. Instead, let's find the number of sequences such that each of its values is divisible by k. Let it be fk.

For k=1, all sequences are valid. So f1=2n−1.

Assume k>1. Let's construct a sequence a such that each ai is divisible by k. First, root the tree at node 1. We will build the array in a bottom-up manner. Let gu be the set of childs of u and pu be the parent of u. Assume that we have set the values for each v∈gu. Now we will set the value of au. For each edge (u,v) such that v∈gu, if we have assigned this edge to v, then do nothing, otherwise we must assign it to u i.e increase au by 1. After we are done with all the edges,

if au is divisible by k, then we can't assign the edge (pu,u) to u because au will be increased by 1 and as au is divisible by k, (au+1) will not be divisible by k because k>1.if au is not divisible by k, then we must assign the edge (pu,u) to u and thus increasing au by 1. If now au is divisible by k, then we are done, otherwise we can't make au divisible by k. So we terminate here.If we can successfully set the values of ai for each i from 1 to n, then fk will be non-zero.

Observation 2: fk for k>1 is either 0 or 1. We can say this by observing the building process of ai that has been discussed already.

So for each k from 1 to n, we can find the value of fk in O(n) by performing a simple dfs. So all fk can be found in O(n2).

Observation 3: If k doesn't divide n−1, then fk=0.

Proof: Notice that  n∑i=1 ai=n−1. So for any integer k, if each ai is divisible k, then k must divide n−1. Similarly, if k doesn't divide n−1, then each ai will not be divisible by k and fk will be 0.

So we only have to perform a dfs when k divides n−1. So all fk can be found in O(n⋅σ0(n−1)) where σ0(x) is the number of divisors of x.

Let hk be the number of sequences which has gcd equals to k. We can notice that hk=fk− ⌊nk ⌋∑i=2 hi⋅k.

So we can find hk for each k from 1 to n in O(n⋅log(n)).

Time Complexity: O(n⋅σ0(n−1)+n⋅log(n))

Code(C++)

Editorial for Codeforces Round #734 (Div.3)

By MrPaul_TUser, history, 19 months ago, translation, In EnglishIdeas: MikeMirzayanov.

1551A - Polycarp and Coins

Tutorial1551A - Polycarp and CoinsLet's initialize variables c1 and c2 by the same value of ⌊n3⌋. Then we need to gather additionally the remainder of dividing n by 3.

If the remainder is equal to 0, we don't need to gather anything else because the variables c1 and c2 have been already set to the correct answer: |c1−c2|=0 because c1=c2 and no absolute value can be less than 0. Otherwise, |c1−c2|≠0 because c1=c2 and n=c1+2×c2=3×c1 in this case, but that's impossible if n isn't divisible by 3.

If the remainder is equal to 1, then we need to gather additionally 1 burle using one coin of 1 burle so let's increase c1 by 1. In this case, c1=c2+1, hence |c1−c2|=1, this value cannot be less than 1, as it was proved above.

If the remainder is equal to 2, then we need to gather additionally 2 burles using one coin of 2 burles so let's increase c2 by 1. In this case, c2=c1+1, hence |c1−c2|=1, this value cannot be less than 1.

There are no other remainders of dividing by 3 so these cases cover the whole solution.

Solution1551B1 - Wonderful Coloring - 1

Tutorial1551B1 - Wonderful Coloring - 1Let's calculate the number of letters which occur exactly once in the string and letters that occur more than once — c1 and c2, respectively.

If a letter occurs more than once, one of its occurrences may be painted in red and another one may be painted in green. We cannot paint all other occurrences because there will be two equal letters painted in one color, but this is unacceptable by the statement. So there are no more than c2 occurrences of letters that occur more than once to be painted in red. Let's select c2 such occurrences and paint them. We need to paint additionally the letters which occur exactly once by meeting the same conditions as we meet painting the whole string.

There's no way to paint these letters and not meet the first two conditions. So we must select the maximal count of the letters so that we will be able to paint some set of remaining letters in green so that the number of red letters will be equal to the number of green letters. This number is equal to ⌊c12⌋.

So the final answer is equal to c2+⌊c12⌋.

Solution1551B2 - Wonderful Coloring - 2

Tutorial1551B2 - Wonderful Coloring - 2Since we must use exactly k colors, each element that occurs in the sequence may have no more than k painted occurrences. Let's select for each element x min(k,cntx) its occurrences where cntx is the number of all its occurrences in the sequence.

Let b1,b2,…,bm be a sequence of all elements that occur in the sequence a, but in the sequence b they will occur only once. Let's create a 1-indexed array p in which we will add sequentially indices of the selected occurrences of b1 in the sequence a, then the selected occurrences of b2, and so on till bm. Currently, p is a set of occurrences, which wonderful coloring is a wonderful coloring of the whole sequence a because if we want to paint an occurrence outside p, we can do it only by selecting an occurrence of the same element in p which we will not paint so that no more than k occurrences will be painted.

We must use exactly k colors and paint for each color an equal number of occurrences, hence if we want to paint all occurrences from p, we must remove from it the minimum number of occurrences so that the size of the array p will be divided by k (i. e. remove the number of occurrences equal to the remainder of dividing the size of p by k). We can remove any occurrences, for example, let's delete it from the suffix of p. Currently, we can paint all occurrences from p using the following rule: the occurrence pi we must paint in the color with a number ((i−1)%k)+1 where % takes the remainder of dividing the left operand by the right operand. So all occurrences from p will be painted and all k colors will be used. Since all occurrences of one element belong to one subsegment of p and their number isn't greater than k, they will be painted in different colors.

It may be so that the array p before painting will be empty. In this case, the wonderful coloring of a doesn't contain any painted element.

Solution1551C - Interesting Story

Tutorial1551C - Interesting StoryLet f(s,c) be the number of the occurrences of the letter c in the word s minus the number of the occurrences of all other letters in total. Since for each two words s1 and s2 the number of the occurrences of a letter in the word s1+s2 is the sum of the numbers of its occurrences in s1 and s2, the equality f(s1+s2,c)=f(s1,c)+f(s2,c) is true (s1+s2 means the concatenation of s1 and s2).

Consider a sequence of words s1,s2,…,sn. A story consisting of words si1,si2,…,sim is interesting if and only if there's a letter c such that f(si1+si2+…+sim,c)>0 — it exactly means that there's a letter which occurs more times than all other in total. So we are interested in searching for a letter c such that exists a positive integer m — a maximal number of words si1,si2,…,sim such that ∑j=1mf(sij,c)=f(si1+si2+…+sim,c)>0.

Suppose we have a set of words that form an interesting story and where c is the letter having more occurrences than all other letters in total. Suppose we can add to it one of few words. We had better add a word s such that f(s,c) is maximal to be able to add more words in the future.

So the problem has the following solution: for each letter c of the Latin alphabet and for each word si let's calculate f(s,c). Then let's iterate over all letters c, take a sequence f(s1,c),f(s2,c),…,f(sn,c) and sort it in descending order. Let's initialize an interesting story by a set of a single word corresponding to the first element of the sequence. If there's no word s such that f(s,c)≤0, then there's no non-empty interesting story containing some words of the given set. Otherwise, let's take the next elements of the sequence sequentially until the sum of f(s,c) over all taken words s is greater than zero. Let's select a letter such that the corresponding taken set is maximal over all letters. Finally, we should print the set's size.

The solution consists of two phases: the calculation of all f(s,c) (works in O(L×∑i=1n|si|) where L is the alphabet's size, |s| is the lengths of a string s) and building a maximal interesting story for each letter c (sorting and a greedy algorithm — O(L×n×logn)).

Solution1551D1 - Domino (easy version)

Tutorial1551D1 - Domino (easy version)See the tutorial for problem D2.

Solution1551D2 - Domino (hard version)

Tutorial1551D2 - Domino (hard version)Suppose n and m are even. A necessary and sufficient condition of existence of the answer is that k is even.

Let's prove the sufficient condition. If the count of the horizontal dominoes is even, then we can combine them and vertical dominoes to blocks of size 2×2 (the number of the vertical dominoes is even, too, if k is even). If n and m are even, we can fill the table with these blocks. The description of the locations of the dominoes may be printed as follows: consider the table is a chessboard where a cell is a block of two dominoes. Consider the leftmost topmost cell of the board is black. If a cell of the board is black, let's mark one of the dominoes of the block with the letter "a" and the other one with the letter "b". If a cell of the board is white, let's mark one of the dominoes of the block with the letter "c" and the other one with the letter "d". There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes.

Let's prove the necessary condition. The number of cells in a column (n) is even, so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time. So the number of cells that belong to horizontal dominoes is even. Let's cross out all cells that belong to vertical dominoes and let's find the leftmost column having cells that haven't been crossed out. It's the leftmost column with such cells so the pairwise cells of the non-crossed out cells belong to the column to the right of the found one. The number of such cells in the right column is equal to the number of found cells so it's even and the number of found horizontal dominoes is even, too. Let's cross out the found cells and the pairwise cells. The number of non-crossed out cells in the right column will be even. The number of crossed-out horizontal dominoes will be even, too. Let's repeat this procedure until all the dominoes will be crossed out. In every step, we have crossed out the even number of horizontal dominoes, hence the total count of horizontal dominoes is even.

Suppose n is odd, hence m is even. In this case, every column contains an odd number of cells, whereas the number of cells that belong to vertical dominoes is even. So the number of cells that belong to horizontal dominoes is odd. Consider the leftmost column and find a cell of it that belongs to a horizontal domino (it must be found because the number of such cells is odd so it isn't equal to 0). Let's find the pairwise cell and cross out both cells. Currently, the two columns will have an even number of non-crossed-out cells. Let's repeat the procedure until all columns will have even non-crossed-out cells. We will cross out m cells and m2 dominoes. So the necessary condition is that the number of horizontal dominoes (k) is at least m2.

Let's extend the necessary condition with the following condition: the value of k−m2 is even. Consider the table that we've become after the previous procedure where each column has exactly one crossed-out cell. Let's start the procedure we've done in the case of even both n and m. The procedure can be started on our table because each column of the table has an even number of non-crossed-out cells. As a result of the procedure, we will cross out an even count of horizontal dominoes, so the value of k−m2 is even.

Let's build an answer if the conditions k≥m2 and k−m2 is even are met. Let's place in the topmost row m2 horizontal dominoes and mark their cells as follows: the first domino will be marked with "x", the second one — with "y", the third one — with "x", and so on. As the result, the region of n−1 rows and m columns will be unfilled. Both values are even, and the value of k−m2 is even, too. So let's fill the region as if it's a separate table having even numbers of rows and columns. As it was proved above, it's possible to do. The set of letters used for the region and set of the letters used for the topmost row don't have common elements, so there will be no cells that are marked with one letter but belong to different dominoes.

The case of odd m (hence, n is even) is similar to the previous one — let's transpose the table (it will have m rows and n columns), swap the values of k and nm2−k, solve the case above and transpose the table back to have n rows and m columns.

Solution1551E - Fixed Points

Tutorial1551E - Fixed PointsLet's use the concept of dynamic programming. Let's create an array dp (0-indexed) with size of (n+1)×(n+1). dp[i][j] will contain the maximal number of the elements equal to their indices if we have considered the first i elements of the sequence a and have not deleted j elements.

Let's fill the array with zeroes, then we will increase the elements of the array for different i and j. Let's start the for-loop with parameter i from 0 to n−1 and the internal one with parameter j from 0 to i. Consider an element ai+1. We can delete or not delete it.

If we delete this element, the number of the elements equal to their indices will not be increased and the number of the non-deleted element will not be increased, too. It means that the answer for dp[i+1][j] may be updated with dp[i][j]. Since we are interested in a maximum answer, we rewrite dp[i+1][j] only if dp[i][j] is greater than dp[i+1][j].

Suppose we don't delete this element. We haven't deleted previously j elements so ai+1 will have the index (j+1) and there will be j+1 non-deleted elements if we consider i+1 elements so we must update dp[i+1][j+1]. If ai+1=j+1 (i. e. an element equal to its index is found), let's update dp[i+1][j+1] with dp[i][j]+1. Otherwise, we should update it with dp[i][j]. Remember that update may be done only if we rewrite the less value with the greater value.

Let's build the answer as follows. We need to minimize the number of deleted elements (maximize the number of non-deleted elements) so that the number of the elements equal to their indices is at least k. Consider only the elements of dp having the first index i=n. Let's start a for-loop in the descending order of j. If dp[n][j]≥k, j is the maximum number of elements that we will not delete, so the answer is n−j. If we will not find j such that dp[n][j]≥k, there's no desired sequence of moves so the answer is −1.

The algorithm works in O(n2).

Solution1551F - Equidistant Vertices

Tutorial1551F - Equidistant VerticesIf k=2, any set of two vertices may be taken so the answer is n(n−1)2 modulo 109+7.

Suppose k≥3. Consider three vertices A, B, C such that dA,B=dA,C=dB,C. If this equality is true, there's a vertex Q that belongs to all three paths, otherwise, either one of the vertices belongs to the path between two others or there is more than one simple path (i. e. path having distinct edges) between any of the vertices so the graph isn't a tree. Hence, the following equalities are true:

dA,B=dA,Q+dB,Q,dA,C=dA,Q+dC,Q,dB,C=dB,Q+dC,Q.Then

dA,Q+dB,Q=dA,Q+dC,Q,dA,Q+dB,Q=dB,Q+dC,Q,dA,Q+dC,Q=dB,Q+dC,Q,hence, dA,Q=dB,Q=dC,Q.

Suppose k>3. Let's select vertices A, B, C, D that is a correct desired set of four vertices, for the triple of paths AB, AC, BC let's select a common vertex Q and for the triple BC, CD, BD — Q′. Because

dB,Q=dC,Q,dB,Q′=dC,Q′Q is the same vertex as Q′. The same procedure we can do for all other pairs of triples of vertices. The situation will not be another if we add a new vertex in the set if the set will still meet the problem's conditions. So if k≥3, a vertex Q exists such that all vertices of the set are equidistant from it.

Note that for each set only one such Q exists. Let's iterate over all vertices taking them as Q and "hang" the tree by Q. The set of k vertices equidistant from Q meets the problem's condition if and only if the vertices of the set are placed in different subtrees of vertices adjacent to Q (in other words, the paths from them to Q must intersect only in Q).

Let's calculate the number of desired sets for a given Q and a layer of equidistant vertices. Let LQ be the number of vertices adjacent to Q (and it's the number of subtrees, too). Let's create an array cnt (1-indexed) of size LQ so that the i-th element will contain the number of the vertices of the layer in the i-th subtree. For the layer of vertices adjacent to Q, this array will be filled with 1. For the other layers, we can update the array as follows: let's mark Q and vertices adjacent to Q as used, then for every vertex of the current layer let's decrease cnt[i] by 1 if i is the index of the subtree of the vertex, then let's increase cnt[i] by the number of the vertices adjacent to the current one but not used. Then let's mark the vertices as used. After the iteration, the array cnt will correspond to the new layer.

Using the array, let's calculate the number of the desired sets of k vertices using the concept of dynamic programming. Let's create an array dp (0-indexed) of size (LQ+1)×(k+1). dp[i][j] will contain a number of found sets of j vertices if only i subtrees have been considered. Let's fill the array with 0 except dp[0][0]=1. Let's start a for-loop with parameter i from 0 to LQ−1 and the internal one with parameter j from 0 to k. In every step, we can either take a vertex from (i+1)-th subtree or take nothing.

If we take a vertex from the subtree (it's possible only if j<k), then we have cnt[i+1]⋅dp[i][j] ways to select j+1 vertices considering i+1 subtrees so that the last vertex belongs to the (i+1)-th subtree. This value we must add to dp[i+1][j+1] that must contain all ways to select j+1 vertices from i+1 subtrees.

If we ignore the subtree, the number of ways to select j vertices from i+1 subtrees ignoring the (i+1)-th subtree is dp[i][j]. It must be added to the number of ways to select j vertices from i+1 subtrees — dp[i+1][j].

The answer for the current Q and the current layer of equidistant vertices is dp[LQ][k]. The answer for the whole tree is the sum of the answers for all Q and for all layers of equidistant vertices. Remember that all arithmetical operations must be done modulo 109+7.

The number of possible central vertices is n. For every central vertex and every layer we perform two actions: recalculate the array cnt and calculate the number of the corresponding sets using the concept of dynamic programming. The recalculation of cnt works in O(LQk), it's just BFS starting from Q so for every central vertex it works in O(n). The dynamic programming for the current Q and the current layer works in O(LQk), for the current Q and all layers — in O(nLQk). The summary time corresponding to the current Q is O(nLQk).

The total algorithm work time is ∑Q=1nO(nLQK)=O(nk∑Q=1nLQ). The sum of all LQ is a total number of the adjacent vertices to all vertices, it's just a double number of edges — 2(n−1). So the total work time is O(n2k).

Solution

Codeforces Round #733 Editorial (all problems)

By tourist, 19 months ago, In EnglishHope you enjoyed the round! Editorials for all problems are out now. Also check out ecnerwala's stream where we went through individual problems and discussed the contest as a whole: https://www.youtube.com/watch?v=5Q4tGWT7p7I.

1530A - Binary DecimalLet d be the largest decimal digit of n.

Note that we need at least d binary decimals to represent n as a sum. Indeed, if we only use k<d binary decimals, no digit of the sum will ever exceed k. However, we need at least one digit equal to d.

At the same time, it is easy to construct an answer with exactly d terms. Start with all terms equal to 0, and consider each digit separately. Let the i-th digit of n be ai. Pick any ai terms out of the d terms we have, and add 1 to their i-th digits.

Therefore, the answer is d.

1530B - Putting PlatesThere are many ways to solve this problem and even more ways to get it accepted. Let's consider a provable solution that minimizes the amount of casework.

We'll call a valid solution optimal if it has the largest possible number of plates.

Claim. There exists an optimal solution that contains a plate in every corner of the table.

Proof. Consider any optimal solution, and consider all four corners one-by-one in any order.

If a corner contains a plate, do nothing.

If a corner doesn't contain a plate, but either of its neighbors does, move the plate from the neighbor to the corner. Note that we'll still obtain a valid optimal solution.

If neither a corner nor any of its neighbors contain a plate, we can put a plate into the corner, increasing the number of plates and contradicting the optimality of our solution. Thus, this case is impossible.

After considering all four corners, we'll obtain an optimal solution with a plate in every corner of the table, as desired. ■Once we put a plate in every corner, four sides of the table don't interact anymore, and we can solve the problem on each side independently. Putting as many plates as possible on one side is easy: just leave one empty cell between neighboring plates, and maybe leave two empty cells at the end if the length of the side is even.

1530C - PursuitThe first thing to notice is that since we're chasing Ilya and we want to reach his score as soon as possible, it only makes sense to add 100's to our scores and 0's to his.

We can also notice that the answer never exceeds n. No matter how bad a stage is for us in terms of points, adding a single stage where we score 100 and Ilya scores 0 "compensates" it. In particular, in the worst case, when all ai=0 and all bi=100, the answer is exactly n.

However, if we just add the 100/0 stages one-by-one and calculate the overall results from scratch every time, our solution will have O(n2) complexity and that's too much.

There are many ways to optimize the solution.

One of them is to transform the given a and b arrays into arrays of length 101, containing the count of each score (since we are not interested in the order of the scores). Let m=100 be the maximum achievable score in a stage. Using the transformed arrays, we can calculate the overall scores in O(m) instead of O(n), to lower the final complexity to O(mn).

Alternatively, notice that when we add 100 to our scores, it just adds 100 to our overall score except for the case when the total number of completed stages becomes divisible by 4, when we also need to subtract the score of the worst currently included stage from the sum. We can similarly handle adding 0 to Ilya's scores. If we sort all our and Ilya's scores at the beginning and maintain a pointer to the current worst included stage in both scoresheets, we can add a new 100/0 stage and recalculate the totals in O(1).

Finally, we can also notice that whenever adding k stages works for us, adding k+1 stages will work too. Thus, we can use binary search on k. We can easily check a single value of k in O(n) or O(nlogn), resulting in O(nlogn) or O(nlog2n) time complexity.

1530D - Secret SantaLet m be the number of different values among ai (that is, the number of distinct employees someone wishes to make a gift to).

It's easy to see that the answer, k, can not exceed m: each employee mentioned in ai allows us to fulfill at most one wish.

It turns out that k can always be equal to m, and here's how.

We can visualize the problem in terms of graphs. We are given a functional graph G (for each i, there is an edge from i to ai), and we need to find a directed graph that consists of cycles of length at least 2 and shares as many edges with G as possible.

For each vertex in G that has at least one incoming edge, keep any of these edges and remove the others. Now every vertex has outdegree at most 1 and indegree at most 1. Hence, our graph becomes a collection of paths and cycles (isolated vertices are considered to be paths of length 0).

Let the paths be P1,P2,…,Pt. For each i=1…t, create an edge from the end of path Pi to the beginning of path Pimodt+1. That is, we are forming a single loop out of all the paths.

This will always work except for one case: if the new loop we are forming has length 1. It means that we have a single isolated vertex v, and all other vertices form valid cycles.

If we ever arrive at this case, we can pick the initial edge going from v to av, return it to the graph, and remove the other edge going from some vertex u into av that we kept. This will break the cycle containing vertex av without changing the number of edges shared with the initial graph. Finally, add an edge from u to v closing the cycle, and that will give us a correct answer.

Alternatively, to not ever arrive at the bad case, we can use the knowledge of our future selves at the earlier stage of choosing the edges to keep and remove, and prioritize keeping edges going from vertices with indegree 0.

Finally, randomized solutions are also possible. For example, we can select the edges to keep at random, write down the sets of vertices with indegree 0 and vertices with outdegree 0, shuffle both sets, and try to create an edge from the i-th vertex of one set to the i-th vertex of the other one. If we fail, and that can only happen when we try to create an edge from a vertex to self, we just start the process from scratch. With an argument similar to counting derangements, it can be shown that the expected number of iterations until we find a correct answer is constant.

1530E - MinimaxThis problem required careful case analysis.

First of all, if all characters of s are the same, there is nothing to reorder: t=s, and f(t)=|t|−1.

Second, if the first character of t appears somewhere else in the string, f(t)≥1. Otherwise, f(t)=0.

Thus, if some character has only one occurrence in s, choose the smallest such character and put it at the front of t, followed by all the remaining characters of s in alphabetical order. That's the lexicographically smallest way to obtain f(t)=0.

Otherwise, if all characters have at least two occurrences in s, we can always reach f(t)=1. The easiest way to construct such t is to choose any character, put one of its occurrences at the front of t, put the remaining occurrences at the back of t, and put the rest of the characters in-between ordered arbitrarily. However, we have to minimize t lexicographically.

First, we have to put the smallest character of s at the front of t, say, a. Then, let's try to follow it with the same character. In this case, t starts with aa, and we can't have another occurrence of aa anywhere in t, as we aim at f(t)=1, which means that at most half of the letters (approximately) can be equal to a. The exact condition of whether we can start with aa is: the number of occurrences of a in s must not exceed |s|2+1. If this is the case, the lexicographically smallest t we can form will look like aabababacacadddeeefffff.

If t starts with a, but can not start with aa, let's find the second smallest character in s, say, b, and start t with ab. Now we are not allowed to have ab anywhere else in t. There are two (final) cases:

if s doesn't have any other characters except a and b, we have to put all the remaining b's in front of all a's. The smallest t will look like abbbbbbbaaaaaaaaaaaaa.otherwise, find the third smallest character in s, say, c. We can now afford putting all a's after the ab prefix if we follow these a's with c. The smallest t will look like abaaaaaaaaaaacbbbcddd.It's possible to consider less cases if you implement a function that checks if a prefix of t can be finished with the remaining characters of s to obtain f(t)=1. Then t can be formed character-by-character from left to right. This approach still requires care, though.

1530F - BingoLet l1,l2,…,l2n+2 denote the 2n+2 possible lines that can be formed. Let Li denote the event that line li is formed, and Li¯¯¯¯¯ denote the event that line li is not formed (i.e., P(Li)+P(Li¯¯¯¯¯)=1).

Let's find the probability that our table is not winning. It is equal to P(L1¯¯¯¯¯¯∩L2¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯).

Note that the following two statements are true:

P(L1¯¯¯¯¯¯∩L2¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯)+P(L1∩L2¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯)=P(L2¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯);P(L1∩L2¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯)=P(L2¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯|L1)⋅P(L1).The first one follows from the law of total probability, and the second one follows from the definition of conditional probability.

These two statements combined allow us to use the following formula:

P(L1¯¯¯¯¯¯∩L2¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯)=P(L2¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯)−P(L2¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯|L1)⋅P(L1).We can apply this formula recursively. Specifically, we can make a function f(i,S), where S={s1,s2,…,sk} is a subset of {1,2,…,i−1}, which calculates P(Li¯¯¯¯¯∩Li+1¯¯¯¯¯¯¯¯¯¯∩…∩L2n+2¯¯¯¯¯¯¯¯¯¯¯¯|Ls1∩…∩Lsk). For i=2n+3, f(i,S)=1, and for i≤2n+2 we can generalize the formula above as follows:

f(i,S)=f(i+1,S)−f(i+1,S∪{i})⋅P(Li|Ls1∩…∩Lsk).Here, P(Li|Ls1∩…∩Lsk) is the probability that line li is formed given that lines ls1,…,lsk are formed. This is equal to the product of probabilities of all cells belonging to li which do not belong to any of ls1,…,lsk.

The answer to the problem, i.e. the probability that our table is winning, is 1−f(1,{}).

This allows us to implement an O(22n⋅n) solution, which is too slow. In fact, this solution is equivalent to applying inclusion-exclusion principle.

To optimize this solution, note that once it becomes easy to calculate f(i,S), we don't have to make any more recursive calls. Why would it become easy to calculate f(i,S) though?

Let's order the lines in such a way that ln+3,ln+4,…,l2n+2 are the horizontal lines of the table. Consider a call of the form f(n+3,S). This call is basically asking: "what is the probability that none of lines ln+3,ln+4,…,l2n+2 are formed, given that lines ls1,…,Lsk are formed?".

Note that the horizontal lines are independent, and we can actually answer this question in O(n2). Specifically, for any horizontal line, the probability that it is not formed is 1 minus the product of probabilities of all its cells not belonging to any of ls1,…,lsk. The overall value of f(n+3,S) is the product of probabilities for individual horizontal lines.

This way, we have built an O(2n⋅n2) solution. This might be fast enough depending on your implementation, but there are at least two ways to optimize it to O(2n⋅n):

The first way is to maintain the products of probabilities of untouched cells for horizontal lines on the fly. For simplicity, assume that l1 and l2 are the diagonal lines. For each i=3,4,…,n+2, after we process (vertical) line li, we can update the products for all horizontal lines with the cells of li (in O(n)), make a recursive call, and roll back the updates (in O(n) again). Once we get to i=n+3, instead of going through every cell of the table in O(n2), we can just multiply n horizontal line products in O(n).The second way is to define g(i,mask) (1≤i≤n; mask is a bitmask of size n) to be the product of ai,j over all j belonging to mask. All values of g can be calculated in O(2n⋅n) using dynamic programming: g(i,0)=1, and g(i,mask)=g(i,mask⊕2j)⋅ai,j, where j is any bit set in mask. When we arrive at a f(n+3,S) call, for each of the n horizontal lines, instead of going through its cells, we can construct the mask of cells the values in which we want to multiply, and use the corresponding value of g in O(1).1530G - What a ReversalFirst of all, the number of 1's in a and b must match. Let c be the number of 1's in a.

If k=0 or k>c, we can not do a meaningful reversal, so we just check if a=b.

If k=c, we can not change the contents of a between the leftmost and the rightmost 1's, we can only reverse it and shift with regard to the outside 0's. It's easy to check whether a can become equal to b then, and at most 2 steps are required if so.

Otherwise, suppose 0<k<c. Since our operations are reversible, we'll apply a usual trick: we'll transform both strings into some canonical representations in at most 2n steps each. If a's and b's canonical representations don't match, we'll prove that there is no solution. Otherwise, we can transform a into b in at most 4n steps: transform a into the canonical representation, and then perform the steps transforming b into the canonical representation, but in reverse order. What representation is canonical is for us to determine later.

We'll focus on one string now. Let's write down the lengths of blocks of consecutive 0's in the string. Formally, let p0,p1,p2,…,pc be the sequence consisting of the number of 0's: before the first 1, between the first and the second 1's, …, after the last 1. Note that some pi might be equal to 0.

What does a single reversal do to the sequence of blocks? k+1 consecutive blocks get reversed, and additionally, the 0's in the leftmost and the rightmost block of these k+1 blocks can be redistributed arbitrarily.

It turns out that we don't need more than k+2 blocks to achieve our goal (we'll see that later), so let's start with the following. Let pi be the rightmost block such that pi>0. If i≤k+1, stop. Otherwise, perform two reversals of blocks pi−k,pi−k+1,…,pi, moving all the 0's from pi to pi−k in the process, effectively making pi zero, and repeat. After this process, only p0,p1,…,pk+1 can still be non-zero.

Now, consider what happens if we reverse p0,p1,…,pk, and then reverse p1,p2,…,pk+1 without changing any values: sequence p0,p1,…,pk+1 will change to pk,pk+1,p0,p1,…,pk−1, that is, will cyclically shift by two positions to the right.

Suppose we repeat this pair of reversals k+1 times. The k-th (0-indexed) position initially contains pk, after the first pair it will contain pk−2, then pk−4 and so on. Assume that k is odd. Then every block will reach the k-th position at some point!

Now, during the first reversal in the pair, let's move all 0's from the k-th block to the 0-th block, and keep the second reversal in the pair as is, without changing the values. Then, after k+1 pairs of reversals, all the 0's will move to the 0-th block, that is, all p1,p2,…,pk+1 will become zero.

We can for sure call this representation — with all of p1,p2,…,pc zeroed out, and p0 equal to the number of 0's in the original string — canonical. It follows that if the number of 1's in a and b is equal to c, k<c and k is odd, a solution always exists.

Let's move on to the case when k is even. In this case, since a pair of reversals makes a cyclic shift by 2, only even-numbered blocks will appear at the k-th position. However, notice that this is not a coincidence: when k is even, whatever reversal we perform, even-numbered blocks only interact with even-numbered blocks, and odd-numbered blocks interact with odd-numbered blocks. In particular, the sum of p0,p2,p4,… can never change, and the sum of p1,p3,p5,… can never change either.

Thus, when k is even, let's call the following representation canonical: p0 contains the sum of all initial values of p0,p2,p4,…; pk+1 contains the sum of all initial values of p1,p3,p5,…; and all the other pi's are zeros.

We can reach this representation in a similar way to the odd k case, using pairs of reversals.

Note that similar to the k-th position which contains blocks pk,pk−2,pk−4,… during the process, the 1-st position contains blocks p1,pk+1,pk−1,pk−3,… during the process.

During the first reversal in each pair, as in the previous case, we'll move all the 0's from the k-th block to the 0-th block. During the second reversal in each pair, we'll move all the 0's from the 1-st block to the k+1-th block. After k+1 pairs of reversals (actually just k2 pairs are enough), we'll zero out all the values except for p0 and pk+1.

All in all, we have found a way to reach the canonical representation in 2c≤2n steps, as desired.

1530H - Turing's AwardLet's look at Alan's moves in reverse. The process can be reformulated as follows. Initially, an is written down into the cell where Alan is located. Then, for each i from n−1 down to 1, first Alan decides whether to stay or move to a neighboring cell, and then ai is written down into Alan's cell only if the cell is empty. This way, it's easier to reason about the process since numbers never get overwritten.

The state at any moment can be described by the current sequence b and Alan's position inside this sequence. The only way we can change b is by appending a number to either end.

Suppose we have decided which elements of the permutation appear in the final sequence b, and for each element, whether it gets appended to the front or to the back. Let's call these elements useful. As a special case, an is always useful. Two things to notice here:

We don't care about intermediate Alan's positions, as long as he has enough time to move between consecutive useful elements. For example, suppose ai gets appended to the front of b (the other case is symmetrical), and there are exactly k useful elements among ai,ai+1,…,an. Let aj be the "next" useful element, that is, j<i and there are no useful elements between aj and ai.If aj should be appended to the front of b, Alan can just stay in the same cell for elements ai−1,ai−2,…,aj+1, and then move to the left to append aj. Here, Alan is always in time.If aj should be appended to the back of b, Alan has to move to the other end of b, and he needs to make k steps to the right. This is possible if and only if i−j≥k.Consider a useful element that neither belongs to the LIS (longest increasing subsequence) of b, nor is an. We can always change this element's status to "not useful", and it won't harm us in any way. Thus, we can assume that all of the useful elements, except for maybe an, belong to the LIS.Let's casework on whether an belongs to the LIS. From now on, we will assume that an does belong to the LIS. However, the other case differs just slightly.

Armed with the above observations, we can solve the problem using dynamic programming:

fL(k,i): suppose ai is a useful element that gets appended to the front, and there are k useful elements among ai,ai+1,…,an. Then fL(k,i) is the smallest possible value of the element at the back of the LIS.fR(k,i): suppose ai is a useful element that gets appended to the back, and there are k useful elements among ai,ai+1,…,an. Then fR(k,i) is the largest possible value of the element at the front of the LIS.Note that some DP states might be unreachable: in this case, we set fL(…) to +∞ and fR(…) to −∞.

Consider transitions from fL(k,i) (transitions from fR(k,i) are similar):

For any j<i such that aj<ai, we can set fL(k+1,j) to fL(k,i).For any j≤i−k such that aj>fL(k,i), we can set fR(k+1,j) to ai.(If we can set f(…) to multiple values, we should choose the smallest one for fL and the largest one for fR.)Thus, we can transition from f(k,…) to f(k+1,…) in O(n2) time. We can optimize it to O(nlogn) if we sweep through the permutation in reverse order (i=n,n−1,…,1) and maintain a segment tree for minimum/maximum indexed with element values.

The answer to the problem is the largest k such that fL(k,i) or fR(k,i) is a reachable state for some i. The complexity of our solution is thus O(knlogn).

Finally, note that the part of b to the left of an forms an increasing subsequence of a, and the part of b to the right of an forms a decreasing subsequence of a. It is well-known that the expected length of the longest increasing/decreasing subsequence in a random permutation is O(n−−√). Therefore, our solution works in O(n1.5logn) on average.

Codeforces Round #732 Editorial

By Cirno_9baka, 20 months ago, In English1546A - AquaMoon and Two ArraysFirst, if the sum of elements in a is not equal to the sum of elements in b, then the solution does not exist.

Each time find a position i satisfying ai>bi, and find such a j satisfying aj<bj. Then let ai−1, aj+1, until the two arrays become the same.

solutionIdea: Cirno_9baka

1546B - AquaMoon and Stolen StringWe can find that for each letter of the answer must appear an odd number of times in its column(Since for other strings, they appear twice in total. The operation does not change the number of the occurrence of some certain letter in one column).

So we can consider each position individually. There is always exactly one letter that occurs an odd number of times. So just take them out and they are the letters of the stolen string.

solutionIdea: AquaMoon

1546C - AquaMoon and Strange SortIt's easy to see that each number needs to move an even distance.

For the same number, count how many of them are in the odd position and even position.

Sort the array and count again.

The given array named A, the sorted array named B.

For every number, if the number of its occurrence in the odd position in A is different from its occurrence in the odd position in B, or the number of its occurrence in the even position in A is different from its occurrence in the even position in B, then the answer is NO. Otherwise the answer is YES.

solutionIdea: Cirno_9baka

1546D - AquaMoon and ChessWe enumerate i from 1 to n. If position i−1 and i both contain a chess and i−1 is not in other groups, then we divide them into one group.

We can change the operation a little: Each time we can swap the two consecutive 1 and the element to their left or right. It's easy to see this operation equals to the initial one.

So that means we can take out the groups (two consecutive 1) and insert them to any position of the chessboard. So let the number of groups be m, the number of zeros be n, it's easy to find that the answer is (n+mm)(Since inserting one group to the left of some 1 or to the right of it are the same).

solutionIdea: Cirno_9baka

1546E - AquaMoon and PermutationsAmong all the arrays not be chosen, if an array have a number which appears exactly once at its column, that the array must belong to the n original arrays. So, we can choose the array and delete all arrays have at least one same bit with it.

If there not exists such an array discribed above, according to the Pigeonhole Principle, all numbers of the unchosen arrays must appear exactly twice on their columns. It means either the original arrays or the additional arrays can form a correct latin square. So, it's correct to choose any one of the unchosen array and delete all arrays have at least one same bit with it. Meanwhile, we need to multiply the number of solutions by 2.

We need to repeat the above operations, until we have chosen n arrays.

solutionIdea: AquaMoon

1546F - AquaMoon and Wrong CoordinateLet's denote for sum[t] the sum of all coordinates at the moment t, and for sum2[t] the sum of all squared coordinates at the moment t.

If there is no error, the sum of the coordinates of all moments will be an arithmetic series, and the difference is ∑mi=1vi. It's easy to find the moment that contains the modified coordinate.

Assuming that the moment that contains the modified coordinate is found, first use three consecutive moments without the modified coordinate. Suppose it is t, t+1, t+2. Sum of squared coordinates of moment t is sum2[t]=∑mi=1(xi+t∗vi)2. Sum of squared coordinates of moment t+1 is sum2[t+1]=∑mi=1(xi+(t+1)∗vi)2. Sum of squared coordinates of moment t+2 is sum2[t+2]=∑ni=1(xi+(t+2)∗vi)2. We could easy to get sum2[t]+sum2[t+2]−2×sum2[t+1]=2×∑mi=1v2i. In this way, we can know the value of 2×∑mi=1v2i.

Then we can enumerate which integer was modified at the moment y. We could try to update the integer back to the original coordinate, so that it can meet both sum[y−1]+sum[y+1]=2×sum[y] and sum2[y−1]+sum2[y+1]−2×sum2[y]=2×∑mi=1v2i. It would be easy to get the original coordinate.

solutionIdea: AquaMoon

1545E2 - AquaMoon and Time Stop (hard version)We scan through the time, each time. We need to get minimum answer for all positions of this certain time.

We can use some data structure to maintain it.

In detail, we use balance tree to maintain every segments which are not covered for some time t.

We can see that after some time, the answer of every position of the segment is shifted. A new arithmetic sequence is added to the left, and the rightmost part is erased. We use lazy tags to maintain them(We update the segment only when we need to use the answer of it).

When a segment is banned, then we just erase it.

When a segment is added, we need to consider the answer of at most two neighboring segment.

There are two conditions:

1. We use two of the neighboring segment to get the answer of the new-added segment. We need to merge the two segments and insert two arithmetic sequences between them.

2. We use only one of the neighboring segment to get the answer of the new-added segment, and this one will even influence the other. We just use brute force to erase some arithmetic sequences of the influenced segment at the end.

For each segment, we use a balance tree to maintain the arithmetic sequences in it.

Since each time we will only add segments of a constant number, so the time complexity is O(nlogn).

(The easy version is for solution without too many data structures)

solutionIdea: AquaMoon and mejiamejia

1545F - AquaMoon and PotatoesWe seek a solution of roughly square root time complexity; the small constraint of m hints at a solution in O(mn−−√). This immediately rules out solutions based on square root decomposition on sequences, because of the overhead incurred with initializing such structures.

Instead of directly solving the problem, let us solve the following - equivalent - task: How can we solve O(n−−√) queries in O(n) time?

If we only consider O(n−−√) queries, then there are at most O(n−−√) positions that are modified throughout these queries. Call these positions "dynamic points", and the others "static points".

A note concerning notation: The following editorial was written when X and Y were permutations, and as such it uses X−1i to denote the value j such that Xj=i. It was later found that the solution can be easily modified to accomodate for X and Y that were not permutations. You can regard X−1i as the set of j such that Xj=i. In the following, we often count the number of dynamic or static elements in a prefix that equals a certain value. The number of elements in a multiset that equal X−1i is the same as the number of elements in said multiset that satisfy Xj=i. In implementation, we can maintain the multiset {Xj:j∈…} instead of the original multiset.

Call a triplet "good" if it satisfies 1≤i<j<k≤r, and Xai=aj=Yak.

Hence, for each query, the good triplets fall under 8 categories, in roughly increasing order of difficulty:

i,j,k are all static.We can calculate for each r in O(n), through DP or the like, the number of good triplets in [1,r] where i,j,k are all static: we simply ignore the dynamic points. This is O(n) preprocessing and O(1) for each query.i,j,k are all dynamic.Similarly to 1, for each query, we do a brute force DP over all dynamic i,j,k before r. This is O(n−−√) for each query.i,j are dynamic, k is static.We iterate over all dynamic j, moving forward, and keep track of the amount of X−1aj currently seen. Then, for each j, we know the number of dynamic i that can precede it through what we tracked; what remains is to count the number of static ak=Y−1aj in [j+1,r] in O(1).We offline all O(n) intervals that we need to count in these O(n−−√) queries and then re-process their contribution at the end of the block.j,k are dynamic, i is static.This is virtually the same as 3; we just iterate in reverse and we count the number of static ai=X−1aj in [1,j−1].j is dynamic, i,k are static.Using the same data structure as 3 and 4, we multiply the number of ai=X−1aj in [1,j−1] with the number of static ak=Y−1aj in [j+1,r].i,k are dynamic, j is static.We iterate over all dynamic k. The number of good i,j,k in this situation equals the number of i,j where 1≤i,j<k, ai=X−1Yak, and aj=Yak, minus the number of i,j where 1≤j≤i<k, ai=X−1Yak, and aj=Yak.For the former, notice that i,j are independent. As we iterate forwards through all dynamic k, we keep track of all dynamic values we have seen so far, and multiply the number of dynamic occurrences of X−1Yak with the number of static occurrences of Yak in [1,k−1]. As usual, to solve for static occurrences we offline them.For the latter, observe, that when ai=s we must have aj=Xs in a good triplet. Hence during the iteration over a, for each dynamic i we count the number of static j before or on it such that aj=Xai. We obtain this count for each dynamic i and then, for each k, sum the count over all ai=X−1Yak.k is dynamic, i,j are static.We iterate over all dynamic k; we seek the number of static i,j in [1,k−1] such that aj=Xai, i<j, and aj=Yak.We offline all O(n) dynamic k that we need to count in these O(n−−√) queries. Then, we iterate forwards through a in a manner similar to part 1, keeping track of the number of i that can bind to each j, and a sum over all current j where aj equals some value, answering offlined questions on the way.i is dynamic, j,k are static.We iterate over all dynamic i; we seek the number of static j,k in [i+1,r] such that aj=Yak, j<k, and aj=Xai.We offline all O(n) intervals that we need to count in these O(n−−√) queries. Notice that the number of j,k in an interval [i+1,r] equals the number of j,k where j is in [i+1,r] minus the number of j,k where j is in [i+1,r] and k is in [r+1,n].We calculate the former iterating backwards through a to count the number of k that can bind to each j, and then use a sum similar to part 3.For the latter, we observe, that j and k are independent since we have fixed both the value of aj=Xai and ak=Y−1Xai, so we simply multiply the possible j in [i+1,r] with the possible k in [r+1,n].As such, we have solved O(n−−√) queries in O(n), and have solved the problem in O(n+mn−−√).

We can prove that this problem is more difficult than calculating matrix multiplication of two matrices with size n−−√×n−−√, when ignoring poly-logarithmic factors.

We construct a special arrangement of array: for ai=2,5,8,…, the corresponding bai=1,4,7,…, the corresponding cai=3,6,9,…. For other ai, bai=cai=n. We make sure that no n exists in the array a.

Array a is separated into three parts from left to right. The first part consists of 1,4,7,…, each appears exactly one time. The second part consists of 2,5,8,…, each may exist multiple times. The third part consists of 3,6,9,…, each may exist multiple times.

Let fk be the number of triplets (i,j,k) that bai=aj=cak. For each ak, there is exactly one ai and it appears exactly one time. Hence, fk is equal to the number of corresponding aj. We only modify elements of a in the second part. If we regard k,ak that k is in the third part of array as a point in 2D space, let xk=k,yk=ak, then inserting a corresponding aj into the second part means a ranged plus operation for any point that y=ak. A query operation with value r reports the sum of all point i that xi≤r. Because of our constructed array, only triplets where k is in the third part can contribute to the answer. So we used an algorithm that can solve this problem to solve the two-dimensional x=A add, y=B sum problem, which is equivalent to x<A add, y<B sum when ignoring poly-logarithmic factors. This problem is further equivalent to the famous range inverse query problem, which was proven more difficult than calculating matrix multiplication of two matrices with size n−−√×n−−√.

As currently the best matrix multiplication algorithm is O(n2.373), seeking a O~(n) solution is not realistic, so the O(n+mn−−√) solution described above is enough for competitive programming.

P.S. There is an easter egg in the problem statement, find it :)

solutionIdea: ODT and box

UPD: Chinese editorial can be found here.

Codeforces Round #731 (Div. 3) Editorial

By doreshnikov, 20 months ago, translation, In English1547A - Shortest Path with Obstacle

Idea: MikeMirzayanov

Tutorial1547A - Shortest Path with ObstacleLet's suppose that the forbidden cell does not affect the shortest path. In that case, the answer would be |xA−xB|+|yA−yB|.

The forbidden cell blocks the shortest path if and only if it belongs to every shortest path. In other words, if there is only one shortest path and the forbidden cell belongs to it. So, the answer differs from |xA−xB|+|yA−yB| if and only if A and B are in one row or column and F is between them. In that case, the answer is |xA−xB|+|yA−yB|+2 (i.e. greater by 2).

In order to check that point R lays between P and Q on a straight line, just check min(P,Q)<R<max(P,Q).

So, the correct solution looks like this:

vector<int> a(2), b(2), f(2);cin >> a[0] >> a[1];cin >> b[0] >> b[1];cin >> f[0] >> f[1];int ans = abs(a[0] - b[0]) + abs(a[1] - b[1]);if ((a[0] == b[0] && a[0] == f[0] && min(a[1], b[1]) < f[1] && f[1] < max(a[1], b[1]))        || (a[1] == b[1] && a[1] == f[1] && min(a[0], b[0]) < f[0] && f[0] < max(a[0], b[0])))    ans += 2;cout << ans << endl;Solution1547B - Alphabetical Strings

Idea: MikeMirzayanov

Tutorial1547B - Alphabetical StringsFor a start, let's find the position of the letter 'a' in string s. If this position does not exist, then the answer would be 'NO'. Suppose that this position exists and equals posa. Let's create two pointers L and R. Initially L:=posa, R:=L. We will try to build string s using the algorithm from the statement. Suppose that we have built substring s[L..R] in i iterations. Consider the next letter of the Latin alphabet ci. Let's look at cases:

find position pos of the letter ci in s (if it does not exist then 'NO');if pos=L−1 then make an assignment L:=L−1 and process the next letter ci;if pos=R+1 then make an assignment R:=R+1 and process the next letter ci;otherwise string s is not alphabetical and the answer is 'NO'.So, if we have built the string in n iteration, then string s is alphabetical and the answer is 'YES'.Solution1547C - Pair Programming

Idea: geranazavr555, MikeMirzayanov

Tutorial1547C - Pair ProgrammingThe solution is that if we can do something, let's do it. It doesn't make sense not to act, because neither adding a new row nor modifying an existing one can prevent the existing row from being changed in the future. Therefore, we will iterate over the actions and eagerly act Monocarp or Polycarp.

Let's create two pointers i and j in arrays a and b — index of possible action of Monocarp and Polycarp and c — the current length of the file.

Suppose that ai=0 or bj=0 on current iteration. Then we take the appropriate zero element and increase c by one. We can do that because appending a new line cannot make a new answer prefix incorrect if the previous prefix was correct.

Suppose that ai≠0 and bj≠0. If ai>c and bj>c then there is no answer because we can potentially do only two actions and both make the answer incorrect. If one number is greater than c and the other is less than or equals then we take the one that less than or equals c.

If one of the sequences a or b ends then only one potential action needs to be checked at each iteration.

Solution1547D - Co-growing Sequence

Idea: doreshnikov

Tutorial1547D - Co-growing SequenceIn order to build lexicographically minimal co-growing with xi sequence, it is enough to build its elements iteratively, beginning from y1 and minimizing the i-th element assuming that y1,…,yi−1 have already been found.

Assign y1=0. According to the statement, all elements of the sequence are non-negative, so y1 cannot be less than zero. It turns out that yi=0 is the minimal possible first element. The existence of an answer with y1=0 follows from the construction algorithm described below.

Let's use mathematical induction and construct yi under the assumption that all the previous elements of the sequence have already been constructed. In order to satisfy the condition for the growth of the final sequence, the number xi⊕yi must contain one bits at all places (but not necessarily limited to them), on which there are one bits in the number xi−1⊕yi−1. Let's denote xi−1⊕yi−1 for t and find out what bits can be in yi to satisfy this condition:

If in t stands 0 bit then independently from xi in yi at the same spot we can place any bit because there is no limit on the corresponding bit in xi⊕yi;If in t stands 1 bit and in xi — 0 then the corresponding bit in yi should be equal 1, so that in xi⊕yi the corresponding bit also equals one;If in t and in xi stands 1 bit then in y1 should be 0 bit at the corresponding place for the same reasons.The bit transformation described above can be given by the expression yi=(t|xi)⊕xi. Indeed, this expression gives us bit 'one' at the fixed position if and only if at that place in t stands 1 bit and in xi stands 0 bit. For the full solution, it remains only to apply this formula in a loop from 2 to n.

Solution1547E - Air Conditioners

Idea: geranazavr555, MikeMirzayanov

Tutorial1547E - Air ConditionersLet's calculate two arrays L and R, where:

Li is the temperature in cell i if we take only air conditioners with numbers less than or equal to i;Ri is the temperature in cell i if we take only air conditioners with numbers greater than or equal to i;Let's show how to calculate array L. We will calculate values from left to right using DP and next formula: Li=min(Li+1+1,ci), where ci is the temperature of air conditioner in cell i (or infinity if there is no air conditioner in this cell). Indeed, the value of Li is either determined by the air conditioner in this cell (i.e. equals ci) or by some air conditioner to the left, but this means that we should take the answer from the previous cell and increase it by 1. The full code for calculating L looks like this:

vector<long long> L(n, INT_MAX);p = INT_MAX;forn(i, n) {    p = min(p + 1, c[i]);    L[i] = p;}In exactly the same way (but from right to left) we will calculate R:

vector<long long> R(n, INT_MAX);p = INT_MAX;for (int i = n - 1; i >= 0; i–) {    p = min(p + 1, c[i]);    R[i] = p;}The answer for cell i is min(L[i],R[i]).

Solution1547F - Array Stabilization (GCD version)

Idea: doreshnikov

Tutorial1547F - Array Stabilization (GCD version)First, note that the array stabilizes if and only if it consists of equal elements, and the number the array a will be consisted of is T=gcd(a1,…,an). Indeed, at the i-th step a number equal to gcd(aj,…,a(j+i)modn) will be written at the j-th position in the array.

This is easy to prove by induction: if at the previous step the adjacent elements in the array were equal to gcd of the numbers on adjacent segments of length i−1 in the original array, then their greatest common divisor will be the greatest common divisor of the union of these two segments (GCD is an idempotent operation).

Thus, the algorithm will stop in no more than n steps, since after n steps all numbers will be equal exactly to T. If we divide all the numbers ai by T before starting the algorithm, then the number of steps won't change, but the array will stabilize at the number 1.

Since the numbers in the array after the k-th step will be exactly equal to gcd of all segments of length k+1 of the original array a, it follows that the number of steps after which all values become the same is exactly equal to the length of the maximum segment of the original array on which gcd>1.

There are several ways to find the length of such a segment. For example, you can use range GCD query and binary search. The following method is based on the factorization of numbers, in other words, on their decomposition into prime factors. Factorization in this problem could be done using both the sieve of Eratosthenes or factoring each number independently in O(ai−−√).

After all the numbers have been factorized, iterate over each i and each prime p in its factorization. In linear time we can go left and right from i, finding the maximum segment of numbers that contain the same factor p. Then we can update the answer with the length of this segment and move onto the next prime in the factorization of ai or go to i+1, if all primes have already been iterated through.

Note that if a segment of numbers divisible by p contains indices from l to r, then we iterate through it r−l+1 times. In order to avoid reiteration on each segment, we remove p from the factorizations of all numbers on the segment after considering only one.

The resulting solution works in O(n⋅MAX_P), where MAX_P — the maximum number of different primes in factoriztion of ai. Considering that ai≤106, MAX_P=8, so the solution fits into the time limit.

Solution1547G - How Many Paths?

Idea: MikeMirzayanov

Tutorial1547G - How Many Paths?The first motivation for solving this problem is to write a lot of standard code like "find strongly connected components", do some DP over the condensed graph (the graph of strongly connected components), and so on.

In fact, this problem can be solved much more elegantly with less code if you have a little better understanding of how depth-first search works.

Consider a usual depth-first search on a digraph that is started from the vertex 1. This will be a normal depth-first search, which will paint vertices using three colors: white (the vertex has not yet been found by the search), gray (the vertex is processing by DFS), and black (the vertex has already been processed by the DFS completely, that is, completely bypassed its subtree of the depth-first search tree).

Here's the pseudocode:

dfs(u):    color[u] = GRAY    for v in g[u]:        if color[v] == WHITE:            dfs(v)    color[u] = BLACKThe following statements are true:

there is a cycle in the digraph reachable from s if and only if the root call dfs(s) visits in the line if color [v] == WHITE when color[v] == GRAY;moreover, for each reachable cycle from s there is at least one vertex that will execute the previous item (then the vertex v belongs to the cycle);if the root call dfs(s) visits in the line if color[v] == WHITE, when color [v] == BLACK, then there is more than one path (the opposite is not true).It is clear that there are infinite paths from s to u if and only if there is a vertex v on some path from s to u such that v is in a cycle. Thus, we mark all such vertices v for which color[v] == GRAY at the moment of execution of the line if color [v] == WHITE. The fact is true: All vertices reachable from those noted in the previous phrase are those and only those vertices that an infinite number of paths lead to them.

A similar fact is also true for finding vertices to which at least two paths (but a finite number) lead. Let's mark all such vertices v for which color[v] == BLACK at the moment of execution of the line if color [v] == WHITE. The fact is true: Let's find all reachable vertices from those marked in the previous phrase. Let's discard those up to which we have already determined that the number of paths is infinite. The remaining reachable vertices are those and only those to which there are at least two paths (and their finite number).

So the solution looks like this:

let's make a depth-first search from the root, mark during it those vertices that were gray when trying to go to them (group A) and were black when trying to go to them (group B);mark the vertices reachable from the group A (let's call them AA);mark the vertices reachable from the group B (let's call them BB);the answer for the vertex is:0 if it is not reachable from s (this determines the first DFS);−1, if it is from AA;2 if it is from BB (but not from AA);1, if it is not from AA and not from BB.In the author's solution, only one dfs function was used with an additional boolean parameter to determine its mode.

Solution

Codeforces Round #730 (Div. 2) Editorial

By JaySharma1048576, 20 months ago, In EnglishA: Exciting BetsHint 1Hint 2TutorialIf a=b, the fans can get an infinite amount of excitement, and we can achieve this by applying the first operation infinite times.

Otherwise, the maximum excitement the fans can get is g=|a−b| and the minimum number of moves required to achieve it is min(amodg,g−amodg).

ProofTime ComplexitySolutionB: Customising the TrackHintTutorialIn the optimal arrangement, the number of traffic cars will be distributed as evenly as possible, i.e., |ai−aj|≤1 for each valid (i,j).

Proof (Warning: Too much Math inside)Now that we have constructed the optimal arrangement of traffic cars, let's find out the value of minimum inconvenience of this optimal arrangement. Finding it naively in O(n2) will time out.

Notice that in the optimal arrangement we will have some (say x) elements equal to some number p+1 and the other (n−x) elements equal to p. Let the sum of all elements in a be sum. Then, x=summodn and p=⌊sumn⌋. For each pair (p,p+1), we will get an absolute difference of 1 and for all other pairs, we will get an absolute difference of 0. Number of such pairs with difference 1 is equal to x⋅(n−x). So, the minimum inconvenience we can achieve is equal to x⋅(n−x). That's all we need to find out!

Time ComplexitySolutionC: Need for Pink SlipsHint 1Hint 2Hint 3Hint 4TutorialBruteforce over all the possible drawing sequences until we are sure to get a pink slip, i.e., until the probability of drawing a pink slip becomes 1.

Why this works?What's left is just implementing the bruteforce solution taking care of precision errors while dealing with floating point numbers, especially while comparing a with v as this can completely change things up, keeping an item valid when it should become invalid. It follows that an error approximation of 1e-6 or smaller is sufficient while comparing any two values because all the numbers in the input have at most 4 decimal places. Another alternative is to convert floating point numbers given in the input to integers using a scaling factor of 106.

Time ComplexitySolutionD1: RPD and Rap Sheet (Easy Version)Hint 1Hint 2Hint 3Hint 4Hint 5TutorialIn this version of the problem, k=2. So, the k-itwise XOR is the same as Bitwise XOR.

In case of incorrect guess, the system changes password to z such that x⊕z=y. Taking XOR with x on both sides, x⊕x⊕z=x⊕y⟹z=x⊕y because we know that x⊕x=0.

Since the original password is less than n and we have n queries, we need to find a way to make queries such that if the original password was (x−1), then the x-th query will be equal to the current password. There are many different approaches. I will describe two of them.

Method 1Method 2 (Idea by KAN)Time ComplexitySolutionsD2: RPD and Rap Sheet (Hard Version)Hint 1Hint 2Hint 3Hint 4Hint 5TutorialNote — It is strongly recommended to read the proofs also to completely understand why the solutions work.

The solutions described for the easy version won't work here because the general k-itwise operation does not satisfy self-inverse property, i.e., a⊕ka≠0.

In this whole solution, we will work in base k only and we will convert the numbers to decimal only for I/O purpose. Notice that any property which is satisfied by k-its will also be satisfied by base k numbers since a base k number is nothing but a concatenation of k-its.

When we make an incorrect guess, the system changes the password to z such that x⊕kz=y. Let's denote the j-th k-it of x by xj. Expanding this according to the definition of k-itwise XOR, for all individual k-its (xj+zj)modk=yj ⟹zj=(yj−xj)modk. So, let's define another k-itwise operation a⊖kb =(a−b)modk. Then, z=y⊖kx. Now, let's extend the solutions of the Easy Version for this version.

Method 1Method 2NotesSolutionsAbout the Adaptive GraderE: The Final PursuitHint 1Hint 2Hint 3Hint 4Hint 5Hint 6Tutorial: Part 1 - Finding the PermutationBefore moving to the solution, notice a very important property of simple n-Dimensional Hypercubes — Two vertices a and b are connected if and only if a and b differ by exactly one bit in their binary representations.

The permutation can be found using the following greedy algorithm — First, assign any arbitrary vertex as p0. This is obvious since all vertices are equivalent. Then, in the simple n-Dimensional Hypercube, all powers of 2 must be connected to the vertex 0. Moreover, these vertices are added only when we are adding another dimension to the cube. Since all directions are also equivalent, it does not matter in which direction we add a new dimension. So, we can assign all the n vertices connected to p0 in the permuted n-Dimensional Hypercube as p1, p2, p4, p8, …, p2n−1 in any arbitrary order. Now, we will find pu for the remaining vertices in increasing order of u.

In order to find pu, first find a set S of vertices v such that v<u and v is connected to u in the simple n-Dimensional Hypercube. Then find any vertex w connected to all the vertices pv such that v∈S in the permuted n-Dimensional Hypercube and assign pu=w. I claim that we can never make a wrong choice because we will never have a choice! There will only be one such vertex w for any u. Let's prove it.

ProofAlternate method of finding the permutation (by mshiladityam)Hint 7Hint 8Hint 9Hint 10Tutorial: Part 2 - Colouring the HypercubeLet's try to colour the simple n-Dimensional Hypercube instead of the permuted one. We can map the colours to the permuted one in the end using the permutation found in Part 1.

I claim that if n is not a power of 2, then no colouring exists. A simple explanation is that the graph is symmetric and also the colours. So, it is natural that the number of vertices of each colour must be equal meaning 2n must be divisible by n or in other words, n must be a power of 2 itself. But if symmetry doesn't satisfy you, I have a formal proof too.

ProofConstruction - This is the most interesting and difficult part of the whole problem. The following construction works —

Consider a vertex u. Let its binary representation be bn−1bn−2…b2b1b0. Then the colour of this vertex will be ⨁i=0n−1i⋅bi. Let's show why this works.

⨁i=0n−1i⋅bi will always lie between 0 and n−1 inclusive because n is a power of 2.If we are at a vertex u with a colour c1 and we want to reach a vertex of colour c2, we can reach the vertex v=u⊕(1≪(c1⊕c2)). This is a vertex adjacent to u since it differs from it by exactly 1 bit and this is the (c1⊕c2)-th bit. Notice that the colour of this vertex v will be c1⊕(c1⊕c2)=c2.(c1⊕c2) will always lie between 0 and n−1 because n is a power of 2. So, v will always be a valid vertex number.You can see that many of these facts break when n is not a power of 2. So, this colouring will not work in such cases.

Finally, after colouring the simple hypercube, we need to restore the vertex numbers of the permuted hypercube. This can be simply done by replacing all vertices u with pu using the permutation we found in Part 1.

Visualise the ColouringTime ComplexitySolutionAlternative Solution (by mshiladityam)

Tutorial of Codeforces Round 729 (Div.2)

By feecIe6418, 20 months ago, In EnglishA TutorialThe answer is 'yes' if and only if there are exactly n odd numbers.

A CodeB Hint 1B Hint 2B Hint 3B TutorialFirst check specially if b=1.

Let's consider when n is in S. The answer is when the smallest number m in S that n mod b=m mod b is less than n. It's easy to see that a new case of x mod b can only appear when you use ×a to generate a new element. So the smallest number m in S that m mod b=k must be a power of a.

Find all powers of a that is smaller than n. If there is one m=ak that n mod b=m mod b, the answer is yes. Otherwise it's no. Time complexity is O(logn).

B Code (Python)C Hint 1C Hint 2C TutorialEnumerate the value of f(i). Since f(n)=i means lcm(1,2,...,i−1)≤n, f(n) will not be too big (less than 100). The number of ks such that f(k)=i is ⌊n/lcm(1,2,...,i−1)⌋−⌊n/lcm(1,2,...,i)⌋. (k should be divisible by 1∼i−1 but not i) So the answer is ∑i>1i(⌊n/lcm(1,2,...,i−1)⌋−⌊n/lcm(1,2,...,i)⌋).

We can also write the answer in another form, which is equivalent to the previous form:

∑i≥1⌊n/lcm(1,2,...,i)⌋+nC CodeD HintD TutorialFor each x, count how many Bs make the final set contain x.

Let's say we have picked the x in the I-th operation, call it X. Then, the subsequence we choose must satisfy the following conditions:

It must contain the i-th operation (otherwise X won't be added).Let s denote the number of numbers less than X in the current T. Whenever we meet a - element in S after the i-th operation, s should be greater than 0.With those conditions, we can come up with the following dp.

Let f(i,j) denote the number of subsequences of a[1...i], that if we maintain T with the subsequence, s will become j.

Then we have the following transitions:

f(i−1,j)→f(i,j) (when we don't include the i-th element is S, here i≠I)f(i−1,j)→f(i,max(j−1,0)) (here, i<I, and the i-th element of A is -, so the number of numbers in T less than x decreases by one. If there is no such number, s remains 0)f(i−1,j)→f(i,j−1) (here, i>I, and and the i-th element of A is -, so the number of numbers in T less than x decreases by one.)f(i−1,j)→f(i,j) (here, the i-th element of A is + and its x is greater than X)f(i−1,j)→f(i,j+1) (here, the i-th element of A is + and its x is less than x or [equal to x but $i>I$] ) [this is to deal with same elements]Then we add ans by X×∑i≥0f(n,i).

The time complexity is O(n3).

D Code (Python)E1 HintE1 TutorialLet's first calculate the number of permutation pair (p,q)s (with length i) that p1<q1 but inv(p)>inv(q) (inv(p) is the number of inversions in p). Call it ti.

Let's enumerate p1=j and q1=k, then inv(p[2...i])−inv(q[2...i])>k−j. (inv(p)=inv(p[2...i])+j−1,inv(q)=inv(q[2...i])+k−1, with inv(p)>inv(q) we get the following.)

Precalculate f(i,j): the number of permutation ps of length i such that inv(p)=j. Let s(i,j) be ∑k≤jf(i,k), then:

ti=∑1≤j≤i∑j<k≤i∑wf(i−1,w)s(i−1,w−(k−j)−1)f and s can be calculated in O(n4) or O(n3) in the following way: if you insert i into a permutation of length i−1 after the i−1−p-th element (0≤p≤i−1), it will bring p inversions into the permutation. So f(i,j)=∑j−i+1≤k≤jf(i−1,k).

After calculating t, calculating the answer it easy. Let ansi be the answer for n=i, then

ansi=i×ansi−1+tiConsider if p1=q1. If so, there are i choices of p1, and ansi−1 choices of the following n−1 numbers. Otherwise, there are ti choices.

Total complexity is O(n5), but it can be optimized to O(n4) if you consider the difference between j−k only, and can be optimized to O(n3logn) using FFT with arbitary mod (which we hope can't pass E2!).

E1 CodeE2 HintE2 TutorialWe recommend you to read E1's editorial first.

Let's directly count the number of permutation pairs (p,q) of length n with inv(p)−inv(q)=k, instead of counting it indirectly from "the number of permutation ps of length i such that inv(p)=j.". Call this number f(n,k).

We have an n4 transition: f(n,k)=∑|i|<nf(n−1,k−i)×(n−|i|) (Consider where to insert n in the first and second permutation. If the two places are indices (I,J), then the delta of inv(p) is n−I, the other is n−J, so the delta of difference is J−I. In [1,n] there are n−|J−I| pairs of integers with difference J−I.)

Let's speed it up. When f(n,k) moves to f(n,k+1), it looks like this: (n=4, as an example)

f(n−1,k−3)×1+f(n−1,k−2)×2+f(n−1,k−1)×3+f(n−1,k)×4+f(n−1,k+1)×3+f(n−1,k+2)×2+f(n−1,k+3)×1f(n−1,k−2)×1+f(n−1,k−1)×2+f(n−1,k)×3+f(n−1,k+1)×4+f(n−1,k+2)×3+f(n−1,k+3)×2+f(n−1,k+4)×1So with prefix sums s (s(i,j)=∑k≤jf(i,k)) we can write f(n,k+1)=f(n,k)−(s(n−1,k)−s(n−1,k−n))+(s(n−1,k+n)−s(n−1,k)).

Note that the second indice of the array might be negative, so we should shift it by 130000.

The memory complexity is O(n3), so we should only keep two layers of transition to optimize it to O(n2) (If implemented well, O(n3) memory solutions can also pass.)

E2 Code

Codeforces Round #728 Editorial

By PurpleCrayon, history, 20 months ago, In English1541A - Pretty Permutations

Author: PurpleCrayon

HintHintHintSolution1541A - Pretty PermutationsThere are two cases:

if n is even, print: [2,1,4,3,6,5…n,n−1] Formally, you swap every other pair of adjacent elements. This is optimal because the total distance is n, which has to be minimal since the distance of one cat must be ≥1.if n is odd, first print [3,1,2] then solve the even case for the remaining elements. This is optimal because the distance is n+1, which has to be minimal since a distance of n is not achievable.1541B - Pleasant Pairs

Author: PurpleCrayon

HintHintSolution1541B - Pleasant PairsLoop over all values of ai and aj. Because i+j≤2⋅n, we only care about pairs (ai,aj) if ai⋅aj≤2⋅n. The number of such pairs is O(nlogn), so you can brute force all pairs.

The reason the total number of pairs is O(nlogn) is because if the first element of the pair is x, there are only 2⋅nx  possible values of y. 2⋅n1 +2⋅n2 +2⋅n3 +…2⋅nn =2⋅n(11 +12 +13 …1n )=O(nlogn) by the harmonic series. Thus the solution runs in O(nlogn) time total.

1540A - Great Graphs

Author: PurpleCrayon

HintHintHintSolution1540A - Great GraphsNote that if there are two nodes a and b and you want to add an edge between them, the value of the edge must be ≥db−da. Otherwise, the cows could take a path to b that goes through da that's strictly less than db. With this in mind, let's add all edges (a,b) with weight db−da if and only if db≤da. All of these numbers are not positive, which means they can't make our answer worse. They also don't change the shortest paths, from our first observation. Now, let's call the node with the max di node x. You can add a single edge from node 1 to node x with cost dx, and now the graph is good. This is because node x is already connected to all other nodes, which means there is always a shortest path to some node a with the right length by going from 1→x→a. However, naively looping through all pairs is too slow. Instead, you can sort d and calculate the contribution of each node to the answer. The complexity is O(nlogn).

1540B - Tree Array

Author: ijxjdjd

HintHintHintSolution1540B - Tree ArrayParsing through the problem statement, the process can be seen as choosing a starting node and "expanding" the subtree of marked nodes to nodes adjacent to the marked component.

Fixing a given root r, the expected value of the entire process is obviously the sum of the expected values for a fixed root divided by n.

Find the contribution of the inversion of two nodes (a,b) where a<b. The expected contribution for any pair (a,b) is equal to the probability that b appears before a with a given root.

Set l=lca(a,b). Note that, until reaching l, every possible process still has the same probability of reaching b before a as it did when the first node was chosen. Therefore, we can assume that the process has reached l and calculate the probability from there.

Once l is reached, we now note that the probability that the process "gets closer" to b is always equal to the probability of getting closer to a.

The problem can be rephrased as having two stacks of size dist(l,a) and dist(l,b) with an arbitrary p to remove a node from one of the two stack (and 1−2p to nothing) and finding the probability that dist(l,b) reaches zero before dist(l,a).

However, it turns out that the actual probability p does not matter. We propose a function F[x][y] that defines the probability that a stack of size y becomes 0 before a stack of size x. In fact a function exists and it is defined as F[x][y]=F[x−1][y]+F[x][y−1]2 . Intuitively, this is because the probability of decreasing x or decreasing y is always the same, so the probability of transitioning the state we end up transitioning to is always the same, regardless of p.

So, the solution is clear. Iterate over and root at all nodes. Then at the given root, iterate over all pairs of node a<b and add F[dist(l,a)][dist(l,b)] to the answer. Finally, divide by n. In total, the solution works in O(N3logN) or O(N3).

1540C2 - Converging Array (Hard Version)

Author: ijxjdjd

HintHintHintHintSolution1540C2 - Converging Array (Hard Version)First, reduce the operations into something more manageable. It turns out operation i sets ai+1−ai=max(bi,ai+1−ai) while keeping ai+1+ai constant. Visually, this is simultaneously moving ai up and ai+1 down until ai+1−a[i]≥bi.

Define f to be the final converged array.

Let's some observations

If ai+1−ai=bi is ever satisfied throughout the process (if an operation ever moves anything), fi+1−fi=bi. Equivalently, if fi+1−fi>bi then no operation i could have ever been conductedIf no operation i has been conducted, then [1,i] is independent of [i+1,n].If i is the first operation that has never been conducted, then ∑ij=1aj=∑ij=1fj because no sum could have been exchanged between ai and ai+1.Let's assume that we know that i is the first observation that hasn't been conducted. We can then restore f1 because we know that f1+f1+b1+f1+b1+b2…=a1+a2+…+ai. To keep the tutorial clean, we refer to the prefix of prefix summation of bi as bpi and the prefix summation of ai as api. Namely, we can solve for f1=api−bpii  given that i is the first observation never conducted.

It turns out that f1=min(api−bpii ) over all i. This can be shown to be a lower bound on f1 because the answer is obviously in this set as there must be some i that is the first operation never conducted. This can also be shown to be an upperbound on the answer by playing the game on each prefix i. At each prefix i, the term api−bpii  is an upperbound because, if it's not equal to that term, there must be some fi+1−fi>bi so f1<api−bpii  because f1+f2+…+fi remains the same.

Returning to the actual problem, we need to count arrays min(api−bpii )≥x. In other words, api≥i⋅x+bpi must hold for all i. Let's do dynamic programming on api. Call dp[i][api] the number of prefixes of length i with current prefix sum of api. We can transition to i+1 from i using prefix sums on each valid api.

Define M=max(ai). The current complexity is O(QMN2) The final step is noticing that there are only O(M) valid integer positions that end up being important for f1. Intuitively, this is because in nearly all cases every operation i ends up being used. To rigorously prove, let's find an upperbound on relevant x. If M⋅n<x⋅n+bpi then there are 0 valid arrays. Because x⋅n+bpi is concave and negative on the decreasing portion (i.e. the function goes down immediately into negative if it ever becomes negative, otherwise strictly increases), we can draw the inequality 0≥x⋅n+bpi, otherwise every array ends up being good. Reducing the inequalities, we can realize that there is exactly M different possible solutions. So, we can precalculate in O(M2N2) and answer in O(1).

1540D - Inverse Inversions

Author: PurpleCrayon

HintHintHintSolution1540D - Inverse InversionsWe'll assume the arrays and the final permutation are 0-indexed from this point forward (you can shift values accordingly at the end).

Let's start with calculating the final array, without any updates. Let ci be the number of indices j such that pj<pi and i<j. It is easy to see that ci=i−bi. Now imagine sweeping from left to right, maintaining the array a. Let's say you're currently at index i, and you have a list of all indices ≤i, where the location of some index j is the value of aj. You know that i must be the ci-th out of those (after inserting it into the list) as the ci smallest values must be before it. This means that you can insert index i at the ci−th position in the list, and you need to find the final location of index i in each query.

Now, let's support O(1) updates and O(n) queries. The first thing to note is that you don't need the entire array a in each query, you just need to query some specific element. Assume you're querying the i-th element of the array. Let's repeat the algorithm mentioned above except instead of storing the lists, you only store the location of the i-th element for each query. Now, you keep some variable loc which stores the location of the i-th element in the list. It is initialized to ci, as it is first inserted to the ci-th position. Now you sweep through all indices j where j>i, and check if loc is changed by the insert. This is only true if loc≥a[j]. This allows for O(1) updates but O(n) queries, which is still too slow.

To speed this up, let's use sqrt-decomp. Divide the array into multiple blocks. For each block, let's store an array next where nextloc represents the final value of the variable loc if it passes through the block. If we have this array, you can loop over all of the blocks and "jump" over them using the next array, querying in O(n/B) time, where B is the size of the block. But how do you calculate and update the next array? Initially, you can calculate the next array in O(n⋅B), by going to each index and naively tracking its position. Updating it is harder. One observation to make is that for each index inside a block, there is some value such that if loc≥x it will be changed by the index, otherwise it will not. You can find all of those values for a single block using a binary indexed tree: sweep from left to right, query for the the smallest update loc using a lower bound on the BIT, and increment a suffix. Then, you can increment all of those suffixes in the next array using another BIT, which would lead to O(n√n+q√nlogn), as queries are O((n/B)logn) and updates are O(Blogn), which will probably be too slow.

To make this faster, note that the suffix that each element is responsible changes by at most one for all non-updated elements. This means that you can update the next array in O(1) for these elements. However, the updated element's suffix might change by O(n). To account for this, you can use another square root decomposition on the next array, which allows for O(√n) range updates, O(1) point updates, and O(1) point queries. This means that updates will remain O(Blogn), but queries will become O(1), so the final complexity is O(q√nlogn) with the right blocksize, which is definitely fast enough (the model solution runs in 2 seconds).

If you know of any faster solutions (O(n√n) or even O(n⋅logk) let us know down in the comments).

1540E - Tasty Dishes

Author: ijxjdjd

HintHintHintHintSolution1540E - Tasty DishesAll operations are conducted under a modulo, it can be proven that each operation we conduct is valid within the modulo.

Key Idea 1 It's optimal to perform each operation if the number being added/multiplied is strictly positive. Specifically, it's optimal to do ai:=i⋅ai and ai:=ai+a+j iif ai>0 and aj>0 respectively.

Key Idea 2 A chef's dish i becomes positive after the d'th day where d is the closest distance of chef i from a positive element. We call this value di for the i'th chef. Initial observations, there are only O(N2) pairs of (i,di) where di is not infinite (never reaches positive value and thus never changes).

Key Idea 3 We refer to a vector of length n with n−1 zeros and a single 1 at the i'th index as  →e i. If we assume that all chefs are currently positive then every chef takes every opportunity copy and the transition matrix T is well defined and obvious.

We can represent the final array at time k as a=Tk∑di≤kT−di →e iai + ∑di>k →e iai. This immediately offers a O(QN2+N4) potential solution with very good constant. Because T is diagonal, its inverse can with respect to a vector  →v  be calculated in O(N2). So, we can precalculate T−k →e i for all valid numbers in O(N2). In fact, this ends up being N4/12 total operations if optimized. We can then answer each query in O(N2) by simply iterating over each chef and finding it's contribution to the answer. Multiplying a matrix O(N2) will be explained later.

With some special hacks, it may even be possible to get this to pass.

Key Idea 4 An arbitrary matrix T has eigenvalues λi and their paired eigenvectors  →v i. Ignoring how we find eigenvectors and eigenvalues, the point of the two is that they are pairs such that T →v i= →v iλi. Notably, given a eigenvector and its respective eigenvalue, we can calculate Tk⋅ →v i in O(Nlogk).

In our case, the transition matrix T is a diagonal matrix. A basic result in linear algebra is that the eigenvalues of a diagonal matrix is exactly the numbers on it's diagonal. In our case, this means that λi=i for 1≤i≤n. Finding the eigenvectors is left as an exercise to the reader. We henceforth denote the eigenvector paired with the i'th eigenvalue as  →v i.

Key Idea 5 Decompose  →e i into a linear combination of eigenvectors. This can be precalculated in O(N3). Let's denote another vector  →c i as this linear combination i.e.  →c i satisfies  →e i=∑ →v i →c i,j. In fact, this is almost all we need. Let's return to to a=Tk∑di≤kT−di →e iai (the second part can be trivially calculated). We can calculate almost "separately" for each eigenvector j. In fact, the contribution of the j'th eigenvector from the i'th chef after the k'th day is λkjci,jaiλ−dij. Let's store ci,jaiλ−jdi in a segment tree/BIT on di. We can extract in O(NlogN) total or O(logN) for a single eigenvector then find the total contribution by multiplying by λkj and using prefix sums on the eigenvector to extract the relevant range [l,r]. We can also process O(NlogN) per update if di stays constant trivially. This is more than enough to pass, but a further optimization is that the array d only changes at most O(N) time (whenever a new element becomes positive). So, we can simply rebuild our segment tree/BIT in O(N) to reach O(N3) complexity.

Final complexity: O(N3+QNlogN).

It's also worth noting that several nonoptimal solutions can pass. We attempted to cut off any solutions that explicitly use matrix multiplication. However, solutions with complexity such as O(QN2) can pass in 64 bit C++ if only additions are used. The only way we found to do only additions was by making the same eigenvector reduction, so we were not too worried. It seems impossible to fail such solutions while maintaining a reasonable TL.

Codeforces Round #727 Editorial

By ch_egor, 20 months ago, translation, In EnglishThanks for the participation!

1539A - Contest Start was authored and prepared by grphil

1539B - Love Song was authored by jury and prepared by talant

1539C - Stable Groups was authored by Artyom123 and prepared by Artyom123 and shishyando

1539D - PriceFixed was authored by Helen Andreeva and prepared by Siberian

1539E - Game with Cards was authored and prepared by TeaTime

1539F - Strange Array was authored and prepared by Tikhon228

1539A - Contest StartLet's find which participants will disturb participant i. Those are participants with number between i+1 and i+min(t/x,n). So each of first max(0,n−t/x) participants will get t/x dissatisfaction, and each next participant will get 1 dissatisfaction less, than previous. So the total answer is max(0,n−t/x)⋅t/x+min(n−1,t/x−1)⋅min(n,t/x)/2.

1539B - Love SongOne can notice that letter with number x will add exactly x to the answer. So, all we have to do is calculate the sum of numbers of letters in our substring. This can be done using prefix sums.

1539C - Stable GroupsFirstly, we will find the amount of groups needed if we don't add any new students. Let's consider the students in the increasing order of their knowledge level. Students are greedily determined to the same group if the difference of their knowledge levels is not greater than x. Else we create another group. After that all students will be split into continuous non-intersecting segments  — stable groups.

Merging two segments with knowledge difference d may be done by adding ⌈dx⌉−1 new students. Each such merge decreases the answer by 1 so we should maximize the amount of merges. To do that we should just consider the merges in increasing order of their costs.

1539D - PriceFixedLet m be the sum of all aiImportant greedy observations:

If there is an item which costs 1, then we will not make the answer worse by buying this item.If all prices are 2, then we will not make the answer worse by buying the item with max bi.Therefore we can sort all items by bi and on each iteration we will only need to consider two items: with max bi and with min bi among us all not bought items.

Another important observation: We already know how many items with price 2 we should buy to be able to buy something with a discount. This means that we can buy multiple items with full price together. Similarly, we can buy multiple items with a discount at once. This solution can be implemented using a two pointers technique which allows to find the answer in O(n⋅logn).

1539E - Game with CardsLet's use dynamic programming to solve the problem. dpL[i] is equal to 1 if we can correcly answer queries on suffix the way that i-th card is taken in left hand and i+1-th card is taken in right hand. dpR[i] is equal to 1 if we can correcly answer queries on suffix the way that i-th card is taken in right hand and i+1-th card is taken in left hand. Let's consider transitions to count dpL. Let's suppose we have j such that dpR[j]=1.

Then we can tell that dpL[i]=1, if these 2 conditions hold:

We can take all cards with indexes [i+1,j] in right hand.Card in query i fits constraints on value written on card in left hand in queries with indexes [i,j].This way we got solution which works in O(n2). Let's notice that if there exists j, that dpR[j]=1 then its optimal to consider such smallest j because it has less strict constraints. We will use the same approach to count values of dpR. This way we get soluton which uses O(n) time and memory.1539F - Strange ArrayNote that the distance from the given element to the median element (the center of a sorted segment) can be defined in terms of numbers of elements that are less, equal or bigger than the given element. Let cntL be the number of elements that are less, cntM — equal (excluding the given) and cntR — bigger than the given element.

Then the distance may be calculated in the following way:

If ai is bigger than the median element: ans=⌊cntL+cntM−cntR2⌋otherwise ans=⌊cntR+cntM−cntL+12⌋To solve the problem you firstly need to assume that the given element is greater than the median element, then consider the other case and take the maximum of two answers. Hereinafter only the second case is considered (in which the element is not greater than the median one), the first case can be done analogically.

Since we need to maximize cntR+cntM−cntL, let's do it separately for the elements to the left and to the right of ours.

Let's sort the indices so that the corresponding elements go in increasing order.

Let array D=[1,1…,1] (its size is n) and P=[1,2,…n]. We will need operations "+= on the segment" and "min/max on the segment", so let's build a segment tree for P.

We will iterate through the indices in the received order and when considering the index i we'll change D and P so that they correspond to the following conditions:

For each 1≤j≤n if aj<ai then Dj=−1, else Dj=1Array P is a prefix sum array for D (changes to P are made via a segment tree)In order to find max(cntR+cntM−cntL) among elements to the left of i we need to find minj=1iPj.

In order to find max(cntR+cntM−cntL) among elements to the right of i will find maxj=inPj.

We will find these values using the segment tree for P and consider the next index.

Note that for all the changes we will need only n actions, because in array D each element is firstly equal to 1, and then once becomes -1 and never changes again.

The described solution's time complexity is O(n⋅log(n))

Codeforces Round #726 (Div.2) Editorial

By mesanu, history, 21 month(s) ago, In English1537A - Arithmetic Array

TutorialTo make the arithmetic mean be equal to exactly 1 the sum needs to be equal to the number of elements in the array.

Let's consider 3 cases for this problem:

1) The sum of the array equals n: Here the answer is 0 since the arithmetic mean of the array is initially 1.

2) The sum of the array is smaller than n: The answer is always 1 since we can add a single integer k such that sum+k=n+1 is satisfied and more specifically k=n−sum+1.

3) The sum of the array is greater than n: If we add any number apart from 0 will add to the sum more or equal than to the number of elements. The number of 0's to add can be found by a loop of adding 0's until the number of elements is equal to the sum or by the simple formula of sum−n.

Code1537B - Bad Boy

Tutorial1537B - Bad BoyWe can notice that the optimal strategy is to put the yoyos in the corners of the board. One solution may be checking the best distance for all pairs of corners. But, if we think a bit more, we can notice that placing the yoyos in opposite corners the distance will always be maximum possible (the distance always being 2⋅(n−1)+2⋅(m−1)). So, one possible answer is to always place the first yoyo in the top-left cell and the second one in the bottom-right cell. This is always optimal because, for any initial position of Anton, the distance will still be the same (2⋅(n−1)+2⋅(m−1)), this being the largest possible distance. The distance can not get larger than that, because if we move one of the yoyos it will get closer to the other yoyo and the distance will decrease by 1 or won't decrease, but it's impossible for it to increase.

Code1537C - Challenging Cliffs

Tutorial1537C - Challenging CliffsWe claim that the maximum difficulty is at least n−2. Assume the array is sorted. We first need to find the two mountains which go on the ends. To do this, we can iterate through every mountain in the sorted array and check the difference between a mountain and its neighbours in the array. Let mk and mk+1 be the mountains with the smallest height difference. We can achieve at least a difficulty of n−2 by arranging the mountains as mk,mk+2,mk+3...mn,m1,m2,.....,mk+1. To get difficulty n−1, we need mk to be the shortest mountain and mk+1 to be the tallest mountain. This will only happen if n=2.

Code1537D - Deleting Divisors

Tutorial1537D - Deleting DivisorsLet's consider 3 cases for this problem:

1) n is odd

2) n is even, and n is not a power of 23) n is a power of 2If n is odd, the only move is to subtract an odd divisor (since all the divisors are odd). Doing this, we will obtain an even number that is not a power of 2(case 2). If D is the divisor of n, then n−D must also be divisible by D, and since D is odd, n−D cannot be a power of 2.

If n is even and is not a power of 2, it means that n has an odd divisor. By subtracting this odd divisor, we will obtain n−D is odd(case 1). Now let's show that subtracting an odd divisor every move results in a win. Primes are losing since the only move you can make on them is subtracting the entire number, which results in n=0 and a loss. Since every prime is odd or a power of 2, it works to give the other player an odd number because it will either be a prime(the other player loses), or they will make a move and give you another even number that is not a power of 2. You can continue this process because you will never land on a losing number and because the game must end after a finite number of moves, your opponent must always lose.

So we proved that odd numbers are losing and even numbers that are not powers of 2 are winning.

What if n is a power of 2? You can do two things in one move, halve n or make n an even number that is not a power of 2(we proved that this is a winning position for the other player). The only optimal move is to halve n, making it another power of 2. The players continue like this until one gets 2, which is a prime number, so it's losing. If log2(n) is even, Alice wins, otherwise Bob wins.

Code1537E1 - Erase and Extend (Easy Version)

Tutorial1537E1 - Erase and Extend (Easy Version)We claim that it is optimal to choose a prefix of the string, then duplicate it until we have a length bigger than k, then delete the excess elements.

Let's relax the requirement so you have a position in the string and each time you either return to the beginning or advance to the next character. The answer will be the first k characters of the lexicographically smallest infinite string. From a given position, the optimal infinite string from it is unique, so you can pick exactly one optimal decision. Now the optimal string is going around some cycle from the start, and we see it also satisfies the original requirement, not just our relaxation

We proved that it is optimal to choose a prefix, duplicate it until the length is bigger than k then delete the excess. As the constraints are low, we can iterate through every prefix on the original string and make a string of length k with it. Then we take the minimum of all these strings as the answer. Solution complexity O(n⋅k).

Code1537E2 - Erase and Extend (Hard Version)

TutorialWe know that the final string is some prefix repeated a bunch of times. Incrementally for i from 1 to n we will keep the longest among the first i prefixes that gives the best answer we've seen so far.

So assume the m−th prefix is currently the best and we're considering position p. If the p−th character is greater than the corresponding character in s1..m⋅(alot) then the p−th prefix and any further prefixes can't possibly give a smaller answer, so we just print the current one and finish. Otherwise all the characters before the p−th are all less than or equal to the corresponding characters in s1..m⋅(alot), so if the p−th is smaller than the corresponding we set the p−th prefix as the best.

Now the interesting case is if the current character is the same as the corresponding one. Say then that p=m+t, by the logic of the previous paragraph we must have s(m+1)..(m+t)=s1..t. If t=m then the new prefix is just the old one twice, so set p as the best prefix now. This ensures that otherwise t<m.

Denote A=s1..t and B=s(t+1)..m, so the string formed by the current best prefix is ABABABABA... and the new one is ABAABAABA... Now if AB=BA then these strings are in fact the same, so set m+t as the new best prefix. Otherwise we can find the first position where AB and BA differ, and use that to determine whether the new prefix is better. This can be done in O(1) with Z function, thus giving a linear solution for the full problem.

Solution by Ari.

Code1537F - Figure Fixing

Tutorial1537F - Figure FixingIf the parity of the sum of the initial values doesn't match the parity of the sum of the target values then there is no solution. Because k is an integer and we always add the value 2⋅k to the sum of the initial values in each operation it's easy to notice that the parity of the sum of the initial values never changes.

Otherwise, let's consider 2 cases:

2) The graph is bipartite.

3) The graph is not bipartite.

If the graph is bipartite, let the nodes be coloured red and blue with the condition that all the neighbors of any red node are blue and all the neighbours of any blue node are red. Let us call sum1=∑targeti−valuei for each blue node and sum2=∑targeti−valuei for each red node. We want to determine if we can make targeti=valuei for each node, which is equivalent to saying sum1=0 and sum2=0. We notice that the difference between sum1 and sum2 is invariant in a bipartite graph because all operations will add to sum1 and sum2 at the same time. So to make sum1=0 and sum2=0 we need sum1−sum2 to be equal to 0 initially.

If the graph is not bipartite, then it is always possible because if the graph is not bipartite, it contains two neighboring vertices of the same color, which can be used to add or subtract from their color sum.

Code

Codeforces Round #725 (Div. 3) Editorial

By Supermagzzz, history, 21 month(s) ago, translation, In English1538A - Stone Game

Author: MikeMirzayanov

Tutorial1538A - Stone GameIf we want to destroy the largest and smallest stone, then there are only four options:

Destroy the stones on the left until we destroy the smallest stone. Then destroy the stones on the right, until we destroy the largest stone.Destroy the stones on the right until we destroy the smallest stone. Then destroy the stones on the left, until we destroy the largest stone.Destroy the stones on the left until we destroy both stones.Destroy the stones on the right until we destroy both stones.You need to check all four options and choose the minimum answer.

Solution1538B - Friends and Candies

Author: MikeMirzayanov

Tutorial1538B - Friends and CandiesLet's denote for s the number of candies all friends have: s=∑i=1nai. Note that at the end, each friend must have sn of candy. If s is not completely divisible by n, then there is no answer.

How to get the answer if it exists? If the i-th friend has more candies than sn, then he must be chosen by Polycarp (otherwise this friend will have more candies than the others). If the i-th friend has no more than sn, then Polycarp may not choose it.

Then, if the answer exists, it is equal to the number of ai>sn.

Solution1538C - Number of Pairs

Author: MikeMirzayanov

Tutorial1538C - Number of PairsThe problem can be divided into two classic ones:

Count the number of pairs ai+aj≤r;Count the number of pairs ai+aj≤l−1.Let A — be the answer to the first problem, and B — be the answer to the second problem. Then A−B is the answer to the original problem.

The new problem can be solved by binary search. Iterate over the first element of the pair. Then you need to count the number of elements such that aj≤r−ai. If you sort the array, this value can be calculated by running a single binary search.

Solution1538D - Another Problem About Dividing Numbers

Author: MikeMirzayanov

Tutorial1538D - Another Problem About Dividing NumbersLet's denote for n the maximum number of moves for which the numbers a and b can be made equal. It is easy to understand that the number of moves is maximum when a=b=1 and each time we divided a or b by a prime number. That is, n= sum of exponents of prime divisors of a+ sum of exponents of prime divisors of b.

Let's denote by m the minimum number of moves for which the numbers a and b can be made equal. Consider a few cases:

If a=b, then m=0;If gcd(a,b)=a or gcd(a,b)=b, then m=1;Otherwise, then m=2.Then, the answer "Yes" is possible in the following cases:

m≤k≤n and k=1 and m=1,or, m≤k≤n and k≠1.Solution1538E - Funny Substrings

Author: MikeMirzayanov

Tutorial1538E - Funny SubstringsWe can't model this process directly, since the maximum string length reaches 250 (look at the second example from the statements).

To optimize this process, you can store each row as a set of the following values.

Number of occurrences of haha in the string  — cnt.String length  — length.The first three characters of the string are  — pref.The last three characters of the string are  — suff.Then, to process the second type of request and combine the two strings a and b into the string c, you need:

c.length=a.length+b.length.c.cnt=a.cnt+b.cnt+count(a.suff+b.pref,haha). (New occurrences may be added at the junction of two words)c.pref=a.pref (However, if the string length is less than 6=3+3, then you need to handle this case carefully with your hands)c.suff=b.suff (Similarly, you need to process small strings separately).Solution1538F - Interesting Function

Author: Supermagzzz, Stepavly

Tutorial1538F - Interesting FunctionFor each digit, we will count how many times it has changed.

The number of changes for the first digit (the lowest) is calculated using the formula r−l.

The number of changes for the second digit is calculated by the formula ⌊r10⌋−⌊l10⌋. That is, it is equivalent to the number of first-digit changes for numbers from ⌊l10⌋ to ⌊r10⌋.

To calculate the number of changes for the remaining digits, you need to apply similar reasoning with dividing the numbers by 10.

Solution1538G - Gift Set

Author: MikeMirzayanov

Tutorial1538G - Gift SetIn this problem, we can use a binary search for the answer (If we can make x sets, then we can make y<x sets). So, we need to come up with the following test, whether we can make n sets knowing the parameters x,y,a,b.

Let a>b (otherwise we will swap them). If a==b, the answer is ⌊min(x,y)a⌋.

Otherwise, let's say we want to make k sets of the first kind. Then we get a system of inequalitiesx≤a⋅k+b⋅(n−k)y≤a⋅(n−k)+b⋅kLet's express kfrom here

(x−b⋅n)a−b≤k(x−a⋅n)b−a≥k0≤kn≥kWe need to check whether these four equations have an intersection in integers. If there is, then the division into n gifts exists.

Solution

Codeforces Round #724 — Editorial

By rabaiBomkarBittalBang, 21 month(s) ago, In EnglishWe hope you liked the problems! If you’re curious about the two different problem formats, initially Tlatoani, golions, qlf9 and I were working on Omkar 3 with antontrygubO_o while MagentaCobra was working on a separate round with isaf27. We eventually decided to join forces and combine the rounds, resulting in the current Omkar 3.

1536A - Omkar and Bad StoryIdea: rabaiBomkarBittalBang

Preparation: rabaiBomkarBittalBang, Tlatoani, qlf9

Video editorial

HintSolutionWe first claim that if any negative number exists in a, then no solution exists. Denote p as the smallest number in a and q as another arbitrary number in the array (as n≥2, q always exists). Clearly, |q−p|=q−p>0. However, because p is negative, q−p>q. As such, adding q−p to the output array would create the pair (q−p,p) with difference q−2p>q−p. We have the same problem as before; thus, it is impossible to create a nice array if there exists a negative number in a.

After we deal with this case, we now claim that b=[0,1,2,...,100] is a valid nice array for any a that contains no negative numbers. It is easy to verify that this is a valid nice array. And since in this case, every element of a is nonnegative and distinct, it is always possible to rearrange and add elements to a to obtain b.

Implementation in Java by rabaiBomkarBittalBangImplementation in Kotlin by TlatoaniImplementation in C++ by kefaa2Implementation in Haskell by Tlatoani1536B - Prinzessin der VerurteilungIdea: MagentaCobra

Preparation: MagentaCobra

Video editorial

Hint 1Hint 2SolutionLet’s brute force check all substrings of length <= 3 and print the lexicographically smallest one that doesn’t appear as a substring in the input. We can guarantee that we will come across the answer due to the pigeonhole principle. There are at most n+n−1+n−2=3n−3 possible substrings of length 3 or shorter in the input. There exist 26+262+263=18278 total substrings of length 3 or shorter. It is impossible for the input to contain all 18278 substrings, as 3n−3<18278 for n≤1000.

Final runtime looks something like O(18278n) or O(n) depending on how you implement substring checking.

Implementation in Java by hu_taoImplementation in Kotlin by TlatoaniImplementation in C++ by 1-gonImplementation in Haskell by Tlatoani1536C - Diluc and KaeyaIdea: MagentaCobra

Preparation: MagentaCobra

Video editorial

Hint 1Hint 2Hint 3SolutionFor each prefix, label it with a pair (a,b) where a = frequency of ‘D’ in this prefix and b = frequency of ‘K’ in this prefix. Divide a and b by gcd(a,b). If we iterate over all prefixes from to left, we can notice that the answer for the prefix equals the # of occurrences of this pair we have seen so far! This can be visualized by drawing a poly-line as mentioned in the hints.

As for implementation, you can use a map in C++ or a HashMap in Java to achieve O(nlogn) or O(n) runtime.

Implementation in Java by hu_taoImplementation in Kotlin by TlatoaniImplementation in C++ by smaxImplementation in Haskell by Tlatoani1536D - Omkar and MediansIdea: rabaiBomkarBittalBang

Preparation: rabaiBomkarBittalBang, Tlatoani

Video editorial

SolutionFor some k<n, assume b1,b2,⋯,bk is the OmkArray of some a1,a2,⋯,a2k−1, and we want to see what values of a2k,a2k+1 we can add so that b1,b2,⋯,bk+1 is the OmkArray of a1,a2,⋯,a2k+1. Let c1,c2,⋯,c2k−1 be a1,a2,⋯,a2k−1 sorted in ascending order.

If bk+1≥bk, note that bk=ck and there are k−2 elements of a ≥ck+1, so no matter how large a2k,a2k+1 are there will be at most k elements larger than ck+1 in a1,a2,⋯,a2k+1. This gives bk+1≤ck+1. We can use a similar argument to show bk+1≥ck−1. Now we want to bound ck+1 and ck−1. Note that each distinct value among b1,b2,⋯,bk must appear at least once in a1,a2,⋯,a2k−1. Therefore, if i, j satisfy that bi is the largest value of bi≤bk and i≠k, and bj is the smallest value of bj≥bk, j≠k, then we have ck+1≤bj, ck−1≥bi, and so bi≤bk+1≤bj. If no such largest/smallest values exist, then we can assume bk+1 is not bounded above/below.

Therefore, if b has an OmkArray, it is necessary that for all i, there does not exist a j≤i such that bj is between bi and bi+1, exclusive. I claim this is also sufficient. We can construct such an array a using the following algorithm:

Let a1=b1.

If bi+1=bj for some bj<bi with j<i, let a2k−2,a2k−1=−∞ (we can replace −∞ with some sufficiently small constant at the end of our array creation process).

Otherwise, if bi+1<bi then let a2k−2=−∞, a2k−1=bi+1.

If bi+1=bj for some bj>bi with j<i, let a2k−2,a2k−1=∞ (we can replace ∞ with some sufficiently large constant at the end of our array creation process).

Otherwise, if bi+1>bi then let a2k−2=∞, a2k−1=bi+1.

Finally, if bi+1=bi, let a2k−2=−∞, a2k−1=∞.

This means that an equivalent condition to having an OmkArray is for all i, there does not exist a j≤i such that bj is between bi and bi+1, exclusive. There are multiple ways to check this for an array b, but one clean way would be to keep some TreeSet s, and check if bi+1 is between \t{s.ceil(bi)} and \t{s.floor(bi)} for all i, and then adding bi+1 to s if it is not already added.

Linear time implementation in Java by rabaiBomkarBittalBangImplementation in Kotlin by TlatoaniImplementation in C++ by kefaa2Implementation in Haskell by Tlatoani1536E - Omkar and ForestIdea: MagentaCobra

Preparation: MagentaCobra

Video editorial

Hint 1Hint 2SolutionImagine picking some subset of ‘#’ and making them 0. Then there is exactly one way to make all the remaining ‘#’ positive integers. To see why, imagine multisource BFS with all 0 as the sources. After the BFS, each ‘#’ will be equal to the minimum distance from itself to any 0 cell. Difference between adjacent cells will be at most 1. Proof can be shown by contradiction: if two cells with difference ≥2 existed, then the larger of these cells is not labeled with the shortest distance to a source (since the distance from the smaller cell +1 will be a better choice). Because of the nature of BFS, we can also ensure the second condition is also satisfied, since the only cells that have no neighbor strictly smaller will be the source cells. This is the only valid assignment because if we make any number larger, there will exist a pair of cells with difference ≥2. If we try to make any number smaller, there will exist a cell with positive karma that has no strictly smaller neighbor.

If we let k equal to the frequency of ‘#’ in the input, then the answer is 2k. Keep in mind of the special case where the input is all ‘#’, in which case you have to subtract 1. This is because a possible arrangement must contain at least one cell with karma of 0.

Obviously the solution runs in O(nm) time.

Implementation in Java by hu_taoImplementation in Kotlin by TlatoaniImplementation in C++ by kefaa2Implementation in Haskell by Tlatoani1536F - Omkar and AkmarIdea: golions

Preparation: golions

Video editorial

Hint 1Hint 2Hint 2 SolutionSolutionBecause of Hint 1 and Hint 2, we want to find the total number of possible games. This can be done by iterating over the number of moves and counting the number of ways to play a game with that number of moves.

We want to find the number of games that end in x moves on a board of size n.

The first step is to calculate the total number of ending states. If x=n, the total number of ending states is just 2 because you can either have ABABA... or BABAB...

Otherwise, a game that ends in x moves will consist of x letters, for example A|B|A|B|... where a | is a possible location of a single empty cell (there cannot be multiple empty cells next to each other or else it would not be a valid ending state). There are x possible places where there can be an empty cell, and n−x empty cells, so there are (xn−x) ways to choose places to put empty cells. Due to the circular nature of the board, you need to account for the case where the first cell on the board is an empty cell (the previous formula only works if the first cell is not empty). If you set the first cell to be empty, there are not x−1 possible places to put an empty cell and n−x−1 remaining empty cells, so you have to add (x−1n−x−1). Multiply the answer by 2 to account for starting with an A or B.

Finally, multiply by x! to account for all the ways you can reach each ending configuration.

Thus, if x=n, there are 2⋅x! optimal games, otherwise there are 2⋅((xn−x)+(x−1n−x−1))⋅x! optimal games.

Add up the number of games that end in x moves for all even x from ⌈n2⌉ to n, inclusive. Thus, the solution is O(n).

Implementation in Java by golionsImplementation in Kotlin by TlatoaniImplementation in C++ by kefaa2Implementation in Haskell by Tlatoani

Codeforces Round #723 (Div. 2) Editorial

By errorgorn, history, 21 month(s) ago, In English1526A - Mean InequalitySetter: antontrygubO_oPreparer: errorgorn

Hint 1Hint 2SolutionThe main idea is that we can split the numbers into the two halves, the big half and small half, we can place the bigger half at the odd positions and the smaller half at the even positions.

This works because the smallest big number is larger than the biggest small number. Hence, the mean of any two small numbers is smaller than any big number, and the mean of any two big numbers is bigger than any small number.

Code (C++)Code (Python)1526B - I Hate 1111Setter: errorgornPreparer: errorgorn

Hint 0Hint 1Hint 2SolutionMethod 1Notice that 1111=11⋅100+11 and similarly 11111=111⋅100+11. This implies that we can construct 1111 and all bigger numbers using only 11 and 111. So it suffices to check whether we can construct X from 11 and 111 only.

Suppose X=A⋅11+B⋅111, where A,B≥0. Suppose B=C⋅11+D, where D<11. Then X=(A+C⋅111)⋅11+D⋅111. So we can just brute force all 11 value of D to check whether X can be made.

Method 2Since gcd(11,111)=1, by the Chicken McNugget Theorem, all numbers greater than 1099 can be written as a sum of 11 and 111. We can use brute force to find the answer to all values less than or equal to 1099 and answer yes for all other numbers.

Code (C++)Code (Python)1526C1 - Potions (Easy Version) and 1526C2 - Potions (Hard Version)Setter: errorgorn and oolimryPreparer: oolimry

Hint 1Hint 2Hint 3SolutionMethod 1 — DPLet's consider a dynamic programming solution. Let dp[i][k] be the maximum possible health achievable if we consider only the first i potions, and k is the total number of potions taken.

The transition is as follows: dp[i][k]=max(dp[i−1][k−1]+ai,dp[i−1][k]) if dp[i−1][k−1]+ai≥0, and just dp[i−1][k] otherwise. The first term represents the case if we take potion i and the second term is when we ignore potion i.

This runs in O(n2) and passes the easy version.

Method 2 — Greedy 1We iterate through the potions in non-decreasing order and drink the potion if we do not die.

For convenience, we define ci=ai+i⋅ϵ, where ϵ is a very small real number so that we can treat ci as distinct integers. We will show by exchange argument that our greedy is optimal.

Let S be the set of potions that is an optimal solution.

Suppose i<j and ci<cj. If i∈S and j∉S, then removing i and adding j into S will still make S a valid solution.

Now, suppose that position i is not drunk. We can assume that there are no k (k<i) such that ck<ci and k is drunk by the previous assertion. Suppose we add i into S. If we reach a position j (we possibly die at j) where cj<ci, then we can remove j from S and add i to S. Otherwise, our greedy will also not choose i, as it was not chosen when we only consider indexes k such that ck<ci.

Notice that we can arbitrarily define the way ϵ is added, so basically we can process ai in any non-increasing fashion.

Doing this naively is O(n2) as well. However, using a range add range max lazy propagation segment tree, we can check if a certain potion can be drunk without dying, and the solution runs in O(nlogn).

Method 3 — Greedy 2 / DP 2We process the potions from left to right. At the same time, we maintain the list of potions we have taken so far. When processing potion i, if we can take i without dying, then we take it. Otherwise, if the most negative potion we've taken is more negative than potion i, then we can swap out potion i for that potion. To find the most negative potion we've taken, we can maintain the values of all potions in a minimum priority_queue. This runs in O(nlogn) as well

To prove that this works, let's consider best solution where we take exactly k potions (best as in max total health). The solution involves taking the k largest values in our priority queue. Then when considering a new potion, we should see whether swapping out the new potion for the $k$th largest potion will improve the answer.

Since the priority queue is strictly decreasing, there will be a cutoff K, where for k at most K, the answer is not affected, and for larger than K, we swap out the kth largest potion. It turns out this process is equivalent to inserting the new potion's value into the priority_queue. For those positions at most K, they are not affected. For the positions larger than K, the elements get pushed back one space, meaning that the smallest element is undrinked.

This can also be seen as an efficient way to to transition from one layer of the dp table to the next.

Code (C++)Code 2 (C++)Code (Python)1526D - Kill AntonSetter: errorgornPreparer: errorgorn

Hint 1SolutionWe claim that in the optimal answer all characters of some type will appear consecutively.

ProofSo, we can try all 24 possible strings and check the number of moves Anton's body needs to transform each string. The time limit is relaxed enough for a O(nlogn) similar to 1430E - String Reversal.

But there is a O(n) solution, the number of moves Anton's body needs to transform each string is given by the number of inversions in the string. But since we know that we only care about strings that have all the same characters appear consecutively, we can just keep a count of the number of inversions for each pair of characters.

Code (C++)Code (Python)1526E - Oolimry and Suffix ArraySetter: iLoveIOIPreparer: iLoveIOI

Hint 1SolutionFirst, let's consider a simpler problem.

Is it possible to make a string with a certain suffix array given an alphabet size k.

Consider two adjacent suffixes in the suffix array "xy" and "ab" where b and y are some strings and x and a are some characters i.e. x is the first character of that suffix and similarly for a. If b and y don't exist we consider them as \$, i.e. smaller than everything. Also, "xy" comes before "ab".

Observation: If the position of b is less than the position of y in the suffix array, x must be less than a. Otherwise, x must be less than or equal to a.

This can be easily shown as "xy" must be lexicographically smaller than "ab". This is sufficient also.

Thus we can iterate through the suffix array and check if pos[arr[i]+1]>pos[arr[i+1]+1] where arr is the suffix array and pos is the position of the ith element in the suffix array. If this condition holds then the arr[i] th character must be strictly less than the arr[i+1] th character. Thus we can just count how many such pairs exist. If this count is larger than the alphabet size no such string is possible. Otherwise, such string exists. Note that special care must be taken when considering arr[i]=n−1 as pos[n] may not be defined (0-indexed).

After tackling the simpler question we move on to the full question of counting how many such strings are there. If we consider the string as an array and the order of the array as the order of the suffix array meaning that the i th element of this array is the arr[i] th element of the string. We have now transformed the question into "Given that some elements must be greater than the previous elements while others can be equal. Count how many arrays are there such that the largest element is less than k".

Consider the difference array, some elements must be ≥1 while some can be ≥0. We add padding to the front and back of the array so as to account for the first value being non-zero and the last element being less than k. These two elements are both ≥0. Let cnt be the number of elements that must be ≥1 in the difference array. Now, this becomes count how many arrays of (n−1+2)=(n+1) non-negative elements sum to k−cnt. This can be solved using stars and bars so the final answer comes out to be (n+1+k−cntn) which can be found easily. Note that we define (ab)=0 when a<b.

Final Complexity O(nlogMOD) or O(n) depending on how you find the modular inverse.

Btw k was chosen to also be ≤2×105 so as to hide the final complexity :)

Code (C++)Code (Python)1526F - Median QueriesSetter: errorgorn and oolimryPreparer: errorgorn

Hint 1Hint 2SolutionThe problem can be broken into 2 main parts:

Finding a pair (a,b) such that |p[a]−p[b]| is roughly less than a third.Finding elements 1 and 2 (actually we may find N and N−1 but it is the same).Find the rest of the elementsA convenient way to think about the queries, is that given p[a]<p[b]<p[c], we will be returned max(p[b]−p[a],p[c]−p[b]).

We will spend the first queries to find a tuple (a,b,c) such that the return value of this query is at most ⌊n−46⌋. The easiest way to do this is by randomly choosing distinct a,b,c and querying it. See proof 1 for the random analysis. But there is also a deterministic solution. Choose any 13 elements from the array, and it is guaranteed that there exists a tuple in those 13 elements such that the return value of the query is at most ⌊n−46⌋, see proof 2. To query all tuples in this sub-array of size 13, it takes 286 queries, which fits very comfortably under 420. user14767553 conjectured that a sub-array of size 10 works, however we are unable to prove it. You can try to hack his solution at 117685511.

Among a, b, and c, we choose a and b. The important idea here is that the gap between a and b is small, because we have found a tuple (a,b,c) is less than or equal to ⌊n−46⌋, so |p[a]−p[b]|≤2⋅⌊n−46⌋≤⌊n−43⌋. Now, we query all tuples (a,b,x) for all x≠a and x≠b. Since the gap between a and b is small, we should be able to identify either (1,2) or (n,n−1). This is because either p[a]−1>p[b]−p[a] or n−p[b]>p[b]−p[a] (WLOG assuming p[b]>p[a]), see proof 3. Therefore, the furthest x will return the largest value when querying for (a,b,x). (If there's ties choose anyone).

Suppose we found element 1, there are at most two possible candidates for element 2, y1 and y2 (the other possible candidate will be either n or n−1). We can use 2 queries to figure out which of them is element 2. We can query (1,y1,a) and (1,y2,a). Whichever produces the smaller value is element 2, see proof 4.

Once we have found elements 1 and 2, solving the rest of the problem is simple. Querying (1,2,x) will always return x−2. And we can find the rest of the elements in another n−2 queries. Do not forgot about the condition that p[0]<p[1]!

Proof 1Proof 2Proof 3Proof 4Code (C++)Code (Python)Code GolfYou may have realized that python codes in the editorial are quite short. We actually had a code golf challenge among testers. You are invited to try code golf our problems and put them in the comments. Maybe I will put the shortest codes in the editorial ;)

Rules for code golf:

any language allowedcodes will be judged by number of charactersmust get AC in the respective problems

Codeforces Round #722 Editorial

By AliShahali1382, history, 21 month(s) ago, In EnglishHi, Codeforces!

1529A - Eshag Loves Big Arrays

problem idea and solution: AmShZ

editorial1529A - Eshag Loves Big ArraysWe state that every element except for the elements with the smallest value can be deleted.

Proof: denote MN as the minimum element (s) of the array a, in each operation pick MN and some other element, say X, which is bigger than MN, since AVG=X+MN2<X, then X will be deleted.

Doing this for every X>MN will result in the deletion of every element except for the elements with the smallest value. So the answer to the problem is n−cntMN, where cntMN is the number of times MN appeared in a.

complexity: O(n)official solution1529B - Sifid and Strange Subsequences

problem idea and solution: Davoth

editorial1529B - Sifid and Strange SubsequencesIt's easy to prove that a strange subsequence can't contain more than one positive element.

So it's optimal to pick all of the non-positive elements, now we can pick at most one positive element.

Assume x is the minimum positive element in the array. We can pick x if no two elements in the already picked set such as a and b exist in a way that |a−b|<x.

To check this, we just have to sort the already picked elements and see the difference between adjacent pairs.

complexity: O(nlogn)official solution1528A - Parsa's Humongous Tree

problem idea and solution: shokouf, AmShZ

editorial1528A - Parsa's Humongous TreeThe solution is based on the fact that an optimal assignment for a exists such that for each vertex v, av∈lv,rv.

Proving this fact isn't hard, pick any assignment for a. Assume v is a vertex in this assignment such that av∉lv,rv.

Let p be the number of vertices u adjacent to v such that au>av.

Let q be the number of vertices u adjacent to v such that au<av.

Consider the following cases:

p>q: In this case we can decrease av to lv and get a better result.p<q: In this case we can increase av to rv and get a better result.p=q: In this case changing av to lv or rv will either increase or not change the beauty of the tree.Based on this fact, we can use dynamic programming to find the answer.

Define dpv,0 as the maximum beauty of v's subtree if av is equal to lv.

Similarly, define dpv,1 as the maximum beauty of v's subtree if av is equal to rv.

dpv,j is calculated based on v's children, for each of v's children such as u, we add u's contribution to dpv,j.

The transitions are:

dpv,0+=max(dpu,0+|lv−lu|,dpu,1+|lv−ru|)dpv,1+=max(dpu,0+|rv−lu|,dpu,1+|rv−ru|)It's clear that the answer is equal to max(dpv,0,dpv,1).

complexity: O(n)official solution1528B - Kavi on Pairing Duty

problem idea and solution: alireza_kaviani

editorial1528B - Kavi on Pairing DutyLet dpi be the number of good pairings of 2i points.

Clearly, the answer is dpn.

Lemma: Denote x as the point matched with the point 1. Notice that each point p (x<p≤2n) belongs to a segment with length equal to [1,x]'s length.

Proof: Assume some point p (x<p≤2n) is paired with a point q (q>p), since [p,q] doesn't lie inside [1,x] then their size must be the equal for the pairing to be good.

To compute dpn, consider the following cases:

x>n: Similar to lemma mentioned above, it can be proved that each point p (1≤p≤2n−x+1) is paired with the point i+x−1, the remaining unpaired x−n−1 points form a continuous subarray which lies inside each of the current pairs, thus they can be paired in dpx−n−1 ways.x≤n: In this case, due to the lemma mentioned above all the segments must have the same length, thus their length must be a divisor of n, in this case they can be paired in D(n) ways; where D(n) is the number of divisors of n.So dpn = D(n)+∑n−1i=0dpi.

Note that dp0=dp1=1.

complexity: O(nlogn)official solution1528C - Trees of Tranquillity

problem idea and solution: AliShahali1382

editorial1528C - Trees of TranquillityLet's start with some observations.

Take any clique C in the memorial graph.

Notice that the vertices of C are a subset of a path from root to some leaf in Soroush's tree. So it's sufficient to solve the task for every leaf in Soroush's tree, specifically we should consider subsets of the paths starting from the root and ending in a leaf in Soroush's tree.

Assume you have a data structure that supports the following operations:

Insert a vertex.Erase a vertex.Among the vertices inside it, find the biggest set of vertices S such that none of them is the ancestor of the other in Keshi's tree.To solve the task, start doing DFS from the root of Soroush's tree. Every time you visit a new vertex v, add v using the 1-st operation. Every time you finish doing DFS in a vertex v, erase v using the 2-nd operation.

It's easy to see that the vertices in the data structure always form a path from root to some vertex v in Soroush's tree.

The answer to the task is the maximum size of S in the 3-rd operation for every leaf u of Soroush's tree, when adding u has been the last operation in the data structure; In other words ans=max(ans,x) where x is the size of S in the 3-rd operation whenever you reach a leaf while doing DFS in Soroush's tree.

When adding a vertex v to the data structure, if no vertex u∈S existed such that u was in v's subtree in Keshi's tree, consider the following cases:

If no ancestor of v was in S, greedily add v to S.Otherwise, let that ancestor be w, erase w from S and add v instead.On the other hand, if such a vertex u already existed in S, we won't add v to S based on the greedy solution mentioned above.

Whatever notation used from here onwards refers to Keshi's tree unless stated.

Do a DFS on the tree and find the starting time/finishing time for each vertex.

It's widely known that vertex v is an ancestor of vertex u⟺ stv≤stu and ftv≥ftu.

Observation: for any pair of vertices u and v, segments [stu,ftu] and [stv,ftv] either don't share an element or one of them lies completely inside the other.

To construct the aforementioned data structure:

Let the set S be a maximal set of the vertices that form a clique in the memorial graph. For each vertex v we store a pair {stv,v} in S.

Now to check whether any vertex u in the subtree of vertex v exists in S: Let p be the first pair in S such that the first element in p≥stv. If p's second element's finishing time is less than ftv then p's second element is in v's subtree, otherwise it's not.

Now to check whether any ancestor of v is in S or not: Let p be the first pair in S such that p's first element is less than stv, it can be proved that if an ancestor u of v exists in S, then p={stu,u}, thus we can check if v is in the subtree of p's second element by the aforementioned observation.

Doing the erase operation is also possible by keeping a history of the deleted elements from the set S.

complexity: O(nlogn)official solutionbetter implementation of official solution: AaParsapython solution: Tetanother O(n.log) solution with seg-tree: N.N_20041528D - It's a bird! No, it's a plane! No, it's AaParsa!

problem idea and solution: AmShZ, AliShahali1382

editorial1528D - It's a bird! No, it's a plane! No, it's AaParsa!Suppose we did normal dijkstra, the only case that might be missed is when we wait in a vertex for some time.

To handle the 'waiting' concept, we can add n fake edges, i-th of which is from the i-th vertex to the (i+1modn) -th vertex with weight equal to one.

Note that unlike the cannons, fake edges do not rotate.

It can be proved that doing dijkstra in the new graph is sufficient if we guarantee that the first used edge is not fake.

We can map waiting for x seconds and then using an edge to go to u from v to using a cannon and then using x fake edges to go to u from v.

Also due to the strict time limit you should use the O(n2) variant of dijkstra.

complexity: O(n3)official solutiona different O(n^3) solution: Atreus1528E - Mashtali and Hagh Trees

problem idea and solution: AliShahali1382

Thanks to Kininarimasu for the editorial.

editorial1528E - Mashtali and Hagh TreesLet dpi be the answer for all trees such that there exists a root and all edges are directed in the same direction from root and the root has at most 2 children. We transition:

dpi=dpi−1+dpi−1⋅pdpi−2+dpi−1⋅(dpi−1+1)2 where pdpi=∑ij=0dpj.

Then let dp2i be the same as dpi except the root must have exactly 2 children. So dp2i=dpi−dpi−1.

The answer for these cases is:

2⋅(dpn+dpn−1⋅pdpn−2⋅(pdpn−2+1)2+pdpn−2⋅dpn−1⋅(dpn−1+1)2+dpn−1⋅(dpn−1+1)⋅(dpn−1+2)6)−1.

This is because dpn holds the answer for at most 2 children and the other section accounts for the rest. We multiply by 2 to account for both edges directions, and subtract 1 because a single path is isomorphic.

This obviously doesn't handle all cases, but all other cases can be found in the following form. Let tup,k be a tree where the root has 2 children and the edges are directed up and the longest path is k, and let tdown,k be a tree where the root has 2 children and the edges are directed down and the longest path is k. Then all other cases are tup,k which exists on some path of length l to and connects to tdown,n−k−l.

We can count every other case as ∑n−1i=0(dpi−1)⋅dp2n−1−iThis works because we pretend the path is always length 1, then if we do dpi⋅dp2n−1−i we handle all cases except for when the tup,k is empty, and that only happens once.

official solution1528F - AmShZ Farm

problem idea and solution: AmShZ, AliShahali1382

editorial1528F - AmShZ FarmConsider the following problem: n cars want to enter a parking lot one by one. The parking lot has n slots numbered 1,2,…,n, the i-th of the n cars wants to park in the ai-th slot.

When the i-th car drives in, it will park in the first empty slot s such that s≥ai.

An array a is Good if all of the cars are parked in some slot after the end of the procedure.

Good arrays can be mapped to more-equal arrays, because it can be proved that in any sorted Good array ai≤i, same goes for the more-equal arrays.

Now let's modify the above problem a bit, consider a circular parking lot with n+1 free slots. n cars want to park in it, i-th of which wants to park in the ai-th slot (1≤ai≤n+1).

When the i-th car drives in, it will park in the first empty slot s such that s is the first empty slot after (including) ai in the clockwise direction.

It's obvious that one slot will be empty after the end of the procedure, let's call this slot x.

Arrays in which x=n+1 can also be mapped to more-equal arrays, let them be good arrays. let the other arrays be called bad arrays (arrays in which x≠n+1).

Every good can mapped to n bad arrays, just add x (1≤x≤n) to all of elements of a, formally speaking for each i (1≤i≤n), ai=((ai+x)modn+1+1). This can also be viewed as a circular shift of the elements/final positions.

Note that the number of arrays compatible with a stays the same in this proccess.

Thus the number of bad arrays is equal to nn+1 of all the possible (n+1)n arrays.

We know that ab1=ab2=…=abk, assume ab1=x, let's fix x (1≤x≤n+1), let CNT be the number of occurrences of x in a. The number of compatible arrays b such that abj=x (1≤j≤k) is equal to CNTk.

So the number of pairs of arrays a and b where b is a compatible array with the more-equal array a is equal to ∑nCNT=0(nCNT)⋅nn−CNT⋅CNTk.

There are n+1 ways to choose x, also we had to divide the result by n+1 because we were previously counting bad arrays as well, so we can simplify both of this terms with each other.

The sum ∑nCNT=0(nCNT)⋅nn−CNT⋅CNTk mentioned above is equal to ∑ki=1S(k,i)⋅i!⋅(ni)⋅(n+1)(n−i), where S refers to Stirling numbers of the second kind.

All of S(k,i) can be found in O(klogk) using FFT.

So overall we can solve the task in O(klogk).

official solution

Codeforces Round #721 — EDITORIAL

By the_nightmare, history, 21 month(s) ago, In English1527A - And Then There Were K

Author: loud_mouthIdea: Bignubie

Editorial1527A - Потом было KLet T= n & (n−1) & (n−2) & (n−3) & ... (k)

If there is at least one integer from K to N whose bit at the ith index is 0, then the value of the ith bit in T will also be 0. We can easily observe that the msb (Highest set bit in n) in N will become 0 for the first time when K=2msb−1. All the other bits will become zero when K=2msb.

Thus the answer is, K=2msb−1.

Solution (Loud_mouth)Solution (the_nightmare)1527B1 - Palindrome Game (easy version)

Author: DenOMINATORIdea: shikhar7s

Editorial1527B1 - Игра на палиндроме (простая версия)If the count of zeros in the string s is even then Bob always win

Proof

Bob can restrict Alice from performing operation 2 by making string s palindrome (if Alice changes s[i] to '1' then Bob will change s[n−i+1] to '1'). However, when the last '0' is remaining, Bob will reverse the string, eventually forcing Alice to perform the operation 1. This way Alice will spend 2 dollars more than Bob resulting in Bob's win.If the count of zeros in the string s is odd then Alice always win except for the case of one '0'Proof

Alice will change s[n/2] from '0' to '1' and play with the same strategy as Bob did in the above case. This way Bob will spend 1 dollar more than Alice resulting in Alice's win.Solution (DenOMINATOR)Solution (shikhar7s)1527B2 - Palindrome Game (hard version)

Author: DenOMINATORIdea:DenOMINATOR

Editorial1527B2 - Игра на палиндроме (сложная версия)Solution 1:

The case when s is a palindrome is discussed in B1. Otherwise, Alice will win or the game will end with a draw.

Proof

If it is optimal for Alice to perform operation 1 in the first move, she will perform it else she will perform operation 2 forcing Bob to perform operation 1 (which is not optimal otherwise Alice would have performed it in the first move).Optimal Strategy for Alice

Alice will keep reversing the string till string s is one move short to become a palindrome with an even number of zeros. This time Alice will perform operation 1 instead of reversing and will make string s a palindrome. Now, string s is a palindrome containing an even number of zeros, with Bob's turn. Here, Alice can take 2 dollars advantage using the strategy mentioned in B1. This way Bob will spend at least 1 dollars more than Alice resulting in Alice's win.In some cases like '1100', '1001110' Alice will just keep on reversing the string and Bob has to change all '0' to 1'.There's only 1 case when there's a draw if the length of string s is odd and contains 2 zeros (1 zero is in mid of string s).Solution 2:

As constraints on n were small, the problem can also be solved using dynamic programming.

Following parameters of string s is enough define current state of game:

cnt00 = count of symmetric 00 pair (s[i]='0' as well as s[n−i+1]='0')cnt01 = count of symmetric 01 or 10 pair (s[i] is not equal to s[n−i+1])mid = True if mid character exists (length of string is odd) and it is '0' else Falserev = True if previous move was operation 2 else FalseIf any player encounters the game state {cnt00,cnt01,mid,rev}, we define dpcnt00,cnt01,mid,rev to be the minimum cost difference he/she can achieve from here.

Transition is pretty simple

if rev is False and cnt01>0: dpcnt00,cnt01,mid,rev=min(dpcnt00,cnt01,mid,rev,−dpcnt00,cnt01,mid,True)if cnt00>0: dpcnt00,cnt01,mid,rev=min(dpcnt00,cnt01,mid,rev,1−dpcnt00−1,cnt01+1,mid,False)if cnt01>0: dpcnt00,cnt01,mid,rev=min(dpcnt00,cnt01,mid,rev,1−dpcnt00,cnt01−1,mid,False)if mid is True: dpcnt00,cnt01,mid,rev=min(dpcnt00,cnt01,mid,rev,1−dpcnt00,cnt01,False,False)Finally,If dpcnt00,cnt01,mid,rev<0, Alice winsIf dpcnt00,cnt01,mid,rev>0, Bob winsIf dpcnt00,cnt01,mid,rev=0, DrawWe can precompute this dp and answer all test cases in O(n). Overall time complexity - O(n2)Solution(Greedy) (DenOMINATOR)Solution(DP) (DenOMINATOR)1527C - Sequence Pair Weight

Author: sharabhagrawal25Idea: rivalq

Editorial1527C - Парный вес последовательностиFirst of all, it can be proved that the maximum possible answer occurs when n=105 and all the elements are identical which comes out to be of the order 4⋅1018, which fits in the long long integer range, thus preventing overflow.

The brute force approach is just to find the weight of each subarray and sum them up but it will definitely not fit into TL.

Let dpi represents the sum of the weights of all subsegments which ends at index i.

So answer=∑ni=1dpiNow, dpi includes:

Sum of the weights of all subsegments ending at index i−1 which is equal to dpi−1.The contribution of ith index for all the subsegments ending at index i. This is just the sum of prefix sums of indexes of the element having the same value as that of ai which has occurred before index i. This is because the number of subsegments ending at index i in which any index j (j<i and aj=ai) has been counted as unordered pair j,i is equal to j. This can be done by maintaining a map that stores the prefix sum of indexes for a given value till i.dpi=dpi−1+∑j where j<i and aj=aiSolution (sharabhagrawal25)Solution (mallick630)1527D - MEX Tree

Author: mallick630Idea: CoderAnshu

Editorial1527D - MEX деревоThis problem can be solved with two pointer approach. We will use the following simple formula to evaluate the number of paths with MEX = i,

ansi = (Number of paths with MEX≥i) - (Number of paths with MEX>i).

First we root the tree at node 0 and calculate the subtree sizes using a basic subtree DP. Now we can easily calculate answer for 0 by just summing up the size⋅(size−1)/2 of its children. Since total number of paths are (n2), the number of paths with MEX>0 are (n2)−ans0 and we will maintain these paths which are having MEX>i for every i in a variable lets say P. Now the main idea is that for the MEX of a path to be equal to i it must contain all nodes from 0...i−1 and not i. It can be seen that if we have current MEX=i in some path then this path can only be extended from both ends as for MEX>i this whole path must be included. So we start with our 2 pointers initially l=0,r=0 i.e. both at the root. We will also be maintaining a visited array which will be denoting all those vertices which are lying in our path from l to r. Now we loop from 1 to n and successively calculate their answers. Suppose we need to add some vertex i to the path, then if the current vertex is already in the path i.e. already visited then we can just continue as the variable P will remain same. In the other case, a possible approach is to just recursively move to the parent marking them as visited until we find a previously visited node. Let that node be U. Note that we will always break at the root as it is marked visited in the initial step.

Now the following two cases arise,

The node U is one of the endpoints l or r. In this case we can simply calculate the number of paths having MEX=i. See the diagram below, we are having P from previous calculations the number of paths having MEX≥i and the number of paths with MEX>i (actually those paths which include all nodes from 0 to i−1) can simply be seen as subtreei⋅subtreel or subtreei⋅subtreer depending on which two endpoints are there now. It should be noted that we also need to update the subtree sizes as we move up to parent recursively, by subtracting the subtreev from subtreeparent(v). After updating the l and r pointers, the answer for MEX=i is simply P−subtreel⋅subtreer and finally we update the variable P=subtreel⋅subtreer denoting for i+1, the number of paths with MEX≥i+1.

The next case is when U is not among the endpoints l and r, then in this case ansi=P and all other remaining i.e MEX≥i+1 are zero, since we can never find a path which can contain all vertices from 0 to i.

Solution (shikhar7s)Solution (the_nightmare)1527E - Partition Game

Author: rivalqIdea: rivalq

Editorial1527E - Игра в разделенияLet's use dynamic programming to solve this problem.

Consider dp[i][j] be the answer for prefix j with i subsegments. Transitions are fairly straightforward. Let c[i][j] be the cost of subarray starting at ith index and ending at jth index.

dp[i][j]=mink<j(dp[i−1][k]+c[k+1][j])If we calculate it naively, it would result in O(n2k) solution which would not be enough for given constraints.

We need some data structure to maintain dp[i−1][k]+c[k+1][j] for every k<j. Consider the example a=[2,2,3,2,3]. We can write cost as (2−1)+(4−2)+(5−3)=5.

Except for the first occurrence, we just need a sum of b[k]=k−last[a[k]] in the range, where last[a[k]] is the index of the last occurrence of a[k] just before index k.

We can maintain this in some segment tree. Let's say our segment tree is built for prefix j, we can transition to prefix j+1 by adding b[j+1] in range [0,last[a[j+1]]−1].

This will result in a O(n⋅klog(n)) solution.

Solution (rivalq)Solution (the_nightmare)

Codeforces Round #720 Editorial

By Karavaiev, history, 22 months ago, In EnglishThanks for participating!

1521A - Nastia and Nearly Good Numbers

Tutorial1521A - Nastia and Nearly Good NumbersThere are 2 cases:

if B=1, then the answer doesn't exist. Here we cannot get the nearly good numbers at all.

Otherwise, we can construct the answer as A+A⋅B=A⋅(B+1).

Solution1521B - Nastia and a Good Array

Tutorial1521B - Nastia and a Good ArrayThere are many ways to solve the problem. Here is one of them:

We will use the fact that gcd(i,i+1)=1 for any integer i≥1.

Let's find the minimum element x of the array a that is located in the position pos. Then for all integer i (1≤i≤n) perform the following operation: (pos, i, x, x+abs(pos−i)). That's how we replace ai to x+abs(pos−i). The main condition: min(ai,aj)=min(x,y) is satisfied because apos always equals to x and this value always less than any other element in the array a.

Consider the structure of the array a after performing the operations describing above.

Let's define l=x+pos−i and r=x+i−pos. These are the leftmost and the rightmost elements in the array a, respectively.

The array a looks like [l, l−1 … x+1, x, x+1 … r−1, r]. Thus, we obtain an absolute difference, equal to one, between all pairs of adjacent elements.

Solution1521C - Nastia and a Hidden Permutation

Tutorial1521C - Nastia and a Hidden PermutationSolution 1:

Let's fix 2 indices i and j (1≤i,j≤n, i≠j). Then restore pi and pj.

Let's assume we know the maximum element among pi and pj: mx=max(pi,pj).

Now we can figure out where exactly the maximum is by asking the following query:

val=max(min(mx−1,pi),min(mx,pj)).

There are 2 cases:

val=mx−1: it means pj<mx, otherwise val=min(mx,pj)=mx.val=mx: it means pj=mx, because min(mx−1,pi)<mx.If we know where the maximum is located we easily can find the remaining element:

if pi=mx, then pj=min(max(1,pj),max(2,pi)).if pj=mx, then pi=min(max(1,pi),max(2,pj)).We can solve the problem if we know the mx. Let's find it:

mx=max(min(n−1,pi),min(n,pj))Take a look on the case when mx=n−1. Here we cannot be sure that mx=max(pi,pj). It's possible only if pi=n. Thus if mx=n−1 we spend an extra query to be sure that pi≠n. We will ask:

val=max(min(n−1,pj),min(n,pi))So, if val=n, then the value pi equlas to n, otherwise the value mx=n−1 equals to the real maximum among pi and pj.

As a result, we can restore any 2 elements of the permutation.

Let's split our permutation into ⌊n2⌋ pairs and restore them independently of each other.

The total queries we perform is ⌊3⋅n2⌋+2. We spend 3 operations to restore each of the pair of elements. And no more than 2 extra queries to be sure that mx is correct.

Solution 2:

Let's find the maximum of the permutation and then restore the element pi (1≤i≤n) of the permutation by query:

pi=min(max(1,pi),max(2,mx).

To find the maximum element let's split the permutation into ⌊n2⌋ pairs and perform the following operation to each of them:

mx=max(min(n−1,pi),min(n,pj)).

if mx=n, then j is the position with a maximum element.if mx=n−1, then need to make sure that pi≠n. Let's make the same extra query as we do in the Solution 1.Note that if you don't find the maximum element among the ⌊n2⌋, then it's in the remaining element when n is odd.

The total queries we perform is n + ⌊n2⌋+1. We ask ⌊n2⌋+2 queries to find the maximum of the permutation and n−1 quiries to restore the remaining elements.

Solution 11521D - Nastia Plays with a Tree

Tutorial1521D - Nastia Plays with a TreeLet's define the variable x as a minimum number of operations that we need to get bamboo from a tree.

Let's remove x edges first and then add x new ones to the graph.

Consider the structure of the graph after removing x edges. This is a forest with a x+1 connected components.

Easy to notice each of the x+1 connected components in the getting forest of trees must be a bamboo to get the bamboo after adding new x edges.

The red edges are removed.Thus, we can get the bamboo from the forest of bamboo after removing x edges by x times adding the conjunction between leaves that are in the different components of connectivity of the forest.

The green edges are added.So, the task is to find the minimum number of the removing edges needs to get the forest of bamboos. Here works the following greedy:

Let's define any vertice of the tree as a root.

We will solve the problem for each of the subtrees v (1≤v≤n).

First, solve the problem for all child vertices of v. Then define the value cv as the number of the children and the value pv as the ancestor for vertex v.

There are 3 cases:

If cv<=1, then we don't remove anything.If cv=2, then we remove the edge (pv,v) if pv exists.If cv>2, then we remove the edge (pv,v) if pv exists and any c−2 existing edges from v to one of the children vertex.Take a look at the picture:

The root of the tree is vertex 1.Solution1521E - Nastia and a Beautiful Matrix

Tutorial1521E - Nastia and a Beautiful MatrixLet's fix n and will check whether we build a beautiful matrix or not.

Let's define the variable mx as a maximum element among all elements from the array a. In other words, the amount of the most frequently occurring number we have. Also, define the variable sum as an amount of numbers we have.

We can single out the 2 criteria. These are sum≤n2−⌊n2⌋2 and mx≤n⋅⌈n2⌉. It can be proved by spitting the matrix into disjoint matrices 2×2.

Let's construct the structure of the matrix and provide the algorithm of arrangement, that if the previous 2 conditions are satisfied, then we always can create the beautiful matrix of n size. Take a look at the picture:

There are 4 types of cells. White cells are empty, blue ones can consist of any number.

Let's fill yellow and red cells in a way that they don't have any common number. We will do it greedily:

Let's fill red cells at first. Let's take numbers x, which is the most frequently occurring, and just try to fill red cells using only it.

If all numbers x are fully fit there, then we just take a new x and continue filling cells. If there are elements of color x that cannot be placed there then we put all such remaining elements in blue cells.

It is always possible to do because the number of blue cells and yellow cells together is n⋅⌈n2⌉, that is the upper bound of the value mx. In this way, we filled red cells and some blue cells.

The other elements, which haven't been placed yet, can be placed randomly because they won't match(by diagonal) due to the way of filling red cells.

Solution

Codeforces Round #719 (Div. 3) Editorial

By Supermagzzz, 22 months ago, translation, In English1520A - Do Not Be Distracted!

Authors: MikeMirzayanov

Tutorial1520A - Do Not Be Distracted!The simplest solution — go through the problem, because of which the teacher might have suspicions. Now you can find the first day when Polycarp solved this problem and the last such day. Between these two days, all problems should be the same. If this is not the case, the answer is "NO".

Solution1520B - Ordinary Numbers

Authors: MikeMirzayanov

Tutorial1520B - Ordinary NumbersNote that every ordinary number can be represented as d⋅(100+101+…+10k). Therefore, to count all ordinary numbers among the numbers from 1 to n, it is enough to count the number of (d,k) pairs such that d⋅(100+101+…+10k)≤n. In the given constraints, it is enough to iterate over d from 1 to 9 and k from 0 to 8.

Solution1520C - Not Adjacent Matrix

Authors: MikeMirzayanov

Tutorial1520C - Not Adjacent MatrixNote that n=2 is the only case where there is no answer.

For other cases, consider the following construction:

Let's say that the cell (i,j) is white if i+j is an even number, otherwise, we will say that the cell (i,j) is black;Let's arrange the cells so that all white cells are first, and if the colors are equal, the cells will be compared lexicographically.Arrange numbers from 1 to n2 in ordered cells.For example, for n=3, the following matrix will be constructed:⎛⎝⎜174639285⎞⎠⎟Solution1520D - Same Differences

Authors: MikeMirzayanov

Tutorial1520D - Same DifferencesLet's rewrite the original equality a bit:aj−ai=j−i,aj−j=ai−iLet's replace each ai with bi=ai−i. Then the answer is the number of pairs (i,j) such that i<j and bi=bj. To calculate this value you can use map or sorting.

Solution1520E - Arranging The Sheep

Authors: Supermagzzz, Stepavly

Tutorial1520E - Arranging The SheepLet's denote by k the number of sheep in the string, and by x1,x2,…,xk (1≤x1<x2<…<xk≤n) their positions in the string.

Note that in the optimal solution the sheep with the number m=⌈n2⌉ will not make moves. This can be proved by considering the optimal solution in which the sheep with the number m makes at least one move and come to the conclusion that this solution is not optimal. Consider sheep with numbers from i=1 to n. Then the final position of the i-th sheep will be xm−m+i, and the answer will be ∑i=1k|xi−(xm−m+i)|.

Solution1520F1 - Guess the K-th Zero (Easy version)

Authors: Supermagzzz, Stepavly

Tutorial1520F1 - Guess the K-th Zero (Easy version)This problem can be solved by binary search. Let's maintain a segment that is guaranteed to contain the k-th zero and gradually narrow it down.

Let the current segment be — [l,r] and we want to find k-th zero on it. Let's make a query on the half of the segment [l,m], where m=l+r2. If there are at least k zeros on the left half of the segment, then we go to the left segment and look for the k-th zero.

If there is only x<k zeros on the left half, then we go to the right segment and look for (k−x)-th zero.

We will spend logn queries, which is within the limits.

Solution1520F2 - Guess the K-th Zero (Hard version)

Authors: MikeMirzayanov

Tutorial1520F2 - Guess the K-th Zero (Hard version)In this problem, you can apply the same solution as in the previous one, but you need to remember the responses to the requests and not make the same requests several times.

Why does it work? Imagine a binary tree with a segment at each vertex, and its children — the left and right half of the segment. We will leave only those vertexes for which we made requests. It remains to show that there are no more than 6⋅104 such vertices.

First — the height of the tree is not more than 18. Let's understand what the maximum number of vertices can be in the tree. We will consider each level separately. If the level number x is less than logt≤14, then we can spend no more than x of vertices (since there are simply no more vertices). If the level number is from 15 to 18, then we can spend no more than t vertices, so each request uses only one vertex per level. By limiting the number of vertices in this way, we get that there are no more than 214−1+4⋅104=56383, which fits into the constraints.

Solution1520G - To Go Or Not To Go?

Authors: Supermagzzz, Stepavly, Aris

Tutorial1520G - To Go Or Not To Go?There is no point in using two transitions between portals, because if you want to go from portal A to portal B, and then from portal C to portal D, then you can immediately go from portal A to portal D for less.

Then there are two possible paths.

First — do not use portals. Here it is enough to find the shortest path between two points.

The second — use a single transition. Let's choose a portal from which we should teleport. Obviously, this is a portal with a minimum distance to it and the cost of the transition. Similarly, the portal in which we should teleport is selected.

Solution

Contest 2050 and Codeforces Round #718 (Div.1 + Div.2) Editorial

By xyz2606, 22 months ago, In English1517A - Sum of 2050First, we need to check whether n is the multiple of 2050. If n is not the multiple of 2050, the answer is always −1.

Then we can divide n by 2050, the problem now is how to represent n as the sum of powers of 10. So the answer is the sum of its digits in decimal representation.

1517B - Morning JoggingThe minimum sum is the sum of m smallest of all nm numbers.

To construct the answer, we can just mark these m smallest numbers and put them in m different columns. A possible way is that for each row, you can sort all numbers from small to large, and rotate the marked number in this row to unmarked columns.

For example,

1????

?23??

???45

1517C - Fillomino 2The answer is unique and always exists. There are two ways to construct the answer.

Construction 1: Start with the main diagonal. There is one cell (x,x) with number 1 on it. That cell must form a region by itself. For each cell (y,y) on the main diagonal that is above (x,x), the cell (y+1,y) belongs to the same region as (y,y). We write the number on (y,y) minus 1 on the cell (y+1,y) and make (y+1,y) belong to the same region as (y,y). For each cell (y,y) on the main diagonal that is below (x,x), the cell (y,y−1) belongs to the same region as (y,y). We write the number on (y,y) minus 1 on the cell (y,y−1) and make (y,y−1) belong to the same region as (y,y).

Then a permutation of 1,…,n−1 are written on the cells (2,1),(3,2),…,(n,n−1). We can continue this process on this subdiagonal. Then a oermutation of 1,2,…,n−2 will be written on the cells (3,1),(4,2),…,(n,n−2). Repeat until all cells have numbers written on them. Note that the numbers written on the cells are not the output. Put x for the region with size x after constructing the regions.

This construction proves that the solution always exists and is unique.

Construction 2: Construct the region for (1,1),(2,2),…,(n,n) in order. When starting at (i,i), we walk from (i,i) for x steps, where x is the number written on (i,i). For each step, if the cell to the left of your current cell is empty, we go to that cell and write x on it. Otherwise we go down and write x there.

We can prove that the second construction produces exactly the same answer as the first construction. They only differ in their orders of processing.

The regions are always paths.

1517D - Explorer SpaceSince the graph is bipartite, when k is odd, it is impossible to go back to the vertex after k steps.

Since the graph is undirected, we can always find a path with length k/2, walk along this path and return.

We can use dynamic programming to compute the shortest path from u with length k. dpu,k=min(u,v)∈E{dpv,k−1+wu,v}.

The time complexity is O(nmk).

1517E - Group PhotoThere can't be two i's such that ci−ci−1>2, or pi−pi−1 won't be non-increasing. And there can't be two i's such that pi−pi−1>2, or ci−ci−1 won't be non-decreasing. So for any 2≤i<m, ci−ci−1≤2, and for any 2≤i<k, pi−pi−1≤2. Then we can find out that there are only two possible patterns: PP...PCC...C or (C/P)CC...CPCPC...PCPP...P(C/P). You can calculate the first pattern in O(n) and calculate the second pattern in O(n) or O(nlogn) with two-pointers or divide-and-conquer.

1517F - ReunionLet B(u,r)={v|dis(u,v)≤r}. And a vertex is colored black iff the volunteer is not attend.

First, we enumerate r and count the number of ways that the answer is no larger than r.

That is equivalent to for all black vertices u, the union of B(u,r) will cover all vertices.

So a typical tree dp is to consider for a subtree, the depth of the deepest uncovered vertex, and how long it can extend (the most shallow black vertex whose neighbor can extend out from this subtree).

Here is an observation that if there is an uncovered vertex in the subtree, how long it can extend doesn't matter. The reason is this vertex needs to be covered by the vertex (v) from other subtrees, and v can extend further than one in this subtree.

So if there is an uncovered vertex in the subtree, we only care about the depth of the deepest uncovered one. Otherwise, we care about the depth of the most shallow black vertex. The state of this subtree is O(sizea) (actually is O(depa)).

Time complexity for each r is O(n2), and overall complexity is O(n3).

It is possible to optimize it to O(n2logn) further.

1517G - Starry Night CampingWe can label all the integer points in the plane as follow:

...2323...

...1010...

...2323...

...1010...

Where all the good points are labeled with 1. If we draw an edge between every adjacent points, all the forbidden patterns form all paths of length 4 with label 0-1-2-3. So we transform the problem to another problem: delete some points with smallest sum of value such that the remaining points doesn't contain a 0-1-2-3 path. It can be solved with a simple min-cut algorithm.

1517H - Fly Around the WorldConsider the DP idea: dp[i][x][y] represests whether there exists a sequence b1,…,bi satisfying all the constraints. (Constraints about bi+1,bi+2,… are ignored.) Then R(i)={(x,y)|dp[i][x][y]=true} is a region on the plane. We will prove that it is convex and then show that we can efficiently transform R(i) to R(i+1).

Initially, we can construct R(2). In R(2), x represents b2 and y represents b2−b1. The constraints are x−1≤b1=x−y≤x+1, x−2≤b2=x≤x+2, y−2≤y=b2−b1≤y+2. R(2) is the intersection of these half planes (so it is convex.)

Calculate R(i+1) by R(i): We should take the new constraints x−i+1≤bi+1≤x+i+1, y−i+1≤bi+1−bi≤y+i+1, z−i+1≤bi+1−bi−(bi−bi−1)≤z+i+1 into account. Let's consider the last constraint first and ignore the first two for now. If (bi+1−bi)−(bi−bi−1)=z, point (x,y) in R(i) (represents bi=x,bi−1=x−y since y=bi−bi−1) will become (bi+1,bi+1−bi)=(bi+(bi−bi−1)+((bi+1−bi)−(bi−bi−1)),(bi−bi−1)+((bi+1−bi)−(bi−bi−1)))=(x+y+z,y+z) in R(i+1) (since (bi+1−bi)−(bi−bi−1)=z). Thus, to transform R(i) to R(i+1), we simply apply the x←x+y tranformation and then move the region by the vector (z,z). x←x+y is a linear transformation. We call the new region R(i)(z).

Now we know that z is between z−i+1 and z+i+1. So we should take the union of all R(i)(z) for z∈[z−i+1,z+i+1].

Finally, we add the first two constraints about x and y back. These constraints correspond to cutting the region by vertical or horizontal half planes.

The answer is yes if and only if R(n) is nonempty.

By the process above, we can prove (inductively) that the region R(i) is always convex. For each i, we only add vertical and horizontal half planes. These half planes will cut some original edges of the convex polygon and add some new vertical or horizontal edges to it. The transformation x←x+y will change an edge with slope 1/k into an edge with slope 1/(k+1) (vertical edges becomes edges with slope 1/1). So we can also prove inductively that for any i, all the edges of R(i) have slope 0,∞ or 1/k for some integer k≤n. These edges can be written as Ax+By+C=0 for integral A,B and C.

We now know that for any i, the region R(i) is always convex and all edges have slope 0,∞ or 1/k for some integer k≤n. Next we describe how to implement the process described above efficiently.

We maintain two deques for the vertices on the upper and lower hull of the polygon. Vertical edges are included in the upper hull if they have minimum x coordinate (and lower hull if they have maximum x coordinate.) To cut the polygon by vertical or horizontal half planes, we simply pop some vertices at the end of the deques. (And possibly add some new vertices at the front or back of the deques.) To apply the transformation x←x+y, we apply it to all vertices of the convex polygon. Since we apply the same operation to all vertices, this can be done by tags in constant time (like the tags in segment trees). We will explain the precision issues later. Finally, to take the union of all R(i)(z), we move the upper hull by (z+i+1,z+i+1) and the lower hull by (z−i+1,z−i+1). (These are again transformations applied to all vertices in each deque. We use tags as well.) The new upper hull and new lower hull are not necessarily connected. If they are not, we connect their first and last vertices.

The time complexity is O(n) assuming each arithmetic operation costs constant time.

Codeforces round #717 editorial

By mohammedehab2002, 22 months ago, In English1516A - Tit for TatThe general approach to minimizing an array lexicographically is to try to make the first element as small as possible, then the second element, and so on. So greedily, in each operation, we'll pick the first non-zero element and subtract 1 from it, and we'll add that 1 to the very last element. You can make the implementation faster by doing as many operations as you can on the first non-zero element simultaneously, but it's not necessary.

Code link: https://pastebin.com/pBsychs2

1516B - AGAGA XOOORRRSo let's try to understand what the final array looks like in terms of the initial array. The best way to see this is to look at the process backwards. Basically, start with the final array, and keep replacing an element with the 2 elements that xor-ed down to it, until you get the initial array. You'll see that the first element turns into a prefix, the second element turns into a subarray that follows this prefix, and so on. Hence, the whole process of moving from the initial to the final array is like we divide the array into pieces, and then replace each piece with its xor, and we want these xors to be equal. A nice observation is: we need at most 3 pieces. That's because if we have 4 or more pieces, we can take 3 pieces and merge them into one. Its xor will be the same, but the total piece count will decrease by 2. Now, checking if you can divide it into 2 or 3 pieces is a simple task that can be done by bruteforce. You can iterate over the positions you'll split the array, and then check the xors are equal using a prefix-xor array or any other method you prefer.

Additional idea: for 2 pieces, you don't even need bruteforce. It's sufficient to check the xor of the whole array is 0. Hint to see this: write the bruteforce.

Code link: https://pastebin.com/tnLpW23C

Bonus task: can you find an O(n) solution? What if I tell you at least k elements have to remain instead of 2?

1516C - Baby Ehab Partitions AgainFirst of all, let's check if the array is already good. This can be done with knapsack dp. If it is, the answer is 0. If it isn't, I claim you can always remove one element to make it good, and here's how to find it:

Since the array can be partitioned, its sum is even. So if we remove an odd element, it will be odd, and there will be no way to partition it. If there's no odd element, then all elements are even. But then, you can divide all the elements by 2 without changing the answer. Why? Because a partitioning in the new array after dividing everything by 2 is a partitioning in the original array and vice versa. We just re-scaled everything. So, while all the elements are even, you can keep dividing by 2, until one of the elements becomes odd. Remove it and you're done. If you want the solution in one sentence, remove the element with the smallest possible least significant bit.

Alternatively, for a very similar reasoning, you can start by dividing the whole array by its gcd and remove any odd element (which must exist because the gcd is 1,) but I think this doesn't give as much insight ;)

Code link: https://pastebin.com/aiknVwkZ

1516D - CutLet's understand what "product=LCM" means. Let's look at any prime p. Then, the product operation adds up its exponent in all the numbers, while the LCM operation takes the maximum exponent. Hence, the only way they're equal is if every prime divides at most one number in the range. Another way to think about it is that every pair of numbers is coprime. Now, we have the following greedy algorithm: suppose we start at index l; we'll keep extending our first subrange while the condition (every pair of numbers is coprime) is satisfied. We clearly don't gain anything by stopping when we can extend, since every new element just comes with new restrictions. Once we're unable to extend our subrange, we'll start a new subrange, until we reach index r. Now, for every index l, let's define gol to be the first index that will make the condition break when we add it to the subrange. Then, our algorithm is equivalent to starting with an index cur=l, then replacing cur with gocur until we exceed index r. The number of steps it takes is our answer. We now have 2 subproblems to solve:

calculating golTo calculate gol, let's iterate over a from the end to the beginning. While at index l, let's iterate over the prime divisors of al. Then, for each prime, let's get the next element this prime divides. We can store that in an array that we update as we go. If we take the minimum across these occurrences, we'll get the next number that isn't coprime to l. Let's set gol to that number. However, what if 2 other elements, that don't include l, are the ones who aren't coprime? A clever way to get around this is to minimize gol with gol+1, since gol+1 covers all the elements coming after l.

counting the number of steps quicklyThis is a pretty standard problem solvable with the binary lifting technique. The idea is to perform many jumps at a time, instead of 1. Let's calculate dp[i][l]: the index we'll end up at if we keep replacing l with gol 2i times. Clearly, dp[i][l]=dp[i−1][dp[i−1][l]] since 2i−1+2i−1=2i. Now, to calculate how many steps it takes from index l to index r, let's iterate over the numbers from log(n) to 0. Let the current be i. If dp[i][l] is less than or equal to r, we can jump 2i steps at once, so we'll make l equal to dp[i][l] and add 2i to the answer. At the end, we'll make one more jump.

Code link: https://pastebin.com/Ng314Xc8

1516E - Baby Ehab Plays with PermutationsLet's think about the problem backwards. Let's try to count the number of permutations which need exactly j swaps to be sorted. To do this, I first need to refresh your mind (or maybe introduce you) to a greedy algorithm that does the minimum number of swaps to sort a permutation. Look at the last mismatch in the permutation, let it be at index i and pi=v. We'll look at where v is at in the permutation, and swap index i with that index so that v is in the correct position. Basically, we look at the last mismatch and correct it immediately. We can build a slow dp on this greedy algorithm: let dp[n][j] denote the number of permutations of length n which need j swaps to be sorted. If element n is in position n, we can just ignore it and focus on the first n−1 elements, so that moves us to dp[n−1][j]. If it isn't, then we'll swap the element at position n with wherever n is at so that n becomes in the right position, by the greedy algorithm. There are n−1 positions index n can be at, and after the swap, you can have an arbitrary permutation of length n−1 that needs to be sorted; that gives us n−1 ways to go to dp[n−1][j−1]. Combining, we get that dp[n][j]=dp[n−1][j]+(n−1)∗dp[n−1][j−1].

Next, notice that you don't have to do the minimum number of swaps in the original problem. You can swap 2 indices and swap them back. Also, it's well-known that you can either get to a permutation with an even number of swaps or an odd number, but never both (see this problem.) So now, after you calculate your dp, the number of permutations you can get to after j swaps is dp[n][j]+dp[n][j−2]+dp[n][j−4]+.... Now, let's solve for n≤109.

Sane solutionNotice that after k swaps, only 2k indices can move from their place, which is pretty small. That gives you a pretty intuitive idea: let's fix a length i and then a subset of length i that will move around. The number of ways to pick this subset is (ni ), and the number of ways to permute it so that we need j swaps is dp[i][j]. So we should just multiply them together and sum up, right? Wrong. The problem is that double counting will happen. For example, look at the sorted permutation. This way, you count it for every single subset when j=0, but you should only count it once. A really nice solution is: force every element in your subset to move from its position. How does this solve the double counting? Suppose 2 different subsets give you the same permutation; then, there must be an index in one and not in the other. But how can they give you the same permutation if that index moves in one and doesn't move in the other?

So to mend our solution, we need to create newdp[n][j] denoting the number of permutations of length n which need j swaps to be sorted, and every single element moves from its position (there's no pi=i.) How do we calculate it? One way is to do inclusion-exclusion on the dp we already have! Suppose I start with all permutations which need j swaps. Then, I fix one index, and I try to subtract the number of permutations which need j swaps to be sorted after that index is fixed. There are n ways to choose the index, and dp[n−1][j] permutations, so we subtract n∗dp[n−1][j]. But now permutations with 2 fixed points are excluded twice, so we'll include them, and so on and so forth. In general, we'll fix f indices in the permutation. There are (nf ) ways to pick them, and then there are dp[n−f][j] ways to pick the rest so that we need j swaps. Hence: newdp[n][j]= n∑f=0 (−1)f∗(nf )∗dp[n−f][j]. Phew!

If you have no idea what the hell I was talking about in the inclusion-exclusion part, try this problem first.

Code link: https://pastebin.com/3CzuGvtw

Crazy solutionLet [l;r] denote the set of the integers between l and r (inclusive.)

Let's try to calculate dp[2n] from dp[n]. To do that, we need to understand our dp a bit further. Recall that dp[n][j]=dp[n−1][j]+(n−1)∗dp[n−1][j−1]. Let's think about what happens as you go down the recurrence. When you're at index n, either you skip it and move to n−1, or you multiply by n−1. But you do that exactly j times, since j decreases every time you do it. So, this dp basically iterates over every subset of [0;n−1] of size j, takes its product, and sums up!

dp[n][j]= ∑s⊂[0;n−1],|s|=j s1∗s2…∗sjNow, let's use this new understanding to try and calculate dp[2n] from dp[n]. suppose I pick a subset of [0;2n−1]. Then, a part of it will be in [0;n−1] and a part will be in [n;2n−1]. I'll call the first part small and the second part big. So, to account for every subset of length j, take every subset of length j2 of the big elements, multiply it by a subset of length j−j2 of the small elements, and sum up. This is just normal polynomial multiplication!

Let big[n][j] denote the sum of the products of the subsets of length j of the big elements. That is:

big[n][j]= ∑s⊂[n;2n−1],|s|=j s1∗s2…∗sjThen, the polynomial multiplication between dp[n] and big[n] gives dp[2n]! How do we calculate big though?

Notice that every big element is a small element plus n. So we can instead pick a subset of the small elements and add n to each element in it. This transforms the formula to:

big[n][j]= ∑s⊂[0;n−1],|s|=j (s1+n)∗(s2+n)…∗(sj+n)Let's expand this summand. What will every term in the expansion look like? Well, it will be a subset of length l from our subset of length j, multiplied by nj−l. Now, let's think about this backwards. Instead of picking a subset of length j and then picking a subset of length l from it, let's pick the subset of length l first, and then see the number of ways to expand it into a subset of length j. Well, there are n−l elements left, and you should pick j−l elements from them, so there are (n−lj−l ) ways to expand. That gives use:

big[n][j]= j∑l=0 (n−lj−l )∗nj−l∗ ∑s⊂[0;n−1],|s|=l s1∗s2…∗slBut the interior sum is just dp[l]! Hurray! So we can finally calculate big[n][j] to be:

big[n][j]= j∑l=0 (n−lj−l )∗nj−l∗dp[l]And then polynomial multiplication with dp[n] itself would give dp[2n]. Since you can move to dp[n+1] and to dp[2n], you can reach any n you want in O(log(n)) iterations using its binary representation.

Code link: https://pastebin.com/yWgs3Ji6

Bonus task-ish: the above solutions can be made to work with k≤2000 with a bit of ugly implementation, but I don't know how to solve the problem with k≤105. Can anyone do it? The sane solution seems far off, and I don't know if it's possible to do the convolution from dp to big quickly in the crazy one.

 Tutorial of Codeforces Round #717 (Div. 2)

Codeforces round #716 editorial

By mohammedehab2002, 22 months ago, In English1514A - Perfectly Imperfect ArrayIf any element is not a perfect square, the answer is yes. Otherwise, the answer is no, because a2∗b2∗...=(a∗b∗...)2.

Code link: https://pastebin.com/s83sFt3G

1514B - AND 0, Sum BigLet's start with an array where every single bit in every single element is 1. It clearly doesn't have bitwise-and equal to 0, so for each bit, we need to turn it off (make it 0) in at least one of the elements. However, we can't turn it off in more than one element, since the sum would then decrease for no reason. So for every bit, we should choose exactly one element and turn it off there. Since there are k bits and n elements, the answer is just nk.

Code link: https://pastebin.com/0D8yL5WW

1514C - Product 1 Modulo NSo first observe that the subsequence can't contain any element that isn't coprime with n. Why? Because then its product won't be coprime with n, so when you take it modulo n, it can't be 1. In mathier words, gcd(prod mod n,n)=gcd(prod,n)≠1. Now, let's take all elements less than n and coprime with it, and let's look at their product modulo n; call it p. If p is 1, you can take all these elements. Otherwise, you should take them all except for p. It belongs to them because p is coprime with n, since gcd(p mod n,n)=gcd(p,n)=1 since all the elements in p are coprime with n.

Code link: https://pastebin.com/JnjZ3SQm

Bonus task: solve it for n≤1012.

1514D - Cut and StickSuppose the query-interval has length m. Let's call an element super-frequent if it occurs more than ⌈m2 ⌉ times in it, with frequency f. If there's no super-frequent element, then we can just put all the elements in 1 subsequence. Otherwise, we need the partitioning. Let's call the rest of the elements (other than the super-frequent one) good elements. One way to partition is to put all the m−f good elements with m−f+1 super-frequent elements; then, put every remaining occurrence of the super-frequent element in a subsequence on its own. The number of subsequences we need here is then 1+f−(m−f+1)=2∗f−m. There's no way to improve this, because: for every subsequence we add, the number of occurrences of the super-frequent element minus the number of good elements is at most 1, so by making it exactly 1 in each subsequence, we get an optimal construction. Now, the problem boils down to calculating f. Note that calculating the most frequent element in general is a well-known slow problem. It's usually solved with MO's algorithm in O(n√nlog(n)), maybe with a tricky optimization to O(n√n). However, notice that we only need the most frequent element if it occurs more than ⌈m2 ⌉ times. How can we use this fact?

Randomized solutionWe can pick ~40 random elements from our range to be candidates for the super-frequent element, then count their occurrences and maximize. If there's a super-frequent element, the probability it's not picked is at most 2−40, which is incredibly small.

To count the number of occurrences of an element in a range, we can carry for each element a vector containing all the positions it occurs in increasing order. Then, upper_bound(r)-lower_bound(l) gives us the number of occurrences in O(log(n)).

Code link: https://pastebin.com/APHEtfge

Deterministic solutionObserve that if a range has a super-frequent element, and we split it into 2 ranges, then this element must be super-frequent in one of them. Now suppose we create a segment tree where every node [l;r] returns an element in the range, and suppose every node merges the 2 elements returned by its children as follows: count their occurrences in [l;r] and pick whichever occurs more. In general, that doesn't return the most frequent element. However, if there's a super-frequent element, it must return it! That's because if there's a super-frequent element in [l;r], it must be super-frequent in one of its children, so by induction the segment tree works. The time complexity is O(nlog2(n)).

Code link: https://pastebin.com/qeGxT0W2

There are also tons of O(n√n) solutions that should pass if the operations are simple enough.

Bonus task: solve it in O(nlog(n)).

1514E - Baby Ehab's Hyper ApartmentThroughout the editorial, I'll call the first type of queries OneEdge and the second type ManyEdges.

The basic idea behind this problem is to find a few edges such that every path that could be traversed in your graph could be traversed using only these edges. With that motivation in mind, let's get started.

The first observation is: the graph has a hamiltonian path. To prove this, suppose you split the graph into 2 halves, each containing some of the nodes. Then, we'll proceed by induction. Suppose each half has a hamiltonian path. I'll describe a way to merge them into one path. First, let's look at the first node in each path and ask about the edge between them. Suppose it's directed from the first to the second one. Then, I'll start my new merged path with the first node, remove it, and repeat. This works because no matter which node follows it, it sends an edge out to it. This is best described by the following picture:

 

We start with the 2 hamiltonian paths we got by induction, then we query that red edge. We find that it's from the grey node to the white node. We then put our grey node as the start of the path and continue doing that with the rest of the nodes, and we don't care which node will follow it, because the edge is out from the black node either way!

If everything falls into place in your mind, you should recognize that this algorithm is merge sort. We just run merge sort on the nodes of the graph, using the comparator OneEdge. That gives you a hamiltonian path in nlog(n) queries.

Now that we have a hamiltonian path, every edge that goes forward in it is useless, since you can just walk down the path itself:

 

So let's focus on the edges going backwards. Suppose we iterate through the hamiltonian path from its end to its beginning, looking at the edges going back from the nodes we met. An edge going backwards from the current node is important only if it goes back further than any of the edges we've met so far. That's because we can take a (much less direct) route instead of this edge if it doesn't go so far back:

 

Now with a few more edges we can form all the paths! How do we get these edges? We can use 2 pointers. Let's iterate through the hamiltonian path from its end to its beginning, carrying a pointer p that tells us how far back the edges we met so far can go. To update p, let's ask ManyEdges from the node we're currently at, to the first p nodes in the hamiltonian path. While the answer is 1, we'll keep decreasing p. This algorithm calls ManyEdges 2n times, since every time we call it, it either returns 0 and the node we're at decreases, or it returns 1 and p decreases.

Code link: https://pastebin.com/RU1yA697

Bonus task: can you get the hamiltonian path using insertion sort instead?

Codeforces Round #715 Editorial

By Ari, history, 23 months ago, In EnglishNote: I can't figure out how to place the tutorials inside spoilers. If someone is familiar with how CF spoilers work and can help I would really appreciate it. For now, be warned that the tutorials are visible by default (but everything else isn't)

UPD: I figured out how to use spoilers! Also added implementations for all problems.

Thanks for participating in our contest!

1509A - Average Height

Author: KuroniFirst solve: Nutella3001 at 00:01:02

HintTutorial1509A - Average HeightFor two consecutive members to be non-photogenic, au and av must have different parity. Therefore, to maximize the number of photogenic pairs, or to minimize the number of non-photogenic pairs, we will order the members so that all members with even height are in front and all members with odd height are at the back.

Comments from the authorsImplementation

1509B - TMT Document

Author: AriFirst solve: blue at 00:04:51

HintTutorial1509B - TMT DocumentThere are many slightly different solutions, all based on some sort of greedy idea. Write n=3k for convenience. Obviously, the string must have k characters M and 2k characters T for the partition to be possible, so we can just discard all other cases.

Now, let's consider the first M character in the string. This must be part of some TMT subsequence, so we must choose a T character to its left to work as the first character of this subsequence. Which character should we choose? Well, it seems intuitive to match it with the first T character we find going from left to right - it is certainly not the right character of any sequence, and it seems like a good idea to assign it to the first M character since characters that are further to the right may be too far right to match with this character.

Continuing this idea, we come up with the following greedy algorithm: Take the first k T characters and use them as the first characters of the subsequences, matching them with the k M characters from left to right greedily. Similarly, take the last k T characters and match them with each M character from left to right greedily. If either of these steps fails, the partition is impossible. This can be formalized into the following observation, which is both easy to prove and gives a solution that is very easy to implement.

Claim. Let m1<m2<⋯<mk be the positions of the M characters and let t1<t2<⋯<t2k be the positions of the T characters. Then the partition exists if and only if ti<mi<ti+k for 1≤i≤k.

Proof. If the condition holds then we can just choose the k subsequences with indices (ti,mi,ti+k), so it is sufficient. To see that it's necessary, consider the first i M characters with indices m1,m2,…,mi, and consider the left T characters in the subsequence they're in. These are to the left of their corresponding M characters, and in particular they are to the left of the i-th M character. Thus there's at least i T characters to the left of the i-th M character, meaning ti<mi. The other inequality is proved similarly.

Comments from the authorsImplementation

1509C - The Sports Festival

Author: AriFirst solve: Dukkha at 00:05:32

Hint 1Hint 2Tutorial1509C - The Sports FestivalAssume that the array of speeds is sorted, i.e. s1≤s2≤⋯≤sn.

The key observation is that the last running can be assumed to be either s1 or sn. This is because if s1 and sn are both in the prefix of length i, then clearly di=sn−s1, which is the maximum possible value of any discrepancy. Similarly di+1,di+2,…,dn are all equal to sn−s1. This moving either s1 or sn (whichever appears last) to the very end of the array cannot possibly increase the sum of these discrepancies, since they already have the largest possible value.

If we repeat the previous observation, we deduce that for each i, the prefix of length i in an optimal solution forms a contiguous subarray of the sorted array. Therefore, we may solve the problem through dynamic programming: dp(l,r) represents the minimum possible answer if we solve for the subarray s[l…r]. Clearly dp(x,x)=0, and the transition is given by

dp(l,r)=sr−sl+min(dp(l+1,r),dp(l,r−1))Which corresponds to placing either the smallest or the largest element at the end of the sequence. The final answer is dp(1,n). This allows us to solve the problem in O(n2).

Comments from the authorsImplementation

1508A - Binary Literature

Author: AriFirst solve (Div. 2): traxex2 at 00:22:48First solve (Div. 1): tourist at 00:05:04

Hint 1Hint 2Hint 3Tutorial1508A - Binary LiteratureFirst solution

Let's focus on two bitstrings s and t. How can we get a short string that has them both as subsequences? Well, suppose both strings have a common subsequence of length L. Then we can include this subsequence as part of our string. Then we just place the remaining characters of both sequences in the correct positions between the characters of this common sequence, to make both strings a subsequence of the result. This saves us L characters compared to just concatenating s and t since the characters of the common subsequence only have to included once, i.e. this uses |s|+|t|−L characters.

Now, in our problem, all strings have a length of 2n, so this algorithm will use a total of 4n−L characters. This means if we can find two strings that have a common subsequence of length n, we can finish the problem. However, the usual algorithm for computing the longest common subsequence works in O(n2), which is unlikely to pass the time limit, so we have to construct this common subsequence more concretely.

The observation is that because each character is either 0 or 1, one of these characters must appear at least n times. Call such a character frequent. Now since each string has at least one frequent character, two of these frequent characters are equal. Considering these two strings and their frequent character we find a common subsequence of length n, equal to either 000…0 or 111…1.

Second solution

This solution uses a similar idea, in a way that is a bit easier to implement. Consider three pointers p1,p2,p3, pointing to a character in each string, and a string t representing our answer. These pointers will represent the prefixes of each string that we have represented in our answer. Initially, t is empty and p1=p2=p3=1 (here our strings are 1-indexed).

Now we will add characters to t one by one. At each step, consider the three characters pointed at by our three pointers. Since they are either 0 or 1, two of them are equal. Add this equal character to t, and advance the pointers that match this character by 1.

Continue this algorithm until one of the strings is completely contained in t, let's say s1. At this point, suppose t has k characters, and thus the pointers have advanced by at least 2k, since at least two of them advance on each step. We have exhausted the characters of s1, so we have advanced p1 by 2n, and the other two pointers have advanced 2k−2n, and thus one of them has advanced by at least k−n. Now just add the remaining characters of this string to t. There are at most 2n−(k−n)=3n−k of them, so in the end t has at most 3n characters.

Comments from the authorsImplementation

1508B - Almost Sorted

Author: Both of us!First solve (Div. 2): shenmadongdong.qaq at 00:29:52First solve (Div. 1): tourist at 00:08:19

Hint 1Hint 2Hint 3Tutorial1508B - Almost SortedFirst solution.

Let's first analyze the general structure of an almost sorted permutation. We know that when the sequence decreases, it must decrease by exactly 1. Thus, every decreasing subarray covers some consecutive range of values. Let's split the permutation into decreasing subarrays, each of them as large as possible. For example, we can split the almost sorted permutation [3,2,1,4,6,5,7] as [3,2,1],[4],[6,5],[7]. The main claim goes as follows.

Claim. Each almost sorted permutation is determined uniquely by the sequence of sizes of its maximal decreasing subarrays.

So for instance, in the previous example, the sequence of sizes 3,1,2,1 uniquely determines the permutation as [3,2,1,4,6,5,7]. This is because the last element ai of a decreasing block must be smaller than the first element ai+1 in the next block. Otherwise we either have ai+1=ai−1, in which case we should expand the previous block, or ai+1<ai−1, which is contradictory.

Now, this is basically enough to get a complete solution. Through some careful counting (which we will go into detail about later) we can show that there are 2n−1 almost sorted permutations of size n. Now notice that smaller sizes for the first block produce lexicographically smaller permutations (since a permutation whose first block has size m starts with m). Moreover, the remaining sequence after deleting the first block is almost sorted. This enables to do a recursive argument to find the permutation, by first choosing the correct size for the first block and then solving recursively for the remaining sequence. This works in O(nlogk).

Second solution.

But we can do better. Let's mark the positions in the array where a decreasing block ends with 0, and the other positions as 1. Notice that the last character is always 0, so we will ignore it and assign only the other n−1 characters. Thus our example permutation [3,2,1,4,6,5,7] becomes 110010 since the first, second, and third blocks end at positions 3, 4, and 6. By the first claim, we can recover the permutation from this sequence (which is also the proof of there being 2n−1 permutations of size n that we promised earlier!).

Now, we can read the assigned sequence as a binary number, for instance, the corresponding number is 1100102=25+24+21=50 for our trusty example. The point of doing this is the following:

Claim 2. The k-th almost sorted permutation in lexicographical order is assigned the number k−1.

To prove this it's actually enough to check that the number m+1 is assigned to a greater permutation than the number m. This can be done by looking at how the permutation changes when we add 1 to m, looking at the binary representation of m from right to left. We leave it to the reader to fill in the details of the proof, but here's a diagram showing the situation graphically (with height representing the values of the permutation).

Anyways, once we have proven this claim, we get a simple O(n+logk) solution by finding the binary representation of k and using it to reconstruct the blocks in O(n).

Comments from the authorsImplementation

1508C - Complete the MST

Author: KuroniFirst solve (Div. 2): deepspacewaifu at 01:42:36First solve (Div. 1): maroonrk at 00:33:17

Hint 1Hint 2Hint 3Hint 4Tutorial1508C - Complete the MSTCall x the XOR sum of the weights of all pre-assigned edges.

Lemma. All but one unassigned edges are assigned with 0, while the remaining unassigned edge is assigned with x.

Proof. Consider any assignment of unassigned edges. There are two cases on the minimum spanning tree:

The MST does not use all unassigned edges: We can assign one unused unassigned edge with x, while all other unassigned edges (including all used in the MST) are assigned with 0. This reduces the weight of the MST.The MST uses all unassigned edges: We can prove that the sum of weights of unassigned edges is at least x, and the equality can be achieved with the construction from the lemma. Intuitively, the XOR sum is an "uncarried" summation, and the construction from the lemma removes any digit carry.Let's DFS on the unassigned edges. It can happen that the unassigned edges may separate the graph into multiple components, and we might need to use some pre-assigned edges in our MST. I will divide the collection of pre-assigned edges into 3 types:

Edges that must be included in the MST: these are edges with smallest weights that connect the components after traversing through unassigned edges.Edges that cannot be included in the MST: these are edges that form cycles with smaller-weighted pre-assigned edges. In other words, these are edges that do not exist in the minimum spanning forest of the pre-assigned edges.Edges that are in neither of the previous types.For the unassigned edges, there are two cases:

The unassigned edges form at least a cycle: We can assign any edge on this cycle as x, the rest as 0, then build an MST using the 0-weighted edges with pre-assigned edges of type 1.The unassigned edges does not form a cycle. Suppose we build the tree using only unassigned edges and edges of type 1. Then any edge of type 3 can replace an unassigned edge in the tree. That is because the edges of type 3 must form a cycle with edges of type 1 and unassigned edges (else it would either be in type 1 or type 2). We can simply replace an unassigned edge in that cycle with this type 3 edge.Therefore, for this case, our solution is to first form the tree with all edges of type 1 and unassigned edge. Then, if the smallest weighted type 3 edge has weight <x, we can replace an unassigned edge with this edge; else, we keep the tree.

Comments from the authorsImplementation

1508D - Swap Pass

Author: AriFirst solve: ksun48 at 00:57:13

Hint 1Hint 2Hint 3Hint 4Tutorial1508D - Swap PassAs it turns out, it is always possible to find the required sequence, no matter the position of the points in the plane and the initial permutation.

It turns out that it's pretty hard to analyze even particular positions of the points, and it will be more convenient to start by analyzing particular permutations instead. To this effect, we will begin by doing two things:

Ignore every i such that initially ai=i. Since we'll prove that the sequence exists for any configuration anyway, they can't ever matter.Draw an arrow from point i to point ai for each i. This divides the points into a bunch of cycles.Now we can make the following observation:

Observation 1. If we have any cycle, we can get all the balls in that cycle to their correct position by choosing any member i in the cycle, and repeatedly swap passing between i and ai, without generating any intersections.

This allows us to solve the problem for any position of the points as long as the permutation has a single cycle. However, this will generally not be the case. We can hope to deal with this by making a second observation.

Observation 2. If we have any two distinct cycles and any two members u and v in those two cycles, then swap passing between u and v will merge both cycles.

By combining both observations we can come up with the following general idea to solve any case:

First, perform swaps between distinct cycles until all of the cycles merge into a single one.Then, move all the balls to their correct positions as described in the first observation.Now we just have to figure out how to perform these moves without having intersections between segments. It might be helpful to think about the case when the points are vertices of a convex polygon first since it simplifies the model without sacrificing too much of the geometry. Either way, we will describe only the general case.

Consider any point, which we will use as a "pivot" for the operations at the end. Now, sort all of the other points by the angle of the segment between them and the pivot point. Call the segments that join two consecutive points in the ordering border segments, and the segments between the pivot and the other points central segments. Now we will just merge all the cycles by using border segments and then move all the balls to their intended position by using central segments, this solves the problem.

However, there's one small special case that we might have to deal with depending on how we're thinking about the problem: If the pivot point we chose is on the convex hull of the set of points, then one of the border segments may actually intersect some other segments! Luckily, we can easily prove that this can't happen for more than one of the segments, so our plan still works. There are many different ways to deal with this case. From simplest to most complicated:

Always choose the bottom-most and left-most point as a pivot. This makes this potentially troublesome segment predictable, and also allows us to slightly simplify the angular sorting code.Discard the problematic segment by looking at which pair of consecutive points makes a clockwise turn instead of a counter-clockwise turn.Discard the problematic segment by brute-force intersecting each border segment with each central segment. This increases our complexity to O(n2), but this is still fine.Intentionally choose a pivot that is not on the convex hull and do something slightly different if the points are the vertices of a convex polygon.Regardless of how we choose to deal with it, we can now solve the problem with approximately 32n operations in the worst case, and a time complexity of either O(nlogn) or O(n2) depending on how we implement the solution.

Comments from the authorsImplementation

1508E - Tree Calendar

Author: KuroniFirst solve: ecnerwala at 01:02:26

Hint 1Hint 2Hint 3Hint 4Tutorial1508E - Tree CalendarFrom the structure, we see that until the end, the process is divided into n phases, where the i-th involves phase pushing value i from the root to the smallest-labeled leaf. Also in the following tutorial, I will use post-order and exit order, as well as pre-order and DFS order interchangeably.

Lemma 1. After finishing pushing i, labels 1 to i are at the post-order positions, and the remaining labels from i+1 to n form the pre-order of the remaining part of the tree offsetted by i.

Proof. There's a formal proof, but I think a better way is to show an illustration instead.

After pushing i, we see that all green labels (label from 1 to i) are at their post-order positions, while all red labels (labels from i+1 to n) are connected and form the pre-order of the red subtree, with an offset of i. Moreover, this suggests that while pushing i, the label of the root is i+1.

Lemma 2. On any day, the order of the values of the children of any node stays the same.

The proof will be left as an exercise for the reader, but a hint would be that for any node, a prefix of its children will be green nodes (nodes that have been pushed), the rest are red nodes (nodes that haven't been pushed). We can prove that the green nodes are ordered the same, the red nodes are ordered the same, and the green nodes are always less than the red nodes.

Lemma 3. Suppose we are pushing/have just finished pushing i. Then the number of days that have passed is the sum of heights of all labels from 1 to i.

Proof. All labels that have finished being pushed, or are being pushed, have all traversed from the root down to their current position, which means the number of days to push each of these labels is equal to the height of the node containing the label.

With the three lemmas, we can finally discuss the algorithm: First, we sort the children of each node by its value. Then we use this order to create the pre-order of the tree, and we can also figure out the current value that is being pushed (it is the value of the root minus 1). Call this value v. Knowing the current value being pushed, we first check if the current value is being pushed to the correct destination (i.e. check if the node with label v is an ancestor of the node with post-order v). Then, we can "revert" the pushing of v by swapping it back up the root, also taking to account the number of days. Finally, we check if values <v are in the post-order positions, and values that are ≥v form the pre-order shifted by v−1 of the remaining of the tree.

Complexity is O(nlogn).

Comments from the authorsImplementation

1508F - Optimal Encoding

Author: KuroniFirst solve: ecnerwala at 01:52:02 (The only contestant who solved this problem!)

Hint 1Hint 2Hint 3Hint 4Hint 5Hint 6Tutorial1508F - Optimal EncodingWe will first solve the problem for q-similar permutations only. Let's transform each of the q ranges into edges on a DAG we call G: for all ranges [li,ri], for all pairs of indices l≤x,y≤r such that ax<ay, we add an edge from x to y. We can easily see a permutation is q-similar iff it satisfies G. Now, our task is to remove edges from G such that the number of permutations that satisfy it stays the same.

Lemma 1. We can remove an edge (u,v) if and only if there is a path from u to v with length ≥2.

Proof. If there exists a path of length ≥2 between (u,v), then we can remove the edge (u,v) without having to worry about losing dependency between u and v. On the other hand, if there doesn't exist such a path, then the only path connecting u and v is via the edge (u,v) itself; removing that edge removes any dependency between u and v. When that is the case, we can easily create a permutation such that av=au+1, then we simply swap au and av to gain a permutation that does not satisfy the original DAG.

Let's return to our problem. For any element u, we consider the edges connecting u→v such that v>u a right edge of u; we define a left edge of u in a similar manner.

Lemma 2. There is at most one right edge of u.

Proof. Suppose there are two right edges of u, namely u→w′ and u→w (suppose w′<w). Because of our range construction, there must be a range that covers both u and w. This range must covers w′ too, therefore there is a path between w and w′, therefore we can remove either u→w or u→w′.

Therefore, there is at most one right edge u→ur. We can actually find this right edge: suppose [l,r] is a range such that l≤u≤r, and r is as large as possible. Then ur is the index between u and r such that aur>au and aur is as small as possible. We can prove similar results with the left edge of u (denoted as u→ul).

However, there will be cases when u→ur is actually not needed (I will call this phenomenon being hidden). What is the condition for u→ur to be hidden? That's when there's a path from u to ur with length ≥2! Suppose this path is in the format u→⋯→t→ur. We can prove that t<u: if t>u then that implies at>au but at<aur, which means the right edge of u is u→t instead. Because t<u, we can take the range [l,r] such that l≤ur≤r, l is as small as possible, and check if there exists an index t∈[l,u] such that au<at<aw. That concludes the solution for finding the optimal encoding for q-permutations. To recap:

Find left and right edges of all u.Check if the left/right edges of all u are hidden. If they are, remove them from the answer.Let's return to the original problem. For each range [li,ri], instead of adding an edge for every l≤x,y≤r to G, let's only add an edge between x′ and y′ such that ax′ and ay′ are adjacent values in the range. This doesn't change our answer because of lemma 1. Let's call these edges candidate edges.

Surprisingly, all of our previous observations hold, but this time on the set of candidate edges. Namely,

At any query, there is at most one right edge u→ur, which is one of the candidate edges.The right edge u→ur must satisfy that ur>u, aur<au and aur is the smallest such value in the range [u,r], where [l,r] is the range covering u with the largest r.u→ur is hidden if there exists a candidate edge u→t such that t<u, au<at<aur, and t∈[l,u] where [l,r] is the range covering ur with the smallest l. We call this edge u→t the destroyer of the edge u→ur.All of the above points holds for the left edge u→ul.Let's organize the candidate edges: for any edge u→v, if v>u, label u→v as a right candidate edge of u, else label u as a left candidate edge of u. Let's sort the right candidate edges of u by increasing ur, and sort the left candidate edges of u by decreasing ul.

Observation. The values of the right end of the right candidate edges are decreasing, i.e. if the right candidate edges of u are u→ur,1,u→ur,2,...,u→ur,k such that, ur,1<ur,2<⋯<ur,k, then aur,1>aur,2>⋯>aur,k. Similarly, if we sort the left candidate edges of u by decreasing index, then the values of the left end of these candidate edges are decreasing.

Using this observation, we can prove that if the destroyer of u→uri is u→ulj, and the destroyer of u→uri+1 is u→u→ul,k, then ul,j≥ul,k, or j≤k; we can also prove a similar result with the destroyers of left candidate edges. Therefore, we can use two pointers to figure out the destroyer for each left and right candidate edge of u.

For each right candidate edge [u→ur,i], let's see when this candidate edge is used in the optimal encoding:

The candidate edge is first activated when there exists a range covering [u,ur,i]. We call this timestamp t1.The candidate edge is hidden when there exists a range covering [ul,j,ur,i], where u→ul,j is the destroyer of u→ur,i. We call this timestamp t2.The candidate edge is deactivated when there exists a range covering [u,ur,i+1], where u→ur,i+1 is the right candidate edge after u→ur,i. We call this timestamp t3.For each candidate edge, we can find these timestamps using a Fenwick tree. With these three timestamps, we can figure out the range of time where each candidate edge is used (which is [t1,min(t2,t3))), and modify the answer accordingly.

Finally, let's find out how many candidate edges there are:

Lemma 3. The number of candidate edges is O(nq√).

Proof. Suppose for a range [l,r], we maintain edges u→v such that l≤u,v≤r, and the values au and av are adjacent in the range [l,r]. When we add/subtract one of the ends by 1, i.e. when we consider [l±1,r±1], the amount of edges that are modified between [l,r] and [l±1,r±1] is O(1) (for example, if we add another element, then we remove at most 1 old edge and add at most 2 new edges; similarly, when removing an element, we remove at most 2 old edges and add at most 1 new edge).

Therefore, consider Mo's algorithm on the given collection of ranges [li,ri], each candidate edge must appear during the process of iterating over the ranges, and the number of modification is O(nq√), therefore the number of candidate edges is O(nq√).

That concludes the solution to the full problem. To recap:

Find all candidate edges.Find the destroyer of all candidate edges.Find the range of timestamps where each candidate edge is used.The complexity is O(nq√logn).

Notes. In particular, your set candidate edges does not have to be exactly the edges connecting consecutive values between ranges; these candidate edges only need to satisfy 3 conditions:

All edges that are included in some optimal k-encoding must be present in the set of candidate edges.The observation is not violated, i.e. if we sort the left/right candidate edges of any node u by the other endpoint, then the value at the other endpoint must be sorted as well.The number of candidate edges must not be too large, at about O(nq√) edges.This is to loosen up the process of generating the candidate edges, since the naive Mo-and-set-of-values approach is incredibly expensive. My edge-generating approach involves using Mo with rollback to only allow deletion of values so I can maintain the sorted values with a linked list, and I also do not delete intermediary edges while iterating one range to another.

Comments from the authorsImplementation

Finally, here's some funny moments that happened while we were working on the round :)

Memes

Divide by Zero 2021 and Codeforces Round #714 (Div. 2) Editorial

By ajit, history, 23 months ago, In EnglishWe hope that you have enjoyed this round! Here is the sketch of solutions for the problems.

A. Array and PeaksProblem Setter: ajitEditorialist: ajitTutorial1513A - Array and PeaksThere are many ways to solve this problem. The key idea is we try to use the first k largest elements from n to n−k+1 to construct the k peaks. So try constructing the array like this: 1,n,2,n−1,3,n−2,...,n−k+1,k+1,k+2,...,n−k. For this answer to be possible n−k+1>k+1 which means 2⋅k<n. If this is not the case we output −1.

Implementation in C++B. AND SequencesProblem Setter: ajitEditorialist: ajitTutorial1513B - AND SequencesConsider an arbitrary sequence b1,b2,…,bn. First let us define the arrays AND_pref and AND_suf of length n where AND_prefi=b1&b2&…&bi and AND_sufi=bi&bi+1&…&bn .

According to the definition of good sequence:

AND_pref1=AND_suf2 which means b1=b2&b3&…&bn .

Now AND_pref2≤AND_pref1=AND_suf2≤AND_suf3. Also according to definition of good sequence, AND_pref2=AND_suf3. This means that b1=AND_pref2=AND_suf3. Similarly, for all i from 1 to n, we get AND_prefi=b1 and AND_sufi=b1.

Therefore for the sequence to be good, b1=bn and the bi must be a super mask of b1 for all i from 2 to n−1.

Initially, we have an array a1,a2,…,an. Let the minimum value among these elements be x. Let the number of elements that have the value of x be cnt.

In order to rearrange the elements of a1,a2,…,an to a good sequence, we need to have cnt≥2 and the remaining elements need to be a super mask of x. If we don't meet this criterion, then the answer is 0. Else the answer will be (cnt⋅(cnt−1)⋅(n−2)!)%(109+7).

The time complexity is O(n).

Implementation in C++C. Add OneProblem Setter: kalpitkEditorialist: dvshahTutorial1513C - Add OneWe can solve this problem using 1D dp.

Let dpi be defined as the length of the string after applying operation i-times to the number 10. Then,

dpi=2, ∀ i in [0,8]dpi=3, if i=9(The final number after applying 9 operations to the number 10 is 109.)

dpi=dpi−9+dpi−10, Otherwise.(length would be the sum of i−9 operations and i−10 operations.)

We can precalculate the above table until m (Note: 1≤m<2⋅105).Now for each test case, the final answer is:

ans=∑|s|i=1((m+(int)(s[i]−′0′)<10)?1:dpm−10+(int)(s[i]−′0′)), where s is n (in form of string).

Time Complexity O(m+t⋅|s|), where |s| is the number of digits in n.

Implementation in C++D. GCD and MSTProblem Setter: ajitEditorialist: ajitTutorial1513D - GCD and MSTWe will iterate from smallest to largest number like in krushkal's algorithm. By this, we will consider the edges with the smallest weight first.

Now, while iterating, we will assume the current value as the gcd we want to get, let's say g and we will go left and then right while going left/right, if gcd(new_element,g)=g, we will add an edge in the graph between corresponding positions of new_element and g. Also while adding edge we must keep in mind that we shouldn't create a cycle. If we are forming a cycle, we shouldn't add this edge and stop spanning in that direction. We can use a DSU to check this but in this particular problem, this is not required. We can simply check previously whether there is any edge connected to new_element. If so, we will add this edge and stop spanning further as any further entry forms a cycle (Think why this is so. Hint: This is because we are adding edges in segments kind of fashion).

Also, we need to stop when the current g we are considering is greater than the parameter p since we can connect the currently connected components by edges with weight p.

Thus the number of edges considered would be O(N), and then the overall complexity of finding MST would be O(NlogN) due to sorting.

Implementation in C++E. Cost EquilibriumProblem Setter: 7danEditorialist: kalpitkTutorial1513E - Cost Equilibriumlet S = ∑n−10(ai).

The first and foremost condition is that S%n=0, and the final values in the beautiful array will be equal to x=S/n.

Since a node cannot operate as both, a source and a sink, therefore:

Nodes with values>x can only be the source vertices.Nodes with values<x can only be the sink vertices.Nodes with values=x with not be used as a source or a sink.The given condition, minimumCost=maximumCost condition holds only when at least one of the below condition holds:

Number of source vertices are zero or one.Number of sink vertices are zero or one.All the source vertices are before the sink vertices in the permutation.All the source vertices are after the sink vertices in the permutation.f(i) denotes the factorial of i. Thus, the answer would be:

If the number of source or sink is less than or equal to one, we need to consider all the unique permutations.Ans=f(n)/(f(x1)∗f(x2)∗...) where x1,x2,… are frequencies of different values.

Else,Ans=2∗A∗B∗CA=(# ways arranging source nodes)=f(src)/(f(x1)∗f(x2)∗…) where x1,x2,… are frequencies of different values in source nodes.B=(# ways arranging sink nodes)=f(snk)/(f(x1)∗f(x2)∗…) where x1,x2,… are frequencies of different values in sink nodes.C=(# ways filling (n−src−snk) identical values in (src+snk+1) places) = Binomial(n,src+src).We have an additional factor of 2 to cover the two possibilities: all sources before all sinks, and all sources after all sinks.The overall complexity of the solution would be O(n).

Implementation in C++F. Swapping ProblemProblem Setter: 7danEditorialist: mtnshhTutorial1513F - Swapping ProblemLet's form 2 sets X and Y. X contains those indices i such that Ai < Bi and Y contains those indices i such that Ai > Bi.

We call a segment Li, Ri as Li=min(Ai,Bi) and Ri=max(Ai,Bii)Let break this Question into a series of observation:

Observation 1:

The answer will reduce by swapping two indexes i and j in B only if:

If an index i belongs to X and j belongs to Y.Segment i and j overlap.Observation 2:

Based on previous observation, we are now left with only a few cases. WLOG we can fix Ai and Bi, and see where our index j be located.

Bj≤Ai and Ai≤Aj≤BiBj≤Ai and Bi≤AjBj≥Ai and Ai≤Aj≤BiBj≥Ai and Bi≤AjObservation 3:

We can see that, in each of the cases our final answer changes by,

final_answer=original_answer−2∗overlap(Segmenti,Segmentj)So, the algorithm would like this:

final_answer=original_answer−2∗max(0,A,B)A=max(min(ri,prefix_Maxima(Y,li))−li) where (li,ri) is a member of X.

B=max(min(ri,prefix_Maxima(X,li))−li) where (li,ri) is a member of Y.

prefix_Maxima(P,q) gives the maximum value of r such that l<=q, where (l,r) is a member of P.

prefix_Maxima can be implemented using a map, segment tree, or two-pointer approach.

The overall complexity of the solution would be O(n*lg(n))

Codeforces Round #713 (Div. 3) Editorial

By Supermagzzz, history, 23 months ago, translation, In English1512A - Spy Detected!

Author: MikeMirzayanov

Tutorial1512A - Spy Detected!To find a number that differs from the rest of the numbers in the array, you need to iterate through the array, maintaining two pairs of numbers (x1,c1) and (x2,c2), where xi is a number from the array, ci is how many times the number xi occurs in the array.

Then, to get an answer, you need to find the position of the xi that occurs in the array exactly once (i.e. ci=1).

Solution1512B - Almost Rectangle

Author: MikeMirzayanov

Tutorial1512B - Almost Rectanglef two asterisks are in the same row, then it is enough to select any other row and place two asterisks in the same columns in it.

If two asterisks are in the same column, then you can do the same.

If none of the above conditions are met and the asterisks are at positions (x1,y1), (x2,y2), then you can place two more asterisks at positions (x1,y2), (x2,y1).

Solution1512C - A-B Palindrome

Author: MikeMirzayanov

Tutorial1512C - A-B PalindromeFirst, let's find such positions i (1≤i≤n) such that s[i]≠'?' (symbols in symmetric positions are uniquely determined):

If s[n−i+1]='?', then s[n−i+1]=s[i];If s[i]≠s[n−i+1], then at the end we will not get a palindrome in any way, so the answer is '-1'.Note that after such a replacement, the remaining characters '?' are split into pairs, except maybe the central one. If the center character is '?' then it is necessary to put the character '0' if a is odd, or '1' if b is odd (if neither a, nor b is odd, then the answer is '-1').

Now the remaining characters '?' are split into pairs (i.e. if s[i]='?', then s[n−i+1]='?'). This allows the remaining characters '0' and '1' to be replaced greedily:

If s[i]='?' and a>1, then s[i]=s[n−i+1]='0' and decrease a for 2;If s[i]='?' and b>1, then s[i]=s[n−i+1]='1' and decrease b for 2;Otherwise the answer is '-1'.Solution1512D - Corrupted Array

Author: MikeMirzayanov

Tutorial1512D - Corrupted ArrayWhat is the sum of all the elements in b? This is twice the sum of all the elements in a + x.

Denote by B the sum of all the elements of b. Let's iterate over which of the array elements was added as the sum of the elements a (let's denote, for a). Then, x = B−2⋅A. It remains to check that the element x is present in the array b, this can be done using a hash table or a binary search tree.

Solution1512E - Permutation by Sum

Author: MikeMirzayanov

Tutorial1512E - Permutation by SumIt is easy to show that if we choose k numbers from a permutation of length n, then the minimum sum of k numbers is k(k+1)2, the maximum sum is k(2n+1−k)2 and any sum between them is achievable (that is, you can choose exactly k numbers from n so that their sum is equal to the desired one).

This fact allows us to implement the following greedy solution:

Denote for low(k)=∑i=1ki=k(k+1)2, for high(n,k)=∑i=n−k+1ni=k(2n+1−k)2 and for k=r−l+1;We will consider the numbers i=n,n−1,…,1 and determine whether to put them in the segment [l,r] or not;If k>0, high(i,k)≥s and s−i≥low(k−1), then put the number i in the segment [l,r] , decrease s by i, decrease k by 1;Otherwise, we will not put the number i in the segment [l,r].In the end, if s=0, then we have chosen r−l+1 a number with the sum of s, so the remaining number can be arranged in any order. If at the end s>0, then there is no way to select r−l+1 a number from 1,2,…,n with the sum of s.

Solution1512F - Education

Author: sodafago

Tutorial1512F - EducationSince the array a does not decrease, if we want to get the position x at some point, it is best to get it as early as possible, because if we get it earlier, we will earn no less money.

Therefore, the solution looks like this — rise to some position and earn money on it for a laptop. Let's go through the number of the position and use simple formulas to calculate the number of days it takes to raise to this position and the number of days it takes to buy a laptop.

From all the options, choose the minimum one.

Solution1512G - Short Task

Author: MikeMirzayanov

Tutorial1512G - Short TaskNote that n≤d(n)≤107 (107 is the maximum value of c in the problem), so it is enough for every n=1..107 to calculate the value of d(n).

To calculate the value of d(n), you can use the sieve of Eratosthenes and get the solution for O(107log(107)).

Also, you can use the linear sieve of Eratosthenes to find the minimum divisor for each n=1..107 and use the multiplicativity of the function d(n):

d(a⋅b)=d(a)⋅d(b) if gcd(a,b)=1.Solution

Codeforces Round #712 Editorial

By Monogon, history, 23 months ago, In Englishomg hi!

I will add implementations soon.

UPD: Implementations are added

1504A - Дежавю

Tutorial1504A - Déjà VuIf s is the character 'a' repeated some number of times, there is no solution. Otherwise, I claim either 'a' + s or s + 'a' is a solution (or both).

Let's prove it. Assume for contradiction that 'a' + s and s + 'a' are both palindromes. Then the first and last characters of s are 'a'. Then the second and second to last characters of s are 'a'. Repeating this, we see that all characters of s are 'a', but we assumed we are not in this case. Therefore, the claim is true.

The solution is simply to check if 'a' + s and s + 'a' are palindromes and output the correct one. Complexity is O(n).

Implementation

1504B - Меняем биты

Tutorial1504B - Flip the BitsLet's call a prefix legal if it contains an equal number of 0 and 1 symbols. The key observation is that applying operations never changes which prefixes are legal. In fact, suppose we apply an operation to a prefix of length i, and consider a prefix of length j. We want to show that if j was legal before, it remains legal. And if it wasn't legal, it won't become legal.

If j<i, then all bits in the length j prefix are inverted. The numbers of 0's and 1's swap, so it cannot change whether they are equal, and hence it cannot change whether j is legal.If j≥i, then i/2 of the 0 symbols become 1 and i/2 of the 1 symbols become 0. So the numbers of both symbols do not change, so it cannot change whether j is legal.Using prefix sums, we can determine for each prefix whether it is legal.

Consider an index i. If i=n and an≠bn, then we must flip the length n prefix at some point. If i<n and ai=bi, ai+1≠bi+1, or ai≠bi, ai+1=bi+1, then we must flip the length i prefix at some point. If we flip precisely these prefixes in any order, it will transform a into b. So we should simply check that every prefix that must be flipped is legal.

Complexity is O(n).

Implementation

1504C - Сбалансируйте биты

Tutorial1504C - Balance the BitsAny balanced bracket sequence must begin with '(' and end with ')'. Therefore, a and b must agree in the first and last positions, so we require s1=sn=1 or a solution doesn't exist.

The total number of open brackets in a and b must be n, which is even. Each 1 bit in s creates an even number of open brackets and each 0 bit creates an odd number of open brackets. Therefore, there must be an even number of 0 bits, or a solution doesn't exist. Note that the number of 1 bits also must be even.

Assuming these conditions hold, let's construct a solution. Suppose there are k positions where si=1. We will make the first k2 positions open in both a and b, and we will make the last k2 positions closed in both a and b. Then, the 0 bits in s will alternate between which string gets the open bracket.

Implementation

1504D - 3-раскраска

Tutorial1504D - 3-ColoringImagine the grid is colored like a checkerboard with black and white squares. Then Bob's strategy is to put tokens 1 on white squares and tokens 2 on black squares as long as he is able. If he is unable, this means all squares of one color are filled, and he can start placing tokens 3 without making an invalid coloring. More specifically, this is his strategy:

If Alice chooses 1:If a black square is free, place a 2 there.Otherwise, place a 3 on a white cell.If Alice chooses 2:If a white square is free, place a 1 there.Otherwise, place a 3 on a black cell.If Alice chooses 3:If a white square is free, place a 1 there.Otherwise, place a 2 on a black cell.Implementation

1504E - Задача коммивояжёра

Tutorial1504E - Travelling Salesman ProblemLet's reindex the cities so they are in increasing order of beauty. Note that it doesn't matter which city we call the start: the trip will be a cycle visiting every city exactly once.

Let's rewrite the cost of a flight i→j asmax(ci,aj−ai)=ci+max(0,aj−ai−ci).Since we always need to leave each city exactly once, we can ignore the ci term from all flights and only try to minimize the sum of max(0,aj−ai−ci).

Note that a flight to a city of smaller beauty is always free in the adjusted cost. So all we need is a path from a1 to an, and the rest of the trip can be done for free. Also, any valid trip will contain a path from a1 to an, so the shortest path is optimal.

Solution 1

All we have to do is encode the graph without storing all edges explicitly, and we can simply run Dijkstra's algorithm to find the shortest path. Add the following edges:

ai→ai−1 with weight 0.i→j with weight 0, where j is the largest index with aj−ai−ci≤0. The index j can be found with binary search.i→j+1 with weight max(0,aj+1−ai−ci) where j is the same as before.Every edge in this new graph corresponds to an edge in the original graph, and every edge in the original graph corresponds to a path in the new graph with at most the same cost. So the distance from a1 to an is preserved.

Solution 2

A simpler solution is to compute for all i>1, the minimum possible cost of the first trip reaching ai or larger. It's easy to see that any path must have at least this cost, and we can construct a path of this cost since moving to smaller ai is free. It corresponds to the following summation.

∑i=2nmax(0,ai−maxj<i(aj+cj))Complexity is O(nlogn).

Implementation 1

Implementation 2

1504F - Переверните карты

Tutorial1504F - Flip the CardsSuppose there is a sorted deck where the i-th card has ci on the front and di on the back. That is, it looks like this:

c1<c2<⋯<cnd1>d2>⋯>dnThe values 1,…,n must appear in some prefix of ci and some suffix of di. That is, they must all appear on distinct cards. So, if two values between 1 and n appear on the same card, we should report there is no solution.

Now, we know that every card in the input has a value in [1,n] and a value in [n+1,2n]. Let f(k) denote the number matched with the value k. Let's split the cards into two sets. Set A will be the cards that will end with the smaller number on the front, and B is the set of cards ending with the smaller number on the back. In each set, as the smaller numbers increase, the larger numbers decrease. Therefore, it must be possible to decompose [f(1),…,f(n)] into two decreasing subsequences, or there is no solution.

To decompose an array into two decreasing subsequences, there is a standard greedy approach. Also, note that any decomposition of [f(1),…,f(n)] into two decreasing sequences corresponds to a solution. In fact, we can put all the cards of one subsequence in A and the rest in B, and it will create a sorted deck.

But how can we find the decomposition that corresponds to the minimum number of card flips? For every index i such that minj≤if(j)>maxj>if(j), let's add a divider between i and i+1. This splits the array [f(1),…,f(n)] into several segments. We can independently choose how to decompose each segment into two subsequences, and combining them is guaranteed to be a valid decomposition for the entire array. Also, there is a unique way to decompose each segment: the only choice is in which one we call the first subsequence. And so, we can independently choose for each segment the choice that requires the smallest number of flips.

Complexity is O(n).

Implementation

1503E - 2-раскраска

Tutorial1503E - 2-ColoringBefore counting, we should understand the structure of a stupid coloring.

First, both of the following cannot hold:

There exists a path of yellow cells from column 1 to column m.There exists a path of blue cells from row 1 to row n.In fact, if two such paths existed, they must have a cell in common, and it would have to be blue and yellow at the same time.

Without loss of generality, suppose statement 1 is false. Consider a yellow cell in the grid. All blue cells in its row must be to its left or right because they lie in one segment. So, each yellow cell either belongs to the connected component A of yellow cells touching the first column or the component B touching the last column.

There cannot be a column with one cell in A and another cell in B, otherwise the segment would connect the two components. And every column has at least one yellow cell, so there exists a number c (1≤c<m) such that A occupies the first c columns and B occupies the last m−c columns.

Let [lA,rA] be the segment of yellow cells in column c and [lB,rB] be the segment of yellow cells in column c+1. Since the segments do not overlap, we either have rA<lB or rB<lA. Without loss of generality, suppose rA<lB. The cells in A create a monotonically increasing path from (1,0) to (rA,c), then make a monotonically decreasing path from (rA,c−1) to (n,0). A similar structure happens for B.

The number of monotonic paths where we step right a times and up b times is counted by the binomial coefficient (a+ba). Now, if we fix rA and lB, we can count the number of stupid colorings with the product of 4 binomial coefficients. To make this fast enough, we can fix only rA and use a prefix sum to find the number of ways over all lB>rA.

To generalize from the assumption that rA<lB, we can multiply the answer by 2 since it's symmetric. To generalize from the assumption that statement 1 is false, we can also count the number of ways if n and m are swapped. But we should be careful about double counting the case where both statements 1 and 2 are false. This can be handled without too much trouble by simply requiring rA+1<lB for one of the two cases.

Complexity is O(max(n,m)2).

Implementation

1503F - Сбалансируйте карты

Tutorial1503F - Balance the CardsSuppose we have a deck of cards where the front and back are both balanced bracket sequences. Let's line the cards up horizontally and draw them as points. For each pair of matching brackets on the front and back, we will connect them with an edge. For matched brackets on the front, we add an edge as a semicircle lying above the points. And for matched brackets on the back, we add a similar edge below the points.

Since every point is incident to exactly two edges, this graph decomposes into cycles. Since the edges are non-intersecting, each cycle is a Jordan curve in the plane. Imagine the curve as a track, and a monorail makes one full trip clockwise around the track. Each edge turns the monorail clockwise or counterclockwise by 180 degrees. Since the overall effect must turn the monorail a full 360 degrees clockwise, there are two more clockwise edges than counterclockwise edges in the cycle. If a cycle has 2m edges, then there are m+1 clockwise edges and m−1 counterclockwise edges.

Now, in the actual problem we are given a shuffled deck of cards. If there exists a way to reorder them so that the front and back are both balanced, then we know the above property must hold. Even though the cards are shuffled, we still have enough information to construct the edges and distinguish two edges in the same cycle by orientation (clockwise and counterclockwise). If there are m+1 edges of one orientation, we should call them the clockwise edges. Otherwise if the number of edges of both orientations are invalid, we should report that no solution exists.

Now that we have restricted ourselves to the case where this important condition holds, we should construct a solution. We can do this by solving for all the cycles independently and concatenating them together.

Consider a cycle. Let's make a binary string describing the sequence of orientations, where 1 denotes a clockwise turn and 0 denotes a counterclockwise turn. Since there are m+1 clockwise turns, we can find two adjacent 1's in the string. For consistency, let's cyclically shift the string so that it begins and ends with 1, and we can consider the curve to begin at the leftmost point. Let's see how we can build the curve recursively. First, there is the base case where the string is 11. Clearly, we can build the curve with two points like this.

Base Case:

Now, suppose we have constructed a curve corresponding to 1s1 for some string s. We will hide the turns of s in the drawing, and just display it as a blue box. From this, we can build a curve corresponding to the string 10s11 as shown on the right. This requires us to add two new points and reverse the order of the points in the blue box.

Operation 1:

Similarly, if we have constructed a curve for 1s1, we can build the curve for 11s01.

Operation 2:

Suppose we have constructed the curves 1s1 and 1t1 for two strings s and t. The turns of s are displayed as a blue box, and the turns of t are displayed as a green box. Then we can build the curve 1st1 as shown on the right. We take the last point in the blue box visited by the curve, and replace it with the points in the green box, in the same order.

Operation 3:

It turns out that the base case and these three operations are enough to build any curve satisfying the required condition. We can do it recursively as follows.

If the string is 11, return the base case.If the string is 10s11 for some s, build the curve 1s1 and apply operation 1.If the string is 11s01 for some s, build the curve 1s1 and apply operation 2.Otherwise, there exist non-empty strings s and t so that the string is 1st1, and s contains the same number of 0's and 1's (and thus so does t). Recursively build the curves 1s1 and 1t1, and apply operation 3.How can we apply these operations efficiently? When constructing a curve, we only care about the list of points (ignoring the leftmost one) as they appear from left to right, and which points are visited immediately before and after the leftmost point by the curve. If we store the list in the form of a doubly linked list, the operations of reversing and inserting in the middle can be done in constant time.

To build it recursively, we also need an efficient way to find a splitting point in the case of 1st1. If we just scan from one endpoint maintaining a prefix sum (number of 1's minus number of 0's), the algorithm will take O(n2) time overall. Instead, we should scan from both endpoints in parallel, and stop when one of them finds a splitting point. If it splits into lengths k and m−k, then the time is given by the recurrenceT(m)=T(k)+T(m−k)+min(k,m−k)=O(mlogm).Complexity is O(nlogn).

There is also an O(n) solution. Scan the string s (ignoring the first and last 1) from left to right, maintaining a stack of linked lists. When the prefix sum (number of 1's minus number of 0's) increases in absolute value, we push the base case to the stack. When the prefix sum decreases in absolute value, we apply an operation 1 or 2 to the curve on the top of the stack, then merge the top two curves with operation 3.

Implementation

CodeCraft-21 and Codeforces Round #711 (Div. 2) Editorial

By ninja_28, history, 23 months ago, In English1498A - GCD SumVideo EditorialAuthor and Problemsetting: ninja_28Editorialist: sigma_g

HintCan you think of the simplest properties that relate a number and its sum of digits?

Hint 2Note that if X is a multiple of 3, then both X as well as the sum of digits of X are a multiple of 3! Can you put this property to use here?

Hint 3If X is a multiple of 3, then gcd-sum(X)≥3. Therefore, we are guaranteed that at least every third number will satisfy the constraints required by our problem (gcd-sum(X)>1).

SolutionTherefore, for the input n, we can simply check which one of n, n+1, and n+2 has its gcd-sum >1, and print the lowest of them.

Corner casesNote that you must take long long, as input integers exceed the range of int.

Moreover, simply outputting ceil((n/3)×3) is incorrect as some non-multiples of three may also may have gcd-sum >1, for example, 26.

C++ solutionPython solution1498B - Box FittingVideo EditorialAuthor and Editorialist: sigma_gProblemsetting: ninja_28

HintThere can exist multiple optimal packings for a given set of rectangles. However, all of them can always be rearranged to follow a specific pattern, based on the rectangles' sizes.

Hint 2Can you show that it is always possible to replace a set of consecutive small blocks with a single large block? (of same or larger size)

Solution summaryWe follow a greedy strategy:

Initialize height of box as 1.Initialize current layer size as W.Pick the largest available rectangle that can fit into the current layer, and place it there. Repeat until this layer cannot fit any more rectangles.If more rectangles remain, increment height by 1 and now repeat the last three steps. Else, output the current value of height.Solution implementationFirst count sort the given rectangles based on their widths. There can only be 20 distinct rectangle widths in the range [1,109], so the following works:

counts = [0 for w in range(0, 20)]for w in widths:    counts[log2(w)] += 1The solution can be implemented by iterating N times.

At each iteration, step through the counts array and take the largest available rectangle that can fit into the current space. If no rectangle was able to fit, increment height by 1 and reset box width to W.

This has complexity O(nlog(wmax)).

Another implementationIt is also possible to implement the solution with a multiset and upper_bound, for a complexity of O(nlog(n)).

Store all rectangle sizes in a multiset. At each iteration, find using upper_bound the largest rectangle that can fit into the current space we have, and fit it in. If no rectangle can fit in this space, reset the space to maximum, increment height, and repeat.

Proof of correctness - briefIt is always possible to replace several smaller blocks with a single larger block if it is available. Because all blocks are powers of two, it must so happen that smaller powers of two will sum to a larger power. Therefore, we can always place a larger block first if it can be placed there.

Proof of correctness - elaborateThis elaborate proof isn't actually required for solving the problem. The intuition in the brief proof is sufficient for solving the problem. This proof is for correctness purpose only.

Let's first note a property: if a1+…+an>a0, then there exists some i such that a1+…+ai=a0, when all ai are powers of 2 AND a1 to an is a non-increasing sequence (AND a1<=a0, of course). Why is this so? You can take an example and observe this intuitively, this is a common property of powers of two. For example, 4+2+2+1+1>8, but 4+2+2 (prefix) =8. Formally: if a1=a0, this property is trivially true. If a1<a0, we can splilt a0=2ka1 for some k into 2k parts and — by strong induction — claim this property holds.

Let us now compare some optimal solution and our greedy solution. Before comparing, we first sort all blocks in each layer of the optimal solution in decreasing order. This does not affect the final answer but helps in our comparison. This comparison goes from bottom to top, left to right. Let us look at the first point of difference: when the block placed by us (BG) is different from the block placed by the optimal solution (BO). There are three cases.

If BO>BG: this is impossible, as in our greedy solution, we are always placing the largest possible block. We wouldn't place BG in there if BO was also possible. If BO==BG: we have nothing to worry about (this isn't a point of difference)

If BO<BG: let us assume that the optimal solution places several consecutive small blocks, and not just one BO. Since the blocks are in decreasing order, none of them would be bigger than BG. Note that either all of these blocks will sum to less than BG or a prefix of them will be exactly equal to BG. In either case, we can swap them with one single large block BG (swapping with a BG which was placed in some higher layer in the optimal solution)

Hence, in the last case, we have shown that any optimal solution (an arrangement of blocks) can be rearranged such that each layer fits the largest possible block first. This is also what is done in our greedy strategy. Therefore, with this proof by rearrangement, we conclude that our greedy strategy gives the same minimum height as that of the optimal answer.

Alternate implementation with easier proofThere is a binary search method to solve this problem. We binary search for the minimum height required. Given a height h — how to check if it can fit all rectangles?

We first preprocess the given array to construct a new array ci = number of rectangles of width 1«i. The size of this array is < 20.

We iterate from largest width to smallest width. Let its width is wi. Then, we know that it fits only W/wi times in one layer. Therefore, with height h, the box can only fit in fi=h×(W/wi). So, we can say that if fi<ci, then this height is insufficient.

Therefore, we now know that for any i, if fi<ci, then the height is insufficient. Do we need more conditions to provably state that the given height is sufficient?

Yes! We also need to check if we can fit in the i-th block in combination with tthe i+1-th block. That is, when checking if the i-th block has enough space, we need to account for the space that has already been used by the i+1-th block. So, we need to update ci=ci+2×ci+1+4×ci+2….

Therefore, we only need to compute the suffix sum ci like so and then check the above conditions. Complexity is O(n+log(wmax)log(n)).

Does this solution work when block widths are not a power of two?As we understood in the proof, this solution only works when it's guaranteed that smaller blocks will always exactly sum to any larger block. Therefore, if the blocks are not powers of two, this guarantee does not hold.

The following counterexample suffices:

6 136 6 4 4 3 3As you can see here the smaller blocks are not guaranteed to sum to the larger block (no prefix of 4,3,3 sums to 6). Our greedy solution gives minimum height 3, but best possible minimum height is 2 (first layer: 6,4,3, second layer: 6,4,3)

C++ solutionPython solutionC++ solution - multisetC++ solution for easier proof1498C - Planar ReflectionsVideo EditorialAuthor, Problemsetter and Editorialist: sigma_g

Hint 1We can use dynamic programming to store the state of the simulation at a given time. Therefore, we can simulate the entire situation by reusing the dp states.

Solution ideaI will describe the most intuitive solution. Naturally, looking at the constraints as well as at the output that is required, we can store a 3-state dp: dp[n][k][2]. Here, dp[n][k][d] indicates the total number of particles (at the end of the simulation) when one particle of decay age k hits the n-th plane in the direction d. (d is either 0 or 1, and indicates the direction (left/right) in which the particle is going)

There can be two directions, N planes and maximum decay age is K. So, this dp requires 2×1000×1000×4 bytes ≈24MB which is well within our memory constraints.

Solution detailsHow to update the DP states? If k=1, the value of dp[n][1][d] for any n or d is obviously 1 (as no copies are produced).

So, let us consider a particle P with k>1. This particle P produces a copy P′ going in the opposite direction. We can count the number of particles produced by P′ as dp[n - 1][k - 1][1 - d], as it hits the previous plane with a smaller decay age and in the opposite direction. Moreover, the particle P itself hits the next plane and continues to produce more stuff. We can calculate its number of particles produced as dp[n + 1][k][d], as it hits the next plane with the same decay age and the same direction!

Finally, we can combine these two values to get the value of dp[n][k][d].

Implementation detailsWe can implement this is easily as a recursive dp with memoization. At each state, we only need to iterate in the correct order (in one case, from right to left, and in the other, from left to right), and update states as required. Look at the implementation for more details. The total complexity of this algorithm is O(nk)NoteObviously, there exist much better solutions which do not use a third state and are much sleaker. However, I wanted to describe the simplest idea required to solve the problem.

C++ solutionPython Iterative solution1498D - Bananas in a MicrowaveVideo EditorialAuthor: shash42Problemsetting and Editorialist: sigma_g

Brute force solutionWe have a brute force O(N⋅M2) solution.

At every timestep t, for each banana bi that has already been reached previously, apply this timestep's operation yt times on bi. For all the yt bananas reachable from bi, update their minimum reachability time if they hadn't been reached previously.

Why is this correct? Simply because we are simulating each possible step of the algorithm exactly as it is described. Therefore, we cannot get an answer that's better or worse than that of the optimal solution.

Optimizing the brute force: hintObserve if we can reduce our search space when we visit nodes that have already been visited previously.

Optimizing the brute force: hint 2Let us take an example. We have some timestep t,x,y=1,5,10. If we start visiting from k=10, we will visit k=15,20,…,55,60. Let us say that k=40 was an already visited state. Do we now need to continue visiting k=45,…,60 or can we stop our search here?

Optimizing the brute force: detailsWe can actually stop our search as soon as we reach a previouly visited node! Why is this so? This is because — within the same iteration — that already visited node will once again start its own search, and will hit all the points that we were going to hit, and some more!

For example, let us say we would reach points a,a⋅x,a⋅x2,…,a⋅xy−1. Now, assume that a⋅x5 had been previously reached, then it is better to stop at a⋅x5, as this node itself will reach a⋅x5,a⋅x6,…,a⋅xy−2,a⋅xy−1,a⋅xy,…,a⋅x5+y−1. Note the latter range includes as a prefix the entire remaining suffix of the former range! Therefore, in this approach, nodes that would have been visited, will eventually be visited, and get assigned the minimum timestamp.

Optimized solution implementationWe can implement the optimized solution by simply adding an extra if already_visited[k]: break to our inner loop. Yup, really, that's all it takes to solve this question!

Complexity analysis: We can show that each node is visited at most twice: an unvisited node is reached atmost once, whereas a visited node is reached atmost twice (once during the main loop and once when searching from the immediately previous visited node) There are N iterations, and in each iteration, each of the M nodes is visited at most twice. Therefore, the total complexity is O(2NM).

Common mistakesInteger overflows: x′ does not fit in integer rangeOut of bounds access: simulating the yt steps of the algorithm even when k exceeds M prematurelyC++ solutionPython solution1498E - Two HousesAuthor, Problemsetting and Editorialist: dixitgarg

DescriptionIn this problem we have to output two nodes a and b such that there is a path from a to b and b to a and the absolute value of the difference of the indegree (|ka−kb|) should be maximum. First of all, let us think of bireachability only i.e how to find two nodes a and b such that they are both reachable from each other? How can we verify this from the judge? Because if we ask "? a b" i.e whether there is a path from a to b or not, then if the judge answers "Yes", we can't ask further queries. So we have to ask queries for those pairs (a,b) for which we are sure that there is a path from b to a. So how to ensure whether there is a path from b to a or not?

Hint1The answer lies in the fact that the given graph is not an ordinary graph, it is a special one. For every pair of vertices in this graph, there is a directed edge. So this type of graph has some interesting properties which we are going to see now.

Image how the compressed SCC of the graph will look like. For every pair of nodes of compressed SCC, there will be an edge, so it will have exactly one source, one sink and there would be only one possible topological sorting of this compressed SCC.

Proof of unique topological sortingSince there is an edge between every pair of nodes, for every pair of nodes in the compresses SCC also, there would be an edge. And we know that if there is an edge between node a to node b, then node a comes before node b in the topological sort. So for every pair of nodes of compressed SCC, we know which node would come first in the topological sorting, so it would result in a unique topological sorting.

Hint2Now we'll see one interesting and important property of this graph.

Property: Consider two consecutive strongly connected components in the topological sorting, then all nodes present in the left component will have indegree strictly less than all nodes present in the right component. Here left denotes lower enumeration in the topological sorting.

ProofConsider two nodes u and v from the left component and right component respectively. Since the contribution to the indegree from the nodes which don't lie in these two components would be the same for both u and v (because u and v lie in adjacent components), we are ignoring it as we have to just compare their values. If we consider all the edges between the nodes of the left component and the right component, then all of them would be directed from the node in the left component to the node in the right component. So the node v would have minimum indegree of SizeofLeftComponent. The node u would have the maximum indegree of SizeofLeftComponent−1. This is because there is no edge directed from the right component to the node u and the maximum indegree will be when all other nodes in the left component have an edge directed towards node u. In that case, it would be SizeofLeftComponent−1. So the indegree of u is strictly less than the indegree of v. Since u and v are arbitrary nodes, it is true for all pairs of nodes.

Hint3Using the above property we can argue that if indegree of node a is greater than the indegree of node b, then node a is reachable from node b. Because either node a lies in the same SCC or to the SCC of higher enumeration in topological sorting. In both cases a is reachable from b.

So we can store all pairs of nodes (a,b),1≤a≤n,1≤b≤n,a<b in an array and sort it according to decreasing order of absolute value of difference of indegrees i.e |ka−kb|. And if we pick a pair, let it be (a,b) and indegree[b]>indegree[a], then we are sure that b is reachable from a so we need to check whether a is reachable from b or not, so we ask "? b a" and if the judge responds by "Yes", then it means both a and b are reachable from each other. Since we were iterating in the decreasing order of |ka−kb|, we get the optimal answer. If the judge never outputs "Yes" in the whole process, then there is no pair of nodes that are reachable from each other. So we will output "? 0 0"Overall Complexity : O(n2log2n)C++ solutionPython solution1498F - Christmas GameAuthor: nikhil_cProblemsetting and editorialist: sigma_g

How do we solve a standard Nim game on arrays?By the Sprague-Grundy theorem, we know that the current player has a winning strategy if a1⊕a2⊕…⊕an (xorsum of sizes of the existing piles) is non-zero. For a proof, read details on CP-algorithms.

How to solve tree nim game for one rooting if K = 1: classifying odd/even stepsLet us classify nodes into odd or even depending on their depth relative to the root. Note that even steps do not affect the game state. Let us prove how:

Let us say it's Alice's turn. If Alice moves some coins from an even step to an odd step, then Bob can move exactly those same coins from that odd step back to an even step. After this transition, once again it's Alice's move. In fact, we realize that Bob can "revert" every even->odd move by Alice.

Therefore, if Alice wants to win, she has to play at least one odd->even move. Moves that go from even->odd do not affect the game state at all, as the other player can always play another move that reverts them. Therefore, we can say that any coins present on even steps will not change the game state.

How to solve tree nim game for one rooting if K = 1: how bad are even stepsLet us now analyze what happens if some coins move from the odd steps to even steps. We know that any coins on even nodes will not contribute to the game state. In fact, we realize that it does not matter whether these coins were present on the even nodes before the game started or whether they came by on the even nodes during the game. Once they are on an even step, they no longer contribute to the game state.

Hence, we can conclude that moving a coin from odd step to an even step is as good as taking a coin from the odd step and throwing it away.

Reducing tree nim game to linear array: the stair case nimAs we can see, we have effectively reduced the Nim game on tree to a linear nim game where only the odd positioned nodes determine the winning strategy. This is known as the staircase nim. The result is the following: the current player has a winning strategy if xorsum of all values at the odd steps is non-zero.

Extending to general KIn general K, we can extend this idea to: parity of d′=⌊dK⌋ where d is the depth of this node (zero-indexed). All nodes — such that d′ is odd for them — will contribute to the final xorsum. Take a moment to digest this.

How to calculate these xors? At each node x, we store a vector of size D(n)=2⋅K where D(n)i is the xorsum of all nodes having their depth = i — relative to node x — in the subtree of node n.

Calculating the answer for all rootsHow to propagate these values in a DFS? We know that the nodes at depth i is at depth i + 1 for my child nodes. So, we can simply cycle through them and update the values. Check the implementation for details.

C++ solutionPython solution

Codeforces Round #710 (Div. 3) Editorial

By Stepavly, 23 months ago, translation, In English1506A - Strange Table

Problem author: sodafago

Editorial1506A - Strange TableTo find the cell number in a different numbering, you can find (r,c) coordinates of the cell with the number x in the numbering "by columns":

r=((x−1)modr)+1, where amodb is the remainder of dividing the number a by the number b;c=⌈xn⌉, where ⌈ab⌉ is the division of the number a to the number b rounded up.Then, the cell number in numbering "by lines" will be equal to (r−1)∗m+c.

Solution1506B - Partial Replacement

Problem author: MikeMirzayanov

Editorial1506B - Partial ReplacementTo solve this problem, you can use the dynamic programming method or the greedy algorithm. Let's describe the greedy solution.

Until we get to the last character '*' we will do the following:

being in position i, find the maximum j, such that sj='*' and j−i≤k, and move to position j.Since we make the longest move on each turn, we will make the minimum number of substitutions.

Solution1506C - Double-ended Strings

Problem author: MikeMirzayanov

Editorial1506C - Double-ended StringsRegarding to the small constraints, in this problem you could iterate over how many characters were removed by each type of operation. If l characters at the beginning and x characters at the end are removed from the string s, then the substring s[l+1,n−x] remains, where n — is the length of the string s.

There is also a fast solution to this problem using dynamic programming.

Solution1506D - Epic Transformation

Problem author: MikeMirzayanov

Editorial1506D - Epic TransformationLet's replace each character with the number of its occurrences in the string. Then each operation — take two non-zero numbers and subtract one from them. In the end, we will have only one non-zero number left, and we want to minimize it. We can say that we want to minimize the maximum number after applying all the operations, which means we want to minimize the maximum number at each step.

We get the following greedy solution — each time we take two characters with maximal occurrences number and delete them.

Solution1506E - Restoring the Permutation

Problem author: MikeMirzayanov

Editorial1506E - Restoring the PermutationIf we want to build a minimal lexicographic permutation, we need to build it from left to right by adding the smallest possible element. If q[i]=q[i−1], so the new number must not be greater than all the previous ones, and if q[i]>q[i−1], then necessarily a[i]=q[i]. q[i]<q[i−1] does not happen, since q[i] — is the maximum element among the first i elements.

We get a greedy solution if q[i]>q[i−1], then a[i]=q[i], otherwise we put the minimum character that has not yet occurred in the permutation.

Solution1506F - Triangular Paths

Problem author: MikeMirzayanov, Stepavly, Supermagzzz

Editorial1506F - Triangular PathsSince all edges are directed downward, there is only one way to visit all n points is to visit the points in ascending order of the layer number. Let's sort the points in order of increasing layer.

It is easy to see that the cost of the entire path is equal to the sum of the cost of paths between adjacent points. Let's learn how to calculate the cost of a path between two points (r1,c1) and (r2,c2):

If r1−c1=r2−c2, then if (r1+c1) is even, then the cost is r2−r1, otherwise the cost is 0;Otherwise, move the point (r2,c2) to (r3,c3)=(r2−r1+1,c2−c1+1) and find the cost of the path (1,1)→(r3,c3) with different criteria for the activation of the edges;If (r1+c1) is even then the cost is ⌊r3−c32⌋;Otherwise, the cost is ⌈r3−c32⌉;Solution1506G - Maximize the Remaining String

Problem author: MikeMirzayanov

Editorial1506G - Maximize the Remaining StringHow can you check if you can perform such a sequence of operations on the string s to get the string t? Note that each time we delete an arbitrary character that is repeated at least two times, so t must be a subsequence of the string s and have the same character set as the string s.

We will consequently build the resulting string t, adding characters to the end. To check if there is such a sequence of operations that turns the string s into the string tc? (a string that first contains the characters of the string t, then the character c, and then some unknown characters), it is enough to do the following:

Find the minimum index i such that t is included in s[1..i] as a subsequence;Find the minimum index j (i<j) such that sj=c;Then the substring s[j+1..n] must contain all characters that are in the string s, but which are not in the string tc.Let's denote a function that checks the criterion above as can(t).

Having received the verification criterion, the following algorithm can be made:

Initially t is an empty string;While there is a character in the string s that is not in the string t, we will find the maximum character c not contained in t, but contained in s, for which can(tc)=true and add it to the end of the string t.Since at each step we take the maximum symbol for which the criterion is met, the resulting string t will be the lexicographically maximum.

Solution

Codeforces Round #709 / Technocup 2021 Final Round — Unofficial Editorial

By Geothermal, history, 23 months ago, In EnglishAs the editorial for round #709 has yet to be released, I thought I'd write up and post my solutions to the problems (with the exception of Div. 1 F). My code may not be especially useful, since it's a bit messier than necessary in some cases, but I'm hoping that the written explanations will be fairly helpful. Feel free to comment if you have any questions!

2A — Prison BreakBy simply playing around with a few small test cases, you might guess that the answer is always equal to ab. This intuition is correct; let's prove it formally.

Consider a graph with ab+1 vertices including one vertex representing each cell of the prison, one vertex representing the outside world, and an edge for each wall of the prison connecting the two vertices on either side of the wall. Then, observe that a set of walls we can remove such that the outside world is accessible from every cell is equivalent to a set of edges that spans our graph (as if every cell is reachable from the outside world, then all cells must be in the same connected component). In particular, a minimal set of walls we can remove is equivalent to a spanning tree of our graph, and since our graph has ab+1 vertices, its spanning trees have ab edges.

Consequentially, we can simply output ab.

Time Complexity: O(1) per test case. Click here for my solution.

2B — Restore ModuloLet di=ai+1−ai. The key observation is that c must be congruent to di modulo m for all i. Moreover, note that c cannot be congruent to both x and y modulo m, if x and y are both nonnegative or if they are both negative. Consequentially, if di takes on multiple different positive values or multiple different negative values, the answer is no.

Now, let's say di takes on at most one positive value and at most one negative value. We do casework.

First, suppose di takes no positive values and no negative values. Clearly, this occurs only when n=1, at which point m can be arbitrarily large and the answer is zero.

Second, suppose di takes on a positive value but no negative values. Then, m can take any value greater than an, while c=di for all i. Therefore, since m is unbounded, the answer to the problem is zero.

Third, suppose di takes on a negative value but no positive values. Then, m can take any value greater than a1 with c=m−di for all i. Therefore, m is unbounded, so the answer to the problem is zero.

Finally, suppose di takes on a positive value and a negative value. Let the positive value be x and the negative value be y. Then, since di=x=ymodm, we must have x−y=0modm. Therefore, m cannot be larger than x−y. We can then verify that x−y is a valid choice of m with c=x, giving us our desired answer.

Having addressed every case, we're finished here.

Time Complexity: O(n) per test case. Click here for my solution.

2C/1A — Basic DiplomacyInitially, let's pick fi1 as our teammate on day i, for all i. (In other words, we choose the first available friend from the given list on each day.) Obviously, this may not provide a valid set of selections, as some friend may be chosen more than ⌈m2⌉ times.

Note that because 2⌈m2⌉≥m, it is impossible for two friends to both be chosen more than ⌈m2⌉ times. If no friend is chosen this many times, we can simply output our initial selections and be done. Otherwise, there must be exactly one friend x who is chosen more than ⌈m2⌉ times.

We give a greedy algorithm that will turn this into a valid set of selections, if doing so is possible. Iterate over all days once again. If friend x is chosen on day i and at least two friends are available on this day, replace friend x with fi2 in our selections. Terminate the algorithm once we've iterated over all the days or friend x no longer appears more than ⌈m2⌉ times.

We conclude by proving that this algorithm is optimal. We clearly see that this algorithm will ensure that friend x appears at most ⌈m2⌉ times unless there are more than ⌈m2⌉ days on which only friend x can be chosen, in which case it is impossible to choose friend x at most ⌈m2⌉ times, and the answer is no.

Then, we note that this algorithm will never lead to a different friend being chosen more than ⌈m2⌉ times. Suppose for contradiction that this algorithm causes friend y to be chosen more than ⌈m2⌉ times. Then, immediately before this occurs, friend y must have been chosen exactly ⌈m2⌉, while friend x must have been chosen more than ⌈m2⌉ times. However, the sum of these two values must then be greater than m, which is impossible since we choose only m friends in total, providing our desired contradiction.

Therefore, if it is possible for friend x to be chosen at most ⌈m2⌉ times, this algorithm will ensure that this happens, and it will never cause another friend to be chosen more than ⌈m2⌉ times. Therefore, if a solution exists, this algorithm will find it, so it is optimal, as desired.

Time Complexity: O(n+m+∑k) per test case. Click here for my solution.

2D/1B — PlaylistWe maintain two sets. First, we maintain a set containing all songs that have not been removed from the playlist. (We'll refer to this as set one.) Then, we maintain a set containing all songs such that the GCD of their genre with the song of the previous song in the current playlist is equal to 1. (We'll refer to this as set two.) Both of these sets can be initialized efficiently using the initial array.

Then, maintain the index nxt of the next song we must listen to. While set two is non-empty, the next song we must remove from the playlist is the next element of set two after nxt. Call this song rem. Then, we must remove rem from both sets. Afterwards, we must update set two. The trick here is that we only need to update one element of set two with each removal: we only need to update whether the next element in set one after rem is in set two, which occurs if and only if it has GCD 1 with the previous element in set one.

We repeat this process until set two is empty. It will then give us a complete list of all the songs that must be removed from the playlist, in the order in which we remove them.

Time Complexity: O(nlogn) per test case. Click here for my solution.

2E/1C — Skyline PhotoWe'll need a bit of heavy machinery to solve this problem. We'll maintain a segment tree of pairs (dpi,vali) that allows us to perform the following operations: - Set the value of dpi for some i. - Set the value of vali to some fixed value for all i in a range. - Find the maximum value of dpi+vali over all i in a given range.

Now, let's actually define these variables. We'll iterate over the buildings in reverse order. Let dpi be the maximum beauty of a set of photos covering buildings i through n. For simplicity, define dpn+1 to be zero. Then, we'll maintain vali such that as we iterate through building j, we have that vali is the beauty of the shortest building from i to j−1. Note that vali is then the beauty of a photo consisting of buildings i through j−1. The last piece of machinery we'll need is a monotonic stack, which will contain a series of buildings in decreasing order (from the bottom) of position and increasing order of height. We'll use this to find the next building shorter than each building we process.

Let's begin iterating over the buildings. When we reach a building, pop all taller buildings from the stack. Once we're finished, the building on top of the stack will be the next building shorter than i. Let this building have position j. Then, update valk to bi over the interval [i+1,j]. Finally, let dpi be the maximum value of dpj+valj over the interval [i+1,n+1]. Each choice of j accounts for the case in which our first photo contains buildings i through j−1.

After iterating over all our buildings, our answer is dp1.

Time Complexity: O(nlogn). Click here for my solution.

2F/1D — Useful EdgesLet's start with some precomputation. First, using Floyd-Warshall, let's compute the shortest paths between all pairs of vertices. Let the shortest path from i to j have length dij. Then, let's compute an array Lij representing the maximum length of a path from vertex i to vertex j such that this path can be extended to form a path satisfying one of our conditions (u,v,l). We initialize this array such that Luv=l for all queries (u,v,l). Then, observe that for all i,j, and k, we have Lij≥Lik−Djk, since a path from i to j can be part of a valid path from i to k if it can be extended using the shortest possible path from j to k to reach a length less than Lik. We can therefore compute the final array L using another application of Floyd-Warshall, taking the edges to have negative length.

Now, let's find the useful edges. Iterate over all root vertices r. Then, iterate over each edge (u,v), and let this edge have length x. Then, if Diu+x≤Liv or Div+x≤Liu, the edge (u,v) can be marked as useful. In the first case, Diu+x is the minimum length of a path starting at i and using the edge in the direction from u to v to finally reach v, and we know from our computation above that Liv is the maximum length of a path starting at i and ending at v such that this path can be extended to satisfy one of our queries. The second case proceeds similarly.

Once we've finished this process, we can output the list of valid edges.

Time Complexity: O(n3+nm+q). Click here for my solution.

1E — VabankLet's start with an observation. Let's let our account balance equal B, and let H be the highest query we've made so far without exceeding the limit. Then, we should never make a query greater than max(B,H), as we'll go bankrupt if M is between max(B,H) and our query.

Consequentially, we should clearly start by querying 1. Moreover, this observation motivates us to increase H as quickly as possible, both to bound our answer and to maximize our ability to increase our account balance quickly. Therefore, let's begin by querying 1,2,4,⋯ until one of these values exceeds M or until we would need to query a value greater than 1014. These are the maximum values we can query at any given time, since each query is equal to our current balance, which is greater than the highest previous query we've made. Since log21014≈46.5, this will take at most 47 queries.

Now, we've bounded the answer in a range of the form [2k,2k+1−1]. At this point, we might be tempted to binary search for M. Suppose at any given time that we've bounded M in the range [lo,hi]. Then, we might query lo until our balance exceeds lo+hi2, at which point we query lo+hi2 and update our range based on whether this query is successful. However, this is not efficient enough. If all queries of this form fail, then we take about log21014 of these queries, and we must also query lo at least once for each of these queries (in some cases, twice) in order to ensure our balance is at least lo+hi2. Therefore, this process consumes a number of queries on the order of 2log21014 queries. After our step above, it takes 3log21014 queries, which vastly exceeds our query limit.

We realize here that we need more queries to get an upper bound on our range than a lower bound, since when a query fails, it costs us money (and thus forces us to query lo again), while when a query succeeds, it increases our balance (and thus decreases the extent to which we'll need to query lo in the future). Therefore, as an improvement over the above idea, we might try doing a similar approach in the style of binary search, but instead of taking our query to be lo+hi2, we might take the query to be lo+r(hi−lo) for some fixed ratio r. By taking r<12, we try to establish relatively tight lower bounds so that it will take fewer lower bounds to find our answer, thus avoiding the 3log21014 worst-case complexity of the above solution.

This is the approach that many people attempted in-contest; unfortunately, some quick math shows that this idea is probably hopeless. With about 60 queries remaining after our initial step, we have the capacity to perform roughly 30 upper bounds, since each lower bound requires at least one additional operation. (In practice, the maximum number of upper bounds turns out to be slightly lower, but this is a good enough approximation for our purposes.) Since our range can contain up to 245 values initially, we must have r30≤1245, which implies r≤123/2≈0.35. However, when M=hi, we must also be able to identify M using at most about 60 lower bounds, which means that we must have (1−r)60≤1245. This gives 1−r≤123/4≈0.59, which implies r≥0.41. No r satisfies both of these conditions, implying that any choice of r is doomed to fail (though it may be quite hard to find a value of M to break any given solution using this approach, leading to a number of unfortunate FSTs).

For the right value of r, this approach intuitively feels relatively optimized (and, in fact, it's quite close to passing), so let's figure out what precision we haven't yet squeezed out of this algorithm. The key idea is that when our queries are successful, they actively help us perform future queries--that is, after successfully finding a new lower bound for our answer, performing upper bounds becomes cheaper in the future. As a result, after each lower bound, we can afford to increase r slightly to account for the fact that we won't have to perform as many lo queries in order to get a given number of lower bounds.

Let's now state the correct solution formally. Suppose that at some point, we know that M is in the range [lo,hi] and we have Q queries left. Moreover, let's say that Blo=K. At this point, we can perform approximately K upper bounds without needing to query lo in order to restore our balance. Therefore, the total number of upper bounds we can perform is Q+K2. As a result, if all our future queries are unsuccessful, we must have r≤1(hi−lo+1)2/(Q+K). We take this value of r, or 12 if r>12, and query lo+r⋅(hi−lo). Finally, we update lo or hi accordingly.

Unfortunately, this solution is a little finicky; I had to perform a bit of tweaking to get my solution to pass, but once configured appropriately, this approach consistently passes within the given query limit.

Time Complexity: O(q) per test case, where q is our query limit. Click here for my solution.

Codeforces Round #708 Editorial

By shishyando, history, 2 years ago, translation, In EnglishWe are really sorry to make the round unrated. Anyway, we hope that you enjoyed the problems!

1497A - Meximization

Idea: shishyando

Tutorial1497A - MeximizationTo maximize the sum of MEX on prefixes we will use a greedy algorithm. Firstly we put all unique elements in increasing order to get maximal MEX on each prefix. It is easy to see that replacing any two elements after that makes both MEX and sum of MEX less.

In the end we put all elements that are not used in any order because MEX will not change and will still be maximal.

Implementation1497B - M-arrays

Idea: Artyom123

Tutorial1497B - M-arraysLet's take each number modulo m. Now let cntx be the amount of x in array a.

If cnt0≠0, then all 0 should be put in a single array, answer increases by 1.For each number x≠0 we put it in an array x,m−x,x,m−x,… In this array the amount of x and the amount of m−x should differ not more than by 1, that's why we need to make max(0,|cntx−cntm−x|−1) arrays, containing a single number (x or m−x) that is more common.Implementation1497C1 - k-LCM (easy version)

Idea: shishyando

Tutorial1497C1 - k-LCM (easy version)If n is odd, then the answer is (1,⌊n2⌋,⌊n2⌋)If n is even, but is not a multiple of 4, then the answer is (n2−1,n2−1,2).If n is a multiple of 4, then the answer is (n2,n4,n4).Implementation1497C2 - k-LCM (hard version)

Idea: isaf27

Tutorial1497C2 - k-LCM (hard version)In this solution we will reuse the solution for k=3.

The answer will be 1,1,…,1 (k−3 times) and the solution a,b,c of the easy version for n−k+3.

(1+1+…+1)+(a+b+c)=(k−3)+(n−k−3)=n.

Also LCM(1,1,…,1,a,b,c)=LCM(a,b,c)≤n−k+32≤n2.

Implementation1497D - Genius

Idea: shishyando

Tutorial1497D - GeniusLet's consider a graph where vertexes are problems and there is an edge {i,j} between vertexes i and j with weight |ci−cj|. Each edge has a unique weight. Let's prove that. Let's assume that weight=|2i−2j| and i>j. Then in binary form weight has its k-th bit set true if and only if j≤k<i. Then for each unique pair {i,j} weight is unique too since the corners of a subsegment with true bits are unique.

Let dpi be the maximal amount of points that may be earned ending with problem i. Initially dpi=0 for each 1≤i≤n. Let's consider all edges in increasing order (because IQ should increase). To do that we can consider j in increasing order from 2 to n and then i in decreasing order from j−1 to 1. It is also explained by the binary form of the weight.

Now let's relax dp values. When we consider an edge {i,j},tagi≠tagj we try to solve problem i after solving dpj problems ending with j, and problem i after solving dpi problems ending with i. It means that dpi=max(dpi,dpj+p),dpj=max(dpj,dpi+p) at the same time, where p=|si−sj|. After considering all edges the answer is the maximal value among all dp values.

Implementation1497E1 - Square-Free Division (easy version)

Idea: Artyom123

Tutorial1497E1 - Square-Free Division (easy version)For factorization of x=pq11⋅pq22⋅⋯⋅pqkk let's define mask(x)=pq1mod21⋅pq2mod22⋅⋯⋅pqmmod2m. After that it is easy to see that x⋅y is a perfect square if and only if mask(x)=mask(y).

Now let's say ai=mask(ai) for all 1≤i≤n. The problem we need to solve is: split the array into minimal amount of non-intersecting subsegments so that on each subsegment all numbers are different. Since k=0 we can do that using a greedy idea. If we consider an element that has not been in our current segment, then we add it to the segment. If it's already taken, then we should end our current segment and start a new one.

Implementation1497E2 - Square-free division (hard version)

Idea: isaf27

Tutorial1497E2 - Square-free division (hard version)Let's use the same definitions as in tutorial of E1. So after making ai=mask(ai) for all 1≤i≤n we need to split the whole array into minimal amount of contiguous subsegments with all different elements. Also, we can change k elements how we want.

Firstly, for each 1≤i≤n and 0≤j≤k let's find lefti,j  — such minimal index l, so that after making j changes the segment al,al+1,…,ai contains only distinct values. For fixed j if i is increased then lefti,j increases, too, that's why for fixed j we can use the two pointers technique. This allows us to calculate lefti,j in O(n⋅k).

Now for each 1≤i≤n and 0≤j≤k let's calculate dpi,j  — the minimal amount of contiguous subsegments that prefix a1,a2,…,ai is possible to divide into after making j changes. For each j let's consider 0≤x≤j  — the amount of changes on the last subsegment. Let's say that l=lefti,x then dpi,j=min(dpi,j,dpl−1,j−x+1). This is done in O(n⋅k2) so the total complexity of the solution after making ai=mask(ai) is O(n⋅k2).

Implementation

Codeforces Round #707 Editorial

By ch_egor, 2 years ago, In EnglishThanks for the participation!

1501A - Alexey and Train was authored by Aleks5d and prepared by 4qqqq

1501B - Napoleon Cake was authored and prepared by KAN

1500A - Going Home was authored and prepared by wrg0ababd

1500B - Two chandeliers was authored by jury and prepared by Siberian

1500C - Matrix Sorting was authored by Endagorion and prepared by NiceClock

1500D - Tiles for Bathroom was authored by meshanya and prepared by KiKoS

1500E - Subset Trick was authored and prepared by isaf27

1500F - Cupboards Jumps was authored and prepared by Akulyat

1501A - Alexey and TrainThe solution of this task is to basically implement what was written in the statement.

Let depi be the moment of train departure from the station i (dep0=0 initially). Then train arrives at the current station i at moment ari=depi−1+(ai−bi−1)+tmi and departure at moment depi=max(bi,ari+bi−ai+12).

The answer is arn.

1501B - Napoleon CakeThe i-th layer is drenched in cream if there is such j≥i that j−aj<i. Then we can calculate answers for all layers i in reverse order (from n to 1) and maintain minimum over all values j−aj as some variable mn.

As a result, when we move from i+1 to i, we update mn=min(mn,i−ai) and then check that mn<i.

1500A - Going HomeLet's prove that if there're at least four different pairs indices with the common sum (ax1+ay1=ax2+ay2=…=ax4+ay4), then there necessarily will be two pairs such that all four indices in them are unique.

Let's analyze some cases:

There're four pairs of the form (x,y1),(x,y2),(x,y3),(x,y4) with sum S. Then ax+ay1=ax+ay2=ax+ay3=ax+ay4=S from which we can conclude that ay1=ay2=ay3=ay4, and it means that pairs (y1,y2) and (y3,y4) are suitable as answer.There're three pairs of the form (x,y1),(x,y2),(x,y3) and the fourth pair doesn't contain index x. Then whatever the fourth pair (z,w) is, it necessarily doesn't contain index x and at least one of indices y1,y2,y3 which means we can take as answer pairs (z,w) and one of three that contain x.Other cases are analyzed in the same way. To make sure that answer always exists among such four pairs, we can imagine graph, where vertices are indices, and there is an edge between two vertices if the corresponding pair of indices has sum S. If such a graph has at least four edges and the degree of all vertices is at most two (we excluded the larger degrees by examining the previous cases), then there will always be two edges with disjoint ends.How to find answer using this? Let's launch simple O(n2) bruteforce which for every sum will save all found pairs with such sum, and for each pair check if there's another already found pair with the same sum and such indices that all four indices in these two pairs are unique.

Let's notice it works in O(min(n2,n+C), because once for some sum we find the fourth pair, we can immediately print the answer. And if the answer is "NO", then we've done no more than O(C) iterations of bruteforce.

1500B - Two chandeliersA formal statement of the problem: there are two sequences of distinct integers, whose are infinitely cycled. You need to find prefix of minimal length which contains exactly k positions i such that ai≠bi.

Let's notice that we can use binary search. So we need to count number of positions i such that ai≠bi on prefix of length x.

Because all integers in ai are distinct (and also in bi), we need to calculate number of non-negative solutions:

{pos≡x(modn)pos≡y(modm)If n and m are coprime, the value can be calculated with Chinese remainder theorem. Solution's complexity will be O((n+m)⋅log(n+m)⋅log(k⋅(n+m)).

If n and m are not coprime, participant can make transition (n,m)→(ngcd(n,m),mgcd(n,m)), solve new equations, and then make reverse transition.

After that, you need to optimize this solution. There are many ways to do this, for example, you can precalculate solutions of all equations. And complexity becomes O((n+m)⋅(log(k)+log(n+m)))1500C - Matrix SortingLet's first learn how to solve with O (n⋅m2).

Note that each column can be sorted no more than once.

Now, let's note that if we could turn matrix A into matrix B, then B has a sorted column.

Idea  — we will choose the rows that we will sort from the end. To do this, we can support string equivalence classes. Where and why? If two rows are in the same class, then the columns that we applied had the same values. Then, we need to find a column that does not break the sequence between the rows inside each of the classes. Let's iterate through such a column every time. We don't care if we apply someone extra  — because of the condition of the possibility of application, it will definitely not spoil. Then just apply the column if we could. Each time, the number of equivalence classes does not decrease, so the number of columns that can be applied does not decrease. If it was not possible to sort after all the applications, it means that some of the classes could not be split correctly, which means that it is impossible to get matrix B from matrix A.

Let's learn how to solve it faster than in a cube. Let's not store equivalence classes explicitly. To do this, note that in the final state of B, the equivalence classes are sub-arrays! Then it is enough for us to store for each pair of adjacent rows whether we were able to separate them (swap the lower and upper places)  — let's call it cut. Also, for each column, we will store the number of still unresolved inversions in it, call it cnt. Initially,  — is just the number of inversions in the column. Next, it will be the same number of inversions, but only within the classes. How does this solution differ from a cube? We are able to quickly find which column can be applied - this is the column j for which cnt[j]=0. Then we just need to learn how to update the cnt. Let's start a queue (we can say that this is bfs, but in fact we do not use anything other than a queue from bfs), to which we will add only columns j in which cnt[j]=0, apply sorting by column, update cnt and add new columns that have cnt=0. cutwill help us with this. Let's, if we managed to swap the columns (that is, in the current column v, b[i][v]<b[i−1][v]), set cut[i]=1 and update all the values of cnt through this row. It is clear that it does not make sense to split rows twice. Since we will apply each column at most once, and the pairs of adjacent rows are O(n), the time complexity is O(n⋅m). Do not forget that it is not necessary to divide into exactly n equivalence classes, because a smaller number may be enough. So in the end, check transformations(not difficult, but need to be careful).

There is also a solution with time complexity O(nmlog), but I think, it is more difficult both in terms of understanding and implementation.

1500D - Tiles for BathroomLet's denote ansi,j as max "good" subsquare side size with left top angle at (i,j) cell. It's obvious that every subsquare with side less than ansi,j is "good" too. So we need to find ansi,j and then print answer for k-size side as ∑x=kn|{(i,j) | ansi,j=k}. This value can be found with partial sums on count array of ansi,j.

Now we need to calculate ansi,j. Let's notice that ansi,j+1≥ansi,j−1, because (i,j+1)-th square is inside of (i,j) square if it's side is longer than 1. So, we can use amortized algorithm of sequential increase square's side. Every time when we can increase ansi,j we will do it, then we will go to calculating ansi,j+1. Using linear algorithm to check if new square's size is "good", we will get O(n3) solution, which is not effective enough, but can be optimized.

Now let's use small constraints for q. For each (i,j) cell we will precalc array colorsi,j, which will have (q+1) nearest colors in line (i′,j),i′≥i. For each color, we will keep it's earliest occurrence It can be calculated in O(n2q), because colorsi,j=colorsi,j+1∪ci,j. If ci,j exists in colorsi,j, we must change earliest occurrence. If it isn't, we should delete the most far color, then insert the current one. All values can be keeped with increasing left occurrence in O(q) for each cell.

Last step — we can merge colorsi,j, …, colorsi+m−1,j in O(mq) — it will be the array of q+1 values corresponding for earliest colors in line of width m. Merging two lines is almost like merge of two sorted arrays — it is used to find q+1 minimal left occurrences. Maximal "good" width can be found as left occurrence of (q+1)-th elementh minus j.

Now we need to unite some rows in a structure and merge lines for current square, then erase first row and repeat the process. The structure can be realized as queue on two stacks, each of whose is keeping merge value of all lines in itself. The algorithm is almost like queue with minimal value (https://cp-algorithms.com/data_structures/stack_queue_modification.html). That's how we get solution with complexity O(n2q).

1500E - Subset TrickLet S={a1,a2,…,an}, where a1<a2<…<an.

Let's calculate the number of good numbers from 0 to sum(X)−1. To get the answer to our problem we should subtract this value from sum(S).

Let's suppose that 0≤x<sum(X) is good. It is easy to see that it is equivalent to an−k+1+…+an≤x<a1+…+ak+1 for some 0≤k<n.

So to calculate the required number of good numbers we should find the length of the union of intervals [an−k+1+…+an,a1+…+ak+1) for all 0≤k<n.

We can note two things:

some of these intervals are emptyall non-empty intervals does not intersect with each otherSo the number we want to find is just ∑k=0n−1max(a1+…+ak+1−an−k+1−…−an,0).

Let's call f(k)=a1+…+ak+1−an−k+1−…−an. Let's note two simply things:

f(k)=f(n−1−k)f(x)≥f(y) if x≤y≤n−12Let's use them. First of all let's find ∑k=0n−12max(f(k),0). We can simply calculate the sum we need from it because we should just multiply this sum by 2 and possibly subtract the number from the middle (if n is odd).

Let's note that in the sum ∑k=0n−12max(f(k),0) some first summands are >0, others are equal to 0 (because 0 will be bigger in the maximum).

Let's find the minimal l≤n−12, such that f(l)≤0 using binary search. After that we should calculate ∑k=0l−1f(k)=∑k=0l−1(a1+…+ak+1−an−k+1−…−an)=∑i=0lai(l−i)−∑i=n−l+1nai(i+l−n).

So what values we should be able to calculate to solve the problem?

The sum of numbers on prefix ∑i=0kai. Using two queries of this type we can calculate f(k).The sum of numbers multiplied by index on prefix ∑i=0kaii. We can calculate the final answer using this query.To answer these queries effectively let's use the segment tree. Initially let's find all numbers that will be in S in some moment (we can do it because we have the list of all queries). We will make a segment tree on this array, where we will write 0, if there is no such number currently in S and 1, otherwise.

For each segment of these segment tree we will store 3 values:

the number of numbers from this segment, that lie in the current Sthe sum of numbers from this segment, that lie in the current Sthe sum of numbers multiplied by index from this segment, that lie in the current SThese values can be easily recalculated when an update in the segment tree happens.

To calculate two sums required for us we need to make the descent in the segment tree summing the segments on the prefix, where the number of numbers that lie in the current S is equal to k.

In total, we get the O((n+q)log2(n+q)) solution, because we make the binary search and use queries to the segment tree inside it.

1500F - Cupboards Jumps− Note 1

We can change cupboards' heights with differences between following ones: di=hi+1−hi. How to get w using d?

wi=max(|di|,|di+1|,|di+di+1|)

− O(nC)

dp[i][dif] - can we choose i differences, with the last equal to dif

Can be updated with O(1) checks

− Note 2

If we can get dif difference, then −dif too, because we can invert all differences on prefix and save all conditions. So keep in mind just dif∈[0,C]

− O(n2)

Let's keep values on each layer we can get as segments. We show that there will be O(n) of them for each layer.

Segment [0;wi] is full able if previous layer has value wiEach segment [l,r] goes to [max(wi−r,0),wi−l]If some segment had x:x≤wi, then we should add: [wi,wi]So, moving to a new layer, we will get no more than one extra segment.Restoring the answer: since we keep all segments for each layer, we can check that previous one contains:

wiwi−difanything ≤wi, if dif=wiWe should return signs to differences, because we have started to consider just non-negative values. We can move from left to right ans put them greedy choosing any correct one − O(n)

Segments don't change much. Each layer change is:

inversion + shift + truncation with zero ([l,r]→[max(wi−r,0),wi−l])check for a corner value (wi→[0,wi])add corner value (x≤wi→[wi,wi])All except inversion and shift happen at corners of our segments list(we keep them sorted). Inversion and shift are the same for all segments. Let's keep cf=±1 and shift sh, recalculating them on each layer and keeping list of our segments the sameAfter recalculating value of cf and sh: let's trunc segments from corners to keep just values in [0,wi] and add [wi,wi](converted) if we need to. Number of truncation will be O(n).

Restoring:

If wi was at previous layer - keep it and useIf dif=wi, use minimum value from previous layerOtherwise we should definitely use wi−dif

Codeforces Round #706 Editorial

By Imakf, history, 2 years ago, In EnglishThe jury solutions will be updated later.

The jury solution is updated now.

1496A - Split it!

Idea: waaitg

1496A - Split it!If k=0 or s[1,k]+s[n−k+1,n] is a palindrome, the answer is yes.

Otherwise, the answer is no.

Note that when 2k=n, the answer is no, too.

The time complexity is O(n+k) for each test case.

Solution (Imakf)1496B - Max and Mex

Idea: waaitg

1496B - Max and MexLet a=max(S),b=mex(S).

When k=0, the answer is n.

Otherwise if b>a, then b=a+1 , so ⌈a+b2⌉=b . It's not hard to find out that max(S∪{b})=b,mex(S∪{b})=b+1, so the set S always satisfies max(S)+1=mex(S). So the answer is n+k when b=a+1.

Otherwise b<a. So b<a⇒2b<a+b⇒a+b2>b⇒⌈a+b2⌉>b. In that case mex(S)=b is always true. So the element we add in all operations is always ⌈a+b2⌉. Just check whether it is in S at first.

The time complexity is O(n) or O(nlogn) for each test case depending on your implementation.

Solution (waaitg)1495A - Diamond Miner

Idea: smg23333

1495A - Добытчик алмазовFirst, you can turn a point (x,y) to (|x|,|y|), while not changing the answer.

After this operation, all points can be described as (0,a) or (b,0) (a,b>0).

In a triangle, if the length of the edges are a, b, c, it is obvious that a+b>c.

So, if you connect all match-pairs with a segment and there are two segments intersecting each other, you must be able to change the matching ways to make the answer smaller.



For example, if you match A(a1,0) with B(0,b1), C(a2,0) with D(0,b2), the answer will be |AB|+|CD|; if you match A with D and B with C, the answer will be |AD|+|BC|<|AO|+|DO|+|BO|+|CO|=|AB|+|CD|.

So in the best solution, there won't be two segments intersecting each other.

Sort all the points on the x-axis and on the y-axis, then match the points in ascending order of x or y, you can get the minimum.

The time complexity is O(nlogn) for each test case.

Solution (smg23333)1495B - Let's Go Hiking

Idea: waaitg

1495B - Let's Go HikingLet's consider that the 2k+1(k≥0)-th turn is Qingshan's and the 2k+2(k≥0)-th turn is Daniel's.

If Qingshan chooses x(1<x≤n) satisfying x=n or px<px+1, then Daniel can choose y=x−1 to make Qingshan can't move in the first turn. The case that x=1 or px<px−1 is the same. So Qingshan must choose x(1<x<n) satisfying px>px−1 and px>px+1 at first.

Let l be the length of the longest monotone segments and c be the number of the longest monotone segments. l≥2 and c≥1 are always true.

It is obvious that Qingshan can't win when c>2 because wherever Qingshan chooses, Daniel can always find a place that he can move l−1 times while Qingshan can move l−1 times at most.

When c=1, Qingshan will also lose. If the only longest monotone segment is ps,ps+1…,ps+l−1 and it's increasing(if it's decreasing, the discussion is almost the same). Qingshan must choose x=s+l−1 at first. The discussion follows:

If lmod2=0, Daniel can choose y=s at first. After the l−3-th turn(Qingshan's turn), x=s+l−l2 and After the l−2-th turn(Daniel's turn), y=s+l2−1. The next turn is Qingshan's and Qingshan loses.If lmod2=1, Daniel can choose y=s+1 at first. Pay attention that Qingshan can't change x to x+1 in the first turn because Daniel can move l−2 times while Qingshan can move l−2 times at most if she change x to x+1 in the first turn. After the l−4-th turn(Qingshan's turn), x=s+l−l−12 and After the l−3-th turn(Daniel's turn), y=s+l−12. The next turn is Qingshan's and Qingshan loses.When c=2 , the only two longest monotone segments must be like pm−l+1<pm−l+2<⋯<pm>pm+1>⋯>pm+l−1. (Otherwise Qingshan will lose.) In that case Qingshan will lose if lmod2=0 because Daniel can choose y=m−l+1 at first and whatever Qingshan's first move is, Qingshan will lose(just like the discussion above). If lmod2=1, Qingshan is the winner. It is not hard to check it in O(n).

The overall time complexity is O(n).

Solution (waaitg)1495C - Garden of the Sun

Idea: Imakf

1495C - Garden of the SunWhen m is the multiple of 3, it's easy to construct a solution: First, remove all the sunflowers on column 2,5,8,11,…. This operation won't form a cycle in the graph.

Let's take this as an example:

After the operation, the graph turns into:



After that, you need to connect these columns to make them connected but without forming a cycle.



The green cells are all alternatives.

This way of construction also works for m=3k+2. But you need to be cautious about the case of m=3k+1 because there is an extra column that may not be connected with the left part. Don't forget to connect them.





Another approach is to remove column 1,4,7,10,… when m=3k+1. So there won't be an extra column.

The time complexity is O(nm) for each test case.

Solution (Imakf)1495D - BFS Trees

Idea: waaitg, Daniel_yuan, isaf27

1495D - BFS TreesLet's enumerate vertexes x,y, and calculate f(x,y) for them.

Let dist(x,y) denote the number of the vertexes which lie on the shortest-path between x and y on the graph.

It is obvious that the distance between x and y in the tree is equal to dist(x,y). And the vertex z satisfying dist(x,z)+dist(y,z)−1=dist(x,y) must be on the path between x and y. So the number of the vertexes z must be equal to dist(x,y) ( including x and y ).

Then, let's consider the contributions of other vertexes i. In the bfs-trees of both x and y, there must be and only be a edge linking i and j, which j satisfies dist(x,i)=dist(x,j)+1∧dist(y,i)=dist(y,j)+1.

Proof :

Let's prove it recursively.

All the vertexes linked to the path between x and y satisfy the condition ( There is and only is a edge linking them ). We can call them layer 1.

All the vertexes linked to the layer 1 satisfy the condition ( There is and only is a edge linking them ). We can call them layer 2.

All the vertexes ...

End of proof

And the contribution of each vertex is independent, which means that for each vertex i we can choose a vertex j without considering other vertexes.

Proof :

No matter which j we choose for i, the layer of i will not change.

So the choice of i won't change the number of choices of others.

End of proof

So we only need calculate the number of j for every i, and multiply them.

For every x,y, we should enumerate all the edges to calculate j for every i. So the complexity is O(m) per x,y. The total complexity is O(n2m).

Solution (Daniel_yuan)1495E - Qingshan and Daniel

Idea: Imakf

1495E - Qingshan and DanielWe can consider that the robots are standing on a cycle.

The game ends up with at least one team having no cards. Let the team having no cards in the end be team A and let the other be team B. If two teams both use up their cards, the first robot's team is A. For team A, we've already known how many cards will its robots discard, because they will discard all their cards. But how to calculate the answer for team B?

Let's look at the process of the game. Obviously, robots in A and robots in B will discard cards alternatively. In another word, if we write down the team of robots who discard cards in time order, it will form a sequence — ABABAB⋯B or BABABA⋯B. For the second type (starting with B), we can just use brute-force to discard the first card and then find the next A. So there is only one circumstance: ABABAB⋯B.

Note that in the sequence every A is followed by exactly one B. So the length of the sequence is the number of cards of team A multiplying 2.

Currently, we are not able to figure out which robot is exactly represented by a particular A or B in the sequence. Luckily, we don't need to know it. What we care about is only how many cards the robot in team B discards. You can consider every AB is the sequence as a query and change operation — "In the current game, some robot i in team A will find the first robot j in team B on its right, and change aj to aj−1". It's a very important limit "In the current game" here because some robot will quit the game halfway according to the statement.

But on the contrary, an interesting fact is that the "important" limit is not important at all. We can make the query and the change in any order and it won't change the answer!

So you just need to iterate the array and maintain a variable cnt — the number of operations that are visited but not performed. If the team of the current robot is A, assign cnt+ai to cnt. Otherwise, you can perform min(ai,cnt) operations now, and assign ai−min(ai,cnt) to ai. Since robots are standing on a cycle, you need to iterate the array 2 times.

So the time complexity is O(n+m).

Solution (Imakf)1495F - Squares

Idea: waaitg

1495F - SquaresIf we let the parent of i(1≤i≤n) is the rightmost j satisfying j<i,pj>pi(if that j doesn't exist, the parent of i is 0), we can get a tree and we can dfs the tree with the order 0,1,2,…,n. Let's call the parent of i is pai and the children set of i is childi.

Here is an example. n=5 and the permutation is 2,1,5,3,4.

The graphs we build follow.

Let's call the edges with the cost ai A-type and the edges with the cost bi B-type. Consider that now you are on the i-th square. If you choose a B-type edge(with the cost bi), you will jump over all the squares in i's subtree(i is not included), that is to say, you will not pass through them. If you choose an A-type edge, we can think you enter i's subtree and you must pass through all of the i's child.

To simplify the problem, we think you choose a node i if and only if you pass through the A-type edge from the i-th square. Let's call the chosen set is S. It is not hard to find out that the node i can be chosen if and only if all the ancestors of i in the tree are chosen(if not, you even don't have the chance to pass through i). And that you pass through the i-th square is equivalent to you choosing the parent of i.

Then the problem is simplified. You purpose is to choose some nodes in the tree (0 must be chosen as it is the root) and minimize your cost. Here your cost is ∑i∈Sai+∑i∉S,pai∈Sbi. If we let ci=ai−bi+∑j∈childibj, the cost can be considered as ∑i∈Sci+∑j∈child0bj. It is very easy to solve it with binups.

The time complexity is O((n+q)logn).

Solution (waaitg)

Codeforces Round #705 (Div.2) Editorial

By AlFlen, 2 years ago, translation, In English1493A - Anti-knapsack

Idea: AlFlen, 74TrAkToR

Tutorial1493A - Anti-knapsackLet's notice that we can take all numbers k+1,k+2…n, because every one of them is greater than k, and sum of any number from k+1,k+2…n and any number from 1,2…n also is greater than k. Let's also take numbers from ⌈k2⌉ to k−1 inclusive. Notice that the sum of any two chosen numbers is already greater than k, and no chosen number is equal to k, therefore such set is correct. It contains (n−k)+(k−⌈k2⌉)=n−⌈k2⌉ numbers.

Let's show why such size of a set is the maximal possible. Numbers from k+1 to n won't give subsets with sum k with any other numbers, so we can take them to the answer: their amount is n−k. The number k can't be taken to the answer, because if we take a subset consisting from that number only, the sum in it will be k. Let's consider numbers from 1 to k−1. They can be divided into ⌊k2⌋ pairs, in each of which the sum of numbers will be k (1 and k−1, 2 and k−2 etc.; if k is even, then the pair with number k2 will consist of one number). If we took at least ⌊k2⌋+1 numbers from 1 to k−1, then at least two chosen numbers will be in one pair, and their sum will be equal to k, what contradicts with problem condition. It means that we can take not more than ⌊k2⌋ numbers from 1 to k−1.

Then the total size of the set will not exceed (n−k)+⌊k2⌋. As known, k = ⌊k2⌋+⌈k2⌉ (you can prove that fact by considering two cases: when k is even, and when k is odd). Let's replace k in recieved estimation: n−(⌊k2⌋+⌈k2⌉)+⌊k2⌋=n−⌈k2⌉, which is the size of mentioned set, therefore mentioned set is the answer to the problem.

Solution (74TrAkToR)1493B - Planet Lapituletti

Idea: AlFlen

Tutorial1493B - Planet LapitulettiIn order to solve the problem, you need to look over all the moments of time after the given one and check if the reflected time is correct in that moment of time. If such moment of time does not exist on the current day, the moment 00:00 of the next day is always correct.

For realization you need to notice that digits 0, 1, 8 transform into themselves after reflection, 2 transforms into 5, 5 transforms into 2, and other digits (3, 4, 6, 7, 9) transform into incorrect digits after reflection.

Solution (74TrAkToR)1493C - K-beautiful Strings

Idea: 74TrAkToR

Tutorial1493C - K-beautiful StringsFirst of all, let's notice that if the length of the string n is not divisible by k, no beautiful string of such length exists. Otherwise the answer to the problem always exists (because the string zz…z is the greatest string of length n and is beautiful).

If the string s is beautiful, then s itself is the answer. Otherwise, let's iterate over all the options of the maximal common prefix of the answer string and s, that way we will iterate from n−1 to 0.

Let's maintain an array cnti — how many times does the i-th leter of English alphabet occur in the prefix we have fixed. We can recalculate that array totally in 0(n), because when we iterate to the smaller prefix we only need to change one value of cnt.

Denote the length of common prefix as pref. Let's iterate over all possible letters at position pref+1 (numeration starts from one) in increasing order. We need to iterate over all letters that are strictly greater than spref+1, because otherwise either the answer will be less than s or the length of common prefix won't be equal to pref.

Now we need to learn how to check quickly if we can pick any suffix so that we will get a beautiful string. To do that you need to go through the array cnt and to calculate for each letter which miminal number of times we need to write it more in order to get the amount of occurences divisible by k. For i-th leter it is (k−cnti % k) % k. Let sum be the sum of such value over all i. If sum isn't greater than the length of the suffix, then what's left is to find the minimal suffix.

How to build the minimal suffix: let's denote the length of unknown suffix as suff (suff=n−pref−1). We know that sum≤suff. If sum<suff, then let's increase the amount of occurences of a on suffix by suff−sum. Now we will place all letters a, then all letters b and so on to z.

A detail of realization: we will consider iterated letter at position pref+1 in the array cnt. We can maintain array cnt on prefix of length pref+1 and take into account that pref+1-st symbol is the iterated symbol and not the symbol of string s.

The complexity of solution is O(n⋅C), where C is the size of the alphabet (26). You can also write a solution in O(n), by maintaining the sum (k−cnti % k) % k in a variable.

Solution (74TrAkToR)1493D - GCD of an Array

Idea: 74TrAkToR

Tutorial1493D - GCD of an ArrayNotice that after each query the answer doesn't become smaller and we can solve the problem for each prime divisor independently.

For each number let's maintain an amount of occurences for all its prime divisors (you can implement it using map). For each prime divisor let's write to its corresponding multiset the amount of times it is met in every of the numbers of the array, at the same time we won't add null values.

Initially, ans=1. Let's understand the way a prime divisor p is included in the answer. If the size of its multiset is not equal to n, then ans won't change, otherwise ans=(ans⋅px) % mod, where x is a minimal number of multiset.

Since ans is not decreasing, then we can avoid calculating it all over again every time and instead recalculate it only for divisors that are being changed (with that, because the minimal number of multiset is not decreasing as well, we can just increase the answer using multiplication).

To process the query, we need to find the prime factorization of x (for example, using the Sieve of Eratosthenes) and add the prime divisors to the map for i-th element (and correspondingly change the multiset for that divisor).

Each query is processed in the complexity of the amount of prime divisors multiplied by the time of map and multiset operation, i.e. log.

Solution (74TrAkToR)1493E - Enormous XOR

Idea: AlFlen

Tutorial1493E - Enormous XORLet's numerate bits from 0 to n−1 from the least significant bit to the most significant (from the end of the representation). If n−1-st bits of numbers l and r differ, then there is a power transition between numbers l and r, and the answer to the problem is 11…1 (the number contains n ones).

Otherwise it can be shown that if 0 bit of the number r is equal to 1, then the answer is r itself. If 0 bit of the number r is equal to 0 and l<=r−2, the answer is r+1, otherwise the answer is r.

Proof.

Firstly, if there is a power transition between l and r, then we can take a segment [11…1; 100…0] (n−1 ones; 1 and n−1 zero), and get xor on it of n ones. It is not hard to show that it will be the maximal possible.

Let's prove that for odd r without power transition the answer is r. That answer can be reached if we take a segment consisting of one number r. Let's prove that the answer if maximal using induction. Base: for segments [r;r], [r−1;r], r is odd, the answer is r (in the first case there is no other segments, in the second case subsegments [r−1;r−1] and [r−1;r] have less xor-s).

Let's take induction step from [l;r] to [l;r+2]. The answer on segment [r+1;r+2] is obviously r+2, remaining subsegments can be split into three groups: with right bound r+2, with right bound r+1, and lying inside the segment [l;r], with that all the left bounds of the subsegments are lying inside [l;r]. The answer on the segments of third group is r (proved by induction). The segments of the first group contain subsegment [r+1;r+2], which has xor equal to 1, and some segment ending at r. Notice that that way we can increase the answer of the segment [l;r] not more by 1, i.e. the answer for the segments of the first group is not greater than r+1.

Now let's consider the segments of the second group. Suppose that we could find the segment from that group with xor on it greater than r+2. Then some bit which was 0 in r+2, became 1 in that xor, with that it is not the 0 bit (since r+2 is odd). Let's find the amount of numbers from r+1 (inclusively) to the nearest having 1 in that bit (non-inclusively). It is not hard to show that that amount is odd (from even to zero inclusively).In order to make the bit 1, we need to take an odd amount of numbers with 1 in that bit. Since the blocks (among consecutive numbers blocks with 0 in that bit and blocks with 1 in that bit) have even length (2, 4, 8 and so on), we need to take an odd amount of numbers in total to take an odd amount of numbers with 1 in that bit. Then the whole segment will contain odd + odd = even amount of numbers (the first summand is the amount of numbers from r to the nearest having 1 in that bit, the second summand is the amount of numbers we will take to make that bit equal to 1), but then the most significant ((n−1)-st) bit will become equal to 0, therefore we will get xor less than r+2. It means that among segments of the second group there is no segment with xor greater than r+2 as well. So, r+2 is the answer for [l;r+2].

Now let's consider even right bounds. If the length of the segment is less than 2 (l>r−2), then it is simple to show that the right bound will be the answer. Otherwise r+1 is the answer. It can be reached on the segment [r−2;r] and is the maximal possible, because we can increase the right bound of the segment by 1 (it will become odd), with that the answer surely won't decrease, and the answer on [l;r+1] is proven to be r+1.

Solution (74TrAkToR)1493F - Enchanted Matrix

Idea: 74TrAkToR

Tutorial1493F - Enchanted MatrixTe problem can be solved in various ways but the main idea is that if we want to check, if the x consecutive blocks are equal to each other, then we can do it using ⌈log2x⌉ queries. Let's suppose we want to check the equality of x blocks, then we will check if the first and second ⌊x2⌋ blocks are equal. If they are not equal, then x blocks are not equal to each other, otherwise we need to check if the last ⌈x2⌉ blocks are equal.

Notice that the problem can be solved independently for rows and columns.

Let's solve the problem for n rows and let's find all r such that the matrix can be split into equal rectangles of r rows. If r is the answer, then the numbers that are divisible by r are also the answers. If r is not the answer, then all divisors of r are not the answers. If r1 and r2 are the answers, then gcd(r1,r2) is the answer as well.

Let's make a dynamic dpr. If dpr=1, then the matrix can be divided into r rows, otherwise dpr=0 and the matrix cannot be divided that way. We will iterate over r in descending order. Let's suppose we want to calculate dpr. Then we know for sure that for every x that are divisors of n and are divisible by r, dpx=1 (because otherwise dpr=0 and we don't have to calculate it). Let's find such minimal x and check the equality of xr blocks using the idea described in the beginning of the editorial.

Let's calculate the sum of dpr — that is the amount of suitable r. Then we will solve the problem similarly for columns and output the product of suitable r and suitable c.

It is guaranteed that with any initial field the described solution will ask less than 3⋅⌊log2(n+m)⌋ queries. An accurate estimation of number of queries will be shown later.

An accurate eastimation of number of queries: let us have the least r such that we can split the matrix into r rows (in order to get equal subrectangles) and all remaining r are divided by it. Using that dynamic we maintain a minimal suitable r, and after that we try to decrease it using the algorithm from the editorial. The worst case is when we divide current minimal r by 3 with 2 queries. Then we need 2⋅log3n queries, which is equal to log34⋅log2n.

Solution (74TrAkToR)

Codeforces Round #704 Editorial

By ch_egor, 2 years ago, translation, In EnglishThanks for the participation!

1492A - Three swimmers was authored by meshanya and prepared by ch_egor

1492B - Card Deck was authored by Noam527 and prepared by ch_egor, adedalic

1492C - Maximum width was authored and prepared by Jatana

1492D - Genius's Gambit was authored by voidmax and prepared by rip

1492E - Almost Fault-Tolerant Database was authored by wrg0ababd and prepared by Sehnsucht

1492A - Three swimmersThe answer is just min(⌈pa⌉⋅a,⌈pb⌉⋅b,⌈pc⌉⋅c)−p.

Complexity: O(1).

1492B - Card DeckIt's easy to prove that order of a deck differs for different permutations. And more than that order of permutation a is greater than order of permutation b if and only if a is lexicographically greater than b.

Since we need to build a lexicographic maximum permutation, at each point of time we need to choose such k that k-th element from the top of the original deck is the maximum element in this deck.

Total complexity is O(nlogn) or O(n) (depending on the implementation).

1492C - Maximum widthFor some subsequence of the string s, let pi denote the position of the character ti in the string s. For fixed i, we can find a subsequence that maximizes pi+1−pi.

Let lefti and righti be the minimum and maximum possible value of pi among all valid ps. Now, it is easy to see that the maximum possible value of pi+1−pi is equal to righti+1−lefti.

To calculate lefti we just need to find the first element after lefti−1 which is equal to ti. This can be done by a simple greedy or dp algorithm. righti can be found in the same way.

So, after finding left and right, the answer is maxi=n−1i=1righti+1−lefti.

Complexity: O(n+m).

1492D - Genius's GambitThis problem has a cute constructive solution.

If a=0 or b=1 the answer is trivial. In other cases let's fix x as a number in form 111…1100…000. Let y=x, then we will change only y.

Let's take the last 1 digit from the consecutive prefix of ones, then move it min(k,a) positions to the right. It is easy to see, that the number of ones in x−y has increased by min(k,a). If k≤a we already have the answer.

If not, let's take the last 1 digit from the consecutive prefix of ones and move it one position to the right. The number of ones in the answer increased by one and if it is less than k, we just repeat this move. With this construction we can easily build an answer for every k≤a+b−2It's not difficult to prove that the answer does not exist when k>a+b−2.

1492E - Almost Fault-Tolerant DatabaseLet's look at the first array. Every possible answer (if there is any) should not differ from this array in more than 2 positions. So we should try to change at most 2 positions in the first array to find a consistent answer.

Let's look at the other arrays. We can ignore each other array that differ with the first array in no more than 2 positions. In particular, if every array doesn't differ in more than 2 position, we can just print the first array as an answer.

If an array differs in 5 (or more) positions, then no answer exists.

Suppose that we selected an array with 3 or 4 diffs. This means that we must change 1 or 2 positions (respectively) in the first array to reduce it to 2 diffs. We have 3 or 6 ways to do this (respectively), and can go through all the options.

After changing, we should look at all arrays again and make changes in the first array again if required (but no more than in 2 positions in total) in a recursive backtracking manner. If we don't get an answer, we should go back and try another option.

The time complexity is O(n⋅m) with a decent constant.

Bonus1: If allowed number of diffs is k, can you solve problem in O(kknm) time?

Bonus2: If allowed number of diffs is k, can you solve problem in O(nm+kknm−−−√) time?

Codeforces Round #703 (Div. 2) Editorial

By okwedook, 2 years ago, translation, In English1486A - Shifting Stacks

Hint1Hint2SolutionLet's consider the smallest amount of blocks we need to make the first i heights ascending. As heights are non-negative and ascending the heights should look like 0,1,2,3,...,i−1, so the minimum sum is (i−1)⋅i2. It turns out that this is the only requirement. If it's not the case for every prefix the answer is NO because we can't make some prefix ascending. Otherwise the answer is YES because you can move the blocks right till there is at least i blocks in the i-th stack and this would make the heights ascending.

Solution using C++: 107892022Solution using Python: 107892053

1486B - Eastern Exhibition

Hint1Hint2SolutionAt first let's see that the problem is not two dimensional. If we change the x coordinate the sum of distances by y is not changed at all. So we just need to calculate the number of good points on a line with points having coordinates x and then y and multiply the answers.

Now to calculate the answer on a line we could use a known fact: point with the smallest summary distance is between left and right median. So now we only need to sort the array and find the elements on positions ⌊n+12⌋ and ⌊n+22⌋ and return their difference plus one.

Solution using C++: 107892065Solution using Python: 107892085

1486C1 - Guessing the Greatest (easy version)

Hint1Hint2SolutionLet's solve for some subsegment [l,r) and mid=(l+r)/2. Now let's check if the max element is in [l,mid) or [mid,r). Let's find the second max element in [l,r) and call it smax. Now let's think that smax is less than mid (for symmetrical reasons). Now if we ask [l,mid) and second max is still smax it means that maximum element is in [l,mid), otherwise it's in [mid,r). Now we've shrunk the segment by a factor of two. So the resulting number of queries is 2⋅⌈log2105⌉=34.

Solution using C++: 107892097Solution using Python: 107892140

1486C2 - Guessing the Greatest (hard version)

Kudos to Aleks5d for proposing a solution to this subproblem.

Hint1Hint2Hint3SolutionLet's find second max smax. Now let's check if the max element is to the left, or to the right. Just ask [1,smax] and see if the answer is different to smax. Now let's suppose that the max element is to the right (for symmetrical reasons). Now we only need to find the smallest m such that the answer to the query [smax,m] is smax. The smallest such m is obviously the position of the maximum element. Now we need to use binary search to find such m. So the resulting number of queries is 2+⌈log2105⌉=19.

Solution using C++: 107892122Solution using Python: 107892144

1486D - Max Median

Hint1Hint2Hint3SolutionLet's binary search the answer. Now let's check if the answer is at least x. Replace all values that are at least x with 1 and values that are less than x with −1. Now if for some segment the median is at least x if the sum on this subsegment is positive! Now we only need to check if the array consisting of −1 and 1 has a subsegment of length at least k with positive sum. So let's just calculate prefix sums of this array and for prefix sum at position i choose the minimum prefix sum amongst positions 0,1,...,i−k, which can be done using prefix minimum in linear time.

So the resulting complexity is O(nlogn).

Solution using C++: 107892153Solution using Python: 107892163

1486E - Paired Payment

Hint1Hint2Hint3SolutionLet's think about it this way. For a middle vertex we only care what are the weights of the edges that pass through it. Now for every vertex v let's create some fake vertices (v,w), where w is the weight of the last edge. This would add at most O(M) new vertices. Now for each starting edge (u,v,w) let's make an edge u→(v,w) of weight 0 and for each vertex (u,was) and edge (u,v,w) let's create an edge (u,was)→v with weight (was+w)2. Now running Dijkstra's algorithm from vertex 1 will result for correct answers for all vertices (as we've simulated the paired edge situation with fake vertices and edges). Also we wouldn't create more than O(M⋅maxW) edges cause if some vertex has degree t we would create no more than t⋅maxW edges and sum of all t is 2⋅M.

Carefully implemented this would result in O(M⋅maxW⋅logM) or O(M⋅maxW+MlogM) time and O(M⋅maxW) or O(M) memory. All of those were fine.

Solution using C++: 107892178

1486F - Pairs of Paths

Hint1Hint2Hint3SolutionLet's root the tree at some vertex. Now the intersection vertex is lca for at least one path.

ProofIf the vertex wasn't lca for both paths it would mean that there are either two edges going up (which is impossible in a rooted tree) or they are going up by the same edge, but this would mean that this vertex parent is also an intersection point, so the paths are intersecting in at least 2 points, so this is impossible too.

Now there are two types of intersections: with the same lca and different lca. Let's count them independently.

For each path and it's lca let's find the subtrees that path goes to from lca. This would result in a triplet (lca,subtree1,subtree2) (replace subtree with −1 if there is none) with subtree1<subtree2 or both of them are −1.

Now to count the intersections of the first type let's use inclusion-exclusion principle. Remember all paths that have same lca. Now we need to calculate the number of pairs so that they have different subtree1 and subtree2 (or −1). The formula is going to be cntpath⋅(cntpath−1)/2−∑(cnt(subtree1,x)+cnt(x,subtree2)−(cnt(subtree1,subtree2)+1))/2 (from inclusion-exclusion principle) where cntpath is the number of paths with this lca and cnt(x,y) is the number of paths with triplet (lca,x,y). The situation with −1 is pretty similar, left as an exercise to the reader.

Finding the number of intersections of second type is a bit easier. We just need to calculate the number of all intersections between a path with fixed lca and a vertical path which crosses this lca (the path is not neccessarily vertical, but it contains both lca and it's parent) and then subtract cnt(subtree1) and cnt(subtree2), where cnt(x) is the number of vertical paths that go into subtree x.

After that we just have to print out the sum of this two numbers. Counting all the needed functions can be done using some data structure (small-to-large for example) or some subtree dynamic programming.

The resulting complexity is O(Mlog2M) or O(MlogM) or even O(M) if you're strong enough.

Solution using C++: 107892186

Codeforces Round #702 (Div. 3) Editorial

By Stepavly, 2 years ago, translation, In English1490A - Dense Array

Problem author: MikeMirzayanov

Editorial1490A - Dense ArrayNote that adding elements between positions i (1≤i≤n−1) and i+1 will not change the ratio of the adjacent elements, except for the ones just added. Therefore, for each pair of adjacent numbers, the problem can be solved independently.

Let us solve the problem for a adjacent pair of numbers ai and ai+1 for which the inequality from the statements does not hold. Suppose that 2ai≤ai+1 (if not, we will swap them). Then between ai and ai+1 it requires to insert ⌈log2(ai+1ai)−1⌉ elements of the form:2ai,4ai,...,2⌈log2(ai+1ai)−1⌉aiIt is better not to use explicit formula, but to use the following cycle:

while a[i] * 2 < a[i + 1]:  a[i] *= 2  ans += 1Solution1490B - Balanced Remainders

Problem author: MikeMirzayanov

Editorial1490B - Balanced RemaindersNote that the numbers in the a array are not important to us, so initially we will calculate the values of c0, c1, c2. Now applying a move for the number ai is equivalent to:

decreasing cai mod 3 by 1;and increasing c(ai+1) mod 3 by 1;We will perform the following greedy algorithm:

while the array a have no balanced remainders, find any i (0≤i≤2) such that ci>n3;we apply the move for ci, that is, replace ci with ci−1, and c(i+1) mod 3 with c(i+1) mod 3+1.It is easy to prove the correctness of this greedy algorithm by cyclically shifting the values c0, c1, and c2 so that the first element is equal to the maximum of them.

Solution1490C - Sum of Cubes

Problem author: MikeMirzayanov

Editorial1490C - Sum of CubesIn this problem, we need to find a and b such that x=a3+b3 and a≥1,b≥1.

Since a and b are positive, a3 and b3 are also positive. Hence a3≤a3+b3≤x. Therefore, the number a can be iterated from 1 to x−−√3. Since in all tests x≤1012, then a≤104.

For each a , you can find b by the formula b=x−a3−−−−−√3. This is a positive number. It remains to check that b is an integer.

Solution1490D - Permutation Transformation

Problem author: MikeMirzayanov

Editorial1490D - Permutation TransformationWe will construct the required tree recursively. Let us describe the state of tree construction by three values (l,r,d), where [l,r] — is the segment of the permutation, and d — is the current depth. Then the following transitions can be described:

find the position m of the maximum element on the segment [l,r], that is, am=maxi=lrai;the depth of the vertex am is equal to d;if l<m, then make the transition to the state (l,m−1,d+1);if m<r, then make the transition to the state (m+1,r,d+1);Then, in order to construct the required tree, it is necessary to take (1,n,0) as the initial state.

Solution1490E - Accidental Victory

Problem authors: Stepavly, Supermagzzz

Editorial1490E - Accidental VictoryHow can a player be checked if he can win the championship? Obviously, he must participate in all the games (otherwise we will increase the number of tokens of the opponents). So you can sort out all the people and play greedily with the weakest ones. Such a check will work in linear time after sorting, so we got a solution for O(n2).

The simplest solution to this problem is — binary search for the answer. We will sort all the players by the number of tokens they have. Let's prove that if player i can win, then player i+1 can also win (the numbers are dealt after sorting). If the player i was able to win, then based on the strategy above, he was able to defeat all the players on the prefix [0…i+1]. The player i+1 can also defeat all these players since he has at least as many tokens. Now both players have to defeat all opponents with numbers [i+2…n] and the number of chips both players have is equal to the sum of the first i+1 numbers in the array. So if the player i has a strategy, then the player i+1 can use the same strategy.

Hence the answer to the problem is — sorted suffix of the input array. You can find this suffix using binary search and linear time checking.

Bonus: this problem also has a fully linear (after sorting) solution.

Solution1490F - Equalize the Array

Problem author: MikeMirzayanov

Editorial1490F - Equalize the ArrayLet's calculate the value of cntx — how many times the number x occurs in the array a. We will iterate over the value of C and look for the minimum number of moves necessary for each number to appear in the a array either 0 times, or C times. Note that if there is no such number y that cnty=C, then such a value of C will not give the minimum answer (because we have removed unnecessary elements).

Then, for a specific C, the answer is calculated as follows:∑cntx<Ccntx+∑cntx≥C(cntx−C)Since the number of candidates for the value of C is no more than n, this method works in O(n2).

Then there are two ways to optimize our solution:

you can consider only unique values of C (there are no more than O(n−−√)), and get a solution in O(nn−−√);you can sort the values cntx and use prefix sums, this solution works for O(nlogn) or for O(n) (if you use counting sort).Solution1490G - Old Floppy Drive

Problem authors: Stepavly, Supermagzzz, MikeMirzayanov, sodafago

Editorial1490G - Old Floppy DriveLet's denote for S the sum of all the elements of the array, and for pref the array of its prefix sums.

If the drive runs for t seconds, the sum is ⌊ts⌋⋅S+pref[tmodn].

This formula immediately shows that if maxi=0n−1pref[i]<x and S≤0, then the disk will run indefinitely. Otherwise, the answer exists.

The disk cannot make less than, ⌈x−maxi=0n−1pref[i]S⌉ full spins, otherwise the required amount simply will not be achived. The disk can't make more spins either, because when it reaches the position of the maximum prefix sum, x will already be achived. So we know how to determine the number of full spins of the disk. Let's make these spins:x:=x−⎡⎢⎢⎢⎢⎢x−maxi=0n−1pref[i]S⎤⎥⎥⎥⎥⎥⋅S.

Now we have a new problem, given x, find the first position i in the array, such that pref[i]≥x. This problem can be solved using binary search. If pref is not sorted into the array, that is, there is j, such that pref[j−1]>pref[j], then pref[j] can simply be thrown out of the array (the answer will never be reached on it).

Solution

Editorial of Codeforces Round #701 (Div. 2)

By TheScrasse, history, 2 years ago, In English1485A - Add and Divide

Author: TheScrassePreparation: MyK_00L

Hint 1Hint 2Hint 3SolutionNotice how it is never better to increase b after dividing (⌊ab+1⌋≤⌊ab⌋).

So we can try to increase b to a certain value and then divide a by b until it is 0. Being careful as not to do this with b<2, the number of times we divide is going to be O(loga). In particular, if you reach b≥2 (this requires at most 1 move), you need at most ⌊log2(109)⌋=29 moves to finish.

Let y be the number of moves of type 2; we can try all values of y (0≤y≤30) and, for each y, check how many moves of type 1 are necessary.

Complexity: O(log2a).

If we notice that it is never convenient to increase b over 6, we can also achieve a solution with better complexity.

Official solution: 107232596

1485B - Replace and Keep Sorted

Author: TheScrassePreparation: Kaey

Hint 1Hint 2Hint 3Hint 4SolutionLet's consider each value x from 1 to k.

If x<al, you can replace al with x (and you get 1 k-similar array). There are al−1 such values of x.If x>ar, you can replace ar with x (and you get 1 k-similar array). There are k−ar such values of x.If al<x<ar, and x≠ai for all i in [l,r], you can either replace the rightmost bi which is less than x, or the leftmost bi which is greater than x (and you get 2 k-similar arrays). There are (ar−al+1)−(r−l+1) such values of x.If x=ai for some i in [l,r], no k-similar arrays can be made.The total count is (al−1)+(k−ar)+2((ar−al+1)−(r−l+1)), which simplifies to k+(ar−al+1)−2(r−l+1).

Complexity: O(n+q).

Official solution: 107232462

1485C - Floor and Mod

Authors: isaf27, TheScrassePreparation: Kaey

Hint 1Hint 2SolutionWe can notice that, if ⌊ab⌋=a mod b=k, then a can be written as kb+k (b>k). Since b>k, we have that k2<kb+k=a≤x. Hence k≤x−−√.

Now let's count special pairs for any fixed k (1≤k≤x−−√). For each k, you have to count the number of b such that b>k, 1≤b≤y, 1≤kb+k≤x. The second condition is equivalent to 1≤b≤x/k−1.

Therefore, for any fixed k>0, the number of special pairs (a≤x; b≤y) is max(0,min(y,x/k−1)−k). The result is the sum of the number of special pairs for each k.

Complexity: O(x−−√).

Official solution: 107232416

1485D - Multiples and Power Differences

Author: TheScrassePreparation: MyK_00L

Hint 1Hint 2Hint 3SolutionBuild a matrix with a checkerboard pattern: let bi,j=720720 if i+j is even, and 720720+a4i,j otherwise. The difference between two adjacent cells is obviously a fourth power of an integer. We choose 720720 because it is lcm(1,2,…,16). This ensures that bi,j is a multiple of ai,j, because it is either 720720 itself or the sum of two multiples of ai,j.

Complexity: O(nm).

Official solution: 107232359

1485E - Move and Swap

Author: TheScrassePreparation: TheScrasse

Hint 1Hint 2Hint 3SolutionDivide the nodes in groups based on the distance from the root. Then, for each dist(1,i) in increasing order, calculate dpi — the maximum score that you can reach after dist(1,i) moves if there is a red coin on node i after step 3. You can calculate dpi if you know dpj for each j that belongs to the previous group. There are two cases:

if after step 2 the coin on node i is red, the previous position of the red coin is fixed, and the blue coin should reach either the minimum or the maximum aj among the j that belong to the same group of i;

if after step 2 the coin on node i is blue, there is a red coin on node j (dist(1,i)=dist(1,j)), so you have to maximize the score dpparentj+|aj−ai|.This can be done efficiently by sorting the ai in the current group and calculating the answer separately for aj≤ai and aj>ai; for each i in the group, the optimal node j either doesn't change or it's the previous node.Alternatively, you can notice that dpparentj+|aj−ai|=max(dpparentj+aj−ai,dpparentj+ai−aj), and you can maximize both dpparentj+aj−ai and dpparentj+ai−aj greedily (by choosing the maximum dpparentj+aj and dpparentj−aj, respectively). In this solution, you don't need to sort the ai.

The answer is max(dpi).

Complexity: O(n) or O(nlogn).

Official solution: 107232216

1485F - Copy or Prefix Sum

Author: TheScrassePreparation: TheScrasse

Hint 1Hint 2Hint 3SolutionFor each i, you can choose either ai=bi or ai=bi−∑i−1k=1ak. If ∑i−1k=1ak=0, the two options coincide and you have to avoid overcounting them.

This leads to an O(n2logn) solution: let dpi be a map such that dpi,j corresponds to the number of ways to create a hybrid prefix [1,i] with sum j. The transitions are dpi,j→dpi+1,j+bi (if you choose bi=ai, and j≠0), dpi,j→dpi+1,bi (if you choose bi=∑ik=1ak).

Let's try to get rid of the first layer of the dp. It turns out that the operations required are

move all dpj to dpj+bicalculate the sum of all dpj in some momentchange the value of a dpjand they can be handled in O(nlogn) with "Venice technique".

dp is now a map such that dpj corresponds to the number of ways to create a hybrid prefix [1,i] such that ∑ik=1ak−bk=j. Calculate the dp for all prefixes from left to right. if bi=ai, you don't need to change any value of the dp; if bi=∑ik=1ak, you have to set dp∑ik=1−bk to the total number of hybrid arrays of length i−1.

Complexity: O(nlogn).

Official solution: 107232144