Codeforces Round #600 (Div. 2) Editorial

By hugopm, 3 years ago, In English1253A - Single PushIf we set di=bi−ai, we have to check that d has the following form: [0,0,…,0,k,k,…,k,0,0,…,0]. Firstly check that there is no negative element in d.

Solution 1 : add 0 to the beginning and the end of the array d, then check that there is at most two indices i such that di≠di+1.

Solution 2 : let l be the smallest integer such that dl≠0, and r be the greatest integer such that dr≠0. Check that for all l≤i≤r, di=dl.

Complexity : O(n) for each test case.

Implementation (solution 1)

1253B - Silly MistakeWe can solve this problem with a straightforward greedy solution: simulate the events in the order in which they occured, and as soon as the office is empty, end the current day and begin a new one.

We can prove that if there exists a valid solution, this greedy algorithm will find one (and furthermore, it will use maximum number of days, even if it wasn't required).

To do the simulation efficiently, we should maintain the state of each employee in an array (never went to the office today / in the office / left the office) and the number of employees currently in the office.

Each time we end a day, we have to reset all states of employees involved in the day (not all employees, otherwise the solution would be O(n2)).

Final complexity is O(n+e) where e is the number of employees, or O(n) if you compress the array beforehand.

Implementation

1253C - Sweets EatingLet's sort array a. Now we can easily that if Yui wants to eat k sweets, she has to eat sweets k,k−1,…,1 in this order, because of rearrangement inequality (put lower coefficients (day) on higher values (sugar concentration)).

A naive simulation of this strategy would have complexity O(n2), which is too slow.

Let's look what happens when we replace k by k+m. During the first day, Yui will eat sweets k+m,k+(m−1),…,k+1. Then, we reproduce the strategy used for xk, but one day late : all coefficients are increased by 1.

Formally, xk+m−xk=new+inc where new=(ak+m+…+ak+1) because of new sweets eaten and inc=(ak+…+a1) because the coefficient of these sweets are all increased by 1 (we eat them one day later).

We can derive the following formula : xk=(ak+ak−1+…+a1)+xk−m.

If we maintain the current prefix sum, and all previous answers computed in an array, we can compute all answers in O(n).

Final complexity is O(nlogn), because sorting is the slowest part of the solution.

Implementation

1253D - Harmonious GraphFor each connected component, let's find the weakest node l and the biggest node r in it (with one DFS per connected component).

If we look for all components at their intervals [l ; r], we can see that two components should be connected in the resulting graph if and only if their intervals intersect. This leads to a O(n2+m) naive solution : create a second graph where nodes represent components, add an edge between all pairs of components with intersecting intervals, and choose any spanning forest.

To optimize it, generate intervals in increasing order of l (starting DFS in increasing order of nodes numbers). Look at them in this order, maintaining the biggest end B seen. If l≤B, it is necessary to connect current interval to the interval ending at B (hence increment answer).

It is quite easy to prove that doing only these connections is also sufficient (i.e. resulting graph will be harmonious).

Final complexity is O(n+m).

Implementation

1253E - Antenna CoverageWe can add an antenna (x=0,s=0). It will not modifiy the answer, because it would be non-optimal to increase the scope of this antenna.

Let dpx be the minimum cost to cover all positions from x to m inclusive, knowing that position x is covered. We compute dp in decreasing order of x.

Base case is dpm:=0.

The default transition is dpx:=(m−x).

If position x+1 is initially covered, dpx:=dpx+1Otherwise, let's consider all antennas and their initial intervals [li;ri]. If x<li, let u=(li−x−1), then a possible transition is dpx:=u+dpmin(m,ri+u).

We take the minimum of all these transitions. Note that we always extend intervals as less as possible, but it's optimal because :

If after using this interval i, we use another interval j (at the right of i), the time spent to extend i could have been used to extend j instead, which will be more optimal.If i was the last interval used, we don't care because the default transition will take care of this case.The final answer will be dp0.

There are O(m) states and O(n) transitions, hence final complexity is O(nm) with very low constant. O(n2⋅m) can also get AC because of very low constant.

Implementation

1253F - Cheap RobotKey insight 1: Since we always end on a central, at any time our robot have to be able to reach the nearest central.

Key insight 2: Since we always start from a central, from any node u, going to the nearest central, then going back to u can't decrease the number of energy points in the battery.

—

Firstly, let's do a multi-source Dijkstra from all centrals. We denote du the distance from node u to the nearest central.

Consider a fixed capacity c. Suppose that we're on node u with x energy points remaining in the battery. Note that x≤c−du.

If x<du, we can't do anything, the robot is lost because it can't reach any central anymore.

Otherwise, if x≥du, we can go to the nearest central, then go back to u, hence we can always consider than x=c−du.

This is a simple but very powerful observation that allows us to delete the battery level in states explored. Hence, we can now solve the problem in O(mlogm+qmlogn), doing binary search on answer and simple DFS for each query.

—

We need to optimize this solution. Now, reaching a node u will mean reaching it with x≥du.

During exploration of nodes, the necessary and sufficient condition for being able to reach node v from u, through an edge of weight w, is that (c−du)−w≥dv, i.e. du+dv+w≤c.

Hence, if we replace the weight of each edge (u,v,w) by w′=du+dv+w, the problem is reduced to find a shortest path from ai to bi, in terms of maximum weight over edges used (which will be the capacity required by this path).

Solution 1 (offline):

Sort edges by new weight. Add them progressively, maintaining connexity with DSU.

As soon as two endpoints of a query become connected, we should put current capacity (i.e. new weight of the last edge added) as answer for this query.

To effeciently detect this, we can put tokens on endpoints of each query, and each time we do union (of DSU), we make tokens go up to the parent. If we do union by rank, each token will move at most O(logn) times.

Solution 2 (online):

Let's construct a MST of the new graph with Kruskal.

It is well-known that in this particular MST, for every pair of nodes (u,v), the only path from u to v will be a shortest path (in terms of maximum weight over the path).

Hence we just have to compute the weight of paths in a tree, which can be done with binary lifting.

These two solutions both run in O(mlogm+qlogn). Implementation of solution 1 is a bit shorter, but solution 2 can deal with online queries.

Solution 1 (hugopm)Solution 2 (faremy)

Codeforces Round #599 Editorial

By gen, history, 3 years ago, In English1243A - Maximum SquareThere are different solutions:

Solution 1: Bruteforce the length of the square l from 1 to n. If you can make a square of side length l, then there should be at least l planks of length at least l. The complexity of such solution: O(n2). The parameter l can be also checked using binary search: then the complexity becomes O(nlogn).

Solution 2: Suppose you want to take i planks and cut the largest square from them. Of course, it is always better to take the longest i planks. The side of the largest square that can be cut from them is bounded by the length of the smallest of these i planks and the number of the planks, i. Therefore, the solution is: sort the numbers ai in descending order; then the solution is max(min(i,ai)). The complexity: O(nlogn). Since the numbers ai are at most n, we can use counting sort and the complexity becomes O(n).

1243B1 - Character Swap (Easy Version)First, suppose that we make the strings equal by picking some i, j. Then for all p≠i,j, we must have sp=tp, since these letters don't change.

Suppose that i=j. Since the strings are distinct, we then must have si≠ti. But then the strings are not equal also after the swap; hence, we always need to pick distinct i and j.

Now, if i≠j and the strings are equal after the swap, we must have that si=sj, ti=tj and si,sj≠ti,tj. Therefore, the solution is as follows: if the number of positions where s and t differ is not equal to 2, the answer is "No". Otherwise we find the two positions i, j, where s and t differ, and check that the above conditions hold. Then the answer is "Yes". Complexity of the solution: O(n).

1243B2 - Character Swap (Hard Version)We claim that you can make the strings equal if and only if the total number of each character in both of the strings s and t is even.

Proof that this is a necessary condition. If we can make the strings equal, then for each position, the characters of s and t will be the same. Therefore, each character must appear an even number of times in both strings together.

Algorithm, if all characters appear even number of times. Iterate over the index i from 1 to n. If si≠ti, then one of the following cases holds:

There is an index j>i such that si=sj. Then simply swap sj with ti and then the strings will have the same character at position i.There is an index j>i such that si=tj. Then first swap tj with sj, and then swap sj with ti. Again, the strings will have the same character at position i.Since we make at most 2 swaps for each position, this algorithm produces two equal strings and makes at most 2n swaps in total. The complexity of the algorithm: O(n).This problem was introduced by [user:MikeMirzayanov] inspired by the easier version of the problem (with a single swap).

1242A - Tile PaintingIf n=pk for some prime p, then the answer is p colors. Simply color all tiles with indices i(modp) in color i. Since any divisor d of n greater than 1 is divisible by p, then any two tiles i and i+d will have the same color. Also, if the first p tiles are colored in c different colors, then each next p tiles have the same c colors, hence the answer cannot be greater than p.

If n=pq for some p,q>1 such that gcd(p,q)=1 then the answer is 1. Examine any two distinct indices i,j. Let's prove that they must have the same color. By the Chinese Remainder Theorem, there exists such 1≤x≤n that x≡i(modp) and x≡j(modq). Therefore, both tiles i and j must be colored in the same color as the tile x. Hence, all tiles must have the same color.

To check which case it is, we use the following algorithm:

First we check whether n is prime. We use the standard O(n−−√) algorithm.Otherwise, if n=pk for k>1, then p must be at most n−−√≤106. We can then find the smallest divisor p of n greater than 1, which is at most 106. Then we try to divide n by the largest power of p. If n=pk, then n will become simply 1; otherwise n will remain greater than 1, hence it is divisible by some prime other than p.Complexity: O(n−−√).1242B - 0-1 MSTFirst examine the given graph where there are only edges of weight 0: suppose that the number of connected components in this subgraph is k. Then the minimum spanning tree of the given graph is equal to k−1. Therefore, we need to find the number of such (zero weight) components in the given graph.

The following is a O(m+nlogn) solution. Let's maintain the zero weight components in the disjoint set union, and let's also store the size of each such component. Then we iterate over all vertices v from 1 to n. Put the vertex v in a new component of size 1. Then we iterate over the weight 1 edges {u,v} such that u<v. For each of the zero weight components, we count the number of edges from this component to v. If the number of such edges is less than the size of the component of u, we should merge the component of u with v (because there is at least one 0 weight edge between this component and v). Otherwise we should not merge the component with v. In the end, we get the number of zero weight components.

What is the complexity of such algorithm? In total, n new components are created in the course of the algorithm (a new one for each of the n vertices). When we merge some old component with v, the number of components decreases by 1. Thus the total number of such cases during the algorithm is at most O(n), and for each we have one merge call for DSU. This part has O(nlogn) complexity.

When we don't merge an old component with v, there is at least one edge of weight 1 from this component to v. Therefore, the total number of such cases is at most the number of edges, m. Thus the complexity of processing these cases is O(m).

Hence, the total complexity of the algorithm is O(nlogn+m).

1242C - Sum BalanceFirst, calculate the total average sum s:=(∑ni=1ai)/k. If the answer is positive, the sum of integers in each box must be equal to s after reordering. If s is not integer, then the answer is immediately negative.

Now, suppose that an integer x:=ai,p is taken out of some box i. Then we know that it should be replaced by y:=s−∑nij=1ai,j+ai,p. We then construct a graph where all of the given integers are vertices, and we draw a directed edge from x to y.

Note that we obtain a functional graph. Examine all of the cycles of this graph; since this a functional graph, no two cycles share the same vertex. Let n:=∑ki=1ni, then the total number of cycles is at most n≤15⋅5000=75000.

Examine any valid reordering. It is easy to see that it is a collection of cycles from the obtained graph such that each box is visited by some cycle exactly once. Therefore, lets extract all of the cycles from our graph such that do not pass through the same box twice. A valid reordering then is some subset of these cycles that visit all of the k boxes exactly once.

We can also reformulate this problem in the following way: each of the extracted cycles C visits some set of boxes S. Find all of such subsets S; the number of such subsets is at most 2k. Now, the problem is reduced to exactly covering the set {1,…,k} with some subset of such sets.

This is a classical problem that can be solved in O(3n) using dynamic programming. For a subset X of {1,…,k}, define dp[X] to be true if X can be exactly covered, and false otherwise. Firstly, dp[∅]=true. To find dp[X] for X≠∅, iterate over all subsets S of X, and check whether S is visited by some cycle and X∖S can be covered (e.g., dp[X∖S] is true). Then the answer is dp[{1,…,k}]. This algorithm can be implemented with complexity O(3k), you can read about it here:https://cp-algorithms.com/algebra/all-submasks.html. The reordering can be restored from this DP table.

The total complexity of the algorithm: O(k⋅∑ki=1ni+3k).

1242D - Number DiscoveryAnalysis by [user:McDic].

Let's make some definitions:

x is non-self number if x is appended into s by summation form. For example, if k=2, then 3,9,13,18,… are non-self numbers.x is self number if x is not non-self number.Let Ii=[(k2+1)⋅i+1,(k2+1)⋅i+2,…,(k2+1)⋅(i+1)]. In other words, Ii is i-th interval of positive integers with k2+1 size.Now let me introduce some strong lemma  — Every interval has exactly one non-self number. Furthermore, we can immediately determine the non-self number of Ik⋅i,Ik⋅i+1,Ik⋅i+2,…,Ik⋅i+k−1 using non-self number of Ii.

How is this possible? First, you can prove there is only 1 non-self number in I0. Now let's try induction. Suppose Ii has only 1 non-self number and each k numbers of k2 self numbers form summation, then you can describe generated summations as follows:

∑j=1k(i⋅(k2+1)+t⋅k+j)+offset=(k⋅i+t)⋅(k2+1)+k⋅(k+1)2−t+offsetWhere t means index of subintervals in Ii (0≤t<k) and offset means added offset into t-th subinterval (0≤offset≤k) since Ii's non-self number can be located at left or inside of t-th subinterval.

Using this fact, you can solve this problem in O(lognlogk) per test case. Some testers solved this problem by detecting pattern of distribution of non-self numbers.

1242E - Planar PerimeterIf there is just a single face, just output it. Suppose there are at least 2 faces.

Let's say that we "glue" a cycle to a planar graph along k edges if we place this cycle so that the graph and the cycle share k edges on their perimeters.

First, sort the numbers in decreasing order (then we have a1≥a2≥…≥an). By gluing any ai to the a1 cycle, we can decrease the number of edges by at most ai−2. Also note that the answer is always at least 3, because there cannot be multiple edges between two vertices. Thus, if a1−2≥∑ni=2(ai−2), then the answer is a1−∑ni=2(ai−2) (we subtract 2 from a1 to keep the perimeter at least 3: these are the 2 edges that we don't glue anything to).

Otherwise the answer is either 3 or 4 (depending on the parity of ∑ni=1ai). The algorithm to construct the graph: let C:=a1. Iterate i from 2 to n. While (C−2)+(ai−2)<∑nj=i+1(aj−2), glue the i-th cycle with the graph along one edge (C+=(ai−2)). For the first ai such that this does not hold, glue it so that ∑nj=i+1(aj−2)≤C−2≤∑nj=i+1(aj−2)+1. Afterwards just glue each remaining cycles aj along aj−1 edges with the graph.

There is one problem with this algorithm: it can happen that we add multiple edges between two vertices. This situation is as follows: suppose you are at some point of the algorithm with a planar graph that you're building. Suppose there is an edge between some vertices u and v on the current perimeter, and you now happen to glue a cycle C along the edges between u and v, and the last edge of the cycle C you're gluing must connect u and v. To solve this situation, take the vertex u′ adjacent to u to the right on the perimeter, and the vertex v′ adjacent to v also to the right on the perimeter. Now, u′ and v′ cannot be connected by an edge in the current graph, because then it would intersect the edge between u and v. This would be a contradiction, because the graph is planar. Then you glue the cycle C along the edges between u′ and v′.

The complexity of the algorithm: O(∑ni=1ai). You should be careful with the implementation: for example, not to make perimeter equal to 2 at some point or use some edge in more than two faces.

Codeforces Round #598 (Div. 3) Editorial

By vovuh, history, 3 years ago, In English1256A - Payment Without Change

Idea: MikeMirzayanov

Tutorial1256A - Payment Without ChangeFirstly, we obviously need to take at least S%n coins of value 1. If we cannot do it, the answer it NO. Otherwise we always can obtain the required sum S if a⋅n+b≥S.

Solution1256B - Minimize the Permutation

Idea: vovuh

Tutorial1256B - Minimize the PermutationThe following greedy solution works: let's take the minimum element and move it to the leftmost position we can. With this algorithm, all forbidden operations are form the prefix of operations: (1,2), (2,3), ..., and so on. So we can carry the position of the leftmost operation we can perform pos. Initially, it is 1. We repeat the algorithm until pos≥n. Let's find the position of the minimum element among elements apos,apos+1,…,an. Let this position be nxt. If nxt=pos then let's increase pos and continue the algorithm. Otherwise, we need to move the element from the position nxt to the position pos and then set pos:=nxt.

Time complexity: O(n2).

Solution1256C - Platforms Jumping

Idea: MikeMirzayanov

Tutorial1256C - Platforms JumpingThis problem has a very easy idea but requires terrible implementation. Firstly, let's place all platforms as rightmost as we can. Thus, we will have the array, in which the first n−∑i=1mci elements are zeros and other elements are 1, 2, ..., m.

Now, let's start the algorithm. Firstly, we need to jump to the position d or less. If we could jump to the position d then we don't need to jump to some position to the left from d. But if we cannot do it, let's take the leftmost platform to the right from the position d and move it in such a way that its left border will be at the position d. Now we can jump to the position d and then jump by 1 right to reach the position d+c1−1. Let's repeat the same algorithm and continue jumping.

If after some move we can jump to the position at least n+1 then we are done.

Time complexity: O(n2) but I'm sure it can be implemented in O(nlogn) or O(n).

Solution1256D - Binary String Minimizing

Idea: MikeMirzayanov

Tutorial1256D - Binary String MinimizingThis problem has a very standard solution: let's take the leftmost zero, place it as left as possible, and solve the problem without this zero and all operations we spent.

But we should do it fast. Let's go from left to right and carry the number of ones on the prefix cnt. If we meet 1, let's just increase cnt and continue the algorithm. It is obvious that if we meet 0 we need to make exactly cnt swaps to place it before all ones. If we can do it, let's just add 0 to the answer, decrease k by cnt and continue. Otherwise, this zero will be between some of these cnt ones and we can place it naively. In this case, the suffix of the string will not change. If after all operations we didn't meet the case above, let's add all ones to the suffix of the resulting string.

Time complexity: O(n).

Solution1256E - Yet Another Division Into Teams

Idea: MikeMirzayanov

Tutorial1256E - Yet Another Division Into TeamsLet's sort all students by their programming skills but save the initial indices to restore the answer.

Now we can understand that we don't need to compose the team of size greater than 5 because in this case we can split it into more teams with fewer participants and obtain the same or even less answer.

Now we can do the standard dynamic programming dpi — the minimum total diversity of the division if we divided the first i students (in sorted order). Initially, dp0=0, all other values of dp are +∞. Because of the fact above, we can do only three transitions (0-indexed):

dpi+3=min(dpi+3,dpi+ai+2−ai);dpi+4=min(dpi+4,dpi+ai+3−ai);dpi+5=min(dpi+5,dpi+ai+4−ai).The answer is dpn and we can restore it by standard carrying parent values (as a parent of the state we can use, for example, the number of participants in the team).

Solution1256F - Equalizing Two Strings

Idea: vovuh

Tutorial1256F - Equalizing Two StringsThe necessary condition to make strings equal is that the number of occurrences of each character should be the same in both strings. Let's show that if some character appears more than once, we always can make strings equal. How? Let's sort the first string by swapping adjacent characters (and it does not matter what do we do in the second string). Then let's sort the second string also by swapping adjacent characters but choose the pair of adjacent equal characters in the first string (it always exists because the first string is already sorted).

Otherwise, all characters in both strings are distinct and they lengths are at most 26. Then the answer is YES if the parity of the number of inversions (the number inversions in the array a is the number of such pairs of indices i,j that i<j but ai>aj) are the same. It can be proven in the following way: every swap of two adjacent elements changes the parity of the number of inversions.

Time complexity: O(max(n,AL2)).

Solution

Codeforces Round #597 (Div. 2) Editorial

By DeliciousFlatChest, history, 3 years ago, In English1245A - Старая добрая раскраска чисел

Tutorial1245A - Good ol' Numbers ColoringIf gcd(a,b)≠1, print "Infinite". This is correct because any integer that isn't divisible by gcd(a,b) will not be expressible in the form ax+by since ax+by is always divisible by gcd(a,b).

Otherwise, print "Finite". To show that this is correct, we will prove that any integer greater than ab is colored white. Let x be an integer greater than ab. Consider the set S={x,x−a,x−2a,…,x−(b−1)a}. If, for any y∈S, y is divisible by b, we are done. Otherwise, by the pigeonhole principle, there exists distinct x−sa,x−ta∈S such that they have the same remainder when divided by b, thus b divides (x−sa)−(x−ta)=a(t−s). WLOG, let s<t. Thus, 0<t−s and b divides t−s, since gcd(a,b)=1. But t−s≤t<b. However, it is not possible for b to divide any integer x such that 0<x<b, thus we arrive at a contradiction.

Solution1245B - Камень-ножницы-бумага с ограничениями

Tutorial1245B - Restricted RPSLet A, B, C be the number of rocks, papers, and scissors in Bob's sequence, respectively. It is easy to see that Alice can win at most w:=min(A,b)+min(B,c)+min(C,a) hands.

So if 2w<n, Alice can't win.

Otherwise, Alice can always win. One way to construct a winning sequence of hands for Alice is as follows:

Create a sequence of length n.For Bob's first min(A,b) rock hands, put a paper hand in the corresponding position in our sequence.For Bob's first min(B,c) paper hands, put a scissors hand in the corresponding position in our sequence.For Bob's first min(C,a) scissors hands, put a rock hand in the corresponding position in our sequence.Just fill in the other elements of the sequence by the remaining hands that Alice has.By construction, Alice uses exactly a rock hands, b paper hands, and c scissors hands. Also, Alice beats Bob exactly w times. Since 2w≥n, Alice wins.

Solution1245C - Аппарат Констанции

Tutorial1245C - Constanze's MachineIf s has any 'm' or 'w', the answer is 0. Otherwise, we can do dp.

Define dpi to be the number of strings that Constanze's machine would've turned into the first i characters of s. Then, dp0=dp1=1. For i>1, transition is dpi=dpi−1+dpi−2 if both si=si−1 and si is either 'u' or 'n', and simply dpi=dpi−1 otherwise. Answer is dp|s|.

Alternatively, notice that the maximum cardinality segment consisiting of k letters 'u' or 'n' multiplies the answer by the k-th term of Fibonacci sequence. Thus, you can precalculate it and some sort of two iterators.

SolutionSolution (Arpa)1245D - Шичикуджи и электросеть

Tutorial1245D - Shichikuji and Power GridClaim. Let i be such that ci is minimum, then there is an optimal configuration with a power station in City i.

Proof. Consider an optimal configuration. Let's say that City u and City v are in the same component if they are connected or City v is connected to a City w such that City w is in the same component as City u. Consider the cities that are in the same component as City i. Exactly one of these cities have a power station, since having a power station in one of these cities is enough to provide electricity to all of them. Let City j be the one with a power station. If i=j, then we are done. Otherwise, there are three cases: ci<cj, ci=cj, ci>cj. The first case leads to a contradiction since having a power station in City i would be more optimal. The third case also leads to a contradiction since ci is minimum. For the remaining case, having a power station in City i would be just as optimal.

Let i be such that ci is minimum. Build a power station in City i. For j≠i, define Cj:=min(cj,(ki+kj)⋅D(i,j)) where D(i,j) is the manhattan distance between City i and City j. Notice that the problem has been reduced to a similar problem, except that there is one less city, and c values have been changed to the corresponding C values. Thus, we can keep reducing until there are no cities left.

Alternatively, you can think of it the following way. Let's call a connection between City u and City v, an undirected edge (u,v) with the weight (ku+kv)⋅D(u,v). Create a dummy City 0 and connect each City u to it with an edge (0,u) with the weight cu. The problem now is to find a minimal spanning tree of this graph. Prim's algorithm can do this in O(n2).

SolutionSolution (PikMike)1245E - Хиякугоку и лестницы

Tutorial1245E - Hyakugoku and LaddersTo make implementation easier, flatten the board into an array a such that the i-th tile on the path is ai. Define a function f as follows: f(i)=i if ai has no ladder, otherwise f(i)=j where j is such that the ladder from ai leads to aj. Then, do dp.

Define dpi to be the minimum expected number of turns before the game ends when the player is at ai. Then, dp100=0 since a100 is the Goal. Next, use the formula dpi=1+∑6r=116⋅min(dpg(i,r),dpf(g(i,r))) where g(i,r)=i+r if i+r≤100 and g(i,r)=i otherwise. Thus, for 95≤i≤99, transition should be dpi=6100−i⋅(1+∑100−ir=116⋅min(dpi+r,dpf(i+r))). And for i<95, transition is the same as the formula. Answer is dp1.

Alternatively, instead of doing dp, we can use numerical methods. Initialize expected100=0 and expected1=expected2=⋯=expected99=1. Then, repeat the following several times: from i=99 to i=1, assign 1+∑6r=116⋅min(expectedg(i,r),expectedf(g(i,r))) to expectedi. After each iteration, expected1 will get closer to the answer. For this problem, 1000 iterations is more than enough to get AC using this method.

Solution1245F - Даниэль и весенняя уборка

Tutorial1245F - Daniel and Spring CleaningClaim. Let x, y be nonnegative integers. If x+y=x⊕y, then x∗y=0, where x∗y is the bitwise AND of x and y.

Proof. Recall that bitwise XOR is just addition in base two without carry. So if addition is to be equal to addition in base two without carry, then there must be no carry when added in base two, which is what we wanted.

Define a function f as follows: let l and r be nonnegative integers, then f(l,r) should be the number of pairs of integers (x,y) such that the following conditions are satisfied:

l≤x<rl≤y<rx+y=x⊕yNotice that f(0,r)=2r−1+f(1,r).

Claim. Let l and r be positive integers. Then, f(2l,2r)=3⋅f(l,r).

Proof. Let x, y be positive integers. Suppose we want the following conditions to be satisfied:

2l≤x<2r2l≤y<2rx+y=x⊕yConsider the binary representations of x and y. There are three ways to choose the rightmost bits of x and y: (0,0), (0,1), and (1,0). And the number of ways to choose the other bits is always f(l,r). Thus, f(2l,2r)=3⋅f(l,r).What if l and r are not both even? Define a function g as follows: let x and n be nonnegative integers, then g(x,n) should be the number of integers y such that the following conditions are satisfied:

0≤y<nx+y=x⊕yThen, if l is odd, f(l+1,r)=f(l,r)−2⋅(g(l,r)−g(l,l)), or f(l,r)=f(l+1,r)+2⋅(g(l,r)−g(l,l)). Similarly, if r is odd, f(l,r−1)=f(l,r)−2⋅(g(r−1,r)−g(r−1,l), or f(l,r)=f(l,r−1)+2⋅(g(r−1,r)−g(r−1,l)).Now all that remains is to implement g efficiently. Define a function LSB as follows: let n be a positive integer, then LSB(n) should be the least significant 1-bit of n. Next, define a function h as follows: let x and n be positive integers, then h(x,n) should be the number of integers y such that the following conditions are satisfied:

n−LSB(n)≤y<nx+y=x⊕yThen, g(x,n)=h(x,n)+g(x,n−LSB(n)) if n>0 and g(x,n)=0 otherwise. Moreover, it is easy to implement h so that its time complexity is logarithmic with respect to n.Solution

Technocup 2020 — Elimination Round 2 + Codeforces Round 596: analysis

By Endagorion, history, 3 years ago, translation, In English1225A - Forgetting ThingsThe answer exists only if da=db, db=da+1, or da=9 and db=1. Alternatively, one could simply check all a up to 100 (or another reasoable bound).

1225B1 - TV Subscriptions (Easy Version)We are looking for a segment of length d with the smallest number of distinct values. In small limitations one could just try all segments and count the number of distinct elements naively (for example, by sorting or with an std::set).

1225B2 - TV Subscriptions (Hard Version)In larger limitations we have to use two pointers to maintain the number of distinct elements between segments. We can store a map or an array that counts the number of occurences of each element, as well as the number of distinct elements (i.e. the number of non-zero entries in the map). Moving the segment to the right involves changing two entries of the map, keeping track of which entries become/cease to be non-zero. The complexity is O(nlogn) or O(n) (both are acceptable).

1225C - p-binarySuppose we want to represent n as the sum of k p-binary numbers. We must have n=∑ki=1(2xi+p) for a suitable choice of x1,…,xk. Moving all p's to the left-hand side, we must have n−kp=∑ki=12xi. In particular, n−kp has to be at least k.

Consider the binary representation of n−kp. If it has more than k bits equal to 1, there is no way we can split it into k powers of two. Otherwise, we can start by taking the binary representation, and if it contains less than k powers, we can always split larger powers into two smaller ones.

We can now check all values of k starting from the smallest. If n≥31p+31, then the answer will not exceed 31 since n−31p is less than 231, hence is always representable with 31 powers. Otherwise, we have n−31(p+1)<0. Since n>0, it means that p+1<0, and n−kp<k for all k>31, thus the answer does not exist.

1225D - Power ProductsSuppose that x⋅y is a k-th power. The sufficient and necessary condition for that is: for any prime p, the total number of times it divides x and y must be divisible by k.

Let us factorize each number ai=pb11…pbmm, and associate the list of pairs Li((p1,b1modk),…,(pm,bmmodk)), omitting the entries with bimodk=0. For example, for 360=232251 and k=2, the corresponding list would be ((2,1),(5,1)).

If ai⋅aj is a k-th power the the primes in the respective lists should match, and bimodk add up to k for corresponding primes. Indeed, if a prime is absent from one of the lists (i.e. the exponent is divisible by k), then it should be absent from the other list too. Otherwise, the total exponent for this prime should be divisible by k, hence the remainders should add up to k.

We now have that for every ai there is a unique possible list L′i for the other number that would give a k-th power product. We can now maintain the count for each of the occuring lists (e.g. with std::map), and every number we meet we add the number of occurences of L′i to the answer, and increase the count for Li by one.

The total complexity comprises of factoring all the input numbers (in O(maxai−−−−−√) or in O(logmaxai) with precomputed sieve), and maintaining a map from vectors to numbers. The total size of all vectors is roughly O(nlogn), so the complexity of maintaining a map is O(nlog2n), or O(nlogn) with a hashmap.

1225E - Rock Is PushLet us compute Ri,j and Di,j – the number of legal ways to reach the goal assuming:

we've arrived at the cell (i,j);our next move is right/down respectively;our previous move (if there was a previous move) was not in the same direction.By definition, let us put Dn,m=Rn,m=1.

We can see that all rocks reachable from (i,j) in these assumptions should be in their original places, thus the answer is independent of the way we've reached the cell (i,j) in the first place.

Recalculation is fairly straightforward. For example, for Di,j let k be the number of stones directly below (i,j). We can make at most n−k−i moves before we make the turn to the right, thus we have Di,j=∑n−k−it=1Ri+t,j. This allows to compute Ri,j and Di,j with dynamic programming starting from the cells with larger coordinates.

The formula hints at some range summing techniques, like computing prefix sums or maintaing a more sophisticated RSQ structure. However, these are not needed in this problem. Indeed, as we consider summation ranges for Di,j and Di+1,j, we can see that they differ by at most one entry on each side. It follows that to compute Di,j, we can take Di,j and add/subtract at most two values of Ri+t,j. The values near the goal cell may need some extra treatment since they are not always a proper range sum. Also, the case n=m=1 need to be treated separately.

The total complexity is O(nm) (additional log for RSQ should be fine though).

1225F - Tree FactoryLet's solve the problem backwards: given a tree, transform it into a bamboo with reverse operations. A reverse operation in this context looks like this: given a vertex v and its two distinct children u and w, make w the parent of u.

What's the lower bound on the number of operations we need to make? We can see that the depth of the tree, i.e. the length of the longest vertical path starting from the root, can increase by at most one per operation. On the other hand, the depth of the bamboo is n−1. Therefore, we'll need to make at least n−1−(initial depth of the tree) operations.

This number would always be enough if for any non-bamboo tree we could find an operation that would increase its depth. And indeed we can: consider a longest path starting from the root. If all its vertices have at most one children, the tree is a bamboo and we are done. Otherwise, take any vertex v on the path with at least two children, its child u on the longest path, and any other child w, then make w the parent of u. One can see that there is a longer path now.

One efficient way to do these operations successively is to keep track of the lowest candidate for u. After applying an operation, the candidate is either u again, or one of its ancestors. With standard amortized analysis, we can now perform all these operations in O(n) time.

To output the answer, print the labelling of the final bamboo you obtain, followed by the reverse sequence of the operations you've made.

1225G - To Make 1An experienced eye will immediately spot a subset dynamic programming solution in roughly O(3n∑ai) time, but the time constraints will not allow this. What to do?

Suppose there is a way to obtain 1 in the end. Looking at how many times each initial number ai gets divided by k (including the divisions of the subsequent numbers containing it), we can obtain the expression 1=∑ni=1aik−bi, where bi are respective numbers of divisions. What if we were given such an expression to start with? Can we always restore a sequence of operations?

As it turns out, yes! Prove by induction. If there a single number, then it must be 1 and we are done. Otherwise, let B=maxbi. We argue that there are at least two numbers ai and aj with bi=bj=B. Indeed, assume there was only one such number aj. Multiply both sides of the expression to obtain kB=∑ni=1aikB−bi. The left-hand side, and all but one summand of the right-hand are divisible by k. But since aj is not divisible by k, the right-hand side is not divisible by k, a contradiction.

Since we have two numbers ai and aj, let's replace them with f(ai+aj)=a′, and put b′=B−(the number of times (ai+aj) is divisible by k). We can see that the new set of numbers still satisfies the expression above, hence by induction hypothesis we can always finish the operation sequence. Note that this argument can be converted into an answer restoration routine: given the numbers bi, group any pair of numbers ai and aj with bi=bj.

The question now becomes: can we find suitable numbers b1,…,bn such that the above expression is satisfied? We can do this with a more refined subset dynamic programming. For a subset S⊆{1,…,n} and a number x, let dpS,x be true if and only if we can have an expression x=∑i∈Saik−bi for suitable bi. The initial state is dp∅,0=1. The transitions are as follows:

include ai into S: dpS,x⟹dpS+ai,x+ai;increase all bi by 1: if x is divisible by k, then dpS,x⟹dpS,x/k.By definition, we can obtain 1 as the final number iff dp{1,…,n},1. Straightforward recalculation requires O(n2n⋅∑ai) time. However, the first type of transition can be optimized using bitsets, bringing the complexity down to O(2n∑ai⋅(1+n/w)), where w is the size of the machine word (32 or 64). To restore bi, trace back from dp{1,…,n},1 to dp∅,0 using reachable states.

1246F - Cursor DistanceAgain, it's easier to solve the problem backwards. For a character si, from which characters sj can we reach si in one step? Clearly, sj should lie in a subsegment of s bounded by adjacent occurences of si (inclusive), or by the borders of s. Let's denote this subsegment for si by [Li,Ri) (we will use half-open intervals for convenience, as should you).

Which characters can be reached from si in k reverse steps? We can see that these characters also form a subsegment, let's denote it [L(k)i,R(k)i). We have that [L(0)i,R(0)i)=[i,i+1), and [L(k)i,R(k)i)=∪j∈[L(k−1)i,R(k−1)i)[Lj,Rj).

Note that having values of [L(k)i,R(k)i) can be used to directly compute the answer, for example, with a formula ∑ni=1∑n−1k=0(n−(R(k)i−L(k)i)). This formula is correct since the expression inside the brackets is the number of characters not reachable from i in k reverse steps, hence a position j reachable in exactly d steps will be accounted for d times. Simplifying a bit, we arrive at the formula n3−∑ni=1∑n−1k=0(R(k)i−L(k)i).

Values of [L(k)i,R(k)i) can be computed in O(n2) individually by applying the above recurrence and using a sparse table, but that is still way too slow. It's tempting to try and use binary lifting, but as k grows, evolution of L(k)i and R(k)i is mutually dependent, and we can't store an n2-sized table. They do, however, become independent at some point, namely, when the range [L(k)i,R(k)i) contains all distinct letters present in s. Indeed, to compute R(k+1)i we simply need to take the largest Rj, where j ranges over the last occurences of letters a, …, z before R(k)i. Slightly more generally, we can treat the evolution of L(k)i and R(k)i independently in a range of k's where the number of distinct characters in the segment doesn't change. And it can only change at most α=26 times...

Time to put this together. For each i, we will store ki — the number of expansions we've applied to [L(k)i,R(k)i), as well as the range's endpoints themselves. We will iterate over the parameter t — the number of distinct characters in ranges we're going to expand now. For each right endpoint r, let's find fr(r) as the largest Rj over t closest distinct letters to the left of r; define fl(l) similarly. Additionally, compute binary lifts f2yr(r), f2yl(l), as well as the sums of r and l visited by each binary lift. Now, for each i we use binary lifting to find the largest number of iterations to apply to [L(k)i,R(k)i) so that the number of distinct characters in the range stays equal to t. Doing this, we can update ki and endpoints of [L(k)i,R(k)i) accordingly, as well as add a part of ∑ni=1∑n−1k=0(R(k)i−L(k)i) to the total. Thus, going into the next phase with t+1, we will have all necessary values up-to-date.

How fast does this work? For every t=1,…,α=26, we'll need O(nlogn) work to construct binary lifts and update everything. The total complexity is thus O(αnlogn).

Codeforces Round #595 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishAll ideas belong to MikeMirzayanov.

1249A - Yet Another Dividing into Teams

Tutorial1249A - Yet Another Dividing into TeamsThe answer is always 1 or 2. Why it is so? Because if there is no such pair i,j among all students that |ai−aj|=1 then we can take all students into one team. Otherwise, we can divide them into two teams by their programming skill parity.

Solution1249B1 - Books Exchange (easy version)

Tutorial1249B1 - Books Exchange (easy version)In this problem you just need to implement what is written in the problem statement. For the kid i the following pseudocode will calculate the answer (indices of the array p and its values are 0-indexed):

pos = p[i]ans = 1while pos != i:    ans += 1    pos = p[pos]Solution1249B2 - Books Exchange (hard version)

Tutorial1249B2 - Books Exchange (hard version)In this problem, we can notice that when we calculate the answer for the kid i, we also calculate the answer for kids pi, ppi and so on. So we can a little bit modify the pseudocode from the easy version to calculate answers faster:

pos = p[i]ans = 1cycle = [i]while pos != i:    cycle.append(pos)    ans += 1    pos = p[pos]for el in cycle: res[el] = ansAnd of course, we don't need to run this while for all elements for which we already calculated the answer. Total time complexity is O(n) because you'll process each element exactly once.

Solution1249C1 - Good Numbers (easy version)

Tutorial1249C1 - Good Numbers (easy version)As you can see from the example, the maximum answer doesn't exceed 2⋅104. So we can run some precalculation before all queries, which will find all good numbers less than 2⋅104. The number is good if it has no 2 in the ternary numeral system. When you read the next query, you can increase n until you find some precalculated good number. Time complexity is O(nq+nlogn).

You also can implement the solution which doesn't use any precalculations and just increase n each time in each query and checks if the number is good inside this loop. Then time complexity will be O(nqlogn).

Solution1249C2 - Good Numbers (hard version)

Tutorial1249C2 - Good Numbers (hard version)Let's see the representation of n in the ternary numeral system. If it has no twos, then the answer is n. Otherwise, let pos2 be the maximum position of 2 in the ternary representation. Then we obviously need to replace it with 0 and add some power of three to the right from it. Let pos0 be the leftmost position of 0 to the right from pos2. We can add 3pos0 and replace all digits from the position pos0−1 to the position 0 with 0. Then the resulting number will be good because we replaced all twos with zeros and the minimum because, in fact, we added only one power of three and this power is the minimum one we could add.

Time complexity is O(logn) per query.

Solution1249D1 - Too Many Segments (easy version)

Tutorial1249D1 - Too Many Segments (easy version)In this problem, the following greedy solution works: let's find the leftmost point covered by more than k segments. We should fix it somehow. How to do it? Let's find some segment that was not removed already, it covers this point and its rightmost end is maximum possible, and remove this segment.

You can implement it in any time you want, even in O(n3) naively.

Solution1249D2 - Too Many Segments (hard version)

Tutorial1249D2 - Too Many Segments (hard version)In this problem, we need to implement the same greedy solution as in the easy version, but faster. Firstly, let's calculate for each point the number of segments covering it. We can do it using standard trick with prefix sums: increase cntli, decrease cntri+1 and build prefix sums on the array cnt.

Let's maintain the set of segments that cover the current point, sorted by the right endpoint. We can do this with almost the same trick: append to the array evli the index i that says us that in the point li the i-th segment is opened. And add to the evri+1 the index −i that says us that in the point ri+1 the i-th segment is closed. Note that you need to add 1-indexed values i because +0 and −0 are the same thing actually. We can change the array cnt to carry the number of segments covering each point using some structure, but we don't need to do it. Let's maintain the variable curSub that will say us the number of segments covering the current point that was already removed. Also, let's carry another one array sub which will say us when we need to decrease the variable curSub.

So, we calculated the array of arrays ev, the array cnt and we can solve the problem now. For the point i, let's remove and add all segments we need, using the array evi and add subi to curSub. Now we know that the set of segments is valid, curSub is also valid and we can fix the current point if needed. While cnti−curSub>k, let's repeat the following sequence of operations: take the segment with the maximum right border rmax from the set, remove it, increase curSub by one and decrease subrmax+1 by one.

Note that when we remove segments from the set at the beginning of the sequence of moves for the point i, we don't need to remove segments that we removed by fixing some previous points, and we need to pay attention to it.

Time complexity: O(nlogn).

Solution1249E - By Elevator or Stairs?

Tutorial1249E - By Elevator or Stairs?This is easy dynamic programming problem. It is easy to understand that we don't need to go down at all (otherwise your solution will be Dijkstra's algorithm, not dynamic programming). Let dpi,0 be the minimum required time to reach the floor i if we not in the elevator right now and dpi,1 be the minimum required time to reach the floor i if we in the elevator right now.

Initially, all values dp are +∞, except dp1,0=0 and dp1,1=c.

Transitions are pretty easy:

dpi+1,0=min(dpi+1,0,dpi,0+ai) (we was not in the elevator and going to the next floor using stairs);dpi+1,0=min(dpi+1,0,dpi,1+ai) (we was in the elevator and going to the next floor using stairs);dpi+1,1=min(dpi+1,1,dpi,0+bi+c) (we was not in the elevator and going to the next floor using elevator);dpi+1,1=min(dpi+1,1,dpi,1+bi) (we was in the elevator and going to the next floor using elevator).The answer for the i-th floor is min(dpi,0,dpi,1).

Time complexity: O(n).

Solution1249F - Maximum Weight Subset

Thanks to neal for the additional editorial of this problem and providing the linear solution!

Tutorial1249F - Maximum Weight SubsetLet's solve this problem using dynamic programming on a tree. Suppose the tree is rooted and the root of the tree is 1. Also, let's increase k to find the subset in which any pair of vertices had distance k or greater instead of k+1 or greater.

Let dpv,dep be the maximum total weight of the subset in the subtree of v if the vertex with the minimum depth we took has depth at least dep. Then the answer is dp1,0.

Firstly, let's calculate this dynamic programming for all children of v. Then we are ready to calculate all dpv,dep for all dep from 0 to n.

Let the current depth be dep, then there are two cases: if dep=0 then dpv,dep=av+∑to∈children(v)dpto,max(0,k−dep−1). Otherwise, let's iterate over all children of v and let to be such child of v that the vertex with the minimum depth we took is in the subtree of to. Then dpv,dep=max(dpv,dep,dpto,dep−1+∑other∈children(v)∖{to}dpother,max(dep−1,k−dep−1).

After we calculated all values of dpv,dep for the vertex v, we can notice that this is not what we wanted. The current value of dpv,dep means the maximum total weight of the subset in the subtree of v if the vertex with the minimum depth we took has depth exactly dep. To fix this, let's push dpv,dep to dpv,dep−1 for all depths from n to 1.

Time complexity: O(n3) but it can be easily optimized to O(n2) using some prefix and suffix maximums.

You can ask, why this is O(n3) but not O(n4) because we iterating over all vertices, then over all possible depths, and then over children of the vertex, and again over children of the vertex. But in fact, this is O(n3) because if we change the order of multiplication, we can see that we are iterating over pairs (parent, child), then over children and possible depths, and the number of such pairs is O(n), so the complexity is O(n3).

Solution (Vovuh, n^3)Solution (PikMike, n^2)

Editorial of Codeforces Round #594 (on the problems of Moscow Team Olympiad)

By ch_egor, 3 years ago, translation, In EnglishThanks for the participation!

1248A - Integer Points was authored by voidmax and prepared by vintage_Vlad_Makeev.

1248B - Grow The Tree was authored by voidmax, cdkrot and prepared by wrg0ababd.

1239A - Ivan the Fool and the Probability Theory was authored and prepared by voidmax.

1239B - The World Is Just a Programming Task (Hard Version) was authored by vintage_Vlad_Makeev and prepared by DebNatkh.

1239C - Queue in the Train was authored by meshanya and prepared by Sehnsucht.

1239D - Catowice City was authored by platypus179 and prepared by budalnik.

1239E - Turtle was authored by voidmax and prepared by cdkrot.

1239F - Swiper, no swiping! was authored and prepared by voidmax.

1248A - Integer PointsConsider two lines y=x+p и y=−x+q:

{y=x+py=−x+q⇒{2y=p+qy=−x+q⇒{y=p+q2y=−x+q⇒{y=p+q2x=q−p2It's clear that they will have integral intersection point iff p and q have the same parity. Let's find p0 и p1 — number of even and odd pi respectively. Moreover let's find q0 and q1 for qi. Now answer is p0⋅q0+p1⋅q1. Complexity: O(n+m).

Pay attention that answer does not fit in 32-bit data type.

1248B - Grow The TreeAt first, let's do some maths. Consider having an expression a2+b2 which we have to maximize, while a+b=C, where C is some constant. Let's proof that the maximum is achieved when a or b is maximum possible.

At first let a or b be about the same, while a≥b. Let's see what happens when we add 1 to a and subtract 1 from b. (a+1)2+(b−1)2=a2+2a+1+b2−2b+1=a2+b2+2(a−b+1). Since a≥b, this expression is greater than a2+b2. It means that we should maximize a (or b, doing the same steps) in order to achieve the maximum of a2+b2.

Notice that we should always grow the tree in one direction. For definiteness, let horizontal sticks go from left to right and vertical from down to top. Now, answer equals to square of the sum of lengths of horizontal sticks plus square of the sum of lengths of vertical sticks. As we proved earlier, to maximize this expression, we should maximize one of the numbers under the squares.

Let's sort sticks by order and orient the half (and medium element if there's an odd amount of sticks) with the greater length vertically, and the other half horizontally.

Work time: O(nlogn)Bonus: can you solve this problem in O(n)?

1239A - Ivan the Fool and the Probability TheoryIf there is no adjecent cells with same color coloring is chess coloring.

Otherwise there is exist two adjecent cells with same color. Let's decide for which cells we already know their color.

It turns out that color rows or columns alternates. It means that this problem equal to the same problem about strip. Answer for the strip is 2Fn.

In this way the final answer is 2(Fn+Fm−1).

1248D1 - The World Is Just a Programming Task (Easy Version)Note first that the number of opening brackets must be equal to the number of closing brackets, otherwise the answer is always 0. Note that the answer to the question about the number of cyclic shifts, which are correct bracket sequences, equals the number of minimal prefix balances. For example, for string )(()))()((, the array of prefix balances is [-1, 0, 1, 0, -1, -2, -1, -2, -1, 0], and the number of cyclic shifts, 2 – the number of minimums in it (−2). Now we have a solution of complexuty O(n3): let's iterate over all pairs of symbols that can be swapped. Let's do this and find the number of cyclic shifts that are correct bracket sequences according to the algorithm described above.

1239B - The World Is Just a Programming Task (Hard Version)Note first that the number of opening brackets must be equal to the number of closing brackets, otherwise the answer is always 0. The answer for a bracket sequence is the same as the answer for any of its cyclic shifts. Then find i— index of the minimum balance and perform a cyclic shift of the string by i to the left. The resulting line never has a balance below zero, which means it is a correct bracket sequence. Further we will work only with it

Let us draw on the plane the prefix balances (the difference between the number of opening and closing brackets) of our correct bracket sequence in the form of a polyline. It will have a beginning at (0,0), an end — at (2n,0) and its points will be in the upper half-plane. It can easily be shown that the answer to the question of the number of cyclic shifts being correct bracket sequence is the number of times how much minimum balance is achieved in the array of prefix balances. For example, for string )(()))()((, the array of prefix balances is [-1, 0, 1, 0, -1, -2, -1, -2, -1, 0], and the number of cyclic shifts, 2 – the number of minimums in it (−2).

After swapping two different brackets (')' and '('), either on some sub-segment in an array of balances 2 is added, or on some sub-segment −2 is added.

In the first case (as you can see from the figure above), the minimum remains the same as it was — 0, and its number does not increase due to the addition of 2 to some sub-section of the array. So, there is no profit in swapping brackets in this case.

In the second case, there are three options: the minimum becomes equal to −2, −1 or 0. In the first case, the minimum reaches a value equal to −2 only at those points at which there was previously value equal to 0, so this answer will less or equal than the one that would have turned out, if no operations were applied to the array at all.

If the minimum becomes equal to −1, then on the segment in the balance array on which 2 was deducted as a result of this operation there could not be balances equal to 0, otherwise the new minimum would become equal to −2. So, if 0=X0<X1<⋯<Xk=2n — positions of minimums in the array of prefix balances, then the operation −2 was performed on the segment [L,R] (Xi<L≤R<Xi+1 for some i). After this operation, the number of local minimums will be equal to the number of elements of the array of balance on the segment [L;R], equal to 1. Since this number shall be maximized, the right border swall be maximised and the left border shall be minimised. So, for some fixed i it is optimal to swap Xi-th and Xi+1−1-th brackets (see following figure)

If the minimum remains equal to 0, then using the reasoning similar to the reasoning above, it can be proven that for some i if we consider points Xi+1=Y0<Y1<⋯<Ym=Xi+1−1 — positions of 1 in the array of balances on the segment [Xi;Xi+1], it is optimal for some j to swap Yj and Yj+1−1 brackets (see following figure)

Thus, we have the solution of O(n) complexity — we shall find all Xi, Yi and count on each of the segments of the form [Xi;Xi+1] or [Yi;Yi+1] the number of elements equal to 0, 1, 2, then according to reasonings above, maximal answer can be found.

1239C - Queue in the TrainThe problem can be solved easily with an abstraction of "events". Let's define an "event" as a tuple of variables (time,type,index), where index is the index of the passenger (1≤index≤n), time is the time when the event will happen, type is either 0 (the passenger exits the queue) or 1 (the passenger wants to enter the queue).

To simulate the activity described in the problem it's necessary to handle events in sorted order. At the start there are n events (ti,1,i), where 1≤i≤n. While there are any unprocessed events, we take the "smallest" event and process it. Event (a,b,c) is "smaller" than event (d,e,f) either if (a<d) or (a=d and b<e) or (a=d and b=e and c<f).

Let's define a few sets: want (the set of passengers who want to enter the queue), in_queue (the set of passengers who are in the queue); and a few integer variables: queue_time (the time when the queue becomes empty, to help calculate the time when a new passenger will exit the queue if he enters now), cur_time (time of the last processed event).

Suppose that we're processing an event. If the type of the event is 1, then we add index to want, otherwise we remove index from in_queue. After processing an event we ought to check if there is a passenger who can enter the queue. Let x be the smallest element of want, and if in_queue either is empty or x is smaller than the smallest element of in_queue, then x immediately enters the queue, therefore creating a new event (max(cur_time,queue_time)+p,0,x).

The complexity of the solution is O(nlogn), because we need to use sorted data structures (for example, std::set of std::priority_queue).

1239D - Конкурс котиковYou are given bipartite graph and a perfect matching in it. You have to find independent set of size n which doesn't coincide with either of two parts.

Suppose such independent set exists, let's call it S. Also, let's call left part of graph as L and right part of graph as R. Then define A=S∩L, B=L∖A, A′ is set of all nodes which are connected by edges from matching with A, B′ — similarly for B. It's easy to see that S=A∪B′.

Let's direct all edges in graph. Edges from matching will be directed from right to left, and all other edges will be directed from left to right. Now edges from matching will direct from A′ to A and from B′ to B. Other edges could direct from A to A′, from B to B′ and from B to A′. Observe that edges cannot direct from A to B′, cause it wouldn't be an independent set otherwise.

It's easy to see that B′ isn't reachable from A. So, let's find all strongly connected components (SCC) in this graph. If there's only one such component, answer doesn't exist due to the fact that any node of B′ isn't reachable from any node of A. If SCC is only one, any node is reachable from any other node therefore in this case either A or B′ are empty. If there are at least two SCC, let's choose any source SCC and call it Q. Consider B′=Q∩R and define A as set of all nodes in left part which are not connected by edges from matching with B′. Let's proof that if some l∈L lies in B′, then r — pair of l in matching also lies in B′. That's obvious since there are no incoming edges in B′ and there's edge from r to l. So, none of nodes from A will lay in chosen SCC. Thus B′ won't be reachable from A and A∪B′ will be an independent set.

The only exception is n=1, in such case there are two SCC but answer doesn't exist (cause chosen A will be empty).

1239E - TurtleConsider that we already fixed the set in the top line and fixed.

If we perform a swap in this situation, the answer will clearly won't become worse (some paths are not changing, and some are decreasing).

So we can assume that the first line is sorted, and similarly the second line is sorted too (but descending).

Now let's think which path the turtle will choose. Observe the difference between to paths:

Then cost of path i+1 minus cost of path i is equal to xi+1−yi.

xi increases when i increases, yi decreases, xi+1−yi decreases, so the discrete derivative increases.

Such function looks like:

So clearly the turtle will choose either the first or the last path.

So now we need to split our set into two of equal size, so that the maximum sum is smallest possible.

This is a knapsack problem. The states are the prefix of elements considered, the number of elements taken, the weight. It works in O(n3maxa)EDIT: it turned out it was inobvious... The corner cells take two minimal elements and are not considered in knapsack since they are contained in all paths. It's easy to prove that it's optimal to put minimal elements in corners.

1239F - Swiper, no swiping!We will look only on set of vertex, that will stay after deleting.

Let node-x — node with degree mod 3 equal x.

Let's consider some cases:

Node-0 exists. It is the answer, except the case, when our graph consists of one node.Cycle on nodes-2 exists. So exists irreducible cycle on nodes-2. It is the answer, except the case, when our graph is cycle.Way between nodes-1 on nodes-2 exists. So exists irreducible way with same conditions. It is the answer, except the case, when our graph is way.Our graph contains one node-1 and nodes-2 form forest. Let's take two trees and delete all except two ways in this trees, such only endpoints are connected with node-1. Those ways and node-1 are the answer, except the case, when our graph is twho cycles with one common node.That's all cases. Let's show it:

Nodes-2 form forest. Exists at least one leaf, that is connected with node-1. So in that case node-1 always exists.Degree of node-1 equals sum degree of nodes-2 minus doubled number of edges between nodes-2. Let k — number of nodes-2. So degree of node-1 mod 3 equals 2k−2(k−1)=2. Contradiction. So forest consist of at least two trees.

Codeforces Round #593 (Div. 2) Editorial

By Cirno_9baka, history, 3 years ago, In English1236A - StonesWe can use many ways to solve the problem. If you just enumerate how many operations of the first and the second type, it will also pass.

Of course there is a greedy solution. We make the second operation as much as possible, and then use the first operation. It takes O(1) time.

1236B - Alice and the List of PresentsThe answer is (2m−1)n.

If we consider each present, it may contain only in the first box, in the second ... both in the first and second box, in the first and the third one ... in the first,the second and the third one ... There are 2m−1 ways.

There are n presents, so there are (2m−1)n ways in total according to the Multiplication Principle.

1236C - LabsThe maximum number is ⌊n22⌋.

It can be proved we cannot find a larger answer. There is n2 pipes between any two groups. So the valid pairs of the minimum of them does not exceed ⌊n22⌋.

Then we try to find a way to achieve the maximum. We find if we put the first lab in the first group, the second one to the second group ... the n-th one to the n-th group. Then put the n+1-th one in the n-th group, the n+2-th one in the n−1-th group ... the 2n-th one to the first group. And then again use the method for the 2n+1-th to the 4n-th lab. if n is odd, then we will only use the previous half of the method.

1236D - Alice and the DollConsider just simulate the whole process. We walk straight, and then turn right when meet the obstacle or the border of the grid. Then we can use set to make it faster. We can check along the direction, which is the first obstacle. To check whether any cell is covered, we can calculate the number of cells we walk across and then check if it equals to n∗m−k. Also,we can sort the obstacles by x and y, then use binary search to find the first obstacle along the direction.

Time complexity is O(nlogn).

1236E - Alice and the Unfair GameFirst there is a conclusion: each start point will be able to reach a consecutive segment of end points except for n=1.

It's easy to prove, when a place is banned, we can make a move to make it reachable again.

So with the conclusion then we can solve the problem. First we will come up with a greedy algorithm. We can move the doll to the left (or right) if possible, otherwise we can keep it at its place. Then we will get the left bound and the right bound of one start point. It's O(n2) and not enough to pass.

Consider we try to find the left bound. We scan the array a and deal with all start points together. For the first element of a, it will only influence one start point (that is, if we start from there, we will meet the element can then we need to keep it at its place). So we can move the start point to its right box (because when it starts from that place, we will get the same answer). Then we can delete the first element. But then there will be more than one start point in the same cell, we can use dsu to merge two set of start points.

Note that the doll cannot move to 0 or n+1. We can also have to deal with this using the algorithm above. And it is the same to find the right bound.

Time complexity is O(n).

Another solution: Consider a grid that there is obstacles on (i,ai). Each time we start from (0,y) and if there is no obstacle on (x+1,y−1) then we move to it, otherwise we move to (x,y−1). We find we may change the direction only if we reach the place (i−1,ai+1) and we will walk to (i,ai+1). So only the O(k) positions are useful. We can use binary search to find the next position for each useful position and start point. Then we get a tree. Just using dfs then we will get left bound for each start points. The Time complexity is O(nlogn).

1236F - Alice and the CactusFirst we consider how to calculate E(X).

The number of connected components equals to the number of nodes minus the number of edges and then add the number of rings in it. So we can calculate the possibility of removing one node, one edge or one single ring.

Then we can split the variance, it is equals to E(X2)−2∗E(X)2+E(X)2=E(X2)−E(X)2. Then we can again to split X2. Let the number nodes equal to a, the number edges equal to b, the number rings equal to c. Then X2=(a−b+c)2=a2+b2+c2−2ab−2bc+2ac. We can find there is contribution between a pair of nodes, edges, rings (the two may be the same) and between a node and an edge, a node and a ring, an edge and a ring. Then we can calculate the possibility of such pair that the elements in it remains at the same time. The answer is the same when the pair is a ring and a node on it, or when it is a ring and a node not on it, or an edge with one of its end point ... If we consider all the situation of intersection and not intersection, we can get a liner algorithm. But the Time Complexity is O(nlogn) since we need to calculate the multiplicative inverse of modulo.

Codeforces Round #592 (Div. 2) Tutorial

By fcspartakm, history, 3 years ago, translation, In English1244A - Pens and PencilsThere is a solution with brute force in O(n2) and a solution with formulas in O(1). I'll describe the latter one.

We should determine the minimum number of pens that we should take to be able to write all of the lectures. It is ⌈ac⌉, but how to compute it easily? We can use some internal ceiling functions. We can also do something like "compute the integer part of the quotient, and then add 1 if the remainder is not zero". But the easiest option, in my opinion, is to use the following formula: ⌈ac⌉=⌊a+c−1c⌋.

The minimum number of pencils can be calculated using the same method. All that's left is to check that k is not less than the total number of writing implements we should take.

1244B - Rooms and StaircasesIf there are no stairs, the best we can do is to visit all the rooms on the same floor, so the answer is n.

Otherwise, the best course of action is to choose exactly one stair (let's denote its number by s) and do one of the following: either start from the leftmost room on the first floor, then use the stair and move to the leftmost room on the second floor, or do the same, but start and end in rightmost rooms instead of leftmost ones. Then for choosing the stair in room s, we get max(2s,2(n−s+1)) as the answer.

Why is it optimal? Let's denote the leftmost stair as l, and the rightmost stair as r. There are four special segments of rooms such that if we enter them, we can't leave. These are: rooms [1…l−1] on the first floor, rooms [1…l−1] on the second floor, rooms [r+1…n] on the first floor and rooms [r+1…n] on the second floor. We can visit only two of them, if one contains the starting room and the other contains the ending room. So the answer cannot be greater than 2n−2min(l−1,n−r−1) — and our algorithm will give exactly this value either by choosing stair l, or by choosing the stair r.

1244C - The Football SeasonThe crucial observation is that d wins give us the same amount of points as w draws. Let's use them to solve a problem where we want to minimize the total amount of wins and draws giving p points (if it is not greater than n, we can just lose all other matches).

If y≥w, then we can subtract w from y and add d to x, the number of wins and draws will decrease, and the number of points will stay the same. So we can limit the number of draws to w−1. And the solution is the following: iterate on the number of draws y from 0 to w−1, and check if the current value of y gives us the result we need (p−yd should be non-negative and divisible by w, and p−ydw+y should be not greater than n).

1244D - Paint the TreeThe key observation is that if we fix the colors of two adjacent vertices x and y, then the color of any vertex adjacent to x or to y can be only 6−cx−cy. So we can fix the colors of the endpoints of any edge (there are 6 possibilities to do that), then do a traversal to color all other vertices, then do another traversal to check that we got a good painting.

To avoid checking that the painting we got is good (which can be tricky to code), we can use the fact that, for each vertex, the colors of all its neighbours should be different from each other and from the color of the vertex we fixed. So, if some vertex has degree 3 or greater, then there is no good painting; otherwise the painting we get is good, since the graph is a chain.

1244E - Minimizing DifferenceSuppose that the maximum value in the resulting array should be R, and the minimum value should be L. Let's estimate the required number of operations to make an array with such properties. All elements that are less than L should be increased to L, and all elements that are greater than R should be decreased to R — and we don't have to do any operation with remaining elements.

Now we claim that either L or R should belong to the initial array. Why so? Suppose we constructed an answer such that L∉A and R∉A. If the number of elements we increased to L is not less than the number of elements we decreased to R, then we could construct the answer with minimum equal to L−1 and maximum equal to R−1, and it would not require more operations. And if the number of elements we increased to L is less than the number of elements we decreased to R, then we construct the answer for L+1 as minimum and R+1 as maximum. So we can shift the range [L,R] so that one of its endpoints belongs to the initial array.

Now we can solve the problem as follows: iterate on the maximum in the resulting array and find the largest minimum we can obtain with binary search, and then do it vice versa: iterate on the minimum in the resulting array and find the largest maximum we can obtain with binary search. To check how many operations we need, for example, to make all values not less than L, we can find the number of elements that we have to change with another binary search (let the number of such elements be m), and find their sum with prefix sums (let their sum be S). Then the required number of operations is exactly Lm−S. The same approach can be used to find the number of operations to make all elements not greater than R.

This is the way the problem was supposed to solve, but, unfortunately, we failed to find a much easier greedy solution.

1244F - ChipsThe main observation for this problem is the following: a chip changes its color if and only if both of its neighbours have the opposite colors (so, a W chip changes its color only if both of its neighbours are B, and vice versa). Let's denote such chips as unstable, and also let's denote an unstable segment as a maximum by inclusion sequence of consecutive unstable chips.

Let's analyze each unstable segment. If it covers the whole circle, then the whole circle changes during each iteration, so the answer depends on whether k is odd or even.

Otherwise the unstable segment we analyze is bounded by two stable chips. When the first chip in the unstable segment changes, its color becomes equal to the color of its neighbour that does not belong to the unstable segment. We can also say the same for the last chip. So, during each iteration all chips in the unstable segment change their colors, and after that, the segment shrinks (the first and the last chip become stable and won't change their colors anymore).

All that's left is to find all unstable segments and analyze how they change.

1244G - Running in PairsFirst of all, let's understand which values of sum we can obtain at all. Obviously, the minimum possible value of sum is mn=n(n+1)2. The maximum possible value of sum is mx=(⌈n2⌉+1+n)⋅⌊n2⌋+n%2⋅⌈n2⌉. We can obtain every possible value of sum between mn and mx and we will show how to do it below.

If k<mn then the answer is -1 (and this is the only such case). Otherwise, the answer exists and we need to construct it somehow. Firstly, suppose that the first permutation is identic permutation (1,2,…,n) and the only permutation we change is the second one. Initially, the second permutation is also identic. Now we have sum=mn and we need to change it to sum=k or to the maximum possible number not greater than k. To do that, let's learn how to increase sum by one. Let's see what will happen if we swap n and n−1. Then the value of sum will increase by one. If we swap n and n−2 then the value of sum will increase by 2, and so on. If we swap n and 1 then the value of sum will increase by n−1.

So, the following constructive algorithm comes to mind: let's carry the current segment of permutation [l;r] we can change (it is always segment because after some swaps some leftmost and rightmost elements cannot increase our answer because they're will be already placed optimally) and the value add we need to add to sum to obtain the maximum possible sum not greater than k. Initially l=1,r=n,add=k−mn. Now let's understand the maximum value by which we can increase the value of sum. Now it is r−l. If this value is greater than add then let's swap pr and pr−add, and break the cycle (p is the second permutation). Otherwise, let's swap pl and pr, decrease add by r−l and set l:=l+1,r:=r−1 . If at some moment l becomes greater than or equal to r then break the cycle.

Now we got the second permutation p with the maximum possible value of sum not greater than k, we can calculate the numeric answer (or print min(mx,k)), print identic permutation and the permutation p.

Сodeforces Round 591 (and Technocup 2020 — Elimination Round 1) Editorial

By Roms, history, 3 years ago, In English1223A - КУС

Idea: Roms

Tutorial1223A - CMEIf n is odd then we have to buy at least one match because integers a+b and c (a, b and c is elements of equation a+b=c) must be of the same parity, so integer a+b+c is always even.

If n is even then we can assemble an equation 1+n−22=n2. But there is one corner case. If n=2, then we have to buy two matches, because all integers a, b and c must be greater than zero.

In this way, the answer is equal:

2 if n=2;1 if n is odd;0 if n is even and greater than 2.Solution (Roms)1223B - Уравнивание строк

Idea: Roms

Tutorial1223B - Strings EqualizationIf there is a character which is contained in string s and t (let's denote it as c), then we answer is "YES" because we can turn these string into string consisting only of this character c.

Otherwise the answer is "NO", because if initially strings have not a common character, then after performing operation they also have not a common character.

Solution (Roms)1223C - Спаси природу

Idea: MikeMirzayanov

Tutorial1223C - Save the NatureAt first, let's assume that x≥y (otherwise, we can swap parameters of programs). Let's define cont(len) as the maximum contribution we can get selling exactly len tickets.

Note, in general case sold ticket can be one of 4 types:

tickets with (x+y)% of the price are contributed; the number of such tickets is cXY;tickets with x% of the price are contributed; the number of such tickets is cX;tickets with y% of the price are contributed; the number of such tickets is cY;tickets which are not in both programs.All values cXY, cX, cY can be easily counted by iterating over indices i from 1 to len and checking whenever i is divisible by a or by b or both.

Now we can understand that it's always optimal to choose in the first group cXY maximums from p, in the second group next cX maximums and in the third — next cY maximums.

Using the algorithm above we can calculate cont(len) in linear time (just sort p beforehand).

The final step is to understand that function cont(len) is non decreasing, so we can just binary search the minimal len with cont(len)≥k.

The time complexity is O(nlogn), but O(nlog2n) can pass too.

Solution (adedalic)1223D - Сортировка последовательности

Idea: Roms

Tutorial1223D - Sequence SortingLet's consider two sequences of integers m1<m2<⋯<mk and d1<d2<⋯<dl. Sequence m contains integers which were used in some operation in the optimal answer. Sequence d contains integers which were not used.

For example, if a=[2,1,3,5,4], then optimal answer is move all 1-elements to the beginning and then move all 5-elements to the end, so m=[1,5] and d=[2,3,4].

Two important conditions are held for these sequences:

maxInd(di−1)<minInd(di) for every i from 2 to l. minInd(x) is the minimum index i such that ai=x, and maxInd(x) is the maximum index i such that ai=x;for each i from 2 to l there is no such integer x, that di<x<di+1 and sequence m contains this integer x.Since the answer is equal to |m|=k, we want to minimize this value. So we want to maximize the length of sequence d.

For each integer l we want to find the maximum integer dpl=len such that we can sort sequence a without moving elements in range l…l+len−1. We can do it with dynamic programming.

Let's consider all integers occurring in sequence a in descending order s1,s2,…,st (si−1>si for each i from 2 to t). If maxInd(si)<minInd(si+1) then dpi=dpi+1+1, otherwise dpi=1.

The answer is equal to t−maxi=1…tdpi, there t is the number of distinct integers in sequence a.

Solution (Roms)1223E - Раскрась дерево

Idea: Neon

Tutorial1223E - Paint the TreeIt is obvious that if we paint two vertices in the same color, they should be adjacent to each other — otherwise we could paint them in different colors, and the answer would not be worse. So we can reduce the problem to the following: choose a set of edges with maximum cost such that no vertex is adjacent to more than k chosen edges. This problem is very similar to maximum weighted matching on the tree, and we can try to use some methods that allow us to solve that problem.

Let's solve the problem using dynamic programming dpv,f — the answer to the problem for the subtree of the vertex v, f is the flag that denotes whether the edge from v to its parent is chosen. Depending on the flag f, we can choose k or k−1 edges connecting our vertex to its children (let's denote the maximum number of edges we can choose as t).

We have to select no more than t child nodes of the vertex v. If we choose an edge leading to node u, then dpu,1+wv,u is added to the dp value we are currently calculating; otherwise, dpu,0 is added.

Based on this formula, you have to choose no more than t child nodes of vertex v for which the total sum of dpu,1+wv,u−dpu,0 is maximum.

Solution (Ne0n25)1223F - Стек-уничтожимые массивы

Idea: Roms

Tutorial1223F - Stack Exterminable ArraysLet's understand how calculate the array nxt, such that nxtl is equal to the minimum index r>l such that subarray al…r is stack exterminable. If there is no such index, then nxtl=−1.

If we calculate this array then we solve this task by simple dynamic programming.

Let's calculate it in order nxtn,nxtn−1,…,nxt1 by dynamic programming. At first consider simple case. If ai=ai+1, then nxti=i+1. Otherwise we have to "add" the block ai+1…anxti+1 (of course, nxti+1 should be not equal to −1) and check that ai=a1+nxti+1. If this (ai=a1+nxti+1) also is not true, then you have to add a new block a1+nxti+1…anxt1+nxti+1 and check the condition ai=a1+nxt1+nxti+1. If this condition also is not try, then you have to add a new block and so on.

It is correct solution, but it can be too slowly. Let's understand, that we add blocks to ai until condition ai=a1+nxt… is holds. Let's assume, that we have an array nxtX (this array contains a hashMaps, for example you can use map in C++), such that nxtXi,x is is equal to the minimum index r>l such that subarray al…r is stack exterminable and x=ar+1. Then we can easily calculate the value nxti=nxtXi+1,ai+1. Remains to understand, how to calculate nxtXi. For this we just can make an assignment nxtXi=nxtXnxti+1. And then update nxtXi,anxti+1=nxti+1.

But I deceived you a little. We can't make an assignment nxtXi=nxtXnxti+1 because it is to slow. Instead that you need to swap elements nxtXi and nxtXnxti+1, this can be done using the function swap in C++ or Java (time complexity of swap if O(1)).

Solution (Roms)1223G - Деревянный плот

Idea: adedalic

Tutorial1223G - Wooden RaftLet's iterate y from 2 to A, where A=max(ai). And let's try to find the best answer for a fixed y in O(Ay) time.

How to do so? At first, we can quite easily calculate the total number of logs of length y we can acquire (denote it as cntY): since all ai∈[ky,ky+y) give the same number of logs which is equal to k, then let's just count the number of ai in [ky,ky+y) for each k. We can do so using frequency array and prefix sums on it.

There are two cases in the problem: both logs of length x lies in the same log ai or from the different logs ai and aj. In the first case it's the same as finding one log of length 2x. But in both cases we will divide all possible values of x (2x) in segments [ky,ky+y) and check each segment in O(1) time.

Let's suppose that 2x∈[ky,ky+y) and there is ai such that ai≥2x and (aimody)≥(2xmody). In that case it's optimal to cut 2x from ai and, moreover, it's optimal to increase 2x while we can. It leads us straight to the solution, let's keep max(aimody) over ai≥ky and check only 2x=ky+max(aimody) (maybe minus one in case of wrong parity). We can maintain this max iterating k in descending order. And since max(aimody) for all ai∈[ky,ky+y) is just a max(ai | ai<ky+y). We can find such ai in O(1) using precalc. To check the chosen 2x is trivial: the number of remaining logs y is equal to cntY−k and the plot will have the area y⋅min(x,cntY−k).

The case with cutting x-s from different ai and aj is based on the same idea, but we need to maintain two maximums mx1 and mx2 (mx1≥mx2). But in this case x can be equal to both mx1 or mx2.

If x=ky+mx2 then everything is trivial: the number of logs y is cntY−2⋅k and so on. If x=ky+mx1 then we need to additional check the existence of ai≥x and aj≥x. Remaining number of logs y will be equal to cntY−2⋅k−1 and so on.

In result, for each y we can calculate the answer in O(Ay), so the total time complexity is O(n+∑Ay=2O(Ay))=O(n+AlogA).

P.S.: We decided to allow the O(Alog2A) solution which binary search x for each y to pass if it's carefully written.

Solution (adedalic)1240F - Футбол

Idea: MikeMirzayanov

Tutorial1240F - FootballLet's assume that m≤n⋅k.

We can randomly assign colors to edges. If there is a vertex that does not satisfy the condition, then we can choose color a which appears the smallest number of times and color b which appears the biggest number of times. We will "recolor" edges that have one of these two colors.

Let's consider this graph only with edges with colors a and b. Let's add a "fake" vertex 0. This graph may have many components. If a component has at least one vertex with odd degree, we connect each such vertex with 0. Otherwise, let's choose any vertex from that component and add two edges to 0. Therefore, the graph will be connected and each vertex will have an even degree. Thus, we will be able to find an Euler cycle. Let's color the odd edges in the cycle in a, and even edges in b. As a result, the difference between these two colors for each vertex will be at most 1.

Let's do this operation while there is a vertex which does not satisfy the condition.

If m>n⋅k, let's split the edges into two groups with the equal sizes (that is, ⌊m2⌋ and ⌈m2⌉). If a group has not greater than n⋅k edges, then do the algorithm at the beginning of the tutorial. Otherwise, split it again.

If you found the answers for two groups, you need to find the answer for the combined graph. Let f1 be the most popular color in the first group, f2 the second most popular color, ..., fk the least popular color in the first group. Similarly, let g1 be the most popular color in the second graph, etc. So, in the combined graph, f1 should be equal to gk, f2 should be equal to gk−1. In other words, we take the most popular color in the first group and color the least popular color in the second group with that color. If there is a vertex that does not satisfy the condition, "recolor" the graph according to the algorithm explained in the third paragraph.

Solution (arsijo)

Codeforces Round #590 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishSuddenly, all problems expect A and D were invented by me. The author of A and D is MikeMirzayanov.

1234A - Equalize Prices Again

Tutorial1234A - Equalize Prices AgainIn this problem, we need to find the minimum possible price such that price⋅n≥sum, where sum is the sum of all ai. price equals to ⌈sumn⌉, where ⌈xy⌉ is x divided by y rounded up.

Solution1234B1 - Social Network (easy version)

Tutorial1234B1 - Social Network (easy version)The solution to this problem is just the implementation of what is written in the problem statement. Let's carry the array q which shows the current smartphone screen. When we receive the new message from the friend with ID idi, let's do the following sequence of moves:

Firstly, let's try to find him on the screen. If he is found, just do nothing and continue.Otherwise, let's check if the current number of conversations is k. If it is so then let's remove the last conversation.Now the number of conversations is less than k and the current friend is not shown on the screen. Let's insert him into the first position.After processing all n messages the answer is just the array q.

Solution1234B2 - Social Network (hard version)

Tutorial1234B2 - Social Network (hard version)The idea of this solution is the same as in the easy version, but now we need to do the same sequence of moves faster. We can notice that the smartphone screen works as a queue, so let store it as a queue! When the new message appears, we have to check if the friend with this ID is in the queue already, but we need to check it somehow fast. Let's use some logarithmic structure that stores the same information as the queue but in other order to find, add and remove elements fast. In C++ this structure is std::set.

So let's check if the current friend is in the queue, and if no, let's check if the size of the queue is k. If it is so then let's remove the first element of the queue from it and the same element from the set also. Then add the current friend to the queue and to the set. After processing all messages, the reversed queue (the queue from tail to head) is the answer to the problem.

Time complexity: O(nlogk).

And don't forget that std::unordered_map and other standard hashmaps can work in linear time in the worst case, so you need to redefine the hash function to use them. You can read more about this issue here: https://codeforces.com/blog/entry/62393.

Solution1234C - Pipes

Tutorial1234C - PipesLet's see how the water can flow when it meets the pipe of type 1 or 2 and in the other case. When the water meets the pipe of type 1 or 2 we cannot do anything but let it flow to the right of the current cell. Otherwise (if the current pipe is curved) then there are two cases: if the pipe on the same position but in the other row is not curved then the answer is "NO" because the water has to change the row but we cannot turn the next pipe to allow it to move to the right or to the left. So, the current pipe is curved and the pipe on the same position in the other row is also curved, let's change the row and move to the right (it is obvious that we never need to move to the left).

So, the answer (and the sequence of pipes) is uniquely defined by types of pipes. If after iterating over all n positions we didn't meet the case of "NO" and the current row is second, then the answer is "YES".

Solution1234D - Distinct Characters Queries

Tutorial1234D - Distinct Characters QueriesLet's store for each letter all positions in which it appears in some data structure. We need such a data structure that can add, remove and find the next element greater than or equal to our element, fast enough. Suddenly, this data structure is std::set again (in C++).

When we meet the first type query, let's just modify two elements of corresponding sets (one remove, one add). When we meet the second type query, let's iterate over all letters. If the current letter is in the segment [l;r] then the first element greater than or equal to l in the corresponding set should exist and be less than or equal to r. If it is so, let's increase the answer by one. After iterating over all letters just print the answer.

Time complexity: O(nlognAL), when AL is the size of the alphabet.

Solution1234E - Special Permutations

Tutorial1234E - Special PermutationsLet's calculate the answer for the first permutation p1(n) naively in O(m). Then let's recalculate the answer somehow and then maybe prove that it works in linear time.

Which summands will change when we try to recalculate the function f(pi(n)) using f(p1(n))? First of all, let's notice that each pair of adjacent elements of x is the segment on the permutation. To calculate f(pi(n)) fast, let's firstly notice that all segments that cover the element i (but i is not their endpoint) will change their length by minus one after placing i at the first position (because i will be removed from all such segments).

This part can be calculated in O(n+m). Let's use the standard trick with prefix sums and segments. Let cnt be the array of length n. For each pair of adjacent elements xj and xj+1 for all j from 1 to m−1 let's do the following sequence of moves: if |xj−xj+1|<2 then there are no points that covered by this segment not being its endpoints, so let's just skip this segment. Otherwise let's increase the value of cnt[min(xj,xj+1)+1] by one and decrease the value of cnt[max(xj,xj+1)] by one. After this, let's build prefix sums on this array (make cnt[i+1]:=cnt[i+1]+cnt[i] for all i from 1 to n−1). And now cnti equals to the number of segments covering the element i.

The second part that will change is such segments that i is their endpoint. Let's store the array of arrays adj of length n and adj[i] will store all elements adjacent to i in the array x for all i from 1 to n. But one important thing: we don't need to consider such pairs xj and xj+1 that xj=xj+1 (it broke my solution somehow so this part is important).

Knowing these two parts we can easily calculate f(pi(n)) using f(p1(n)). Firstly, let's initialize the result as res=f(p1(n))−cnt[i]. Then we need to recalculate lengths of such segments that i is their endpoint. Let's iterate over all elements j in adj[i], set res:=res−|j−i| (remove the old segment) and set res:=res+j (add the length of the segment from j to 1) and increase res by one if j<i (it means that i and j change their relative order and the length of the segment from j to i increases by one).

Now we can see that after iterating over all i from 1 to n we make at most O(n+m) moves because each pair of adjacent elements in x was considered at most twice.

Total complexity: O(n+m).

Solution1234F - Yet Another Substring Reverse

Tutorial1234F - Yet Another Substring ReverseFirst of all, I wanted to offer you one little challenge: I found a solution that I can't break (and I don't sure if it can be broken) and I will be so happy if anyone will give me countertest which will break it. You can see its code below.

Let's notice that we can reduce our problem to the following: find two substrings of the given string that letters in them do not intersect and the total length of these substrings is the maximum possible. Why can we make such a reduction? It is so because our answer consists of at most two non-intersecting parts: one fixed substring and at most one substring that we appended to the first one. We can always append any other substring to the first one by one reverse operation (just look at some examples to understand it).

Let's iterate over all possible substrings of length at most AL (where AL is the size of the alphabet) which contain distinct letters. We can do it in O(nAL). Let the current substring containing distinct letters be s[i;j]. Let's create the bitmask corresponding to this substring: the bit pos is 1 if the pos-th letter of the alphabet is presented in the substring and 0 otherwise (letters are 0-indexed).

Store all these masks somewhere. Notice that our current problem can be reduced to the following: we have the set of masks and we need to find a pair of masks that they do not intersect and their total number of ones in them is the maximum possible. This reduction is less obvious than the previous one but you also can understand it considering some examples.

So how to solve this problem? We can do it with easy bitmasks dynamic programming! Let dpmask be the maximum number of ones in some mask that is presented in the given string and it is the submask of mask. How to calculate this dynamic programming? First of all, all values dpmask for all masks presented in the string are equal to the number of ones in corresponding masks. Let's iterate over all masks from 0 to 2AL−1. Let the current mask be mask. Then let's try to update the answer for this mask with the answer for one of its submasks. It is obvious that because of dynamic programming we need to remove at most one bit from our mask to cover all possible submasks that can update our answer. So let's iterate over all bits in mask, let the current bit be pos. If this bit is zero then just skip it. Otherwise update dpmask:=max(dpmask,dpmask^2pos), where ^ is the xor operation.

After calculating this dynamic programming we can finally calculate the answer. Let's iterate over all masks presented in the string, let the current mask be mask. We can update the answer with the number of ones in mask plus dpmask^(2AL−1) (mask^(2AL−1) is the completion of mask).

Total complexity: O(nAL+AL2AL).

SolutionWA?

Codeforces Round #589 (Div. 2) Editorial

By McDic, history, 3 years ago, In EnglishHello, I hope all of you enjoyed my contest!

1228A - Distinct DigitsLet's see how to check if all digits of x are different. Since there can be only 10 different numbers(0 to 9) in single digit, you can count the occurrences of 10 numbers by looking all digits of x. You can count all digits by using modulo 10 or changing whole number to string.

For example, if x=1217, then occurrence of each number will be [0,2,1,0,0,0,0,1,0,0], because there are two 1s, single 2 and single 7 in x. So 1217 is invalid number.

Now do the same thing for all x where l≤x≤r. If you find any valid number then print it. Otherwise print −1.

Time complexity is O((r−l)logr).

[Behind story of A]

There is a successful hack for A. I am really surprised.My code: https://codeforces.com/contest/1228/submission/615788421228B - Filling the GridYou can see some observations below;

r and c values reserves some cells to be full, and some cells to be empty. Because they have to satisfy number of consecutive full cells in their row/column.If some cell is reserved to be full by some values and reserved to be empty by some other values, then it is impossible to fill grid. Let's call this kind of cell as invalid cell.If there is no invalid cell, then the answer is 2unreserved where unreserved means the number of unreserved cells, because setting state of unreserved cells doesn't affect validity of grid.For easier understanding, please look at the pictures below.

Black cells are reserved to be full by some r or c value.White X cells are reserved to be empty by some r or c value.White ? cells are unreserved cells.Red X cells are invalid cells.This is the explanation of the first example. There is 1 unreserved cell, so the answer is 2.This is one of the impossible cases. That red X cell is reserved to be full by r3, but reserved to be empty by c2. So this is impossible.Time complexity is O(wh).

[Behind story of B]

There is no behind story.My code: https://codeforces.com/contest/1228/submission/615788411228C - Primes and MultiplicationLet's say h(x,p)=logpg(x,p), then h(x,p)+h(y,p)=h(xy,p). Because if we describe x=ph(x,p)qx and y=ph(y,p)qy, then xy=ph(x,p)+h(y,p)qxqy.

Now let's go to the main step;

∏i=1nf(x,i)=∏i=1n∏p∈prime(x)g(i,p)=∏i=1n∏p∈prime(x)ph(i,p)=∏p∈prime(x)∏i=1nph(i,p)=∏p∈prime(x)p∑ni=1h(i,p)=∏p∈prime(x)ph(n!,p)So we have to count h(n!,p) for each p in prime(x), and calculate exponents. You can count h(n!,p) by following formula;

h(n!,p)=∑k=1∞⌊npk⌋Fortunately, since h(n!,p) never exceeds n, we don't have to apply Euler's theorem here. You just have to be careful about overflow issue.

Roughly calculated time complexity is O(x−−√+loglogx⋅logn), because you use O(x−−√) to get prime divisors of x, and the number of distinct prime divisors of x is approximately loglogx.

[Behind story of C]

Initial version of C statement consists of tons of mathematical formula. CF team and testers requested me to reduce amount of mathematical formula.This problem was added before a week to the round. If there was no such C, the balance would be bad.Thanks for dorijanlendvaj , he improved test data for C a lot!My code: https://codeforces.com/contest/1228/submission/615788561228D - Complete TripartiteYou can make answer by following these steps;

If two vertices u1 and u2 are in same vertex set, there should be no edge between them. Otherwise, there should be edge between them.If you choose any u as first vertex of specific vertex set, then you can simply add all vertices which are not directly connected to u in that vertex set.Make 3 vertex sets by doing second step multiple times. If you can't make 3 sets or there is any vertex which is not in any vertex set, then answer is impossible.If m≠|v1|⋅|v2|+|v2|⋅|v3|+|v3|⋅|v1|, then answer is impossible. |vi| means size of i-th vertex set.For all vertices u1 and u2 from different vertex sets, if there is no direct connection between u1 and u2, then answer is impossible.If you validated all steps, then current vertex set assignment is answer.Make sure you are doing all steps. If you forget any of these steps, your solution will print wrong answer.

Time complexity is O((n+m)logn).

[Behind story of D]

Same as C, I wrote tons of mathematical formula in D. After CF team's request, I reduced the amount of formula.This is my personal favorite problem among ABCDEF.My code: https://codeforces.com/contest/1228/submission/615788611228E - Another Filling the GridO(n3) solution:Let f(r,c) to be the number of filling grids of r rows, c incomplete columns, and n−c complete columns. Incomplete columns means which doesn't contain 1 in already filled part, and complete columns means opposite. Now you can see that the formula can be described as below;

f(r,0)=(kn−(k−1)n)r (1≤r), because we don't have to care about minimum value of columns. However, there should be at least one cell which has 1.f(1,c)=kn−c (1≤c), because we have to fill 1 in all incomplete columns in that row. But, other cells are free.f(r,c)=(kn−c−(k−1)n−c)⋅(k−1)c⋅f(r−1,c)+kn−c⋅∑cc0=1(cc0)⋅(k−1)c−c0⋅f(r−1,c−c0) (2≤r, 1≤c). Each part means number of cases when you select c0 incomplete columns to be complete column in this row.The answer is f(n,n).

O(n2) and O(nlogn) solution:Let R[i] be the restriction of the i-th row having some value <= 1 and C[i] the same but for columns. We want ⋂ni=1R[i]∩C[i].

Negate that expression twice, and we'll get U−⋃ni=1¬R[i]∪¬C[i]. Using inclusion-exclusion this is:

∑i=0n∑j=0n(−1)i+j⋅(nj)⋅(ni)⋅kn2−n⋅(i+j)+i⋅j⋅(k−1)n⋅(i+j)−i⋅jThis is enough for O(n2logn) with fast exponentiation or O(n2) precomputing the needed powers. To get O(nlogn) note that we the second sum is a binomial expansion so the answer can be simplified to:

∑i=0n(−1)i⋅(ni)⋅(kn−i⋅(k−1)i−(k−1)n)n[Behind story of E]

MikeMirzayanov changed the name of problem before 10~20 minutes to the contest. It was "Minimum One" before.This problem was the easiest to prepare data. Just pure random and k=1 is strong enough.I managed to create O(n3) pypy3 solution for E in 1 second lol.Thanks tfg for providing O(nlogn) solution.My code: https://codeforces.com/contest/1228/submission/615788681228F - One Node is GoneLet me suggest this observation;

Root of generated tree should be one of middle of diameter. Because only 1 node is deleted from complete full binary tree.So there are 3 valid cases;

The removed node is child of root. In this case, there are 2 answers(2 center nodes), diameter is decreased by 1 (odd), and tree looks like two complete full binary trees' roots are connected. You have to check if two center's subtrees are complete full binary tree.In this case, there are 2 answers, which are 2 centers of diameter.The removed node is leaf(n>2) or normal node. In this case, there is only 1 answer and 1 root node. Check if whole tree is complete full binary tree with 1 node error toleration. You can do case-handling by degree of nodes.If non-root has degree 3, then this node is normal.If non-root has degree 2 (error), then this node should be parent of removed leaf. You should check if this node's child node is leaf.If non-root has degree 1, then this node should be leaf.If non-root has degree 4 (error), then this node should be parent of removed normal node. This is the hardest case. I did this by checking depth of each child's subtree using DFS, then consider each tree to be complete and binary tree with no error, but with different depths.If you encountered multiple error nodes, then this tree is invalid. To check my exact approach, please look at my code.

In these cases, we can fix the center of whole tree by center of diameter.To check if specific subtree is complete and full binary tree, you can use top-down recursive approach. Maybe you can use bottom-up approach by collapsing leaf nodes too, but it's very hard(at least I think) to check all conditions strictly.

Time complexity is O(2n). But you can solve this in like O(n⋅2n) or something bigger one.

[Behind story of F]

This problem was the hardest to prepare data. We considered more than 10 types of trees to block various kind of WA solutions.I intended top-down error-toleration based case handling approach for this contest, but seems other approaches are also ok.Also thanks for dorijanlendvaj here, he is real MVP tester.My code: https://codeforces.com/contest/1228/submission/61578884[Behind story of G (removed problem)]

Nobody(including red testers) solved this problem for a week. This problem is saved as spare problem for another Div.1 contest.I love this beautiful problem than any other problems I ever made.Thanks in advance!

Dasha Code Championship Finals and Mirror Round 588 Editorial

By Radewoosh, history, 3 years ago, In English1230A - Dawid and Bags of CandiesLet's firstly sort all the bags in non-decreasing order of capacities. As the order of friends doesn't matter, it turns out that one of them should take only the biggest bag or the biggest and the smallest bag. It's easy to check if any of these possibilities works.

1230B - Ania and MinimizingThere are a couple of corner cases: if k=0, we cannot change S. Otherwise, if n=1, we can change S into 0.

Now assume that n≥2 and k≥1. A simple greedy approach works here: we can iterate over the digits from left to right and change them to the lowest possible digits as long as we still can change anything. The leftmost digit can be only changed to 1, and all the remaining digits should be changed to 0. We need to remember not to fix the digits that are currently the lowest possible.

For instance, if k=4, the number S=450456450 will be changed to 100006450 (the modified digits are marked blue).

The algorithm can be easily implemented in O(n) time.

1230C - Anadi and DominoWe can imagine writing an integer from 1 to 6 in each vertex — if we write an integer x in vertex v, then we want each half of the domino directed toward vertex v to have exactly x dots. Then, it's easy to calculate the result — we should place as many different dominoes as possible according to the written numbers so that we won't place any domino multiple times.

If n≤6, then it's optimal to write different numbers everywhere, so the result will be equal to m (the number of edges).

If n=7, then it's optimal to use only two equal numbers and it doesn't matter which number appears twice. Then, we can iterate over the pair of vertices with the same number and then easily calculate the result.

1229A - Marcin and Training CampIf there are multiple people with the same set of skills (i.e., the same values of a), it's optimal to take each of them to the camp as they won't think they're better than everyone else.

Now consider a person i which has a different set of skills than everyone else.

If they have a strictly smaller set of skills than someone already in the group, they can safely be included in the group.If they don't, we can prove that they can't ever be included in the group.This allows us to implement a simple O(n2) solution: first take all people that have an equal set of skills as someone else, and then include everyone else who has a strictly smaller set of skills than someone already in the group.

1229B - Kamil and Making a StreamLet's prove the following observation:

Fix a vertex v (the bottom end of the path), and consider all its ancestors u. The number of distinct values of f(u,v) is at most log2(1012).

To prove this observation, consider the ancestors of v in the order from the bottom-most to top-most: v=u0,u1,u2,u3,…,uk=1. Notice that f(ui,v)=gcd(xu0,xu1,xu2,…,xui). Therefore, each consecutive ui adds another value xu,i to the gcd of all numbers. If a gcd of all numbers changes, it must be a divisor of the previous gcd. Therefore, it's easy to see that it can change at most log2(1012) times.

We can now implement a depth-first search. If we invoke a recursive call in vertex v, we will receive the multiset of values {f(u,v)∣u is an ancestor of v}. We add all these values to the result and run the recursive calls in the children.

This is currently O(n2) or O(n2logn), but we can improve it by actually using a map from the distinct values in the multiset to the number of their occurrences. Then each map will have no more than Olog2(1012) elements. As we need to compute gcd's throughout the algorithm, this solution allows us to solve the problem in O(nlog2(1012)) time and in O(nlog(1012)) memory.

It's also possible to solve the problem using jump-pointers. Each jump-pointer will additionally hold the greatest common divisor of all the numbers we jump over when following the pointer.

1229C - Konrad and Company EvaluationLet's imagine that the graph is directed as in the sample explanation (and edge u→v exists if u brags to v). We have to deal with two kinds of queries:

Count the number of three-vertex directed paths.Change the direction of a single edge in the graph.If we remember indegrees indeg and outdegrees outdeg for each vertex, then we can see that the result for the first query is ∑vindeg(v)⋅outdeg(v). It's also easy to maintain the in- and outdegrees for each vertex when updating the graph using the second query.

Let's get back to the original problem. If a person v becomes the best-paid employee in the company, we can model it as taking all the edges ending at v, and reversing their direction.

It turns out that throughout the whole simulation, this edge-reversal won't happen too many times! Let's sort the vertices from left to right by their degree in the decreasing order. It now turns out that each vertex is adjacent with at most 2m−−−√ vertices to its left: if there were more, it would mean that there exist more that 2m−−−√ vertices with their degrees larger than 2m−−−√. It would mean that the sum of degrees of all the vertices in the graph is more than 2m−−−√⋅2m−−−√=2m — a contradiction.

Define the potential of the graph as the number of edges which point from left to right. If we revise the salary for employee v, we might need to flip many edges, but at most 2m−−−√ new edges will start pointing from left to right. The remaining edges incident to v will now point from right to left. Therefore, we do the number of swaps proportional to the change of the potential, and the potential at each query can increase at most by 2m−−−√. The potential at the beginning could be as high as m, and therefore the total number of swaps throughout the algorithm is at most m+q2m−−−√.

The algorithm can be therefore implemented in O(n+m+qm−−√) time. Note that we should store the adjacency list of the directed graph in vectors — when we revise the salary of employee v, we should process all edges entering v and simply clear the corresponding vector. Storing the graph in sets or hashsets has worse complexity or a huge constant factor and will likely time out.

1229D - Wojtek and Card TricksLet's first enumerate all permutations by integers from 0 to k!−1. Now, we can memoize all possible compositions of two permutations in an k!×k! array. This will allow us to compose any two permutations in constant time.

Let l and r be the left and right ends of any interval. We'll compute the sum in the problem statement for each r separately. Set some r. Notice that if there are multiple occurrences of the same permutation before r, only the latest occurrence is important for us — any earlier occurrences won't help us create any new decks. Therefore, for each of k! possible permutations, we can maintain its latest occurrence before r. We can also maintain a sorted list of such latest occurrences among all the permutations — from the latest to the earliest. This creates k! intervals of value l where the number of possible decks can't change.

Now, we only need to be able to maintain the set of decks (permutations) we can generate using the tricks we already know. Initially, we can generate only one deck (with the cards in sorted order). When learning a new trick, one of two things can happen:

If a single application of the new trick generates a deck we can already create using previous tricks, this trick gives us nothing — we can simply simulate this new trick by a sequence of old tricks.If this trick T creates a brand-new deck of cards, we need to recalculate the set of achievable permutations. We maintain a set of generators {g1,g2,…,ga}, ga=T (these are the tricks that have increased the number of decks we can generate). Now, each deck in the new set of decks can be created using this repeatedly applying the generators from this set. We can use BFS/DFS to compute the new decks.This is obviously a correct algorithm, but why does it work fast enough? If you know some abstract algebra, then you can notice that what we're computing here is a chain of subgroups in a symmetric group Sk (a group of all permutations of k elements). By Lagrange's theorem, if a group G is a subgroup of a finite group H, then |H| is a multiple of |G|. Therefore, each new set of achievable decks is at least twice as large as the previous one. It means that:

The set of generators is always at most as large as log2(k!),The time needed to compute all the subgroups can be bounded by log2(k!) times the sizes of all subgroups in the chain. As the sizes are growing exponentially large, the sum of sizes is at most O(k!). Therefore, all the additions take at most O(k!logk) time.The time complexity of the intended solution was therefore O((k!)2+nk!k).

The solution can be sped up significantly by computing all possible sets of achievable decks (i.e., all subgroups of Sk) — for k=5, there are only 156 of them. Some preprocessing will then allow us to add a single element to the subgroup in constant time. This was however not necessary to get AC.

1229E1 - Marek and Matching (easy version)Let's first discuss one of possible solutions for the easy subtask.

Let's assume that n=6 (all smaller n's can be easily reduced to this case). There are two layers of vertices: left L={ℓ1,ℓ2,…,ℓ6} and right R={r1,r2,…,r6}. Let's do meet-in-the-middle on the right layer: Ra={r1,r2,r3} and Rb={r4,r5,r6}.

Consider two parts of the graph: between L and Ra, and between L and Rb. Each of them has n⋅n2=18 edges, so we can try all subsets of edges in each of them separately. For each such subset:

Compute the probability that we'll generate exactly this subset of edges.Find all 3-element subsets of L which can match perfectly with the currently considered half of R.This can be done easily in 218×poly(n) time.

Now, here's a trick — there are only (63)=20 three-element subsets of L! Therefore, for each 20-element mask M, we can find:

pa(M) — the probability that the set of three-element subsets of L matching perfectly with Ra is exactly M,pb(M) — the probability that the set of three-element subsets of L whose complements match perfectly with Rb is exactly M.Let's find the probability that there is no perfect matching in the graph. We can see that it's ∑A∩B=∅pa(A)pb(B) where A and B are 20-element masks. This can be solved easily using SOS dynamic programming technique. If we let qb(X):=∑Y⊆Xpb(X), then the required sum is ∑A⊆[20]pa(A)qb([20]∖A) where [20]={1,2,3,…,20}.

Therefore, this algorithm allows us to solve the easy version of the problem in 218⋅poly(n)+220⋅20 time.

1229E2 - Marek and Matching (hard version)Let's consider another approach that can solve the hard subtask as well.

In the algorithm above, we computed all k-element subsets of L, |L|=n, that can match perfectly with some fixed k vertices on the right. It turns out that not all families of subsets can be generated — for instance, if two sets: {ℓ1,ℓ2} and {ℓ3,ℓ4} can both match perfectly with {r1,r2}, then one of the following subsets: {ℓ1,ℓ3} and {ℓ1,ℓ4} must match perfectly as well. We'll try to use this observation to solve the problem.

Let's add the vertices of R one by one. After adding vertices r1,r2,…,rk, consider all families of k-element subsets of L which can match perfectly with {r1,r2,…,rk} in any generated graph. Now try adding rk+1. Check all 2n ways of randomly drawing a subset of n edges incident to rk+1. For each such subset and for each family Fk of k-element subsets computed previously, we need to compute the new family Fk+1 of (k+1)-element subsets of L matching perfectly with {r1,r2,…,rk+1}. We can do it in a straightforward way — iterate over all (k+1)-element subsets S⊆L. If S matches perfectly with k+1 vertices on the right, then rk+1 must be connected to some vertex ℓ∈S, and {r1,…,rk} must match perfectly with S∖{ℓ}.

This allows us to solve the whole problem in O(n⋅max number of families at any moment⋅2n) time. It turns out that for n=7, here are at most ∼30000 families for any value of k. This allows to solve the problem in a reasonable time. The model solution finishes within 1.5 seconds, but some breathing space was added so that some less efficient implementations will pass as well.

1229F - Mateusz and Escape RoomLet's introduce the variables x1,x2,…,xn where xi is the number of coins passed from the i-th to the (i+1)-th scale (or, xi<0, it means that −xi coins are passed from the (i+1)-th to the i-th scale). We can now create the following conditions regarding the final number of stones on each scale:

ai−xi+xi−1∈[li,ri]for all i.It turns out that for any sequence integers x1,…,xn satisfying the inequalities before, we can create a sequence of |x1|+|x2|+⋯+|xn| moves satisfying all the conditions in the statement! In order to see this, consider a few cases:

If x1,x2,…,xn>0, then we take any coin and make a full lap with it along the circle in the order of increasing i's. We can now decrease each xi by one.If x1,x2,…,xn<0, we can do the similar thing, but we're decreasing i's.In the remaining cases, we can pick a scale i that won't receive coins anymore (that is, xi≥0 and xi−1≤0) and it still has some coins to distribute (xi>0 or xi−1<0). If xi>0, take a single coin, put it on the (i+1)-th scale, and decrease xi by one. If xi−1<0, take a coin, put it on the (i−1)-th scale, and increase xi by one.By following these operations, we will create the final configuration in |x1|+⋯+|xn| moves.

Therefore, we need to minimize this value. Let's try to guess x1 and try to optimize |x1|+|x2|+⋯+|xn| for some fixed x1. The simplest way is to write a dynamic programming: dp(i,xi)= the minimum value of |x1|+|x2|+⋯+|xi| given a value of xi and such that the final numbers of stones on the second, third, fourth, …, i-th scale are satisfied. To progress, we iterate over the possible values xi+1 such that ai−xi+xi−1∈[li,ri] and compute the best value of dp(i+1,xi+1). Notice that the initial state is dp(1,x1)=|x1| and dp(1,⋆)=+∞ everywhere else. To compute the result, we must take the minimum value dp(n,xn) for xn satisfying a1−x1+xn∈[l1,r1].

How to improve this DP? First of all, we'll try to maintain the dp(i,xi) as a function on xi. In order to compute dp(i+1,x) from dp(i,x), we'll need to:

Shift the function (left or right).Given a function f and a constant t, compute g(x):=miny∈[x,x+t]f(x).Given a function f, compute g(x):=f(x)+|x|.It turns out that after each of these operations, the function remains convex. We can therefore say that the function is linear on some segments with increasing slopes. Therefore, we can maintain a function as a set of segments, each segment described by its length and its slope.

How to describe the second operation? We can see that it's actually adding a segment with slope 0 and length t to the function. Meanwhile, the third operation is splitting the function into two parts: for negative and positive x. We need to decrease the slopes in the first part by 1, and increase the slopes in the second part by 1.

All these operations can be implemented on any balanced BST in O(logn) time. Therefore, the whole subproblem (for fixed x1) can be solved in O(nlogn) time.

How to solve the general problem? It turns out that...

Lemma. The function F mapping x1 into the optimal result for a fixed x1 is convex.

Proof will be added if anyone requests it. The basic idea is to prove that: (1) the answer won't change if xi could be any arbitrary real values, (2) if (a1,…,an) and (b1,…,bn) are good candidates for (x1,…,xn), so is (a1+b12,…,an+bn2). We can use that to show that F(a1)+F(b1)2≥F(a1+b12).

Therefore, we can run a ternary search on x1 to find the optimal result for any x1. This ternary search takes O(log(∑ai)) iterations, so the final time complexity is O(nlognlog(∑ai)) with a rather large constant.

Codeforces Round #587 (Div. 3) Editorial

By vovuh, history, 3 years ago, In EnglishAll problems except the problem F are invented by fcspartakm. The problem F idea belongs to BledDest.

1216A - Prefixes

Tutorial1216A - PrefixesThe problem can be solved like this: firstly let's iterate over all i from 1 to n2. If characters s2i−1 and s2i are the same then we obviously need to replace one of them with the other character. We can see that such replacements are enough to make the string suitable.

Solution1216B - Shooting

Tutorial1216B - ShootingWe can see that because the multiplier x in the formula (ai⋅x+1) is the position of the number and we want to minimize the sum of such formulas, the following greedy solution comes up to mind: because we want to count greater values as earlier as possible, let's sort the array a in non-increasing order (saving initial indices of elements), calculate the answer and print the permutation of indices in order from left to right.

Solution1216C - White Sheet

Tutorial1216C - White SheetThere are at least two solution to the problem. I'll describe both of them.

The first solution: firstly let's notice that the point we search can have non-integer coordinates, but if the answer exists then there will be the answer such that its point has at most half-integer coordinates. So let's multiply all coordinates by two and solve the problem with integer coordinates. The second thing is that for some x there is only two points we need to check — top point with this x and bottom point with this x. The same for some y. So we can iterate over all possible values of x and check if the point (x,y1) lies outside of both black rectangles. The same with point (x,y2). Then do the same for points (y,x1) and (y,x2). x should be in range [x1;x2] and y should be in range [y1;y2]. Time complexity is linear on size of the white rectangle.

The second solution is most tricky but has the better time complexity. Let wb1 be the intersection of white rectangle and the first black rectangle, wb2 the same but with the second black rectangle and inter be the intersection of wb1 and wb2. Then it is obvious that the answer exists if wb1 and wb2 doesn't cover the whole white rectangle (sq(w)>sq(wb1)+sq(wb2)−sq(inter)). Time complexity: O(1).

Solution 1Solution 21216D - Swords

Tutorial1216D - SwordsFirstly, let's notice that for the fixed value of z our problem is reduced to the following: we are given n numbers a1,a2,…,an. We need to choose such values k1,k2,…,kn that a1+k1⋅z=a2+k2⋅z=⋯=an+kn⋅z. And among all such values k1,k2,…,kn we need to choose values in a way to minimize ∑i=1nki. And the sum of ki is y! Of course, for the fixed value z the minimum sum of ki can be only one.

Let's start with z=1. It is obvious that if the maximum value in the array a is mx the value ki equals mx−ai (for z=1). Assume that each ki from 1 to n has some divisor d. Then if we multiply z by d and divide each ki by d the answer will only become better. How to calculate this value of z fast? We can see that this value equals to gcd(k1,k2,…,kn)! And it can be proven that this value of z is always optimal and we can easily determine y for such z.

Time complexity: O(n+logmax(ai)).

Solution1216E1 - Numerical Sequence (easy version)

Tutorial1216E1 - Numerical Sequence (easy version)Let's take a look on the upper bound of the number n, where n is the maximum possible number of block which can be asked. If we assume that each number has length 1 then the sum of lengths will be equal to 1+2+⋯+n. And as we know this value equals n(n+1)2. So the maximum value of n is not greater than O(k−−√).

Now we can just iterate over all i from 1 to n (where n is no more than 5⋅104) and carry the length of the last block. If this length is greater than or equal to k (0-indexed) then let's decrease k by this length, increase the length of the last block and continue. Otherwise our answer lies in the current block. So then let's iterate over all j from 1 to i and if the decimal length of j is greater than or equal to k then decrease k by this length otherwise our answer lies in the current number j and we just need to print jk (0-indexed).

Time complexity: O(k−−√) per query.

Solution1216E2 - Numerical Sequence (hard version)

Tutorial1216E2 - Numerical Sequence (hard version)This problem idea is not very hard. Now n can be up to 109 so we need to find the number of block i faster. Let's do binary search on it! Now using some shitty pretty formulas we can determine if the total sum of lengths of blocks from 1 to i is greater than or equal to k or not.

And more about these formulas: let's iterate over all possible length of numbers from 1 to len(i) and carry the sum of lengths add of numbers with length less than the current length l. We know that the number of numbers (he-he) of length l is exactly cnt=10l+1−10l (cnt=i−10l+1 for l=len(i)). Let's add add⋅cnt+cnt(cnt+1)2⋅cnt to the total sum of lengths and increase add by cnt⋅len.

What does add⋅cnt means? This formula means that we have exactly cnt blocks ending with numbers of length l and we need to add sum of lengths of all numbers with length less than l exactly cnt times. And what does cnt(cnt+1)2⋅cnt means? It is the sum sums of lengths of all numbers of length l (i.e. previously we added sum of lengths of numbers with length less than l and now we add sum of sums of lengths of numbers with length l).

When we found the number of block i, let's decrease k by the total length of all blocks from 1 to i−1 and continue solving the problem.

This part was pretty hard to understand. And the easiest part: when we determined the number of block i we can easily determine the number j from 1 to i such that our answer lies in the number j. Let's iterate over all lengths from 1 to len(i) (here we go again) and for the current length l let cnt=10l+1−10l (cnt=j−10l+1 for l=len(j)). And now all we need is to increase the sum of lengths by cnt⋅len.

After determining j decrease k by sum of lengths of numbers from 1 to j−1 and print jk.

Time complexity: O(log2n).

Solution1216F - Wi-Fi

Tutorial1216F - Wi-FiFirstly, I know that this problem has very pretty linear solution and its author can describe it if he wants. I'll describe my own solution without any data structures but std::set.

Let dpi be the total cost to connect all rooms from i to n−1 to the Internet (0-indexed). Initially dpn=0, all other values are +∞. Let's iterate over all i from n−1 to 0 and make some transitions. After all the answer will be dp0.

The first transition is the easier: update dpi with dpi+1+i+1 (just connect the current room directly). To do other transitions, let's carry two sets mins and vals and one array of vectors del of length n. Set mins carries all values dpi+1,dpi+2,…,dpi+k+1. Initially it carries dpn=0. Set vals carries the minimum cost to cover some suffix of rooms that also covers the room i. Array of vectors rem helps us to carry the set vals efficiently. First of all, if i+k+2≤n then let's remove dpi+k+2 from mins. Then let's remove all values of deli from vals. Then if vals is not empty, let's update dpi with the minimum value of vals. Then if si= '1' then let val be the minimum value of mins plus i+1. Update dpi with val and insert val into vals. Also let's add val into deli−k−1 if i−k−1≥0. And after we make all we need with the current i, add the value dpi to the set mins.

Time complexity: O(nlogn).

It can be optimized to O(n) solution with some advanced data structures as a queue with minimums.

Solution

Codeforces Round #586 Editorial

By wrg0ababd, history, 3 years ago, translation, In EnglishUpdate: editorial for G is out

1220A - CardsIt's easy to see that letter z contains only in zero and n contains only in one, so we should print 1 count(n) times and then 0 count(z) times.

1220B - Multiplication TableLet's note that (xy)⋅(xz)(yz)=x2 if x,y,z>0. In this problem n≥3, so we can get each value this way.

1220C - Substring Game in the LessonThe main idea of this task is that Mike never moves. Lets fix k, there two cases:

1) s[k]≥s[i] for all i<k, in this case s[k,k]≤s[l,r] for all l≤k и r≥k, so Ann can't make her first move (Mike wins).

2) There is i<k such that s[i]<s[k]. In this case Ann can move with substring s[i,r]. If we choose the least possible i<k such that s[i] is minimal, we will deprive Misha of the opportunity to make a move (Ann wins)

Final solution: for all k we should check whether s[k] is the least on substring s[0,k]. It can be done with one for in wich we should maintain a minimum on prefix. Complexity O(|s|).

1220D - Alex and JulianLet all numbers in B be odd. If two vertices i and j are connected, then they have different parity, hence our graph is already bipartite (first part is even vertices, second – odd vertices).

Now let's see that if we choose an integer k>0, multiply all elements of the set by 2k and build a new graph on this set, our new graph will also be bipartite. Proof: consider k-th bit. An edge connects only vertices with different k-th bit, so partition is clear.

So, we found out that if all elements in B have equal power of 2 in their factorization, then this set builds a bipartite graph. What about other cases? Let a,b∈B. They form a cycle with len=lcm(a,b)a+lcm(a,b)b=agcd(a,b)+bgcd(a,b). It's easy to see that len is odd iff a and b contain different powers of 2 in their factorization, so we just proved that there is no other cases.

Finally, the solution is to find maximum power of 2 that divides Bi for all 1≤i≤n, find the largest subset B′ with equal power of 2 and drop B∖B′. Complexity O(nlogmaxB).

1220E - TourismLet's note that if you visit a vertex u located on a loop, you can always add the numbers on vertices in this loop to answer and you can also add the numbers on vertices between u and s. It is true because you can just visit u, go through the vertices of the cycle, return to u and then go back to s. But if from the given vertex we can't get to the cycle, then we can't return back. So the problem is to сhoose the best branch leading only to the leaves. And from this point there are several solutions for this problem. Let's discuss one of them:

Let eu be the maximum extra value we could get, if we are in u and we want to go only to leaves. First of all just put all the leaves except s in stack or queue. Then we choose the next vertex u from our queue and look at its parent v. Let's decrease v's degree and update ev=max(ev,eu+wu). If v's deegre became 1, it means that v is the leave now, so let's push it in our queue, if it isn't s. It looks like at each step, we just erase one leave from our graph and recompute e value for its parent.

At the end, we considered all vertexes which are not belong to the cycles and not belong to the pathes from s to one of the cycles. So we need to sum up the biggest eu with the sum of all wv, where v wasn't considered during our leaves removing.

There are also solutions that build edge-connectivity components and compute the value using DP on tree.

1220F - Gardener AlexNotice that element a is an ancestor of an element b when it's minimum on a subsegment from a to b. Count amount of ancestors for every element in initial permutation. Now, when you remove element l from the left, all elements between it and the leftmost element smaller than l now have one ancestor less. When you move it to the right, all elements between it and the rightmost element smaller than it have one ancestor more. And new amount of ancestors for element moved to the right is one more than amount of ancestors of the rightmost element smaller than it. You can store amounts of ancestors in a segment tree with lazy propagation if you concatenate given permutation with itself.

1220G - GeolocationLet's look on the sum of squared distances from unknown point (x;y) to all known points (xi;yi):

∑i=1nd2i=∑i=1n((x−xi)2+(y−yi)2)=n(x2+y2)−2x∑i=1nxi−2y∑i=1nyi+∑i=1n(x2i+y2i)If we switch to new coordinates with the origin in the center of mass of all points, terms ∑i=1nxi and ∑i=1nyi will be equal to zero, thus the whole sum will be equal to:∑i=1nd2i=n(x2+y2)+∑i=1n(x2i+y2i)From this we obtain that all possible points (x;y) lie on the circumference with the center in the center of mass of all points with the squared radius equal to 1n∑i=1n(d2i−x2i−y2i). Due to the randomness of unknown point we may assume that there is only as much as logn integer points on this circumference. If we try all possible distances from first point, we may reduce possible points to only those found on the intersection of two circumferences.

Codeforces Round #585 Editorial

By BledDest, 3 years ago, translation, In English1215A - Yellow Cards

Editorial1215A - Yellow CardsAt first, if k1>k2, then we swap k1 with k2 and a1 with a2, so the number of yellow cards required to send a player of the first team off is not greater than the same value for the second team.

If all players from the first team receive k1−1 cards each and all players from the second team receive k2−1 cards each, we will minimize the number of players who left the game. Let cnt=a1⋅(k1−1)+a2⋅(k2−1). If cnt≤0, then the minimum number of players who left the game is equal to 0. In the other case, if any player receivse one more yellow card, he leaves the game. So the minimum number of players who left the game is (n−cnt).

When we maximize the number of players who left the game, at first we should give cards to players in the first team, and then give cards to players in the second team. So, if n≤a1⋅k1, the answer is ⌊nk1⌋. In the other case, the answer is a1+⌊n−a1⋅k1k2⌋.

Solution (fcspartakm)1215B - The Number of Products

Editorial1215B - The Number of ProductsAt first, let's calculate the value of ansp — the number of subsegments with positive product. We should iterate through the array and store bal — the number of negative elements. Also we should store cnt1 and cnt2 — the number of elements such that there is an even number of negative elements before them (cnt1) or an odd number of negative elements before them (cnt2). If for the current element bal is even, we should increase cnt1 by one, else we should increase cnt2 by one. Then if the current element is negative, we should increase bal by one. Then we should add the number of subsegments ending in the current element and having positive product to ansp. If bal is even, then any subsegment ending in the current element and containing even number of negative elements should begin in a position where bal was even too, so we should add cnt1 to ansp. If bal is odd, we should add cnt2 to ansp (we use similar reasoning).

The number of segments having negative product can be calculated, for example, by subtracting ansp from the total number of subsegments, which is n⋅(n+1)2.

Solution (fcspartakm)1215C - Swap Letters

Editorial1215C - Swap LettersLet's calculate two vectors pos01 and pos10. pos01 will contain all positions x such that s[x]=0 и t[x]=1. Analogically, pos10 will contain all positions x such that s[x]=1 и t[x]=0. If the sizes of these vectors are not equal modulo 2, the answer does not exist, because the total number of letters "a" and "b" should be even.

In the other case, we should perform operations in a greedy way. In one operation we can make s[a] equal to t[a] and s[b] equal to t[b], if both a and b belong to pos01, or if both these positions belong pos10.

If the sizes of pos01 and pos10 are even, we need only (|pos01|2+|pos10|2) operation. In the other case, there are two positions x and y such that s[x]=0, s[y]=1, t[x]=1, t[y]=0. We need two operations to make s[x]=t[x] and s[y]=t[y]: at first we perform the operation (x,x), and then the operation (x,y). After that, strings s and t will be equal to each other.

Solution (fcspartakm)1215D - Ticket Game

Editorial1215D - Ticket GameLet's denote the balance as the difference between the sum of digits in the left half and the sum of digits in the right half. Also let L be the minimum possible balance (it can be calculated if we replace all question marks in the left half with 0's and all the question marks in the right half with 9's), and let R be the maximum possible balance.

The second player wins if and only if L+R2=0. Let's prove it by induction on the number of question marks left in the ticket.

If all characters are digits, the second player wins only if the ticket is happy, and that is when L+R2=0.

Okay, now suppose the number of question marks is even, and now it's first player's turn. Each turn decreases the value of R−L by 9, and may set L to any number from current L to L+9. If L+R>0, then the first player can make L as large as possible, and set it to L+9. The best thing the second player can do on his turn is to set R to R−9 (and leave L as it is), and the value of L+R will be the same as it was two turns earlier. The case L+R<0 can be analyzed similarly. And in the case L+R=0 the second player has a symmetric strategy.

Solution (fcspartakm)1215E - Marbles

Editorial1215E - MarblesThe main fact is that the number of colors is less than 20, which allows us to use exponential solutions.

For each pair of colors (i,j), we can calculate cnt[i][j] — the number of swaps required to place all marbles of color i before all marbles of color j (if we consider only marbles of these two colors). We can store a sorted vector for each color, and calculate this information for a fixed pair with two pointers.

Then let's use subset DP to fix the order of colors. Let d[mask] be the minimum number of operations to correctly order all marbles from the mask of colors. Let's iterate on the next color we consider — it should be a position in binary representation of mask with 0 in it. We will place all marbles of this color after all marbles we already placed. If we fix a new color i, let's calculate the sum (the additional number of swaps we have to make) by iterating on the bit j equal to 1 in the mask, and increasing sum by cnt[j][i] for every such bit. The new state of DP can be calculated as nmask=mask|(1«i). So the transition can be implemented as d[nmask]=min(d[nmask],d[mask]+sum).

The answer is the minimum number of swaps required to place all the colors, and that is d[220−1].

Solution (fcspartakm)1215F - Radio Stations

Editorial1215F - Radio StationsLet's try to solve the problem without any constraints on f (we just need to choose a set of stations that satisfies all the complaints and contains no forbidden pair). We can see that this is an instance of 2-SAT: we can convert it into a logical expression that is a conjunction of some clauses, and each clause contains exactly two variables (maybe negated), we have to assign some values to all variables so that this expression is true. The i-th variable true if we include the i-th station in our answer, or false otherwise. We can solve this problem in linear time by building an implication graph and finding strongly connected components in it.

If the constraints were lower, we could iterate on f and initially set all variables corresponding to stations we can't use with fixed f to false. But this solution is quadratic, so we have to include f into our original 2-SAT problem.

Let's introduce M additional variables, the i-th of them corresponding to the fact "f≥i". Add M−1 clause of the form "f≥i OR NOT f≥i+1" into our conjunction. The prefix of additional variables which are equal to true can be transformed into the value or f we should use, and vice versa. If we introduce these variables, the constraints on f that are implied by some station can be modeled with two additiona clauses: "f≥li OR station i is not used" and "NOT f≥ri+1 OR station i is not used". So we get a linear solution (though with a noticeable constant factor).

Solution (BledDest)

Codeforces Round #584 (Dasha Code Championship Elimination Round) (div. 1 + div. 2) Editorial

By dragonslayerintraining, 3 years ago, In English1209A — Paint the NumbersAuthor: MikeMirzayanov

Consider the smallest element x in the array. We need to paint it in some color, right?

Observe, that we can paint all elements divisible by x in that color as well.

So we can perform the following while the array is not empty:

find the minimum element x,assign new color and remove all elements divisible by xComplexity: O(n2).

1209B — Koala and LightsAuthor: FieryPhoenix

Because each individual light flashes periodically, all the lights together are periodic as well.

Therefore, we can simulate the lights up to the period to get the answer.

The actual period can be calculated as follows:

SpoilerHowever, computing the actual period is not necessary and a very large number will work (like 1000).

Challenge: Can we bound the time even more?

1209C — Paint the DigitsAuthor: MikeMirzayanov

The sequence must split into two non-decreasing where the end of the first ≤ start of the second.

Let's bruteforce the value x, so that all elements <x go to the color 1, all elements >x go to the color 2, and for =x we are not sure.

Actually, we can say that all elements equal to x, which go before the first element >x сan safely go to the color 2, while the rest can only go to the color 1.

So we colored our sequence and we now only need to check whether this coloring is fine.

Complexity is 10⋅n.

1209D — Cow and SnacksAuthor: FieryPhoenix

Since every animal has exactly two favorite snacks, this hints that we should model the problem as a graph. The nodes are the snacks, and the edges are animals with preferences connecting snack nodes.

Let's consider a connected component of the graph with size greater than 1. The first animal (edge) in that component to eat must take two snacks (nodes), all other snack nodes will be eaten by exactly one animal edge. It is always possible to find an order so that no other animals takes two snacks (for example, BFS order). Thus, a connected component with c vertices can satisfy at most c−1 animals.

Let N be the number of snacks, M be the number of animals, and C be the number of connected components (including those of size 1). The number of satisfied animals is N−C, so the number of of unhappy animals is M−(N−C).

Complexity: O(n+m)1209E1 — Rotate Columns (easy version)Authors: MikeMirzayanov and cdkrot

There many approaches possible, let's describe one of them.

Let's change the problem to the following:

Rotate columns any way you want.Select in each row one value, maximizing the sum.This can be done with a dp, states are (prefix of columns, mask of taken columns). Basically at each step we are rotating the current column and fixing values for some of the rows.

The most simple way to write this makes 3n⋅m⋅n2 (for every submask->mask transition iterate over all possible shifts and elements to consider in cost function).

But if we precalculate the cost function in advance, we will have O((3n+2nn2)⋅m).

1209E2 — Rotate Columns (hard version)The previous solution is slightly too slow to pass the large constraints.

Let's sort columns by the maximum element in them. Observe, that it is surely unoptimal to use columns which go after first n columns in sorted order (we could've replaced them with some unused column).

So we can solve the hard version with previous solution in which we consider only best n columns.

Complexity O((3n+2n⋅n2)⋅n+T(sort))1209F — Koala and NotebookAuthor: dragonslayerintraining

First split all edges into directed edges with single digit labels, creating O(mlogm) dummy vertices if necessary.

Since the first edge will not be zero (no leading zeros), longer paths are always greater. With a BFS, this reduces the problem to finding lexicographical minimal paths in a DAG.

To avoid needing to compare long sequences, we will instead visit all the vertices in order by their lexicographical minimal path. This can be done efficiently by something like BFS/DFS.

The main idea is to visit sets of vertices at a time. If we have a set of vertices whose minimal paths are P, we can find the set of vertices whose minimal paths are P0 by following all outgoing 0 edges. Then, we find the set of vertices whose minimal paths are P1 by following all outgoing 1 edges, and so on for all digits. Since we ignore vertices once they are visited, this is O(mlogm)1209G1 — Into Blocks (easy version)Author: Errichto

Let's solve easier version first (we will reuse core ideas in hard version as well).

Clearly, if some two integers are ``hooked'' like in 1…2…1…2, then they will end up being turned into the same integer.

So when we see integer x with first occurrence at a and last at b, let's mark segment [a;b] as blocked. E.g. for array [3,3,1,2,1,2] we have not blocked only the bar between 3 and 1, that is we have |3,3|1,2,1,2|.

Now for every such segment we have to change all elements into a common element. So the answer for a segment is segment length minus the number of occurrences of the most frequent element.

One easy implementation is as follows: blocking is "+= 1 on segment" (can be done easily in O(n+operations) in offline, then for an element x, put the number of it's occurrences in the position of first occurrences.

Now we only need to compute max on disjoint segments, so it can be done in a naive way.

Complexity: O(n).

1209G2 — Into Blocks (hard version)To adjust the solution for many queries we need to create some sophisticated data structure.

E.g. we all know that mentioned above "+= 1 on a segment" is easily done with a segtree. If we maintain for every value ai the corresponding set of occurrences, it's easy to update mentioned above ``number of occurrences in the first position''.

So what we need to do now? We need to dynamically recalculate the sum of minimums (and the set segments to calculate minimum can change quite much due to updates).

You probably also now that we can design a segtree which supports range increments and query (minimum, number of minimums) on the segment. In a similar way we can build a structure which returns (minimum, number of minimums, the sum of largest stored counts between minimums). Just maintain a few values in each node and do lazy propagation.

Complexity O(qlogn).

1209H — Moving WalkwaysAuthor: Errichto

Some minor tips:

Everything is a walkway. When there is no walkway, it is a walkway of speed 0.You can increase all speeds by 1 and assume that you own speed is in [−1;+1]Energy is an entity which is δ speed × time, which is distance.Also if you spend x energy per segment of len l and speed v, it is not important how exactly you will distribute it over the walking process. In any way, you will walk by feet l−x meters in time (l−x)/v.

So it turns out it's better to distribute more energy to low-speeded walkways (because the denominator is smaller).

Assume that you (by default) save up all energy on any non-feet path (for feet path it's always optimal to walk with speed ≥1 (≥0 after speeds hack), so now save up's).

Build an energy graphic where the Ox axis will correspond to the point you are in (not time). It will be a piecewise linear function, so it is enough to store it's value only in points corresponding to points between walkways. Iterate over walkways in the order of speed and try to steal as much energy as possible to the current walkway.

What are the limits of stealing energy?

there is a restriction based on l and v (if you take too much energy, you wouldn't be able to fully walk it up)the graphic must still be able above 0 at all points.The latter condition is just a suffix minima on a segment tree.

Complexity: O(nlogn).

Editorial of Codeforces Round #583 (based on Olympiad of Metropolises)

By ch_egor, 3 years ago, In EnglishThanks for the participation!

1214A - Оптимальный обмен валюты was authored and prepared by Helen Andreeva.

1214B - Бейджи was authored by jury and prepared by Chmel_Tolstiy.

1214C - Плохая последовательность was authored by meshanya and prepared by GoToCoding.

1214D - Остров Сокровищ was authored by meshanya and prepared by malcolm.

1214E - Петя и конструктор was authored and prepared by voidmax.

1214F - Трудоустройство was authored and prepared by grphil.

1214G - Хорошее настроение was authored and prepared by isaf27.

1214H - Укладывание плитки was authored and prepared by cdkrot.

1214A - Optimal Currency ExchangeIf we have bought dollar bills with value of two or more dollar bill, we can change it one-dollar bills. Same goes for euro, we can replace all euro bills with several 5-euro bills.

Now we can simply try buying some number of five-euro bills and buying all the rest with one-dollar bills.

    int ans = n;    for (int i = 0; i * 5 * e <= n; ++i) {        ans = min(ans, (n - i * 5 * e) % d);    }Complexity is O(n).

1214B - BadgesVasya must take one deck for each possible combination (participantsgirls,participantsboys) (where 0≤participantsgirls≤g, 0≤participantsboys≤b and participantsgirls+participantsboys=n).

Let's determine how many girls can come for the game:

at least n−min(b,n),at most min(g,n).All intermediate values are also possible, to the answer is just min(g,n)−(n−min(b,n))+1.

1214C - Bad SequenceLet's call a balance of bracket sequence a number of opening brackets minus the number of closing brackets. Correct bracket sequence is such a sequence that balance of any of its prefixes is at least 0 and the balance of the entire sequence is equal to 0.

To solve the problem let's consider the shortest prefix with balance equal to −1. In this prefix last symbol is obviously equal to ")", so let's move this closing bracket to the end of the sequence. If the sequence is correct now, then the answer is "Yes", otherwise it is "No", because it means that in original sequence there exists some longer prefix with balance equal to −2. Let's show why we can't move some bracket so that the sequence becomes correct.

Consider the shortest prefix with balance equal to −2. If we move some opening bracket to the beginning of the sequence, balance of considered prefix becomes −1 and the sequence is not correct yet. Moving opening bracket from considered prefix to the beginning doesn't change anything. Even more, if we move the closing bracket from the end of the considered prefix to the end of the sequence, it still doesn't become correct, because balance of the prefix is −1.

This results in a following solution: if balance of all prefixes is not less than −1, answer is "Yes", otherwise it's "No".

1214D - Treasure IslandThe answer is no more than two as we can block (2,1) and (1,2). If there is no way from (1,1) to (n,m), the answer is zero. The only thing to do is to distinguish k=1 and k=2.

If answer is one, there must exist such cell (x,y) that each path from (1,1) to (n,m) goes through that cell. Also we can notice that in each path the cell (x,y) goes on the (x+y−1)th place.

Let's run dfs to obtain the set of cells which are accessible from (1,1) and dfs backwards to obtain the set on cells such that (n,m) is accessible from them. Let's intersect these sets and group cells by the distance from (1,1). If some group has a single cell, that would be the cell to block and the answer is one. If each group has more than one cell, the answer is two.

1214E - Petya and Construction SetAssume without loss of generality that the array d sorted in non-increasing order.

Let's make a linear ("bamboo") graph from the vertices 1,3,5,…,2n−1 in this order. We will add nodes 2i one by one, we will also maintain the longest route during that. On the i-th step we are looking for the vertex at the distance di−1 from 2i−1. That node is (i+di−1)-th on the route. So we can connect to it vertex 2i. If 2i was connected to the last vertex of the route we should add 2i to the end of it.

(i+di−1)-th node on the longest route always exists because of two limitations:

d1≤nfor all i≥2: di−1≥di.1214F - EmploymentFirst, let's notice that the optimal answer can be achieved without changing the relative order of candidates. That means that if we order candidates by circle clockwise, the second candidate will work at the next clockwise workplace from the first candidate's workplace, the third candidate will work at the next clockwise workplace from the second candidate's workplace and so on. Let's prove it. If in optimal answer the order has changed, then there should be 2 candidates, so that the first of them lives earlier clockwise then the second and works at workplace, which is further. If we swap their workplaces, the distance between home and workplace for each of them will either stay the same or decrease. So, doing this swaps, we can achieve the situation, when the relative order of candidates stay the same.

Now we can come up with simple O(n2) solution. Let's first sort all candidates and workplaces by their city number. Let's select some workplace for the first candidate. Because in the optimal answer the order of candidates will not change, for each candidate we know his workplace. Now in O(n) time we can calculate the total distance. And because there are n possible workplaces for the first candidate, the solution works in O(n2) time.

To solve problem faster, let's notice, that if some candidate lives in city with number x and his workplace has number y, the the total distance from home to work for him will be:

−x+y+m if y<x−m/2x−y if x−m/2≤y<x−x+y if x≤y<x+m/2x−y+m if x+m/2≤ySo for each candidate we have at most 4 intervals of workplaces positions, at which the sign before the candidate's home position in the distance formula stays the same. The same way for each workplace we have at most 4 intervals of candidates positions, where the sign before the workplace position in distance formula stays the same. Also, there are 4 intervals of candidates positions, where we need to add m to the distance formula. Because the relative order of candidates stays the same, we can iterate over all possible workplaces for the first candidate and check the total distance in each variant. When we move first candidate workplace to the next, for some candidates and workplaces their distance formula can change, but for each of them it can change no more then 4 times. So we will totally do no more then 8n changes. All in all we will check all distances in O(nlogn) time (we have additional logarithm because of sorting).1214G - Feeling GoodLet's define the set Ai for each 1≤i≤n as a set of columns j, such that the color of the cell (i,j) is blue. If there exists two rows 1≤x1<x2≤n, such that Ax1⊄Ax2 and Ax2⊄Ax1 the good mood certificate exists. It's easy to see, because if Ax1⊄Ax2 there exists some y1, such that y1∈Ax1 and y1∉Ax2 and if Ax2⊄Ax1 there exists some y2, such that y2∈Ax2 and y2∉Ax1. Four cells (x1,y1), (x1,y2), (x2,y1), (x2,y2) will be the good mood certificate. Otherwise, if for any two rows 1≤x1<x2≤n Ax1⊂Ax2 or Ax2⊂Ax1, there is no good mood certificate.

Let's use bitset ai for each row, such that aij=1, if the color of the cell (i,j) is blue. For two rows 1≤x1<x2≤n it's easy to check that Ax1⊂Ax2 or Ax2⊂Ax1 and find any good mood certificate if it is false using simple operations with two bitsets ax1 and ax2 in time O(mw). Let's sort rows by the size of Ai. If for every two adjacent rows in this order one of them was a subset of other it is true for every pair of rows. So, we can check only pairs of adjacent rows in the sorted order. Let's keep a set of rows, sorting them by the size of Ai. And let's keep set of any good mood certificate for every two adjacent rows in the first set, if it exists. Now, if some row x changes, we can change bitset ax in time O(mw) and make O(1) changes with our two sets.

Time complexity: O((logn+mw)q), there w=32 or w=64.

1214H - Tiles PlacementSuppose there exists a vertex with tree with a tree paths going from it, with longest paths of lengths a, b and c (in edges).

Then if a+b≥k−1, b+c≥k−1, a+c≥k−1, then clearly the answer is Impossible.

We can check whether such vertex exists in O(n) using subtree dp and "uptree dp".

Good news: this is the only case when the answer is "No".

Bad news: providing the coloring is slightly more sophisticated.

In fact, we can prove that the following coloring works:

Construct a tree's diameter.Color vertices on diameter with periodic colors: 1, 2, ..., k, 1, 2, ...By the way, if diameter has less than k vertices, any coloring will be correct.Cut the diameter in half, the parts' lengths will differ by 1 atmost.Color both halves of the tree with dfs: colors in the left part will decrease i→i−1→…, while colors in the right part will increase i→i+1→….The result will look roughly as follows:

The total complexity is O(n).

Let's give a sketch of the proof why this coloring works. Well, suppose there is some bad path of k vertices. Let's analyze path's position with respect to the diameter.

Case 1. The bad path is not related to the diameter.

It's easy to see that blue part of diameter is greater or equal than any half of the red path; so the vertex v is a bad vertex to the our criterion.

Case 2. The bad path goes through a diameter, but lies in one half of it.

The vertex v makes a bad vertex for the criterion, just for the same reasons.

Case 3. The bad path goes through a diameter, and lies in both halves.

If you recall how our coloring looks like, you will see that all paths of this form are well-colored.

Codeforces Round #582 (Div. 3) Editorial

By vovuh, history, 4 years ago, In EnglishAll ideas except the problem C belong to MikeMirzayanov.

1213A - Chips Moving

Tutorial1213A - Chips MovingWe can see that the only information we need is the parity of the coordinate of each chip (because we can move all chips that have the same parity to one coordinate for free). So if the number of chips with odd coordinate is cnto then the answer is min(cnto,n−cnto).

Solution1213B - Bad Prices

Tutorial1213B - Bad PricesLet minPricei be the minimum price of the berPhone during days i,i+1,…,n. We can precalculate this array moving from right to left and carrying the minimum price we met (in other words, if we iterate over all i from n to 1 then minPricei=ai if i=n otherwise minPricei=min(ai,minPricei+1)). Then the answer is the number of such days i from 1 to n−1 that ai>minPricei+1.

Solution1213C - Book Reading

Tutorial1213C - Book ReadingLet k=⌊nm⌋ be the number of integers from 1 to n divisible by m. We can notice that because we write down only the last digit of each number divisible by m then the length of the "cycle" of digits does not exceed 10. In fact, we can always suppose that it is 10 because i⋅m%10=(10+i)⋅m%10 for all i from 0 to 9. So let cyclei=m∗(i+1)%10 for all i from 0 to 9. Then the answer is ⌊k10⌋⋅∑i=09cyclei+∑i=0k%10cyclei.

Solution1213D1 - Equalizing by Division (easy version)

Tutorial1213D1 - Equalizing by Division (easy version)Let x be the number such that after some sequence of moves there will be at least k elements x in the array. We can see that there is always O(nlogn) possible candidates because all values x are among all possible values of ⌊ai2m⌋ for some m from 0 to 18. So we need to check each candidate separately and try to update the answer with it. How to do this?

Let the current number we trying to obtain is x. Then let's iterate over all ai in any order. Let y be the current value of ai. Let's divide it by 2 while its value is greater than x and carry the number of divisions we made cur. If after all divisions y=x then let's remember the value of cur in some array cnt. If after iterating over all n elements of a the size of cnt is greater than or equal to k then let's sort it and update the answer with the sum of k smallest values of cnt.

Time complexity: O(n2log2max(ai)log(nlogmax(ai))) or O(n2log2max(ai)), depends on sorting method.

Solution1213D2 - Equalizing by Division (hard version)

Tutorial1213D2 - Equalizing by Division (hard version)In this problem we need to write almost the same solution as in the previous one (easy version) but faster. Observe that we calculate the value of ⌊ai2m⌋ too many times. Let valsx for all x from 1 to 2⋅105 be the array of numbers of divisions we need to obtain x from every possible ai from which we can. We can calculate these arrays in time O(nlogn). How? Let's iterate over all ai and divide it by 2 while it is positive (and carry the number of divisions cur). Then let's add to the array valsai the number cur before each division.

Then we can see that we obtain the array cnt from the tutorial of the previous problem for each x from 1 to 2⋅105. Let's iterate over all possible values of x and try to update the answer with the sum of k smallest values of valsx if there is at least k elements in this array.

Time complexity: O(nlognlog(nlogn)) or O(nlogn), depends on sorting method.

Solution1213E - Two Small Strings

Tutorial1213E - Two Small StringsWe can check the following solution by stress-testing (or maybe prove it somehow): let's iterate over all possible permutations of the string "abc". Let the first character of the current permutation be c1, the second one be c2 and the third one be c3. Then let's add the following two candidates to the answer: "c_1 c_2 c_3 c_1 c_2 c_3 ... c_1 c_2 c_3" (the string consisting of n copies of "c_1 c_2 c_3") and "c_1 ... c_1 c_2 ... c_2 c_3 ... c_3" (exactly n copies of c1 then exactly n copies of c2 and exactly n copies of c3). Then the answer will be among these 12 strings and we can check each of them naively.

Solution1213F - Unstable String Sort

Tutorial1213F - Unstable String SortBecause if we write down all characters of s in order of both permutations and this string will be sorted, it is obvious that these two strings are equal. Let's try the maximum possible number of distinct characters and then replace extra characters with 'z'. How to find the maximum number of distinct characters?

Let's iterate over all values of p (and q) in order from left to right. If we staying at the position i now, let's add to the set vals1 the value pi and to the set vals2 the value qi. And when these sets become equal the first time, let's say that the block of positions i such that values pi are in the set right now, have the same letter, and then clear both sets. We can see that this segment of positions is the minimum by inclusion set that can contain equal letters. We don't need to compare sets naively and clear them naively, you can see implementation details in author's solution.

If the number of such segments is less than k then the answer is "NO", otherwise the answer is "YES" and we can fill the string s with letters in order of these segments (if the segment is [l;r] then all characters of s with indices pl,pl+1,…,pr has the same letter, the first segment has the letter 'a', the second one has the letter 'b', and so on, all segments after 25-th has the letter 'z').

Time complexity: O(nlogn).

Solution1213G - Path Queries

Tutorial1213G - Path QueriesLet's carry the value res that means the answer for the current set of edges. Initially it is 0. Let's sort all edges by their weight and all queries by their weight also (both in non-decreasing order).

Let's merge components of the tree using DSU (disjoint set union). We need to carry sizes of components also (it is easy if we use DSU). Then let's iterate over all queries in order of non-decreasing their weights. If the current query has weight cw then let's merge all components connected by edges with weight wi≤cw. When we merge two components with sizes s1 and s2, the answer changes like that: res:=res−(s12)−(s22)+(s1+s22). The value (x2) equals to x(x−1)2. It is so because we subtract all old paths corresponding to these components and add all new paths in the obtained component. So the answer for the current query will be res after all required merges.

Time complexity: O(nlogn+mlogm).

Solution

Codeforces Round #581 (div. 2) Tutorial

By rotavirus, history, 4 years ago, In English1204A - BowWow and the TimetableBasically, the problem asks you to count ⌈log4s⌉, which is equal to ⌈log2slog24⌉=⌈log2s2⌉. If we denote l as a length of the input number, then ⌈log2s⌉ is either equal to l−1 if s is the power of two (it can be checked by checking that there is not more than one 1 in the input string), or to l−1 otherwise, so the answer to the problem is either ⌈l−12⌉ or ⌈l2⌉. Also for s=0 the answer is 0.

1204B - Mislove Has Lost an ArrayAny array that satisfies statements' conditions contains only powers of two from 20 to 2k−1, where l≤k≤r, so the minimal sum is achieved when we take powers of two from 20 to 2l−1 and set the other n−l elements equal to 20; the maximal sum is achieved when we take powers of two from 20 to 2r−1 and set the other n−r elements equal to 2r−1.

1204C - Anna, Svyatoslav and MapsFirstly, find the matrix of the shortest paths using Floyd-Warshall algortihm or running dfs from all vertexes; then a greedy approach works here: add p1 to the answer and then go along the path; if the distance from the last vertex in the answer to the current vertex pi is shorter than in given path, add the vertex pi−1 to the answer and continue traversing the path. Don't forget to add pm in the end!

1204D2 - Kirk and a Binary String (hard version)Solution 1: Let's call a string p fixed if there isn't another string t of the same length which satisfies the first condition of the statement (it was about the same lengths of the longest nondecreasing subsequences on substrings). The following statements are obivous:

string 10 is fixed;if strings p and q are fixed, then their concatenation pq is fixed;if a string p is fixed, then the string 1p0 is fixed;each fixed string contains the same number of ones and zeroes;the length of the longest nondecreasing subsequence for any fixed string is equal to the half of its length, which can be obtained by taking all zeroes or all ones;So if we erase all fixed strings from the given string, the remaining parts consists of zeroes at prefix and ones at suffix; it is obvious that we can change all these ones to zeroes and the string still satisfies the condition.

Solution 2: If we change any 1 to 0 and the longest nondecreasing sequence of the whole string remains the same, then we are able to change it to 0. To count the longest nondecreasing sequence of a new string, store and maintain following arrays: dppi — the longest nondecreasing sequence of the substring s1…i; zeroi — number of zeroes in the substring s1…i; dpsi — the longest nondecreasing sequence of the substring si…n and onesi — number of ones in the substring si…n; now, if we change 1 to 0 at a position i, then the length of the longest nondecreasing sequence of a new string is max(dppi−1+onesi+1,zeroi−1+1+dpsi+1).

1204E - Natasha, Sasha and the Prefix SumsLet's count a dp k[x][y] — the number of arrays consisting of x ones and y minus ones such that their maximal prefix sum is equal to 0: if x=0 then k[x][y]=1, else if x>y then k[x][y]=0, else k[x][y]=k[x−1][y]+k[x][y−1], because if we consider any array consisting of x ones and y−1 minus ones which maximal prefix sum is 0 then adding a minus one to the end leaves it equal to 0; also if we consider any array consisting of x−1 ones and y minus ones which maximal prefix sum is 0 then adding a one to the end leaves it equal to 0, because x≤y.

Now let's count a dp d[x][y] — the answer to the problem for n=x and m=y: if x=0 then d[x][y]=0, else if y=0 then d[x][y]=x, else d[x][y]=((x+y−1y)+d[x−1][y])+(d[x][y−1]−((x+y−1x)−k[x][y−1])). That is because if we consider any array of x−1 ones and y minus ones (there are (x+y−1y) such arrays) then adding a one in its beginning increases its maximal prefix sum by 1; also if we consider any array of x ones and y−1 minus ones then adding a minus one in its beginning either decreases its maximal prefix sum by 1 if it was greater than 0 (there are (x+y−1x)−k[x][y−1] such arrays) or leaves it equal to 0. So the answer to the problem is d[n][m].

Editorial of Codeforces Round #580

By antontrygubO_o, 4 years ago, translation, In English1206A - Choose Two NumbersLet a be the largest number in the array A, b be the largest number in the array B. Then the number a+b isn't present neither in the array A nor in the array B. Indeed, a+b>a, and a is the largest number in the array A, so a+b is not included in A. Similarly, a+b is not included in B. Thus, you can select a from A, b from B.

The asymptotics is O(m logm+n logn) if you find the largest element by sorting (which many did), or O(m+n) if you find it linearly.

1206B - Make Product Equal OneThe product of several integers is equal to one if and only if each of these numbers is 1 or −1, and there must be an even number of −1.

Then: we will have to reduce every positive ai at least to one, and we have to spend at least ai−1 coin on this. Similarly, we will have to increase every negative ai at least to −1, for this we will spend at least −1−ai coins.

Now we have all the numbers equal to −1, 0, or 1. Let k be the number of 0 among them. Let's analyze two cases:

k>0.

We need to replace every zero with either 1 or −1, so we will have to spend at least k coins. It turns out that this is enough: change k−1 zeros to 1 or −1 randomly, and change the last zero to 1 or −1 so that the product is equal to one.

k=0.

If the product of all numbers is 1, we no longer need to spend coins. Otherwise, you have to change some 1 to −1 or some −1 to 1. This will take another 2 coins.

Asympotics O(n).

1205A - Almost EqualConsider a valid arrangement for some n. We denote Si=ai+ai+1+ai+2+⋯+ai+n−1 for each i from 1 to 2n, where at+2n=at. Then we have: Si+1−Si=(ai+1+ai+2+ai+3+⋯+ai+n)−(ai+ai+1+ai+2+⋯+ai+n−1)=ai+n−ai. Hence |ai+n−ai|≤1. Since ai+n and ai are different, |ai+n−ai|= 1.

It is also clear from this that ai+n−ai and ai+n+1−ai+1 have opposite signs: if they were both equal to 1, we would get Si+2−Si=(Si+2−Si+1)+(Si+1−Si)=(ai+n+1−ai+1)+(ai+n−ai)= 2, similarly with −1. Thus, the values ​​ai+n−ai for i from 1 to 2n shoul be 1 and −1 alternating, and this is a sufficient condition.

Now, if n is even, we get a contradiction, since ai+n−ai=−(a(i+n)+n−ai+n), but due to the alternating they must be equal.

If n is odd, then it's now easy to build an example: for i from 1 to n ai=2i−1, ai=2i, if i is even, and ai=2i , ai=2i−1 if i is odd.

Asymptotics O(n).

Challenge:

For which pairs of (n,k) (n>k≥1) is there an arrangement of numbers from 1 to n on a circle such that the sums of each k consecutive numbers differ by not more than 1 ?

1205B - Shortest CycleThe most important thing in this task is to notice that if any bit is contained at least 3 numbers, then they will form a cycle of length 3, and the answer is 3.

Suppose now that each bit is in no more than two numbers. It follows that each bit can be shared by at most one pair of numbers. From here we get that in the graph there are no more than 60 edges. Then in it you can find the shortest cycle in O(m2): for each edge between the vertices u and v we will try to remove it and find the shortest distance between the vertices u, v in the resulting graph. If each time u and v turned out to be in different components, then there is no cycle in the graph, otherwise its length is 1 + the minimal of the distances found.

Asymptotics O(n log1018+602).

1205C - Palindromic PathsDenote ask((x1,y1),(x2,y2))=1 if there is a palindromic path between them, and 0 otherwise. We also denote by grid[i][j] the number written in the cell (i,j).

Firstly, make an observation: if the Manhattan distance is |x2−x1|+|y2−y1|= 2, then ask((x1,y1),(x2,y2))=1⟺board[x1][y1]=board[x2][y2]. In fact, the path between the cells (x1,y1) and (x2,y2) has a length of 3, and therefore it is palindromic if and only if board[x1][y1]=board[x2][y2].

Consider a chessboard coloring such that the upper left unit is painted white. Then, using the observation described above, we can restore the numbers in all white cells. In a similar way, if we fix a certain number in a black cell, then all other numbers in black cells will be restored uniquely. Thus, we only have two options for arranging numbers on the board, which differ in the fact that in the second option, the numbers in the black cells are opposite to those in the first option. In the figure below, green pairs of white cells are connected, about which we can ask questions to find out all the values in them, and red - pairs of black cells.

Now there are two approaches. First: for each option, calculate ask((x1,y1),(x2,y2)) for each pair of suitable cells, find where they differ, and ask a question about these two cells. This way we can uniquely identify the board option. It is possible to determine ask((x1,y1),(x2,y2) using dynamic programming: the answer is 1 only when grid[x1][y1]=grid[x2][y2] and there is a path -palindrome between a pair of (x1+1,y1),(x1,y1+1) and (x2−1,y2),(x2,y2−1).

The second approach is a little more interesting, and it also shows why there is such a pair of cells for which the two options give different answers. Consider any path with a length of 4 cells, denote the numbers in its cells as c1,c2,c3,c4. Then two of the cells of the path are black, and two are white. We know the relation between c1,c3, as well as between c2,c4 (by the relation we mean that we know are numbers in them same, or different). Suppose that the relation between c1,c3 is the same as between c2,c4. Then ask(c1,c4) will make it possible to uniquely determine all the numbers! Indeed, if c1=c4, then c2=c3, and therefore the path will be palindromic. Otherwise, no path between c1 and c4 will be palindromic. Thus, we will be able to establish a relation between some white and some black cell, which will be enough to solve the problem.

Suppose that for any path of four cells c1,c2,c3,c4, the relation between c1,c3 is different from the relation between c2,c4. This is equivalent to c1⊕c2⊕c3⊕c4=1. Suppose that for any path of four cells ⊕ of numbers in them is equal to 1. Then we consider any path from the cell (1,1) to the cell (n,n) of length 2n−1. If the xor of each 4 of neighboring cells in it is 1, then the line is periodic with a period of 4, but the numbers in the first and last cell in it are different from the condition! Thus, the algorithm is as follows: choose any path between (1,1) and (4,4), find on it four cells with a xor of numbers equal to 0, and ask a question about it.

Asymptotics O(n2).

1205D - Almost AllFirst we prove the following lemma:

Suppose that there are n vertices in the tree G with the root v. Let also 0<a1<a2⋯<an−1 be any n−1 different positive numbers. Then we can arrange non-negative integers on the edges of G so that the distances from v to the remaining vertices of the tree are a1,a2,…,an−1 in some order.

Proof: for example, by induction. Let s be some child of v in whose subtree, including s, there are m vertices. Then we write on the edge between (v,s) a1, and solve the problem for the subtree s and the numbers a2−a1,a3−a1,…,am−a1. After that, we discard the subtree of s from consideration and fill in the remaining edges for the numbers am+1,…,an−1.

Thus, the lemma is proved.

Now let c be the centroid of tree. Root the tree from c and let s1,s2,…,sk be the sizes of the subtrees of his childs (as we know, si≤n2). Divide the subtrees of the childs into two groups so that size of each group is at least ⌈n−13⌉. It is possible: while there are at least 4 subtrees, there are two for which there are no more than n2 vertices in total, then we unite them. When we have 3 subtrees left, we will unite two smaller ones into one group. It is easy to see that in each of the two groups there will be at least ⌈n−13⌉ vertices.

Let the first group have a vertices and the second b. Then, using the lemma, we put the numbers on the edges in a and between c and a so that the distances from c to the vertices of the first group are 1,2,…,a. Similarly, we make the distance from c to the vertices of the second group equal to (a+1),2(a+1),…,b(a+1). Then each number from 1 to (a+1)(b+1)−1 can be obtained as the distance between some vertex from the first group and some from the second. It is easy to show that (a+1)(b+1)−1 for a+b=n−1 and a,b≥⌈n−13⌉ cannot be less than 2n29. (For example, we can say that this value is minimized at a=n−13 and get (a+1)(b+1)−1≥(n+23)(2n+13)−1=2n2+5n+39−1≥2n29 for n>1 (the case of n=1 is obvious)).

Asymptotics O(n) (but a checker takes O(n2))

1205E - Expected Value AgainLet fi(s) be a function of the string s equal to 1 if the prefix and suffix of length i are equal, and equal to 0 otherwise. We need to calculate E((f1(s)+f2(s)+⋯+fn−1(s))2)= (using linearity of expectation) ∑n−1i=1E(fi(s)2)+∑1≤i,j≤n−1,i≠jE(fi(s)fj(s)).

We will call the number k the period of the string s if s[i]=s[i+k] for all 1≤i≤len(s)+1−k. Moreover, the length of s is not required to be divided by k.

** Statement 1: ** fi(s)=1⟺ n−i is the period of the string is s.

** Proof: ** that fi(s)=1 is equivalent to s[1]s[2]…s[i]=s[n+1−i]s[n+2−i]…s[n], which is equivalent to the fact that s[j]=s[j+n−i] for j from 1 to i.

** Statement 2: ** E(fi(s))=k−i.

** Proof: ** The probability that fi(s)=1 is k−i, since each of the last i characters is uniquely determined from the previous ones.

** Statement 3: ** Let i1=n−i,j1=n−j. Then E(fi(s)fj(s))=kmax(i1+j1−n,gcd(i1,j1))−n.

** Proof: ** Assume that fi(s)=fj(s)=1. We know that the string is i1 and j1-periodic. Consider a graph of n string positions, and draw edges between positions at distances i1,j1. Then the number of different strings satisfying fi(s)=fj(s)=1 is kcomps, where comps is the number of connected components of our graph. Then E(fi(s)fj(s))=kcomps−n. Thus, we need to show that comps=max(i1+j1−n,gcd(i1,j1)).

The case of i1+j1≤n is obvious: in this case, by subtracting and adding i1,j1 we can show that the string has period gcd(i1,j1), in this case comps=gcd(i1,j1). We now consider the case when i1+j1>n.

Without loss of generality, i<j⟹i1>j1. We write out in a circle numbers from 1 to i1. They denote the components of connectivity when we draw only the edges connecting the positions at a distance of i1. Now we need to add edges of the form (k,k+j1) for k=1,2,…,j (here i1+1=1,…). Moreover, we know that j<i1.

We will add these edges one at a time and observe how the connected components change. If we connected two positions that were not connected yet, then we reduced the number of connected components by 1. Otherwise, we connected two already connected vertices and formed a cycle. When does a cycle form at all? If we consider all the edges of the form (k,k+j1), then our graph is divided into gcd(i1,j1) cycles - components, each of which contains all positions giving the same residues when divided by gcd(i1,j1). Thus, it is necessary to calculate how many of these cycles we form. If t cycles are formed, then the number of components will be i1−j+t=i1+j1−n+t.

How many cycles will we create? Let's see if the cycle consisting of positions giving the remainder x when divided by gcd(i1,j1) closes. It closes only if all its vertices are in [1,j]. This is equivalent to the fact that among the positions in [j+1,i1], not a single number gives the remainder of x when dividing by gcd(i1,j1). If i1−j=i1+j1−n≥gcd(i1,j1), then this cannot happen for any x, t=0, and comp=i1+j1−n=max(i1+j1−n,gcd(i1,j1). Otherwise, there will be exactly gcd(i1,j1)−(i1+j1−n), where comp=i1+j1−n+gcd(i1,j1)−(i1+j1−n)=gcd(i1,j1). Thus, the statement is proved.

Further reasoning is standard. We have shown that E(fi(s)fj(s)) depends only on i1+j1 and gcd(i1,j1). It remains for s,gcd to count the number of pairs i1,j1 such that s=i1+j1, gcd=gcd(i1,j1), 1≤i1,j1≤n−1. We will do it as follows: if s2=sgcd, i2=i1gcd, j2=j2gcd, then we rewrite it as s2=i2+j2, gcd(i2,j2)=1, 1≤i2,j2≤⌊n−1gcd⌋. Now we just need to find the number of numbers coprime to s2 on the segment [max(1,s−⌊n−1gcd⌋),min(s−1,⌊n−1gcd⌋)]. This can be done for O(2primes), where primes is the number of prime divisors of s2.

It can be shown that this gives the asymptotics of O(nlogn2) (If you have a better one, please share in the comments!)

1205F - Beauty of a PermutationWe will denote (a,b) if there exists a permutation of length a with beauty equal to b. To begin with, it is obvious that the beauty of a permutation of length a is at least a+1 for a>1: indeed, you can take each element individually and the entire permutation completely.

** Statement 1 **: if (a1,b1) and (a2,b2), then (a1+a2−1,b1+b2−1).

Let p1,p2,…,pa1 be a permutation of length a1, whose beauty is b1, and q1,q2,…,qa2 be a permutation of length a2, whose beauty is equal to b2. Let us build from them a permutation of length a1+a2−1, whose beauty is b1+b2−1. We "expand" p1 in the permutation p to p1+q1−1,p1+q2−1,…,p1+qa2−1, and to the rest of the elements p, greater than p1 , add a2−1. We got a permutation of length a1+a2−1. Denote it by t. If t1 is not between ta2,ta2+1, then we reverse the first a2 elements, and this will be done in a new permutation. Now let t1 be between ta2, ta2+1. Then what good pairs do we have in t? There are b2 good pairs among the first a2 elements, there are b1 good pairs if you count the first a2 elements in one, and we counted the interval from the first a2 elements twice, so we counted b1+b2−1 pairs At the same time, this is all pairs, because if some good segment contains ta2 and ta2+1, then it must contain t1 as well. Thus, this statement is proved.

** Statement 2 **: if (a,b), then either b=a+1, or b=a(a+1)2, or exist (a1,b1), (a2,b2) such that 1<a1,a2, a1+a2−1=a and b1+b2−1=b.

Show it. We will call subsegments consisting of several consecutive numbers in some order good. Consider some kind of permutation of length a of beauty b. Suppose that b≠a+1.

We want to show that in the permutation there is some good [L,R] subsegment of length not equal to 1 or a, with the following property: for any other good [L1,R1] subsegment if [L,R] and [L1,R1] intersect, then one of them contains the second. In this case, by analogy with the proof of Proposition 1, we can "squeeze" the segment [L,R] into one element, obtaining some kind of permutation q. Then the number of good segments in the entire permutation will be equal to the number of good sub-segments on the segment [L,R]+ the number of good segments in q −1 (since we counted the segment [L,R] twice). We will call such a segment very good. Thus, if in each permutation there is a very good segment, then the statement 2 is true.

Suppose that b≠a+1, then in the permutation there is a good segment [L,R] of length not equal to 1 or a. Let's say he's not very good. Then there is another. We denote (a,b) if there exists a permutation of length a with beauty equal to b. To begin with, it is obvious that the beauty of a permutation of length a is at least a+1 for a>1: indeed, you can take each element individually and the entire permutation completely.

** Statement 1 **: if (a1,b1) and (a2,b2), then (a1+a2−1,b1+b2−1).

Let p1,p2, dots,pa1 & mdash; a permutation of length a1, whose beauty is b1, and q1,q2, dots,qa2 & mdash; a permutation of length a2, whose beauty is equal to b2. Let us build from them a permutation of length a1+a2−1, whose beauty is b1+b2−1. We "expand" p1 in the permutation p to p1+q1−1,p1+q2−1, dots,p1+qa2−1, and to the rest of the elements p, greater than p1 , add a2−1. We got a permutation of length a1+a2−1. Denote it by t. If t1 is not between ta2,ta2+1, then we reverse the first a2 elements, and this will be done in a new permutation. Now let t1 be between ta2, ta2+1. Then what good pairs do we have in t? There are b2 good pairs among the first a2 elements, there are b1 good pairs if you count the first a2 elements in one, and we counted the interval from the first a2 elements twice, so we counted b1+b2−1 pairs At the same time, this is all pairs, because if some good segment contains ta2 and ta2+1, then it must contain t1 as well. Thus, this statement is proved.

** Statement 2 **: if (a,b), then either b=a+1, or b=a(a+1)2, or (a1exists,b1), (a2,b2) such that 1<a1,a2, a1+a2−1=a and b1+b2−1=b.

Show it. We will call subsegments consisting of several consecutive numbers in some order good. Consider some kind of permutation of length a of beauty b. Suppose that b≠a+1.

We want to show that in the permutation there is some good [L,R] subsegment of length not equal to 1 or a, with the following property: for any other good [L1,R1] subsegment if [L,R] and [L1,R1] intersect, then one of them contains the second. In this case, by analogy with the proof of Proposition 1, we can "squeeze" the segment [L,R] into one element, obtaining some kind of permutation q. Then the number of good segments in the entire permutation will be equal to the number of good sub-segments on the segment [L,R]+ the number of good segments in q −1 (since we counted the segment [L,R] twice). We will call such a segment very good. Thus, if in each permutation there is a very good segment, then the statement 2 is true.

Let [L,R] be a good segment that is not very good. Then there is a good segment [L1,R1], which intersects with [L,R], but does not contain and is not contained in it. The segments [L,R] and [L1,R1] form together 3 segmentы. It is easy to show that each of them is good, and the numbers in the segments go monotonously. Let us demonstrate this with an example: p=(2,1,3,5,4), the first segment is [2,1,3], the second is [3,5,4]. Then together they will give the union of three segments: [2,1],[3],[5,4]. As we can see, each of these segments is good, and also all numbers in the second segment are larger than all numbers in the first, all numbers in the third segment are larger than all numbers in the second.

Let at the moment we have lined up a chain of good segments (going consecutively) s1,s2,…,sm, where the union of any several consecutive ones is a good segment, as well as all the numbers in si+1 more than all the numbers in si (or vice versa). As long as S=s1+s2+⋯+sm is not equal to the whole segment, we will do this: since S is very good, there is a segment [L,R] that intersects with it but is not contained in it does not contain. It is easy to see that, thanks to the segment [L,R], our chain of good segments is extended.

Now suppose that s1+s2+⋯+sm is the whole segment. While there is a segment of length greater than 1 among the segments, we will do the same: if len(si)>1, then we will find the necessary [L,R] for it, then si will be split into two smaller good segments .

At the end of the process, we get a good segments of length 1 each, and the numbers are sorted monotonously. Hence, the numbers in the permutation were initially sorted monotonously, whence the number of good segments is a(a+1)2. The statement 2 is proved.

Now the left is easy: for each i from 1 to 100, we calculate what beauty values ​​can be in a permutation of length i using statement 2, storing the corresponding values ​​(a1,b1),(a2,b2). After that, it is easy to answer the request by building a permutation of the desired beauty according to the algorithm with the approval of 1.

Asymptotics of O(n6) (With an incredibly small constant, up to n=100 on Codeforces this works for 300 ms).

Challenge: improve the asymptotics to O(n5) (works in less than 30 ms).

Codeforces Round #579 (Div. 3) Editorial

By vovuh, history, 4 years ago, In EnglishAll ideas belong to MikeMirzayanov

1203A - Circle of Students

Tutorial1203A - Circle of StudentsWe just need to find the position of the 1 in the array and then check if the sequence 2,3,…,n is going counterclockwise or clockwise from the position pos−1 or pos+1 correspondingly. We can do this by two cycles.

Total complexity: O(n).

Solution1203B - Equal Rectangles

Tutorial1203B - Equal RectanglesAfter sorting a we can observe that if the answer is "YES" then the area of each rectangle is area=a1⋅a4n. Then we just need to check for each i from 1 to n that a2i−1=a2i and a4n−2i+1=a4n−2i+2 and a2i−1⋅a4n−2i+2=area. If all conditions are satisfied for all i then the answer is "YES". Otherwise the answer is "NO".

Solution1203C - Common Divisors

Tutorial1203C - Common DivisorsLet g=gcd(a1,a2,…,an) is the greatest common divisor of all elements of the array. You can find it by Euclidean algorithm or some standard library functions. Then the answer is just the number of divisors of g. You can find this value in g√.

Solution1203D1 - Remove the Substring (easy version)

Tutorial1203D1 - Remove the Substring (easy version)In this problem we can just iterate over all possible substrings and try to remove each of them. After removing the substring we can check if t remains the subsequence of s in linear time.

Let we remove the substring s[l;r]. Let's maintain a pointer pos (the initial value of the pointer is 1) and iterate over all possible i from 1 to |s|. If pos≤|t| and si=tpos let's increase pos by one. If after all iterations pos=|t|+1 then let's update the answer with the length of the current substring.

Solution1203D2 - Remove the Substring (hard version)

Tutorial1203D2 - Remove the Substring (hard version)Let rgi be such rightmost position x in s that the substring t[i;|t|] is the subsequence of s[x;|s|]. We need values rgi for all i from 1 to |t|. We can calculate it just iterating from right to left over all characters of s and maintaining the pointer to the string t as in easy version.

Then let's iterate over all positions i from 1 to |s| and maintain the pointer pos as in the easy version which tells us the maximum length of the prefix of t we can obtain using only the substring s[1;i) (exclusively!). Suppose we want to remove the substring of s starting from i. Then if pos≤|t| then let rpos be rgpos−1, otherwise let rpos be |s|. rpos tells us the farthest rightmost character of the substring we can remove. So we can update the answer with the value rpos−i+1 and go to the next position (and don't forget to increase pos if needed).

Solution1203E - Boxers

Tutorial1203E - BoxersLet lst be the last weight of the boxer taken into the team. Initially lst=∞. Let's sort all boxers in order of non-increasing their weights and iterate over all boxers in order from left to right. If the current boxer has the weight w then let's try to take him with weight w+1 (we can do it if w+1<lst). If we cannot do it, let's try to take him with weight w. And in case of fault let's try to take him with weight w−1. If we cannot take him even with weight w−1 then let's skip him. And if we take him let's replace lst with him weight. The answer is the number of boxers we took.

Solution1203F1 - Complete the Projects (easy version)

Tutorial1203F1 - Complete the Projects (easy version)Firstly, let's divide all projects into two sets: all projects giving us non-negative rating changes (let this set be pos) and all projects giving up negative rating changes (let this set be neg). Firstly let's take all projects from the set pos. How do we do that? Let's sort them by ai in non-decreasing order because each project we take cannot make our rating less and we need to consider them in order of their requirements. If we can take the current project i (r≥ai), set r:=r+bi and go further, otherwise print "NO" and terminate the program.

Okay, what do we do with the projects that has negative bi? Firstly, let's set ai:=max(ai,−bi). This means the tighter requirement of this project, obviously. Then let's sort all projects in order of ai+bi in non-increasing order and go from left to right and take all of them. If we cannot take at least one project, the answer is "NO". Otherwise the answer is "YES".

Solution1203F2 - Complete the Projects (hard version)

Tutorial1203F2 - Complete the Projects (hard version)To view the main idea of the problem, read the editorial of easy version. The only difference is that for non-negative bi we don't need to print "NO" if we cannot take the project, we just need to skip it because we cannot take it at all. And for negative bi we need to write the knapsack dynamic programming to take the maximum possible number of projects (we need to consider them in order of their sorting). Dynamic programming is pretty easy: dpi,j means that we consider i projects and our current rating is j and the value of dp is the maximum number of negative projects we can take. If the current project is the i-th negative project in order of sorting, we can do two transitions: dpi+1,j=max(dpi+1,j,dpi,j) and if r+bi≥0 then we can make the transition dpi+1,j+bi=max(dpi+1,j+bi,dpi,j+1). And then we just need to find the maximum value among all values of dp and add the number of positive projects we take to find the answer.

Solution

Codeforces Round #578 (Div. 2) Editorial

By djm03178, history, 4 years ago, In EnglishThe problems with Gildong (B, D, F) are by me, and Amugae (A, C, E) are by nong.

1200A - HotelierMake an array of size 10 filled with 0. Then for each character from the input: L : Find the first position containing 0, then change it to 1. R : Find the last position containing 0, then change it to 1. 0   9 : array[x] = 0.

Time complexity: O(n)1200B - Block AdventureWe can easily see that it's always optimal to have as many blocks as possible in the bag before getting to the next column. Therefore, if the character is currently on the top of the i-th column, Gildong just needs to make hi become max(0,hi+1−k) by repeating the 1-st or the 2-nd action. In other words, we should add hi−max(0,hi+1−k) blocks to the bag. Adding or subtracting one by one will lead to TLE. If there exists a situation where the bag will have negative number of blocks, the answer is NO. Otherwise the answer is YES.

Time complexity: O(n) for each test case.

1200C - Round CorridorDenote the corridor's length as 1. Then, there is a wall at (1,1n),(1,2n),⋯,(1,nn),(2,1m),(2,2m),⋯(2,mm). For some value x, If there are walls at (1,x) and (2,x) at the same time, we can't move from y to z for y<x and z>x. Let's call them a "dual wall."

Suppose g=gcd(n,m). Then dual walls exist at 1g,2g,⋯,gg. So we can make g groups. We can move freely in the same group, and we can't move from one group to another group.For x=1, (1,1),(1,2),⋯,(1,ng) belong to group 1, and (1,ng+1),(1,ng+2),⋯,(1,2ng) belong to group 2, and so on. For x=2, (2,1),(2,2),⋯,(2,mg) belong to group 1, and (2,mg+1),(2,mg+2),⋯,(2,2mg) belong to group 2, and so on.

For each query, print YES if (sx,sy) and (ex,ey) belong to the same group. Otherwise, print NO.

time complexity: O(log(max(n,m))+q)1200D - White LinesLet's consider a single row that contains at least one black cell. If the first appearance of a black cell is at the l-th column and the last appearance of a black cell is at the r-th column, we can determine whether it becomes a white line when a certain cell (i,j) is clicked in O(1), after some preprocessing. It becomes a white line if and only if a cell (i,j) is clicked where the row is at [i,i+k−1] and j≤l≤r≤j+k−1. We just need to compute l and r in advance.

Now let's consider all n rows (not columns). First, count all rows that are already white lines before clicking. Then we count the number of white rows when the cell (1,1) is clicked, by applying the above method to all rows from 1 to k. Ignore the already-white rows that we counted before. So far we obtained the number of white rows when the cell (1,1) is clicked. From now, we slide the window. Add the k+1-st row and remove the 1-st row by applying the same method to them, and we obtain the number of white rows when the cell (2,1) is clicked. We can repeat this until we calculate all n−k+1 cases for clicking the cells at the 1-st column. Then we repeat the whole process for all n−k+1 columns.

The same process can be done for counting white columns, too. Now we know the number of white rows and white columns when each cell is clicked, so we can find the maximum value among their sums.

Time complexity: O(n2)1200E - Compress WordsDenote the words from left to right as W1,W2,W3,⋯,Wn.

If we define string F(k) as the result of merging as described in the problem k times, we can get F(k+1) by the following process:

If length of F(k) > length of Wk+1Assume the length of F(K) is x, and the length of Wk+1 is y. Construct the string c=Wk+1+F(k)[x−y...x] ( * s[x..y] for string s is the substring from index x to y)Get the KMP failure function from string c.We can get maximum overlapped length of Wk+1's prefix and F(k)'s suffix from this function. Suppose the last element of the failure function smaller than the length of Wk+1 is z. Then the longest overlapped length of F(k)'s suffix and Wk+1's prefix is min(z,y). Let L=min(z,y).Then, F(k+1)=F(k)+Wk+1[L+1...y]OtherwiseConstruct c as Wk+1[1...x]+F(k). We can get F(k+1) from the same process described in 1.In this process, we can get F(k+1) from F(k) in time complexity O(len(Wk+1)). So, we can get F(N) (the answer of this problem) in O(len(W1)+len(W2)+⋯+len(WN)).

1200F - Graph TravelerSince a travel will never end, it is clear that every travel will eventually get into an infinite loop. But we should consider more than just the vertices, since c could be different every time he visits the same vertex. Since the number of outgoing edges of each vertex is at most 10, we can see a state can be reduced to lcm(1..10)=2520 for each vertex. Therefore, we can think that the graph actually has 2520⋅n vertices, each with a single outgoing edge.

To simulate the travels, we just need to follow the exact process written in the description, except that c should be kept in modulo 2520. The problem is when to stop, and how to count the number of distinct vertices that are in the loop.

We can stop simulating until we find a state that we already have visited. There can be two cases when we find a visited state.

The first case is when we have not visited this state in the previous travels, i.e. this is the first travel that visits this state. We need to check all of the states after the first visit of this state and count the number of distinct vertices. Duplicated vertices can be removed simply by using a set, or more efficiently, using timestamp. Then we can apply the answer to all of the states we visited in this travel.

The second case is when the state was visited in one of the previous travels. We know that both the previous travel and the current travel will end in the same loop, so we can apply the same answer to all of the states we visited in this travel.

On a side note, the simulation can be done with recursion, but this can lead to maximum of 2520000 recursion depth. This causes stack overflow or recursion limit excess for some languages (including Java).

Time complexity: O(2520n+q)

Codeforces Round #577 (Div 2) Editorial

By SPatrik, history, 4 years ago, In English1201A - Important ExamFor each of the question let's count the number of answers of different type. Let cnt[i][A]=The number of A answers to the i-th question. The maximum score for that answer is a[i]⋅max(cnt[i][A],cnt[i][B],cnt[i][C],cnt[i][D],cnt[i][E]). The answer is the sum of the maximum answer for the m questions.

C++ code: 58307249

1201B - Zero ArrayThere are 2 things needed to be possible to make all elements zero:

1: The sum of the elements must be even.

2: The biggest element have to be less or equal than the sum of all the other elements.

If both are true, the answer is "YES", otherwise "NO".

C++ code: 58307265

1201C - Maximum MedianSort the array in non-decreasing order. In the new array b1,b2,…,bn you can make binary search with the maximum median value. For a given median value (x), it is required to make ∑ni=(n+1)/2max(0,x−bi) operations. If this value is more than k, x can't be median, otherwise it can. Time complexity: O((n/2)⋅log(109))C++ code: 58307281

1201D - Treasure HuntingMake two arrays: left and right. left[i] is the treasure in the leftmost position in row i (0 if there are no treasures in row i). right[i] is the treasure in the rightmost cell in row i (0 if there are no treasures in row i).

We can simply take out rows where there is no treasure (and add 1 to the result if there are treasure above that line, because we have to move up there).

For every row, except the last, we have to leave that row at one of the safe columns. Let's notice that the last treasure we collect in the row will be either left[i] or right[i]. Let's take a look at both possibilities: If we collect the left[i] treasure last, we have to leave the row either going left or going right to the closest safe column, because going further wouldn't worth it (consider moving up earlier and keep doing the same thing at row i+1). The same is true for right[i]. For the first row, we start at the first column, we can calculate the moves required to go up the second row at the for cells. For all the other rows, we have 4 possibilities, and we have to calculate how many moves it takes to reach the row i+1 at the 4 possible columns. For the last row, we don't have to reach a safe column, we just have to collect all the treasures there. We can count the answer for the problem from the calculated results from the previous row. Time complexity: O(16∗n)C++ code: 58307302

1201E2 - Knightmare (hard)First calculate the number of moves needed to reach (without capturing) positions (a1;b1) and (a2;b2).

If one of the knights can reach it's goal at least 2 moves faster than the other can and faster than the other can reach it's goal, than there is a winning strategy with it. Just go the shortest path. The other knight won't be able to capture your knight, because after you move you are x moves away from it, than the other knight must be at least x+2 far, so it will be at least x+1 after it's move.

If one of the knights can reach it's goal at exactly 1 move faster than the other can and faster than the other can reach it's goal, we have to count the moves needed to reach all the positions which is 1 move away from the goal. If there is a position from these which can be reached at least 2 moves faster, than that knight can win.

Let's color the chessboard the regular way with white and black colors. If the 2 knights are in same color, than only the black knight can capture the white, otherwise only the white can capture the black (that is because knights always move to different color than they come from).

In all the other situation there is at least drawing strategy with the knight that can capture the other:

Move to the position that the other knight have to reach and stay there or 1 move away from it. The other knight won't be able to reach that position without getting captured. So we choose that knight and search for the winning strategy. You can win the game in 2 steps:

First: Go to your opponent's target cell in the fastest way (if the opponent could go there faster, you can still outrun him, because there is no position which is 1 move away from the opponents goal and can be reached at least 2 moves faster (we already looked that situation), so you can take away the opponent's possibility to reach the target by threatening with capturing their knight). This is maximum of 333 moves.

Second: Go from there to your target cell on the fastest way. It can be easily shown that it takes 3 moves to go there. When you are in the opponent's target position your opponent can be either exactly 1 move or at least 3 moves away from you (because the distance (in moves) between you and your opponent's knight after your opponent's turn is always odd). If it is 1 move away, you can capture his knight, if at least 3 or moves away from you (and therefore the target position), you can reach your target faster than your opponent.

That's a total of 336 moves.

C++ code: 58307320

O(n4) complexity solution for problem E1 by KAN: 58306483

Round #576 Editorial

By Um_nik, history, 4 years ago, In English1199A - City Dayx and y are small, so we can explicitly check every day. Complexity O(n(x+y)).

1199B - Water LilyWe can use Pythagorean theorem and get the equation x2+L2=(H+x)2. Its solution is x=L2−H22H.

1198A - MP3First let's calculate how many different values we can have. Maximal k is 8In, maximal K is 2k. We have to be careful not to overflow, let's use K=2min(20,k) (220 is bigger than any n).

Let's sort the array and compress equal values. Now we have to choose no more than K consecutive values in such a way that they cover as much elements as possible. If K is bigger than number of different values, then answer is 0. Otherwise we can precalculate prefix sums and try all the variants to choose K consecutive values.

Complexity is O(nlogn).

1198B - Welfare StateFor every citizen only the last query of type 1 matters. Moreover, all queries before don't matter at all. So the answer for each citizen is maximum of x for last query of type 1 for this citizen and maximum of all x for queries of type 2 after that. We can calculate maximum x for all suffices of queries of type 2, and remember the last query of type 1 for each citizen. It can be implemented in O(n+q) time.

1198C - Matching vs Independent SetLet's try to take edges to matching greedily in some order. If we can add an edge to the matching (both endpoints are not covered), then we take it. It is easy to see that all vertices not covered by the matching form an independent set — otherwise we would add an edge to the matching. Either matching or independent set has size at least n. Complexity — O(n+m).

1198D - Rectangle Painting 1Let's solve the problem for rectangle W×H (W≥H). Of course, we can cover all rectangle with itself for cost W. To get something smaller than W we have to leave at least one column uncovered — otherwise we pay at least sum of w over all rectangles which is at least W. This gives us an idea to use DP on rectangles to solve the problem: dp[x1][x2][y1][y2] is minimal cost to cover the rectangle [x1;x2)×[y1;y2). It is initialized by max(x2−x1,y2−y1), and we have to try not to cover every column/row. Of course, we have to check if it is all white from the beginning; to do that we will precalculate 2D prefix sums. Total complexity is O(n5).

1198E - Rectangle Painting 2If we use some rectangle [x1;x2)×[y1;y2) (x2−x1≤y2−y1), then we can change it to [x1;x2)×[0,n) without changing the cost. Also we can choose w rectangles of width 1 instead of one rectangle of width w, it will not change the cost.

So, we have to choose minimal number of columns and rows such that all black cells are covered by at least one chosen column/row. If we will build a bipartite graph — left part is columns, right part is rows, there is an edge iff the cell in the intersection of given row and column is black — then the answer is minimal vertex cover in this graph. Minimal vertex cover is the same size as maximum matching, which can be found using flow. All that is left is to see that we can compress identical vertices, and we will have O(m) vertices in both parts.

With Dinic algorithm complexity is O(m4).

1198F - GCD Groups 2All numbers have no more than k=9 different prime divisors.

If there exist a solution, then for every number there exist a solution in which this number is in group of size not more than (k+1), because all we have to do is to "kill" all prime numbers from this number, and to do it we only need one number for each prime.

If n≤2(k+1), we can try all the splits in time O(2n(n+logC)).

Let's take two numbers which will be in different groups. How to do it? — let's take random pair. For fixed first number probability of mistake is no more than kn−1. Now in each group we have to kill no more than k primes. Let's do subset DP — our state is what primes are still alive. This solution has complexity O(n22k).

But we actually don't need all n numbers. For each prime we can look at no more than 2k candidates which can kill it, because to kill all other primes we need strictly less numbers, and we will have a spare one anyways. Thus the solution has complexity O(22kk2+nk). We don't need factorization for any numbers except two chosen, and we can factorize them in O(C−−√).

Codeforces Round #575 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1196A - Three Piles of Candies

Idea: MikeMirzayanov

Tutorial1196A - Three Piles of CandiesThe answer is always ⌊a+b+c2⌋. Let's understand why it is so. Let a≤b≤c. Then let Bob take the pile with a candies and Alice take the pile with b candies. Then because of b≤a+c we can see that Bob's pile always can reach size of Alice's pile (and remaining candies can be divided between them fairly except one candy if a+b+c is odd).

Solution1196B - Odd Sum Segments

Idea: vovuh

Tutorial1196B - Odd Sum SegmentsFirstly, let cnt be the number of odd elements in the array. Note that even elements are don't matter at all because they cannot change the parity of the sum.

If cnt<k then it is obviously impossible to split the given array into k subsegments with odd sum. And if cnt%2≠k%2 then it is impossible to split the array into k subsegments with odd sum also because at least one of k segments will have even number of odd elements (so will have odd sum).

In other cases the answer is always "YES" and you can print k−1 leftmost positions of odd elements and n as right borders of segments (it means that when you find one odd element, you end one segment). Because cnt%2=k%2 now, the last segment will have odd number of odd elements so it will have odd sum also.

Solution1196C - Robot Breakout

Idea: MikeMirzayanov and vovuh

Tutorial1196C - Robot BreakoutIn fact, we have some restrictions on OX axis and OY axis (for example, if some robot stays at the position x and cannot move to the left, then the answer point should have X≥x).

So we can take the minimum among all y-coordinates of robots that cannot go up and save it into maxy, maximum among all y-coordinates of robots that cannot go down and save it into miny, minimum among all x-coordinates of robots that cannot go right and save it into maxx and maximum among all x-coordinates of robots that cannot go right and save it into minx. Initially minx=miny=−∞,maxx=maxy=+∞.

So these restrictions are describe some rectangle (possibly incorrect, with minx>maxx or miny>maxy). Let (minx,miny) be the bottom-left point of this rectangle and (maxx,maxy) be the top-right point of this rectangle.

In case if this rectangle have minx>maxx or miny>maxy, the answer is "NO". Otherwise this rectangle describes all integer points which can be reachable all robots and you can print any of them.

Solution1196D1 - RGB Substring (easy version)

Idea: MikeMirzayanov

Tutorial1196D1 - RGB Substring (easy version)You can just implement what is written in the problem statement and solve this problem this way.

Let's iterate over all starting positions of the substring i from 0 to n−k+1 and over all possible offsets of the string t = "RGB" offset from 0 to 2 inclusive. Then let's iterate over all position of the current substring pos from 0 to k−1 and carry the variable cur which denotes the answer for the current starting position and the current offset. And if si+pos≠t(offset+pos)%3 then let's increase cur by 1. After iterating over all positions pos let's update the answer with the value of cur.

Solution1196D2 - RGB Substring (hard version)

Idea: MikeMirzayanov

Tutorial1196D2 - RGB Substring (hard version)In this problem you should make the same as in the previous one but faster. Let's consider three offsets of string "RGB": "RGB", "GBR" and "BRG". Let's copy the current offset of the string so that it will has the length n (possibly, without some trailing characters) and save it in the string t.

Then let's compare the string s with this offset of length n and build an array diff of length n where diffi=1 if si≠ti. Then let's iterate over all possible continuous subsegments of this array diff and maintain the variable cur denoting the current answer.

Firstly, for the current position i let's add diffi to cur. Then if the current position i is greater than or equal to k−1 (0-indexed) let's decrease cur by diffi−k. So now we have the continuous subsegment of the array diff of length no more than k. Then if the current position i is greater than or equal to k (0-indexed again) (the current subsegment has the length k) then let's update the answer with cur. Then let's do the same with two remaining offsets.

Solution1196E - Connected Component on a Chessboard

Idea: MikeMirzayanov

Tutorial1196E - Connected Component on a ChessboardI'll consider the case when b≥w, the other case is symmetric and the answer I construct is the same but shifted by 1 to the right.

Consider the given field as a matrix where x is the number of row and y is the number of column. Firstly, let's build the line of length 2w−1 from the cell (2,2) to the cell (2,2w). Then b will decrease by w−1 and w will (formally) become 0.

Then we have two black cells to the left and to the right ((2,1) and (2,2w+1)) and w−1 black cells to the up (all cells (1,2w+2∗i) for all i from 0 to w−1) and w−1 black cells to the down (all cells (3,2w+2∗i) for all i from 0 to w−1). Let's add the required number of cells to the answer.

If even after adding all these cells b still be greater than 0 then the answer is "NO" (maybe there will be a proof why it is so but you can read it already from other participants). Otherwise the answer is "YES" and we constructed the required component.

Solution1196F - K-th Path

Tutorial1196F - K-th PathThe main observation is that you don't need more than min(k,m) smallest by weight edges (among all edges with the maximum weights you can choose any). Maybe there will be a proof later, but now I ask other participant to write it.

So you sort the initial edges and after that you can construct a graph consisting of no more than 2min(k,m) vertices and no more than min(m,k) edges. You just can build the new graph consisting only on these vertices and edges and run Floyd-Warshall algorithm to find the matrix of shortest paths. Then sort all shorted distances and print the k-th element of this sorted array.

Time complexity: O(mlogm+k3).

I know that there are other approaches that can solve this problem with greater k, but to make this problem easily this solution is enough.

Solution

Codeforces Round #574 (Div. 2) Editorial

By vovuh, history, 4 years ago, In English1195A - Drinks Choosing

Idea: budalnik

Preparation: budalnik

Tutorial1195A - Drinks ChoosingLet's take a look on a students. If two students have the same favorite drink, let's take one set with this drink. Let the number of such students (which we can satisfy as pairs) be good. Because the number of sets is ⌈n2⌉ we always can do it. So there are students which are the only with their favorite drinks remain. It is obvious that if we take one set we can satisfy at most one student (and one of the others will gain not his favorite drink). Let the number of such students (which remain after satisfying pairs of students) be bad. Then the answer is good+⌈bad2⌉.

Solution1195B - Sport Mafia

Idea: ?

Preparation: MikeMirzayanov and cdkrot

Tutorial1195B - Sport MafiaIn fact, we need to solve the following equation: x(x+1)2−(n−x)=k and when we will find x we need to print n−x as the answer. x(x+1)2 is the number of candies Alya will put into the box with x turns (sum of arithmetic progression). This equation can be solved mathematically. The only problem is getting the square root, it can be avoided with binary search or taking square root in non-integer numbers and checking some amount of integers in small range nearby the obtained root. The other solution is the binary search by x.

Solution (binary search)Solution (formula)1195C - Basketball Exercise

Idea: meshanya

Preparation: tsarn

Tutorial1195C - Basketball ExerciseThis is pretty standard dynamic programming problem. Let dpi,1 be the maximum total height of team members if the last student taken has the position (i−1,1), dpi,2 is the same but the last student taken has the position (i−1,2) and dpi,3 the same but we didn't take any student from position i−1. Transitions are pretty easy:

dpi,1=max(dpi−1,2+hi,1,dpi−1,3+hi,1,hi,1);dpi,2=max(dpi−1,1+hi,2,dpi−1,3+hi,2,hi,2);dpi,3=max(dpi−1,1,dpi−1,2).This dynamic programming can be calculated almost without using memory because we need only the i−1-th row to calculate the i-th row of this dp. Moreover, we don't actually need dpi,3 if we will add transitions dpi,1=max(dpi,1,dpi−1,1) and dpi,2=max(dpi,2,dpi−1,2). These transition will change our dp a bit. Now dpi,j is the maximum total height of the team members if the last student taken has the position (i−1,1) or less. The same with dpi,2. The answer is max(dpn,1,dpn,2).

Time complexity: O(n).

Solution1195D1 - Submarine in the Rybinsk Sea (easy edition)

Idea: MikeMirzayanov

Preparation: MikeMirzayanov

Tutorial1195D1 - Submarine in the Rybinsk Sea (easy edition)Let's take a look into some number a=a1,a2,…,alen, where len is the length of each number in the array. We know that in n cases it will be the first argument of the function f(a,b) (where b is some other number), and in n cases it will be the second argument. What it means? It means that a1 will have multiplier 102len−1⋅102len−2⋅n, a2 will have multiplier 102len−3⋅102len−4⋅n, and so on. If we take a look closer, a will add to the answer exactly f(a,a)⋅n. So the final answer is n∑i=1nf(ai,ai). Don't forget about modulo and overflow (even 64-bit datatype can overflow in this problem, because f(109,109) has 20 digits in decimal notation).

Solution1195D2 - Submarine in the Rybinsk Sea (hard edition)

Idea: meshanya

Preparation: sava-cska

Tutorial1195D2 - Submarine in the Rybinsk Sea (hard edition)Let cntlen be the number of ai with length len. We will calculate each number's contribution in the answer separately.

When we calculate the contribution of the current number in the answer, let's iterate over all lengths l from 1 to L where L is the maximum length of some number in the array and add the following value to the answer: cntl⋅(flai,l+frai,l).

The function flx,l means that we merge the number x with some (it does not matter) number of length l and digits of x will be on odd positions in the resulting number (except some leading digits which will be on odd and on even position as well). And the function frx,l does almost the same thing but it counts digits of x on even positions.

Time complexity is O(n) with the constant factor L2.

Solution1195E - OpenStreetMap

Idea: budalnik

Preparation: ima_ima_go

Tutorial1195E - OpenStreetMapThere is almost nothing to say about this problem. It is pretty standard data structure problem.

Let mni,j be the minimum value over all values hi,j,hi−1,j,…,hi−a+1j. If i is less than a then its value does not matter for us because the corresponding submatrix is not counted in the answer. These values can be calculated using std::deque or minimum queue. You can read more about it here: https://cp-algorithms.com/data_structures/stack_queue_modification.html.

After building such matrix mn we can actually calculate the answer. Let's iterate over all rows of the matrix (starting from row a) i and carry the floating window of width b of values mni,j. And when the size of the queue with minimums reaches b we know the minimum on the corresponding submatrix that ends in the current element and we can add it to the answer.

Time complexity: O(nm).

Solution1195F - Geometers Anonymous Club

Idea: craborac

Preparation: budalnik

Tutorial1195F - Geometers Anonymous ClubSuppose we want to compute the Minkowski sum of two polygons a and b. Let's denote two sequences of free vectors:

u1, u2, ..., uka such that free vector ui is congruent to the bound vector starting in i-th vertex of the first polygon and ending in the (i+1)-th vertex of this polygon (if i=ka, then we use the 1st point as the (i+1)-th one);v1, v2, ..., vkb such that free vector vi is congruent to the bound vector starting in i-th vertex of the second polygon and ending in the (i+1)-th vertex of this polygon (if i=kb, then we again use the 1st point as the (i+1)-th one).It's impossible to choose a pair of vectors from the same sequence in such a way that they are parallel, since there are no three points lying on the same line in the same polygon (but it may be possible to find a pair of antiparallel vectors belonging to the same sequence).

Let's try to analyze how we can construct such sequence for the resulting polygon. For example, let's pick some side of the first polygon (let vector ui denote this side of the polygon) and analyze how this side can affect the resulting polygon. There are two cases:

there is a vector vj such that it is parallel (not antiparallel) to ui. Then this vector represents a side of the second polygon. If we construct the Minkowski sum of these two sides (the side represented by ui in the first polygon and the side represented by vj in the second polygon), then we will get a segment having length equal to |ui|+|vj|. The line coming through this segment divides the plane into two halfplanes, and all points belonging to the Minkowski sum of these polygons will be contained in the same halfplane. That's because all points of the first polygon belong to the same halfplane (if we divide the plane by the line coming through the side represented by ui), and all points of the second polygon belong to the same halfplane (if we divide the plane by the line coming through the side represented by vj) — moreover, both these halfplanes are either upper halfplanes (and then the whole resulting polygon belongs to the upper halfplane) or lower halfplanes (then result belongs to the lower halfplane). So, the resulting polygon will have a side represented by the free vector equal to ui+vj (obviously, there can be only one such side);there is no such vector in the second sequence such that it is parallel to ui. Then there exists exactly one vertex of the second polygon such that if we draw a line parallel to ui through this vertex, the whole second polygon will be contained in the upper halfplane or the lower halfplane (depending on whether the first polygon belongs to the upper halfplane or the lower halfplane in respect to the side parallel to ui). Actually, this case can be analyzed as the case where vj exists, but has zero length: the resulting polygon will have a side represented by the vector ui.So, for every vector in the sequences constructed by the given polygons, there will be a vector parallel to it in the resulting sequence of vectors. It is quite obvious that every vector in the resulting sequence is also parallel to some vector from the first two sequences. It means that the number of sides in the Minkowski sum is equal to the number of vectors in these two sequences, but all parallel vectors count as one.

This fact can be extended to computing the Minkowski sum of multiple polygons: the resulting polygon will have the number of sides equal to the number of vectors in all sequences for given polygons, if we count all parallel vectors as one. Now we can solve the problem in such a way: construct the sequences of vectors for the given polygons and divide these vectors into equivalence classes in such a way that vectors belong to the same class if and only if they are parallel. The answer to each query is equal to the number of equivalence classes such that at least one vector belonging to this class is contained in at least one sequence on the segment of polygons; this can be modeled as the query "count the number of distinct values on the given segment of the given array". This problem can be solved with Mo's algorithm, mergesort tree or persistent segment tree.

Solution

Codeforces Round #573 Editorial

By tokitsukaze, 4 years ago, In English1191A - Tokitsukaze and Enhancement

Idea: tokitsukaze

TutorialJust enumerating the increment can pass.

However, by increasing at most 2 points, the value of her HP can always become an odd number, and thus the highest possible level is either A or B. We can just solve case by case.

Solution (by Claris)Solution (by tokitsukaze)1191B - Tokitsukaze and Mahjong

Idea: tokitsukaze, 2014CAIS01

TutorialThere are only two types of mentsus, so you can enumerate the mentsu you want her to form, and check the difference between that and those currently in her hand.

Alternatively, you can find out that the answer is at most 2, since she can draw two extra identical tiles which are the same as one of those in her hand. You may enumerate at most 1 extra tile for her and check if it can contribute to a mentsu. If she can't, the answer will be 2.

Solution (by skywalkert)Solution (by isaf27)1190A - Tokitsukaze and Discard Items / 1191C - Tokitsukaze and Discard Items

Idea: tokitsukaze

TutorialThe order of discarding is given, so we can simulate the process of discarding.

In each time, we can calculate the page that contains the first special item that has not been discarded, and then locate all the special items that need to be discarded at one time. Repeat this process until all special items are discarded.

Each time at least one item would be discarded, so the time complexity is O(m).

Solution (by tokitsukaze)1190B - Tokitsukaze, CSL and Stone Game / 1191D - Tokitsukaze, CSL and Stone Game

Idea: tokitsukaze

TutorialUnless the first player must lose after the first move, the numbers of stones in these piles should form a permutation obtained from 0 to (n−1) in the end, in order to ensure that there are no two piles include the same number of stones.

Let's use cnt[x] to represent the number of piles which have exactly x stones in the beginning. There are four cases that Tokitsukaze will lose after the first move:

cnt[0]>1;cnt[x]>2 for some x;cnt[x]>1 and cnt[y]>1 for some x, y (x≠y);cnt[x]>1 and cnt[x−1]>0 for some x.If Tokitsukaze won't lose after the first move, then we only need to check the parity of the total number of stones that can be taken.

By the way, if you don't want to discuss the above four cases, you can just enumerate her first move.

Solution (by tokitsukaze)Solution (by skywalkert)1190C - Tokitsukaze and Duel / 1191E - Tokitsukaze and Duel

Idea: teitoku, winterzz1

TutorialIf a player can make a move from a situation to that situation again, this player will not lose. Except for some initial situations, one can move from almost every situation to itself. Based on these two conclusions, we can get a solution.

If Tokitsukaze cannot win after her first move, she cannot win in the future. In this case, we can quickly check if k is so limited that she cannot win.

After her first move, it is possible that Quailty wins in the next move. If he cannot, in order to prevent failure, he can just leave the situation to his opponent by doing useless flipping and thus result in a draw.

Therefore, we can check if no matter how Tokitsukaze moves, Quailty has no chance to win after his first move. It can be easily checked linearly if we do some precalculation and enumerate Tokitsukaze's first move. Alternatively, we can find and check the pattern of initial situations in which Quailty can win.

Solution (by quailty)Solution (by skywalkert)Solution (by winterzz1)1190D - Tokitsukaze and Strange Rectangle / 1191F - Tokitsukaze and Strange Rectangle

Idea: tokitsukaze

TutorialFor each strange rectangular area and its corresponding set of points, we only need to focus on the lowest y-coordinate yB, the leftmost x-coordinate xL and the rightmost x-coordinate xR of points in this set. Different sets must have different yB, xL, xR, so we can count them by enumerating these values.

Let's enumerate yB first. Then, we need to list all the possible x-coordinates of points (xi,yi) satisfying that yi≥yB and mark every possible x′ satisfying there is a point (x′,yB). By doing so, we can make sure when enumerating xL and xR, the requirement for yB is met as well. However, enumerating forcibly, which is in time complexity O(n3), is too slow to pass, so let's optimize the enumeration step by step.

Let's pick and sort the points (x′1,yB),(x′2,yB),…,(x′m,yB) from left to right. Assuming that x′0=0, and (x′j,yB) is the leftmost point of them that is in the chosen set, we can count the number of aforementioned different x-coordinates in ranges [x′j−1+1,x′j] and [x′j,∞) and then count the number of possible pairs (xL,xR) immediately. More specifically, let cnt(l,r) be the number of different x-coordinates of points in the area {(x,y)|l≤x≤r,y≥yB}, and we know the number of possible pairs (xL,xR) is cnt(x′j−1+1,x′j)⋅cnt(x′j,∞). After precalculating c(1,x) for each yB, we can reduce the time complexity into O(n2).

The very last step is using the trick of sweeping lines. We can enumerate yB from highest to lowest, and during that process, use data structures to maintain possible x-coordinates. What we need to implement is to maintain a container, check if a coordinate is already in the container, add a coordinate to the container, and query the number of coordinates in a range. These requirements can be easily achieved by Fenwick tree, segment tree or others. With the last optimization, we can solve in time complexity O(nlogn).

By the way, there also exist solutions using other approaches, such as divide and conquer.

Solution (by tokitsukaze)Solution (by winterzz1)1190E - Tokitsukaze and Explosion

Idea: chenjb, Subconscious

TutorialIt is obvious that we can binary search the answer because we can pull any line closer to O and the situation won't change. Applying a binary search, we focus on if it is possible to set m barriers with the same distance to O and meet the requirement. By doing so, we can draw a circle whose center is O such that the closest point to O on each barrier is on the circumference. Then it becomes a classic problem — for each barrier we can get the angle range of its closest point on the circle, and we have to choose at most m points on the circle to ensure that there is at least one point within each range.

This kind of greedy trick is very simple on a sequence. As to ranges on a sequence, you only have to sort all ranges in increasing order of left endpoint and take every necessary right endpoint. As to ranges on a circle, you can enumerate a position to break the circle into a sequence. But if you enumerate as the same way on the sequence, the time complexity will be O(n2) which is not enough.

Instead, we can double and extend these ranges into 2n ranges and then regard them as on a sequence. We can do some precalculation, such as if we want to choose a point to cover the i-th sorted range and other ranges in its right as many as possible, what is the next range that we cannot cover. Let's denote that as f[i][0], and then we can calculate the next range after 2p repeated steps from the i-th range as f[i][p], which can be obtained from f[f[i][p−1]][p−1]. After preparation, we can enumerate the beginning position and use binary lifting method, each time in complexity O(logm), to know that whether we can use m steps to cover all the ranges.

Therefore, the total time complexity can be O(nlogmlogD), where D is the precision requirement.

Solution (by chenjb)Solution (by quailty)1190F - Tokitsukaze and Powers

Idea: skywalkert

TutorialFirstly, let me briefly review this problem for you. Given integers n, m and p (n>0, m>1, p≠0), we denote S={x|x∈Z,0≤x<m,gcd(m,x)=1} and T={pemodm|e∈Z,e≥0}, where gcd(m,x) means the greatest common divisor of m and x, and you are asked to pick up n distinct integers from (S−T), the set of elements in S but not in T, or report that it is unachievable. Besides, there is an additional restriction, m=qk for a prime number q and a positive integer k.

It is not difficult to show |S|, the size of S, equals to φ(m)=m(1−1q). When gcd(m,p)>1, there is only one element p0modm=1 in T which is coprime to m, so in that case, |S−T|=φ(m)−1. To output a solution, you can just enumerate the smallest integers and skip the integer 1 and any multiples of q. In this process, you won't need to enumerate more than (2n+1) integers, because n1−1q+1≤2n+1.

When gcd(m,p)=1, we can observe that T⊆S. Let |T| be λ, and we may conclude from Euler's totient theorem that λ≤φ(m), and even λ|φ(m). When n>φ(m)−λ, there is no solution, so we need to calculate λ in order to determine the existence of solutions.

To calculate λ, you can just enumerate all the divisors of φ(m) and check them using Fast Power Algorithm, because the number of divisors is not too large due to the restrictions. Alternatively, you can do it more advanced and check more efficiently like the following.

lambda = phi(m)for each x in prime factors of phi(m) :	if pow(p, lambda / x, m) == 1 :		lambda = lambda / xThe above approach requires O(logφ(m)) calls of Fast Power Algorithm. It is used more regularly when searching a random primitive root in modulo some integer.

When implementing Fast Power Algorithm, you may notice an issue that the modular multiplication may not be easy to code, when the 128-bit integer operations are not directly provided on this platform. In a precise way, you can implement another like Fast Multiplying Algorithm, though it is a bit slow. But if you believe you are lucky enough and you prefer using C/C++, you can try the following code in a convenient way.

typedef long long LL;typedef long double LD;LL mod_mul(LL x, LL y, LL mod) { // 0 <= x, y < mod	LL ret = x * y - (LL)((LD)x * y / mod + 0.5) * mod;	return ret < 0 ? ret + mod : ret;}No matter what approach you used, the factorization of (q−1) is inevitable, so the problem requires you to factorize a relatively large number (less than 1018) a bit quickly. For example, you can use Pollard's Rho Algorithm with Miller-Rabin Primality Test. By Birthday Paradox, which is a heuristic claim, when x is not a prime, Pollard's Rho Algorithm can split x into u⋅v in O(min(u,v)−−−−−−−√)=O(x1/4) iterations. By the way, you can obtain q from m by enumerating possible k from large to small, instead of factorization.

Let's go back to the case that gcd(m,p)=1 and n≤φ(m)−λ. When any solution exists, we can observe that φ(m)−λ≥φ(m)2, so there may exist some solutions based on random distribution. That is, if you are able to check whether an integer is in T or not, you can roughly pick 2n integers in S and check them. One approach is like the mechanism built in the problem checker, but as space is limited, I would not expend it at here. One thing you should be aware of is that you can't pick them without checking, as the probability of failure may be so large, like 12. Moreover, you can't use Baby-Step-Giant-Step algorithm since its time complexity O(nm−−−√) is too slow.

If there exists at least one primitive root in modulo m, then we can construct the output integers. Since a primitive root g can represent S as {gemodm|e∈Z,0≤e<φ(m)}, we can reduce the problem into something about modular equation that only concerns the exponents. As the number of primitive root in modulo m is φ(φ(m)), if the root exists, we can get a random primitive root easily. Now let's assume we find a primitive root g and p≡gu(modm). An integer (gvmodm) is in T if and only if the equation eu≡v(modφ(m)) has a solution of e. It is easy to show, when gcd(φ(m),u)|v, a solution of e always exists, so the construction is quite straightforward.

The only case we left is when no primitive root exists in modulo m, which occurs when m=2k, k≥3. In this case, we cannot represent all the elements in S as non-negative integer powers of one specific number, but we can find a pseudo-primitive root g′ to use its powers to represent all the elements in the form of (4t+1) in S (as the group (S,×m), also known as (Z/mZ)×, is isomorphic to a direct product of cyclic groups, C2×C2k−2). Besides, {m−(g′emodm)|e∈Z,0≤e<2k−2} can represent the rest numbers (in the form of (4t+3)) in S. As the product of two integers in the form of (4t+3) is in the form of (4t+1), we can discuss the parity of e in expression (pemodm) and check if an integer is in T, so the construction could work after a little modification. By the way, there exist many different construction methods for this case.

In summary, to solve this problem, we need to factorize φ(m), calculate the order of p in modulo m, find a primitive root g (or a pseudo-primitive root g′) in modulo m and enumerate some small integers (values or exponents) to construct a solution.

Time complexity: O((m1/4+n)M(m)), where M(m) means the cost of one multiplication modulo m. Some slow solutions are accepted as well.

Solution (by skywalkert)Solution (by quailty)

Editorial of Codeforces Round #572

By 244mhq, 4 years ago, translation, In EnglishCodes have been added!

We've added challenges(mostly not hard) to some tasks. Feel free to share solutions and ask any questions in comments!

Keanu ReevesIf the string is good, then answer it's itself. Otherwise, there are at least two strings in answer, and we can print substring without its last symbol and its last symbol separately. Complexity O(n).

code

Number circleLet's suppose that array is sorted. First of all, if an≥an−1+an−2, than the answer is — NO (because otherwise an is not smaller than sum of the neighbors). We claim, that in all other cases answer is — YES. One of the possible constructions (if the array is already sorted) is:

an−2,an,an−1,an−4,an−5,…,a1It's easy to see, that all numbers except an will have at least one neighbor which is not smaller than itself. Complexity O(nlog(n)).

code

ChallengeSolve the task in O(n) (if we suppose that all numbers don't exceed 109).

Candies!!!Solution 1 (magic)Solution 2 (dp)Add on a treeWe claim, that the answer is YES iff there is no vertex with degree 2. After this, it's easy to get a solution for first subtask in O(n).

ProofBecause all numbers are different, in the second subtask if we have a vertex with degree 2 then answer is NO. If there is no such then construction also follows from proof. Indeed, if we can add on any path to leaf, then we can add on one edge. So, consider any edge uv and suppose we want to add x on this edge. Let's find any leaf in a subtree of vertex u, which doesn't contain v, let's name it l. If l=u, just add x on path uv. Else, add x on path vl and −x on path ul. It's clear, that after this two operations we've added x on edge uv and didn't add anything on other edges. Then, just add on each edge needed number.

In the end, let's talk about implementation. To add on the path to leaf it's sufficient to find a leaf in the subtree. We can do it naively in O(n), then complexity is O(n2). Also, we can precalculate leaves in each subtree and, for example, root tree at some leaf. Then, it's possible to do all operations in O(1), and complexity is O(n), but it wasn't needed.

ChallengeSolve task if numbers are not necessary even and different, but all operations should be also with integer x(now it turns out that sometimes it's possible to solve it in rationals, but not in integers).

code for 1 subtask code for 2 subtask

Count pairsLet's transform condtition a ittle bit. ai−aj≢0 mod p, so condtition is equivalent:

(ai−aj)(ai+aj)(a2i+a2j)≡(ai−aj)k⇔a4i−a4j≡kai−kaj⇔a4i−kai≡a4j−kaj.

That's why we just need to count number of pairs of equal numbers in the array bi=(a4i−kai) mod p. It's easy to do it, for example, using map. Complexity O(n) or O(nlog(n)).

code

ChallengeSolve the task, if numbers are not necessarily different.

Array beautyFirst of all, let's learn how to solve the following subtask:

For given x how many subsequences of length k have beauty at least x? If we know that the answer for x is px, than the answer for original task is p1+p2+…+pmax(a), where max(a) is maximum in array a. Let's solve subtask.

Suppose, that array is sorted. We should count subsequence p1<p2,…<pk, iff:

ap2≥ap1+x,…,apk≥apk−1+x.

We will solve this task using dp. The slow solution is:

dp[last][cnt] — number of subsequences of length cnt, which end in alast. There are transitions from state with last′<last,cnt′=cnt−1, such that alast≥alast′+x. To optimize it we need to note, that suitable last′ form some prefix of the array. If we know needed prefixes and prefix sums from the previous layer of dp, then we can make transitions in constant time. We can find needed prefixes using two pointers(because it's obvious, that length of prefixes doesn't decrease). So, we can solve subtask in O(nk) time.

And, using solution to subtask, we can solve inital task in O(max(a)nk). And here comes magic:

If x>max(a)k−1, than px=0. Indeed, если ap2≥ap1+x,…,apk≥apk−1+x, than:

an≥apk≥apk−1+x≥apk−2+2x…≥ap1+(k−1)x≥(k−1)x. It follows: (k−1)x≤an⇔x≤ank−1.

So we can run our dp only for x≤max(a)k−1. In total our solution works in O(max(a)k−1nk)=O(max(a)n) time, because kk−1≤2.

ChallengeHow fast you can solve the task if you need to print answer for all 2≤k≤n?

code

Make equalWe will suppose, that array is sorted. Let x be the final number. Than x≥an. Also, if we define bits[c] — as number of ones in binary notation of c, than, to get x from ai we will spend at least bits[x−ai] moves(it follows from the fact, that minumum number of powers of two, which in sum are equal to the number, corresponds to it binary notation). Let t=x−an, than x−ai=t+an−ai. So we need the following task:

Minimize sum bits[t+an−a1]+bits[t+an−a2]+…+bits[t+an−an], where t is some nonnegative integer. Also, let's define bi as an−ai.

We will solve this task using dp — value, which we want to minimize is sum bits[t+bi], taken over bits up to (k−1). Then, suppose we want to decide something about k-th bit. Let's understand, which information from the previous bits is needed for us. Imagine, that we sum t и bi in vertical format. Clearly, to find k-th bit in number t+bi it's sufficient to know k-th bit in number t and do we have carry from previous digit. Furthermore, if we know this information for the previous bit, we can get it for the next(carry in new digit will occur iff bitk[bi] + bitk[t] + (didwehavecarry)≥2). But we should save information about carry for all numbers t+bi, so, at first sight, for one bit we have at least 2n different states of dp. To reduce the number of states we need to note key fact:

Let t′=t mod 2k, c′=c mod 2k. Than, carry in k-th bit will occur t+c iff t′+c′≥2k. Indeed, carry corresponds to the fact that the sum of "cutoff" numbers is at least 2k.

Using this fact we understand that, if we sort numbers b′i=bi mod 2k, than carry in k-th bit will happen only for some suffix of b′i. That's why, we get n+1 different states for one bit, which is good. So we only need to learn how to make transitions fast. It's useful to note, that we don't need to know numbers bi, it's sufficient to know do we have a carry and value of k-th bit of bi. Then, transition reduces to count the number of 1 and 0 in k-th bit on some segment of the array sorted by b′i. This can be easily done in constant time if we precalculated prefix sums(for better understanding you can read attached code). So, we can solve the task in nlog(n)F time, where F is bit up to which we'll write dp. So, it' left to show (or to believe :)), that there is no sense to consider big F.

Not so long proofNow we can honestly say that complexity of solution is O(nlog(n)log(max(a)).

code

ChallengeCan you solve task in O(nlog(max(a))?

Problem from Red Panda.We'll suppose(as in 3 tasks before), that the array is sorted. Our operation is equivalent to choosing some 1≤i≤k and increasing ai by k−1, аnd decreasing remaining ai by one. To solve the task, we need to make some claims:

Claim 1Difference ai−aj mod k doesn't change for any i,j. Moreover, in one move ai shifts by 1 mod k.

Claim 2If we've made two sequences of moves of length i and j, where i<k, j<k, then obtained configurations coincide iff i=j and chosen colors coincide as multisets(orders can be different, but number of times we've chosen each color needs to be equal).

Proof

Because in one side claim is obvious, we will suppose, that obtained configurations are equal and we'll show that multisets of colors are also equal. Let's define number of baloons, which we've got using first sequence, as bt and ct for the second. Because bt≡bt−i mod k, ct≡at−j mod k, то i=j. Let's note that bt=at−i+k⋅addB[t], where addB[t] — number of times we've chosen color t. So, we get that addB[t]=addC[t] for each 1≤t≤k.

Claim 3If there is i, such that ai+1<i, then we'll not make more than i−1 moves.

Proof

On each move we choose exactly one color, so after i moves there will be at least one color among first i+1 that we didn't choose. But then, the number of balloons of this color will be less than i−i=0, which is not allowed.

Let's call minimum index i from Claim 3(if it exists) critical.

Claim 4Suppose critical index is equal to i. Assume, that we decided to make j<k moves and we've fixed number of choices of each color — add[t]. It's clear, that add[t]≥0,add[1]+add[2]+…add[k]=j. Then, there exist correct sequence of moves with this number of choices iff:

j<iIf at<j, then add[t]>0.

Not so long proofUsing these claims, we can solve the problem if the critical index exists and is equal to i:

Let's iterate through all possible number of moves between 0 and i−1, suppose it's equal to x. Then, by Claim 4 we know that, if ap<x, then add[p]>0, else there are no restrictions (except obvious add[p]≥0). So, we have arrived to the following problem:

Count the number of nonnegative solutions add[1]+…+add[k]=x, where fixed num numbers should be positive. By Claims 2 and 4 the solutions of this equation correspond to some final configuration, and this is exactly what we need to count.

This is well known task(stars and bars), answer is given by Cx−num+k−1k−1So, the answer is given by the sum of these values over all x.

Let's call configuration critical, if it has critical element (in other words, if there is index i such that i<k−1 and at least i+2 elements of configuration do not exceed i).

To solve the problem when there is no critical index we need:

Claim 5If configuration is not critical, then configuration bi is reachable iff ai−bi≡aj−bj mod k and bi≥0, a1+…ak=b1+…bk.

Long proofNow, it only remains to show how to count the number of such b from Claim 5.

b1,b2,…,bk should give remainders (a1+t)modk,(a2+t)modk,…,(ak+t)modk for some t. We сan calculate configurations with such remainders by the following way: remaining a1+a2+…+ak−(a1+t)modk−(a2+t)modk−…−(ak+t)modk are splitted in groups by k and are distributed in k elements in any way. So, that's why, for given t number of configurations(by stars and bars) is given by Ca1+a2+…+ak−(a1+t)modk−(a2+t)modk−…−(ak+t)modkk+k−1k−1. Sum a1+a2+…+ak−(a1+t)modk−(a2+t)modk−…−(ak+t)modk can be calculated for t=0,1,…,k−1 in O(1), if we precalculate number of each remainder among a1,a2,…,ak.

That's why final complexity for each of the cases is O(n+k).

code

Challenge

Find all typos in proofs.

Editorial of Codeforces Round #571 (Div. 2)

By BanRussiaAtIOI, 4 years ago, In English1186A - Казак Вус и контестSince a pen and a notebook would be given to each participant, the answer is "Yes" if and only if n≤k and n≤m. The answer is "No" otherwise.

1186C - Казак Вус и строкиLet's say that we want to know whether f(c,d) is even for some strings c and d.

Let's define cntc as number of ones in string c and cntd as number of ones in d.

It's easy to see that f(c,d) is even if and only if cntb and cntc have same parity. In other words if cntc≡cntd(mod2) then f(c,d) is even.

So, we can check if two strings have even number of distinct bits in O(1) if know how many ones does each of them contain.

Using that fact we can easily solve problem in O(n) by using prefix sums.

1186D - Казак Вус и числаAt first step we should floor all the elements of the array. Then we iterate through the array and do the following:

If sum of all the elements of array is equal to 0, then the algorithm stops.If the decimal part of ai was not equal to 0, then we assign ai:=ai+1Increase i and repeat step 1.If you are interested why this works, here is the proof:

Every element ai of the initial array can be expressed as ⌊ai⌋+εi. It is obvious that 0≤εi<1.

Sum of all elements of array a equals to 0, it means that:∑i=1nai=0∑i=1n(⌊ai⌋+εi)=0∑i=1n⌊ai⌋+∑i=1nεi=0From equations above we can see that ∑ni=1εi is an integer. Every εi<1, and that means ∑ni=1εi is smaller than number of elements that were floored, so we will always be able to achieve zero sum of array a by adding 1 to some of the numbers that were initially floored.

1186E - Казак Вус и полеLet's define f(x,y) a function that returns sum of all elements of submatrix (1,1,x,y) (these 4 numbers stand for x1,y1,x2,y2 respectively. If we can get value of this function in a fast way, then we can answer the queries quickly by using well known formula for sum on submatrix with cooridantes x1,y1,x2,y2:

sum=f(x2,y2)−f(x2,y1−1)−f(x1−1,y2)+f(x1−1,y1−1)If you want to prove the formula you should draw some examples and use the inclusion-exclusion principle.

So we reduced our task to finding value of f(x,y) for some arbitrary x and y.

At first, we should precalculate values of f(x,y) for every 1≤x≤n,1≤y≤m. This can be easily done using dynamic programming.

Let's forget about the sums for a while. Let's take a look on the fields. They can be both inverted or not inverted. Let's see how fields are distributed when generating an infinite field.

At step 0 we have one field, which is not inverted:0At step 1 we have four fields:0110And so on...

After 3 steps we can see that you can split each horizontal or vertical line in pairs of inverted and not inverted fields like on the picture (vertical pairs are highlighted with yellow, horizontal pairs are highlighted with red):

Sum of inverted and not inverted matrices of size n×m is equal to n⋅m.

Knowing these facts we can get O(1) solution.

Let's say that we want to know f(x,y). Let's define fieldx and fieldy as coordinates of the field which cell (x,y) belongs to. They can be easily found:fieldx=⌊x−1n⌋+1fieldy=⌊y−1m⌋+1The solution is splited into four parts:

When both fieldx and fieldy are odd.When fieldx is odd, but fieldy is even.When fieldx is even, but fieldy is odd.When both feildx and field+y are even.Solving each of the part is very similar, so I'll show you how to get value of f(x,y) if both fieldx and fieldy are even (In this particular example fieldx=fieldy=4). The big black dot shows us the position of (x,y) (i.e. it shows that the cell with coordinates (x,y) is located somewhere in the field with coordinates (4,4)).

Using the fact I mentioned before we can get the value of pairs highlited as red: it is equal to((fieldx−1)⋅(fieldy−1)−1)⋅n⋅m2You can easily use the same fact in order to find the blue and yellow parts.

In order to find the green parts we need to know whether each of the matrices, highlighted with green is inversed. How to know if the matrix with coordinates (a,b) is inversed? Here is the trick (here bitcnt is the function which returns number of bits in a number):

If bitcnt(a)+bitcnt(b) is an odd number, then the matrix is inversed.1186F - Казак Вус и графAt first, let's create a fictive vertex (I'll call it 0 vertex) and connect it with all of the vertices which have odd degree. Now all the vertices including 0 vertex have even degree. The statement that 0 vertex will have even degree too can be easily proven using the fact that the sum of degrees of all vertices equals to the number of edges multiplied by two. Let's denote the number of edges in the new graph as k.

There were m edges initially and we added at most n new edges that connect fictive vertex with the real ones, so it always holds that k≤n+m.

Now, since all the vertices have even degree we can find Euler cycle of the new graph. Let's define e1,e2,…,ek as an array of all edges of the graph, ordered as in found Euler cycle. Now we can iterate over the array e and delete all the edges on even positions. Due to this action now the new graph contains at most ⌈k2⌉≤⌈n+m2⌉ edges. That is exactly what we needed!

It is interesting that in the new graph by deleting the edges the way mentioned above, the degree of each vertex would not be reduced more than twice. How to prove that? Well, you can think about it the following way:

Let's say that the ei edge connects some vertices a and b, that means that the ei+1 edge connects vertex b with some vertex c. If i is odd, then we will delete only the ei+1 edge, and if i is even, then we will delete only the ei edge. And that happens for every vertex: if some edge i enters it, then we will either delete i-th edge or i+1-th edge. So at most half of edges connected to a vertex will be deleted. If the length of Euler cycle is odd, then the last edge in it won't be deleted at all, so the algorithm will still work correctly.

But that works for the new graph, which contains fictive vertex. But we need to solve the problem for the real graph. We can not simply delete all the edges from the real graph, that were on even positions in Euler cycle mentioned above. Here is the examle where it does not work (numbers near the edges show their positions in e array, edges that would need to be removed are highlited with red):

If we removed edge between vertices 2 and 3, degree of vertex 3 would become 0 which is definetely less then ⌈d32⌉=1. How do we avoid this bad situation? We can simply do the following:

If ei is a fictive edge (i.e. it connects a real vertex with fictive one), then we do not really care about it, since we have to output answer about the real graph.If ei is a real edge (i.e it connects only real vertices) and we have to delete it, then we should look if ei−1 or ei+1 is a ficive edge. If either of them is one, then we can delete the fictive edge instead of the real edge ei (i.e. we simply do not delete ei from the graph), otherwise we delete the edge. (Note that if ei is the last edge in the Euler cycle, then instead of checking the ek+1 edge which does not exist, you check if e1 is fictive or not, similar goes for the case if i=1).It is obvious that by doing so we do not change the number of edges deleted. It is also easy to see that the degree of a i−th vertex in the new graph is at most di+1. We still delete at most ⌊di+12⌋ edges connected to it (or ⌊di2⌋ if it initially had an even degree), but in case when it's degree was "artificially" increased, we prefer to delete the fictive edge, which we do not care about. The last question is: whether there we will a fictive edge which we will try to delete more than once? It is easy to prove that there is no such edge, you can try it by yourself.

That's it, the problem is solved.

Note that the graph is not necessarily connected, so you should find Euler cycle and do the following steps for each component independently.

In order to better understand the solution, check out author's source code:

Codeforces Round #570 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1183A - Nearest Interesting Number

Idea: MikeMirzayanov

Tutorial1183A - Nearest Interesting NumberEven if we will iterate over all possible numbers starting from a and check if sum of digits of the current number is divisible by 4, we will find the answer very fast. The maximum possible number of iterations is no more than 5.

Solution1183B - Equalize Prices

Idea: MikeMirzayanov

Tutorial1183B - Equalize PricesIt is very intuitive that the maximum price we can obtain is min+k where min is the minimum value in the array. For this price we should check that we can change prices of all products to it. It can be done very easily: we can just check if each segment [ai−k;ai+k] covers the point min+k. But this is not necessary because if we can change the price of the maximum to this value (min+k) then we can change each price in the segment [min;max] to this value. So we just need to check that min+k≥max−k and if it is then print min+k otherwise print -1.

Solution1183C - Computer Game

Idea: MikeMirzayanov and vovuh and BledDest

Tutorial1183C - Computer GameFirstly, about the problem description. Vova really needs to complete the game i. e. play all n turns. Exactly n turns. Among all possible ways to do it he need choose one where the number of turns when he just plays (this is the first type turn!) is maximum possible.

Suppose the answer is n. Then the charge of the battery after n turns will be c=k−na. If this value is greater than 0 then the answer is n. Otherwise we need to replace some turns when Vova just plays with turns when Vova plays and charges. The charge of the battery will increase by diff=a−b avfter one replacement. We have to obtain c>0 with some replacements. The number of turns to do it is equals to turns=⌈−c+1diff⌉, where ⌈xy⌉ is x divided by y rounded up. If turns>n then the answer is -1. Otherwise the answer is n−turns.

Solution1183D - Candy Box (easy version)

Idea: MikeMirzayanov

Tutorial1183D - Candy Box (easy version)Let's calculate the array cnt where cnti is the number of candies of the i-th type. Let's sort it in non-ascending order.

Obviously, now we can take cnt1 because this is the maximum number of candies of some type in the array. Let lst be the last number of candies we take. Initially it equals cnt1 (and the answer ans is initially the same number). Then let's iterate over all values of cnt in order from left to right. If the current number cnti is greater than or equal to the last taken number of candies lst then we cannot take more candies than lst−1 (because we iterating over values of cnt in non-ascending order), so let's increase answer by lst−1 and set lst:=lst−1. Otherwise cnti<lst and we can take all candies of this type, increase the answer by cnti and set lst:=cnti.

Solution1183E - Subsequences (easy version)

Idea: MikeMirzayanov

Tutorial1183E - Subsequences (easy version)The topic of this problem is BFS. Let strings be the vertices of the graph and there is a directed edge from string s to string t if and only if we can obtain t from s by removing exactly one character.

In this interpretation we have to find first k visited vertices if we start our BFS from the initial string. And then the answer will be just nk minus the sum of length of visited strings. The last thing to mention: instead of standard queue of integers we need to maintain the queue of strings and instead of array of visited vertices we have to maintain the set of visited strings. Don't forget to stop BFS when you obtain exactly k strings.

If the number of distinct subsequences is less than k then the answer is -1.

Solution1183F - Topforces Strikes Back

Idea: vovuh

Tutorial1183F - Topforces Strikes BackI know about some solutions that are trying to iterate over almost all possible triples, but I have a better and more interesting one. Possibly, it was already mentioned in comments, but I need to explain it.

Let's solve the problem greedily. Let's sort the initial array. The first number we would like to choose is the maximum element. Then we need to pop out some maximum elements that are divisors of the maximum. Then there are two cases: the array becomes empty, or we have some maximum number that does not divide the chosen number. Let's take it and repeat the same procedure again, but now we have to find the number that does not divide neither the first taken number nor the second taken number.

So we have at most three numbers after this procedure. Let's update the answer with their sum. This solution is almost correct. Almost! What have we forgotten? Let's imagine that the maximum element is divisible by 2, 3 and 5 and there are three following numbers in the array: maximum divided by 2, by 3 and by 5. Then their sum is greater than the maximum (and may be greater than the answer we have!) because 12+13+15>1. So if these conditions are satisfied, let's update the answer with the sum of these three numbers.

It can be shown that this is the only possible triple that can break our solution. The triple 2,3,4 does not match because the maximum divided by 4 divides the maximum divided by 2. The triple 2,3,6 is bad for the same reason. And the triple 2,3,7 has sum less than the maximum element.

Solution1183G - Candy Box (hard version)

Idea: MikeMirzayanov

Tutorial1183G - Candy Box (hard version)First of all, to maximize the number of candies in the gift, we can use the following greedy algorithm: let's iterate on the number of candies of some type we take from n to 1 backwards. For fixed i, let's try to find any suitable type of candies. A type is suitable if there are at least i candies of this type in the box. If there exists at least one such type that wasn't used previously, let's pick any such type and take exactly i candies of this type (and decrease i). It does not matter which type we pick if we only want to maximize the number of candies we take.

Okay, let's now modify this solution to maximize the number of candies having fi=1. We initially could pick any type that has at least i candies, but now we should choose a type depending on the number of candies with fi=1 in this type. For example, if we have two types having x1 and x2 candies with fi=1 respectively, and we want to pick i1 candies from one type and i2 candies from another type, and x1>x2 and i1>i2, it's better to pick i1 candies of the first type and i2 candies of the second type. In this case we have min(x1,i1)+min(x2,i2) candies with fi=1, in the other case it's min(x2,i1)+min(x1,i2). And if x1>x2 and i1>i2, then min(x1,i1)+min(x2,i2)≥min(x2,i1)+min(x1,i2). So, when we want to pick a type of candies such that we will take exactly i candies of this type, it's optimal to choose a type that wasn't used yet, contains at least i candies, and has maximum possible number of candies with fi=1. This best type can be maintained with a multiset or a set of pairs.

Solution1183H - Subsequences (hard version)

Idea: MikeMirzayanov

Tutorial1183H - Subsequences (hard version)Firstly, let's calculate the following auxiliary matrix: lsti,j means the maximum position pos that is less than or equal to i, and the character spos=j (in order from 0 to 25, 'a' = 0, 'b' = 1, and so on). It can be calculated naively or with some easy dynamic programming (initially all lsti,j are −1 and then for each i from 1 to n−1 all values lsti,j are equal to lsti−1,j except lsti,si which is i).

After calculating this matrix we can solve the problem by the following dynamic programming: let dpi,j be the number of subsequences of length j that ends exactly in the position i. Initially all values are zeros except dpi,1=1 for each i from 0 to n−1.

How do we perform transitionss? Let's iterate over all lengths j from 2 to n, then let's iterate over all positions i from 1 to n−1 in a nested loop, and for the current state dpi,j we can calculate it as ∑c=025dplsti−1,c,j−1. If lsti−1,c=−1 then we don't need to add this state of the dynamic programming to the current state. Don't forget to take the minimum with 1012 after each transition!

This transition means that we take all subsequences that end with each possible character of the alphabet and try to add the current character to each of them. You can understand that there are no overlapping subsequences in this dynamic programming.

After that let's iterate over all possible lengths j from n to 1 and calculate the number of subsequences of the current length j. It equals to cnt=∑c=025dplstn−1,c,j. The same, if lstn−1,c=−1 then we don't need to add this state of the dynamic programming to cnt. Don't forget to take the minimum with 1012! If cnt≥k then let's add k(n−len) to the answer and break the cycle. Otherwise let's add cnt(n−len) to the answer and decrease k by cnt.

If after all iterations k is greater than zero then let's try to add the empty string to the answer (we didn't take it into account earlier). Increase the answer by n and decrease k by one. If after this k is still greater than zero then the answer is -1, otherwise the answer is the calculated sum.

Time complexity: O(n2).

Solution

Editorial of Round #569

By DmitryGrigorev, history, 4 years ago, translation, In English(Idea of the problem Div2A — ScreaMood)

(Developer of the problem Div2A — DmitryGrigorev)

1180A - Alex and a RhombusLooking into the picture attentively, one can realize that there are 2 rows with one cell, 2 rows with two cells, ..., and 1 row with n cells. Thus the answer can be easily computed by O(n).

Code

(Idea of the problem Div2B — kirillbogatiy)

(Developer of the problem Div2B — DmitryGrigorev)

1180B - Nick and ArrayInitially, we are going to make a product maximal by absolute value. It means that if ai≥0 we are going to apply described operation (i.e to increase the absolute value). Now if the product is already positive, it's the answer. Else to apply the operation to the minimal number is obviously optimal (if we applied the operation to any other number the result would not be greater by absolute value, but applying to the minimum we have received non-negative product already). Thus the solution works in O(n).

Code

(Idea of the problem Div1A — Mr.Hakimov)

(Developer of the problem Div1A — Mr.Hakimov)

1179A - Valeriy and DequeIt can be noted that if the deque has the largest element of the deque in the first position, then during the next operations it will remain in the first position, and the second one will be written to the end each time, that is, all the elements of the deque starting from the second will move cyclically left.

Let's go over the deque and find the largest element by value. We will perform the operation described in the statements until the maximum position is in the first position and save the elements in the first and second positions by the operation number. In order to pre-calculate all pairs until the moment when the maximum position is found, it is enough to make no more than one pass through the deque, since in the worst case, the maximum element can be located at the end of the deque.

Denote as maxIndex the position of the maximum element. Then if mj<maxIndex, simply return a pair of numbers from the pre-calculated array, otherwise A is equal to the maximum element, and B is equal to the deque element with the index (mj−(maxIndex+1))%(n−1)+1 in 0-indexing (since we performed the operations until the moment when the maximum position is in the first position, this maximum element is now recorded in the first position).

Code

(Idea of the problem Div1B — DmitryGrigorev)

(Developer of the problem Div1B — PeregudovSergey)

1179B - Tolik and His UncleFirst, we are going to describe how to bypass 1⋅m strip.

This algorithm is pretty easy — (1,1) -> (1,m) -> (1,2) -> (1,m−1) -> …. Obviously all jumps have different vectors because their lengths are different.

It turns out that the algorithm for n⋅m grid is almost the same. Initially, we are going to bypass two uttermost horizontals almost the same way as above — (1,1) -> (n,m) -> (1,2) -> (n,m−1) -> … -> (1,m) -> (n,1). One can realize that all vectors are different because they have different dy. Note that all of them have |dx|=n−1. Then we will jump to (2,1) (using (−(n−2),0) vector). Now we have a smaller task for (n−2)⋅m grid. One can see that we used only vectors with |dx|≥n−2, so they don't influence now at all. So the task is fully brought down to a smaller one.

Code

(Idea of the problem Div1C — ----------)

(Developer of the problem Div1C — ----------)

1179C - Serge and Dining RoomThe main idea of the task is that the answer is minimal x which satisfies the condition that the number of dishes with cost ≥x is strictly more than the number of pupils who have more than x togrogs.

It can be proved using the fact that we can change every neighbor pair for pupils and we don't change the final set of dishes. Exact prove is left as an exercise.

Now to find the answer we can use a segment tree that maintains a balance between the number of dishes and the number of pupils for all suffices of values. Now change query transforms to add in the segment tree, the answer should be found searching the last element which is less than 0 (standard descent in the segment tree).

Complexity is O(n⋅log(n)).

Code

(Idea of the problem Div1D — DmitryGrigorev)

(Developers of the problem Div1D — ---------- и DmitryGrigorev)

1179D - Fedor Runs for PresidentWe suppose we add an edge u−v. Path u−v in the tree contains vertices t1,…,tk, where k — length of the path, t1=u,tk=v. For each vertex x of the tree, we say that f(x) — the closest to x vertex of this path. Finally, we call a component of ti all vertices x having f(x)=ti.

One can notice that after adding an edge every pair of vertices may generate not more than two simple paths — the first one had already been in the tree, the second one may be generated using added edge. One can notice that every new path is generated by every pair of vertices lying in different components. Let's consider the sizes of components — s1,…,sk respectively. So new path isn't generated for ∑i=1ksi⋅(si−1)2 pairs of vertices. So we have the following problem — to minimize this sum.

Thus, we should minimize ∑i=1ksi⋅(si−1)2, what is the same as, ∑i=1ksi⋅(si−1) = ∑i=1ksi⋅si−si = ∑i=1ks2i (because of ∑i=1ksi = n).

It's obvious now that u,v are leafs of the tree (else we could decrease this sum increasing the path).

For convenience, we will hang the tree for a non-leaf. We will consider that tl=lca(u,v) in the path. Then, the desired sum will be:

A+B+C, где

A=sz2t1+(szt2−szt1)2+…+(sztl−sztl−1)2B=(n−sztl−1−sztl+1)2C=sz2tk+(sztk−1−sztk)2+…+(sztl−sztl+1)2When we fix L=tl, p1=tl+1 и p2=tl−1, one can realize that A doesn't depend on L at all but depends on the subtree of p1, as C depends of the subtree of p2. Thus these sums can easily be calculated using DP. Let dp[x] be that optimal sum for vertex x. Then, when we fix L — lca(u,v) — we need to calculate the minimum by all different p1,p2 — children of L — the following sum:

dp[p1]+dp[p2]+(n−szp1−szp2)2.

We get:

n2+dp[p1]−2⋅n⋅szp1+dp[p2]−2⋅n⋅szp2+2⋅szp1⋅szp2.

Now one can see that if we sort all vertices by sz in non-increasing order one can use Convex Hull Trick — for the next vertex p2 we find minimum by all p1 which are already processed by functions 2⋅szp1⋅szp2−2⋅n⋅szp1+dp[p1], i.e k=2⋅szp1, b=−2⋅n⋅szp1+dp[p1]. k decreases, thus we write usual CHT.

Complexity is O(n⋅log(n)).

Code

Read this comment of saketh about another approach for this problem.

(Idea of the problem Div1E — DmitryGrigorev)

(Developer of the problem Div1E — TheWayISteppedOutTheCar)

1179E - Alesya and Discrete MathWe denote T as log(1018) for convenience.

Let, without loss of generality, n is even. Let us find such xi for function fi that fi(xi)=L2 using binary search. Now we're going to renumber functions so that in new numeration i<j attracts xi≤xj. Let xn2=P. Now one can see that we have reduced the task to two smaller ones — the original task for functions with numbers 1,…,n2, having only a restriction that all their segments of answer are enclosed inside segment [0;P], and, similarly, for others functions and segment [P;1018]. Considering the original problem with all functions as a problem with the restriction that segments of the answer are enclosed inside [0;1018], the task is reduced to smaller ones.

Proof of correctness if left as an exercise, it's pretty easy.

This works in O(n⋅T⋅log(n)).

To speed it up, we're going to find n2-th function by xi a little bit smarter. Long story short, we're going to act as in the search of k-th element in an array in linear time. We will take a random function fi, run binary search for it, and not run binary searches for others but check how many fj so that fj(xj)≤fi(xi). It's easy to check using one query fj(xi) for all fj. It will work in O(T⋅log(n)+n) queries on the average, as we know this process will averagely converge in O(log(n)) steps.

Let's estimate the total complexity.

Let, without loss of generality, the number of functions is n=2s for some s. So:

O(∑i=1s2s−i⋅T⋅i + n⋅log(n)) is number of queries ( (we will have 2s−i segments on the s−i-th level pf recursion, and for each of them log is i).

Thus it's:

O(n⋅log(n) + T⋅∑i=1s2s−i⋅i). So:

O(n⋅log(n) + T⋅n⋅∑i=1si2i).

It's O(n⋅log(n)+T⋅n), cause that series converges to 2.

Code

Editorial for Codeforces Round #568 (Div. 2)

By cannor147, 4 years ago, In English1185A - RopewalkersLet's solve the problem when a≤b≤c. If it's not true, let's sort a, b and c. If we move b to any direction, the distance between b and one of a or c decreases, so we get to a worse situation than it was. Thus, we can assume that the position b does not change. Then we should make following conditions come true: |a−b|≥d and |b−c|≥d.

If a−b≥d it can be achieved in 0 seconds, else in d−(a−b) seconds. So, the first condition can be achieved in max(0,d−(a−b)). If b−c≥d it can be achieved in 0 seconds, else in d−(b−c) seconds. So, the second condition can be achieved in max(0,d−(b−c)).

So, the answer for the problem is max(0,d−(a−b))+max(0,d−(b−c)).

Authors: MikeMirzayanov and geranazavr555

Authors' solution1185B - Email from PolycarpIt should be noted that if Polycarp press a key once, it's possible to appear one, two or more letters. So, if Polycarp press a key t times, letter will appear at least t times. Also, pressing a particular key not always prints same number of letters. So the possible correct solution is followed:

For both words s and t we should group consecutive identical letters with counting of the each group size. For ex, there 4 groups in the word "aaabbcaa": [aaa,bb,c,aa]. For performance you should keep every group as the letter (char) and the group size (int).

Then, if the number of groups in word s isn't equal to the number of groups in word t, then t can not be printed during typing of s. Let's go through array with such groups and compare the i-th in the word s with the i-th in the word t. If letters in groups are different, answer is NO. If the group in s are greater than group in t, answer is NO. Answer is YES in all other cases.

Every string can be splitted into such groups by one loop. So, the total time complexity is ∑|s|+∑|t|Author: MikeMirzayanov

Authors' solution1185C1 - Exam in BerSU (easy version)First of all we should precalculate sum si of all students' durations for each student. For i-th student si=si−1+ti.

Then for each student we can sort all durations ti of passing exam of students, who are before the current student. So, let's walk by these durations from larger to smaller and calculate prefix sum of them Di. We will iterate them until total duration is enough for the current student to pass the exam too, i.e. until si+ti−Di≤M. For i-th student the answer is number of iterated durations.

Sorting works in O(nlogn), walking by array works in O(n). Total complexity for all students is O(n2logn).

Authors: MikeMirzayanov, cannor147 and geranazavr555

Authors' solution1185C2 - Exam in BerSU (hard version)Note that 1≤ti≤100 for each i-th student. It brings us to the idea that for each student we only need to know number of students, who are before current student and whose duration of passing the exam is exactly k, for all k from 1 to 100.

Let's use countk as array of number student, whose duration of passing the exam is exactly k. Initially countk=0 for all k from 1 to 100.

For each student we can precalculate sum si of all durations of students before current. Now we can iterate all students from 1-st to n-th. Let's walk by k from 100 to 1. Initially the answer ai for i-th student is 0.

If si+ti−countk⋅k>M, let's si=si−countk⋅k and ai=ai+countk.If si+ti−countk⋅k≤M, it means that ai+countk is the answer, but it might be not minimal answer. So, the answer is ai+⌈sik⌉Authors: MikeMirzayanov, cannor147 and geranazavr555

Authors' solution1185D - Extra ElementFirst of all, we should sort all elements (from smaller to larger, for example, or vice versa). But in the answer is index of element in original sequence, so let's keep the array c of pairs {bi,i}, sorted by bi.

Now we need to check some simple cases, for example, let's check the 1-st and the 2-nd elements whether they are the answers. We'll create the copy of original sequence, but without 1-st element. Then we will check that all neighboring elements ci.first and ci+1.first have the same difference. If it is so, c1.second is the answer. For the 2-nd element similarly.

Okay, now we have the sequence, where 1-st and 2-nd elements aren't the answers. Let's fix difference between them d and check that all neighboring elements ci.first and ci+1.first have the same difference. If we meet the pair, where the difference doesn't equal d, we will check the difference between ci.first and ci+2.first. If it equals d, so ci+1.second may be the answer, otherwise there is no answer (output −1). If we will find one else pair, where the difference doesn't equals d, there is no answer too.

If all pairs have the difference that equals d, it means that it's initially arithmetic progression. So we can remove first or last element and get arithmetic progression again. In this case let's output 1.

Author: MikeMirzayanov

Authors' solution1185E - Polycarp and SnakesRemember, that Polycarp draws snakes in alphabetic order.

Firstly we should find the most top left and the most bottom right occurrences of each letter.

Secondly we should walk by these letters from 'z' to 'a'. We will skip first not found letters. If for any letter both length and width are larger than 1, there is no way to draw snakes. Otherwise we should check that all elements in the line equals current letter or '*'. If it's so, let's overdraw this line with '*' and move on to the next letter. If it's not so, there is no way to draw snakes.

If there is the answer, for each snake we can output coordinates of the most top left and the most bottom right occurrences of relevant letter. If there is no occurrences for some letter, we can suppose that the next letter fully overdrew the current letter. Totally we can solve the task, walking by field no more than 1+26=27 ones.

Authors: MikeMirzayanov, cannor147 and geranazavr555

Authors' solution1185F - Two PizzasThe first idea that could help to solve this problem is that the number of ingredients is small (1≤bit,ajt≤9). It means that we can keep information about favorite ingredients for each person in a bitmask. THe same situation is for pizzas' ingredients.

Let's keep two pizzas with the smallest cost for each ingredients' mask. This information could be calculated during the reading pizzas' mask.

Then, we should go through all possible masks, that could be reached by two different pizzas. For each such mask we should keep two pizzas with the smallest total cost, which gives us that mask (i. e. their bitwise-or is equal to our current mask).

After such calculations, let's go through all possible summary masks and count the number of people, who would be satisfied by this mask. It could be done with a submasks-bruteforce in 39. After this, we will have an optimal answer.

So, time complexity for this solution is O(n+m+22f+3f), where f≤9Authors: MikeMirzayanov, cannor147 and geranazavr555

Authors' solution1185G1 - Playlist for Polycarp (easy version)Consider all genres are from 0 to 2 instead of from 1 to 3. It will be easier to deal with 0-based indices.

Let's use DP to calculate d[mask][lst], where mask (0≤mask<2n) is a binary mask of songs and lst is a genre of the last song. The value d[mask][lst] means the number of ways to order songs corresponding to the mask in such a way that any neighboring (adjacent) songs have different genres and the genre of the last song is lst.

DP to find the array d is follows. It is easy to see that if d[mask][lst] is calculated correctly, you iterate over all possible songs j to append (such songs should be out of mask and a genre different from lst). In this case, you should increase d[mask+2j][genre(j)] by d[mask][lst].

Here is the sample code to calculate all cells of d:

d[0][3] = 1;forn(mask, 1 << n)    forn(lst, 4)        forn(j, n)            if (genres[j] != lst && ((mask & (1 << j)) == 0))                d[mask ^ (1 << j)][genres[j]] = (d[mask ^ (1 << j)][genres[j]] + d[mask][lst]) % M;Here we use some fake genre 3 to initialize DP (it can precede any real genre).

To find the answer, just take into account only such masks that the correspondent total duration is exactly M. Just find the sum of all such d[mask][lst] that the correspondent total duration is exactly M. You can do it at the same time with DP calculations. So the resulting code is:

int result = 0;d[0][3] = 1;forn(mask, 1 << n)    forn(lst, 4) {        forn(j, n)            if (types[j] != lst && ((mask & (1 << j)) == 0))                d[mask ^ (1 << j)][types[j]] = (d[mask ^ (1 << j)][types[j]] + d[mask][lst]) % M;        int sum = 0;        forn(i, n)            if (mask & (1 << i))                sum += durs[i];        if (sum == T)            result = (result + d[mask][lst]) % M;    }

cout << result << endl;The total complexity is O(n×2n).

Authors: MikeMirzayanov, cannor147 and geranazavr555

Authors' solution1185G2 - Playlist for Polycarp (hard version)Consider all genres are from 0 to 2 instead of from 1 to 3. It will be easier to deal with 0-based indices.

Let's find two arrays:

a[i][s] = number of ways to choose a subset of exactly i songs of the genre 0 with total duration of exactly s;bc[i][j][s] = number of ways to choose a subset of exactly i songs of the genre 1 and j songs of the genre 2 with total duration of exactly s.You can easily do it with DP. Here is the sample code to do it while reading the input:

    int n, T;    cin >> n >> T;

    vector<int> cnts(4);    vector<int> durs(4);

    a[0][0] = bc[0][0][0] = 1;    forn(i, n) {        int dur, type;        cin >> dur >> type;        type–;        if (type == 0) {            for (int cnts0 = cnts[0]; cnts0 >= 0; cnts0–)                forn(durs0, durs[0] + 1)                    inc(a[cnts0 + 1][durs0 + dur], a[cnts0][durs0]);        } else {            for (int cnts1 = cnts[1]; cnts1 >= 0; cnts1–)                for (int cnts2 = cnts[2]; cnts2 >= 0; cnts2–)                    forn(durs12, durs[1] + durs[2] + 1)                        inc(bc[cnts1 + (type == 1)][cnts2 + (type == 2)][durs12 + dur],                            bc[cnts1][cnts2][durs12]);        }        cnts[type]++;        durs[type] += dur;    }This part works in O(n3⋅T) with a really small constant factor.

Let's calculate the array ways[i][j][k][lst] = number of ways to put i zeroes, j ones and k twos in a row (its length is i+j+k) in such a way that no two equal values go consecutive and the row ends on lst. You can also use DP to find the values:

    ways[0][0][0][3] = 1;    vector<int> c(3);    for (c[0] = 0; c[0] <= cnts[0]; c[0]++)        for (c[1] = 0; c[1] <= cnts[1]; c[1]++)            for (c[2] = 0; c[2] <= cnts[2]; c[2]++)                forn(lst, 4)                    if (ways[c[0]][c[1]][c[2]][lst] != 0) {                        forn(nxt, 3)                            if (nxt != lst && c[nxt] + 1 <= cnts[nxt]) {                                vector<int> cn(c);                                cn[nxt]++;                                inc(ways[cn[0]][cn[1]][cn[2]][nxt], ways[c[0]][c[1]][c[2]][lst]);                            }                    }This part works in O(n3) with a really small constant factor.

And now if the final part of the solution. Let's iterate over all possible ways how songs with the genre 0 can be in a playlist. It means that we try all possible counts of such songs (c[0] in the code below) and their total duration (durs0 in the code below). Now we know the total time for genres 1 and 2, it equals to T−durs0. Let's iterate over all possible counts of songs with genre=1 and songs with genre=2 (say, c[1] and c[2]). For fixed c[0], durs0, c[1] and c[2] there are x ways to choose songs, where x=a[c[0]][durs0]⋅b[c[1]][c[2]][T−durs]. To count all possible orders of songs, let's multiply x on:

c[0]! — number of permutations of songs with genre=0;c[1]! — number of permutations of songs with genre=1;c[2]! — number of permutations of songs with genre=2;ways[c[0]][c[1]][c[2]][0]+ways[c[0]][c[1]][c[2]][1]+ways[c[0]][c[1]][c[2]][2] - number ways to order them in the required way.After all the multiplications add the result to the answer.

The following code illustrates this part of the solution:

    int result = 0;    for (c[0] = 0; c[0] <= cnts[0]; c[0]++)        forn(durs0, durs[0] + 1)            if (T - durs0 >= 0)                for (c[1] = 0; c[1] <= cnts[1]; c[1]++)                    for (c[2] = 0; c[2] <= cnts[2]; c[2]++) {                        long long extra = (long long)(a[c[0]][durs0]) * bc[c[1]][c[2]][T - durs0] % M;                        forn(i, 3)                            extra = extra * f[c[i]] % M; // where f[j] = factorial of j                        forn(lst, 3)                            if (c[lst] > 0)                                inc(result, extra * ways[c[0]][c[1]][c[2]][lst] % M);                    }This part works in O(n3⋅T) with a really small constant factor.

So the total complexity is O(n3⋅T) (the constant factor is significantly less than 1).

Authors: MikeMirzayanov, cannor147 and geranazavr555

Authors' solution

Editorial of Codeforces Round #567 (based on All-Russian olympiad in the name of Keldysh)

By cdkrot, history, 4 years ago, translation, In EnglishThanks for the participation!

1181A - Chunga-Changa was authored by vintage_Vlad_Makeev and prepared by achulkov2

1181B - Split a Number was authored by Endagorion and prepared by manoprenko

1181C - Flag was authored and prepared by budalnik

1181D - Irrigation was authored by Helen Andreeva and prepared by ch_egor

1181E2 - A Story of One Country (Hard) was authored by voidmax and prepared by voidmax and alexey_kuldoshin.

And now the editorial:

1181A - Chunga-ChangaIt's easy to calculate how much coconuts we will buy: k=⌊x+yz⌋ (suppose that all money transferred to a single person, this way the number of bought coconuts would be clearly maximal)If k=⌊xz⌋+⌊yz⌋, then the answer is ⟨k,0⟩. The remaining case is a bit harder.Let's notice, that there is no need to transfer ≥z chizhiks, since the one transferring money could have used z chizhiks to buy one more coconut herself.Also it's optimal to transfer coins such that the remainder modulo z of the receiving part will turn to be exactly zero (we could have simply transfer less for the same effect).So the answer is ⟨k,min(z−(xmodz),z−(ymodz))⟩.1181B - Split a NumberSuppose that the number doesn't contain any zeros (that is, we can split it at any point).

Than it is easy to show that it is enough to check only the following cuts:

k; k, if the length of the number is 2k.k+1; k and k; k+1, if the length of the number is 2k+1.Some intuition behind this: it's not optimal to make "inbalanced" cuts. Because the sum a+b is at least max(a,b). And in case the maximum is large already, we could have built a more optimal answer if we would make a cut in a less "inbalanced" way.

One can also examine not only 1−2 possible cuts, but rather O(1) different options around the center, this way solution is a bit easier to proof.

In case we have zeros, the solution is mostly the same: we just simply need to consider the closest valid cut to the left from center and closest valid cut to the right. And take a minimum of them.

One can note that in the solution above we need to add and compare "long integers". One could have used a programming language in which they are already implemented (Python/Java) or implemented the required functions themselves. The number can be simply stored as a sequence of digits from least-important digit to the most-important. It's simple to implement the summation and comparing of such integers.

Tutorial is loading...1181D - Irrigation

Let's solve all the queries simultaneously. For this purpose sort them all in increasing order. Sort all the countries based on the number of hosted competitions in the first n years (see picture)

How this diagram changes after several more years of the competition? The cells are filled from lower rows to the higher, while inside one row we order cells based on the country number.

Let's fill this table from bottom upwards.

For the queries which won't be replied in the current row, it is not important in which order the cells in the current row are colored, only the quantity is important. So for such queries we can simply accumulate the number of already painted cells so far.

Now let's discuss the queries, which need to be answered in the current row. If we subtract from k (the query parameter) the number S of cells painted in previous rows, then we simply need to return the k−s-th element in this set. So in other words we need to add countries in the set and sometimes compute i-th element in it. One can use cartesian tree "treap" or a segment tree to do that.

It may also turn out, that after we fill all the diagram, there are some questions unanswered yet. In this case we can notice, that all the subsequent rows look like the whole set of countries. So the answer is simply the remainder of k−S modulo m.

Since we only need to consider at most n lines until the diagram is filled-up, the solution works in O((q+n+m)log).

1181E2 - A Story of One Country (Hard)We can rephrase the problem as follows:

There is a set of non-intersecting rectangles on the plane. Let's say, that some rectangular area on the plane is good, if it contains exactly one rectangle in it or there exists a vertical or horizontal cut, which cuts the area into two good areas. You are asked to check whether the area [0;109]×[0;109] is good.

It's easy to see that it is exactly the same process as in the statement, except we don't merge countries into one, we look at the reversed process, where we split one country into many.

Also let's notice, that when we found some cutting line, which doesn't goes through inner part of any rectangle, we can always apply it to separate our area into two. We can do that, since our predicate of set of rectangles being nice is monotonic: if we replace set of rectangles with its subset, it only can make better.

Now let's analyze when the cut is good:

This already gives us a solution in O(n2log), which passes the easy version of the problem. Simply solve the problem recursively, sorting rectangles as shown above. (and symmetrically for horizontal cuts) and try finding a cut. Once we find it, solve the problem recursively.

Now we have working time: T(n)=T(x)+T(n−x)+O(nlogn), where x is a size of one part of the cut. The worse case is x=1, so T(n)=O(n2log). □For the full version we need a faster solution.

The key idea is: let's cut always "smaller from larger". Suppose we are magically able to find any valid cut in O(1) (basically the number x). Then we could have spent O(x) to cut out the smaller part into new recursive call. While we can continue the process of cutting with the remaining rectangles in this recursion call.

This solution works in O(nlogn): Each time the size of problem reduces at least twice when we go into recursion, so there are only log levels.

However we need to handle "magic" here. For example one could have used a segment tree to implement all mentioned above (it would give a O(nlog2) time). But there is a simpler solution!

Let's sort rectangles using all 4 possible sortings. And let's iterate over all this sortings simultaneously. We need 4 directions instead of 2, because if we would e.g. only iterate from let to right, we wouldn't be able to cut out the "smaller" from "larger", in case the "smaller" is to the right of "larger". So we want to both go from left to right and from right to left.

When in one of the directions we see a valid place to make a cut, we remove all the rectangles into the separate recursion call. We also mark all those rectangles in the current recursion call as deleted and start the procedure of cutting again. We can simply skip the rectangles marked as deleted when we encounter them. For example we could use a linked list for that:

So now we got a solution in O(nlog2): one logarithm is from cutting smaller from larger and one logarithm is from sorting.

One could drop the second logarithm. For that we should sort all rectangles at the beginning and then carefully pass the correct ordering down the recursion. But that wasn't required.

Codeforces Round #566 (Div. 2) Editorial

By McDic, history, 4 years ago, In EnglishSorry for such difficulty balance. Here is the editorial.

1182A - Заполнение формамиIf you want to have no empty spaces on 3×n tiles, you should fill leftmost bottom tile. Then you have only 2 choices;

Both cases force you to group leftmost 3×2 tiles and fill. By this fact, we should group each 3×2 tiles and fill independently. So the answer is — if n is odd, then the answer is 0 (impossible), otherwise, the answer is 2n2.

Time complexity is O(1) with bit operation or O(n) with iteration.

Solution Code for A

Behind story of B: Original B was harder. None of 2100+ rated testers solved original B, so it got downgraded. Also there was more than 15 pretests before.

1182B - Плюс из рисункаFirst, try to find if there is any nonempty space which has 4 neighbors are all nonempty spaces. (Giant black star in the picture below.) If there is no such nonempty space, the answer is "NO".

Second, try to search the end of the "+" shape from the center. (White stars in the picture below.)

Third, try to find if there is any nonempty space outside of "+" shape(the area filled with "?"). If found then the answer is "NO".

If you validated all steps, then the answer is "YES".

Time complexity is O(wh).

Solution Code for BBehind story of C: C is created before few days to contest. If there was no current C, the contest would have hell balances.

1182C - Красивые строфыLet's make some definitions;

s1 and s2 are complete duo if two word s1 and s2 have same number of vowels and the last vowels of s1 and s2 are same. For example, "hello" and "hollow" are complete duo.s1 and s2 are semicomplete duo if two word s1 and s2 have same number of vowels but the last vowels of s1 and s2 are different. For example, "hello" and "hola" are semicomplete duo.If you want to form a beautiful lyric with 4 words, then the lyric must be one of the things listed below;

Consist of two complete duos.Consist of one semicomplete duo and one complete duo.Since the order of lyrics is not important, make complete duos as many as possible, then make semicomplete duos as many as possible. This can be done with the greedy approach with the usage of the red-black tree or hashmap.

After you formed all duos, make beautiful lyrics using one semicomplete duo and one complete duo first, then make beautiful lyrics using two complete duos. With this method, you can make the maximum possible number of beautiful lyrics.

Time complexity is O(n log n) or O(n).

Solution Code for CBehind story of D: Honestly I predicted D as hell hard problem. But other high rated people said it's not that hard.

1182D - Complete MirrorFirst, the valid tree should form like the picture below unless the whole tree is completely linear.

top: This node is the top of the tree. This node has always degree 1. This node is always one of the possible answers of valid tree. There might be no top node in the tree.semitop: This node is the closest children from the top node that satisfies degree>=3. In other words, this node is the end of the leaf branch which includes top node as leaf. This node can be one of the possible answers of valid tree. If there is no semitop in the tree, the whole tree is invalid.mid level: This is the area of nodes between semitop node and semibottom nodes.semibottom: These nodes are the closest ancestors from each leaf nodes which satisfies degree>=3. In other words, these nodes are the end of each leaf branches.bottom: These nodes are the leaves except top node.And also let's define u1 and u2 are directly reachable if there are only nodes with degree=2 between u1 and u2 exclusive.

There are two ways to find the top node and the semitop node.

Lawali's solution. Find the diameter path and validate for two leaves of the diameter path. If no valid vertex found(i.e. top is not in the diameter path), then the semitop should be the middle of the diameter path. Now validate for the semitop and the closest directly reachable leaf from semitop. If any valid vertex found, print it. Otherwise print −1.The first case of diameter path in valid tree. Semitop node is the middle of diameter path.The second case of diameter path in valid tree. Top node is the end of diameter path.

McDic's solution. Clone the whole tree and cut the leaf branches(include top) from the cloned tree. Let's call this tree as "inner tree". Inner tree consists of only semitop, mid level nodes and semibottom nodes. Then you can find the semitop by collapsing each level from leaf nodes of inner tree. Now validate for semitop, the furthest directly reachable leaf node from semitop, and the closest directly reachable leaf node from semitop. It is guaranteed that the top node is one of those two leaves. If any valid vertex found, print it. Otherwise print −1.This is the inner tree of original tree. You can find the semitop easier than before since top is removed in inner tree.Time complexity is O(n).

Solution Code for DBehind story of E: I didn't expected such well-known problem. My solution for E is more complicated.

1182E - Рекуррентность произведенийYou can form the expression into this;

cxfx=cx−1fx−1⋅cx−2fx−2⋅cx−3fx−3Let g(x,p)=cxfx's p-occurrence for prime number p. For example, 40=23×5 so 40's 2-occurrence is 3.

Then we can set the formula g(x,p)=g(x−1,p)+g(x−2,p)+g(x−3,p) and calculate g(n,p) using matrix exponentiation. Since all different prime numbers p share same matrix, we can calculate matrix only once. And we have less or equal than 36 distinct prime numbers targeted because you cannot get more than 9 distinct prime numbers by prime decomposition from numbers in range [1,109].

With g(x,p) we can calculate cnfn, and we can calculate fn using modulo inverse.

Time complexity is O(log n+ sqrt(max(f1,f2,f3,c))).

Solution Code for EBehind story of F: This problem was located at D originally.

1182F - Максимальный синусLemma: For all x, y ∈[0,π], if |sin(x)|>|sin(y)| then x is more closer to the π2 than y.

With this lemma, we can avoid the calculation of floating precision numbers. Let's reform the problem; Find minimum possible integer x that pqxπmodπ is the closest to π2. This is equivalent to find minimum possible integer x that 2pxmod2q is the closest to q.

Let g(x)=2pxmod2q. Now set the interval with length t=sqrt(b−a+1) and construct the list like this — [(g(a),a),(g(a+1),a+1),…(g(a+t−1),a+t−1)]. Then remove the big number xs with duplicated g(x) values from the list and sort the list.

Now we can find any x that g(x) is the closest to any integer y in O(log(n)). We will search all numbers in range [a,b] without modifying the list we created. How is this possible? Because g(x)+g(y)≡g(x+y)(mod2q) for all integers x, y.

So in every sqrt(b−a+1) iterations, we can set the target and just find. More precisely, our target value is q−2×i⋅t⋅pmod2q for i-th iteration. With this search, we can find such minimum possible integer x. Oh, don't forget to do bruteforce in remaining range!

The time complexity is O(sqrt n log n).

Solution Code for F

Codeforces Round #565 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1176A - Divide it!

Idea: vovuh

Tutorial1176A - Divide it!What if the given number n cannot be represented as 2cnt2⋅3cnt3⋅5cnt5? It means that the answer is -1 because all actions we can do are: remove one power of two, remove one power of three and add one power of two, and remove one power of five and add two powers of two. So if the answer is not -1 then it is cnt2+2cnt3+3cnt5. If this formula isn't pretty clear for you, you can just simulate the process, performing actions from third to first.

Solution1176B - Merge it!

Idea: MikeMirzayanov

Tutorial1176B - Merge it!Let cnti be the number of elements of a with the remainder i modulo 3. Then the initial answer can be represented as cnt0 and we have to compose numbers with remainders 1 and 2 somehow optimally. It can be shown that the best way to do it is the following: firstly, while there is at least one remainder 1 and at least one remainder 2, let's compose them into one 0. After this, at least one of the numbers cnt1,cnt2 will be zero, then we have to compose remaining numbers into numbers divisible by 3. If cnt1=0 then the maximum remaining number of elements we can obtain is ⌊cnt23⌋ (because 2+2+2=6), and in the other case (cnt2=0) the maximum number of elements is ⌊cnt13⌋ (because 1+1+1=3).

Solution1176C - Lose it!

Idea: vovuh

Tutorial1176C - Lose it!Let cnt1 be the number of subsequences [4], cnt2 be the number of subsequences [4,8], cnt3 — the number of subsequences [4,8,15] and so on, and cnt6 is the number of completed subsequences [4,8,15,16,23,42].

Let's iterate over all elements of a in order from left to right. If the current element is 4 then let's increase cnt1 by one (we staring the new subsequence). Otherwise it is always better to continue some existing subsequence (just because why not?). If the current element is 8 then we can continue some subsequence [4], if it is 16 then we can continue some subsequence [4,8,15] and the same for remaining numbers. Let pos be the 1-indexed position of the current element of a in list [4,8,15,16,23,42]. Then the case pos=1 is described above, and in other case (pos>1) if cntpos−1>0 then let's set cntpos−1:=cntpos−1−1 and cntpos:=cntpos+1 (we continue some of existing subsequences). The answer can be calculated as n−6cnt6 after all n iterations.

Solution1176D - Recover it!

Idea: MikeMirzayanov

Tutorial1176D - Recover it!Firstly, let's generate first 199999 primes. It can be done in O(nn−−√) almost naively (just check all elements in range [2;2750131]). It also can be done with Eratosthenes sieve in O(n) or O(nloglogn). We also can calculate for each number in this range the maximum its divisor non-equal to it (if this number is not a prime). And in other case we can calculate the index of this prime. Using all this information we can restore the array a.

Let's maintain a multiset (a set in which multiple copies of the same element are allowed) of all elements in b. While it is not empty, let's take the maximum element from this set mx. If it is prime (we can check it using the information calculated earlier) then it is some pai. Let's find the index of this prime (ai) using calculated information, remove this element and ai, push ai in a and continue. Otherwise this element is not a prime and then it is some ai. Let's remove it and its maximum divisor non-equal to it from the multiset, push ai in a and continue.

Solution1176E - Cover it!

Idea: MikeMirzayanov

Tutorial1176E - Cover it!Firstly, let's run bfs on the given graph and calculate distances for all vertices. In fact, we don't need distances, we need their parities. The second part is to find all vertices with an even distance, all vertices with and odd distance, and print the smallest by size part. Why is it always true? Firstly, it is obvious that at least one of these sizes will not exceed ⌊n2⌋. And secondly, because we are checking just parities of distances, it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity (because it has this parity from some vertex of the opposite parity).

Solution1176F - Destroy it!

Idea: BledDest

Tutorial1176F - Destroy it!The first (and crucial) observation is that we don't need all the cards that we get during each turn. In fact, since the total cost is limited to 3, we may leave three best cards of cost 1, one best card of cost 2 and one best card of cost 3, and all other cards may be discarded. So, the problem is reduced: we get only 5 cards each turn.

The problem may be solved with dynamic programming: dpx,y is the maximum damage we may deal if we played x turns and the last card we played had remainder y modulo 10. Processing each turn may be done with auxiliary dp: zc,f — the maximum damage we can deal during the turn if we play c cards, and f denotes whether some card (there will be only one such card, obviously) deals double damage. To calculate this auxiliary dp, we may do almost anything since we are limited to 5 cards during each turn. It is possible to calculate it in a fast way using some casework, but it is easier, for example, to try all possible permutations of 5 cards and play some prefix of a fixed permutation.

By combining these two techniques, we get a solution.

Solution

Codeforces Round #564 Editorial

By ouuan, history, 4 years ago, In English1173A - Nauuo and Votes

Idea: ouuan

TutorialConsider the two edge cases: all the z persons upvote / all the z persons downvote. If the results are the same in these two cases, it is the answer. Otherwise, the result is uncertain.

Solution1173B - Nauuo and Chess

Idea: Sulfox

Tutorialm≥⌊n2⌋+1Consider the chess pieces 1 and n.

∵⎧⎩⎨|r1−rn|+|c1−cn|≥n−1|r1−rn|≤m−1|c1−cn|≤m−1∴m−1+m−1≥n−1∴m≥n+12∵m is an integer∴m≥⌊n2⌋+1m can be ⌊n2⌋+1If we put the i-th piece on (ri,ci) satisfying ri+ci=i+1, it is a feasible plan, because |ri−rj|+|ci−cj|≥|ri+ci−rj−cj|.

Solution1172A - Nauuo and Cards

Idea: QAQAutoMaton

TutorialFirst, try to finish it without playing any empty cards.

If that's not possible, the best choice is to play several empty cards in a row, then play from 1 to n. For a card i, suppose that it is in the pi-th position in the pile (pi=0 if it is in the hand), you have to play at least pi−i+1 empty cards. So the answer will be max{pi−i+1+n}.

Solution1172B - Nauuo and Circle

Idea: Sulfox

TutorialFirst, if we choose a node as the root, then each subtree must be in a continuous arc on the circle. Then, we can use DP to solve this problem.

Let fu be the number of plans to draw the subtree of u, then fu=(|son(u)|+[u≠root])!∏v∈son(u)fv — choose a position for each subtree and then u itself, then draw the subtrees. However, instead of choosing the position of the root, we suppose the root is on a certain point on the circle, then rotate the circle, thus get the answer: nfroot.

In fact, we don't have to write a DP, the answer is n times the product of the factorial of each node's degree (n∏i=1ndegree[i]!).

Solution1172C1 - Nauuo and Pictures (easy version) and 1172C2 - Nauuo and Pictures (hard version)

Idea: ouuan

TutorialFirst, let's focus on a single picture with weight w which Nauuo likes, so we only have to know the sum of the weights of the pictures Nauuo likes (SA=∑i=1nwi[ai=1]) and the sum of the disliked ones (SB=∑i=1nwi[ai=0]) instead of all the n weights.

Then, we can use DP to solve this problem.

Let fw[i][j][k] be the expected weight of a picture Nauuo likes with weight w after another i visits since SA=j and SB=k.

Obviously, fw[0][j][k]=w.

The state transition:

The next visit displays the picture we focus on. Probaility: wj+k. Lead to: fw+1[i−1][j+1][k].

The next visit displays a picture Nauuo likes but is not the one we focus on. Probaility: j−wj+k. Lead to: fw[i−1][j+1][k].

The next visit displays a picture Nauuo doesn't like. Probaility: kj+k. Lead to: fw[i−1][j][k−1].

So, fw[i][j][k]=wj+kfw+1[i−1][j+1][k]+j−wj+kfw[i−1][j+1][k]+kj+kfw[i−1][j][k−1].

Let gw[i][j][k] be the expected weight of a picture Nauuo doesn't like with weight w after another i visits since SA=j and SB=k. The state transition is similar.

Note that i,j,k,m have some relation. In fact we can let f′w[i][j] be fw[m−i−j][SA+i][SB−j] (SA and SB are the initial ones here).

But up to now, we can only solve the easy version.

To solve the hard version, let's introduce a lemma:

fw[i][j][k]=wf1[i][j][k]Proof:

Obviously, this is true when i=0.

Then, suppose we have already proved fw[i−1][j][k]=wf1[i−1][j][k].

f1[i][j][k]=1j+kf2[i−1][j+1][k]+j−1j+kf1[i−1][j+1][k]+kj+kf1[i−1][j][k−1]=2j+kf1[i−1][j+1][k]+j−1j+kf1[i−1][j+1][k]+kj+kf1[i−1][j][k−1]=j+1j+kf1[i−1][j+1][k]+kj+kf1[i−1][j][k−1]fw[i][j][k]=wj+kfw+1[i−1][j+1][k]+j−wj+kfw[i−1][j+1][k]+kj+kfw[i−1][j][k−1]=w(w+1)j+kf1[i−1][j+1][k]+w(j−w)j+kf1[i−1][j+1][k]+wkj+kf1[i−1][j][k−1]=w(j+1)j+kf1[i−1][j+1][k]+wkj+kf1[i−1][j][k−1]=wf1[i][j][k]Also, a brief but not so strict proof: the increment in each step is proportional to the expectation.

So, we only have to calculate f1[i][j][k] (f′1[i][j]).

In conclusion:

f′1[i][j]=1 (i+j=m)f′1[i][j]=SA+i+1SA+SB+i−jf′1[i+1][j]+SB−jSA+SB+i−jf′1[i][j+1] (i+j<m)g′1[i][j]=1 (i+j=m)g′1[i][j]=SA+iSA+SB+i−jg′1[i+1][j]+SB−j−1SA+SB+i−jg′1[i][j+1] (i+j<m)If ai=1, the expected weight of the i-th picture is wif′1[0][0], otherwise, the expected weight is wig′1[0][0].

Last question: how to calculate the result modulo 998244353?

If you don't know how, please read the wiki to learn it.

You can calculate and store all the O(m) inverses at first, then you can get an O(n+m2+mlogp) solution instead of O(n+m2logp) (p=998244353 here).

Solution1172D - Nauuo and Portals

Idea: Sulfox

TutorialConsider this problem:

the person in (i,1) facing right is numbered ai, the person in (1,i) facing bottom is numbered bi. The person numbered pi has to exit the grid from (i,n), the person numbered qi has to exit the grid from (n,i).

The original problem can be easily transferred to this problem. And now let's transfer it into an (n−1)×(n−1) subproblem by satisfying the requirement of the first row and the first column.

If a1=p1 and b1=q1, you can simply do nothing and get an (n−1)×(n−1) subproblem.

Otherwise, you can set a portal consisting of two doors in (x,1) and (1,y) where ax=p1 and by=q1. Swap a1 and ax, b1 and by, then you will get an (n−1)×(n−1) subproblem.

Then, you can solve the problem until it changes into a 1×1 one.

This problem can be solved in O(n), but the checker needs O(n2).

Solution1172E - Nauuo and ODT

Idea: ODT

TutorialFor each color, we can try to maintain the number of simple paths that do not contain such color.

If we can maintain such information, we can easily calculate the number of simple paths that contain a certain color, thus get the answer.

For each color, we delete all nodes that belong to such color, thus splitting the tree into some clusters (here we define a "cluster" as a connected subgraph of the original tree).

By maintaining ∑cluster size2, we can get the number of simple paths that do not contain such color.

For each color we try to maintain the same information, add them together, and get the answer.

So now the problem is: a white tree

reverse the color of a node ( white <-> black )

output ∑cluster size2This problem can be solved by many data structures like top tree, link/cut tree or heavy path decomposition.

Let's use the link/cut tree for example.

You can maintain the size of each subtree and the sum of size2 of each node's sons. Link/cut one node with its father (choose a node as the root and make the tree a rooted-tree first) when its color changes. In this way, the real clusters are the ones that are still connected after deleting the top node of a cluster in the link/cut tree. Update ∑cluster size2 while linking/cutting.

 

link:

 

cut:

 

Solution1172F - Nauuo and Bug

Idea: rushcheyo

TutorialAt first, let's solve this problem in O(nnlogn−−−−−√).

Let's split our array into blocks by B integers, and let's find a function, f(x)= which value you will get at the end of the current block if you will start with x. With simple induction, you can prove that this function is a piece-wise linear, and it has O(B) segments, so you can build it iteratively in O(B2) time for each block, so the preprocessing took O(nB).

And to answer the query, you can keep the current value of x and then find with binary search by that piece-wise linear function the f(x) for the current block.

With a good choice of B, this solution will work in O(nnlogn−−−−−√).

Ok, but then how to solve it in O(nlog+qlog2)?

Lemma: each segment of this piece-wise linear function has length at least p.

You can prove it with simple induction.

And then, with this lemma, it is possible by two functions f(x) of size n and g(x) of size m find the new function h(x)=g(f(x)), in the O(n+m), you can do it with two pointers, similar to the previous iterative method, but adding a several points to the function each time, best way to understand it is to check the indendent solution :)

SolutionWe had prepared a problem similar to 1174F - Ehab and the Big Finale before that round, so we needed to prepare new problems in four days. It was in such a hurry that there are some imperfections in our round. Please accept our sincere apology.

Codeforces round #563 editorial

By mohammedehab2002, 4 years ago, In English1174A - Ehab Fails to Be ThanosIf all elements in the array are equal, there's no solution. Otherwise, sort the array. The sum of the second half will indeed be greater than that of the first half.

Another solution is to see if they already have different sums. If they do, print the array as it is. Otherwise, find any pair of different elements from different halves and swap them.

Code link: https://pastebin.com/FDXTuDdZ

1174B - Ehab Is an Odd PersonNotice that you can only swap 2 elements if they have different parities. If all elements in the array have the same parity, you can't do any swaps, and the answer will just be like the input. Otherwise, let's prove you can actually swap any pair of elements. Assume you want to swap 2 elements, a and b, and they have the same parity. There must be a third element c that has a different parity. Without loss of generality, assume the array is [a,b,c]. You'll do the following swaps:

Swap a and c: [c,b,a].Swap b and c: [b,c,a].Swap a and c: [b,a,c].In other words, you'll use c as an intermediate element to swap a and b, and it'll return to its original position afterwards! Since you can swap any pair of elements, you can always sort the array, which is the lexicographically smallest permutation.

Code link: https://pastebin.com/xhqGXLiu

Time complexity: O(nlog(n)).

1174C - Ehab and a Special Coloring ProblemLet's call the maximum value in the array max. Let the number of primes less than or equal to n be called p. Then, max≥p. That's true because a distinct number must be assigned to each prime, since all primes are coprime to each other. Now if we can construct an answer wherein max=p, it'll be optimal. Let's first assign a distinct number to each prime. Then, assign to every composite number the same number as any of its prime divisors. This works because for any pair of numbers (i,j), i is given the same number of a divisor and so is j, so if they're coprime (don't share a divisor), they can't be given the same number!

Code link: https://pastebin.com/tDbgtnC8

Time complexity: O(nlog(n)).

1174D - Ehab and the Expected XOR ProblemThe main idea is to build the prefix-xor of the array, not the array itself, then build the array from it. Let the prefix-xor array be called b. Now, al⊕al+1⋯⊕ar=bl−1⊕br. Thus, the problem becomes: construct an array such that no pair of numbers has bitwise-xor sum equal to 0 or x, and its length should be maximal. Notice that "no pair of numbers has bitwise-xor sum equal to 0" simply means "you can't use the same number twice". If x≥2n, no pair of numbers less than 2n will have bitwise-xor sum equal to x, so you can just use all the numbers from 1 to 2n−1 in any order. Otherwise, you can think of the numbers forming pairs, where each pair consists of 2 numbers with bitwise-xor sum equal to x. From any pair, if you add one number to the array, you can't add the other. However, the pairs are independent from each other: your choice in one pair doesn't affect any other pair. Thus, you can just choose either number in any pair and add them in any order you want. After you construct b, you can construct a using the formula: ai=bi⊕bi−1.

Code link: https://pastebin.com/0gCLC0BP

Time complexity: O(2n).

1174E - Ehab and the Expected GCD ProblemLet's call the permutations from the statement good. For starters, we'll try to find some characteristics of good permutations. Let's call the first element in a good permutation s. Then, s must have the maximal possible number of prime divisors. Also, every time the gcd changes as you move along prefixes, you must drop only one prime divisor from it. That way, we guarantee we have as many distinct gcds as possible. Now, there are 2 important observations concerning s:

Observation #1: s=2x∗3y for some x and y. In other words, only 2 and 3 can divide s. That's because if s has some prime divisor p, you can divide it by p and multiply it by 4. That way, you'll have more prime divisors.

Observation #2: y≤1. That's because if s=2x∗3y, and y≥2, you can instead replace it with 2x+3∗3y−2 (divide it by 9 and multiply it by 8), and you'll have more prime divisors.

Now, we can create dp[i][x][y], the number of ways to fill a good permutation up to index i such that its gcd is 2x∗3y. Let f(x,y)=⌊n2x∗3y⌋. It means the number of multiples of 2x∗3y less than or equal to n. Here are the transitions:

If your permutation is filled until index i and its gcd is 2x∗3y, you can do one of the following 3 things upon choosing pi+1:

Add a multiple of 2x∗3y. That way, the gcd won't change. There are f(x,y) numbers you can add, but you already added i of them, so: dp[i+1][x][y]=dp[i+1][x][y]+dp[i][x][y]∗(f(x,y)−i).

Reduce x by 1. To do that, you can add a multiple of 2x−1∗3y that isn't a multiple of 2x∗3y, so: dp[i+1][x−1][y]=dp[i+1][x−1][y]+dp[i][x][y]∗(f(x−1,y)−f(x,y)).

Reduce y by 1. To do that, you can add a multiple of 2x∗3y−1 that isn't a multiple of 2x∗3y, so: dp[i+1][x][y−1]=dp[i+1][x][y−1]+dp[i][x][y]∗(f(x,y−1)−f(x,y)).

As for the base case, let x=⌊log2(n)⌋. You can always start with 2x, so dp[1][x][0]=1. Also, if 2x−1∗3≤n, you can start with it, so dp[1][x−1][1]=1. The answer is dp[n][0][0].

Code link: https://pastebin.com/N8FRN9sA

Time complexity: O(nlog(n)).

1174F - Ehab and the Big FinaleLet depa be the depth of node a and sza be the size of the subtree of node a. First, we'll query the distance between node 1 and node x to know depx. The idea in the problem is to maintain a "search scope", some nodes such that x is one of them, and to try to narrow it down with queries. From this point, I'll describe two solutions:

HLD solution:Assume that your search scope is the subtree of some node u (initially, u=1). How can we narrow it down efficiently? I'll pause here to add some definitions. The heavy child of a node a is the child that has the maximal subtree size. The heavy path of node a is the path that starts with node a and every time moves to the heavy child of the current node. Now back to our algorithm. Let's get the heavy path of node u. Assume its other endpoint is node v. We know that a prefix of this path contains ancestors of node x. Let the deepest node in the path that is an ancestor of node x be node y (the last node in this prefix). I'll now add a drawing to help you visualize the situation.

 

So, recapping, u is the root of your search scope, v is the endpoint of the heavy path starting from u, x is the hidden node, and y the last ancestor of x in the heavy path. Notice that y is lca(x,v). Now, we know that dist(x,v)=depx+depv−2∗depy. Since we know depx, and we know depv, we can query dist(x,v) to find depy. Since all nodes in the path have different depths, that means we know y itself!

Another way to find yNow, if depx=depy, x=y, so we found the answer. Otherwise, we know, by definition, that y is an ancestor of x, so it's safe to use the second query type. Let the answer be node l. We can repeat the algorithm with u=l! How long will this algorithm take? Note that l can't be the heavy child of y (because y is the last ancestor of x in the heavy path), so szl≤⌊szy2⌋, since it's well-known that only the heavy child can break that condition. So with only 2 queries, we managed to cut down at least half of our search scope! So this algorithm does no more than 34 queries (actually 32 under these constraints, but that's just a small technicality).

Code link: https://pastebin.com/CM8QwdUf

Centroid decomposition solution:As I said, assume we have a search scope. Let's get the centroid, c, of that search scope. If you don't know, the centroid is a node that, if removed, the tree will be broken down to components, and each component's size will be at most half the size of the original tree. Now, c may and may not be an ancestor of x. How can we determine that? Let's query dist(c,x). c is an ancestor of x if and only if depc+dist(c,x)=depx. Now, if c is an ancestor of x, we can safely query the second node on the path between them. Let the answer be s, then its component will be the new search scope. What if c isn't an ancestor of x? That means node x can't be in the subtree of c, so it must be in the component of c's parent. We'll make the component of c's parent the new search scope! Every time, the size of our search scope is, at least, halved, so the solution does at most 36 queries.

Code link: https://pastebin.com/hCNW5BfQ

Codeforces Round #562 — Editorial

By 300iq, history, 4 years ago, In English1169A - Circle MetroStraightforward simulation. Check the intended solutions:

Simulation1169B - PairsOne of x,y is obviously one of a1,b1. For example, let's fix who is x from the first pair. Then you need to check that there exists some y such that all pairs that don't contain x, contain y. For this, you can remember in the array for each value how many pairs that don't contain x contain this value, and then you need to check that in the array there exists some value that is equal to the number of pairs left.

This solution

1169C - Increasing by ModuloLet's check that the answer to the problem is ≤x.

Then, for each element, you have some interval (interval on the "circle" of remainders modulo m) of values, that it can be equal to.

So you need to check that you can pick in each interval some point, to make all these values non-decrease.

You can do it with greedy! Each time, let's take the smallest element from the interval, that is at least the previously chosen value.

And after this, let's make the binary search on x.

So we have the solution in O(nlogm).

This solution

1169D - Good TripleLemma: there are no strings without such x,k of length at least 9.

In fact, you just can write brute force to find all "good" strings and then realize that they all are small.

Ok, so with this you can just write some sort of "naive" solution, for each l find the largest r, such that l…r is a "good" string, and then add n−r to the answer. You can do it in 9⋅9⋅n or in 9⋅n, as I do in my solution. Check it out!

1169E - And ReachabilityLet's calculate goi,k — the smallest j, such that aj contains bit k, which is reachable from i.

How to recalculate it? Let lasti,k is the smallest j>i, such that aj contains bit k.

Then, I claim that goi,k is equal to the i or to the min(golasti,j,k) for all bits j that ai contains.

Why? Because if you go from i to some number, which has bit j in the intersection, it is useless to go to the number which is not equal to lasti,j, because from lasti,j you can go to all numbers that have bit j and that positioned farther.

So in O(nlog) you can calculate all these values, and then to answer the query you can check that there exists some bit j in ay such that gox,j≤y.

This solution

1168D - Anagram PathsOk, let's make some useless (ha-ha, in fact not) observation at first, obviously, all leaves must have the same depth.

Now, I will define the criterion for the tree to be good.

Let f(v,x) be the largest number of characters x that contained on edges of some path from vertex v to the leaf, and lenv be the length of a path from v to the leaf.

Lemma: tree is good iff for each vertex ∑f(v,x)≤lenv.

Obviously, if the tree is good ∑f(v,x)≤lenv for each vertex because else you just don't have enough "space" in the subtree of the vertex to contain all required characters.

Why is it criterion? If for each vertex it is satisfied, from the root you can find some suitable characters on the edges from it, and then it is easy to see that you can restore the children by induction.

Ok, with this knowledge how to solve the problem? Maybe some spooky tree data structures will help us?...

Yup, you can do it with the "Dynamic tree DP technique" with HLD, and you will get the solution in O(nlog2n) even for not a binary tree.

But it is not very easy to realize it :)

Let's remember that all leaves must have the same depth, so I will give you another Lemma!

Lemma: if you will "compress" all vertices with one son in the tree, where all leaves have an equal depth, then the depth of this tree will be O(n−−√).

Why? let ai be the number of vertices on the depth i, then ai≥ai−1 for each i≤h as each vertex at the depth i−1 should have at least one son, and you have ∑ai=n, so there are O(n−−√) distinct values among them, so almost all (without some O(n−−√) values) i has ai=ai−1 (which means that all vertices at the depth i−1 has exactly one son).

So with this knowledge, you can "compress" the tree as I described, and after each query just go up from the end of the changed edge and recalculate the DP. Of course, each edge now will have several characters on it, so you should maintain a counter in each edge, but it is more a realization aspect.

Finally, here is the solution

1168E - Xor PermutationsIf xor of all elements of the array is not zero, then the answer is "Fou".

Now let's assume that you have two permutations p,q and when xored they are producing an array a.

I will show that it is possible to change any two elements ai,aj to elements ai⊕x,aj⊕x with some transformation of the given permutations.

Let's change ai,aj to ai⊕x,aj⊕x.

Let's find such t, that ai⊕qi=pt.

If t is equal to i or i+1, then you can make some swaps to "fix" the array, to make it satisfy ai=pi⊕qi for all i.

Now you have:

pt,qt,at at position tpi,qi,ai at position ipj,qj,aj at position jLet's make some swaps at these positions to transform it to:

pi,qj,at at position tpt,qi,ai at position ipj,qt,aj at position jNow, after you make these transition, you will have pi⊕qi=ai, and now you need to "fix" positions t and j, and just process recursively.

Lemma: this thing will end in O(n) operations.

______________________________________________________________________________________

Proof: Let's assume that at some two moments you have pt coincided with some pt earlier, let's check the first that moment.

For simplicity of the proof, let's assume that numbers are moving like that:

pt,qi,ai at position tpi,qj,at at position ipj,qt,aj at position j(So pi's are constant, and ai's are changing now. Obviously, it is equivalent to the previous transformation)

Now, assume, that you had numbers:

pt,qt,at at position tpi,qx,ay at position i (1)pj,qy,aj at position j (2)and then, you will make one transformation, and everything will go to:

pt,qx,ay at position tpi,qy,at at position ipj,qt,aj at position jAfter that, before you will be stuck into described earlier equality:

pt,qx,ay at position tpi,qv,au at position ipj,qu,aj at position jAnd after swapping with tpi,qu,ay at position i (3)pj,qx,aj at position j (4)Let's look at (1), (2) and (3), (4)

From (1), (2), we can see qy=pi⊕qx⊕ay⊕pj⊕ajFrom (3), (4), we can see qu=pi⊕ay⊕pj⊕qx⊕ajSo qy=qu, but u≠y, so it is a contradiction, because q is a permutation.. _________________________________________________________________________________

Ok, using these operations it is pretty simple to get an arbitrary array. Just start with 0,0,…,0 (two equal permutations). And then make ai=bi,ai+1=ai+1⊕(ai⊕bi), at the end you will have one element rest and it will be good because initially xor was zero.

My solution.

Codeforces Round #561 (Div. 2) Editorial

By Ari, history, 4 years ago, In EnglishThank you for participating! We hope you liked our problems.

1166A - Silent ClassroomFirst, note that we can solve the problem for each starting letter independently, because two students whose name starts with a different letter never form a chatty pair.

How do we solve the problem when all the students' names start with the same letter? We claim that it's best to split as evenly as possible. If one classroom has a students, and the other has b students with a>b+1, then by moving one of the students from the first classroom into the second we remove a−1 chatty pairs from the first classroom and create b new chatty pairs in the second, for a net result of (a−1)−b>0 chatty pairs removed. So in the best splitting we have |a−b|≤1, meaning we split as evenly as possible.

Then, if cnta denotes the number of students whose name starts with a, we will split them into a classroom containing ⌊cnta2⌋ students and one containing ⌈cnta2⌉ students. So the total number of chatty pairs among students whose name starts with a is

(⌊cnta2⌋2)+(⌈cnta2⌉2)The expression is the same for the other letters in the alphabet, and adding them all up gives us our answer. We can also solve the problem without determining what the best splitting is. If, for each starting letter, we try all the possible number of students to send into the first classroom, and choose the one that gives the minimal x, then we will only have to do O(n) checks in total, which is more than fast enough to solve the problem.

Complexity: O(n).

1166B - All the Vowels PleaseFirst, which boards could we feasibly fill with characters satisfying that every row and column contains one vowel at least once? Well, if we have a board with less than 5 rows, then each column contains less than 5 characters, so we cannot have every vowel on each column, and we can't fill the board. Similarly, we can't fill a board with less than 5 columns.

Ok, so say now that we have a board with at least 5 rows and at least 5 columns. Can we fill it? Yes we can! It's enough to fill it by diagonals, as shown in the following picture:

Now we can easily solve the problem. If n⋅m=k, then n must divide k and m=kn. So we can iterate over all possible n from 5 to k, check whether n divides k and in that case, check whether m=kn is at least 5. If this works for at least one value of n then we can fill the n⋅m board by diagonals as shown before, and obtain our vowelly word by reading the characters row by row. If we don't find any values of n satisfying this, then no vowelly word exists.

Complexity: O(k).

1166C - A Tale of Two LandsFormally, the condition for the legend being true reads

min(|x−y|,|x+y|)≤|x|,|y|≤max(|x−y|,|x+y|)Now, it is possible to characterize when this condition happens through casework on the signs and sizes of x and y, but this can be tricky to do right. However, there is a neat trick that allows us to solve the problem without any casework. What happens if we change x into −x? The values of |x| and |y| stay the same, while |x−y| and |x+y| will swap values. This means that the pair {x,y} works if and only if {−x,y} works. Similarly we can switch the sign of y. This means that we can replace x and y by their absolute values, and the original pair works if and only if the new one works.

If x≥0 and y≥0 then the condition becomes |x−y|≤x,y≤x+y. The upper bound obviously always holds, while the lower bound is equivalent by some simple algebra to

x≤2y and y≤2xSo the problem reduces to counting the number of pairs {x,y} with |x|≤2|y| and |y|≤2|x|. To solve this we now take the absolute values of all the ai and sort them into an array b1≤b2≤⋯≤bn. The answer to the problem is the number of pairs (l,r) with l<r and br≤2bl. For each fixed l we calculate the largest r that satisfies this condition, and just add r−l to the answer, as the values l+1,l+2,…,r are all the ones that work for this l. We can either do a binary search for the best r at each l, or calculate the optimal r's for all of the l's in O(n) using two pointers. Either way, our final complexity is O(nlogn) as this is the time required to sort the array.

Complexity: O(nlogn)1166D - Cute SequencesWe will first deal with determining when the sequence doesn't exist. To do this, we place some bounds on the values of xn. If we choose all values of the ri to be equal to 1 then we can calculate that xn=2n−2(x1+1). Reciprocally if we choose all ri to be equal to m then we find xn=2n−2(x1+m). All other values give something inbetween, so we get

2n−2(x1+1)≤xn≤2n−2(x1+m)Therefore, if b doesn't lie on any of the intervals [2n−2(a+1),2n−2(a+m)] for some value of n, then it is impossible for b to be a term of an m-cute sequence starting at a. This can be checked naively in O(log(1014)) since there are this many relevant values of n. We can convince ourselves that all values in these intervals are feasible through some experimentation, so we now turn to the more difficult problem of actually constructing a sequence.

First, notice that we can rearrange the definition of the sequence as follows:

xn=x1+x2+⋯+xn−1+rn=(x1+⋯+xn−2)+xn−1+rn=(xn−1−rn−1)+xn−1+rn=2xn−1+rn−rn−1Now, we can try to find a pattern. We see that x2=a+r1, x3=2a+r1+r2, x4=4a+2r1+r2+r3, and in general it would seem that.

xn=2n−2a+2n−3r2+2n−4r3+⋯+2rn−2+rn−1+rnThis is actually very easy to prove inductively using xn=2xn−1+rn−rn−1: All coefficients double from one term to the next, but we substract rn−1 once, so that coefficient becomes 1 instead. Now we can also find an explicit solution: Write b as 2n−2(a+k)+r where r<2n−2, and consider the binary representation r=dn−3dn−4…d0 of r. Then choosing ri=k+dn−1−i (where d−1=0) works, because

2n−2a+2n−3(k+dn−3)+⋯+2(k+d1)+(k+d0)+k=2n−2a+(2n−3+2n−4+⋯+2+1+1)k+2n−3dn−3+2n−4dn−4+⋯+d0=2n−2a+2n−2k+r=2n−2(a+k)+rAlternatively, after getting the formula, we can iterate on i from 2 to k and greedily choose the values of ri to be as large as we can without exceeding b. This can be easily shown to work using that the coefficients are consecutive powers of two.

Both of these approaches can be implemented in O(log(1014)) per query.

Complexity: O(qlog(1014))1166E - The LCMs Must be LargeWe denote by lcmA the lcm of all elements in a collection A. Also, denote by Di and Si the collections that Dora and Swiper bought on day i, respectively.

First, when can we say for sure that the values of ai cannot exist? Well, suppose that Di=Sj for some i and j. Then we also have Dj=Si, so if the condition were true we would have

lcmDi>lcmSi=lcmDj>lcmSj=lcmDiWhich is of course impossible. What now? We can actually make our impossibility condition a bit stronger by noticing that lcmB≤lcmA whenever B is a collection contained in A, which happens because lcmB actually divides lcmA. Then, if the stores Dora bought from on day i are completely disjoint from the stores Dora bought from on day j, then Dj would be completely contained in Si and vice-versa, so

lcmDi>lcmSi≥lcmDj>lcmSj≥lcmDiWhich is again a contradiction.

Ok, any two days must have a common store for the statement to be possible, so what? The remarkable fact here is that this is the only condition we need to check: i.e., the solution exists if and only if the sets of stores that Dora visited on days i and j intersect for all i and j.

How do we get a valid solution? We will take m different prime numbers p1,p2,…,pm and set ai to be the product of pj for all the j's such that Dora visited store i on day j. Then pj is a divisor of ai if and only if Dora visited store i on day j.

Now proving that this works is easy: We know that on day i, Dora bought an integer from a store that she also visited on day j, and this number must be a multiple of pj. So lcmDi=p1p2…pm for all i. On the other hand, Si contains no multiples of pi, because they are all in Di. So the lcm of Si is strictly smaller.

Now we just need to check that any two days have a common store, which can be done in O(nm2) by checking each pair of days and determining for each i whether Dora visited both stores on day i in O(n). You can achieve a slight speedup if you check this using a bitset, but this wasn't necessary to solve the problem.

Complexity: O(nm2).

1166F - Vicky's Delivery ServiceLet G be the graph with cities as vertices and roads as edges. Note that the edges originally in G can be regarded as m queries of the "add edge" type, so we will just describe a solution that can handle m+q queries of any type.

We need a way to capture the idea of going through two roads of the same color in a row. To do this, consider a graph G∗ with the same vertices as G, in which vertices u and v are connected by an edge if uw and vw are edges of the same color for some vertex w. Then any path in this graph corresponds to a double rainbow in the original. However, this doesn't solve the problem yet, because of the condition that the final edge of a double rainbow can be of any color.

To help in solving this issue, consider n sets Sv such that Sv has all of the G∗-connected components of both v and any neighbor of v. Then we can see that we have a double rainbow from u to v if and only if the connected component of u is in Sv (either we reach v directly, or we reach one of its neighbors and then use our final edge to go to v). So as long as we can mantain these sets, we have a O(logn) time way to answer queries of the second type.

Now we need to deal with adding edges. To do this, we will store the connectivity of G∗ using a DSU. When we connect two connected components in G∗, we do the merges from small to large. If we merge component b into component a then for each vertex u in component b and every neighbor v of u we remove b from Sv and insert a instead. By merging from small to large we guarantee that each vertex changes component at most O(logn) times, and thus we also update Sv through the edge uv at most O(logn) times. Each update is just two O(logn) operations, so over all updates this amortizes to O((m+q)log(n)2) (because we have O(m+q) edges), plus O(nlogn) for actually moving the vertices.

There's an easy to fix, but important note, which is that the number of edges in G∗ can be quadratically large. However, we can check that for each edge uv of color x that we add, we only need to add two edges to G∗. Namely, if u′ and v′ are neighbors of u and v respectively through an edge of color x, then it is enough to add edges uv′ and u′v. (If one of u′ or v′ doesn't exist then we just don't add the corresponding edge). We can store these x-colored neighbors of each vertex in sets which have total size at most m+q, so we can find in O(logn) which updates we need to perform, and we perform a constant number of updates per added edge.

Complexity: O(nlog(n)+(m+q)log(n)2), or O((n+m+q)log(n)) using hash tables.

Codeforces Round #560 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1165A - Remainder

Idea: vovuh

Tutorial1165A - RemainderAs we can see, last x digits of the resulting number will be zeros except the n−y-th. So we need to change all ones to zeros (if needed) among last x digits, if the position of the digit is not n−y, and change zero to one (if needed) otherwise. It can be done with simple cycle.

Solution1165B - Polycarp Training

Idea: MikeMirzayanov

Tutorial1165B - Polycarp TrainingAfter sorting the array, we can maintain the last day Polycarp can train, in the variable pos. Initially it is 1. Let's iterate over all elements of the sorted array in non-decreasing order and if the current element ai≥pos then let's increase pos by one. The answer will be pos−1.

Solution1165C - Good String

Idea: BledDest

Tutorial1165C - Good StringThe following greedy solution works: let's iterate over all characters of the string from left to right, and if the last block of two consecutive characters in the resulting string is full, just add the current character to the resulting string, otherwise add this character if it is not equal to the first character of the last block. And don't forget about the parity of length (remove last character if the length is odd).

Solution1165D - Almost All Divisors

Idea: MikeMirzayanov

Tutorial1165D - Almost All DivisorsSuppose the given list of divisors is a list of almost all divisors of some x (in other words, suppose that the answer exists). Then the minimum divisor multiplied by maximum divisor should be x. This is true because if we have a divisor i we also have a divisor ni. Let's sort all divisors and let x=d1⋅dn.

Now we need to check if all divisors of x except 1 and x are the permutation of the array d (check that our answer is really correct). We can find all divisors of x in O(x−−√), sort them and compare with the array d. If arrays are equal then the answer is x otherwise the answer is -1.

Solution1165E - Two Arrays and Sum of Functions

Idea: vovuh

Tutorial1165E - Two Arrays and Sum of FunctionsLet's use contribution to the sum technique to solve this problem. How many times the value ai⋅bi will occur in the answer? It will occur i⋅(n−i+1) times. Okay, now we can see that for each position i we have the value ai⋅bi⋅i⋅(n−i+1). The only non-constant value there is bi. So let vali=ai⋅i⋅(n−i+1). Note that you cannot take this value modulo 998244353 here because then you can't compare these values correctly. We should pair the minimum bi with the maximum vali, the second minimum with the second maximum and so on. So, let's sort the array val and the array b, reverse the array b and calculate the sum of values vali⋅bi (don't forget about modulo here!).

Solution1165F1 - Microtransactions (easy version)

Idea: BledDest

Tutorial1165F1 - Microtransactions (easy version)Let's iterate over all possible answers. Obviously, this value is always in the range [1,2⋅∑i=1nki]. The first day when Ivan can order all microtransactions he wants will be the answer. How to check if the current day ansd is enough to order everything Ivan wants?

If we had several sale days for some type of microtransaction (of course, we can use only such days that are not greater than the fixed last day ansd), let's use the last one, it is always not worse than some of the previous days. Then let's iterate over all days from 1 to ansd and do the following: firstly, let's increase our balance by one burle. Then let's try to order all microtransactions for which the current day is the last sale day (and pay one burle per copy). If we are out of money at some moment then just say that we should order all microtransactions that remain in this sale day during the last day for two burles per copy. It is true because it does not matter which types will remain because this day is the last sale day for all of these types. So, after all, we had some remaining microtransactions that we cannot buy during sales, and the current balance. And the current day is good if the number of such microtransactions multiplied by two is not greater than the remaining balance.

Solution1165F2 - Microtransactions (hard version)

Idea: BledDest

Tutorial1165F2 - Microtransactions (hard version)The main idea of this problem is the same as in the easy version. The only thing we should replace is the search method. Replacing linear search with binary search leads to reducing time complexity from O(n2) to O(nlogn). And it is obvious that we can apply binary search here because if we can order all microtransactions during some day d then we can order all of them during day d+1 (even using the answer for d days and doing nothing during day d+1).

Solution

Codeforces Round #559 — editorial

By isaf27, 4 years ago, translation, In English1159A - A pile of stonesLet's consider an array a, there ai=1, if si="+" and ai=−1, if si="-".

Let's notice, that the answer ≥ak+1+…+an for all k. It is true, because after making the first k operations the number of stones will be ≥0, so at the end the number of stones will be ≥ak+1+…+an.

Let's prove, that the answer is equal to ans=max0≤k≤n(ak+1+…+an). We proved that it should be at least that number of stones. It's easy to see, that if we will take a1+…+an−ans stones at the beginning, the pile will be non-empty each time when Vasya should take a stone and at the end, the number of stones will be equal to ans.

Complexity: O(n).

Jury solution: 54047380

1159B - Expansion coefficient of the arrayLet our array be a k-extension. All inequalities k⋅|i−j|≤min(ai,aj) for i≠j can be changed to k≤min(ai,aj)|i−j|. For all i=j inequalities are always true, because all numbers are non-negative.

So, the maximum possible value of k is equal to the minimum of min(ai,aj)|i−j| for all i<j. Let's note, that min(ai,aj)|i−j|=min(ai|i−j|,aj|i−j|). So, we need to take a minimum of ai|i−j| for all i≠j. If we will fix i the minimum value for all j is equal to aimax(i−1,n−i) and it is reached at the maximum denominator value, because ai≥0.

So the answer is equal to min1≤i≤naimax(i−1,n−i) and it can be simply found by linear time.

Complexity: O(n).

Jury solution: 540474161159C - The Party and SweetsLet's note, that for all 1≤i≤n,1≤j≤m is is true, that bi≤gj, because bi≤aij≤gj. So max(b1,b2,…,bn)≤min(g1,g2,…,gm). If it is not true, the answer is −1.

Let's prove, that if max(b1,b2,…,bn)≤min(g1,g2,…,gm) the answer always exists and let's find it. Let's make all aij=bi. Let's note, that bi=min(ai1,ai2,…,aim). But in this case maximums in each column can be wrong. To make them correct we should place 1≤j≤m into the j-th column of the table a the number gj. To make the sum as small as possible we want to place all gj into the row with maximal bi. If we will make it the minimal in this row will be equal min(g1,g2,…,gm). But the number b for this row is equal to max(b1,b2,…,bn). So, if max(b1,b2,…,bn)=min(g1,g2,…,gm) the answer is equal to (b1+b2+…+bn)m+g1+g2+…+gm−max(b1,b2,…,bn)m. But if max(b1,b2,…,bn)<min(g1,g2,…,gm) we should place some of the gj in the other row. Let's place g1 into the row there bi is second maximum in the array b. It's easy to check in this case, that all minimums, maximums will be correct in this case. In this case the answer is equal to (b1+b2+…+bn)m+g1+g2+…+gm−max(b1,b2,…,bn)(m−1)−max2(b1,b2,…,bn).

So:

If max(b1,b2,…,bn)>min(g1,g2,…,gm) the answer is −1;If max(b1,b2,…,bn)=min(g1,g2,…,gm) the answer is (b1+b2+…+bn)m+g1+g2+…+gm−max(b1,b2,…,bn)m;If max(b1,b2,…,bn)<min(g1,g2,…,gm) the answer is (b1+b2+…+bn)m+g1+g2+…+gm−max(b1,b2,…,bn)(m−1)−max2(b1,b2,…,bn).Maximum, second maximum in the array b, minimum in the array g and the sums in the arrays b and g can be easily computed in the linear time. So, we have a linear time solution.

Complexity: O(n+m).

Jury solution: 540474561159D - The minimal unique substringLet's define the value a=n−k2. We know, that (kmod2)=(nmod2) so a is integer number. Let's construct this string s: a symbols "0", 1 symbol "1", a symbols "0", 1 symbol "1", … Let's prove, that this string satisfy the conditions. Let's note, that it's period is equal to (a+1).

Let the substring t be unique. Let's look at the only l for this substring. But if l>a+1, then l−(a+1) satisfy (as the left border of the string t occurrence), if l≤n−(a+|t|) then l+(a+1) satisfy (because the period of s is equal to (a+1), so shift on (a+1) don't change anything). So l≤a+1 and n−(a+|t|)<l, because in other case l can't be the only. So n−(a+|t|)<l≤a+1 so n−(a+|t|)<a+1 so n−(a+|t|)≤a so n−2⋅a≤|t| so k≤|t|.

As the example of the unique substring of length k we can take t=sa+1…sn−a.

Complexity: O(n).

Bonus: How to solve the problem without condition, that (kmod2)=(nmod2)? For what k the answer exists?

Jury solution: 540474871159E - Permutation recoveryNote that if there are indices i<j for which the values nexti and nextj are defined and i<j<nexti<nextj are satisfied, then there is no answer. Suppose that this is not true and there exists permutation p1,p2,…,pn. Note that since j<nexti we get that pi>pj (otherwise nexti would not be the minimum position in which the number is greater than pi). But then pj<pi<pnexti, so nextj is not the minimum position for j. Contradiction.

Now we prove that if for any pair of indices i<j such condition is not satisfied, then the permutation always exists.

First, let's get rid of nexti=−1. If nexti=−1 let's say nexti=i+1. Note that for any pair i<j the condition i<j<nexti<nextj is still not satisfied (since nexti=i+1 cannot take part in such inequality).

Consider the following rooted tree with n+1 vertices: the vertex with index n+1 will be the root, and the ancestor of the vertex with index i will be nexti. Since it is always i<nexti we get the rooted tree.

Let's run the depth first search algorithm (dfs) from the vertex n+1 in this tree. In this case, we will bypass the sons of each vertex in order from the smaller number to the larger one. Let's make some global variable timer=n+1. Each time we come to the vertex i, we will make pi=timer and reduce timer by 1. Note that p1,p2,…,pn will form a permutation of numbers from 1 to n.

We prove that this permutation is the answer.

First of all, for all i due to nexti was the ancestor of i, we'll go there early and so pnexti>pi. Let i<j<nexti. We need to prove that we will come to the vertex j later than to the vertex i. Note that then the vertex nexti will be a descendant of j in the tree, because if you start go from j by next, you cannot jump over nexti, because otherwise there is an index x, for which the inequality i<x<nexti<nextx is satisfied. But such pair of indexes i, x cannot exist. We'll get to j later because the son of nexti, which is the ancestor of j will be ≥j, and thus >i.

That is, we understood what is the criterion of the answer and learned how to quickly build an answer, if this criterion is satisfied. But we still need to check that this criterion is satisfied. This can be done by some simple linear algorithm. But we will do this: let's make an algorithm for constructing the answer (without checking the criterion) and find the permutation p. Now, using the stack and the standard algorithm, we find the nexti values for it. If they match the given nexti, then we have found the answer, otherwise, let's say that there is no answer. If the criterion is satisfied we will find the answer and if not satisfied after checking p we will say there are no answers.

Complexity: O(n) time and memory.

Jury solution: 540475131159F - Winding polygonal lineLet's describe the algorithm, which is always finding the answer:

Let's find any point Ai, lying at the convex hull of points A1,A2,…,An. We don't need to construct the convex hull for this, we can simply take the point with the minimal y. This point will be the first in the permutation.

Let's construct the polygonal line one by one. Let the last added point to the polygonal line be Api. The point Api should always lie at the convex hull of remaining points and Api (at the beginning it is true). If si= "L" the next point be the most right point (sorted by angle) and if si= "R"the next point be the most left point (sorted by angle) from the remaining. This is the picture for this:

It is easy to see, that the new point lies at the convex hull. The next rotation at the point Api+1 will be to the right side, because if si= "L" all other points lies from the left of the vector ApiApi+1−→−−−− and if si= "R" all other points lies from the right of the vector ApiApi+1−→−−−−.

To take the most left or right point, sorted by the angle from the remaining we will simply take minimum or maximum using the linear search. The point X lies to the right of the point Y from the point Api, if ApiX−→−−×ApiY−→−−>0. The operation × is vectors multiply.

Complexity: O(n2).

Jury solution: 540475611158E - Strange deviceThe solution will consist of two parts.

1 part

Let's divide all points into sets with equal distance to the vertex 1. To do this, we will do the following algorithm. How to understand what set of points lies at a distance ⌊n2⌋ from the top of 1? Let's fill d with zeros and make d1=⌊n2⌋ for the first operation and d1=⌊n2⌋−1 for the second operation. After that we will make 2 operations with such d arrays. Those vertices whose bulbs did not light up during the first operation lie at a distance of >⌊n2⌋. Those that caught fire at the first, but did not catch fire at the second operation lie at a distance of ⌊n2⌋. Finally, those who caught fire during the second operation lie at a distance of <⌊n2⌋. Generalize this idea. We will store the set of distances for which we already know the set of vertices at lying such distance from 1 (we will call them good distances). Initially it is 0 (only vertex 1 at distance 0) and n (empty vertex set at distance n). We will also store between each pair of adjacent good distances l1<l2 those vertices for which the distance is greater than l1, but less than l2. Now let's iterate over pairs of adjacent good distances l1<l2. Take m=⌊l1+l22⌋. Now the sets of vertices lying at distances greater than l1, but less than m, exactly m and more than m, but less than l2 can be obtained using the two operations described at the beginning. With this action, we make m a good distance. To do this in parallel for several pairs of adjacent good distances just iterate over pairs with even numbers and odd ones. Then as each of the cases would not be adjacent pairs, you can make two common operations. Thus, with the help of 4 operations, we will make the middle between all pairs of adjacent good distances also a good distance. If we divide in half, then for ⌈logn⌉ of divisions we will make all distances good. At this part we will spend 4⌈logn⌉ operations.

2 part

For each vertex at the distance of l>0 let's find the index of the ancestor vertex lying at a distance of l−1 (which is the only one). Suppose we want to do this for only one distance l>0. Note that if we make dv=1 for all v∈S, for some subset of vertices S lying at a distance l−1, and for all other vertices 0, then among the vertices at a distance l will include those whose ancestor belongs to S. Then let's for all i such that 2i<n choose S as the set of vertices v such that v−1 contains i-th bit in binary notation and lies at a distance of l−1. Then, for each vertex at a distance of l, we will know all the bits in the binary representation of its ancestor, that is, we will find this number. This process can also be done in parallel, if we take the distance l, giving the same remainder of dividing by 3. Then, since these distances are not close, they will not interfere with each other. At this part we will spend 3⌈logn⌉ operations.

In total we get a solution using 7⌈logn⌉ operations.

Complexity: O(nlogn).

Number of operations: 7⌈logn⌉.

Jury solution: 540476261158F - Density of subarraysWe have some c-array a. Let's find the criterion, that any c-array of length p is its subsequence. To check that c-array b is a subsequence of a, we should iterate all elements of b and take the most left occurrence of this symbol in a, starting from the current moment. Because any c-array should be a subsequence of a on each step we can take the symbol the most left occurrence of such is the most right. Let's denote the positions, which we have taken on each step l1,l2,…,lp. So if we will look to the array a[li+1…li+1], in this arrays each of the c symbols exists and the symbol ali+1 occurs exactly 1 time. Let's name such array "critical block". So the density of a≥p, if a is the concatenation of p consecutive critical blocks and some other symbols at the end.

Let's note, that the density of any array of length n won't be more than k=nc. It is obvious, because in any critical block at least c symbols.

Let's find dpt,i as the number of subsequences of the array prefix a[1…i] that contain the position i, which are divided into exactly t critical arrays (and no other characters). We will consider it for all 1≤t≤k and 1≤i≤n.

Let's first understand how to get an answer from these values, and then show how to calculate them. If we denote by ft the number of subsequences whose density is ≥t, then ft=∑i=1ndpt,i⋅2n−i. Next, note that the number of density subsequences exactly t is anst=ft+1−ft.

Here are 2 different ways to calculate dpt,i:

1) denote by numi,j the number of subsequences of array a[i…j] that contain j and are critical. Then numi,j=∏x=1,x≠ajc(2cntx,i,j−1), where cntx,i,j — is the number of characters x among a[i…j]. Then we can calculate num for O(n2c). To speed up this calculation to O(n2) we will fix i and increase j by 1, supporting ∏x=1c(2cntx,i,j−1). Then in such a product 1 multiplier will be changed and it can be recalculated by O(1). To get numi,j, you simply divide the supported product by 2cntaj,i,j−1.

Then note that dpt,i=∑j=0i−1dpt−1,j⋅numj+1,i (iterate over j — the end of the previous critical block). This allows us to calculate the values of dp in time O(n2k).

2) We will need an auxiliary dinamical programming values ui,t,mask (where mask is a mask of characters, that is 0≤mask<2c), which means the number of ways to choose a subsequence from the prefix a[1…i], in which there will be first t critical blocks and then several characters that are in mask, but each character from mask will be at the several symbols at least once. Then dpt,i=ui−1,t−1,2c−1−2ai, which follows from the definition.

Conversion formulas are as follows: ui,t,mask=ui−1,t,mask, if ai is not contained in mask and ui,t,mask=2ui−1,t,mask+ui−1,t,mask−2ai, if ai is contained in mask (if you take ai in the subsequence and if not). For mask=0 it is true, that ui,t,0=ui−1,t,0+dpI,t.

These formulas can be used to calculate the values of u and dp by iterating i in increasing order over time O(nk2c). The i parameter can be omitted from memory because the recalculation is only from the previous layer.

In total, we get 2 ways to calculate dp working for O(n2k) and O(nk2c). Recall that k=nc. That is, our solutions work at the time O(n3c) and O(n22cc). If c>logn, then let's run the first solution and it will work for O(n3logn), otherwise if c≤logn and 2cc≤nlogn, so let's run the second solution, which will then work, too, in O(n3logn) time.

If we carefully implement these 2 solutions and run them depending on c, we get a solution with O(n3logn) complexity and it is working fast enough.

Complexity: O(n3logn) or O(n2c⋅min(n,2c)).

Jury solution: 54047665

Codeforces Round #558 (Div. 2) Editorial

By Kuroni, history, 4 years ago, In EnglishHello everyone, this is the editorial for Codeforces Round #558 (Div. 2). I hope you enjoy the problem as well as I did!

1163A - Eating Soup

Author: ArguteOnAir

Tutorial1163A - Eating SoupWe can prove that the first one to leave the circle does not make any difference to our answer. So after trying some tests, you will probably come up with an idea of selecting the cats that are sitting right between the other two to be the prior ones to leave because, in this way, those vacancies will definitely be useful for creating more separate groups.

Therefore, if m−1<⌊n2⌋, the answer is m since each cat to leave (after the first cat) increases the number of groups. Otherwise, if m+1≥⌊n2⌋, each independent cat to leave decreases the number of groups so the answer is n−m. Summarily, the answer is min(m,n−m). Be careful with m=0.

Complexity: O(1).

Implementation1163B2 - Cat Party (Hard Edition)

Author: Shirone

Tutorial1163B2 - Cat Party (Hard Edition)We can iterate over all streaks and check for each streak if we can remove one day so that each color has the same number of cats.

There are 4 cases where we can remove a day from the streak to satisfy the condition:

There is only one color in this streak.All appeared colors in this streak have the occurrence of 1 (i.e. every color has exactly 1 cat with that color).Every color has the same occurrence of cats, except for exactly one color which has the occurrence of 1.Every color has the same occurrence of cats, except for exactly one color which has the occurrence exactly 1 more than any other color.All of these four conditions can be checked using counting techniques.

Complexity: O(n).

Implementation1163C2 - Power Transmission (Hard Edition)

Author: GreymaneSilverfang

Tutorial1163C2 - Power Transmission (Hard Edition)First, we will divide the problem into several parts: 1) construct the wires, 2) remove duplicates, and 3) count the number of pairs that intersect.

The first part is relatively simple: note that each wire is simply a line that goes through two distinct points (poles) on the Oxy plane. Suppose this line goes through point A(x1,y1) and point B(x2,y2), then it can be described by the equation ax−by=c where a=y1−y2, b=x1−x2, c=y1x2−y2x1.

For step two, we will simplify the equation for each line by dividing each coefficient by their greatest common divisor. Now each equation uniquely identifies a line, and vice versa - so we can sort the wires by their values of a, b, and c; then remove adjacent duplicates.

The final part of the solution also makes use of this sorted list. As any pair of lines on the plane must intersect unless they are parallel, we only need to count the number of parallel pairs and subtract these from the total number of pairs. These are the pairs with the same slope (i.e. same value of a and b), and they already are next to each other in our list. We now iterate over these "blocks" of parallel lines and count the number of pairs each block contributes — a block of size s gives s(s−1)2 pairs.

Complexity: O(n2logn).

Implementation1163D - Mysterious Code

Author: Kuroni

Tutorial1163D - Mysterious CodeFirstly, we will find the maximal value of f(c′,s)−f(c′,t) via dynamic programming. Denote 'dp[i][ks][kt]' as the maximal value of the said value when replacing the first i-th character of c, and the KMP state for the replaced sub-code to be ks and kt. The maximal value of f(c′,s)−f(c′,t) for the whole code will lie among all end states dp[n][ks][kt] for all values of ks and kt.

Complexity: O(|c|⋅|s|⋅|t|).

Implementation1163E - Magical Permutation

Author: Kuroni

Tutorial1163E - Magical PermutationThe idea here is iterate x and check if it is possible to create a magical permutation for the current x we are iterating through.

An observation to be made is that if it is possible to create a magical permutation P from 0 to 2x−1, then it must be possible to express each integer from 0 to 2x−1 as the xor value of elements in one subset of S. This is because 0 is represented as the xor value of the empty subset of S. Because of that, every element to the left of 0 in P is also the xor value of one subset of S, and so is every element to the right of 0 in P.

Because of that, we first check that if we can create every integer from 0 to 2x−1 using only the xor values of every subset of S. This is possible by creating a basis for integers from 0 to 2x−1 — x integers such that each integer from 0 to 2x−1 is the xor value of a subset of these x integers — from S using Gaussian elimination.

Now, if it is possible to create such a basis for integers from 0 to 2x−1 using only elements of S, is it possible to create a magic permutation then? Recall that each integer from 0 to 2x−1 corresponds to the xor value of a subset of the basis, or in other words, corresponds to a bitmask of the basis. We can also narrow down the original condition, such that the xor value of any two consecutive elements belongs to the basis; or in other words, the corresponding bitmask of any two consecutive elements in the magical permutation differs by exactly 1 bit. The problem now becomes creating a permutation of integers from 0 to 2x−1 such that any two consecutive elements in this permutation differs by 1 bit, and then convert this permutation to a magical permutation using the created basis. It turns out that we can always do this using Gray codes, although DFS works just as well.

It also turns out that the basis for integers from 0 to 2x−1 does not exceed 2x−1, we can sort S and create the basis along with checking the aforementioned condition.

Complexity: O(nlogn+nlogMAX+MAX) if Gray codes are used, or O(nlogn+nlogMAX+MAXlogMAX) is DFS is used instead, where MAX denotes the maximum value of elements in S.

ImplementationImplementation with DFS1163F - Indecisive Taxi Fee

Author: Kuroni

Tutorial1163F - Indecisive Taxi FeeFirstly, we will find and trace out one shortest path from vertex 1 to vertex n in the graph. Let's call this path main path, and we will number the edges on the main path as E1, E2, .., Ek respectively. We will also call all of the other edges that does not belong to this main path candidate edges.

During the procedure, we can also calculate the shortest path from 1 to every vertex u, and the shortest path from every vertex u to n. After calculating all of these values, we can now query the shortest path from 1 to n that must pass through each edge (u,v) in either direction.

We have a few observations to be made here:

Observation 1: Apart of the vertices belong to the main path, for each vertex u, the shortest path from 1 to u uses a prefix of the main path. More formally, there exists an index lu (0≤lu≤k) such that the shortest path from 1 to u must use the edges E1, E2, ..., Elu at its beginning.

Using the same analogy, we can say that for each vertex u, the shortest path from u to n uses a suffix of the main path; or in other words, there exists an index ru (1≤ru≤k+1) such that the shortest path from u to n must use the edges Eru, Eru+1, ..., Ek at its end. Note that if lu=0, the shortest path from 1 to u does not use a prefix of the main path, and if ru=k+1, the shortest path from u to n does not use a suffix of the main path.

For every vertex v that belongs to the main path however, we will set lv=t,rv=t+1, where t is the position where v appears on the main path.

What does this imply? This implies that the shortest from 1 to n that passes through u does not rely on the edges Elu+1, Elu+2, ..., Eru−1.

Observation 2: For each candidate edge (u,v), the shortest path from 1 to n passing through this edge in the order u→v does not rely on the edges Elu+1, Elu+2, ..., Erv−1. This is because, the shortest path passing through this order u→v will consist of the shortest path from 1 to u, the edge (u,v), and the shortest path from v to n. With the same analogy, the shortest path from 1 to n passing through this edge in the order v→u does not rely on the edges Elv+1, Elv+2, ..., Eru−1.

Using the observations, we can now answer the queries.

There are three cases that we should consider when answering the shortest path with the modified edge:

The modified edge is a candidate edge (i.e. it does not belong to the main path): we will take the minimal of the main path and the shortest path that goes through this modified edge.The modified edge belongs to the main path, and its value decreases: the new shortest path is still the main path, and its new value is the old value subtracting the difference between the original and the modified weight of that edge.The modified edge belongs to the main path, and its value increases: the new shortest path is either one of these two options:The main path, its new value being the old value adding the weight-difference of the modified edge.The shortest path from 1 to n that does not use the modified edge. This shortest path must use a candidate edge, since we cannot reuse the main path anymore; more specifically, this shortest path uses a candidate edge that does not rely on the modified edge. To get the value of this option, recall in observation 2 that for each candidate edge (u,v) and with its direction, we know the range of edges belonging to the main path that this candidate edge does not rely on. Hence, we can use a segment tree to manage and query the shortest path that does not rely on this edge.Complexity: O((m+n)logn).

Implementation

Forethought Future Cup Final Round Tutorial

By Lewin, history, 4 years ago, In EnglishHere's the tutorial. Code can be found in this link (more will be added there soon): https://www.dropbox.com/sh/xwxn3zrl1icp3i2/AACtYSdYH0KlTEdVgCFFgPrYa?dl=0

Zoning Restrictions Again1162A - Zoning Restrictions AgainThis problem can be done by processing the restrictions one by one. Let's keep an array a of length n, where the i-th value in this array represents the maximum possible height for house i.

Initially, we have processed no restrictions, so we fill ai=h for all i.

For a restriction k, we can loop through the elements j between lk and rk and update aj=min(aj,xk). This is because the new house must be at most height xk, and we know previously it had to be at most aj, so we take the min of the two.

After processing all restrictions, we can greedily choose the height of the i-th house to be ai. The answer is the sum of a2i for all i.

The time complexity for processing one restriction is O(n), so the total time complexity is O(nm).

Double Matrix1162B - Double MatrixThere are too many possibilities to try a brute force, and a dp solution also might be too slow (e.g. some bitmask dp). There is a solution that uses 2sat but that is a bit hard to code so I won't go into details in this tutorial. Let's instead look at a greedy solution.

First, let's swap ai,j with bi,j if ai,j>bi,j. At the end, for every i and j, we have ai,j≤bi,j. We now claim that there is a solution if and only if this configuration is valid. We can guess this intuitively and by trying a few examples, or we can do the proof below.

<start of formal proof for why this works>

If this configuration is valid, then obviously this solution works, so we're done with this side of the implication.

The other way is to show if there exists a solution, then this configuration is also valid. We do this by contradiction. We show if this configuration is not valid, then there is no solution. If this configuration is not valid, without loss of generality, let bi,j≥bi,j+1. bi,j must go somewhere in the matrix and it needs to be before either bi,j+1 or ai,j+1, but we have ai,j+1≤bi,j+1≤bi,j, so we have nowhere that we can put bi,j, thus this shows there is no solution. We can also extend this argument to the other cases.

<end of proof for why this works>

So, given the above claim, the solution is simple. Do the swaps so aij≤bij. Then, check if the two matrices are increasing, and print "Possible" if so and "Impossible" otherwise. The runtime is O(n2) to read in the input, do the swaps, then do the checks that the matrices are valid.

Hide and Seek1147A - Hide and SeekAnother way to phrase this problem is to count the number of ordered pairs (p,q) that satisfy the following

|p−q|≤1There exists a number i such that p doesn't appear in x[0…i] and q doesn't appear in x[i+1…n].There are only O(n) pairs that satisfy the first condition, so we can loop over all these pairs and try to efficiently check the second condition.

If p=q, this pair is valid if p doesn't appear in x, so we can just check this for all 1…n directly with just one sweep through x.

For p,q that differ by exactly one, we can check that the first occurrence of p occurs after the last occurrence of q. This is because we can start at p, wait until the last question about q has been asked, and then swap to p. This is guaranteed to avoid all of Bob's questions.

To answer this question efficiently, let's precompute the first and last occurrence of each number. This can be done by sweeping through the array once. Thus, checking if the condition is satisfied is just checking that first[p]>last[q].

The total time complexity is O(k) for pre-computation, and O(n) for answering all the questions.

Chladni Figure1147B - Chladni FigureLet's brute force the value of k and check if it's possible to rotate the image by k to get the same image. We can do this by iterating through all segments (a,b), and checking that (a+k,b+k) is a segment (the endpoints taken modulo n if needed).

This gives an O(nm) solution, however, you can notice that we only need to check divisors of n rather than all values from 1 to n. This is because the set of segments (a,b),(a+k,b+k),(a+2k,b+2k),… is exactly equal to (a,b),(a+gcd(n,k),b+gcd(n,k)),(a+2gcd(n,k),b+2gcd(n,k)),…. Thus, this take O(m⋅d(n)), where d(n) denotes the number of divisors of n, which is fast enough to pass this problem.

There is also a faster linear time solution. We can reduce this to a problem of finding the largest period of a string. For every point, we can sort the length of the segments starting from that point (length in this case refers to clockwise distance). We also add some null character to denote a point. For instance, the first sample case's string might start like 2,−1,−1,4,8,10,−1,… that represent the points from 1 to 3. Such a string can be computed in O(mlogm) time. Then, after finding this string, we just want to check the period is bigger than 1. Let w be the length of the string. We can find this by concatenating the string to itself, then use z-algorithm to check if there is any is any index i from 1 to w−1 that is at least w.

Thanos Nim1147C - Thanos NimThe main claim is that if a player is forced to reduce the minimum number of stones over all piles, then they lose. Intuitively, every time a player reduces the minimum, the other player has a move that doesn't reduce the minimum, and if a player isn't forced to reduce the minimum, they have a move that will force the other player to reduce the minimum.

More formally, let m be the minimum number of stones in a pile, and let x be the number of piles with m stones. Alice can win if and only if x≤n/2. Let's call the positions where Alice can win "winning positions", and all other positions "losing positions"

To see why this works, we need to show from a winning position, we can reach some losing position, and if we are at a losing position, we can only reach winning positions.

If we are at a winning position, there are at least n/2 piles that have strictly more than m stones, so we can choose any arbitrary subset of them and reduce them to m stones. This is now a losing position.

If we are at a losing position, no matter what we do, we must include a pile of size m in our chosen subset. If m is zero, this means we have no available moves. Otherwise, the minimum will strictly decrease, but only at most n/2 piles (from the piles that we chose) can reach that new minimum. Thus, losing positions can only reach winning positions.

The solution is then as follows. Find the min of the array and find the frequency of the min. Print "Alice" if the frequency is less than or equal to n/2, otherwise, print "Bob". The time complexity is O(n). Alternatively, you can sort and check the index 0 and index n/2 are the same for a short three line solution.

Palindrome XOR1147D - Palindrome XORSince the leading character of s is a "1", then that means a<2m−1 and 2m−1≤b<2m. Let's fix the length of a as k. I'll describe a more general solution, so there might be simpler solutions that work for this specific problem.

Let's make a graph with n+k+2 nodes. The first n nodes represent the n bits of b, and the next k nodes represent the k bits of a. The last two nodes represent a 0 node and 1 node (which we will explain later). We want to find the number of ways to color the graph with two colors 0 and 1 such that they satisfy some conditions.

Let's draw two different types of edges 0-edges and 1-edges. If two nodes are connected by a 0-edge, then that means they must be the same color. If two nodes are connected by a 1-edge, then that means they must be a different color.

We will draw some edges as follows:

Draw a 1 edge between the 0 node and 1 node to represent they must be different colors.Draw a 0 edge between bi and bn−i−1 to represent the palindrome conditions (similarly we can do this for a).For the i-th bit, if si is "1", draw a 1 edge between ai and bi (if i>k, we instead draw an edge from bi to 1). If si is "0", then draw a 0 edge between ai and bi. If si is "?", then don't draw any edges, since there are no explicit constraints.Now, we want to count the number of valid colorings. We want to split the graph into a two colors, which is a bipartite graph. We want all edges that cross the bipartition to be 1 edges and all edges within the same bipartition to be 0 edges.

To count this, we first collapse all connected components of 0 edges, then check if the remaining 1 edges form a bipartite graph. If there is a non-bipartite graph, return 0 immediately, since this means it's impossible to fulfill the conditions. Otherwise, let C be the number of connected components. We add 2C−1 to our answer. The reason we subtract 1 is that the component containing the 0 and 1 node is fixed to be colored 0, but for other components, we are free to color the components in either of two ways.

There are n different lengths to try, each of which take a linear amount of time to get the count, so the overall time complexity is O(n2).

Rainbow Coins1147E - Rainbow CoinsLet's define a new question that takes a list of coins t1,t2,…,tk, and returns the answers about all adjacent pairs of coins in this list (e.g. the answers to (t1,t2),(t2,t3),(t3,t4),…. We can do this in two questions, one question is (t1,t2),(t3,t4),…, and the other is (t2,t3),(t4,t5),…, and we can interleave the results to get the answer for all adjacent pairs in order.

We show how to use only three questions of this type to get the answer (so the total number of questions in the original problem is 6).

First, let's ask about all adjacent pairs in 1,2,…,n. This splits the coins into contiguous groups of the same color. Let's take some arbitrary representative from each group and put them in a line, so we now have a problem where all adjacent coins in the line are different colors.

Now, we ask two more questions about adjacent pairs. One for coins 1,3,5,… and one for coins 2,4,6,….

This is now enough to reconstruct the color of all the coins. WLOG, coin 1 is red, and coin 2 is blue. We know coin 3 cannot be blue (since it must be different from coin 2), and we compared it with coin 1, so we know if it is either red or green. We can repeat this for all coins in sequence.

Zigzag Game1147F - Zigzag GameI first got the idea for this problem from this problem: https://www.codechef.com/problems/HAMILG. There might be an easier version of the problem on a bipartite graph out there somewhere also. Anyways, the solution for the problem is conceptually simple. Find a matching of the graph, and then you can play according to the matching. You don't even need to remember which vertices you've seen before, since the main idea is if your opponent can make a move, then you can too.

The same idea can be extended to this problem. The intuition is to find some matching to show that Bob can always win. It's not clear how to find such a matching directly, so let's look at what properties the matching needs.

Let's call nodes 1 to n the "left" side of the bipartite graph and nodes n+1 to 2n the "right" side

Without loss of generality, suppose Alice choose "increasing" and she placed her token somewhere on the left side.

Now, let's consider what properties a matching needs. Let's take any two edges in our matching, one that connects nodes (w,x) (w is on the left, x is on the right), and the other connects (y,z) (y is on the left, z is on the right).

We want it to be the case that if it is legal for Alice to move from x to y, then it is legal for Bob to move from y to z. This way, Bob always can respond by playing according to the matching.

Let's see what this means in terms of edge weights. If Alice can move from x to y, then that means edge(x,y)>edge(w,x), since the last edge traversed was (w,x) and Alice is increasing. We want it to be the case that edge(x,y)>edge(w,x) implies that edge(x,y)>edge(y,z). Thus, the matching is bad if and only if there are two edges in the matching (w,x) and (y,z) such that edge(x,y)>edge(w,x) and edge(x,y)<edge(y,z).

We can solve this with stable marriage. We call the bad case an instability, which happens if x prefers y over w and y prefers x over z. We can construct the preference list of the nodes as follows. For each node on the left side, create a preference list of nodes on the right in decreasing order of weight. For each node on the right side, create a preference list of nodes on the left in increasing order of weight.

We now find any stable marriage in O(n2) time. It is guaranteed that one exists and has no instabilities. Thus, we've found a matching that guarantees Bob's win.

As a followup, can you devise a strategy that guarantees Alice can beat Bob if Bob makes a non-optimal move?

Codeforces Round #556 Editorial

By mnbvmar, 4 years ago, In EnglishThis is the preliminary version of editorial. Expect bugs. Some changes might happen!

1150A. Stock Arbitraging

Tutorial1150A - Арбитраж акцийThe main observation is that we always want to buy shares as cheaply as possible, and sell them as expensively as possible. Therefore, we should pick the lowest price at which we can buy shares smin=min(s1,s2,…,sn), and the highest price at which we can sell the shares bmax=max(b1,b2,…,bm). Now, we have two cases:

If smin<bmax, it's optimal to buy as many shares and possible in the morning and sell them all in the evening. We can buy as many as ⌊rsmin⌋ shares and gain bmax−smin bourles profit on each of them. Therefore, the final balance is r+⌊rsmin⌋(bmax−smin).If smin≥bmax, we're not gaining any profit on the shares and therefore we shouldn't care about trading stocks at all. The final balance is then r.The solution can be therefore implemented in O(n+m) time. However, the constraints even allowed brute-forcing the seller, the buyer and the amount of stock we're buying in O(nmr) time.

Note that many programming languages have routines for finding the minima/maxima of the collections of integers: e.g. min_element in C++, Collections.min in Java, or min in Python. This should make the code shorter and quicker to write.

Code1150B. Tiling Challenge

Tutorial1150B - Испытание замощениемNotice that there is only one orientation of the wooden piece (and this is the orientation depicted in the statement). Moreover, we can notice the following fact:

Take any (untiled) topmost cell of the board. If there is any correct tiling of the board, this cell must be covered by the topmost tile of the piece.

The fact is pretty obvious — there is simply no other way to cover the cell.

Having that, it's straightforward to implement an O(n4) solution: while the board isn't fully covered, take any topmost untiled cell and try to cover it with a piece. If it's impossible, declare the failure. If it's possible, lay the piece and repeat the procedure. We can lay at most O(n2) pieces, and we're looking for the topmost cell in O(n2) time. This gives us O(n4) running time.

While this is enough to solve the task, one can also notice that we don't have to seek the whole board in search of the cell. In fact, we can do a single scan through the board in row-major order, and as soon as we find any uncovered cell, we try to cover it by a wooden piece. This allows us to implement the solution in O(n2) time.

Code1150C / 1149A. Prefix Sum Primes

Tutorial1150C - Простые префиксные суммыThere are at least a couple of correct solutions I had in mind. Let me present the one I find the most straightforward, which doesn't even require implementing any sieve.

If all the numbers on the tiles are equal, we have no choice but to output the only possible permutation. In the remaining cases, we'll show that the following solution is optimal:

Start with 2 and 1.Use all remaining 2s.Finish with all remaining 1s.It's easy to see that we generate 2 and all odd numbers between 3 and ∑ni=1ai as the prefix sums. Notice now that each prime is either 2 or an odd number greater than or equal to 3. Therefore, using the construction above we construct all possible prime prefix sums we possibly can — and so the construction is optimal. The solution can be implemented easily in O(n) time.Code1150D / 1149B. Three Religions

Tutorial1150D - Три религииFor our convenience, construct a two-dimensional helper array N where N(i,c) is the location of the first occurrence of character c in the Word of Universe on position i or later (or ∞ if no such character exists). This array can be created in a straightforward in O(26⋅n) time, by iterating the word from the end to the beginning.

Example. Consider the Word of Uniwerse equal to abccaab. The helper array looks as follows:

Actually, for our purposes it's easier to set ∞=n (in our example, n=7) and also consider additional links from indices n and n+1 to index ∞=n. Why? We'll later need the index of the first occurrence of some character after some location p. If this p already happens to be ∞ (n, as we already established), we can easily see that no requested occurrence exists:

Let's now try to answer each query in O(2503) time. We can do it using dynamic programming: let D(n1,n2,n3) be the length of the shortest prefix of the Word of Universe that contains the disjoint occurrences of the prefix of length n1 of the first religion's description, the prefix of length n2 of the second religion's description, and the prefix of length n3 of the third religion's description. Each state can be evaluated in constant time by checking for each religion i∈{1,2,3}, what the prefix length would be if the last character of the prefix is a part of the i-th religion's description. (We use the helper array N to speed up the search.)

How to write the state transitions? For each i∈{1,2,3}: chop the last character of the i-th description's prefix, find the shortest prefix of the Word of Universe containing all three descriptions, and then reappend this last character. We can do that using our helper array:

D(n1,n2,n3)=min⎧⎩⎨N(D(n1−1,n2,n3)+1,description1[n1])N(D(n1,n2−1,n3)+1,description2[n2])N(D(n1,n2,n3−1)+1,description3[n3])if n1≥1,if n2≥1,if n3≥1.Now, if the lengths of the descriptions are ℓ1, ℓ2, and ℓ3, respectively, then the embedding of these descriptions as distinct subsequences exists if and only if D(ℓ1,ℓ2,ℓ3)<∞=n.

However, due to the nature of queries, we can do a single update in O(2502) time: if we drop a character, we don't need to recompute any states; if we add a character to the i-th description, we only need to recompute the states with ni equal to the length of the description — and there are at most 2512 of them! This allows us to solve the problem in O(q⋅2502) time.

Code1150E / 1149C. Tree Generator™

Tutorial1150E - Генератор Деревьев™Take any rooted tree and its description. For any vertices u, v, let h(v) be its depth in the tree, and d(u,v)=h(u)+h(v)−2h(lca(u,v)) be the distance between u and v.

Consider the traversal of the tree represented by the description. Let's say we're processing the parentheses one by one each second, and let's set μ(t) be the current depth after t seconds. Moreover, let tu and tv be the moments of time when we're in vertices u,v, respectively (there might be multiple such moments; pick any). Therefore, h(u)=μ(tu) and h(v)=μ(tv).

Assume without the loss of generality that tu<tv and consider the part of the description between the tu-th and tv-th second. What is the shallowest vertex we visit during such traversal? As the description represents a depth-first search of the tree, it must be lca(u,v). Therefore, h(lca(u,v))=mintl∈[tu,tv]μ(tl). It follows that d(u,v)=maxtl∈[tu,tv](μ(tu)+μ(tv)−2μ(tl)).

Eventually, the diameter is equal to maxu,vd(u,v)=maxtu≤tl≤tv(μ(tu)−2μ(tl)+μ(tv)). This leads to a slow O(n) solution for computing a single diameter without constructing the tree: consider the parentheses one by one, and maintain the current depth and maximum values of μ(a), μ(a)−2μ(b) and μ(a)−2μ(b)+μ(c) for a≤b≤c on the prefix. However, we still need to be able to process the updates quicker than in linear time.

It turns out we can maintain a segment tree. Each node will maintain some information about the substring of the description. Note that such substring doesn't have to describe the whole tree, and so the number of opening and closing parentheses doesn't have to match and it can happen that we're at a negative depth when following the description.

We'll hold the following information about the substring. We assume everywhere that a≤b≤c:

δ (the final depth, might be non-zero),maxμ(a), max(−2μ(b)), max(μ(a)−2μ(b)), max(−2μ(b)+μ(c)), max(μ(a)−2μ(b)+μ(c)).Note that the values in the second point describe all the contiguous parts of the formula μ(a)−2μ(b)+μ(c).It's now pretty straightforward to combine the informations about two neighboring substrings into a single information about the concatenation of the substrings. Note for example that δ=δL+δR and maxμ(a)=max{maxLμ(a), maxRμ(a)+δL}. This allows to maintain the segment tree over the description and process the single character replacement in O(logn) time. Therefore, we can process each query in O(logn) time, and solve the whole task in O(n+qlogn) time.

Notably, square-root decomposition isn't much slower in this task; O(n−−√) per query should pass if you aren't deliberately trying to write as slow code as possible.

Code1149D. Abandoning Roads

Tutorial1149D - Отказ от дорогLet's partition the edges of the graph into two classes: light (weight a) and heavy (weight b). Let's now fix a single settlement p as the location of the parliament house, and consider how the path between settlements 1 and p could look like.

Lemma 1. If there is a path between two settlements u, v consisting of light edges only, then they will be connected using the light edges only in any minimum spanning tree.

Proof. Consider the Kruskal minimum spanning tree algorithm (which can produce any minimum spanning tree depending on the order we consider the edges with equal weight). After we process all light edges, settlements u and v will be connected.

Lemma 2. Consider the connected components in the graph with heavy edges removed. In the original graph, a path can be a part of the minimum spanning tree if and only if there is we don't leave and then reenter any of the components.

Proof. If we leave and then reenter any connected component, there are two vertices u, v in a single connected component (that is, connected by a light path in the original graph) that has at least one heavy edge on the path in between. Lemma 1 asserts that it's impossible. However, if no such situation happens, it's straightforward to extend the selected path to a minimum spanning tree — first add all possible light edges, then all possible heavy edges so that the graph becomes a spanning tree.

This leads us to an (inefficient) O(2nmlog(2nm)) solution: find the connected components in the graph with light edges only. We want now to find the shortest path between 1 and all other vertices that doesn't revisit any component multiple times. In order to do so, create a graph where each state is of the following format (mask of components visited so far,current vertex). This information allows us to check if we don't reenter any previously visited component. After we do that, we run Dijkstra's shortest path algorithm from vertex 1. The shortest path between vertices 1 and p can be found in the state first visiting vertex p.

The beautiful thing now is that the algorithm can be sped up by the following greedy observation:

Lemma 3. Consider any component of size 3 or less. It's not optimal to leave and then reenter this component even if we don't explicitly forbid this.

Proof. We need to use at least two heavy edges to leave and then reenter the component, and this costs us 2b or more. However, as the component has at most three vertices, the path between any pair of vertices costs at most 2a. As a<b, it's always more optimal to take the path inside the component.

Therefore, we can simply ignore all components of size 3 or less. As we now need to remember the components having at least 4 vertices, the number of states drops down to O(2n/4m). This immediately allows us to finish the solution in a number of ways:

Implement the vanilla Dijkstra algorithm on the state graph — time complexity O(2n/4mlog(2n/4m)).Notice that the edges of the graph have only two weights (a and b) and therefore the priority queue can be implemented using two queues — time complexity drops to O(2n/4m).CodeChallenges1149E. Election Promises

Tutorial1149E - Предвыборные обещанияLet's get straight to the main lemma:

Lemma. For any vertex v, let's define the level of v as M(v)=mex{M(u)∣v→uis an edge} where mex is the minimum-excluded function. Moreover, for any t∈N, let X(t) be the xor-sum of the taxes in all cities v fulfilling M(v)=t; that is, X(t)=⨁{hv∣M(v)=t}. The starting party loses if and only if X(t)=0 for all t's; that is, if all xor-sums are equal to 0.

Proof. Let's consider any move from the position in which all xor-sums are zero. If we're holding the convention in the city v, then we must decrease the amount of taxes in this city. Note however that there is no direct connection from v to any other city u having the same level as v, as M(v) is the smallest integer outside of the set {M(u)∣v→uis an edge}. Therefore, there is exactly one tax value changing at level M(v), and thus the value X(M(v)) must change. As it was zero before, it must become non-zero.

Now consider any configuration where some xor-sums are non-zero. Let t be the highest level at which X(t)>0. We want to hold the election in a selected city at level t. Which one? Notice that no city at a single level is connected to each other, and therefore we can only afford to pick one city and strictly decrease its tax. This is equivalent to the game of Nim where each city corresponds to a single stack of stones. We perform a single optimal move in this game: pick a city and decrease the tax in the city by a non-zero amount of bourles, leading to the position where the new xor-sum of the taxes at this level X′(t) is equal to zero. We also need to take care of zeroing all X(l)'s for l<t. This is however straightforward: for each l<t, pick a single city vl fulfilling at level l directly reachable from v (there must be one from the definition of M(v)), and alter the value of tax in order to nullify X(l).

The proof above is actually constructive and allows us to compute a single winning move in O(n+m) time.

As a small bonus: if you're into advanced game theory, you can come up with the lemma above without much guesswork. One can compute the nimbers for the state where there are no taxes anywhere except a single city v where the tax is equal to hv, and it turns out to be equal to ωM(v)⋅hv where ω is the smallest infinite ordinal number. Moreover, it's not that hard to see that the nimber for the state where there are more taxed cities is a nim-sum of the nimbers corresponding to the states with only one taxed city. This all should quite naturally lead to the lemma above.

Code

Codeforces Round #555 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1157A - Reachable Numbers

Idea: BledDest

Tutorial1157A - Reachable NumbersThe key fact in this problem is that the answer is not very large (in fact, it's not greater than 91). Why is it so? Every 10 times we apply function f to our current number, it gets divided by 10 (at least), and the number of such divisions is bounded as O(logn).

So we can just do the following: store all reachable numbers somewhere, and write a loop that adds current number n to reachable numbers, and sets n=f(n) (we should end this loop when n already belongs to reachable numbers). The most convenient way to store reachable numbers is to use any data structure from your favourite programming language that implemenets a set, but, in fact, the constrains were so small that it was possible to store all reachable numbers in an array.

Solution1157B - Long Number

Idea: BledDest

Tutorial1157B - Long NumberLet's find the first digit in a that becomes strictly greater if we replace it (obviously, if there is no such digit, then the best solution is to leave a unchanged). In the optimal solution we will replace this digit and maybe some digits after this. Why is it so? It is impossible to make any of the previous digits greater (since we found the first digit that can be replaced with a greater one).

Then let's analyze all digits to the right of it. We should not replace any digit with a lower digit (because it is better not to replace it and all digits to the right of it at all), but there's nothing wrong with replacing any other digits.

So, the segment we need to replace begins with the first digit that can become greater after replacing (and includes this digit) and goes to the right until the first digit that becomes less after replacing (and this digit is excluded).

Solution1157C1 - Increasing Subsequence (easy version)

Idea: MikeMirzayanov

Tutorial1157C1 - Increasing Subsequence (easy version)In this problem the following greedy solution works: let's maintain the last element of the increasing sequence we got and on each turn choose the minimum element greater than this last element among the leftmost and the rightmost. Such turns will maximize the answer. You can find details of implementation in the authors solution.

Solution1157C2 - Increasing Subsequence (hard version)

Idea: MikeMirzayanov

Tutorial1157C2 - Increasing Subsequence (hard version)The solution of the previous problem works for this problem also. Almost works. What if the leftmost element is equal the rightmost element? Which one should we choose? Let's analyze it. If we take the leftmost element then we will nevertake any other element from the right, and vice versa. So we can't meet this case more than once because after meeting it once we can take only leftmost elements or only rightmost elements. The only thing we should understand is which of these two cases is better (take the leftmost element or take the rightmost element). To do it we can just iterate from left to right and calculate the number of elements we can take if we will take the leftmost element each time. If we cannot take the current element then just stop the cycle. And do the same thing for the rightmost element and take the best case.

Solution1157D - N Problems During K Days

Idea: MikeMirzayanov

Tutorial1157D - N Problems During K DaysI suppose there are some solutions without cases handling, but I'll describe my own, it handling approximately 5 cases.

Firstly, let nn=n−k(k+1)2. If nn<0 then the answer is "NO" already. Otherwise let's construct the array a, where all ai are ⌊nnk⌋ (except rightmost nn%k values, they are ⌈nnk⌉). It is easy to see that the sum of this array is nn, it is sorted in non-decreasing order and the difference between the maximum and the minimum elements is not greater than 1. Let's add 1 to a1, 2 to a2 and so on (this is what we subtract from n at the beginning of the solution). Then if nn≠k−1 or k=1 then this answer is correct. Otherwise we got some array of kind 1,3,…,ak. How do we fix that? For k=2 or k=3 there is no answer for this case (you can try to prove it or try to find answers for cases n=4,k=2 and n=8,k=3). Otherwise k>3 and we can subtract one from a2 and add it to ak and this answer will be correct (this also can be proved with some easy formulas).

Time complexity: O(k).

Solution1157E - Minimum Array

Idea: vovuh

Tutorial1157E - Minimum ArrayLet's maintain all elements of the array b in a set that allows multiple copies of equal elements (std::multiset for C++). Then let's iterate from left to right over the array a and try to minimize the current element in array c. This order will minimize the resulting array by lexicographical comparing definition. So for the i-th element ai let's find the minimum element greater than or equal to n−ai in the set because n−ai will give us remainder 0, n−ai+1 will give us remainder 1 and so on. If there is no greater or equal element in the set then let's take the minimum element of the set and take it as a pair for ai otherwise let's take this greater or equal element and remove it from the set.

Time complexity: O(nlogn).

Solution1157F - Maximum Balanced Circle

Idea: MikeMirzayanov

Tutorial1157F - Maximum Balanced CircleLet's realize what we need to construct the minimum balanced circle with heights from l to r. We can represent it as l,l+1,…,r−1,r,r−1,…,l+1. As we can see, we need one occurrence of l and r and two occurrences of all other heights from l+1 to r−1. How can we find the maximum balanced circle using this information? We can find the maximum by inclusion segment of neighboring heights with at least two occurrences using the array of frequencies cnt, sorted array of unique heights b and two pointers technique. For the current left border l we should increase r (initially it is l+1 and it is an excluded border) while br−br−1=1 and cntbr≥2. Then for the current left and right borders we can try to extend the segment to the left if bl−bl−1=1 and to the right if br+1−br=1 and try to update the answer with the the current segment (and go to the next segment). There may be some corner cases like n=1 or all cnt are 1, but you can avoid them if you will implement the solution carefully. There are almost no corner cases in my solution, you can see details of implementation in authors code.

Time complexity: O(nlogn) or O(n) (depends on sorting method).

Solution1157G - Inverse of Rows and Columns

Idea: vovuh

This is the comment about the quadratic solution. Thank you so much for mentioning this fact, STommydx!

Tutorial1157G - Inverse of Rows and ColumnsThe first observation: if we have an answer where the first row is inverted, we can inverse all rows and columns, then the matrix will remain the same, and the first row is not inverted in the new answer. So we can suppose that the first row is never inverted. Note that this will be true only for slow solution.

The second observation: if we consider a sorted matrix, its first row either consists only of '0's, or has at least one '1' and then all other rows consist only of '1's. This observation can be extended to the following (one user wrote a comment about it and I pinned the link to it above) which can improve time complexity of the solution a lot: in the sorted matrix either the first row consists only of '0's, or the last row consists only of '1's (the corner case is n=1, but for n=1 we can obtain both answers).

So what should we do with these observations? I will explain a slow solution, a faster solution can be obtained by mirroring one of cases of this one. Let's iterate over the number of '0's in the first row. Let it be cnt. Then the first cnt elements of the first string should be '0's, and all others should be '1's. We can do it by inverting the columns with elements '1' among first cnt elements of the first row and columns with elements '0' among remaining elements. So, it's case handling time!

The first case (when cnt<m) is pretty easy. We have to check if all rows from 2 to n that they consist only of '0's or only of '1's (and if some row consists of '0's then we should invert it). If it is true then we found the answer. Otherwise the first row consists only of '0's. So we have to find the "transitional" row (the row with some '0's on the prefix and '1's on the suffix or vice versa). If the number of such rows among all rows from 2 to n is greater than 1 then this configuration is bad. If the number of such rows is 1 then let idx be the index of this row. Then we should inverse all rows above it consisting only of '1's and all rows consisting only of '0's below it. And we have to check if the current row is really transitional. We know that its sum is neither 0 nor m so there is at least one '1' and at least '0' in it. If the first element is '1' then let's inverse it. Then we just should check if this row is sorted, and if it is then we found the answer. And the last case is if there are no transitional rows in the matrix. Then we should invert all rows from 2 to n consisting only of '0's (or only of '1's, it does not matter).

So, we have a solution with time complexity O(n3). Each number of '0's in the first row is processed in O(n2) and there are O(n) such numbers. But we can see that if we apply the last case (when the number of '0' is m) to the first row and then do the same, but with the last row consisting of m '1', we can get a solution in O(n2).

Solution

Codeforces Round #554 (Div. 2) Editorial

By AkiLotus, history, 4 years ago, In English1152A - Неко и виноградAuthor: xuanquang1999Development: xuanquang1999, AkiLotus, GreenGrapeTheme development: AkiLotus, GreenGrapeEditorialist: xuanquang1999

Tutorial1152A - Neko Finds GrapesThe most important observation is that:

Key with odd id can only be used to unlock chest with even idKey with even id can only be used to unlock chest with odd idLet:

c0,c1 be the number of chests with even and odd id, respectivelyk0,k1 be the number of keys with even and odd id, respectivelyWith c0 even-id chests and k1 odd-id keys, you can unlock at most min(c0,k1) chests.

With c1 odd-id chests and k0 even-id keys, you can unlock at most min(c1,k0) chests.

Therefore, the final answer is min(c0,k1)+min(c1,k0).

Complexity: O(n+m)Solution (xuanquang1999)1152B - Кошачье преобразование фурфурьеAuthor: AkiLotusDevelopment: AkiLotus, xuanquang1999Theme development: AkiLotusEditorialist: AkiLotus

Tutorial1152B - Neko Performs Cat Furrier TransformThere are various greedy solutions possible. I'll only cover one of them.

We'll perform a loop as follows:

If x≤1, stop the process (since it's already correct).If x=2m (m≥1), perform operation A with 2m−1. Obviously, the resulting x will be 2m+1−1, which satisfies the criteria, so we stop the process.Otherwise, let's denote MSB(x) as the position/exponential of the most significant bit of x (for example, MSB(4)=MSB(7)=2). We'll perform operation A with 2MSB(x)+1−1. If x after this phase is not a valid number, we'll then perform operation B and return to the beginning of the loop.This will never take more than 40 queries, since each iteration removes the most significant bit (and it would never reappear after later steps), and x can only have at most 20 bits initially.

Also, it is possible to solve this problem by finding exactly shortest operation sequence by using a BFS. However, this was not required.

Solution 1 - Greedy (Akikaze)Solution 2 - BFS (Akikaze)1152C - Неко занимается математикойAuthor: stefdascaDevelopment: stefdasca, AkiLotusTheme development: xuanquang1999, neko_nyaaaaaaaaaaaaaaaaaEditorialist: stefdasca

Tutorial1152C - Neko does MathsThe lcm(a+k,b+k) is equal to (a+k)⋅(b+k)gcd(a+k,b+k). In fact, there are not much possible values for the denominator of this fraction.

Without losing generality, let's assume a≤b. Applying one step of Euclid's algorithm we can see, that gcd(a+k,b+k)=gcd(b−a,a+k).

So the gcd is a divisor of b−a. Let's iterate over all divisors q of b−a. That also means that a(modq)=b(modq). In case a(modq)=0, we can use k=0. Otherwise, the corresponding k should be q−a(modq). Lastly, we need to check whether the value of lcm(a+k,b+k) is the smallest found so far.

Also, one has to be careful when dealing with k=0 answer, which was the reason why many solutions got WA 63.

The complexity is O(b−a−−−−√).

Solution (implemented by stefdasca)Solution (implemented by Akikaze)1152D - Неко и пранкAuthor: cdkrotDevelopment: cdkrotTheme development: xuanquang1999Editorialist: cdkrot

Tutorial1152D - Neko and Aki's PrankNote, that many subtrees of the trie are equal. Basically, if we consider two vertices on the same depth and having the same balance from root to them (that is, the number of opening brackets minus the number of closing brackets), than their subtrees will be entirely same. For example, the subtrees after following ((()), ()()( and (())( are all the same.

We will use this observation to consider the tree in "compressed" form. Clearly, this way there are only O(n2) different vertices types (basically a vertex is described by (depth,balance)).

Now let's get back to finding a maximum matching in the tree. There are two approaches to this problem. One of them is greedy. Basically if you find a matching in a tree you can always greedily take the edge between a leaf and its parent (since this adds one edge to the answer and destroys at most one edge you would've chosen).

This idea can transform into the following algorithm (for the problem of the maximum matching in the tree). Do a dynamic programming on the subtrees, the result of dp[v] is a pair of "number of edges taken in subtree, whether the root of this subtree is free (so we can start a new edge upwards)".

Combining this with the idea that there are little (n2) number of vertex types, we get a dp solution.

Solution (_kun_)1152E - Неко и флэшбекиAuthor: xuanquang1999Development: xuanquang1999Theme development: xuanquang1999Editorialist: xuanquang1999

Tutorial1152E - Neko and FlashbackObviously, if b′i>c′i for some i, then the answer is "-1".

From the statement, we have bi=min(ai,ai+1) and ci=max(ai,ai+1). For this to happen, either one of the following must happen:

ai=bi and ai+1=ciai=ci and ai+1=biIn order word, one of the two following pairs — (bi,ci) or (ci,bi) — will match the pair (ai,ai+1). From the statement, we also have b′i=bpi and c′i=cpi. Therefore, one of the two following pairs — (b′i,c′i) or (c′i,b′i) — will match the pair (api,api+1)Consider a graph G with 109 vertices. For each i from 1 to n−1, we will add an undirected edge between b′i and c′i. The following figure show such graph G for the third example.

Consider the path P=a1→a2→a3→…→an. Each edge (b′i,c′i) will correspond to exactly one edge between aj and aj+1 for some j. In other word, P correspond to an Eulerian path on the graph G. The following figure show the path P=3→4→5→2→1→4→3→2 for the third example.

For implementation, we need to do the following step:

For all elements of b′ and c′, we need to replace them with corresponding value from 1 to k (where k is the number of distinct value in b′ and c′). This part can be done using an balanced BST (C++ 'map' or Java 'TreeMap') or by sorting in O(nlogn).Build the graph G as aboveFinding an Eulerian path in G using Hierholzer's_algorithm in O(n), or detect that such path does not exists.Complexity: O(nlogn)Solution (xuanquang1999)1152F1 - Неко захватывает кошковселенную (упрощённая версия)1152F2 - Неко захватывает кошковселенную (усложнённая версия)Author: MofKDevelopment: MofK, xuanquang1999, AkiLotusTheme development: xuanquang1999, AkiLotusEditorialist: MofK, AkiLotus

Tutorial - F1 (Small version)1152F1 - Neko Rules the Catniverse (Small Version)As the problem stated, from planet x we can go backwards any to any planet y such that y<x.

This implies an idea of considering the planets from n to 1, then deciding whether to insert each planet to the current path or not.

Formally, if our current path is v1,v2,…,vp and we are going to insert planet x somewhere (x<vi for all i), we can either insert it into the back, or insert it before some planet vi such that vi≤x+m.

Therefore, we can use dynamic programming with the parameters being: the planet being considered, the number of planets chosen so far, and the bitmask of the last m planets (whether each of them is chosen or not).

The transition is straightforward: either we don't choose the planet, or we choose it and there are 1+bitcount(mask) ways to insert the planet into the path.

Total complexity: O(nk⋅2m).

Tutorial - F2 (Large version)1152F2 - Neko Rules the Catniverse (Large Version)The core idea is similar to F1, however there is one crucial observation.

We can see that all DP transitions are just linear transformations, thus we can construct a transition matrix of size k⋅2m, then use fast matrix exponentiation as a replacement of the original DP transitions.

Total complexity: O(log(n)⋅(k⋅2m)3).

Solution F1 (xuanquang1999)Solution F2 (xuanquang1999)Solution F2 (veryheckingfast by MofK)BonusSolve the problem in (or faster than) O(log(n)⋅k2⋅(2m)3).

Authors' logs (miscellaneous things during our preparations)

Codeforces Round #553 (Div. 2) Editorial

By Dalgerok, history, 4 years ago, In English1151A - Maxim and BiologyCheck every substring of string s of length 4 and find the minimum number of operations to transform it into "ACTG" and update the answer.

Complexity is O(n).

1151B - Dima and a Bad XORLet's take the first number in each array.

Then, if we have current XOR strictly greater than zero we can output an answer.

And if there is some array, such that it contains at least two distinct numbers, you can change the first number in this array to number, that differs from it, and get XOR 0⊕x>0.

Else, each array consists of the same numbers, so all possible XORs are equal to 0, and there is no answer.

Complexity is O(n⋅m).

1151C - Problem for NazarAt first let's simplify the problem. Let's denote as f(x) function that returns sum of the elements that are on positions from 1 to x inclusive.

How to implement function f(x)?

To find the answer we can find the sum of even and sum of odd numbers and add them. Let's find how many there are even and odd numbers. Let's call them cureven and curodd. Iterate through the powers of two. If current power is even, then add minimum from x and current power of two to curodd, otherwise add minimum from x and current power of two to cureven, after that reduce x by current power of two. If x becomes less than or equal to 0 break.

Now our task is reduced to twos: for given number n find the sum of first n even numbers and for given number m find the sum of first m odd numbers. The answer for first task is n⋅(n+1). The answer for second task is m2.

Now the answer for the problem is f(r)−f(l−1).

Don't forget about modulo :)

Complexity is O(logN).

1151D - Stas and the Queue at the BuffetFirstly, open the brackets: ai⋅(j−1)+bi⋅(n−j) = (ai−bi)⋅j+bi⋅n−ai. As you can see bi⋅n−ai is not depending on j, so we can sum these values up and consider them as constants.

Now we must minimize the sum of (ai−bi)⋅j.

Let's denote two integers arrays each of length n: array c such that ci=ai−bi and array d such that di=i (for each i from 1 to n). Now we must solve the following task: minimize the value ∑ni=1ci⋅di if we can rearrange the elements of array c as we want. To solve this problem we must sort array c in non-increasing order. You can use an exchange argument to prove it.

Complexity is O(nlogn).

1151E - Number of ComponentsFirst of all assign 0 to a0.

How to find the value of f(l,r) in O(n)?

For each i from 0 to n set bi to 1 if l≤ai≤r, otherwise set it to 0. Now we can see that the value of f(l,r) is equal to the number of adjacent pairs (0,1) in array b.

So now we can find the answer in O(n) using technique contribution to the sum. For every adjacent pair of elements in array a (including zero-indexed element) we must find it contribution to the overall answer. Considering the thoughts above about f(l,r), we must find the number of pairs (l,r) such that ai is on the range [l,r] and ai−1 is not on the range [l,r]. There are two cases:

What if ai is greater than ai−1? Then l must be on range from ai−1+1 to ai and r must be on range from ai to n. The contribution is (ai−ai−1)⋅(n−ai+1).

What if ai is less than ai−1? Then l must be on range from 1 to ai and r must be on range from ai to ai−1−1. The contribution is ai⋅(ai−1−ai).

Sum up the contributions of all adjacent pairs to find the answer.

Complexity is O(n).

1151F - Sonya and InformaticsHow to solve this problem in O(n⋅k)?

Let's find the answer using dynamic programming. Denote cur as the number of zeroes in array a, and dpi,j as the number of rearrangements of array a after i operations and j is equal to the number of zeroes on prefix of length cur. Denote x as the number of zeroes on prefix of length cur. The initial state will be dp0,x=1. Notice that the answer will be dpk,cur∑curi=0dpk,i.

The transitions are not so hard. You must know the following values: the number of ones on prefix of length cur, the number of zeroes on prefix of length cur, the number of ones NOT on prefix of length cur and the number of zeroes NOT on prefix of length cur. For example, you can find the number of pairs such that after we swap them the number of zeroes on prefix of length cur is increased by one: the number of ones on prefix of length cur multiply by the number of zeroes NOT on prefix of length cur. Also there are transitions when the number of zeroes on prefix of length cur remains the same, and when it decreased by one (you can find them by yourself).

To solve the original problem we must create the transition matrix and find the answer using matrix multiplication with binary exponentiation.

Also you must know how to find the modular multiplicative inverse to find the answer.

Complexity is O(n3⋅logk).

Codeforces Round #552 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1154A - Restoring Three Numbers

Idea: MikeMirzayanov

Tutorial1154A - Restoring Three NumbersLet x1=a+b, x2=a+c, x3=b=c and x4=a+b+c. Then we can construct the following answer: c=x4−x1, b=x4−x2 and a=x4−x3.

Because all numbers in the answer are positive, we can assume that the maximum element of x is a+b+c. So let's sort the input array x consisting of four elements and just print x4−x1,x4−x2 and x4−x3.

Solution1154B - Make Them Equal

Idea: MikeMirzayanov

Tutorial1154B - Make Them EqualLet's leave only unique values of the given array in the array b (i. e. construct an array b that is actually array a without duplicate element) and sort it in ascending order. Then let's consider the following cases:

If the length of b is greater than 3 then the answer is -1;if the length of b is 3 then there are two cases:if b3−b2=b2−b1 then the answer is b2−b1;otherwise the answer is -1;if the length of b is 2 then there are also two cases:if b2−b1 is even then the answer is b2−b12;otherwise the answer is b2−b1;and if the length of b is 1 then the answer is 0.Solution1154C - Gourmet Cat

Idea: le.mur

Tutorial1154C - Gourmet CatLet the number of rations of fish food be a1, the number of rations of rabbit stew be a2 and the number of rations of chicken stakes be a3 (so we have an array a consisting of 3 elements).

Let full be the maximum number of full weeks cat can eat if the starting day of the trip can be any day of the week. The value of full is min(⌊a13⌋,⌊a22⌋,⌊a32⌋).

Let's subtract the value 3⋅full from a1, and 2⋅full from a2 and a3. We can see that we cannot feed the cat at least one more full week. So the final answer is 7⋅full+add, where add<7.

Now it's time for some good implementation! Of course, you can try to analyze all cases and handle them using ifs or something similar, but I will try to suggest you a good enough way to implement the remaining part of the problem:

Let's create an array idx of length 7, where idxi means the type of the food cat eats during the i-th day of the week (1 for fish food, 2 for rabbit stew and 3 for chicken stake). It will be idx=[1,2,3,1,3,2,1].

Now let's iterate over the day we will start our trip. Let it be start. For the current starting day let cur be the number of rations cat has eaten already (initially it is zero), day be the current day of the trip (initially it is start) and the array b be the copy of the array a. Then let's do the following sequence of the operations, while bidxday is greater than zero: decrease bidxday by one, increase cur by one and set day:=day%7+1 (take it modulo 7 and add one). After this cycle we can update the answer with the value of 7⋅full+cur.

Solution1154D - Walking Robot

Idea: MikeMirzayanov

Tutorial1154D - Walking RobotLet's simulate the process of walking and maintain the current charges of the battery and the accumulator, carefully choosing which to use each time we want to pass a segment.

Obviously, if at the beginning of some segment our battery is exhausted (its current charge is 0), we must use the accumulator to continue, and vice versa.

What if we can use both types of energy storage? If we can recharge the accumulator (the current segment is exposed and the current charge of accumulator is lower than its initial charge), let's do it — because it only consumes one charge of the battery, and there is no better way to spend it. And if we cannot recharge the accumulator, it's optimal to use it instead of the battery (suppose it's not right: our solution uses the accumulator during current moment of time t and the battery during some moment in future t2, but optimal solution does vice versa. Then the usage of the battery in optimal solution does not grant us any additional charges, so we can instead swap our decisions in these moments, use the accumulator right now and the battery later, and the answer won't get worse).

So, what's left is to carefully implement the simulation, keeping track of charges and choosing what to use according to aforementioned rules.

Solution1154E - Two Teams

Idea: MikeMirzayanov

Tutorial1154E - Two TeamsLet's maintain two data structures: a queue with positions of students in order of decreasing their programming skill and a set (std::set, note that we need exactly ordered set) with positions of students not taken in any team.

To construct the first data structure we need to sort pairs (ai,i) in decreasing order of the first element and after that push second elements in order from left to right.

The second data structure can be constructed even easier — we just need to insert all values from [1,n] into it.

Also let's maintain an array ans, where ansi=1 if the i-th student belongs to the first team and ansi=2 otherwise, and the variable who to determine whose turn is now (initially it is 1).

While our set is not empty, let's repeat the following algorithm: firstly, while the head (the first element) of the queue is not in the set, pop it out. This is how we determine which student will be taken now. Let his position be pos. And don't forget to pop him out too. Create the additional dynamic array add which will contain all students we will add to the team during this turn.

Let's find the iterator to the student with the position pos. Then make the following sequence of moves k+1 times: add the element the current iterator is pointing at to the array add, then if the current iterator is pointing at the first element, break the cycle, otherwise go to the iterator pointing at the previous element.

Then let's find the iterator to the student next to the student with position pos. And then let's make almost the same sequence of moves k times: if the current iterator is pointing to the end of the set, break the cycle, otherwise add the element the current iterator is pointing at to the array add and advance to the iterator pointing at the next element.

Then let's remove all values from the array add from the set, and for each student st we delete let's set ansst=who. And change the variable who to 2 if it is 1 now and to 1 otherwise.

Time complexity: O(nlogn).

Solution1154F - Shovels Shop

Idea: MikeMirzayanov

Tutorial1154F - Shovels ShopFirst of all, since we are going to buy exactly k shovels, we may discard n−k most expensive shovels from the input and set n=k (and solve the problem which requires us to buy all the shovels). Also, let's add an offer which allows us to buy 1 shovel and get 0 cheapest of them for free, to simulate that we can buy shovels without using offers.

Now we claim that if we sort all the shovels by their costs, it's optimal to divide the array of costs into some consecutive subarrays and buy each subarray using some offer. Why should the sets of shovels for all purchases be consecutive subarrays? Suppose it's not so: let's pick two purchases such that they are "mixed" in the array of costs, i. e. there exists at least one shovel A bought in the first purchase such that there exists a shovel B cheaper than it and a shovel C more expensive than it, both bought in the second purchase. If shovel A is for free, then we may "swap" shovels A and C, otherwise we may swap shovels A and B, and the answer won't become worse. So, we can do it until all purchases correspond to subsegments in the array of costs.

Then it's easy to see that we can make purchases in such a way that we always buy some amount of cheapest shovels. And now the problem can be solved by knapsack-like dynamic programming: let dpi be the minimum cost to buy exactly i cheapest shovels. dp0 is 0, and for each offer (x,y) we can update dpi+x by the value of dpi+sum(i+y+1,i+x), where sum(l,r) is the sum of costs of all shovels in the sorted order from shovel on position l to shovel on position r, inclusive (these sums can be calculated in O(1) using partial sums method).

Solution1154G - Minimum Possible LCM

Idea: MikeMirzayanov

Tutorial1154G - Minimum Possible LCMI've heard about some very easy solutions with time complexity O(aloga), where a is the maximum value of ai, but I will describe my solution with time complexity O(nd), where d is the maximum number of divisors of ai.

A very good upper-bound approximation of the number of divisors of x is x−−√3 so my solution works in O(na−−√3).

Firstly, let's talk about the idea. The main idea is the following: for each number from 1 to 107, we want to find two minimum numbers in the array which are divisible by this number. Then we can find the answer among all such divisors that have at least two multiples in the array.

Let's write a function add(idx) which will try to add the number aidx to all its divisors. The easiest way to do it is iterate over all divisors in time O(aidx−−−√) and add it somehow. But it is too slow. Let's improve it somehow. How can we skip numbers that aren't divisors of aidx? Let's build an Eratosthenes sieve (I highly recommended one with time complexity O(n) because the sieve with time complexity O(nloglogn) is about twice slower on such constraints) which will maintain the minimum divisor for each number from 1 to 107 (the linear sieve builds this array automatically in its implementation). Then we can factorize the number in O(logaidx) and iterate over all its divisors using simple recursive function.

And the last thing I should notice — this solution can give TLE and require some constant optimizations. I recommended to use pair of integers (or arrays of size two) for each divisor and to add numbers using a few if-statements.

Solution

Codeforces Round #551 (Div. 2) Editorial

By Serval, 4 years ago, In English1153A - Serval and Bus

Author: Serval, preparation: bzh

EditorialFind the first bus Serval can see in each route and find the earliest one. For each route, finding the first bus Serval sees can work in O(1).

Or mark all the time no more than max(si,t+max(di)) which bus would come or there will be no bus, then search the nearest one.

1153B - Serval and Toy Bricks

Author: Serval, Preparation: bzh

EditorialFill in all the bricks, and then remove all bricks you must remove (which in some view, there is empty). This can be solved in O(nm).

1153C - Serval and Parenthesis Sequence

Author & preparation: Serval

EditorialFirst let ( be +1, ) be −1 and ? be a missing place, so we will replace all the missing places in the new +1,−1 sequence by +1 and −1.

Obviously, for each prefix of a correct parenthesis sequence, the sum of the new +1,−1 sequence is not less than 0. And for the correct parenthesis sequence itself, the sum of the new sequence should be 0. So we can calculate how many +1 (let a denotes it) and how many −1 (let b denotes it) that we should fill in the missing places.

According to the problem, our goal is to fill the missing place with +1 and −1 to make sure there is no strict prefix (prefixes except the whole sequence itself) exists with the sum equal to 0. This can be solved in greedy. We want the sum of prefixes as large as possible to avoid the sum touching 0. So let the first a missing places be filled with +1 and the last b missing places be filled with −1.

Check it whether it is a correct parenthesis sequence or not at last. The complexity is O(n).

1153D - Serval and Rooted Tree

Author & preparation: bzh

EditorialIf we want to check whether x is the answer (I didn't say I want to do binary search), then we can set all the numbers no less than x as 1, and the numbers less than x as 0. Then we can use dpi to represent that the maximum number on node i is the dpi-th smallest number of leaves within subtree of i. There should be at least dpi ones in the subtree of i such that the number on i is one. Then k+1−dp1 is the final answer. Complexity O(n).

CodeAnother SolutionCode for Another Solution1153E - Serval and Snake

Authors & preparation: Serval, bzh

EditorialIf the answer to a rectangle is odd, there must be exactly one head or tail in that rectangle. Otherwise, there must be even number (0 or 2) of head and tail in the given rectangle.

We make queries for each of the columns except the last one, then we can know for each column whether there are odd number of head and tails in it or not. Because the sum is even, we can know the parity of the last column.

If the head and tail are in different columns, we can find two columns with odd answer and get them. Then we can do binary search for each of those two columns separately and get the answer in no more than 999+10+10=1019 queries totally.

If the head and tail are in the same column, we will get all even answer and know that fact. Then we apply the same method for rows. Then we can just do binary search for one of the rows, and use the fact that the other is in the same column as this one. In this case, we have made no more than 999+999+10=2008 queries.

Bonus: How to save more queries?1153F - Serval and Bonus Problem

Author: Serval, preparation: Serval, bzh

EditorialWithout loss of generality, assume that l=1. For a segment covering, the total length of the legal intervals is the probability that we choose another point P on this segment randomly such that it is in the legal intervals. Since all 2n+1 points (P and the endpoints of each segment) are chosen randomly and independently, we only need to find the probability that point P is in the legal intervals. Note that only the order of these 2n+1 points make sense. Because the points are chosen in the segment, the probability that some of them coincide is 0, so we can assume that all points do not coincide.

Now the problem is, how to calculate the number of arrangements that P is between at least k pairs of endpoints. It can be solved by dynamic programming in time complexity of O(n2). We define f(i,j,x) as the number of arrangements for the first i positions, with j points haven't been matched, and P appeared x times (obviously x=0 or 1). So we can get three different types of transition for the i-th position below:

Place P at i-th position (if j≥k): f(i−1,j,0)→f(i,j,1)Start a new segment (if i+j+x<2n): f(i−1,j−1,x)→f(i,j,x)Match a started segment, note that we have j choices of segments: f(i−1,j+1,x)×(j+1)→f(i,j,x)Then f(2n+1,0,1) is the number of legal arrangements. Obviously, the total number of arrangements is (2n+1)!. However, there are n pairs of endpoints whose indices can be swapped, and the indices n segments can be rearranged. So the final answer is f(2n+1,0,1)×n!×2n(2n+1)!.

CodeUPD: We fixed some mistakes and added another solution for D.

Codeforces Round #550 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1144A - Diverse Strings

Idea: MikeMirzayanov

Tutorial1144A - Diverse StringsThe string is diverse if it is a permutation of some substring of the Latin alphabet ("abcd ... xyz").

In other words, the string is diverse if all letters in it are distinct (we can check it using some structure like std::set or array of used elements) and if the number of letters between the letter with the maximum alphabet position and the letter with the minimum alphabet position plus one is exactly the length of the string. For example, the position in alphabet of letter 'a' is one, the position of letter 'f' is six and so on.

Solution1144B - Parity Alternated Deletions

Idea: MikeMirzayanov

Tutorial1144B - Parity Alternated DeletionsLet's calculate the sum of the whole array sum and then divide all its elements into two arrays odd and even by their parity (odd for odd, even for even). Sort both of them in non-increasing order. Then what can we see? We always can delete first k=min(|odd|,|even|) elements from both arrays (where |x| is the size of x). So let's decrease sum by the sum of first k elements of the array odd and the same for the array even. If one the arrays has more than k elements (both arrays cannot have more than k elements because if it is so then k should be greater) then let's decrease sum by the k+1-th element of this array (because this is the maximum possible element we can remove). Now sum is the answer for the problem.

Solution1144C - Two Shuffled Sequences

Idea: MikeMirzayanov

Tutorial1144C - Two Shuffled SequencesLet's count the number of occurrences of each element in the array cnt. Because the maximum possible element is 2⋅105, it can be done without any data structures.

Then let's check if cnti is greater than 2 for some i from 0 to 2⋅105, and if it is, then the answer is "NO", because this element should occur at least twice in one of the sequences.

Now let's output the increasing sequence. The number of elements in it is the number of elements i such that cnti=2. Let's iterate from left to right, print the suitable elements and decrease their cnt.

The number of elements in the decreasing sequence is just the number of elements with non-zero cnt. So let's iterate from right to left and just print suitable elements.

Solution1144D - Equalize Them All

Idea: vovuh

Tutorial1144D - Equalize Them AllLet's find the most frequent element in the array (using the array of frequencies cnt, of course). Let this element be x. If we will see the operations more carefully, we can see that the part of these operations means "set element p to element q". if p<q then this operation is 1pq, otherwise it is 2pq.

Now let's consider the number of operations in the optimal answer. It is obvious that we need at least n−cntx operations to equalize all the elements. And it is also obvious that we can always do it with n−cntx such operations we have.

How to restore the answer? There is an easy way to do it: find the first occurrence of x. Let it be pos. Then let's go from pos−1 to 1 and set each element to the next element (element at the position pos−1 to pos, pos−2 to pos−1 and so on). And don't forget to print right type of operation. Then let's go from left to right from 1 to n and if the i-th element don't equal to x then set it to i−1-th element using right operation.

Solution1144E - Median String

Idea: vovuh

Tutorial1144E - Median StringThis problem supposed to be easy long arithmetic problem.

Let's represent our strings as huge numbers with base 26. Let s be l and t be r.

So if we will see more precisely in the problem statement, then we can see that the answer is l+r2. The operation l+r with long numbers can be done in O(k) and division long number by two also can be done in O(k).

All details of implementation are in the author's solution.

Solution1144F - Graph Without Long Directed Paths

Idea: MikeMirzayanov

Tutorial1144F - Graph Without Long Directed PathsWhat if the given graph will contain a cycle of odd length? It will mean that some two consecutive edges of this cycle will be oriented in the same way and will form a path of length two.

What if there is no cycles of odd length in this graph? Then it is bipartite. Let's color it and see what we got. We got some vertices in the left part, some vertices in the right part and all edges connecting vertices from different parts. Let's orient all edges such that them will go from the left part to the right part. That's it.

Solution1144G - Two Merged Sequences

There is different solution for the problem, it is pretty interesting! Thanks, Roundgod!

Idea: vovuh

Tutorial1144G - Two Merged SequencesI know about greedy solutions and other approaches, but I'll describe my solution. This is dynamic programming. I'll consider all positions 0-indexed.

Let dpi,0 be the maximum possible minimal element in the decreasing sequence, if the last element (i−1-th) was in the increasing sequence, and dpi,1 be the minimum possible maximum element in the increasing sequence, if the last element (i−1-th) was in the decreasing sequence.

Initially, all dpi,0 are −∞ and all dpi,1 are ∞ (except two values: dp0,0=∞ and dp0,1=−∞).

What about transitions? Let's consider four cases:

The previous element was in the increasing sequence and we want to add the current element to the increasing sequence. We can do dpi,0:=max(dpi,0,dpi−1,0) if ai>ai−1;the previous element was in the increasing sequence and we want to add the current element to the decreasing sequence. We can do dpi,1:=min(dpi,1,ai−1) if ai<dpi−1,0;the previous element was in the decreasing sequence and we want to add the current element to the decreasing sequence. We can do dpi,1:=min(dpi,1,dpi−1,1) if ai<ai−1;the previous element was in the decreasing sequence and we want to add the current element to the increasing sequence. We can do dpi,0:=max(dpi,0,ai−1) if ai>dpi−1,1.The logic behind these transitions is kinda hard but understandable.

If dpn−1,0=−∞ and dpn−1,1=∞ then the answer is "NO". Otherwise we can restore any possible answer using parents in the dynamic programming.

Solution

Codeforces Round #549 Editorial

By grphil, history, 4 years ago, In English1143A - The DoorsLet's walk through the array and find for each exit the door, that was opened last. Then the answer is minimum of the numbers of these doors.

Authors: grphil and vekarpov

1143B - NirvanaLet number x be an answer, and y0y1…yl¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ - number from input, so x = y0y1…yk(yk+1−1)99…9¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ for some k (otherwise, you can increase one of the digits by 1, so that x will still be no more than y). So, let's go through k from 0 to the length of y and return the maximum of them by the product of digits.

Author: MikeMirzayanov

1143C - QueenFrom the condition about the fact that each vertex equally respects all its ancestors, we can understand that each vertex is either always a candidate for deletion or it can never be deleted. That is because when we delete some vertex all new vertices which become sons of it's parent are also disrespecting it.

Now we can iterate over all vertices and if it respects it's parent, we will remember that it's parent can not be deleted. And so we will get the answer.

Authors: grphil and vekarpov

1142A - The BeatlesLet's assume that we know the length of the jump, and it is equal to l. Then, in order to be back at the starting point, Sergey will need to make exactly n⋅k/gcd(n⋅k,l) moves, where gcd is the greatest common divider.

Let l=kx+c, where c and x are non-negative integers. So, if we know a and b, than c can only take 4 values: ((a+b)%c,(a−b)%c,(b−a)%c,(−a−b)%c), where %c means modulo c. It is clear that only x<n can be considered. Then we iterate over all the 4n variants of the pair (x,c), and for each we find the number of moves to the starting point. The minimum and maximum of the resulting numbers will be the answer.

Authors: grphil and vekarpov

1142B - Lynyrd SkynyrdFor each ai if the number ai has position j in p, let's find the greatest l, such that l is less then i and al=pj−1 (let's define p0=pn) We will call this position bi. This can be done in O(n) time, just for each pj we will keep the last it's position in a while iterating over a.

Now let's notice that using this info for each i we can find the beginning of right most subsequence of a which is a ciclic shift of p and ends exactly at ai. This can easily be done because if there is a subsequence of a ai1,ai2…,ain−1,ai, which is the right most such subsequence, then in−1 is bi, in−2 is bin−1, and so on. So to find such subsequence and the position of it's beginning, we need to calculate b[b[b…b[i]…]] n−1 times. To do it we can use binary lifting. Then we will have O(mlogn) precalc and we will get the beginning of such subsequence in O(logn) time.

Now for each prefix of a let's calculate the the beginning of right most subsequence of it, which is a cyclic shift of p. This can be calculated in linear time, first we look at the answer for this prefix without the last number, and then update it with the right most subsequence, which ends at the end of prefix.

Now we can answer each query in O(1) time, because we just need to find the beginning of the right most subsequence, which ends at prefix of length r and compare it with l.

Author: qoo2p5

1142C - U2Let's rewrite parabola equation y=x2+bx+c as y−x2=bx+c. This means, that if you change each point (xi,yi) to (xi,yi−x2i), then the parabolas will turn into straight lines, and the task will be reduced to constructing a top part of convex hull on the obtained points and calculate the number of segments on it.

Authors: grphil and vekarpov

1142D - ForeignerLet's take any inadequate number x of length n. Let's keep 3 parameters for it: ax which is the number of all inadequate numbers less of equal then x, bx which is the number of inadequate numbers less then x which have length n and cx which is the number of inadequate numbers grater then x which have length n. We know that there are exactly ax modulo 11 inadequate numbers that come from x by adding a new digit to the end. Also, because we know bx and cx, we can find a, b and c parameters for each of those numbers. Let's now notice, that if instead of keeping a, b and c parameters we can keep all of them modulo 11. The parameters of all numbers that come from x will still be defined because if we increase a by 11, these parameters will be the same modulo 11, if we increase b by 11, a and b parameters of all numbers that come from x are increase by 0+1+2+…+10=(11⋅10)/2=55 which is 0 modulo 11. The same is with c parameter. So these 3 parameters modulo 11 exactly define what new numbers will come from x and the values of these 3 parameters for them. Now we can create some kind of automaton of size 113, where we will have 9 starting nodes and all paths from these nodes will be the inadequate numbers and for any inadequate number there will be path which will define it. Now let's create dynamic dp[i][j], which is how long we can go into the automaton by the characters of suffix of length i of our given string s starting from node j in automaton. We can calculate this dp in n⋅113 time and using it we can check for each suffix of s what is its longest prefix that is an inadequate number and so we can solve the problem.

Actually, during the contest it turned out that this problem has shorter solution, but this is more general one which doesn't depend on the starting numbers (in our case they were 1,2,3,…9).

Authors: grphil, qoo2p5, super_azbuka

1142E - Pink FloydFirst let's assume that graph has only the green edges and we still don't know their directions. Then we can do the following. We will keep some node which we will call the "top node" and the list of the nodes, that can be reached from the top node. Let's take some node A which is not reachable and ask about the direction of edge between the top node and A. If the edge goes from top node to A, then we can add A to the list of reachable nodes and the size of the list will increase by one. If the edge goes from A to the top node, then we can call A the new top node, and as the old top node was reachable from A, the list of reachable nodes will remain the same, but the node A is reachable from itself, so it also will be added to the list. This way after each query we will increase the number of reachable nodes and in n−1 query we will get the answer.

In our graph we have edges that are coloured in pink, so if we will repeat the described above algorithm, we may get that the edge between top node and A is coloured in pink. To avoid it, let's create the condensation of pink graph (condensation means the graph of the strongly connected components (later SCC)). As it is a condensation, there always should be some SCCs, that have no incoming edges. Let's call them free SCCs. We will pick some free SCC and pick some node from it and make it top node. Now we will repeat the following: if there are no other free SCC except the one, that contains the top node, all others are reachable from the only free SCC, which means that we have solved the problem. If there is any other top SCC, let's pick some node A from it. Because this SCC has no incoming edges, the edge between A and top node is green. So we can repeat the algorithm described above. After that as the node A is reachable by green color, we can assume that this node is deleted. If it was the last node in it's SCC, we delete this SCC as well and delete all outcoming edges from it. Now some more SCCs may become free. And then we repeat our algorithm. After at most n−1 steps all nodes will be reachable from top one by single coloured path, which means that we have solved the problem.

In out algorithm we need first to create condensation of the graph, which can be done in O(n+m) time, then we need to remember how many nodes are in each SCC and keep a set of all free SCCs. That can also be done in O(n+m) time.

Author: grphil

Codeforces Round #548 Editorial

By Ashishgup, history, 4 years ago, In EnglishI hope you guys enjoyed the contest and we hope to host another one soon! The next one will be more balanced :P

With that said, here are the tutorials:

1139A - Even SubstringsAny substring ending in 2,4,6,8 forms an even substring. Thus, iterate over all positions i of the string s, and if the digit represented by character at ith index is even, then add i+1 to the answer, since all the substrings starting at 0,1,...,i and ending at i are even substrings.

Overall Complexity: O(n).

Author: Ashishgup

C++ Code: 51651509

Java Code: 51651164

1139B - ChocolatesIt is optimal to proceed greedily from the back of the array. If we have taken x candies of the i+1 type, then we can only take min(x−1,Ai) candies for type i. If this value is less than zero, we take 0 from here.

Overall Complexity: O(n)Author: Ashishgup

C++ Code: 51651887

Java Code: 51651375

1139C - Edgy TreesLet's find the number of bad sequences — Sequences of length k that do not pass through any black edges. Then answer is all possible sequences minus the number of bad sequences.

Thus, we can remove black edges from the tree.

Now the tree would be split into connected components.

For every connected component, if we start with A1 being a node from this component, then we cannot step outside this component, since doing so would mean that we visit a black edge. But we can visit all the nodes in the current connected component in any order. So if the size of the current component is p, then we have pk bad sequences corresponding to this connected component.

Thus, the overall answer is nk−∑pk where p is the size of different connected components, considering only red edges.

Author: Ashishgup

C++ Code: 51652029

Java Code: 51651756

1139D - Steps to OneLet dp[x] be the expected number of additional steps to get a gcd of 1 if the gcd of the current array is x.

Suppose the current gcd of the array a is x, after the next iteration of the algorithm, we would append some randomly chosen j with a probability 1m, and move to state gcd(x,j) and since the length increases by 1 on appending, we will make dp[gcd(x,j)]+1 steps for this j.

So the recurrence is :dp[x]=1+∑j=1mdp[gcd(j,x)]mI recommend this Expectation tutorial to get more understanding of the basics.

We can group together all terms having the same gcd(j,x), move terms having gcd(j,x)=x to the left side of the equation and use that to calculate dp[x].

This is an O(m2) solution.

Here we notice that gcd(j,x) is a factor of x,

So the recurrence could be modified as :dp[x]=1+∑y∈divisors(x)dp[y]⋅f(y,x)mwhere f(y,x) is the count of integers 1≤p≤m, such that gcd(p,x)=yLets express x=y⋅a, and p=y⋅b where a, b are positive integers,

So we want to find the number of p's where 1≤p≤m, p=y⋅b, such that gcd(b,a)=1, i.e. we want to find number of b where 1≤b≤m/y such that gcd(b,a)=1.

Lets find factorization of a, so b must not be divisible by any of the prime factors of a.

We can find number of b≤m/y such that it isn't divisible by some set of primes by inclusion exclusion.

Since there are at most 6 primes, we have complexity: O(mlogm⋅26⋅6)

For an alternate solution using mobius function, refer code 2.

Author: Vivek1998299

C++ Code (Above Logic): 51652491

C++ Code (Mobius Inversion): 51652104

1139E - Maximize MexLet's reverse the queries so that instead of removal of edges we need to work with the addition of edges. Now consider a bipartite graph with values 0…m on the left side and clubs 1…m on the right side. For an ind i, which has not been removed, we add an edge from pi on the left to ci on the right. Let's start finding matching for values 0…m in sequence. Let's say we couldn't find matching for i-th value after query x, so our answer for query x will be i. Now, we add the student of query x. Let the index of the student be ind, then we add an edge from pind on the left to cind on the right. Now, we start finding matching from i…m, until matching is not possible. We repeat this process until all queries are solved.

Overall Complexity: O(d⋅n+m⋅n)Author: Jeel_Vaishnav

Java Code: 51652167

1139F - Dish ShoppingLet's consider a matrix where i-th row represents price i and j-th column represents beauty j, such that the value of c[i][j] represents the number of dishes that can be bought by a person having income i and preferred beauty j. Then, adding a dish with price p, standard s and beauty b is similar to adding +1 in each cell in the triangle formed by vertices P(p,b), Q(s,b−s+p) and R(s,b+s−p). Now, we need to update the given triangles with +1 in a matrix efficiently. Let's do this offline.

Note that for a triangle with vertices P(p,b), Q(s,b−s+p) and R(s,b+s−p), the column updated in p-th row is b. The columns updated in (p+1)-th row are b−1, b and b+1. So, if the columns updated in i-th row are x…y, then the columns updated in i+1-th row will be (x−1)…(y+1). For updating a range l…r in a row i, we can update mat[i][l] with +1 and mat[i][r+1] with −1. And then when we do prefix sum in that row we get actual values for each cell.

We can use similar approach here. Note that instead of updating mat[i][l] with +1, we can update some array larr[i+l] with +1, similarly instead of updating mat[i][r+1] with −1, we can update some array rarr[r+1−i] with −1. In this way, we can provide updates for each row in triangle instead of just one row. The value of a cell mat[i][j] will be addition of prefix sum of larr in range [0,i+j] and prefix sum of rarr in range [0,j−i].

Let's create four events for each triangle. For, a triangle with vertices P(p,b), Q(s,b−s+p) and R(s,b+s−p), the events added will be larr[p+b]+=1 at cell (p,b), rarr[b+1−p]-=1 at cell (p,b+1), larr[p+b]-=1 at cell (s+1,b−s−1+p), rarr[b+1−p]-=1 at cell (s+1,b+s+1−p). Also, we add query events for each person i at cell (inci,pbi). Let's sort this events on the basis of rows of the cell and then for the same row we handle triangle events first and then handle query events. For maintaining prefix sum in larr and rarr, we can use compression and a datastructure like fenwick tree.

Overall Complexity: O((n+m)⋅log(n+m))Author: Jeel_Vaishnav

Java Code: 51652020

Codeforces Round #547 (Div. 3) Editorials

By MikeMirzayanov, 4 years ago, In EnglishThanks for taking part in the round. I hope you enjoyed the round. It happens that the statements were really easy to understand (thanks to testers). We've got only 38 questions during a round!

1141A - Игра 23If m is not divisible by n then just print -1 and stop the program. Otherwise, calculate d=m/n, denoting the required number of times to multiply n. It is easy to see that d should be a product of zero or more 2's and of zero or more 3's, i.e. d=2x3y for integers x,y≥0. To find x just use a loop to divide d by 2 while it is divisible by 2. Similarly, to find y just use a loop to divide d by 3 while it is divisible by 3. After the divisions, the expected value of d is 1. If d≠1, print -1. Otherwise, print the total number of the loop iterations.

Code1141B - Максимальный непрерывный отдыхAt first consider we process the only day. In this case just iterate over hours and maintain len — the length of the current rest block (i.e. if the element equals 1 then increase len, if the element equals 0 then reset len to 0). The maximum intermediate value of len is the answer.

In case of multiple days, consider the given sequence as a cyclic sequence. Concatenate the sequence twice and solve the previous case. Sure, not it is no necessary to concatenate it in explicit way, just use a[i % n] instead of a[i] and process i=0…2⋅n−1.

Code1141C - Поликарп восстанавливает перестановкуLet's p[1]=x. Thus, p[2]=p[1]+(p[2]−p[1])=x+q[1], p[3]=p[1]+(p[2]−p[1])+(p[3]−p[2])=x+q[1]+q[2], ..., p[n]=p[1]+(p[2]−p[1])+(p[3]−p[2])+⋯+(p[n]−p[n−1])=x+q[1]+q[2]+⋯+q[n−1].

It means that the sequence of n partial sums p′=[0,q[1],q[1]+q[2],…,q[1]+q[2]+⋯+q[n−1]] is the required permutation if we do +x to each element. The value of x is unknown yet.

Find such i that p′[i] is minimum. Thus, x=1−p′[i]. Exactly this value will change p′[i] to be 1 after you add x. So, add x to each element of p′ and check that now it is a permutation.

Probably, you need to use long long to avoid possible integer overflows.

Code1141D - Цветные ботинкиUse greedy approach in this problem. At first, match such pairs that colors are exactly the same (and they are specific, not indefinite). After it match each indefinite colored left boot (if any) with any specific colored right boot. Possibly, some indefinite colored left boots stay unmatched. Similarly, match each indefinite colored right boot (if any) with any specific colored left boot. And finally match indefinite colored left and right boots (if any).

Code1141E - Супергеройская битваIn general the answer looks like: some number of complete (full) round cycles plus some prefix the the round.

Check corner case that there are no complete (full) rounds at all (just check the first round in naive way). If no solution found, the answer has at least one complete (full) cycle and some prefix.

If total sum in one round is not negative, then a complete (full) cycle doesn't help and it is again the no solution case.

Let's find number of complete (full) cycles. We need such number of cycles x that if your multiple x by total sum and add some prefix, the result (with negative sign, because it is not a damage) will be greater or equal than H. So, to find x just add with H the minimal prefix partial sum and divide the result by minus total sum. Now you know the number of complete (full) cycles, just iterate over the last round in naive way to find the answer.

Code1141F1 - Блоки равной суммы (простая редакция)Please, read the editorial of the hard edition.

1141F2 - Блоки равной суммы (усложненная редакция)Let's x the same sum of blocks in the answer. Obviously, x can be represented as a sum of some adjacent elements of a, i.e. x=a[l]+a[l+1]+⋯+a[r] for some l and r.

Iterate over all possible blocks in O(n2) and for each sum store all the blocks. You can use 'map<int, vector<pair<int,int»>' to store blocks grouped by a sum. You can do it with the following code:

map<int, vector<pair<int,int>>> segs;for (int r = 0; r < n; r++) {    int sum = 0;                                  for (int l = r; l >= 0; l–) {        sum += a[l];        segs[sum].push_back({l, r});    }}Note, that blocks are sorted by the right end in each group.

After it you can independently try each group (there are O(n2) of them) and find the maximal disjoint set of blocks of a group. You can do it greedily, each time taking into the answer segment with the smallest right end. Since in each group they are ordered by the right end, you can find the required maximal disjoint block set with one pass. Let's assume pp is the current group of blocks (they are ordered by the right end), then the following code constructs the maximal disjoint set:

int cur = 0;int r = -1;vector<pair<int,int>> now;for (auto seg: pp)    if (seg.first > r) {        cur++;        now.push_back(seg);        r = seg.second;    }Choose the maximum among maximal disjoint sets for the groups.

Code1141G - Приватизация дорог в ДревляндииFormally, the problem is to paint tree edges in minimal number of colors in such a way, the the number of improper vertices doesn't exceed k. A vertex is improper if it has at least two incident edges of the same color.

It is easy to show that D colors is always enough to paint a tree in such a way that all the vertices are proper, where D is the maximum vertex degree. Actually, it is always the truth do any bipartite graph.

Indeed, if number of colors is less than the maximum degree, such vertices will have at least two edges of the same color (Dirichlet's principle). If D equals the maximum degree, you can use just depth first search tree traversal to paint edges in different colors.

In this problem you can have up to k improper vertices, so just choose such minimal d that number of vertices of degree greater than d is at most k. In an alternative solution, you can use a binary search to find such d, but it makes the implementation harder and the solution becomes slower by log factor.

After it paint edges with d colors, each time choosing the next color (skip color if it equals with the color of the traversal incoming edge).

Code

Editorial of Round #546(Div.2)

By DmitryGrigorev, history, 4 years ago, In English(Idea of the problem A — ----------)

1136A - Nastya Is Reading a BookIt is easy to understand that the first unread chapter is the last chapter, whom li≤k. In order to find it we can iterate through list of chapters in increasing order.

Code

(Idea of the problem B — IbragiMMamilov)

1136B - Nastya Is Playing Computer GamesNote that in any case we will open n hatches. Also, initial position of stones is : 1,1,1,1,1,1...1 (1 - the number of stones on the i-th hatch ).After any permutation of stones we will have permutation of numbers : 2,0,1,1,1,1,1... So, to open hatch with 2 stones, we need at least 2 movements. So, at all, we need at least n+1 movements(1). To get into all the hatches we need at least min(n−k,k−1)+n−1 movements.(since we can only go to the neighboring). So, at all, answer is : (n+1)+n+(n−1)+min(n−k,k−1)=3n+min(n−k,k−1).

Code

(Idea of the problem C — usertab34)

1136C - Nastya Is Transposing MatricesLet's note that after applying the operation multiset of numbers on each diagonal (which goes up and right) stays the same. Also we can get any permutation of numbers on any diagonal because we can swap neighboring elements on diagonal. So, we just need to check if the multisets of numbers on corresponding diagonals are the same.

Code

(Idea of the problem D — Denisson)

1136D - Nastya Is Buying LunchSolution 1: Let's solve the proiblem, iterating from the end, adding pupils one by one. I. e for every suffix we are solving original problem without pupils, which don't belong to this suffix. What happens when we add pupil i to the suffix?

By the time when we add pupil i we have answer for the previous suffix. In this answer there are, probably, pupils, which Nastya can't overtake. Let this subset of pupils be P. Then, if i-th pupil can give place for Nastya and all pupils from P, we will swap them. Otherwise, we can add this pupil to P. In order to check this condition we can iterate through pupils, who can swap with i-th pupil, and calculate how many are contained in P. This solution works in O(n+m). Obviously, when we consider all suffixes, answer will be n−1−|P|.

Solution 2: Let's build directed graph, where i-th vertex corresponds i-th pupil and edge from u to v exists if and only if pupil v can't give place to pupil u and v is closer to the beginning of queue than u. We can note that answer is number of vertexes in this graph, which are unreachable from Nastya's vertex. Proof:

(1) Obviously, if edge from u to v exists, pupil v will always be in front of u.

(2) If vertex v is reachable from vertex u, the same condition is true.

Let's prove that Nastya can overtake pupils, who are unreachable in graph by giving an algorithm how to do it. Let there are unreachable vertexes in front of Nastya, u - the closest from them. If u is directly in front of Nastya, they can swap and number of such vertexes will decrease.

Otherwise, let v be the next pupil after u (further from the beginning). Because u is the closest unreachable vertex, v is reachable. So, there is no edge from u to v and they can change their places. We can similarly move v further and then swap him with Nastya.

Using this algorithm, Nastya can overtake all pupils, which correspond unreachable vertexes.

Fine, now we just have to calculate number of such vertexes. It can be done with standard algorithm "DFS by complement graph".

Code

(Idea of the problem E — Ralsei)

1136E - Nastya Hasn't Written a LegendLet ti=k1+k2+...+ki−1, bi=ai−ti.

We can rewrite the condition ai+1>=ai+ki, using array b:

ai+1>=ai+ki

ai+1−ki>=aiai+1−ki−ki−1−...−k1>=ai−ki−1−...−k1ai+1−ti+1>=ai−tibi+1>=biLet's calculate arrays t and b.

So as ai=bi+ti, in order to get sum in subarray of a, we can sum corresponding sums in b and t.

Now let's find out what happens with b after addition x to position i. bi increases exactly on x. Then, if bi+1<bi, bi+1 becomes equal to bi, and so on for i+2, i+3, ..., n. Note that array b is always sorted and each addition sets value bi+x in half-interval [i,pos), where pos - the lowest index such as bpos>=bi+xTo handle these modifications, let's build segment tree on array b with operation "set value on a segment", which stores sum and maximum in every vertex. The only problem is how to find pos. This can be done with descending along the segment tree. If the maximum in the left son of current vertex is bigger or equal that bi+x, we go to the left son, otherwise we go the right son.

BONUS: solve it with modifications of elements of k.

Code

Codeforces Round #545 – Editorial

By cdkrot, history, 4 years ago, In EnglishCredits:

1138A - Sushi for Two, idea and development by KAN

1138B - Circus, idea by MikeMirzayanov, development by cdkrot

1137A - Skyscrapers, idea by jury together, development: achulkov2

1137B - Camp Schedule, idea and development by wrg0ababd

1137C - Museums Tour, idea by ch_egor, development by qoo2p5

1137D - Cooperative Game, idea and development by mingaleg

1137E - Train Car Selection, idea and development by Schemtschik

1137F - Matches Are Not a Child's Play , idea by GlebsHP, development: cdkrot

And now the editorials:

1138A - Sushi for TwoIt is more or less obvious that the answer is the maximum among the minimums of the length of two consecutive segments of equal elements. As for implementation, just go from left to right and keep the last element, the length of the current segment and the length of the next segment. When the current element is not the same as the last element, update the answer.

1138B - CircusNote, that there are only four types of artists: «0; 0», «0; 1», «1; 0», «1; 1».

So the whole problem can be described with four integers — the number of artists of each type. Let's say, that there are na «0; 0» artists, nb «0; 1» artists, nc «1; 0» artists, nd «1, 1» artists.

In the same manner, the selection of artists for the first performance can be described with four integers 0≤a≤na, 0≤b≤nb, 0≤c≤nc, 0≤d≤nd.

Note, that we have some restrictions on a, b, c, d.

In particular, we need to select exactly half of the artists: a+b+c+d=n2.

Also we have a requirement that the number of clowns in first performance (c+d) must be equal to number of acrobats in the second (nb−b+nd−d): c+d=nb−b+nd−d, so we have b+c+2d=nb+nd.

This equations are necessary and sufficient. So we have 4 unknown variables and 2 equations. We can bruteforce any two variables, calculate using them other two variables. And if everything went well, print an answer.

Complexity: O(n2).

1137A - SkyscrapersLet's examine the i-th row and j-th column, suppose the element on their intersection is xLet's denote the number of different elements less than x in the row as Lrow, and in the column as Lcol. Similarly, let's say that the number of different elements greater than x in row is Grow and in column is Gcol (L = Less, G = Greater).

Then the answer is ans=max(Lrow,Lcol)+1+max(Grow,Gcol). First summand is necessary to fit all elements <x, second is for x and the last one for >x.

Now let's find a way to compute all this 4 values.

Let's for each line and each column write down all the elements in it, sort them, delete repeating elements and save the result in such form.

Now how to find Lrow and Grow? Simply do a binary search over this list to find the element equal to x. If the length of this list is x and the position of the found element is i (0-based), then Lrow=i and Grow=k−1−i.

Similarly we can find Lcol, Gcol and solve the problem

Complexity is: O(nmlog).

1137B - Camp ScheduleIf we can't make any occurrences of string t in string s just output any permutation of s.

Otherwise, we can show that there is an optimal answer x, such that it starts with a string t.

Suppose the opposite, then remove all characters of the string s before the first occurrence of the string t and insert them to the end. The number of occurrences clearly didn't decreased.

Obviously, we want to make the next occurrence of string t in string s as left as possible. If we decide to make it somewhere else, we can move out the extra characters and try to improve the answer. To achieve this, we need to find the largest suffix of the string t that matches the prefix of string t of the same length. It can be found by using the prefix function, z-function or hashes.

1137C - Museums TourLet's build a graph where the vertices are (u, t) where u is the node for original graph and t is a day modulo d (days are indexed from 0 to d−1).

Then connect (u, t) to (v, (t+1)modd) for all edges (u,v) from original graph and find the strongly connected components of this graph. For each of the SCC compute the number of different opened museums in it. Then we just need to find a path with maximum cost that begins in SCC which contains (1, 0). We can do it with a dynamic programming on the DAG.

The key fact is that if there is a path from (u, j) to (u, j′), then there is also a path from (u, j′) to (u, j) (simply go this path in original graph d−1 times more), so we won't count some museum twice in the dynamic programming on this graph.

1137D - Cooperative GameThe count of friends you have in the problem was actually a misleading. Here is how to solve this problem with only three of them.

Let's name them fast, slow, lazy, and then consider the following process:

fast and slow moves forward, then fast only, then fast and slow again and so on until at some moment they will appear in same vertex on cycle (fast takes the lead, makes it to the cycle, circles there until slow makes it to the cycle too, and then approaches him, reducing the distance between them by 1 every 2 moves).

Here you can notice, that slow had no time to make even one full circle on cycle, because in that case fast would managed to make at least two full circles and they would meet earlier.

Let r denote the distance from finish vertex to the one fast and slow met. Then slow=t+x (1) and fast=t+?⋅c+x (2). Also fast=2⋅slow (3) as soon as fast had a move at each step and slow had only on the odd ones.

Substitute (1) and (2) into (3) and you would get t+?⋅c+x=2⋅t+2⋅x. Simplify it and take in modulo c to get −x≡t(modc), i.e. if you would now apply t moves to fast and slow they would end up in finish vertex, and if we instead somehow would manage to apply exactly t moves to all friends, all of them would end up in the finish vertex. Here is the last bit of the solution: instead of trying to compute t let's just move all friends until all of them would meet in one vertex — that vertex will be the finish one.

Described solution takes less than 2⋅(c+t) steps in the first stage and exactly t steps in the second stage, so in total it would made less than 3⋅(c+t).

1137E - Train Car SelectionThere are many approaches to this problem, many of them having O(qlogq) time, but we will describe a purely linear solution.

First, notice that for every group of cars added together, we need only to care about the first car in this group — the remaining ones will never be the answer.

Second, notice that there are some cars appended to the head of the train, then all previous cars will never be answer again, so we can simply replace them with cars with Ai=0.

So now we only need to care about operations of adding cars to the tail, and about adding the progression.

Suppose cars located at positions x and have comfort Ax.

Then observe the lower-left convex hull of points (x,Ax). One can see, that the points not lying on this hull will never be an answer.

Also note, that we can handle all progressions implicitly — suppose the progressions are described with bi, si. Then let's simply store current sums of bi and si. Then the operation of adding progression can be done by simply adding to those sums, also we don't have to track the moment the cars are added, since we can simply subtract from Ai based on sums at the moment of addition.

So when we add cars to the end we simply need to add point to the end and possibly drop some points from the end of the current convex hull. And when we add new progression, we may also need to drop some elements from the hull, but since it's the convex hull, the line coefficients between neighboring points are monotonous, so we need to drop only some points in the end of the hull.

1137F - Matches Are Not a Child's PlayFirst, let's notice, that operation "compare" is redundant and can be implemented as two "when" operations (we didn't removed it from onsite olympiad's version as a possible hint).

Suppose we know the order of the burning vertices. How it will change after "up" operation? Actually, quite simply: let's notice, that the part from previous maximum to the new one will burn the last. Actually, everything except this path burns out in the same relative order as before, and then burns the path, in order from older maximum to the new one.

Let's say, that "up" paints it's path in the color i (and i++). Then to calculate when[v], let's first get the color of vertex v. And then when[v] equals to the number of vertices of smaller colors plus the number of vertices of the same color, but which will burn before this one. The latter is simply the number of vertices on the path from older maximum to the new one in the corresponding up query.

To implement coloring on the path, we can use Heavy-Light-Decomposition. Inside every path of HLD let's store a set of segments of vertices of the same color. Then operation to color some path works in O(log2n), amortized.

The number of vertices with smaller color can be calculated with a fenwick tree (which stores for color the number of such vertices).

There are also small technical details to handle: you need to account the original order of burning out, before all up's. But since each vertex changes it's color from zero to nonzero at most once, you can do it in O(number such vertices).

Codeforces Round #544 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1133A - Middle of the Contest

Idea: MikeMirzayanov

Tutorial1133A - Middle of the ContestFirstly, let's parse both strings to four integers (h1,m1,h2,m2). Just read them and then use some standard functions to transform them into integers (or we can do it manually).

The second part is to obtain t1=h1⋅60+m1 and t2=h2⋅60+m2. Then let t3=t1+t22. It is the answer.

We have to print h3=⌊t360⌋ and m3=t3%60, where ⌊ab⌋ is a divided by b rounding down and a%b is a modulo b.

The only thing we should do more carefully is to print one leading zero before h3 if it is less than 10 and do the same for m3.

Solution1133B - Preparation for International Women's Day

Idea: MikeMirzayanov

Tutorial1133B - Preparation for International Women's DayLet cnti be the number of boxes with i candies modulo k.

Firstly, the number of pairs of boxes we can obtain using two boxes with remainder 0 modulo k is ⌊cnt02⌋.

Secondly, if k is even then we also can obtain pairs of boxes using two boxes with remainder k2 modulo k and its number is ⌊cntk22⌋.

And for any other remainder i from 1 to ⌊k2⌋ the number of pairs of boxes is min(cnti,cntk−i−1).

So, if we sum up all these values, the answer is this sum multiplied by two (because we have to print the number of boxes, not pairs).

Solution1133C - Balanced Team

Idea: MikeMirzayanov

Tutorial1133C - Balanced TeamLet's sort all values in non-decreasing order. Then we can use two pointers to calculate for each student i the maximum number of students j such that aj−ai≤5 (j>i). This is pretty standard approach. We also can use binary search to do it (or we can store for each programming skill the number of students with this skill and just iterate from some skill x to x+5 and sum up all numbers of students).

Solution1133D - Zero Quantity Maximization

Idea: BledDest

Tutorial1133D - Zero Quantity MaximizationFor each index i∈[1,n] let's try to find which d we should use in order to make i-th element of c equal to zero.

If ai=0, then ci=bi no matter which d we choose. So we should just ignore this index and add 1 to the answer if bi=0.

Otherwise, we should choose d=−biai. Let's calculate the required fraction for each index, and among all fractions find one that fits most indices (this can be done, for example, by storing all fractions in a map).

The only thing that's left to analyze is how to compare the fractions, because floating-point numbers may be not precise enough. Let's store each fraction as a pair of integers (x,y), where x is the numenator and y is the denominator. We should normalize each fraction as follows: firstly, we reduce it by finding the greatest common divisor of x and y, and then dividing both numbers by this divisor. Secondly, we should ensure that numenator is non-negative, and if numenator is zero, then denominator should also be non-negative (this can be achieved by multiplying both numbers by −1).

Solution1133E - K Balanced Teams

Idea: MikeMirzayanov

Tutorial1133E - K Balanced TeamsFirstly, let's sort all students in order of non-decreasing their programming skill.

Then let's calculate the following dynamic programming: dpi,j is the maximum number of students in at most j non-empty teams if we consider first i students.

How to do transitions from dpi,j? The first transition is pretty intuitive: just skip the i-th (0-indexed) student. Then we can set dpi+1,j+1:=max(dpi+1,j+1,dpi,j).

The second possible transition is to take some team starting from the i-th student.

The only assumption we need to do it is the following: take the maximum by number of students team starting from the i-th student is always optimally. Why it is so?

If we consider the student with the maximum programming skill in the team, we can take him to this team instad of forming the new team with this student because this is always not worse.

So the second transition is the following: let cnti be the number of students in a team if the i-th student is the first in it. We can calculate this part in O(n2) naively or in O(n) using two pointers.

We can set dpi+cnti,j+1=max(dpi+cnti,j+1,dpi,j+cnti).

Time complexity: O(n(n+k)).

Solution1133F1 - Spanning Tree with Maximum Degree

Idea: MikeMirzayanov

Tutorial1133F1 - Spanning Tree with Maximum DegreeWe can take any vertex with the maximum degree and all its neighbours. To implement it, just run bfs from any vertex with the maximum degree. See the authors solution for better understanding.

Solution1133F2 - Spanning Tree with One Fixed Degree

Idea: MikeMirzayanov

Tutorial1133F2 - Spanning Tree with One Fixed DegreeFirstly, let's remove the vertex 1 from the graph. Then let's calculate the number of connected components. Let it be cnt.

The answer is NO if and only if cnt>D or D is greater than the number of edges incident to the first vertex.

Otherwise let's construct the answer. Firstly, let's add into the new graph spanning trees of components in the initial graph without vertex 1.

Then let's add into the new graph cnt edges from vertex 1 — one edge to each component.

Then let's add into the new graph any D−cnt remaining edges from vertex 1.

The last thing we need is to construct a spanning tree of a new graph such that all edges incident to the vertex 1 are in this spanning tree (and other edges doesn't matter).

How to do it? Let's run bfs from the vertex 1 in a new graph!

Solution

Codeforces Round #543 and Technocup 2019 Final Round Editorial

By Golovanov399, history, 4 years ago, translation, In EnglishWe are sorry for not having controlled the situation about the streamed editorial and also for the broadcast message about an unethical behaviour of someone from community: here is explanatory comment to the message. When we tried to move the casino problem one position below, something went wrong leading to it being moved one position above (however, Radewoosh didn't seem to feel that something was wrong, congratulations!).

Nevertheless, we hope that you liked the problems, and those of you who decided to do something else after you knew that the round was made unrated can solve the problems when convenient (if they wish).

Problem A of final/div2 (Technogoblet of Fire)1121A - Technogoblet of FireFirst of all, each time we move someone to another school the number of schools which contain at least one Chosen One can increase at most by one. Second, if a school contains c>0 Chosen Ones, but the strongest guy in this school is not one of them, then we need to move someone at least c times to make all these chosen ones selected. Combining these two statements one can see that the answer to the problem equals the number of Chosen Ones which are currently not the strongest ones in their schools.

Problem B of div2 (Mike and Children)1121B - Mike and ChildrenNotice that the sum of sweets each child gets cannot exceed 2⋅105, so for each of numbers no more than this threshold we can store the number of ways to obtain it as the sum of two sweets. It can be done just by considering all possible (unordered) pairs of sweets and printing the maximal obtained number (of ways to represent something as sum of two sweets). Indeed, if x can be represented as a sum of two sweets in several ways then no two of them share a sweet since if ai+aj = ai+ak then aj=ak and therefore j=k.

Problem B of final/C div2 (System Testing)1121C - System TestingLet's determine for each solution when it begins being tested. It can be done, for example, by the following algorithm: let's store for each testing process the time when it becomes free to test something (initially all these k numbers are zeroes), then iterate over all solutions in the queue and for each of them we pick a process with minimal time, say that it's the time when this solution begins being tested, and then update the time when this process stops testing.

After we determined this, we can easily know for each moment the number of solutions which are completely tested before this moment, and then for each test of each solution just check the required condition of being interesting on this test.

Problem C of final/D div2/A div1 (Diana and Liana)1120A - Diana and LianaFirst of all, let's learn how to check if a perfect wreath can be obtained from the subsegment [l,r] of our liana (that is, if we can remove some flowers so that the remaining ones on [l,r] represent a perfect wreath, and this whole wreath will be cut). First, the number of other wreaths must be n−1, so the inequality ⌊l−1k⌋⋅k+⌊m−rk⌋⋅k≥n−1 must hold. Second, the segment [l,r] has to contain flowers of all required types. Finally, r−l+1 must be at least k. One can see that these conditions also guarantee that [l,r] can become a cut perfect wreath.

Now let's find for every l the minimal possible r for which the second condition holds. It can be done with the two pointers technique: if we iterate for all l from 1 to m then this r cannot become less than it was, and it's easy to update all counts and the number of insufficient flowers types both when increase l and r.

So what remains is to find out if there is any l such that the segment [l,max(r,l+k−1)] satisfies the first requirement, and if it does, then print some flowers before l which we delete (we must ensure that what remains before l is divisible by k and does not exceed (n−1)k) and some flowers from [l,r] we delete (without breaking the conditions). It's not necessary to delete anything after r, though.

Problem D of final/F div2/C div1 (Compress String)1120C - Compress StringLet's say that dp[p] is the minimal cost to encode the prefix of s with length p, the answer is dp[n]. If we want to encode the prefix with length p then the last symbol in our encoded string either equals sp, or represents some substring s[l,p] so that it occurs in the prefix of length l−1. Therefore one can see that

dp[0]=0,dp[p]=min(a+dp[p−1],min(b+dp[l−1]∣s[l,p] is a substring of s[1,l−1])).One way to implement this is to calculate this dp forward and use hashes, but it may require some efforts to avoid collisions and fit into the time limit. Another way is to find for each p all appropriate l's by calculating z-function on the reverse of s[1,p]. The total complexity in this case is O(n2).

Problem E of final/E div2/B div1 (Once in a casino)1120B - Once in a casinoSince each operation saves the alternating series of the digits, if it's different for a and b, then the answer is '-1'. Now we prove that otherwise it's possible to win.

Let's imagine that digits can be negative or bigger than 9 (that is, for example, number 19 can become the number with digits 2 and 10). Denote by ai the i-th digit of a (and similarly for b). Now there is no difference between any two orders of the same set of operations, so we can do allowed operations from left to right. After we do all operations with first digit (there are at least |a1−b1| such operations), a2 will become equal to a2+b1−a1. After we do all operations with a2 and a3 (there are at least |a2+b1−a1−b2| such operations), a3 will be equal to a3+b2−a2−b1+a1, and so on. Thus we can calculate the minimal total number of operations and find their set. The goal is to prove that it's possible to perform them in some order and never break the rules about the correctness of intermediate numbers.

Indeed, let's just perform these operations from left to right. Assume that we can't perform the current operation. Without loss of generality assume that we can't decrease two digits: one of ak and ak+1 is 0 now. It's easy to see that ak>0 because after we perform the set of our operations ignoring the rules, ak will become bk, which is nonnegative. Hence ak+1=0. Then we must increase ak+1 and ak+2 at least once (again because we can ignore the rules and get bk+1 in the end). If we can do it then we do it and then decrease ak and ak+1 just as planned and then continue performing the operations. Otherwise, ak+2=9. Reasoning similarly, either we can decrease ak+2 and ak+3, or ak+3=0, et cetera. As it can't continue infinitely, we can perform some operations from our set and decrease ak and ak+1, so we can reach the goal doing the minimal number of operations.

Problem F of final/D div1 (Power Tree)1120D - Power TreeOne can see that the problem doesn't change if we want to be able to obtain any possible combination of numbers in leaves from the all-zero combination.

Solution 1. Let v1, v2, ..., vl be the indices of all leaves in the order of any Euler tour. Let ai be the number written in vi. We say that v0=vl+1=0. Denote the difference ai+1−ai by di. We want to be able to obtain an arbitrary sequence d0, ..., dl with zero sum.

Imagine that we bought a vertex u whose subtree contains exactly leaves from vi to vj. Applying the operation to this vertex with number x means increasing di−1 by x and decreasing dj by x without affecting all other differences.

Let's build new graph with vertices from 0 to l. Each such vertex u represents an edge connecting vertices (i−1) and j with weight cu. To be able to get every possible sequence with zero sum it's needed and sufficient for the graph with picked edges be connected. Now we want to know what is the weight of a minimal spanning tree and which edges can be in it. Both can be found by, for example, Kruskal's algorithm.

Solution 2. We say that a vertex u covers a leaf v if it's in u's subtree.

One can see that we can buy a set of vertices iff for each vertex u there is at most one leaf in its subtree which is not covered by any of bought vertices from the subtree. Indeed, if there are at least two such leaves then the difference between their values never change. On the other hand, if this holds, we can set the required values in the bought vertices in the order of increasing depth, performing the needed operation each time we are in vertex whose subtree contains a leaf which is not covered by any bought vertex in the subtree except the one we consider.

So we calculate ans[v][k] where 0≤k≤1 where this value means the minimal possible cost where in the subtree of v there are k not covered leaves. It can be shown that these values are enough to calculate the answer.

Problem G of final/E div1 (The very same Munchhausen)1120E - The very same MunchhausenDefine the balance of a number x as S(nx)⋅n−S(x). By the balance of a digit string we mean the balance of the corresponding number.

Solution 1. We are gonna do the following:

Find out if the solution exists. If no, print -1 and exit.Find any string with negative balance.Find any string with positive balance.Take their linear combination with zero balance (maybe we pad the numbers we found by leading zeroes before this). By linear combination of several strings we mean their concatenation where each of them can occur several times.It is quite clear how to perform the last step. To perform the initial step it's convenient to introduce some lemmas.

Lemma 1. S(a+b)≤S(a)+S(b).

Proof. It's obvious more or less since if we write both numbers one under another and start calculating their sum then the result will have sum of digits being equal to S(a)+S(b) minus 9 times the number of carries.

Lemma 2. S(ab)≤aS(b).

Proof. S(ab)=S(b+b+…+b)≤S(b)+S(b)+…S(b)=aS(b). Here the inequality holds according to Lemma 1.

Lemma 3. S(ab)≤S(a)S(b).

Proof. Let a=an−1an−2…a1a0¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯. Then

S(ab)=S(an−1b⋅10n−1+an−2b⋅10n−2+…+a0b)≤S(an−1b⋅10n−1)+S(an−2b⋅10n−2)+…+S(a0b)==S(an−1b)+S(an−2b)+…+S(a0b)≤(an−1+an−2+…+a0)S(b)=S(a)S(b).Now consider two cases.

a=2d1⋅5d2.Let b=10max(d1,d2). One can see that

a⋅S(an)=a⋅S(bnb/a)=aS(b/a)⋅S(b/a)⋅S(bnb/a)≥aS(b/a)⋅S(bn)=aS(b/a)⋅S(n).That means that if a>S(b/a) then the answer doesn't exist, otherwise the number b/a has non-positive balance. One can easily see that the number 1 always has non-negative balance, so in this case the problem is solved.

a has a prime divisor which is not 2 and not 5.It turns out that in this case the answer always exists. Indeed, the decimal fraction 1/a is infinite, that means that S(10ka) in nondecreasing and can be sufficiently large; and so can be S(10ka+1) since the number of trailing 9-s of 10ka is bounded. Meanwhile S(a⋅(10ka+1)) is bounded by, say, 1+9⋅len(a), so we always can find a string with negative balance, and, as we mentioned above, the number 1 always has nonnegative balance.

We know two ways to perform the second step.

Divide 1 by a and find the period. Let's say that the period can be represented as a string s and the part before it by a string t (possibly empty). Let s′ have the same length as s and equal (s+1) when being treated as an integer. We are looking for a string of type tsss…ss′ with negative balance. One can calculate the impact on balance of strings t, s and s′ and therefore find the minimal required number of stings s.Construct a weighted directed graph. Its vertices are numbers from 0 to a−1, and for each pair of numbers (c,x)≠(0,0) with 0≤c<a and 0≤x≤9 there is an edge from c to ⌊ax+c10⌋ with weight (ax+c)(mod10) and label x. Informally, if we traverse through some path from 0, and labels of the edges on this path are digits of some number n from right to left, then the sum of weights are the current balance of an (that is, if we consider only last len(n) digits when calculating the balance) and the last vertex represents the current carry. Now we can find a negative cycle in this graph via Ford-Bellman algorithm and then construct a path from 0 to this cycle, go through the cycle required number of times (so that the final sum of weights is negative) and then return to the zero vertex.This solution has a disadvantage: the final answer can have a length up to S(n)⋅n2. One workaround is to find, say, 300 different possibilities of negative balance (by taking more periods/negative cycles) and find the positive balance string by trying all numbers from 1 to 10000 and constructing a string with a small balance divisible by any of negative balances. It can be done by a sort of knapsack on found positive balances. The idea is to get a big gcd of the two found balances so that we don't need to repeat the negative-balance-string too many times (because among the two found strings it is the one which can have a superlinear length).

Solution 2. Imagine we have infinite time and memory. Then we can say that we have states of kind (carry,balance) similar to the states of the graph from solution 1, where for each state (carry,balance) and each digit x (except state (0,0) and digit 0 at the same time) there is a transition to ((carry+a⋅x)(mod10),balance+a⌊carry+a⋅x10⌋−x). Our goal is to reach (0,0) again. One can bfs over this (infinite) graph with creating new states, when needed. However, traversing over this graph consume too much memory.

It turns out that if we don't consider states with |balance|>a then there always is a solution, and this is relatively easy to come up with (and definitely easier to pass than the previous one).

Problem H of final/F div1 (Secret Letters)1120F - Secret LettersConsider any optimal solution. Consider all letters of W between two times when P visits R. It's clear that

maybe the first of these messages is sent via R,some of the last messages are also sent via R,all other messages are sent via O.The sense behind shipping the first message via R is to obtain all messages which are currently stored there. If the first message is sent via O, and some of the others is sent via R, then we can swap them thus paying less. On the other hand, once we got all these letters, it makes sense to send something through R iff ct≤d where t is the time between the moments when we send this message and when P visits R to obtain it. The same holds if we swap W and P.

Denote by ans[i] the minimal possible cost of the first (i−1) letters if the i-th is sent through R.

Also denote by ans_delay[i] the minimal possible cost of the first (i−1) letters if the i-th is sent through R and if R has already kept exaclty one letter. To calculate these values we can each time try every possible number of last letters sent through R. This takes O(n2) time.

One can observe that if we fix the left bound of letters sent through R then the cost depends linearly on the time ti which we are calculating this for, and since we need the minimum of linear functions each time then we can use convex-hull trick which gives us O(n) or O(nlogn) complexity.

Codeforces Round #542 [Editorial]

By zoomswk, 4 years ago, In EnglishThanks for participating; we hope you enjoyed the tasks! Look at the bottom of this post for some more challenges.

Feel free to ask in the comment if you have any question. If you have a different solution from ours, share it too. :D

Our approachesDiv2A1130A - Be PositiveTutorial is not available

Div2B1130B - Two CakesTutorial is not available

Div2C1130C - ConnectLet S be the set of cells accessible from (r1,c1).

Similarly, let T be the set of cells accessible from (r2,c2).

We can find S and T using a search algorithm such as a DFS or a BFS.

If S=T, then a tunnel is not needed, so the answer is 0.

Otherwise, we need to create a tunnel with an endpoint in A and the other in B. Now, we can simply iterate through all possible pairs of cells ((x1,y1),(x2,y2)) where (x1,y1)∈S and (x2,y2)∈T to find one that minimizes the cost (i.e., (x1−x2)2+(y1−y2)2).

The time complexity is O(n4).

Div1A / Div2D1129A2 - Toy TrainWe can consider the pickup requests from each station individually. The overall answer for some fixed starting station is simply the maximum time needed to fulfill deliveries among all pickup stations.

Suppose the starting station for the train is fixed at some station s (1≤s≤n).

Consider some station i (1≤i≤n). Let out(i) denote the number of candies that need to be picked up from station i. If out(i)=0, we do not consider this station. From now on, we assume out(i)≥1. Each time that the train visits station i to pick up a candy, we can choose which candy it should pick up. Therefore, we should find an order that would minimize the time needed to fulfill all deliveries from pickup station i. It turns out, however, that the only thing that matters is the last candy to be delivered. Suppose the last candy is to be delivered to station e, the total time needed to fulfill all pickup requests from station i would be: dist(s,i)+n∗(out(i)−1)+dist(i,e), where dist(a,b) represents the time needed to travel from station a to station b. Take some time to think why this is the case! With this formulated, it is now clear that we have to choose the last candy to deliver that minimizes dist(i,e).

All of this can be done in O(n) (with an O(n+m) pre-process only once to find the optimal last candy for each pickup station). To find the answer for every starting station for the train, we can simply run the above algorithm n times.

The time complexity is O(n2+m).

Div1B / Div2E1129B - Wrong AnswerSuppose a0=−1 and ai≥1 for each 1≤i<n. Let S=∑i=0n−1ai.

Assume also that n≥2.

It is easy to see that Alice's algorithm produces (n−1)(S+1) as the answer. Meanwhile, there are two possible correct answers: either nS or (n−1)(S+1), whichever is greater.

Assume further that a1≥2. The correct answer for this array is then nS. The difference between these two results is nS−(n−1)(S+1)=S−n+1.

Now, we can easily create array a greedily so that S−n+1=k.

The time complexity is O(n).

Div1C1129C - Morse CodeWe will be computing the answers offline instead of doing so immediately after each modification.

Let T=Sreversed. Now, we need to find the number of English sequences that, if considered backward, would translate into some substring of each suffix of T.

Let f(l,r) be the number of English sequences that translate to exactly T[l..r].

Let g(l,r) be sum of f(l,x) over all l≤x≤r.

Note that f(l,r) can be calculated with dynamic programming for all 1≤l≤r≤m in O(km2) where k denotes the longest length of an English alphabet in Morse code (which is 4). Following that, we can calculate g(l,r) for all 1≤l≤r≤m in O(m2).

The answer for the suffix T[x..m] is simply the sum of g(i,m) over all x≤i≤m subtracted by the number of over-counted English sequences. The number of over-counted sequences can be calculated by considering the suffix array of T. Namely, for each two adjacent suffixes in the list, we over-counted them by g(l,r) with l and r denoting the corresponding indices of their longest common prefix (LCP).

Therefore, the answer for T[1..m] is ∑1≤i≤mg(i,m) subtracted by the sum of g(l,r) of the LCP between each pair of adjacent suffixes.

Transitioning to solve the problem for T[x′..m] where x′=x+1 can be done efficiently, since the removal character of the string affects only one entry in the suffix list.

To sum up, we find g(l,r) for all valid l and r in O(km2). Then, we sort the suffixes naively in O(m2logm), before computing the answer in the final step in O(m2).

The time complexity is O(km2+m2logm).

Div1D1129D - IsolationLet f(l,r) be the number of integers that appear exactly once in the segment a[l..r]. We can use the following recurrence to compute the answer: dp(n)=∑0≤i<n∧f(i+1,n)≤kdp(i), where dp(0)=1.

A naive O(n2) implementation will definitely be too slow. To compute the said recurrence efficiently, we will do as follows.

Preparation

First, let's design an array b so that f(l,r) is the sum of elements in segment b[l..r] for some fixed r. Ideally, it should be easy (i.e., require only a few operations) to transform this array b into another array b′ that would work with r′=r+1 instead.

One design is as follows. First, let each entry of b be 0. This array now works imaginarily when r=0. To make it work for r′=r+1, consider the element ar+1.

If this value appeared before at least twice, set bi=0 where i is the second-last appearance of ar+1 (not counting the appearance at index r+1).If this value appeared before at least once, set bi=−1 where i is the last appearance of ar+1.Finally, set br+1=1.Now, you can see that the sum in the segment b[l..(r+1)] correctly represents f(l,r+1) for any 1≤l≤r+1!

The Real Thing

Let us divide the array into k blocks so that each block contains nk elements (assume for simplicity that k divides n). Each block corresponding to some segment [L..R] should store (1) sum of elements in b[L..R] (i.e., f(L,R)) and (2), for each −nk≤i≤nk, q(i)= sum of dp(x−1) where f(x,R) is less than or equal to i. A modification to bj for some index j will require an O(nk) update.

With array b ready for our r, we are ready to compute dp(r). Let t be a temporary variable initially equal to 0. For each l≤r that belongs to the same block as r, add dp(l−1) to dp(r) if f(l,r)≤k, and also add bl to t. This runs in O(nk). To account for the left possible endpoints from other blocks, for each block, starting from one directly to the left of the block that contains r to the leftmost block:

Suppose this block corresponds to the segment [L..R].Let x=k−t.If x<−nk, do nothing.If −nk≤x≤nk, add q(x) to dp(r).If nk<x, add q(nk) to dp(r).Add f(L,R) to t.The step above runs in O(k). That is, our algorithm takes O(k+nk) time to compute dp(r) for some r.

The time complexity is O(nk+n2k), since there are n values of r that we need to compute dp(r) for.

If we choose k=n−−√, our solution would run in O(nn−−√).

Div1E1129E - Legendary TreeIn this analysis, let V be the set of all vertices. We will use tuples of the form (S,T,v) to represent queries.

First, we will root the tree at vertex 1. The size of each subtree can be found in n−1 queries by asking ({1},{2,3,…,n},i), for each 1≤i≤n.

Suppose sz(i) denotes the size of the subtree rooted at vertex i. Let us sort the vertices (and store the results in v) so that sz(vi)≤sz(vi+1) for each 1≤i<n.

We will find all children of each vertex vi in the ascending order of i. While we do so, we will maintain a set X, initially containing only v1. It will store the processed-so-far vertices whose parents have not been found.

Namely, for each 2≤i≤n:

Let k=({1},X,vi). This is the number of direct children that vi has.Let x1,x2,…,x|X| be the vertices in X in an arbitrary order.For k times: binary search to find the smallest m such that querying ({1},{x1,x2,…,xm},vi) returns a non-zero result and remove xm from X. For each such m, we know that there is an edge (xm,vi).Add vi to X.This solution asks at most 2(n−1)+(n−1)log2n queries.

Time complexity: O(n2logn)ChallengesDiv2CCan you do better than ?

There's a nice  solution, but you could also use a Voronoi diagram for an  runtime too!

Div1A / Div2DDevelop from our  approach to solve the task in linear time!

Div1CSolve the task when m can be up to 105!

Codeforces Round #541 Editorial

By ch_egor, 4 years ago, translation, In English1131A - Sea BattleLet's classify marked squares to two groups. First group will consist of cells that are neighboring by corner to ship. There are exactly 5 such corners. Second group will consist of cells that are neighboring by side to ship. Number of such squares is equal to length of perimeter of a ship.

Thus answer is equal to 2⋅(w1+h1+h2)+4.

(Developing and idea — vintage_Vlad_Makeev)

1131B - Draw!Since some scores are already fixed, we only have "liberty" in between of them.

One can easily see, that basically we need to solve the problem between each neighboring pair and then sum all the answers (it may turn out, that for a fixed score, it will be accounted twice, in the "left" pair and in the "right", but it's easy to subtract it back).

How to solve the problem between score (a,b) and (c,d)? We want to put in the middle as much pairs (x,x) as possible. So we have a≤x≤c and b≤x≤d, hence max(a,b)≤x≤min(c,d), it's easy to count the number of such x's and you can also see, that there is a goal sequence which achieves all such (x,x)'s together.

(Developing and idea — MikeMirzayanov)

1131C - BirthdayThe solution is greedy one.

Suppose we have reordered ai, so that ai≤ai+1.

Then I claim that the answer can be built as follows:

First write all elements with even indices and then all elements with odd indices in reversed order.

For example, if n=5: we get a1,a3,a5∣a4,a2 and if n=6: a1,a3,a5∣a6,a4,a2.

One can "check on many tests" that it works in practice, but here goes the proof:

Note, that the solution provides answer which is at most maxai+2−ai.

Let's show that for every i, answer must be at least ai+2−ai. To do this, draw all ai's as a graph. Then the solution to the problem is some Hamiltonian cycle.

Let's suppose that ai+2−ai is prohibited to us (and all jumps containing this one).

Red denotes the forbidden jumps. One can easily see, that ai+1 is a cut point, and no hamiltonian cycle is possible. This concludes our proof!

(Developing — cdkrot, idea — jury)

1131D - Gourmet choiceThis task has different possible solutions.

One of them is as follows — make a DSU for all n+m dishes (Disjoint Set Union data structure, https://en.wikipedia.org/wiki/Disjoint-set_data_structure), and unite all dishes that should be evaluated with the same number according to the table (unite dishes i and n+j if aij equals "=".

Then create graph. We will iterate over all i, j and add a directed edge in some direction between the sets, corresponding to the i and j, if one of them is better, then the other.

In case the graph has a self-loop or cycle, it's easy to see that the answer is impossible. Otherwise assign numbers, where the vertex gets the least number greater than the vertex it goes to. This is the answer.

(Developing — Sehnsucht, idea — Helen Andreeva)

1131E - String MultiplicationLet's notice, that the string multiplication is associative, that is (a⋅b)⋅c=a⋅(b⋅c). So instead of left "(a⋅b)⋅c" given in statement, let's use "a⋅(b⋅c)"

That is, we have sn, then go to sn−1⋅sn, then sn−2⋅(sn−1⋅sn) and so on.

One can also solve the problem without observing the associativity property and going with s1→s1⋅s2→(s1⋅s2)⋅s3 and so on. However there is one caveat. Since the string grows very fast, "an answer" will grow as well.

And while you are promised that the answer is at most 109, observe the following situtation: s1,s2,...,s100 are "aaaaaaaaaaaaaaaaaaaa", which makes an answer quite large, but if you add a s101 equal to "c" it collides to a mere 1, so it requires some careful handling, basically store for every value x you want value min(x,109). Going in another direction has an advantage, that if some value is large it will stay large for life, so since answer is 109 no overflows will happen.

Now back to the suggested solution.

Let's proceed as sn→sn−1⋅sn→sn−2⋅(sn−1⋅sn) and so on.

Note, that it's enough to store not whole the current string si⋅…⋅sn, but just some basic information about. Let's simply store:

The length of the largest substring of a single characterWhether the string consists of the single character or notThe left and the right character of itThe length of the prefix, which consists of a single character and the same for the suffix.It's easy to see that if you know such values for some string si⋅…⋅sn, you can also compute it for si−1⋅si⋅…⋅sn (here, the brackets are assumed as in a⋅(b⋅c)).

(Developing and idea — VFeafanov)

1131F - Asya And KittensIn this problem we are given a disjoint set union process with n−1 steps, merging n initial 1-element sets into one n-element set. We have to put elements into a linear array of cells, so that the cells to be joined at each step of the process were immediate neighbours (i.e. not separated by other cells).

This problem can be solved in O(nlogn) or in O(nα(n)) (where α(n) is the inverse Ackermann function) via standard disjoint-set data structure, additionally storing lists of elements in each set.

The simplest solution is based on a set-size version of rank heuristic:

storing mapping from item to id (representative) of its current set, and the inverse mapping from set to the list of its elementswhen we have to merge two sets A and B, we make the smaller set part of the larger set and update mappings, assigning new set ids for elements in O(min(|A|,|B|)) and concatenating the lists (can be done in O(1) or in O(min(|A|,|B|)))This gives us O(nlogn): element can not change its set more than logn times, because the change leads to (at least) doubling of the element's set size.

In order to get O(nα(n)), we have to use the disjoint set structure with both path compression and rank heuristics, plus concatenation of lists should be done in O(1).

(Developing and idea — Sender)

1131G - Most Dangerous SharkThis problem can be solved using dynamic programming technique.

Let dpi be minimum cost to fall first i dominoes. If i-th domino was dropped to the right dpi=min(dpj+ci) over such j that dropped i-th domino will fall all dominoes from j+1 to i. Otherwise, some other domino was dropped to the right and fell domino i. Then dpi=min(dpj−1+cj) other such j, that j-th domino dropped to the right will fall i-th domino. Such solution works in O(m2).

We need to speed up this solution. We need to find possible j for each i faster. At first let's notice, that possible j's forms subsegments, so we need just find most right j. This can be done using stack technique like finding nearest element greater than current.

Another part of the solution, we need to optimize is taking range minimum query of dp's. That can be easily done using segment tree technique or fenwick tree technique, however it requires O(logm) time per query which is too slow. To make it faster we can use stack technique again! Let's maintain stack of increasing values of dpi (or dpi+ci, depending on case). Because segments on which we are taking minimum are nested or non-intersecting we can always drop all values after the optimum for each query. Using amortized analysis technique, we can see that such solution works in O(m).

(Developing and idea — voidmax)

Codeforces Round #540 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1118A - Water Buying

Idea: MikeMirzayanov

Tutorial1118A - Water BuyingThe answer can be calculated by easy formula: ⌊n2⌋⋅min(2a,b)+(n % 2)⋅a, where ⌊xy⌋ is x divided by y rounded down and x % y is x modulo y.

Solution1118B - Tanya and Candies

Idea: MikeMirzayanov

Tutorial1118B - Tanya and CandiesLet's maintain four variables oddPref, evenPref, oddSuf and evenSuf, which will mean the sum of ai with odd i on prefix, even i on prefix, odd i on suffix and even i on suffix. Initially, oddPref and evenPref are 0, oddSuf equals to the sum of ai with odd i in a whole array and evenSuf equals to the sum of ai with even i in a whole array.

Let's iterate from left to right over all elements of the array. Let's consider the current element ai. If i is even, then set evenSuf:=evenSuf−ai, otherwise let's set oddSuf:=oddSuf−ai. Then let's consider we give the current candy to dad. Then we have to increase the answer if oddPref=evenSuf and evenPref=oddSuf. Then if i is even then let's set evenPref:=evenPref+ai, otherwise let's set oddPref:=oddPref+ai.

Solution1118C - Palindromic Matrix

Idea: MikeMirzayanov

I should mention this blog because it is amazing! This is a tutorial of this problem from MikeMirzayanov.

Tutorial1118C - Palindromic MatrixBasically, what does the matrix being palindromic imply? For each i,j values in cells (i,j), (i,n−j−1), (n−i−1,j) and (n−i−1,n−j−1) are equal (all zero-indexed). You can easily prove it by reversing the order of rows or columns and checking the overlapping cells in them.

Thus, all cells can be split up into equivalence classes. The even n case is simple: all classes have size 4. The odd n case has classes of sizes 1, 2 and 4.

Let's fill the classes one by one. Obviously, the order between the classes of the same size doesn't matter. I claim that filling the classes in order 4,2,1 in sizes construct the answer if any exists. The key observation is that each next size is divisible by the previous one.

The implementation can come in lots of different forms and complexities. Mine works in O(MAXVAL+n2), you can refer to it in attachment.

Solution1118D1 - Coffee and Coursework (Easy version)

Idea: MikeMirzayanov

Tutorial1118D1 - Coffee and Coursework (Easy version)Since the number of days doesn't exceed n, let's iterate over this value (from 1 to n). So now we have to check (somehow), if the current number of days is enough to write a coursework.

Let the current number of days be k. The best way to distribute first cups of coffee for each day is to take k maximums in the array. Then we have to distribute second cups for each day. Let's also take the next k maximums in the remaining array, and so on.

How do we can calculate such a thing easily? Let's sort the array a in the reversed order (before iterating over all numbers of days), then the following formula will work fine for the current number of days k: ∑i=1nmax(0,ai−⌊i−1k⌋).

So if the value of the formula above is greater than or equal to m then the current number of days is enough. If there is no any suitable number of days, the answer is -1.

Solution1118D2 - Coffee and Coursework (Hard Version)

Idea: MikeMirzayanov

Tutorial1118D2 - Coffee and Coursework (Hard Version)Well, the main idea is described in the previous (D1) problem editorial. Read it firstly.

So, now we have to improve our solution somehow. How can we do it? Wait... What is it? We iterate over all numbers of days... And the number of pages Polycarp can write when we consider k+1 days instead of k is strictly increases... (because we always can drink any cup even with the minimum value of ai as a first during the new day, and the number of pages will increase). So, what is it? Oh, this is binary search!

So all we need is to replace linear search to binary search, submit the written code and get AC.

Solution1118E - Yet Another Ball Problem

Idea: MikeMirzayanov

Tutorial1118E - Yet Another Ball ProblemThe first observation: we cannot construct more than k(k−1) pairs at all due to second and third rules.

The second observation: we always can construct an answer which will contain all k(k−1) pairs (and get some prefix of this answer if we need less than k(k−1) pairs). Ho do we do that?

Let man's costumes colors be in the following order: 1,2,…,k;1,2,…,k;1,2,…,k and so on. Now we have to set some colors to woman's costumes. The first thing comes to mind is to use some cyclic shift of 1,2,…,k. And it is the best thing we can do! So let women's costumes colors be in the following order: 2,3,…,k,1;3,4,…,k,1,2;4,5,…,k,1,2,3 ans so on. So we use each cyclic shift of 1,2,…,k in order from second to last. The maximum number of pairs can be obtained when k=447 and the number of such pairs is n=199362.

So now we have to prove that second, third and fourth rules are satisfied (or write a stress test, it is not so hard to do it). The easiest way to prove all rules are satisfied is the following: if some element x in the left part has position i (let's consider all positions modulo k) then each element x in the right part will have all positions expect i in order i−1,i−2,…,i−k+1 (you can see it from our placement). Now we can see that all rules are satisfied because of such a placement.

Solution1118F1 - Tree Cutting (Easy Version)

Idea: MikeMirzayanov

Tutorial1118F1 - Tree Cutting (Easy Version)Let's root the tree by some vertex. The edge (v,u), where v is the parent of u, is now nice if and only if the subtree of u contains either all red vertices of the tree and no blue vertices or all blue vertices of the tree and no red vertices. That's because removing that edge splits the tree into the subtree of u and the component of every other vertex.

Thus, the task is to calculate the number of red and blue vertices in each subtree with dfs and check a couple of conditions.

Overall complexity: O(n).

Solution1118F2 - Tree Cutting (Hard Version)

Idea: MikeMirzayanov

Tutorial1118F2 - Tree Cutting (Hard Version)Okay, this solution is really complicated and I would like to hear nicer approaches from you in comments if you have any. However, I still feel like it's ok to have this problem in a contest specifically as a harder version of F1.

Let's start with the following thing. Root the tree by some vertex. For each color take all vertices of this color and paint their lowest common ancestor the same color as them. The purpose of that will come clear later. Why can we do this? The case with lca = some vertex of that color is trivial. Now, take a look at the edges from lca to its subtrees. At least two of them contain a vertex of that color. You can't cut the edges to these subtrees because this will make vertices of the same color belong to different components. Thus, lca will always be in the same component as these vertices.

If lca is already painted the other color then the answer is 0. That's because lca once again make vertices of the same color belong to different components.

Now everything will be calculated in a single dfs. Let dfs(v) return one of the following values:

0, if there is no colored vertex in the subtree of v;x, if there exists some color x such that vertex v has vertices of color x in its subtree and vertex v has ancestors of color x (not necesserily direct parent);−1, otherwise.I claim that if there are multiple suitable colors for some vertex v then the answer is 0. Let's take a look at any two of them and call them colors x1 and x2. For both colors take a path from arbitrary vertex of that color in subtree to arbitrary vertex of that color that is ancestor of v. You can't cut any edge on these paths because that will divide the vertices of the same color. Now, either path for color x1 contains vertex of color x2 or path for color x2 contains vertex of color x1. That vertex is the upper end of the corresponding path. That means that component of one color includes the vertex of the other color, which is impossible.

Moreover, that's the last specific check for the answer being 0. The step with lca helped us to move to the ancestor instead of any vertex in the upper subtree of v. I truly believe that you can avoid lca in this solution, however, that will make both implementation and proof harder.

Now let's do dp[v][2] — the number of ways to cut some edges in the subtree of v so that: 0 — the component with vertex v has no colored vertices in it, 1 — has some colored vertices. Generally, the color itself for 1 doesn't matter. If for some child u of v: dfs(u) returned color x then it must be color x in that component, otherwise the color doesn't matter. For −1 all vertices of each color presented in the subtree of u are contained within the subtree of u.

The transitions will be of form "do we cut the edge from v to u or not" for all children u of v. That is the most tedious part so I'm sorry if I mess up something the way I did with my author solution :D

Here from now I'll ignore the children that returned 0 (if I say all children, I will mean all non-zero returning children) as they add nothing to the answer.

If there are no children, then the vertices with av=0 will have dp[v][0]=1, dp[v][1]=0 and the other vertices will have dp[v][0]=0, dp[v][1]=1.

Basically, there are two main cases. I would recommend to follow the code in attachment while reading this, tbh.

av=0 and all children dfs returned −1. Then for each edge to the child you can either cut it if there are colored vertices (take dp[u][1]) or don't cut it if it has no colored vertices (take dp[u][0]). So dp[v][0]=∏u∈g(v)(dp[u][0]+dp[u][1]). For v to have some color you'll need to push that color from exactly one of the children. You can't choose two subtrees because they are guaranteed to have different colors in them (otherwise they wouldn't return −1). So dp[v][1]=∑x∈g(v)∏u∈g(v),u≠xdp[x][1]⋅(dp[u][0]+dp[u][1]). To calculate that fast enough you'll need to precalculate prefix and suffix products of (dp[u][0]+dp[u][1]).av≠0 or av=0 but some children returned the same value x≠−1. Then you are required to make v the part of component with vertices of color x. That means that dp[v][0]=0 for that case. For children, who returned x, you don't cut their edge (take dp[u][1]). For the other children you can either cut it if there are colored vertices (take dp[u][1]) or don't cut it if it has no colored vertices (take dp[u][0]). Thus, dp[v][1]=(∏u∈g(v),dfs(u)=−1(dp[u][0]+dp[u][1]))⋅(∏u∈g(v),dfs(u)≠−1dp[u][1]).The answer will be stored in dp[root][1] after that.

Overall complexity: O(nlogn) but I'm sure this can be rewritten in such a manner that it becomes O(n).

Solution

Codeforces Round #539 Editorial

By aleex, history, 4 years ago, translation, In English1113A - Sasha and His TripWhen n−1<v the answer is n−1. Else you must notice, that it is optimal to fill the tank as soon as possible, because if you don't do that, you will have to spend more money in future. So to drive first v−1 kilometers just buy v−1 liters in the first city, then to drive between cities with numbers i and i+1, buy liter in the city with number i−v+1.

Author's solution

1113B - Sasha and Magnetic MachinesFirst notice that if we divide some number by x, then to get the minimal sum, it is optimal to multiply by x the smallest number in the array. So now precalculate the sum of the initial array and the minimal ai, then you can check all possible x for every ai, and choose the best variant. So the complexity is O(n⋅ai).

Author's solution1109A - Sasha and a Bit of RelaxNotice, that if al⊕al+1⊕…⊕amid=amid+1⊕amid+2⊕…⊕ar then al⊕al+1⊕…⊕ar=0 (it comes from the fact that for some integers A, B, C if A⊕B=C then A=B⊕C).

Now we have another task. How many are there pairs (l,r) that r−l+1 is even and al⊕al+1⊕…⊕ar=0.

Precalculate array prefi=a1⊕a2⊕…⊕ai. Then al⊕al+1⊕…⊕ar=prefr⊕prefl−1. So if prefr⊕prefl−1=0 then prefr=prefl−1.

So again we should solve another thask, which is equivalent to original one. How many are there pairs (l,r) that r−l+1 is even and prefr=prefl−1.

So to count the answer just have two arrays cnt[0][x] to store elements from even positions and cnt[1][x] for odd positions. Then iterate i from 1 to n and add to the answer cnt[imod2][prefi]. After you processed i, increase cnt[imod2][prefi] by 1.

Author's solution1109B - Sasha and One More NameLet's s be the given string, n  — it's length. If s consists of n or n−1 (when n is odd) equal characters, then there is no way to get the answer. Otherwise, let's prove that the answer can be always reached in two cuttings. Let's the longest prefix of s, that consists of equal characters has the length equal to len−1. Cut pref=s[1…len] and suff=s[n−len+1…n], and call the remaining piece as mid. Swap pref and suff, then unite all three parts together. The central part (mid) will stay unchanged, pref≠reverse(pref) and pref≠suff then pref+mid+suf≠suf+mid+pref. So now we can get the answer in two cuttings. Finally you must chech if it is possible to get the result by making just one cutting. As soon as one cutting is equal to some cyclic shift, then our task is to check if there is a cyclic shift which is a palindrome and not equal to s. It can be done by fixing each cyclic shift and checking each one separately.

Complexity: O(n2)Bonus: Try to solve this task in linear time without using any string algorithm.

Author's solution Solution of bonus task1109C - Sasha and a Patient FriendLet's keep not deleted pairs (t,s) in a treap where t will be the key of some node.

Also we need some auxiliary variables. So each node in the treap will store that:

time  — time of the eventspeed  — speed of the tap since second timetL, tR  — the minimum and the maximum time in the subtree of that nodespeedR  — the speed of the event with maximum time in the subtree of that noderes  — the value of patience after processing all events from the subtree (we assume that the value before tL-th second is 0)mn  — what is the minumum value of patience if we process all events from the subtree (also initial value is 0)links to the left child and to the right childIt turns out that this information is enough. Now to make treap work correctly it should be possible to merge two chilrens of some node. Let's look how to do it (suppose that this node has either left child (LC) or right child (RC)):

time doesn't changespeed doesn't changetL=LC.tL, tR=RC.tR, speedR=RC.speedRIt is easier to calculate res and mn simulatenously. Look at this block of code:

mn = 0, res = 0  mn = min(mn, LC.mn)  res += LC.res + LC.speedR * (time - LC.tR)  mn = min(mn, res)  res += speed * (RC.tL - time)  mn = min(mn, res + RC.mn)  res += RC.res  mn = min(mn, res)  It goes through all possible periods of time where mn can be, and finds the best one, during this it calculates res.

If there is no left or right child then the calculation doen't change too much.

So if you have combine function then you can do insert, delete, split, merge.

You can answer queries of the 3-rd type in the following way. Cut out the needed range from the treap. And go down the treap starting from the root while you can (you go to the left child, if the value of patience becomes equal to 0 earlier than time, you can check that using the imformation stored in nodes, then check the right one if it is needed). So it is left to consider some extreme cases, which I leave you as and exercise, and that is all.

The complexity is O(q⋅log(q)). If you don't like treaps, you can actually use segment tree on pointers, or make coordinate compression and write a simple segment tree, the complexity will stay the same.

Author's solution1109D - Sasha and Interesting Fact from Graph TheoryLet's fix edges  — the number of edges on the path between a and b. Then on this path there are edges−1 vertices between a and b, and they can be choosen in A(n−2,edges−1) ways. The amount of ways to place numbers on edges in such a way, that their sum is equal to m, is (m−1edges−1) (stars and bars method). If an edge doesn't belong to out path, then doesn't metter what number is written on it, so we can multiply answer by mn−edges−1. Now, we want to form a forest from remaining n−edges−1 vertices and to hang it to any of edges+1 vertexes from our path. According to one of generalizations of Cayley's formula, number of forsests of x vertices, where vertices 1,2,…,y belong to different trees is f(x,y)=y⋅xx−y−1. So for fixed edges we got the formula trees(edges)=A(n−2,edges−1)⋅f(n,edges+1)⋅(m−1edges−1)⋅mn−edges−1Complexity is O((n+m)⋅log(mod)) or O(n+m), in case you precompute all powers, factorials and thier inverse in linear time.

Author's solution1109E - Sasha and a Very Easy TestThe main idea: Let's factorize x in every query of the 1-st and the 2-nd type. Now x can be presented as pα11⋅pα22⋅…⋅pαkk, where pi is a prime divisor of x.

Then let's split pi into two sets: those which are divisors of mod and those which are not and process them in different ways.

It's easy to see that all primes from the second set are coprime with mod. According to Euler's theorem for each coprime with mod there is a modular multiplicative inverse. So you can just build a segment tree with lazy propagation to multiply and divide modulo mod.

What to do with primes from the first set? Notice, that there are at most 9 (because 2⋅3⋅5⋅7⋅11⋅13⋅17⋅19⋅23⋅29>109; let's call such function DiffPrimes(x) to use later) different prime divisors of mod. So let's maintain a vector in each node of segment tree, which contains pairs (p,α), what means that α is such power of p, that each number from the corresponding range should be multiplied by pα. So also use lazy propogation to multiply and divide by those primes.

Now how to answer queries of the 3-rd type? Just maintain in each node some auxiliary numbers:

sumUnder  — the sum from childsmulSecond  — equal to the product of primes from the second set, means that each number from the range should be multiplied by mulSecondpowersFirst  — vector, which contains pairs (p,α), also means that each mumber from the range should me multiplied by pαAnd it is obvious that the sum on the range which is controled by some node is sumUnder⋅mulSecond⋅pαii. How to write combine function for two nodes from segment tree and push to push modification to children I leave you as an exercise, there is nothing diffcult here.

Now combine ideas from the above, and got the complexity O((n+q)⋅log2(n)⋅log2(q)⋅DiffPrimes(105)) (because x in queries doesn't exceed 105). To remove a log2(q) we can precompute all powers of each prime divisors of mod, so we will have no need to use binary exponentiation algorithm in segment tree. But here you have to be careful, because since we have q queries and each of them can increase power of prime by log2(105) in the worst case, so maximal power of prime can be q⋅log2(105).

The complexity is O((n+q)⋅log2(n)⋅DiffPrimes(105)).

Author's solution1109F - Sasha and Algorithm of Silence's SoundsA range [l…r]  — a tree, if the graph formated by it doen't have any cycle and there is only one connected component in this graph. Let's tr be such minimal position, that [tr…r] doen't contain cycles (forest). It is obvous that tr≤tr+1. Suppose for each r we find tr. Then the task now is to count the number of such tr≤l≤r that graph formated by the range [l…r] consists of one connected component.

How to find tr for each r. Let's move two pointers: tr and r. For each moment we store a graph formated by that range. If you add 1 to one of the pointers then you should add/delete up to 4 edges to the graph. Before adding an edge check whether two verticies are in different components (not to form a cycle), and if they are in one component, then it is needed to delete some edges  — move the first pointer. So now we need some structure that can process 3 types of queries online: add an edge, delete an edge, check if two verticies are in one connected component. As long as the graph will never have a cycle, so it is possible to answer queries using link-cut tree (O(log(n⋅m)) for one query).

It is left to count the number of suitable l (tr≤l≤r) for each r. Let's iterate r from 1 to n⋅m and maintain cmpi  — the number of connected components for [i…r]. Then for a fixed r you should add to the answer the number of such i that tr≤i≤r and cmpi=1. What is going on when we move r and add some edge at that moment. Let's that edge be (x,r+1) and tr≤x (if x<tr then you can skip this edge). For i, for which x⪇i≤r, cmpi won't change after you add an edge, but for tr≤i≤x two trees merge in one  — cmpi decreases by 1. Let's have a segtree to store cmpi, then decreasing by 1 is equivalent to adding −1 on a range, and the number of 1 on a range is the number of minimums. All such queries can be done in O(log(n⋅m)).

The total complexity is O(n⋅m⋅log(n⋅m)).

Author's solution

Codeforces Round #538 (Div. 2) Editorial

By AkiLotus, 4 years ago, In EnglishModel solutions are now available.GreenGrape and I will write more about problem F, including an alternative data structures (still quite tight on time limit) ;)

1114A - ВиноградAuthor: AkiLotus, GreenGrapeDevelopment: AkiLotus, GreenGrape, neko_nyaaaaaaaaaaaaaaaaaEditorialist: AkiLotus

TutorialFirst of all, we can see the grape preference is hierarchically inclusive: the grapes' types Andrew enjoys are some of those that Dmitry does, and Dmitry's favorites are included in Michal's.

Let's distribute the grapes to satisfy Andrew first, then to Dmitry, then Michal. If any of the following criteria is not satisfied (which means one of our friends is not happy), then we can immediately say that no distributions are available:

Andrew must have at least a green grapes. So we need, x ≤ a.Dmitry can have purple grapes and/or the remaining green grapes. In other words, y ≤ a + b - x (the minus x is because x green grapes have been given to Andrew already).Michal can have grapes of any kinds. In other words, z ≤ a + b + c - x - y (similar explanations like above for both minus x and minus y).If all three criteria are satisfied, then a grape distribution is possible.

Total complexity: .

Solution (Akikaze)1114B - Очередная задача про разбиение массиваAuthor: xuanquang1999Development: AkiLotus, xuanquang1999Editorialist: xuanquang1999, neko_nyaaaaaaaaaaaaaaaaa

TutorialIn a perfect scenario, the maximum beauty of the original array is just a sum of m·k largest elements.

In fact, such scenario is always available regardless of the elements.

Let's denote A as the set of these m·k largest elements. The solution for us will be dividing the array into k segments, such that each segment contains exactly m elements of A. Just make a split between corresponding elements in the set A.

Depending on the way we find m·k largest elements, the time complexity might differ.

If we simply do so after sorting the entire array by usual means, the time complexity will be .

However, we can use std::nth_element function instead of sorting the entire array. The idea is to sort the array in such a way that, every elements not higher than a value v will be stored in the left side, other elements will stay on the right, and this works in linear time (a.k.a.  time complexity).

An example implementation of such ordering can be shown here.

Solution (xuanquang1999)1114C - Замыкающие нулиAuthor: AkiLotusDevelopment: AkiLotus, majk, cdkrotEditorialist: AkiLotus

TutorialThe problem can be reduced to the following: finding the maximum r that n ! is divisible by br.

By prime factorization, we will have the following: b = p1y1·p2y2·...·pmym.

In a similar manner, we will also have: n ! = p1x1·p2x2·...·pmxm·Q (with Q being coprime to any pi presented above).

The process of finding p1, p2, ..., pm, y1, y2, ..., ym can be done by normal prime factorization of the value b.

The process of finding x1, x2, ..., xm is a little bit more tricky since the integer they were originated (n !) is too huge to be factorized manually. Still the factorial properties gave us another approach: for each pi, we can do the following:

Initially, denote xi = 0.

Repeatedly do the following: add  to xi, then divide n by pi. The loop ends when n is zero.

After all, we can obtain the final value r as of following: .

Total complexity:  (as the number of prime factors of an integer b will not surpass ).

Solution (Akikaze)1114D - Игра-заливкаAuthor: neko_nyaaaaaaaaaaaaaaaaaDevelopment: AkiLotus, neko_nyaaaaaaaaaaaaaaaaa, cdkrotEditorialist: neko_nyaaaaaaaaaaaaaaaaa, cdkrot

TutorialThis problem was inspired by the game Flood-it. It is apparently NP-hard. You can try out the game here. https://www.chiark.greenend.org.uk/\%7Esgtatham/puzzles/js/flood.html

The first solution is rather straightforward. Suppose squares [L, R] are flooded, then they are either of color cL or cR. We can define  as the minimum number of moves required to make the segment [L, R] monochromic:

 is the least moves required to make the segment having color cL. is the least moves required to make the segment having color cR.The second solution, which is the author's intended solution, is less so. Note that the size of the component doesn't matter, so first "compress" the array so that every adjacent elements are different. We will work on this compressed array instead.

We want to maximize the number of turns that we can fill two adjacent squares instead of one. From a starting square, this maximum number of "saved" turns is equal to the longest common subsequence (LCS) of the array expanding to the two sides. The answer is the N — (maximum LCS over all starting squares)

This is equivalent to finding the longest odd size palindrome subsequence. In fact, it is the longest palindrome subsequence. For every even-sized palindrome subsequence, since adjacent elements are different, we can just insert an element in the middle and obtain a longer palindrome subsequence.

To find the longest palindrome subsequence, we can make a reversed copy of the array and find LCS of it with the original array.

Alternatively, we can also use the first solution on the compressed array, without needing the third parameter.

Time complexity: .

Solution 1 (_kun_)Solution 2 (neko_nyaa)1114E - Арифметическая прогрессияAuthor: AkiLotusDevelopment: AkiLotus, GreenGrapeEditorialist: AkiLotus, xuanquang1999

TutorialThe > query type allows you to find the max value of the array through binary searching, which will cost  queries.

The remaining queries will be spent for the queries of the ? type to get some random elements of the array. d will be calculated as greatest common divisors of all difference between all consecutive elements, provided all elements found (yes, including the max one) is kept into a list sorted by increasing order.

Having d and max, we can easily find the min value: min = max - d·(n - 1).

The number of allowed queries seem small (30 queries to be exact), yet it's enough for us to have reasonable probability of passing the problem.

By some maths, we can find out the probability of our solution to fail being relatively small — approximately 1.86185·10 - 9.

Proof on the probability, written by xuanquang1999Keep in mind to use a good random number generator and a seed which is hard to obtain, thus making your solution truly random and not falling into corner cases.

Some of the tutorials of neal might be helpful:

Don't use rand(): a guide to random number generators in C++How randomized solutions can be hacked, and how to make your solution unhackable

Solution (Akikaze)1114F - Очередная задача про запросы к массивуAuthor: AkiLotus, cdkrotDevelopment: AkiLotus, GreenGrape, cdkrotEditorialist: AkiLotus, GreenGrape, cdkrot

TutorialThere's a few fundamentals about Euler's totient we need to know:

φ(p) = p - 1 and φ(pk) = pk - 1·(p - 1), provided p is a prime number and k is a positive integer. You can easily prove these equations through the definition of the function itself.Euler's totient is a multiplicative function. f(x) is considered a multiplicative function when  means f(a)·f(b) = f(a·b).Keep in mind that we can rewrite φ(pk) as of following: .

Let's denote P as the set of prime factors of .

Thus, the answer for each query will simply be: .

So, for each query we'll need to know the product of the elements, and which primes are included in that product.

There are a few ways to work around with it. One of the most effective way is as following:

Create a product segment tree to maintain the segment products.Since  only depends on the appearance or non-appearance of the primes, and the constraints guaranteed us to have at most 62 prime factors, we can use bitmasks and an or-sum segment tree to maintain this part.Also, the bitmasks and range products can be maintained in a sqrt-decomposition fashion (please refer to GreenGrape's solution), making each query's complexity to be somewhat around . Still, this complexity is quite high and surpassed time limit on a pretty thin margin.

Complexity for initializing segment trees: .

Complexity for each update query: .

Complexity for each return query: .

Solution 1a (_kun_)Solution 1b (Akikaze) [literally kun's solution, yet shorter, and a bit uglier :P]Solution 2 (GreenGrape)

CodeCraft-19 and Codeforces Round #537 (Div. 2) Editorial

By nitesh_gupta, history, 4 years ago, In English1111A - Трансформация супергероевCheck lengths of s and t. If they are different, s can never be converted to t and answer is "No".

If for all indexes i either both s[i] and t[i] are vowels or both s[i] and t[i] are consonants, then answer is "Yes", else answer is "No".

Author's code1111B - Средняя сила супергероевIf we want to remove an element to increase the average it should be the smallest element in our current set. For each deletion, 1 operation is used.

Lets try finding f(i) = maximum average by deleting i smallest elements.

If we delete i elements, then for the remaining n−i elements the maximum increase can be min(m−i,k∗(n−i)) since m−i operations can be now at max used, and at one particular index at most k operations can be done.

So f(i)=( sum of largest (n−i) elements +min(m−i,k∗(n−i)))/(n−i)The sum of largest (n−i) terms can be computed using prefix sums.

ans=max f(i) over all i from 0 to min(m,n−1)The min condition comes because there is no use of deleting all elements, and the number of deletions is limited by the maximum number of operations possible.

Author's code1111C - Изобретательный щелчокMake a recursive function rec(l,r) where l and r are start and end indexes of subarray to be considered. Start with l=1 and r=2n. If there is no avenger in l to r return A (power consumed). Else either power consumed to burn it directly is b∗x∗len (where x is number of avengers in l to r and len is length of array (r−l+1) ) or by dividing the array is the result of recursion(l,mid) + recursion(mid+1,r) where mid=(l+r)/2. Return the minimum power consumed. If l is equal to r then do not go into recursion further, return power consumed according to first operation. One thing is remaining, the value of x, given l and r. Sort the array containing indices of avengers and then find positions of l and r in that array using binary search. Difference is positions of l and r in array will give x. Time Complexity : O(n∗k∗log(k)). Explanation : Reaching any subarray will take maximum of n operations and we can have maximum k subarrays (each having one avenger), it will take O(n∗k). O(log(k)) time needed for binary search (calculating x). So net complexity is O(n∗k∗log(k)).

Author's code1111D - Уничтожить поселениеThe question reduces to the following. Given a string s with lowercase and uppercase characters,a good string is one which can be generated by reshuffling characters, such that all occurences of a particular alphabet are in the same half. ( (1 to n/2) or (n/2+1 to n)) and this condition is true for all alphabets. Now given a pair i and j, you want to find the number of good strings such that all the occurences of s[i] and s[j] in the string are also in the same half in the string.

Lets first try to find the number of good strings. k = total number of alphabets.

Store the frequencies of the alphabets as their order does not matter, and let them be c1,c2,c3..ck Now if we can select indices i1,i2,…,ip such that ci1+ci2+…,cip = n/2 then we can arrange those alphabets in the first half, and the remaining in the second half. Total ways for arranging in first half = (n/2!)/(ci1!∗ci2!∗ci3!..cip!)Similarly total ways for arranging in 2nd half = (n/2!)/(product of factorials of remaining frequencies.)

Thus total ways = ((n/2!)∗(n/2!))/(product of factorials of frequencies of all alphabets) =W(say) Thus notice that, for all combinations of frequencies adding upto n/2, the number of ways comes out to be constant.

Hence now the total number of good strings =W∗ (number of combinations of frequencies adding to n/2)

The part for the number of combinations adding upto n/2 can be computed using standard knapsack dp.

Now let's try to solve for the condition that all occurrences of s[i] and s[j], should all also be in the same half, apart from the condition of the string being a good string.

This basically means now we want to select alphabet frequencies adding upto n/2 from the remaining frequencies ( excluding the frequency of alphabet s[i] and s[j]). One way is to use the same method we did above for all good strings.

This gives complexity O(n∗k) for every pair, taking a total of O(n∗k3) for k2 pairs.

Now using the idea of adding items to a knapsack, we can also extend it to remove items.

In short, we can use the pre-computed dp table to remove the number of ways which included the ith item, by reversing the direction of the loop and the operation ( addition becomes subtraction). Let the frequency of the element we want to remove be x.

dp[j] = number of ways to get sum as j using all elements.

for (int j=x;j<=n;j++)

dp[j]-=dp[j-x];

( see the code for more details)

In this way for every pair (x,y), you copy the precomputed dp into a temporary array, remove ways using characters x and y, and then the answer will be 2∗dp[n/2]∗W ( 2 because you can choose the first or the second half for putting the group containing x and y). After precomputation, each query is answered in O(1). Total time O(2∗n), for every pair and there are (k∗(k−1))/2 pairs. Final time complexity O(n∗k2)Author's code1111E - ДеревоAssume that we didn't have to root at Y in each query. Lets first solve the problem for all queries having root at 1.

While processing the query, let's sort the given set of nodes according to the dfs order. Let dp[i][j] denotes the number of ways to divide the first i nodes in the set into j non-empty groups. For a node i, let h[i] denote the number of ancestors in the query set. Now,

dp[i][j] = dp[i-1][j]⋅(j-h[i]) + dp[i-1][j-1]

The first part basically says, that apart from the groups of the ancestors of i, it can be included in any other group, hence (j-h[i]) choices for allocating a group to i. The second part is including i-th node in a completely new group.

Thus our final answer would have been the sum of dp[n][j] for all j from 1 to x. Now how to find h[i]? If we mark all the nodes which have appeared in the query, h[i] is the number of marked nodes from i to the root. This can be computed using standard range updates and point queries on Euler tree. For all nodes i, perform a range update on the range [ST(i),EN(i)] and h[i] basically becomes query(ST[i]).

Now a key observation. Notice that actually we only care that for node i, before updating its dp, all its ancestors are visited. This means we actually do not need the dfs order, instead just the level-wise order. So all we need to do is sort all nodes in the query set according to the h[i] values. By removing the condition for dfs order on the ordering of the dp, the condition for rerooting can also be handled.

If the tree is rooted at Y, Now hnew[i] becomes the number of marked nodes between i and root Y. This can be computed using the same technique of range update and query. hnew[i] = h[i] + h[Y] - 2⋅h[ LCA(i,Y)] + (mark[LCA(i,Y)]==true) -1

(-1 because we do not want to include i in hnew[i])

Now we do the same dp and compute the answer.

For every query: Sorting = O(KlogK), LCA computation = O(KlogN), bit update and query= O(KlogN) LCA precomputation = O(NlogN) Thus final complexity = O( NlogN + logN⋅(summation over all values of K))

(where summation of K <= 10^5)

Author's code

Codeforces Round #536 (Div. 2) Editorial

By jinlifu1999, history, 4 years ago, In English1106A - Lunar New Year and Cross CountingThe solution is simple: Just check if crosses can appear in every positions. Two nesting for-loops will be enough to solve this problem.

Time complexity: O(n2)Code1106B - Lunar New Year and Food OrderingThe implementation of the problem is easy: Just do what Bob tells you to do. The only difficulty, if it is, is to handle the cheapest dish. This can be done by a pointer or a priority queue. The details can be found in the code.

Time complexity: O(m+nlogn)Code1106C - Lunar New Year and Number DivisionThis problem is easy as it looks like, and it is proved to be simple. As n is even, the optimal grouping policy is to group the smallest with the largest, the second smallest with the second largest, etc.

First, it is easy to prove that it is optimal to group these numbers 2 by 2, so the proof is given as an exercise to you.

The proof of the second part is about the Rearrangement Inequality. Let's consider two of the permutations of the sequence {ai}. Suppose they are {bi},{ci} where bi=cj if and only if bj=ci. Then the sum12∑i=1n(bi+ci)2is one of the grouping policy of {ai}. As we do not care about the part12∑i=1n(b2i+c2i)We only aim to minimize ∑ni=1bici. That is the direct application of the Rearrangement Inequality.

Time complexity: O(nlogn)Code1106D - Lunar New Year and a WanderIn fact, you don't really need to consider the path Bob wanders. A priority queue is enough for this problem. When Bob visits a node, add its adjacent nodes into the priority queue. Every time he visits a new node, it will be one with the smallest index in the priority queue.

Time complexity: O(mlogn)Code1106E - Lunar New Year and Red EnvelopesYes, this is where Alice shows up and ... probably the problem is not related to Game Theory. Let's divide the problem into two parts: The first is to obtain the maximum coins Bob can get from time points 1 to n, and the second is to decide when to disturb Bob.

For the first part, we apply event sorting to those time segments. After that, we use a set with a sweep line to deal with it. Whenever we meet a start or a terminate of one red envelope, we add this into the set or remove that from the set. Note that you need to use multiset, since there can be multiple red envelopes with same d and w.

For the second part, we apply dynamic programming since m is relatively small. Let f[i][j] denote that the minimum coins Bob gets when we only consider the timeline from 1 to i and Alice disturbs Bob for j times. The transition is trivial and you can take a look at it in the code.

Time complexity: O((n+k)logk+nm)Code1106F - Lunar New Year and a Recursive SequenceThis problem seems weird first looking at it, but we can rewrite it into a linear recursive equation. The most important thing you should know is that g=3 is a primitive root of p=998244353. Briefly speaking, the primitive g is called a primitive root of p if and only if the following two constraints are satisfied:

gp−1modp=1 (shown by Fermat's little theorem)∀1≤k<p−1, gkmodp≠1The two constraints shown above imply that ∀1≤x<y<p, gxmodp≠gymodp. The proof is simple: If gxmodp=gymodp, we have gy−xmodp=1. However, it violates the second constraint since 1≤y−x<p−1. Thus the function q(x) defined by gq(x)modp=x is a bijection: We can recover x from q(x) using fast power algorithm and get q(x) from x using baby step giant step algorithm.

Now, we construct a new sequence h1,h2,…,hi,… where hi=q(fi). Then we can derive the equation that hi should satisfy:

ghimodp=(∏j=1kghi−jbj)modp,which yields (applying Fermat's little theorem)

ghimodp−1modp=g(∑kj=1bjhi−j)modp−1modpSince g is a primitive root of p, the equation satisfied if and only if the exponents are the same. Thus

hi=(∑j=1kbjhi−j)modp−1You may obtain the same equation by applying discrete logarithm on both sides of the equation of fi.

Note that the equation of hi is a normal linear recursive equation, which can be solved using matrix exponentiation to get the relationship between hn and hk. To obtain hn, just apply the baby step giant step algorithm, and the relationship between hn and hk can be represented by a congruence equation:

chk≡hn(modp−1)In this equation, c is the corresponding coefficient of hk obtained by matrix exponentiation. Note that f1=f2=…=fk−1=1, which yields h1=h2=…=hk−1=q(1)=0. Therefore, we just ignore those items, leaving chk alone.

This congruence equation can be solved by Extended Euclidean algorithm. If no solution exists for this equation, the original problem has no solution as well. After obtaining hk, fk can be recovered using fast power algorithm.

Time complexity: O(k3logn+p–√logp)UPD: Now I would add some details about those two algorithms: matrix exponentiation and baby step giant step algorithm.

1. Matrix exponentiation

Suppose that we have a linear recursive equation

fi=∑j=1kbjfi−jwhere b1,b2,…,bk, f1,f2,…,fk are known constants. Then the following equation of matrices holds for some i (i≥k)

⎡⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢b1100⋮0b2010⋮0b3001⋮0⋯⋯⋯⋯⋱⋯bk−1000⋮1bk000⋮0⎤⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⋅⎡⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢fifi−1fi−2fi−3⋮fi−k+1⎤⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢fi+1fifi−1fi−2⋮fi−k+2⎤⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥Let's call the matrix A transition matrix, where

A=⎡⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢b1100⋮0b2010⋮0b3001⋮0⋯⋯⋯⋯⋱⋯bk−1000⋮1bk000⋮0⎤⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥and

fi=⎡⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢fifi−1fi−2fi−3⋮fi−k+1⎤⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥Therefore, the equation shown above can be rewritten as

Afi=fi+1which yields

An−kfk=fnSo we can obtain fn in O(k3logn) time since a single matrix multiplication takes O(k3) time.

There are two problems that you may consider as your further research on linear recursive equations.

Solve this linear recursive equation in O(k2logn) time or O(klogklogn) if you apply Fast Fourier Transform.Solve the following linear recursive equation in O(k3logn) time or faster:fi=∑j=1kbjfi−j+cwhere c is a constant.

2. Baby step giant step algorithm

Consider the following congruence equationaz≡b(modp)where p is a prime (for convenience) and a,b are known constants.

The intuition of the baby step giant step algorithm is meet-in-the-middle. Let's write z=x⋅p–√+y for convenience. In this representation, x,y<p–√. We store b⋅a−0,b⋅a−1,…,b⋅a−(p√−1) in a map. Then we try every possible x from 0 to p–√−1. Sinceax⋅p√+y≡b(modp)which yieldsax⋅p√≡b⋅a−y(modp)Therefore, the result of b⋅a−y can be found in the map in O(logp) time. So the overall time complexity is O(p–√logp).

Code

Codeforces Round #535 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1108A - Two distinct points

Tutorial1108A - Two distinct pointsOne of the possible answers is always a pair of endpoints of the given segments. So we can add all endpoints to the array and iterate over all pairs of elements of this array and check if the current pair is suitable or not.

Solution1108B - Divisors of Two Integers

Tutorial1108B - Divisors of Two IntegersLet's take a look on the maximum element of the given array. Suddenly, this number is x (or y, the order doesn't matter). Okay, what would we do if we know x and merged list of divisors of x and y? Let's remove all divisors of x and see what we got. The maximum element in the remaining array is y. So, the problem is solved.

Solution1108C - Nice Garland

Tutorial1108C - Nice GarlandIt is easy to see that any nice garland has one of the following 6 patterns:

"BGRBGR ... BGR";"BRGBRG ... BRG";"GBRGBR ... GBR";"GRBGRB ... GRB";"RBGRBG ... RBG";"RGBRGB ... RGB";We can hard-code all all this patterns or iterate over all these permutations of letters "BGR" using three nested loops or standard language functions. We can calculate for each pattern the cost to obtain such pattern from the given string and choose one with the minimum cost.

Solution1108D - Diverse Garland

Tutorial1108D - Diverse GarlandLet's divide the initial string into blocks of consecutive equal letters. For example, if we have the string "GGBBBRRBBBB" then have 4 blocks: the first block is two letters 'G', the second one is three letters 'B', the third one is two letters 'R' and the last one is four letters 'B'.

Let's see at the current block (let it has the length len) and consider two cases.

The first case is when this block has odd length. Then it seems like "XXXXXXX". So, what is the minimum number of recolors we need to make this block correct? It is ⌊len2⌋. Why can we always make this block correct for such number of recolors? Because we can recolor all 'X' at even positions to any 'Y' which differs from 'X'. So our block will be look like "XYXYXYX".

The second case is when this block has even length. Then it seems like "XXXXYYY ... YYY" where 'Y' is the next block letter (if the next block exists, because the last block doesn't have the next one). What is the minimum number of recolors in this case? It is len2. How can we recolor this block to make it correct? Let's recolor all 'X' at even positions (again) to any 'Z' which differs from 'X' and differs from 'Y'. So our block will be look like "XZXZYYY ... YYY".

So all we have to do is to iterate over all blocks from left to right and apply the algorithm above to recolor them.

Solution1108E1 - Array and Segments (Easy version)

Tutorial1108E1 - Array and Segments (Easy version)Let's divide all segments to four classes. The first class contains segments which covers both minimum and maximum values (the answer) of the resulting array, the second class contains segments which covers only minimum value of the resulting array, the third class contains segments which covers only maximum value of the resulting array and the fourth class contains segments which covers neither maximum nor minimum of the resulting array.

We can easy see that we cannot increase the answer if we apply segments of first and third classes. What is common in this two classes? Right, both of them are cover maximum value.

So we can came up with the solution in O(n2m) or O(n(n+m)) (depends on implementation). Let's iterate over position of the supposed maximum value and apply all segments which not cover it. It can be done in O(n2m) with straight-forward implementation or in O(n(n+m)) using prefix sums. After we apply all needed segments we can try to update the answer with the value of the obtained array.

Solution1108E2 - Array and Segments (Hard version)

Tutorial1108E2 - Array and Segments (Hard version)This tutorial is based on the previous problem (easy version) tutorial.

At first, I want to say I know that this problem and this approach can be implemented in O(mlogn) with segment tree.

So, we iterate over all supposed maximums in the array and trying to apply all segments not covering our current element. How do we can calculate the answer for each element if this element is the supposed maximum?

Let's divide all segments we apply into two parts: the first part consists of segments such that their right endpoints is less than the current position and the second part consists of segments such that their left endpoints is greater than the current position. Then let's independently calculate answers for the left and for the right parts and merge them to obtain the answer.

I will consider only first part of the solution (first part of segments) because the second part is absolutely symmetric with it.

Let's maintain the minimum value on prefix of the array (let it be mn and initially it equals to +∞), maintain the array ansv of length n (initially its values are −∞ and ansvi means the answer if the i-th element of the array will be supposed maximum) and the array add of length n, where addi will be the value for which we decrease the i-th element (in other words, the number of segments we apply to the i-th element).

What do we do for the current position i? Firstly, let's update the answer for it with the value ai+addi−mn (in other words, set ansvi:=max(ansvi,ai+addi−mn)). Then let's apply all segments with right endpoints equals to the current position straight-forward and update the value mn with each new value of covered elements. Just iterate over all positions j of each segment ends in the current position, make addj:=addj−1 and set mn:=min(mn,aj+addj). And don't forget to update the value mn with the value ai+addi after all changes (because we need to update this value with each element not covered by segments too).

So then let's do the same from right to left and then ansvi will mean the answer if the i-th element is the supposed maximum in the resulting array. Then we can find any position of the maximum in the array ansv and apply all segments which don't cover this position.

What is time complexity of the solution above? We iterate over all elements in the array, this is O(n) and apply each segment in O(n), so the final time complexity is O(n+nm)=O(nm).

Solution1108F - MST Unification

Tutorial1108F - MST UnificationThe first (and the most straight-forward) approach is to construct MST with any suitable algorithm, build LCA with the maximum edge on a path with binary lifting technique and then we have to increase the answer for each edge ei=(ui,vi,wi) such that wi equals to the maximum edge on a path between ui and vi in MST.

The second (and the most pretty and easy to implement) solution is the improved Kruskal algorithm.

Let's do Kruskal algorithm on the given edges. Sort them, and let's consider all edges of the same weight at once. They can be divided into two classes. The first class contains edges which connect nothing and the second class contains edges which can connect something.

Let the number of edges of current weight be k, edges of the current weight of the first class be kbad and edges with of current weight of the second class be kgood. Okay, we can just skip the first class because it will never increase the answer. How to calculate useless edges of the second class? Let's try to merge all components connected with edges of the second class. Suppose we make q merges. Then we have to increase weights of all remaining edges by one. So we add to the answer the value kgood−q and go to the next weight.

Why is this right? This is right because if the edge of the second class cannot connect anything because of the previously considered edges then the maximum on a path between endpoints of this edge equals to this edge weight. So we have to increase the weight of this edge by one. If we didn't do it we would be able to replace the edge connects these components with our edge. And it is obvious that this edge is totally useless with the weight increased by one.

Time complexity is O(mlogm) because of edges sorting.

Solution

Codeforces Round #534 — Editorial

By scanhex, history, 4 years ago, In English1104A - Splitting into digitsIt was a joke :). Let's split number n to n digits, equal to 1. Their sum is n and the number of different digits is 1. So, it can be found as the answer.

Author: isaf27

1104B - Game with stringIt can be shown that the answer does not depend on the order of deletions. Let's remove letters from left to right, storing a stack of letters, remaining in the left. When we process a letter, it will be deleted together with the last letter in the stack if they are equal or will be pushed to the stack. Let's calculate parity of the number of deletions during this process and determine the answer.

Author: 300iq

Statements and editorial: scanhex

1104C - Grid gameOne possible solution is to place vertical tiles into lower-left corner and place horizontal tiles into upper-right corner.If some tile comes, but there is already a tile of the same type, than we will place the new tile into upper-left corner. So both tiles will be cleared and only them.

Author: scanhex

Solution

1104D - Game with moduloLet's ask this pairs of numbers: (0,1),(1,2),(2,4),(4,8),…,(229,230). Let's find the first pair in this list with the answer "x". This pair exists and it will happen for the first pair (l0,r0), that satisfy the inequality l0<a≤r0. We can simply find this pair using ≤30 or ≤31 questions.

Now we have a pair of numbers (l0,r0), such that l0<a≤r0. Let's note, that r0<2⋅a, because it was the first such pair in the list. Now if we ask pair (l0,x) for some l0<x≤r0 we will get the answer "y", if x<a and the answer "x" otherwise. So let's do the binary search in the segment [l0+1,r0], asking the question (l0,x) and moving the borders of binary search according to this. Here we will use ≤29 questions.

So we have a solution asked ≤59 questions.

Author: isaf27

1104E - Johnny SolvingLet's build a dfs spanning tree from the vertex 1 and find the depth of the tree. If the depth is at least nk then we can just print the path from the root to the deepest vertex.

Otherwise, there will be at least k leaves in the tree. Let's prove it. Consider a tree with c leaves, after that consider a path from a particular leaf to the root, let's denote length of i-th path (in vertices) by xi. We can say that x1+…+xc≥n, because every particular vertex in the tree will be covered by one of pathways. So, using Dirichlet's principle we can say that max(x1,…,xc)≥nc. Hence, depth of the tree is at least nc.

Now, consider a leaf in our spanning tree, let's denote it like v. This leaf has at least 2 back edges (edges which connected with one of ancestors), let's denote ancestors like x and y. Obviosly, we have three cycles here: path from x to v with corresponding back edge, the same cycle from y to v, and path between x and y with two back edges connected with v. Lengths of these cycles are d(v,x)+1, d(v,y)+1 and d(x,y)+2, where d(a,b) - distance between vertices a and b. It's clear that one of these numbers is not divisible by three. Last problem is to choose representative - we should choose leaves. Size of output is not exceed 106 because the depth of our tree at most nk and each cycle has length O(nk).

Author: altruist

1103D - Professional layerWe supposed this as the author solution:

Let's find gcd and factorize it. gcd=pα11⋅…⋅pαmm, where pi i-th prime number in factorization (pi<pi+1) and αi>0 — number of occurrences of this prime. It's clear, that m≤11 in our constraints, because ai≤1012. Obviously, that in optimal answer is always best to divide set of our primes in subsets and distribute these subsets between array numbers and divide each number ai by product of all primes (with ai powers) in corresponding subset.

Also clear, that we are interested in only vector of powers of primes of gcd, other primes in a factorization of ai we can ignore, but we need to be cautious about costs, so, we can left the cheapest m numbers with the same prime-vector. After this compression we will left at most M=12000 numbers. We can get this estimation by this point: maximum numbers after compression we can reach if all primes are small as possible and αi=1 for all i. Hence, we have at most 11 possibilities and can easily brute all of them. Also, after compression, let's calculate vector best(mask) - best m numbers by cost to cover set of primes corresponding to mask. We can do it easily in O(M⋅2m⋅m).

Now let's fix a partition of our set of primes into subsets. Well known, that the number of partitions is equal to Bm, where Bi — i-th Bell number. Now, we want to update the current answer. We need to do it by value x⋅y, where x is number of subsets in the partition (we already know it) and y is minimum cost to distribute our subsets between array numbers. Let's consider all indices i for subset mask which we can match with this mask by constraint "divisor is at most k". We will get the bipartite graph with weighted right part (part with indices) and our purpose is to find perfect matching with minimal cost of used vertices in the right part. We can solve this problem with Kuhn algorithm greedily — we can sort right part in not ascending order and do all iterations in this order. It's correct, because we can consider transversal matroid with elements in right part and apply greed Rado-Edmonds theorem. Now we need just to figure out, that we can build this graph using precalced best(mask), because we are interested only in at most m best indices for the particular vertex in the left part. So, we will have graph with O(x2) edges and O(x) size of the left part. Kuhn algorithm will be work in O(x3) (even we do the algorithm in right part with size O(x2)) if we clear used array carefully — only after increasing of the current matching. Summing up x3 over all partitions of 11 elements we will get ∼108 operations.

P. S. Solutions that were passed by participants during the contest used same ideas about the compression. But instead of minimal matching we will use dynamic programming approach. Let's denote dp(mask,i) - minimal cost to correctly cover set of primes corresponding to mask using exactly i divisions. To calculate it let's precalc best′(i) (inversion of best(mask)) — m masks for which i-th number of the array is one of m best. Using this helped data we can calculate our dp(mask,i). For this, we can iterate over all numbers and try to update all states where we can use our best′(i) masks. It will be work in O(m2⋅3m) and all algorithm will be work in O(M⋅2m⋅m+m2⋅3m)Author: altruist

1103E - Radix sumAfter reading the problem statement, it is pretty clear that you should apply something like Hadamard transform, but inner transform should have size ten instead of two. There is no 10-th root of one modulo 258 (except 5-th and 2-th roots), so it is not possible to solve the problem just calculating all values modulo 258.

The main idea is that you should calculate all values in a polynomial ring modulo x10−1 (in this ring identity x10=1 holds, so x is the one's 10-th root).

Now the problem is there is no modular inverse of 105, so we apply the trick. Let's just use unsigned long long, and in the end we will divide the answer by 55 (it is invertible, because it is relatively prime to 2), and then we simply divide the answer by 25 with integer division, it can be easily shown that the result will be correct. It is worth noting that after inverse transform you should eliminate monomes larger than x4 by applying the identity x4−x3+x2−x1+x0=0 (modulo x10−1). After that only the coefficient with x0 remains, and this will be the answer.

Author: scanhex

Solution 1

Solution 2

Codeforces Round #533 (Div. 2) — Editorial

By Warawreh, 4 years ago, In English1105A - Salem and SticksFirstly, we must find the value of t and it can easily proven that t is less than or equal to 100, so we can iterate over all possible value of t from 1 to 100 and calculate the cost of making all the sticks almost good for that t.

That works in 100⋅n.

1105B - Zuhair and StringsSince all the substrings of length k must be of the same latter, we can iterate over all letters from 'a' to 'z' and for each letter count the number of disjoint substrings of length k and take the maximum one.

1105C - Ayoub and Lost ArraySince we need the sum of the array to be divisible by 3, we don't care about the numbers themselves:

We care about how many numbers x such that x(mod3)=0 or 1 or 2 and we count them by simple formulas.

For example, let's count the number of x with remainder 1 modulo 3, hence x=3k+1 for some integer k.

Then we have l≤3k+1≤r, l−1≤3k≤r−1and then ceil(l−13)≤k≤floor(r−13).

It is easy to count number of such k then.

After counting all numbers we can solve the problem using dynamic programming. Let's say that dp[i][j] represents that the sum of the first i numbers modulo 3 is equal to j. There are O(n) states and transitions and the answer will be at dp[n][0].

1105D - Kilani and the GameThis problem can be solved in many ways, one of them uses a bfs.

Let's process the first round.

Iterate over players and use a multi-source bfs for each player from his starting castles to find cells reachable in at most s[i] moves. A multi-source bfs works just like regular one, except you push more vertices in the queue in the beginning. While moving, we can't enter a blocked cell or an already controlled cell.

And in the each following turn do the same, but start from the cells we stopped on the previous turn, instead of starting castles.

Keep doing this until no player can move anymore.

Complexity: O(p⋅nm)1105E - Helping HiasatLet's change this problem to a graph problem first.

Let's say, that each action of the first type is a "border". Consider all friends visiting our profile after this "border" but before the next one. Clearly, we can satisfy at most one of them. Let's change the friends into graph nodes and add edges between every two friends that are between the same borders.

Then it's enough to solve "the maximum independent set of the graph", clearly any possible answer must be an independent set and by any independent set we can always build a way to change our handle.

The maximum independent set can be solved in O(2m) (where m is the number of friends). But since m is up to 40, it is too slow. However, we can apply the meet in the middle approach and then it becomes O(2(m/2)) or O(2(m/2)m).

The simplest way is to do the following (notice, that the independent set is same as clique if all edges are inverted, so we will solve a max clique problem).

Let's write a bruteforce solve(mask) which returns size of the largest clique, which forms a subset of mask. The answer will be just to run solve of full mask.

How to write solve? Let's find a first bit of mask, let it be vertex v.

There are two cases:

The vertex v is not in an answer. Kick it and run a recursive call.The vertex v is in answer. Hence all other vertices of answers are neighbors of v. Run the recursive call from mask & g[v], where g[v] denotes the mask of neighbors.Clearly, it works in O(2m). However, if we add memorization (don't calculate for same mask twice) it is magically becomes O(2m/2).

Why? Consider the recursion, there are at most m/2 recursion calls before we arrive into the state, where there are no set bits of the first half.

This part will take at most 2m/2 then. And clearly there are at most 2m/2 states with no set bits in the first half.

Codeforces Round #532 (Div. 2) — Editorial

By den2204, history, 4 years ago, translation, In English1100A - Roman and BrowserThe constraints in this task allowed us to simply iterate over the closed tab and check the answer, but we can solve it more quickly — calculate the sum for each value modulo k and count the total sum for the whole array. After that, you just need to go through the module tab numbers that we delete, and update the answer.

Complexity — O(n2) or O(n+k).

1100B - Build a ContestWe will keep the arrays, how many problems are created for each specific complexity i — cnti and how many problems have been created for the round j — existj. Then if we create a task with complexity c, we will recalculate cntc=cntc+1, existcntc=existcntc+1. Suppose we have already given k rounds. Then, after adding the next task, we only need to check that existk=n, in this case we can held the next round, otherwise not.

The complexity is O(m).

1100C - NN and the Optical IllusionConsider three circles — inner and two outer. Since all the circles are tangent, the sides of the triangle constructed on the centers of the circles pass through the tangency points of the circles. Denote by α the angle in an equilateral n -gon. Then α=π(n−2)n. On the other hand, Rr+R=cos( alpha2). It can be noted that Rr+R=R+r−rr+R=1−rr+R, i.e. the function increases with R. On this basis, a binary search can be used to find the answer, or explicitly derive the formula R=rcos(α2)1−cos(α2)The complexity is O(1) or O(logC).

1100D - Dasha and ChessOne of the possible strategies: the king goes to the center, then goes to the corner that he has as few rooks as possible behind his back. The solution uses the Pigeonhole principle, since in the largest corner and in two neighbors to it, the sum will be no less than 666∗3/4>499 rooks, i.e. ≥500 rooks, and since the king gets to the corner for 499 of moves, he will definitely get under check of the rook.

1100E - Andrew and TaxiSuppose we have k traffic controllers. They can turn all edges whose weight is less than or equal to k. Then let's remove all these edges from the graph, make a topological sorting of the remaining graph, and orient the other edges in the order of topological sorting. If there are cycles left in the graph after removing the edges, then we cannot get rid of them, having k traffic controllers. Otherwise, by adding edges we will not add new loops. The parameter k can be iterated through a binary search. Also in binary search, you can go through not all possible values ​​of k, but only the values ​​that are on the edges.

Complexity — O((n+m)logC) or O((n+m)logm).

1100F - Ivan and BurgersNote that to answer on a segment, it is enough to know the basis of this segment, that is, the minimum set of numbers, with which you can represent all the numbers that are representable on this segment. Since 0≤ai≤1000000, then the basis will be no more than 20. To find the maximum number, run the Gauss algorithm for the basis so that there is no pair of numbers in the basis for which the maximum bit is the same. Then the maximum representable number can be obtained by the following algorithm: we will consider the numbers starting from the maximum, and add them to the answer if they increase the current answer.

The complete problem can be solved using the "divide and conquer" method: if we split the segment in half, then all requests on it either completely lie into one of the segments, or lieinto both. For requests that completely lie in one of the segments, we respond recursively. For queries that fall in both segments, we combine two linear hulls — hull[l,mid] and hull[mid+1,r]. All linear hulls of the form hull[i,mid] and hull[mid+1,j] can be obtained by adding vectors sequentially from right to left (on the right segment from left to right).

An alternative solution was proposed at the contest. Note that a query on a segment is a suffix of some array prefix. We will gradually increase the array prefix and maintain the "maximally right" array basis (if for the current prefix we go right through to the left, then the "maximally right" basis is the greedily typed basis of array values). When adding an element, it can either not be presented in the current basis, then it must be added to the current basis. If we can represent the element, then it is necessary to find the left-most element whose removal does not change the linear hull. This can be done by simulating Gauss algorithm from right to left: the first representable element must be removed from the basis. Since the basis is small, this operation can be done with each addition of a vector. We can get the answer to the problem, since for the fixed right element, we know at what point the basis changes as the left border moves from right to left.

Complexity is O((n+q)log2C) or O(nlog2C+q).

Codeforces Round #531 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1102A - Integer Sequence Dividing

Tutorial1102A - Integer Sequence DividingThe first solution: take n modulo 4 and solve the problem manually (then for cases n=0 and n=3 the answer is 0 and for n=1 and n=2 the answer is 1).

Prove: Let's see what can we make for numbers n, n−1, n−2 and n−3. We can add n and n−3 in A and add n−1 and n−2 in B. Then the difference between sums will be 0. We can consider last four numbers this way until we have at least four numbers. And then we have a case n≤3. We can prove the solution for these four cases using bruteforce.

The second solution: if ∑i=1ni is even then the answer is 0 otherwise the answer is 1. The formula above is just n(n+1)2.

Prove: if we have an integer sequence 1,2,…,n then we can obtain every number from 0 to n(n+1)2 as the sum of some elements of this sequence. How? Greedily! You can see how this greedy works (and prove, if you want) yourself. So what's next? If n(n+1)2 is even then we can obtain the sum n(n+1)4 in A and in B. Otherwise we can only obtain ⌊n(n+1)4⌋ in A and ⌈n(n+1)4⌉ in B (or vice versa).

Solution 1Solution 21102B - Array K-Coloring

Tutorial1102B - Array K-ColoringHow can we solve this problem easily? Firstly, let's sort the initial array (but maintain the initial order of the elements in the array to restore the answer). Then let's just distribute all the colors uniformly. Let's color the first element in the first color, the second one — in the second, the k-th element — in the k-th color, the k+1-th — in the first color, and so on. So we color the i-th element in the color (i−1)%k+1 (% is just modulo operation). We can see that the answer is "NO" if there is an element with frequency at least k+1 in the array (by pigeonhole principle). Otherwise our solution builds the correct answer. So we can try to find such element in the array naively, using counting sort or many other approaches.

Time complexity — O(nlogn) or O(n2).

Solution1102C - Doors Breaking and Repairing

Tutorial1102C - Doors Breaking and RepairingLet's consider two cases:

If x>y then the answer is n because we can make opposite moves to the Slavik's moves and it always will reduce durability of some door (so at some point we will reach the state when all doors will have durability 0).

Otherwise x≤y and we have to realize the optimal strategy for us. If we have some door with durability z≤x then let's break it immediately (why shouldn't we do this?). If we don't do it then Slavik will repair this door during his move. So what Slavik will do now? He will repair some door. Which door he has to repair? Of course the one with durability z≤x because otherwise we will break it during our next move. So we can realize that doors with durability z>x are not interesting for us because Slavik will make opposite moves to our moves. And what is the answer if the number of doors with durability z≤x equals to cnt? It is ⌈cnt2⌉.

Solution1102D - Balanced Ternary String

Tutorial1102D - Balanced Ternary StringLet's count how many characters '0', '1' and '2' we have in the string s and store it in the array cnt. Also let's count our "goal" array cur. Firstly, the array cur is [n3,n3,n3].

The main idea of this problem is a pretty standard lexicographically greedy approach. We go from left to right and try to place the minimum possible character at the current position in such a way that placing this character is not breaking conditions of our problem. How can we apply this approach to this problem?

Firstly, let's define a function need(cnt,cur)=|cnt0−cur0|+|cnt1−cur1|+|cnt2−cur2|2. What does the value of this function mean? It means the number of replacements we need to reach cur from cnt. Let initNeed=need(cur,cnt) at the beginning of the program. This value means the minimum number of replacements to obtain some balanced ternary string. Let's maintain the variable curRep which initially is 0 and means the number of replacements we already made.

So, we iterate over all positions i from 1 to n. Firstly, let's decrease cntsi. So the array cnt maintains the current amount of characters on suffix of the string. Now let's iterate over characters j from 0 to 2 and try to place every character. If the current character is needed (curj>0), then let's decrease curj and if the number of replacements will still be minimum possible after such replacement (curRep+need(cnt,cur)+(si≠j)=initNeed) then let's place this character, set curRep:=curRep+(si≠j) and go to the next position. This will form lexicographically minimum possible answer with minimum number of replacements.

There is another (simpler) solution from PikMike, you can call him to explain it, I just will add his code to the editorial.

Solution (Vovuh)Solution (PikMike)1102E - Monotonic Renumeration

Tutorial1102E - Monotonic RenumerationWe are interested in such subsegments of the array a that for every value belonging to this segment all occurences of this value in the array are inside this segment. Let's call such segments closed segments. For example, if a=[1,2,1,2,3], then [1,2,1,2], [3] and [1,2,1,2,3] are closed segments.

We can see that the result is some partition of the given array into several closed segments — if for some value x all occurences of x in bi do not form a segment in ai, then there exists some pair bi,bi+1 such that bi>bi+1 (which contradicts the statement); and if the formed segment is not a closed segment, then for some indices i and j such that ai=aj it is not true that bi=bj (which also contradicts the statement).

Okay, let's try to partition the array into closed segments greedily: take the first prefix of the array that is a closed segment, erase it, take the next prefix, and so on. Let m be the number of closed segments we got with this procedure.

The key fact is that any valid partition can be produced from this partition by merging some adjacent segments. To prove it, suppose we partitioned the array in some other way. The intersection of two closed segments, if it exists, is also a closed segment; so there exists at least one segment in the partition we picked greedily that can be broken into two — but that contradicts the algorithm we used to construct this partition.

So we may merge some of m segments to get a valid partition. There are exactly 2m−1 ways to do so, because for every pair of adjacent segments we may choose whether we will merge it.

Solution1102F - Elongated Matrix

Tutorial1102F - Elongated MatrixReally low constraints, choosing some permutation... Surely, this will be some dp on subsets!

At first, let's get rid of m. For each two rows calculate the minimum difference between the elements of the same columns — let's call this mn1i,j for some rows i, j. This will be used to put row j right after row i. Let's also calculate mn2i,j — the minimum difference between the elements of the column k of row i and column k+1 of row j. This will be used to put row i as the last row and row j as the first one.

Now let's think of choosing the permutation as choosing the traversal of the following graph. Vertices are rows and the weights of edges between the vertices are stored in mn1. However, you can't straight up do minimum weight Hamiltonian cycle search as the edge between the first vertex and the last one should be of weight from mn2 and not mn1.

Let's fix some starting vertex and find minimum weight Hamiltonian paths from it to all vertices. Finally, update the answer with min(mn2u,v,pathv,u). That will lead to 2n⋅n3 approach (minimum weight Hamiltonian path is a well-known problem solved by dp[maskofusedvertices][lastvisitedvertex]).

That's completely fine and it's the most intended solution.

However, there exist another solution that would have worked better if the edge weight were a bit smaller.

Let's do binary search, each time checking if the answer is greater or equal to mid. The check is simple enough. Now the graph is binary (edge exists if its weight is greater or equal to mid), thus you should check for existence of Hamiltonian path, not for the minimum weight one. That can be done in O(2n⋅n2), leading to O(2n⋅n2logMAXN) solution. The key idea of that dp is storing the vertices where the path of the current mask could have ended as a mask itself. Then it becomes dp[mask] with n transitions.

Overall complexity: O(2n⋅n3) or O(2n⋅n2logMAXN).

Solution 1Solution 2

Codeforces Round #530 — Editorial

By 300iq, 4 years ago, translation, In English1099A - SnowballThis problem can be solved in many ways, we will tell you one of them. Let's just iterate through all the heights of i from h to 1. Inside the loop, we have to add i to the weight of snowball, and then check whether there is a stone at this height. If there is, then you need to check whether weight of snowball is more than weight of the stone. If more — then subtract the weight of the stone from weight of snowball, if not — then assign the weight of snowball value 0.

Code: ism_OK_tutorial

1099B - Squares and SegmentsConsider any resulting configuration of the squares. We can safely assume that a set of non-empty rows and non-empty columns are connected (otherwise just move the disconnected part a bit closer to any other). Clearly, in every column and every row we can «for free» extend it to have all the squares in the bounding box — minimum rectangle containing the resulting figure. From this we can conclude that we can search for the optimal answer among the rectangles.

The answer for a rectangle a×b equals a+b (just draw the first row and the first column), so we need to find two values a and b such that a×b≥n and a+b is minimum possible. It's easy to see that the answer is not optimal if |a−b|≥2: by moving the numbers towards each other we get the same sum, but greater product. This observation leads to the following solution: if s=[n−−√], then the answer is either a rectangle s×s, or a rectangle s×(s+1), or a rectangle (s+1)×(s+1) (because of the rounding). We just need to check which one is better.

1099C - PostcardIf the string in the postcard does not contain any snowflakes or candy cones, k must be equal to the length of the string, because the only string encoded by such message is the string itself, and in this case if k is not equal to the length of the string, the answer is «Impossible».

Let's call the characters of the message mandatory if they are not followed by snowflakes or candy cones. Clearly k should be at least the number of mandatory characters, otherwise the answer is «Impossible».

In case there a snowflake (*) in the message, we can repeat the preceding character enough times to get the length k, and remove the rest of non-mandatory characters.

If there are no snowflakes, but only candy cones, we should use the characters followed by candy cones until we get the desired length k. In case we don't have enough, the answer is «Impossible».

1099D - Sum in the treeTo achieve the minimum possible sum of values in the tree, for vertices with even depth we need to put 0 for leaves and the maximum value possible for other vertices, because increasing the value does not make the resulting sum worse — our children would compensate for it. Since av≥0, it's obvious that spv≤spv+av=sv. For every child u of vertex v it's also true that sv≤su, hence spv≤sv≤su. From this one can derive that the maximum possible av for vertices with even hv equals minu − child vsu−spv.

Given the values av in the vertices of even depth, we can restore the values in the vertices of odd depth using the formula av=sv−spv. This requires a simple DFS (which translated to a for-loop given the tree representation in the problem statement).

1099E - Nice tableKey idea:

In a good matrix, either each row contain at most two different characters, or each column contain at most two different characters.

Proof: (it will be here, but for now the editorial fields are too narrow to contain it).

In other words, the field looks either like (up to a permutation of «AGCT»):

«AGAGAG»

«CTCTCT»

«AGAGAG» (or «GAGAGA»)

«CTCTCT» (or «TCTCTC»)

«AGAGAG» (or «GAGAGA»)

«CTCTCT» (or «TCTCTC»)

(and so on)

or similarly by columns.

So, the solution is to say that we have this alternation by rows, iterate over the permutation of letters, for each row choose from the row and its inversion the one that differs from the row of the original matrix in the minimum number of characters. Then rotate the matrix, and solve similarly again, and take a more optimal one.

1099F - CookiesIf Mitya moves the chip to vertex i during the game and then moves it back to the root, he will have exactly T−2⋅(time to reach vertex i from the root) time to eat cookies. Let's denote the maximum number of cookies he can eat during this time by f[i].

Let's first focus on what to do next, assuming we have already computed f[i]. We can use DFS to compute dp[i] — the maximum number of cookies Mitya can eat if he finishes the game in the subtree of vertex i (vertex i itself included). Let m1[i] and m2[i] be the indices of two children of vertex i with maximum value dp[j] among its children. It's simple to compute dp[i]:

In case vertex i is a leaf, dp[i]=f[i], since we can not move any further.In case vertex i is a root of the tree, we have two choices: either stop the game, or go to the child with the maximum value of dp, which means dp[i]=max(f[i], dp[m1[i]]) in this case.Otherwise, if we're in the vertex i, Vasya can remove an edge to any child j of vertex i, and clearly he would remove the one with maximum value of dp, meaning he would remove the edge from i to m1[i]. This means dp[i]=max(f[i], dp[m2[i]]), because we can also decide to stop the game in vertex i.The only thing left now is how to compute values f[i] efficiently. We can do it with another DFS: while traversing the tree, for vertex i we maintain the pairs (tj, xj) for all vertices on the path from the root to vertex i. Clearly Mitya would prefer to eat the cookies that he can eat quickly, so we maintain these vertices ordered by tj in increasing order, and to compute the answer for vertex i, we just eat the cookies from "fastest" to "slowest" until we run out of time. To do it efficiently, one can use their favourite data structure (BIT / Segment Tree / Treap) while traversing the tree, which leads to O(nlogn) solution.

1098C - Construct a treeNote, that vertex belongs to subtrees of vertexes, which lay on its way to root. So, sum of sizes of subtrees is equal to p+n, where p is sum of lengths of ways from root to vertexes. Let's consider which sum of sizes of subtrees can be in tree with branching coefficient less or equal than k.

Minimal sum can be achieved in k-nary tree (it consists of root, k vertexes on distance 1, k2 on distance 2, etc, the last level can be filled not completely).

Maximal sum can be achieved in bamboo — tree, which consists of only one way with length n. If s is bigger than sum in this tree, the answer will be «No».

Let's find minimal k, such that s is not smaller than sum of sizes of subtrees in k-nary tree (using binary search). Now s is between minimal and maximal sum of sizes of subtrees in tree with branching coefficient, which is not bigger than k.

Let's show how to build tree with the given sum, which is between these two borders. Let's start with k-nary tree.

Let's realize recursive function, which rebuilds tree. Let we are in a subtree, and want to increase sum of sizes of subtrees by x (in this subtree). We can change this subtree to bamboo with same number of vertexes (if the sum of sizeof of subtrees won't be too big). Otherwise, we run this function from subtrees in some order. If we reach needed sum, we will terminate the process. Otherwise, every subtree of child is bamboo now, current sum of sizes is smaller than needed, but if we merged bamboos, it would be bigger than it. Let's move vertexes to the end of the first bamboo from others. Over time, after next moving, sum of sizes will increase too much. We can move it to the another position in the first bamboo, in order to make sum equal to s, and terminate the process.

But if we believe that every tree with sum of sizes of subtrees between maximal and minimal can be built, there is another solution with O(nlogn) complexity, which is easier to realize.

The sum of subtree sizes is influenced only by the number of vertices at each distance, and not by their mutual arrangement. Sum of sizes of subtrees is equal to n+i⋅di, where di — number of vertexes on distance i from the root. Let's built this array of counts. These conditions must be satisfied:

If the i-th element is bigger than 0 (i>0), than i−1-th element must be bigger than 0.If the i-th element is equal to t, i+1-th mustn't be bigger than t⋅k.Sum of elements must be equal to n.Let we have recovered some prefix of this array (i.e we know that we can fill rest, and sum of sizes of subtrees will be equal to s). Let's try to put some value to the next element.

We know that the tree can be rebuilt so that the sum is any between maximum and minimum, so there are two conditions, which are satisfied (we want to put value x to position i).

x must be big enough, so if we fill suffix with numbers x, x⋅k, x⋅k2, ... (the last non-zero number can be smaller, sum of numbers is n) sum of sizes of subtrees will be not greater to s.x must be small enough, so if we fill suffix with 1, sum of sizes of subtrees will be not less than s.Both borders form some segment of values, which could be put to this position. We haven't to look for the left border, just find the right border by binsearch, and put number, which is equal to it. We can easily restore the tree, using array d.

1098D - EelsLet's consider a set of fishes of size k and sort it in non-decreasing order: a1≤a2≤…≤ak. Let's call a fish fat if its weight is greater than twice the sum of all fishes with smaller indices: fish ai is fat iff ai>2∑j<iaj.

Key fact. Let t be the total number of fat fishes. We'll prove that in this case the set of fishes has danger k−t.

Observation 1. A fat fish can't dangerously eat a fish with smaller weight. Indeed, even if all the smaller fishes eat each other, the resulting fish would be too small. We can conclude that the danger is not greater k−t.

Observation 2. Let's use the following strategy: at every moment fishes with two smallest weights fight with each other. If a battle between fishes with masses a and b is not dangerous, it's clear that fish b has not eaten any other fish yet — otherwise this fish is a sum of two smaller fishes c+d=b, where c≤d, but in this case d≥b/2>a, hence according to the strategy there must have been a fight between two fishes a and c before. This indicates that fish b has not eaten any other fish yet, and fish a is a result of battles between all smaller fishes. In this case b is a fat fish by definition, which completes the proof that this strategy guarantees exactly k−t dangerous battles.

Algorithm. Clearly now we need a data structure that allows us to perform three types of operations:

add element xremove element xfind all elements that are greater than the sum of all smaller elementsLet's split the allowed values range into half-intervals [1,2), [2,4), [4,8), ..., [230,231).

Observation 3. Every half-interval contains at most 1 fat fish, and if there is one, it's the on with the minimum value. Indeed, every single half-interval does not contain two values x and y where y>2x.

Now for each half-interval we can maintain the sum of all fishes in this half-interval, the sum of weights of fishes in this half-interval, and the minimum fish in the half-interval (one could use set / PriorityQueue or a similar data structure). In this case we can determine the count of fat fishes simply by iterating over all half-intervals. The resulting complexity is O(log2n) per query.

1098E - Fedya the PotterThere are O(N⋅logN) different values of gcd, because if we fix the left bound of a segment and iterate right bound from left bound to the end, the gcd stays unchanged or decreases in two or more times. We can get a compressed version of array b if we compress equal consecutive elements in to pair (value,countOfValue). We can use segment tree to find all segments of equal elements.

Let's estimate how many segments in array b have sum less or equals some M. If size of array b had been small, we could have done the 2 pointers technique to do that. Unfortunately, size of array b is O(N2). However, array b has a lot of equal elements. So, the solution is to process a group of equal elements in a fast way. Let's fix bounds L and R in array b, assume T - is a sum of elements beetwen L and R, after L we have a group of elements X, with size xcnt, after R we have a group of elements Y, with size ycnt. Then, it is easy to see that our task is to find out how many pairs of integers (a,b) satisfy the condition: 0<b⋅Y−a⋅X+T≤M.This is a standard task where we need to calculate all integer points under a line that can be done with the euclidean algorithm. Here the example of a plot of this function:

To find the median element, we can use a binary search with the above function.1098F - Ж-functionAnswer for query l, r is equal to ∑ri=lmin(lcp(l,i),r−i+1). lcp(i,l) is the length of longest common preffix of i-th and l-th suffixes. Let min(lcp(l,i),r−i+1) be denoted by «cutted lcp» of two suffixes. Now we can use another approach to calculate the answer. For each k=1…r−l+1 let's count number of suffixes i=l…r with «cutted lcp» ≥k, it is equal to number of suffixes i=l…r−k+1 with lcp ≥k. The sum of these values will be an answer.

Let's build the suffix tree of our string.

To count this value for fixed k and l, let's consider an ancestor of l-th suffix with depth equal to k, number of sought for suffixes is equal to a number of suffixes with numbers from l to r−k+1 in the subtree of our vertex.

So let's suppose that for each vertex v there is a data structre, which can count number of leaves with numbers from l to r−hv+1 (hv is the depth of v) in subtree of v for fixed l and r.

Now to get an answer for query we should find sum of these sums for given l and r for all ancestors with depth ≤r−l+1 of vertex which corresponds the substring of request.

Now we can just divide the request into two parts! We should count the number of leaves with numbers ≤r−hv+1 and number of leaves with numbers <l.

The first part is similar to counting number of leaves (in subtree) with numbers x, that x+hv≤r+1.

Now we should use Heavy-light decompositin of our suffix tree to find sum on way. Let's consider all O(logn) heavy ways which are above the fixed leaf. Our vertex appears in some prefixes of these ways, and its values are x+hv,x+hv+1,…,x+hv+len. So on each way there are some leaves determined by (x+hv,len) which should be considered. Lets denote these pairs by (xi,yi). Now we just need to count number of (i,j), that 0≤j≤yi and xi+j≤r+1. I.e. for each query we should calculate ∑max(0,min(r+1−xi,yj)) on prefixes of considered heavy ways.

Now we can use scaning line and Fenwick tree for each way to process all queries. It would be easy for you to find out how to do it if you understood everything before ;).

The second part can be done similary, but in this case each leaf corresponds a point, not linear function.

The complexity is O(nlog2n), which easily passes TL.

Codeforces Round #529 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1095A - Repeating Cipher

Tutorial1095A - Repeating CipherThere are many possible approaches in this problem, I will describe one of the easiest.

Let's print the initial string by the following algorithm: firstly, init the variable i=1. Then, while the encrypted string isn't empty, print the first character of this string, remove i first characters from it and increase i by one.

Solution1095B - Array Stabilization

Tutorial1095B - Array StabilizationIt is easy to see that we always have to remove either minimum or maximum of the array. So we can sort the array and the answer will be min(an−1−a1,an−a2). We also can do it without sort because two minimal and two maximal elements of the array can be found in linear time.

Solution1095C - Powers Of Two

Tutorial1095C - Powers Of TwoFirst of all, let's analyze how can we calculate the minimum number of powers of two needed to get n as the sum. We can use binary representation of n: each bit in it, which is equal to 1, becomes a summand in the answer.

Firstly, if the number of summands is greater than k then the answer is NO. Okay, what if we don't have enough summands? Every summand x>1 can be broken down into two summands equal to x2. Let's maintain all summands greater than 1 somewhere (stack, array, queue, multiset, anything you want), and pick an arbitrary summand and break it into two until we have exactly k summands. If n≥k, then this process will terminate since we will have some summand to pick until all of them are equal to 1.

Solution1095D - Circular Dance

Tutorial1095D - Circular DanceLet's write a function check(a, b) which will try to restore the circle if kid with number b comes right after kid with number a. If b comes right after a then we can determine c — the number of kid who is next to kid b. So now we have: b comes right after a, c comes right after b. Let's determine d — kid who is next to kid c.

If we repeat this operation n times then we can "determine" the answer if b comes right after a. But it can be wrong so we have to check that our answer corresponds to the input.

So if we have this function, we can apply it two times to determine the correct answer. Just call check(1,a1,1) and check(1,a1,2).

Solution1095E - Almost Regular Bracket Sequence

Tutorial1095E - Almost Regular Bracket SequenceIn this problem we have to calculate the number (count) of positions such that if we change the type of the bracket at this position then the obtained bracket sequence will become regular.

Let's calculate the balance of each prefix of the bracket sequence and store it in the array prefBal. Just iterate from left to right over the string and if the current bracket is opening then increase the current balance by one, otherwise decrease it by one.

For each prefix let's also calculate whether it can be a prefix of a regular bracket sequence (RBS) and store it in the array prefCan. The prefix of length i can be the prefix of RBS if and only if the prefix of length i−1 can be the prefix of RBS and prefBali≥0.

Let's calculate the same arrays for all suffixes (and call they sufBal and sufCan correspondingly), but now the closing bracket will increase the balance by one and the opening will decrease it by one and we consider the characters from right to left.

Now if we have these arrays, let's iterate over all positions in the initial bracket sequence. If we now at the position i then let's do the following things: firstly, if prefCani=false or sufCani=false then skip this position. Otherwise if the current bracket is opening then we have to increase the answer if prefBali−1>0 and prefBali−1−1+sufBali+1=0 (only in this case the bracket sequence will become regular). And if the current bracket is closing then we have to increase the answer if prefBali−1+1−sufBali+1=0.

Solution1095F - Make It Connected

Tutorial1095F - Make It ConnectedSuppose we have found all the edges of the graph explicitly, sorted them, and start running Kruskal on the sorted list of edges. Each time we add some edge to MST, it is either a special edge given in the input, or an edge which was generated with cost ax+ay (whichever costs less). Let's try to analyze how can we find the cheapest edge of each type that connects two components. For special edges, we may just maintain the number of special edges we already added or skipped, and when choosing a new edge, we skip some more (possibly zero) special edges that don't connect anything, until we find an edge that connects something. And for the other type of edges, we may find two components having minimum numbers on the vertices in those components as small as possible, and just connect the minimum vertex in the first component with the minimum vertex in the second component. We may simulate this by maintaining a data structure (for example, a multiset), where for each component we will store the vertex having minimum ai in this component, and pick two minimums from this set. We also have to be able to check if two vertices are connected (this can be done with DSU) and merge two components.

But this solution can be made easier. Every time we add a "non-special" edge, one of the ends of this edge is the vertex with minimum ai. So we may just find this vertex, generate all edges connecting this vertex to all other vertices, merge this set of edges with the set of special edges, and run any MST algorithm on the resulting set of edges. If there are multiple minimums in the array a, then we may pick any of them because in Kruskal algorithm it doesn't matter which of the edges with equal costs we try to add first.

Solution

Technocup 2019 — Elimination Round 4 + Codeforces Round 528: editorial

By Endagorion, history, 4 years ago, translation, In English1087A - Right-Left CipherYou can simulate the process, maintaining the indices of characters of the initial string. So, like this you can find the value of character of the initial string.

1087B - Div Times Modn has to be divisible by p=xmodk, which in turn is less than k. We can try all options of p (in O(p) time), and for suitable options restore x=p⋅n−pk. Choose the smallest possible x. Note that p=1 always divides n, hence at least one option will always be available.

1086A - Connect ThreeThe smallest possible number of plots required to connect all three plots is at least Δx+Δy+1, where Δx=xmax−xmin and Δy=ymax−ymin (here xmin, xmaxn, ymin, ymax are extreme coordinate values among the three given plots). It now suffices to find any suitable collection of plots of this size.

Let xm and ym be the median values of (xA,xB,xC) and (yA,yB,yC). For each of the plots A, B, C connect it with the plot (xm,ym) with any shortest path (if one of A, B, C coincides with (xm,ym), just do nothing). One can check that the resulting collection has size exactly Δx+Δy+1, and it clearly connects A, B and C together.

The above solution has complexity O(C), where C is the largest coordinate value. Given that C is quite small, one could go with slower solutions, for instance, instead of (xm,ym) try all C2 plots as the connecting plot.

1086B - Minimum Diameter TreeLet's denote the number of leaves in this tree for l.

Let's prove that the answer is 2sl.

To construct an example with such diameter, let's put the weight sl to the edge adjacent to the leaf, and let's put the weight 0 to other edges. It is easy to see that the diameter of this tree is 2sl.

To prove that it is the minimal possible diameter we denote leaf numbers for a1,…,al. For distxy we denote the sum of weights of edges lying on the path between vertices x and y. Then l(l−1)2⋅max1≤i<j≤ldistaiaj≥∑1≤i<j≤ldistaiaj. Note that the contribution to the sum on the right side of the inequality of the weight of each edge will be at least l−1, because any edge lies on ≥l−1 paths between the leaves of the tree. So, ∑1≤i<j≤ldistaiaj≥(l−1)⋅∑e∈Eweighte=(l−1)⋅s. So, l(l−1)2⋅max1≤i<j≤ldistaiaj≥(l−1)⋅s and we get that max1≤i<j≤ldistaiaj≥2sl.

So, to solve this problem you need to calculate the number of leaves in the tree. This can be done in linear time by counting all degrees of vertices.

Time comlexity: O(n).

1086C - Vasya and TemplatesLet's implement the following strategy: obtain the minimal string which is greater than or equal to a to correspond to at least one template. If there exists such a string and it is less than or equal to b then the answer exists, otherwise it's not.

Let's iterate over the length of prefix of the answer s′, which equals the prefix of a. For some fixed length we can restore some part of the template. For example, let prefix of s be "abd" and prefix of a be "dba", template will then look like "db?a". Also sometimes prefix can have no answer.

Now we want to expand the prefix with some character c at position i. If that character had appeared already, then the substitute is known. Also if the substitute is less than ai then the resulting string will be less than a, so it will be incorrect. If it equals ai then put it and proceed to position i+1. And if it's greater then the resulting string will be greater than a, so the rest of the string can be filled greedily, minimizing the resulting string s′.

If character c hadn't appeared previously, then let's try all possible character to substitute it (let it be some character c′). That character should be greater than or equal to ai and it shouldn't be already taken. If c′ is greater then ai, then the rest of the string can be filled greedily, minimizing the resulting string s′. Otherwise it's ai and we proceed to position i+1.

It's easy to show that the greedy filling will be performed no more than k times, thus the solution will work in O(nk).

1086D - Rock-Paper-Scissors ChampionFirst, let's determine which players can win in a given configuration. If all players have the same shape, then everyone can win. If there are only two kinds of shapes, then one shape always loses, and everyone with the other shape can win. Let's now assume there are all three shapes present. If a player i can win, then they have to independently eliminate everyone to either side. It suffices to determine if i can win everyone to their left (the other side can be treated symmetrically).

Suppose that the player i has the shape R (all the other cases are similar). We will show that i can not eliminate everyone to the left if and only if two conditions hold:

there is no S to the left of i;there is at least one P to the left of i.Indeed, if both of these are true, there is nothing stopping a P from eliminating i. Otherwise, if there are no P to the left of i, he can potentially win everyone there.

Finally, suppose that there is an S to the left of i. Here's how i can eliminate everyone to the left. First, eliminate all P's as follows: locate the closest pair of P and S, bring them together by eliminating all R's in between with the P, then eliminate the P. When we've eiliminated all P's this way, we are left with the previous case (no P's).

Now, how to deal with modifications? Assume that there are currently all three shapes present (otherwise we can easily find the answer as described at the start). How many R's can not win (similar for P's and S's)? According to our criterion, all R's losing because they can not eliminate their respective left-hand sides are located between P0 and S0, where P0 and S0 are positions of the first P and S (that is, when P0<S0, otherwise there are no R's losing this way). A similar condition applies to the R's losing because of the right-hand side. Now we simply count the number of R's in these ranges and subtract them from the total. Note that we can never subtract an R twice since there is at one S on one of its sides.

It now suffices to use any data structure that supports range summing and finding extreme values in a set, with modifications. For the range summing we may use a Fenwick tree (BIT) or a segment tree, and for extreme values an std::set will suffice. All operations we need take O(logn) time, hence each modification and answer takes O(logn) time.

1086E - Beautiful MatrixCalculate the following dp: dp[n] — the number of permutations of length n of elements 1…n such that pi≠i for every i=1…ndp[n]=(n−1)⋅(dp[n−1]+dp[n−2]);

Calculate the following dp: dp2[n][k] — the number of permutations of length n of elements 1,2,…,n,n+1,n+2,…,2n−k such that pi≠idp2[n][0]=n!dp2[n][k]=dp2[n][k−1]−dp2[n−1][k−1];

We can follow the usual process of recovering the lexicographic index. Iterate over the element to put in the current position and add the number of ways to complete the matrix to the answer.

How to calculate the number of ways to complete the matrix?

The current row can be completed the following way:

Look at the elements of the previous row (the same suffix as the one we want to complete), renumerate its elements into 1…t, where t is the length of suffix. The current row now incudes some elements which appeared in the suffix of the previous row and some which don't. Let's renumerate those that appeared correspondingly. Let there be k of such elements. Then the number of ways to complete the row is dp2[t][k].

The other rows can be completed the following way:

For any row the previous one can be renumerated into permutation of form 1…n, thus the number of ways to choose the current row is dp[n].

The only thing left is to raise dp[n] to the power of the number of rows to be completed.

That solution is O(N3) as we were looking into all the candidates for the current position. However, these candidates can be split up into two groups: those that change the value of k by 1 and those that leave it as is. Thus a single cell can be processed in O(logN) with a couple of data structures.

1086F - Forest FiresLet f(t) be the total number of trees burnt during first t seconds. The answer can be represented as tf(t)−∑i=0t−1f(i). Computing one value of f(t) can be done in O(n2) or O(nlogn) with scanline or something like that.

Let's analyze how the value of this function is changed as time goes. In the beginning, only n initial trees are burnt, then the zones around their position, expand, and so on, until two zones start intersecting. Then again, until another pair of zones starts intersecting. And so on. Let x1,x2,…,xk be the sorted sequence of moments when two zones start intersecting (this sequence has no more than O(n2) elements and can easily be computed in O(n2logn)). Let's analyze the behavior of the function f(t) on segments [0,x1−1],[x1,x2−1] and so on.

Why are we interested in such segments? Because for each such segment, f(t) can be represented as a polynomial. This can be proven with the help of inclusion-exclusion: for each subset of zones, the intersection of zones is either empty or a rectangle. And if we expand the rectangle, then during second 0 its area is ab, during second 1 — (a+2)(b+2), during second t — (a+2t)(b+2t), it's a 2-nd degree polynomial. So if we would try to compute the area of affected land through inclusion-exclusion formula, we would get a sum of no more than 2n polynomials, each having degree no more than 2, so the result is also a 2-nd degree polynomial. We can actually compute the coefficients of this polynomial by interpolation or just some pen and paper work. And f(xi)+f(xi+1)+f(xi+2)+⋯+f(xi+1−1) is a polynomial of 3-rd degree, which can be computed using some more pen and paper work.

So, to conclude, the solution consists of two steps:

find all the moments when two zones affected by different trees start intersecting;consider the function on the segments when it behaves as a polynomial.

Codeforces Round #527 (Div. 3) Editorial

By vovuh, history, 4 years ago, translation, In English1092A - Uniform String

Tutorial1092A - Uniform StringThe only thing you need to do is to place letters by blocks 1,2,…,k, 1,2,…,k and so on. The last block can contain less than k letters but it is ok. It is easy to see that this letters distribution is always not worse than others.

Solution1092B - Teams Forming

Tutorial1092B - Teams FormingIf we sort the students in order of non-decreasing their skill, we can see that the minimum cost of the team with the lowest skill (let's call it the first team) is equal to a2−a1 (if a is already sorted), the cost of the second team is a4−a3 and so on.

So if we sort a in non-decreasing order then the answer is ∑i=1n2a2i−a2i−1.

Solution1092C - Prefixes and Suffixes

Tutorial1092C - Prefixes and SuffixesThe first observation: if we will take two strings of length n−1 then we almost can restore the initial string. Why almost? Because there are two possible options: when the first string of length n−1 is a prefix and the second one is the suffix and vice versa.

Let's write a function check(pref, suf) which will check if the first string can be the prefix of the guessed string and the second one can be the suffix. After we write this function, we can run it two times (depending on the order of strings of length n−1) and find any suitable answer.

If the first string (pref) is the prefix and the second one (suf) is the suffix then the whole string s=pref+sufn−2 (0-indexed) where '+' is the concatenation of strings. Let's check if we have all prefixes and suffixes of this string in the input. We can easy do it with two nested loops and some boolean array which can say us if some string is already used or not. Firstly, let's iterate over the length of the prefix or suffix and inside let's find any string from the input matching to the current prefix or suffix. If we find all 2n−2 strings then the current string is one of the guessed and we can print the answer.

Solution1092D1 - Great Vova Wall (Version 1)

Tutorial1092D1 - Great Vova Wall (Version 1)Fairly enough, solutions of both versions of the problem are pretty similar.

The major difference between them are the vertical bricks. As you aren't required to minimize the total height, you can work not with the heights themselves but with their parities instead. Vertical brick now does nothing and horizontal brick changes the parity of neighbouring parts of the same parity.

Now imagine the following greedy solution. While you have some segment of the same parities of even length, fill it with horizontal bricks. This operation merges this segment with one to the left and to the right. If there is a single segment left then the answer is "YES". Otherwise it's "NO". The proof is left to the readers.

Implementing this as it is will be O(nlogn) at best. You'll need to keep the whole set of segments and the set with only even length ones.

But there exists more fun approach.

We don't even need the lengths of the segments — just the parities of the lengths. Then merging the even segment with something will just erase that segment and xor the length of the left and right ones. Moreover, you don't even need to erase the whole even segment, you can do it brick by brick, as this operations are now the same.

Let's simulate this with a stack. When the new number comes, push its parity to the stack. If the topmost two elements of the stack have the same parity, pop them both. Now the answer is "YES" if at the end stack has no more than one element.

When I heard of this problem, I actually had not that stack itself in mind but the correct bracket sequences. Like let's define parity 0 as '(' and ')' and parity 1 as '[' and ']'. Now the operations we perform with stack are "greedily put the closing bracket if the last unclosed bracket was of the same type" and "put opening otherwise". Then the stack will have like all the brackets which are still to be closed and you'll close them as early as you can. This idea helped to both prove the correctness of algo and implement it.

Overall complexity: O(n).

Solution 1Solution 21092D2 - Great Vova Wall (Version 2)

Tutorial1092D2 - Great Vova Wall (Version 2)Fairly enough, solutions of both versions of the problem are pretty similar.

Read the second part of the previous tutorial first.

This problem can also be implemented in the strightforward manner. The greedy solution now is searching for the first minimum in array and putting a brick in there. If it's impossible then the answer is "NO". This can also be simulated with sets, a bit more tedious but still ok and also O(nlogn).

Now back to the stack approach. Here you can't go to parities of the numbers (like tests [1,3] and [1,1] lead to different results). You push the number itself. However, you will also need an extra condition on the stack. You can't push to it the number greater than the current topmost element.

The only problem with this are maximums of array. Obviously, the resulting wall (if the answer exists) will be of height equal to the maximum initial height. And it means that you shouldn't care about the ability to match all maximums in stack. They way I suggest to take around the issue is to process separately each segment between two consecutive maximums.

One can easily prove the correctness of it by construction.

Overall complexity: O(n).

Solution1092E - Minimal Diameter Forest

Tutorial1092E - Minimal Diameter ForestLet's start with the solution and then proceed to the proof.

For each tree in a forest find such a vertex that the maximal distance from it to any vertex is minimal possible (a center of a tree). Tree may include two centers, take any of them in that case. Find the the tree with the maximum diameter. Connect the centers of other trees with its center.

Overall complexity is the complexity of looking for a diameter: O(n) or O(n2).

The center is the best vertex in a tree to connect to. The diameter of merging two trees t1 and t2 by v in t1 and u in t2 with d1 being the maximum shortest path from v to any other vertex in t1, d2 being the same for u in t2 is max(diam1,diam2,d1+d2+1). Thus minimizing both d1 and d2 will produce the best result.The most optimal structure is a star. The center tree will be connected directly to any other tree. The other trees will be connected through a single vertex among each other, which leads to the answer no more than 1 worse than connecting them directly. And building the answer the other way will exceed this difference as some tree will be connected to the center tree of the star through one vertex as well.The previous fact implies that the center tree of the star should have the maximal diameter among all trees.Solution1092F - Tree with Maximum Cost

Tutorial1092F - Tree with Maximum CostFirstly, let's calculate the answer (let it be res) for some fixed vertex. Let this vertex be the vertex 1. Just run simple dfs and calculate the result using the formula from the problem statement. Also let's calculate the sum of values (let the sum in the subtree of the vertex v be sumv) in each subtree of the given tree if its root is the vertex 1. It can be easily done with simple dynamic programming.

And now the magic part: let's apply the technique which is called "re-rooting" (at least we called it so). Let's maintain the correct values in subtrees at each step of our algorithm. How will values and the answer change if we will go through the edge (u,v)?

The following sequence of changes will change all values correctly:

Firstly, it can be seen that res will decrease by sumv (because the distance to each vertex in this subtree will decrease by one);then sumu will decrease by sumv (because we change the root of the tree) (we need this step to maintain the correct values);then res will increase by sumu (because the distance to each vertex in this subtree will increase by one);and then sumv will increase by sumu (because we change the root of the tree) (we need this step to maintain the correct values).So, we can recalculate all the values we need if we go through the edge. So now we can write another one dfs to try to update the answer for each vertex as a root (as the chosen vertex).

Solution

Codeforces Round 526 — Editorial

By TheWayISteppedOutTheCar, history, 4 years ago, In Russian1084A - The Fair Nut and ElevatorFor each request of passenger who lives on the p-th floor to get to the first floor, we need 2⋅(max(p,x)−1) energy, because in this case lift moves from the x-th floor to the p-th, then from the p-th to the first, then from the first to the x-th. So sum is |p−x|+|x−1|+|p−1| and it equals 2⋅(max(p,x)−1). if request is to get from the first to the p-th floor, number of energy is the same. So the optimal answer can be acheived be choosing the first floor as the x-th.

1084B - Kvass and the Fair NutIf ∑ai ≤s  — the answer is −1Otherwise, let v  — minimal volume from these kegs. The answer is ≤v. For all i: s-=(ai−v). Now all elements equal to v. if s become ≤0 the answer is v. Else the answer is ⌊v−(s+n−1)/n⌋.

1084C - The Fair Nut and StringFirstly, let's erase all symbols different from 'a' and 'b'. Then let's split string on blocks of consecutive symbols 'a'. Now we need to multiply all sizes of blocks increased by 1. It is an answer which also includes one empty subsequence, so we should just decrease it by one.

1083A - The Fair Nut and the Best PathLet's write on edge with length l number −l. Let sum on the path be sum of amounts of gasoline, which can be bought in cities on this path plus sum of the numbers, which were written on its edges.

If we don't run out of gasoline on some path, sum on it will be equal to amount of gasoline at the end of way. If we run out of gasoline on a path, we can start from the next city after the road, where it happened, and sum on the path won't decrease. So, there is a path with maximal sum, where we don't run out of gasoline. This sum is answer to the problem.

How to find it? Let dpi is maximal sum on vertical way, which starts in vertex i. It is not difficult to calculate dpi, using dp values for children of vertex i. Every way can be divided to two vertical ways, so we can calculate answer by turning over i, which is the highest vertex of a path, and taking the two biggest vertical ways, which starts from vertex i.

1083B - The Fair Nut and StringsIf s and t are equal, answer is n.

Let's cut common prefix of s and t, and increase answer to its length. Now s starts from "a" and t starts from "b". Let m is new lengths of s and t. If string s weren't written, we can change the lexicographically smallest string to s, and c will not decrease. We can do the same thing with t. Now s and t are in answer. We can increase answer by 2⋅m, decrease k by 2 and don't count strings, which are prefixes of s and t, while calculating c. Let's divide strings in answer into groups — two strings are in one group if and only if their first characters are equal and their largest common prefixes with s or t (it depends on the first character) are equal. Let length of group be m−lcp, where lcp — length of this common prefix.

c is equal to the number of vertexes in trie on written strings. If we have fixed l — number of strings, which will belong to some group, we have to maximize size of set of vertexes, which is union of l ways in full binary tree with height h, equals to length of group. It can be proved by induction, that the first way increases size of set by h, the second by h−1, next 2 ways by h−2, next 4 ways by h−3, etc. We can create array p, where pi - how many ways increase answer by h−i. Note that these values are additive - if we have two independent binary trees and want to distribute some number of ways between them, we can sum their arrays (and it is how prove the previous fact).

We have O(n) independent groups, and we want to sum their arrays fast. Every binary tree increases values on suffix by [1,1,2,4,...]. Let's forget about the first 1 and add it in the end. Then, put 1 to the second position in suffix, and add 2⋅ai to ai+1 for 1≤i≤n−1 in increasing order, where a — array, which we want to get. Note that values in this array could be very big, but if we change values, bigger than k, to k, answer will not change (because there are only k ways).

To calculate answer, let's take the prefix with sum k (if there are no such prefix, we take the first prefix with sum, which is bigger than k and decrease last element), fill other elements with 0. Answer will be equal sum a[i]⋅i for 1≤i≤m.

1083C - Max MexFirst let's redefine the MEX query more clearly — you need to find what is the maximum a, such that all nodes with permutation values up to a lie on the same path.

For that you can use just a simple segment tree — in a node of a segment tree you need to store is it true that all nodes with permutation values between l and r lie on the same path and if so, what are the endpoints of this path. You can merge these paths using precalculated LCA and in and out times. For example you can just check all pairs of nodes from the endpoints of paths as candidates for the endpoints of a new path. So for the MEX query you need to traverse this segment tree, and for the change query you just update paths in O(log n) nodes of your segment tree. O(n log n)

1083D - The Fair Nut's getting crazyConsider O(N2) solution: Fix intersection of this segments L…R. We will call right barrier those integer Right, that right border of right segment can be from R…Right. Also Left barrier is integer, that left border of left segment can be from Left…L. If we precalculate for each element the furthest left and right elements equal to our (gol[i];gor[i]): Right=MIN(gor[i])−1 and Left=MAX(gol[i])+1. Add to answer (L−Left+1)*(Right−R+1) for all segment intersections.Faster solution: Let's go i=1….N and keep two arrays Left and Right in any data structure, Leftj=Left barrier for segment j…i, Rightj=Right barrier for segment j…i. We need to add sum of (j−Leftj+1)*(Rightj−i+1) for all j from 1 to i. Let's do it using clever Segment Tree.Imagine we are in position i and we want to recalculate arrays Left and Right after increasing i by 1. Element Ai has furthest left equal Al. We need to do max=l on prefix 1⋯ in array Left. With Right everything is similar. We can note, that Left and Right are monotonous, so we can just do equation on some segment.

Now we want to update the answer. We are in position i, amount of good pairs of segments are (j−Leftj+1)*(Rightj−i+1)=−Leftj*Rightj-(i+1)*(j+1)+Rightj*(j+1)-Leftj*(i+1). Rightj*(j+1) we can keep in separate Segment Tree. Calculating -(i+1)*(j+1)-Leftj*(i+1) is easy too. To get −Leftj*Rightj we need segment tree, which can do update on first array segment, update on second array segment, get sum of pair products. It can be done keeping sum of Left's, sum of Right's, and sum of Left * Right, and some modificators. We can do it using push's. To see details you can see the code.

1083E - The Fair Nut and RectanglesLet's order rectangles by xi, so x1,...,xn will be increasing. If the x1,...,xn is increasing, y1,...,yn is decreasing, because there are no nested rectangles. Then lets define dpi as the maximum value, which can be acheived by choosing some subset of first i rectangles which contains the i-th rectangle. It can be calculated by dpi=max1≤j<idpj+xi⋅yi−xj⋅yi, where j is the previous chosen rectangle (we subtract xj⋅yi because it is common square of the subset for dpj and i-th rectangle). This formula can be optimized using convex hull trick and calculated in O(nlogn) or in O(n) if rectangles are already sorted.

1083F - The Fair Nut and Amusing XorLet ci=ai⊕bi.

Let's notice that if there is list of operations to both arrays, which makes them equal, applying these operations to a makes it equal to b. Because of this, applying them to c makes all elements equal to 0.

Now we are processing modifications of c. Let's make array d with length n+1, consisting of c0, n−1 values ci⊕ci+1 for 1≤i≤n−1, and cn−1. The only result in d of applying operation to c is changing two elements di, di+k to di⊕x, di+k⊕x.

Let's divide array d into k groups. Elements with the same indexes by modulo k will be in one group. Tasks for different groups are independent and matches up to the initial problem for k=2.

Now we are solving problem for k=2. Let's calculate prefix xors. Operation with k=2 changes only one prefix xor (and it is not the last prefix xor). So, if the last prefix xor isn't equal to 0, the answer is −1. Otherwise, minimal number of operations to apply is number of prefix xors, which are not equal to 0.

Let's see what modification does with prefix xors. It changes all elements from a to a⊕x on some suffix. To recalculate number of zeros fastly, let's divide array to blocks with length O(n−−√) and keep in every block count of every element and modifier. To process modification, let's update modifier for all blocks, which are covered by suffix and recalculate all counts for block, which is partly covered by it. Number of zeros in a block is count of elements, which are equal to modifier. We also have to store the last element of array, which is equal to xor of all x from modifications.

Note, that this task is solved for each of k groups, so we have to store sum of counts of non-zero prefix xors, and number of groups, where the last prefix xor is not zero.

Codeforces round #525 editorial

By mohammedehab2002, 4 years ago, In English1088A - Ehab and another construction problemWell, the constraints allow a brute-force solution, but here's an O(1) solution:

If x = 1, there's no solution. Otherwise, just print x - x%2 and 2.

Code link: https://pastebin.com/LXvuX8Ez

Time complexity: O(1).

1088B - Ehab and subtractionLet s be the set of numbers in input (sorted and distinct). In the ith step, si is subtracted from all bigger or equal elements, and all smaller elements are 0. Thus, the answer in the ith step is si - si - 1 (s0 = 0).

Code link: https://pastebin.com/bpz1YxBe

Time complexity: O(nlog(n)).

1088C - Ehab and a 2-operation taskThe editorial uses 0-indexing.

Both solutions make ai = i.

First solution, n adds and 1 modFirst, let's make ai = x * n + i (for some x). Then, let's mod the whole array with n (making ai = i). If the "add update" changed one index, we can just add i + n - ai%n to index i. The problem is, if we make ai = x * n + i, then update an index j > i, ai will be ruined. Just start from the back of the array!

Code link: https://pastebin.com/dBfhNBL8

Second solution, 1 add and n modsNote: for any a, b, if b > a, a%b = a. Additionally, if a ≥ b > , a%b = a - b.

Let's add 5·105 to the whole array, loop over ai (in order), and mod prefix i with ai - i. Why does this work? Notice that ai%(ai - i) = ai - (ai - i) = i (the second note). Also, ai won't be changed afterwards (the first note).

Code link: https://pastebin.com/L6suPC1f

Time complexity: O(n).

1088D - Ehab and another another xor problemThis problem is particularly hard to explain :/ I recommend the simulation.

Let's build a and b bit by bit from the most significant to the least significant (assume they're stored in curA and curB). Then, at the ith step,  and  have all bits from the most significant to the (i + 1)th set to 0. Notice that whether x is greater or less than y is judged by the most significant bit in which they differ (the one that has 1 is bigger). Let's query with  and .  and  can only differ in the ith bit (or a bit less significant). Now, if the results of the queries are different, a and b have the same value in this bit, and this value can be determined by the answer of respective queries (1 if the second query's answer is 1, 0 otherwise). If the queries give the same result, a and b must differ in this bit. How to know which of them has a 1 and which has a 0? We know that the greater between them (after setting the processed bits to 0) has a 1 and the other has a 0. The trick is to keep track of the greater between them. Before all queries, we send (0, 0) to know the greater. Every time they differ in a bit, the greater may change. It'll simply change to the answer of the 2 queries we sent! In other words, we know when we sent the queries that after making a and b equal in this bit, some other bit became the most significant bit in which they differ. Also, we know who has a 1 in this bit (the greater in this query). Thus, we'll keep the answer of this query for the future, so when this bit comes, we don't need additional queries.

Simulation for an exampleCode link: https://pastebin.com/b9zgKuJ6

Time complexity: O(log(n)).

1088E - Ehab and a component choosing problemAssume you already chose the components. Let the sum of nodes in the ith component be bi. Then, the expression in the problem is equivalent to average(b1, b2, ..., bk). Assume we only bother about the fraction maximization problem and don't care about k. Then, it'll always be better to choose the component with the maximum bi and throw away the rest! This is because of the famous inequality:

max(b1, b2, ..., bk) ≥ average(b1, b2, ..., bk) and the equality only occurs if all bi are equal!

This means that the maximum value of the fraction is simply the maximum sum of a sub-component in the tree. To calculate it, let's root the tree at node 1, and calculate dp[node], the maximum sum of a sub-component that contains node. Now, I'll put the code, and explain it after.

void dfs(int node,int p,bool f){    dp[node]=a[node];    for (int u:v[node])    {        if (u!=p)        {            dfs(u,node,f);            dp[node]+=max(dp[u],0LL);        }    }    if (f)    ans=max(ans,dp[node]);    else if (dp[node]==ans)    {        dp[node]=0;        k++;    }}ans denotes the maximum sub-component sum.

First, we call dfs(1, 0, 1). We calculate the dp of all the children of node. For every child u, we extend the component of node with the component of u if dp[u] > 0, and do nothing otherwise. Now, we solved the first half of our problem, but what about maximizing k? Notice that all components you choose must have a sum of weights equal to ans (because the equality occurs if and only if all bi are equal). You just want to maximize their count. Let's calculate our dp again. Assume dp[node] = ans. We have 2 choices: either mark the node and its component as a component in the answer (but then other nodes won't be able to use them because the components can't overlap), or wait and extend the component. The idea is that there's no reason to wait. If we extend the component with some nodes, they won't change the sum, and they may even have another sub-component with maximal sum that we're merging to our component and wasting it! Thus, we'll always go with the first choice, making dp[node] = 0 so that its parent can't use it, and increasing k :D

Code link: https://pastebin.com/8pCrTfuP

Time complexity: O(n).

1088F - Ehab and a weird weight formulaFirst, let's reduce the problem to ordinary MST. We know that each edge {u, v} adds ⌈log2(dist(u, v))⌉·min(au, av) to w. In fact, it also adds 1 to degu and degv. Thus, the problem is ordinary MST on a complete graph where each edge {u, v} has weight (⌈log2(dist(u, v))⌉ + 1)·min(au, av) + max(au, av)!

Let the node with the minimum weight be m. Let's root the tree at it.

Lemma: for every node u and a child v, av > au. In simpler words, the weight increase as we go down the tree.

Proof: the proof is by contradiction. Assume av ≤ au. Then, the condition in the problem (that every node has an adjacent node with less weight) isn't satisfied yet for v. Therefore, v must have a child k such that ak < av. However, the condition isn't satisfied for k, so k needs another child and the child needs another child etc. (the tree will be infinite) which is clearly a contradiction.

From that, we know that the weights decrease as we go up the tree and increase as we go down.

Back to the MST problem. From Kruskal's algorithm, we know that the minimal edge incident to every node will be added to the MST (because the edges are sorted by weight). Let's analyze the minimal edge incident to every node u. Let its other end be v. Except for node m, v will be an ancestor of u. Why? Assume we fix the distance part and just want to minimize av. We'll keep going up the tree (it's never optimal to go down, since the weights will increase) until we reach the desired distance. Now, since the minimal edge incident to every node will be added to the MST (by Kruskal's algorithm), and they're distinct (because, otherwise, you're saying that u is an ancestor of v and v is an ancestor of u), THEY ARE THE MST. Now, the problem just reduces to finding the minimal edge incident to every node and summing them up (except for m). To do that, we'll fix the ⌈log2(dist(u, v))⌉ (let it be k), and get the 2kth ancestor with the well-known sparse-table (binary lifting).

Code link: https://pastebin.com/vzJqh8si

Time complexity: O(nlog(n)).

Codeforces Round #524 (Div. 2) Editorial

By stanislav.bezkorovainyi, history, 4 years ago, In English1080A - Petya and OrigamiLet's calculate how many notebooks we need for each color separately, and the answer, obviously, will be their sum. We need 2⋅n red sheets, 5⋅n green sheets, and 8⋅n blue sheets. So we need ⌈2nk⌉ notebooks with red sheets, ⌈5nk⌉ and ⌈8nk⌉ notebooks with of green sheets and blue sheets, respectively.

C++ code: 46178226

1080B - Margarite and the best presentAt first let's simplify the problem. Let's denote as f(x) function that returns sum of the elements of the array that have indices from 1 to x inclusive.

In order to calculate the function in a fast and easy way let's split the task into two parts:

If x is even, then the sum is equal to:f(x)=−1+2−3+4−⋯−(x−1)+xf(x)=(−1+2)+(−3+4)+⋯+(−(x−1)+x)Since the number x is even the number of such pairs is equal to x2. Since the sum of the elements of each pair is equal to 1, than

f(x)=x2If x is odd, than the sum is equal to:f(x)=−1+2−3+4−⋯−(x−2)+(x−1)−xf(x)=f(x−1)−xSince x is an odd number than x−1 is an even number. And we know how to solve the problem for even numbers.

But how do we calculate the sum of the elements on an arbitrary segment?

Let's show that the sum of the elements of the array with indices from l to r inclusive is equal to f(r)−f(l−1).

f(r)=a1+a2+a3+⋯+arf(l−1)=a1+a2+a3+⋯+al−1f(r)−f(l−1)=a1−a1+a2−a2+a3−a3+⋯+al−1−al−1+al+al+1+⋯+arf(r)−f(l−1)=0+0+⋯ +0+al+al+1+⋯+arf(r)−f(l−1)=al+al+1+⋯+arOverall complexity O(1).

C++ code: 46178084

1080C - Masha and two friendsAt first let's define a function w(a,b), which returns the number of white cells on the subrectangle, the left bottom corner of which has coordinates (1,1) and the top right one has coordinates (a,b). (I will tell you how to implement the function later).

How do we solve the problem using this function?

Let's define functions W(a,b,c,d) and B(a,b,c,d), which return the number of white cells on the subrectangle which has coordinates (a,b,c,d) and the number of black cells on the subrectangle which has coordinates (a,b,c,d). (The definition of what we call the coordinates of a rectangle can be found in the statements)

It can be easily proven that

W(a,b,c,d)=w(c,d)−w(a−1,d)−w(c,b−1)+w(a−1,b−1)The value of B(a,b,c,d) can be found as the number of all cells substracted by the number of the white cells:

B(a,b,c,d)=(c−a+1)⋅(d−b+1)−W(a,b,c,d)It means that in order to calculate the value of functions W and B efficiently it is enough to be able to calculate the value of w efficiently.

How de solve the problem using the funcitons defined above?

Step 1. We should find the number of black cells and white cells in the initial chessboard (these values will be stored in the variables called black and white respectivly):

black=B(1,1,m,n)white=W(1,1,m,n)Step 2. All the black cells in the rectangle (x1,y1,x2,y2) will become white. So now:

black:=black−B(x1,y1,x2,y2)white:=white+B(x1,y1,x2,y2)Step 3. Now all the white cells in the rectangle (x3,y3,x4,y4) will become black. So now:

white:=white−W(x3,y3,x4,y4)black:=black+W(x3,y3,x4,y4)But since the functions functions B and W return the number of cells black and white cells respectively in the initial board, so it isn't enough. What we did in the intersection of the rectangles:

On step 2 we took the cells that were initially black and coloured them in white (everything is ok by now), but on step 3 we took only the cells that were initially white and coloured them in black. The cells that were initially black and coloured in white on step 2 were not coloured in black.

In order to fix this we should find the rectangle which is an intersection of the rectangles (x1,y2,x2,y2) and (x3,y3,x4,y4), find the number of black cells in it and then colour them in black.

It is obvious that the coordinates of the itersection of the rectangle are (max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4)).

If max(x1,x3)>min(x2,x4) or max(y1,y3)>min(y2,y4) then there is no intersection, so we can just terminate the program.

In another case we should apply:

white:=white−B(max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))black:=black+B(max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))So we solved the task. Now it's time to tell how to implement function w(a,b).

Let's consider following chessboards from the examples:

In order to explain more easily, I will name the pattern like this the pattern type 1

And the pattern like this the pattern type 2:

It can be easily seen that if the number of rows is even, then the number of rows of both types is equal to b2.If the number of rows is odd, then the number of rows of the type 2 is equal to ⌈b2⌉ and the number of rows of the type 1 is equal to ⌊b2⌋.

Since ⌈b2⌉=⌊b2⌋ if b is even then we can just assume that the number of rows with pattern type 1 is ⌊b2⌋ and the number of rows with pattern type 2 is ⌈b2⌉.

In the same way we can prove that the number of white cells in one row with pattern type 1 is equal to ⌊a2⌋ and in the pattern type 2 it is equal to ⌈a2⌉.

So now:

w(a,b)=⌈b2⌉⋅⌈a2⌉+⌊b2⌋⋅⌊a2⌋Overall complexity O(1).

C++ code: 46178118

1080D - Olya and magical squareAt first let's check if the value of k is not too large. This can be done greedily in the folllowing way:

First splitting operation would be applied on the only existing inital square.

After that we have 4 squares with sides 2n−1. Now we will do 4 spliiting operations each on one of them. Then we will have 16 squares with sides 2n−2. If we repeat the action n−1 times we would end up having 4n squares with size 1. After that we can't do any more operations. Of course we don't do this manually — we just substract the number of splitting operations we did on each step from the number k′ (that's the variable that is a copy of variable k — we will need the value of k later).

If at some point of the algorithm we have to do more splitting operations than there remains to, then the value of k is smaller than the maximum number of operations we can apply, thus k is not too large, so we can just stop checking. If the algorithm successfuly did n−1 iterations and k′ is still greater than 0, it means that k is greater than the maximum number of operations we can apply, so the answer is "NO". It can easily proven that for any n>30 there are no too large numbers k for them within the constraints of the task.

Now we know that we can do k operations, but can we do them in such a way the the condition of Olya's happiness is fuldilled?

Let's imagine that the constraints are not so big and we can emulate the process. We can do it in the following way:

Step 0. We split the only existing square.

Step 1. If we can apply splitting opertation to all of the squares on the path from leftmost bottom point to rigthmost top point with the reamining operations, we should do it and after that we return to Step 1. Otherwise, the size of the squares of which the path consists is equal to the size of the squares the path consits now. Go to Step 2.

Step 2. When we first did Step 1, we left one square of size 2n−1 untouched. All the remaining spliiting operations will be used in arbitrary way on it or the squares that appear from it.

Let's prove that with relatively big n we can always solve the problem with the following algorithm.

If we can build the path from leftmost bottom point to rightmost top point with squares of size 20 than everything is ok, since the remaining splitting operations can be done (we already checked that the value of k is not too large).

Otherwise, we can easily see that the number of squares to which you need to apply the splitting operation on each step changes like this: 3,7,15,⋯. It can be proven that the number of splitting operations on the i-th step is equal to:

needi=4∗2i−1−1Let's assume that we stopped on x-th iteration of Step 1. It means that the number of splitting operations remaining is less than 4∗2x−1−1. It also means that we can do at least 1+4+16+⋯+4x−1 operations on the 2n−1 square that was left untouched after the first iteration of the algorithm. Let's find the set of such numbers x that 1+4+16+⋯+4x−1 is greater or equal to 4∗2x−1−1:

1+4+16+⋯+4x−1≥4∗2x−1−1Since, in numerical system with base 4 1+4+16+⋯+4x−1 can be represented as number with length x+1 that consists only of ones, it follows that:

1+4+16+⋯+4x−1=4x−13Now, back to our inequality:

4x−13≥4∗2x−1−14x−1≥12∗2x−1−34x≥12∗2x−1−2It's obvious that function f1(x)=4x grows faster than f2(x)=12∗2x−1−2, so once the value of f1 becomes greater than the value of f2 it will never beome smaller. For x=3:

f1(3)=43=64, f2(3)=12∗22−2=46,f1(3)>f2(3)For x=2:

f1(3)=42=16, f2(3)=12∗21−2=22,f1(2)<f2(2)Now we know that the following algorithm always finds solution for all n≥3. The rest tests cases can be solved with if's, but still the algorithms works for them. The only exception is test "2 3" — there is no solution for this test, though k is smaller than the maximum number of splitting operations you can apply.

Like the first part of the solution we shouldn't do the algorthm manually – we can just on each step substract the length of the path from the variable k. (For i-th step it's needi).

Overall complexity O(logn+logk).

C++ code: 46178228

1080E - Sonya and Matrix BeautySuppose we have a submatrix and we want to check whether it is beautiful. First, each line must have a maximum of one character that occurs an odd number of times. Why is this enough to ensure that each line can be made a palindrome by reordering the characters in it? If there is exactly one character that occurs an odd number of times, then the string has an odd length and we can swap it with characters that stand in the central position of the string. All remaining characters can be paired and placed in opposite positions relative to the center of the line. Obviously, this condition is necessary. Also, in order for the submatrix to be beautiful, the following property must be satisfied: the opposing lines of the submatrix, relative to the central lines, must have the same content of characters, possibly in a different order. In other words, if the number of the first line of the submatrix is ​​i, and the number of the last line of the submatrix is ​​j, then for any integer k (0≤k≤j−i) and for any character c from 'a' to 'z' should be true, that the number of times that the character c occurs in the line with the number i+k coincides with the number of times the character c occurs in the line with the number j−k. The necessity of this condition is based on the fact that after reordering characters independently in each row, our columns should turn out to be palindromes. To better understand this, see the explanation of the third example from the problem statement.

Let us proceed to the solution of the problem: find the number of submatrices for which both of the above conditions are fulfilled. Fix the number of the first column of our submatrix. We will move the right column from the left one to the last one. So, what to do when we have two columns fixed. Let's define which strings can be palindromes, and which ones can't. To do this, we can support the auxiliary array cnt[i][c] — how many times the character c appears in the row with the number i. If the submatrix is ​​beautiful, then each of its rows can be a palindrome, which means we can break our lines into groups of maximum size from consecutive lines that can be palindromes, and solve the puzzle for each group independently.

Now we have the left and right columns of our submatrix, as well as a segment of consecutive lines, all of which can be palindromes. Then if we select any two rows and form a submatrix from these columns, rows and all rows between them, each row can be a palindrome, which means the first rule will always be fulfilled. It remains only to ensure that the second rule will be fulfilled.

Let's break all strings into equivalence classes. In other words, we will give each line some number that will characterize the content of this line — the number of times how many letters each occur in this line. If two lines coincide in content, then they will have the same equivalence class, otherwise their classes will be different. For example, if we have a set of 4 lines abac,ccab,bcaa,baab, then their classes will be 1,2,1,3, respectively. How can you find these classes? Previously, we created an array of cnt[i][c], which stores the number of occurrences of each character in each row. We can encode this array with a single number — hash. What to do when we find equivalence class for each line? Let's look at some sub-line from a row of lines. More precisely, we will be interested only in the sequence of their equivalence classes. If our submatrix (formed by all elements on this segment and between the fixed columns) is good, then the equivalence classes of opposite rows are equal. So the sequence of classes on this segment will be a palindrome. So, we reduced the task to finding the number of palindromes on some sequence. This can be done using the Manacher's algorithm for O(n) for each fixed pair of columns, or for O(nlogn) using binary search and one more auxiliary array of hashes.

More information about the mentioned topics can be found at the links listed below:

    Manacher's algorithm: https://cp-algorithms.com/string/manacher.html;     Hashes: https://cp-algorithms.com/string/string-hashing.html;     Equivalence classes: https://en.wikipedia.org/wiki/Equivalence_class;C++ code: 46178239

1080F - Katya and Segments SetsLet's have an array in which we will store each segment and the number of the set to which it belongs. Sort this array in the non-decreasing order of the left border. If the left border is equal, we sort in random order.

Now consider any query a b x y. We should find the first position where the left border of the segment is greater than or equal to x. If there is no such position, then it is obvious that the answer will be "no", since there is no set that contains at least one suitable segment. Otherwise, we are interested only in the segments from the position that we have found to the last segment in the array. We can forget about the rest. Now let's among these segments for each set with a number from a to b, find the minimum number W, such that there exists at least one segment that belongs to this set and its right bound is W (note that we consider only those segments whose left bound is greater than or equal to x). If for some segment this number W is greater than y, then the answer is "no". Otherwise the answer is "yes".

Let's create a persistent segment tree, where for each set we keep its number W. We will update our W values ​​in reverse order — from the last segment to the first one. After hanging the value of the new W, we will save the current version in our segment tree.

Then how to respond to requests? Let's find the position starting from which all the left borders of our segments will be at least x. After that, take the version of the persistent tree of segments that was added immediately after adding this segment. And in this segment tree, we take the minimum on the segment from a to b. If our minimum is greater than y, then the answer is "no". Otherwise the answer is "yes".

C++ code: 46178244

Codeforces Round #523 Editorial

By Jeel_Vaishnav, history, 4 years ago, In EnglishI hope you guys enjoyed the contest and we hope to host another one soon :)

With that said, here are the tutorials:

1061A - CoinsNotice that using maximum value coin whenever possible will be always optimal. Hence, we can use floor(S/n) coins of value n. Now, if Smodn is not equal to 0, then we need to use one more coin of valuation Smodn. Hence, our answer can be written as ceil(S/n).

Overall Complexity: O(1)Author: Ashishgup

C++ Code: 46095081Java Code: 46095332

1061B - Views MatterLet's sort the array in increasing order and find the minimum number of blocks X required to retain the same top and right views. Then, the answer would be ∑ni=1Ai−X.

For every i from 1 to N, we need to keep at least 1 block for this stack to retain the top view. Thus, X=X+1 for every i. However, we also need to maintain the maximum height we can cover till now, by keeping 1 block in this stack.

Let the previous best height we had be Y.

Then, if A[i]>Y, then we managed to increase the height Y by 1, by keeping the block at Y+1. However, if A[i]=Y, then we cannot increase the number of blocks in the right view, since we are only allowed to keep the current block in range [1,Y].

In the end, when we finish processing all the stacks, we also need to keep max(Ai)−Y blocks in the longest stack, to retain the right view as it was originally.

Overall complexity: O(nlogn)Refer to solution code for clarity.

Author: Jeel_Vaishnav

C++ Code: 46095083Java Code: 46095337

1061C - MultiplicityLet's introduce the following dynamic programming approach, dp[n][n], where dp[i][j] indicates the number of ways to select a good subsequence of size j from elements a1,a2,...,ai. Our final answer will be ∑ni=1dp[n][i].

dp[i][j]={dp[i−1][j]+dp[i−1][j−1]dp[i−1][j]if a[i] is a multiple of jotherwiseNow, maintaining a 2-D dp will exceed memory limit, however notice that dp[i] is calculated only on the basis of dp[i−1], hence mainitaining a 1-D dp will work. Also, now dp[j] is updated if and only if j is a divisor of a[i]. We can find divisors of a number x in O(x−−√).

Overall Complexity : O(n⋅(maxD+maxA−−−−−√)). Here, maxD indicates maximum number of divisors possible and maxA indicates maximum value of ai possible.

Also, we can use sieve to compute divisors of each number and achieve complexity of O(maxA⋅log(maxA)+n⋅maxD).

Authors: Jeel_Vaishnav, Ashishgup

C++ Code: 46095097Java Code: 46095342

1061D - TV ShowsSolution: Sort the TV shows on the basis of their starting time. Now, we start allocating TVs greedily to the shows. For any show i, we allocate a new TV only if there is no old TV where the show ends at ro, such that ro<li and (li−ro)⋅y<=x. Also, if there are many such old TVs, then we use the TV where ro is maximum.

Proof: Notice that there is a minimal cost of ∑ni=1(ri−li)⋅y, which will always be added. Hence, the optimal solution completely depends on the rent of new TV and the time wasted on old TVs.

Now, lets try to prove that allocating an old TV with maximum ro is optimal. Suppose we are allocating a TV to show i. Let's consider two old TVs o1 and o2, such that ro1<ro2<li and (li−ro1)⋅y<=x. In such a case, it is possible to allocate both the TVs to this show. For choosing which TV to be allocated let's consider the three possible cases:

Case I: There is no show j(j>i), such that (lj−ro2)⋅y<=x. In this case, it would be better to allocate TV o2 to show i, since (li−ro2)⋅y<(li−ro1)⋅y. Hence, allocating TV o2 to show i is optimal in this case.

Case II: There are shows j(j>i), such that (lj−ro2)⋅y<=x; but there is no show j(j>i), such that (lj−ro1)⋅y<=x. In this case, if we allocate TV o1 to show i and TV o2 to show j, then the cost will be (lj−ro2)⋅y+(li−ro1)⋅y. And, if we allocate TV o2 to show i, then we need to buy a new TV for show j and our cost will be x+(li−ro2)⋅y. Now, as (lj−ro1)⋅y>x, (lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y. Hence, allocating TV o2 instead of TV o1 to show i is optimal in this case.

Case III: There are shows j(j>i), such that (lj−ro1)⋅y<=x. In this case, if we allocate TV o1 to show i, cost will be (li−ro1)⋅y+(lj−ro2)⋅y. If we allocate TV o2 to show i, cost will be (li−ro2)⋅y+(lj−ro1)⋅y. Here, we can see that in both of the allocations, the cost is (li+lj−ro1−ro2)⋅y and so any allocation is optimal here.

Hence, we can see that if more than one old TVs are available, allocating the one with maximum ro is always optimal.

Overall Complexity: O(n⋅logn)Authors: Jeel_Vaishnav, Ashishgup

C++ Code: 46095154Java Code: 46095344

1061E - PoliticsLet's create a graph with a source, sink and two layers. Let the left layer denote the nodes of tree 1 and right layer denote the nodes of tree 2.

Let's denote xi as the demand of the ith node.

For a demand (k,x) in tree 1, we add an edge from source to node k in the left layer with cost=0 and capacity=x−∑xj, such that j is not equal to i and j belongs to the subtree of i.

Similarly for a demand (k,x) in tree 2, we add an edge from node k in the right layer to sink with cost=0 and capacity=x−∑xj, such that j is not equal to i and j belongs to the subtree of i.

Now, for every node i, let col1i be the closest node to i, such that i belongs to subtree of col1i and the demand of col1i in tree 1 has been provided. Similarly col2i be the closest node to i, such that i belongs to subtree of col2i and the demand of col2i in tree 2 has been provided.

For every node i, we add an edge from col1i in left layer to col2i in right layer with capacity=1 and cost=−ai.

Now, when we run min cost max flow on this graph, our answer will be negative of the minimum cost obtained.

Overall Complexity: O(n3) using MCMF with bellman ford; O(n2⋅logn) using MCMF with Dijkstra.

Author: Jeel_Vaishnav

Java Code: 46095349

A nice explanation of Problem E by Kognition in the comment section: https://codeforces.com/blog/entry/63352?#comment-473028

1061F - Lost RootThis solution had many randomized approaches, some with higher probability of passing and some with lower probability of passing.

The author's solution (there exist better solutions with even lower probability of failure - comment yours below) is as follows:

Part 1: Checking if a node is a leaf node:

It can be done in O(n) queries.

Suppose candidate node is XGenerate a random node Y(!=X)For all Z, if Y X Z is false, then X is a leaf node, otherwise is not.

Part 2: Finding a leaf node:

Generate a random node and check if it is a leaf node. Probability of getting a lead node is >=0.5. Higher the K, higher the probability.

So we can find a leaf node in O(20⋅n) queries with failure probability (1/2)20Part 3: Generating a leaf node in other subtree of the actual root:

Fix a random node (that is not the same as the leaf node, L1, that we found), check if it is a leaf node, and if it is a leaf node and check if 2h−1 nodes separate Leaf 1 and this current leaf. If yes, we have found two separate leaf nodes and the 2h−1 candidate nodes for the root. We can use  O(40⋅n) queries to ensure a failure probability of (1/2)20Finally: Instead of checking all of them separately in 2H⋅N, we can fix their order in O(H2) by finding each node's appropriate position by placing them incrementally. Let the initial path be L1 L2, then we add X to get L1 X L2. Now to find Y's appropriate position, we check if it lies between L1, X or X, L2. And so on. In the final order, the middle node would be the root.

Author: Ashishgup

C++ Code: 46095066Java Code: 46095373

Codeforces Round #522 and Technocup 2019 Elimination Round 3 Editorial

By Golovanov399, history, 4 years ago, translation, In EnglishWe are sorry that you were having troubles with access to Codeforces.

Problem A of elimination/div21032A - Kitchen UtensilsSuppose we've found the minimum possible number p of dishes served for each person. If the input contains utensils of t types exactly, it's clear that the total number of utensils used is at least p⋅t⋅k and the number of utensils stolen is at least p⋅t⋅k−n. Moreover, it's easy to construct an example with this exact number of stolen utensils having our n objects served.

It is also easy to note that the minimum p is equal to the ratio of the maximum number of utensils of one type and the number of guests, rounded up.

Problem B of elimination/div21032B - Personalized CupLet's iterate over all possible pairs (a,b) with 1≤a≤5 and 1≤b≤20 to find the optimal one satisfying the inequality a⋅b≥|s|. So now we need to place the characters of s in the same relative order through the table. Possibly, several cells will remain unused, but we will distribute them over the table and place at most one asterisk in every row.

One can show that we will have at most one asterisk in each row, because otherwise we would have been able to reduce the value of b.

Problem C of elimination/div21032C - Playing PianoLet dp[i][j] be −1 if we cannot play the first i notes in such a way that the i-th note is played by the j-th finger, otherwise let this be the number of the previous finger in any of possible fingerings. This dp can be easily calculated for about 5n⋅5 operations.

Problem D of elimination/div2 = problem A of div11032D - Barcelonian DistanceOne way is to handle some cases: intersect the line with the border of the bounding box of (x1,y1) and (x2,y2), and relax answer by some values depending on the mutual location of intersection points, as on the pics below. Another way is to intersect horizontal and vertical lines through (x1,y1) and (x2,y2), intersect them with the ax+by+c=0 line, consider the obtained 6 points as vertices of a graph, add all horizontal and vertical edges in this graph, run Floyd/Ford-Bellman/Dijkstra algorithm.

Problem E of elimination/div2 = problem B of div11032E - The Unbearable Lightness of WeightsSuppose the numbers a1,a2,…,an can have only up to two different values. Then we can unambiguously determine the masses of all the weights (e.g., suppose there are t weights with a mass of w each, then we can ask our friend about a set of t weights with a total mass of t⋅w; the only thing he can do is to return all the weights with the mass w, so we can reveal the masses of all the weights).

If the masses of the weights have at least three different values then the only thing we can do is to determine several weights of the same mass (because if the friend tells us a set having distinct masses, we cannot distinguish them from one another; the same holds for the set of remaining weights). So we need to ask our friend such values (k,m) that the only way to obtain the mass m using k weights is to take k weights of mass mk each.

So now we have reduced our problem to finding for every w≤∑i=1nai and every number of weights k≤n the number of ways (regardless of the order of the weights) to obtain a mass of w using precisely k weights. This value cnt(w,k) can be computed via a simple dynamic programming.

Finally, the answer will be equal to the maximum such k that for some b there exist at least k weights with mass b each and the mass k⋅b can be obtained uniquely.

One should note that it's sufficient to calculate, say, min(2,cnt(w,k)) instead of cnt(w,k) since the latter can be quite large.

Problem F of elimination/div2 = problem C of div11032F - Vasya and Maximum MatchingFirstly let's understand when the maximum matching in the tree is unique — and it is unique if and only if it's perfect (i. e. every vertex having at least one incident edge is saturated). So the problem is reduced to counting the number of ways to split the tree so that each component having size 2 or more has a perfect matching.

Let's use dynamic programming to do this. Let dpv,0…2 be the number of ways to delete edges in the subtree of v so that in this subtree every component is valid (if its size is more than 1, then it has a perfect matching). The second parameter can take one of three values:

dpv,0 — v can be used for the matching (but it's not necessary to do it).

dpv,1 — v is already used in the matching.

dpv,2 — v is not used in the matching yet, but we have to match it to some vertex.

Then

dpv,0=∏todpto,0+∑to(dpto,1⋅∏to′,to′≠to(dpto′,0+dpto′,2)),

dpv,1=∏to(dpto,0+dpto,2),

dpv,2=∑to(dpto,1⋅∏to′,to′≠to(dpto′,0+dpto′,2)),

where to and to′ are children of v.

Problem G of elimination/div2 = problem D of div11032G - ChatteringLet us for a moment think that parrots stand in a line. We want to compute a series of values ri,k and li,k. li,k is the index of the leftmost parrot that will chatter in 2k seconds after the i-th parrot starts chattering. ri,k is defined similarly. Clearly, li,0=i−ai and ri,0=i+ai.

We calculate li,k using the values with lesser k. Precisely, li,k=minlt,k−1, where t goes in range [li,k−1,ri,k−1]. Explanation: the i-th parrot triggered some t-th parrot in 2k−1 seconds, then the t-th parrot triggered some other parrot in next 2k−1 seconds. Thus we want to find such t that the leftmost parrot triggered by t is minimum possible.

We use a segment tree or a sparse table on the values of the (k−1)-th level to compute the value of the DP on the k-th level.

The idea for the solution on a circle is essentially the same, but you must consider segments more carefully. One rather simple way to do it is to duplicate all the parrots, now numbering them …,−2,−1,0,1,…,n−1,n,n+1,… such that the numbers with the same remainder modulo n denote the same parrot. Then we can bound the values for li,k and ri,k between −n and 2n. Now a range query over a circle transforms to a constant number of range queries over a segment.

Time complexity: O(nlog2n).

Problem E of div11078E - Negative Time SummationDisclaimer: there seem to be solutions much simpler than the author's. You can read some passed codes.

Let's define our workplace as follows: we will take 6 rows, containing (in order from up to down): carry bits, bits of a, bits of b, two lines of some buffer garbage and the line with the answer. Consequently, these strings have y-coordinates from 2 to −3.

Now our plan is to do the following:

add leading zeroes to the left of a and b,go back to the right end of numbers,a little more than 30 times (say, 32) do the following:add a zero carry bit, if necessary,calculate xor(carry,ai,bi), which is the i-th digit of the result,calculate maj(carry,ai,bi), which is the new carry (maj is the majority function which returns 1 iff at least 2 of 3 arguments are 1),move one cell to the left to the next digits.To do this we can implement some helper functions. Let inv(dir) be the direction opposite to dir (for example, inv(l) = r):

move_if_1(dir) = <dir><inv(dir)>st

This means that after running the subprogram, say, lrst, robot goes one cell to the left iff it was standing on 1, otherwise it doesn't do anything. Let's write some other subprograms:

move_if_0(dir) = <dir><inv(dir)>t

move_if_not_empty(dir) = <dir>s<inv(dir)>t

copy(dir) = <dir>10<inv(dir)>t

The last subprogram copies a symbol one cell to the given direction. It's important that it's the first function which works properly only when the robot is standing on a non-empty cell.

Explaining how to build a maj and xor of three arguments seems really hard to me, but the idea is as follows: we (ab)use the fact that these functions are symmetric (that is, their result doesn't depend on the order of the arguments), so if we have three bits one under another and we want to obtain some f(x,y,z) somewhere under them, we can first copy them one, two and three times, respectively, place necessary bits in the buffer zone and then do something like

move_if_1(r) d move_if_1(r) d move_if_1(r) d do_something

In the end we should obtain something like this (if numbers were no more than two bits long):

Here is a gif with our algorithm adding 2 to 3 if the length was no more than 2.

Codeforces Round #521 (Div. 3) Editorial

By vovuh, history, 4 years ago, In English1077A - Frog Jumping

Tutorial1077A - Frog JumpingWith each pair of jumps of kind "to the right — to the left" the frog jumps a−b. So the answer is almost (a−b)⋅⌊k2⌋. Almost because there can be one more jump to the right. So if k is odd then we have to add a to the answer.

Solution1077B - Disturbed People

Tutorial1077B - Disturbed PeopleThe first observation is that we are interested only in patterns of kind "101". All other patterns don't make sense at all.

So, let's build a greedy approach. Let's iterate over the given array from the left to the right and maintain that the prefix of the given answer is already correct. If now we are at some position i, ai−1=ai+1=1 and ai=0 (and the prefix from 1 to i−2 is already correct) then which one 1 we have to replace? When we replace the left one then we cannot do better in the future, but when we replace the right one then we can fix some on the suffix of the array.

The easiest example is "1101011". If now we are at the position 3 then we will do better if we will set a4:=0.

Solution1077C - Good Array

Tutorial1077C - Good ArrayThe first part: calculate the sum of the whole array: sum=∑i=1nai (be careful, it can be 2⋅1011!).

The second part: let's maintain an array cnt of size 106+1 where cnti will be equal to the number of elements in the given array equals to i.

The third part: iterate over the array, let the current position be i. Set sum:=sum−ai, make cntai:=cntai−1. If sum is even, sum2≤106 and cntsum2>0 then the index i is nice otherwise it doesn't. And after all make cntai:=cntai+1 and set sum:=sum+ai.

Solution1077D - Cutting Out

Tutorial1077D - Cutting OutLet's solve the problem using binary search by the answer. It is easy to see that if we can construct the answer for some number of copies val then we also can do it for val−1. The only thing we need is to write the function can(val) which will say can we cut off val copies of some array t from s or not.

Let's imagine val copies of string t as a matrix of size val×k. Obviously, each row of this matrix should be equal to each other row. Let's fill not rows but columns of this matrix. For some element i of s we can easy notice that we can take exactly ⌊cntival⌋ columns containing this element where cnti is the number of such elements in s. So, overall number of columns we can fill in this matrix will be ∑i=12⋅105⌊cntival⌋. If this value is greater than or equal to k then can(val) is true otherwise it is false.

It is easy to construct the answer using all things we described above.

Overall complexity is O(n+|A|logn) where |A| is the size of the alphabet.

Solution1077E - Thematic Contests

Tutorial1077E - Thematic ContestsThe first thing: we don't need the problems, we need their counts. So let's calculate for each topic the number of problems with this topic and sort them in non-decreasing order. The counting can be done with std::map or another one sorting.

The second thing: the answer is not exceed n (very obviously). So let's iterate over the number of problems in maximum by the number of problems thematic contest. Now we have to calculate the maximum number of problems we can take in the set of thematic contests. Let's do it greedily.

The number of contests in the set don't exceed logn. Let the number of problems in the current contest be cur (at the beginning of iteration the current contest is the maximum by the number of problems). Let's take the topic with the maximum number of problems for this contest. If we cannot do it, stop the iteration. Otherwise we can (maybe) continue the iteration. If cur is even then divide it by 2 and continue with the rest of topics, otherwise stop the iteration. Which topic we have to choose for the second one contest? The answer is: the topic with the maximum number of problems (which isn't chosen already). So let's carry the pointer pos (initially it is at the end of the array of counts) and decrease it when we add another one contest to our set. All calculations inside the iteration are very obviously.

Let's notice that one iteration spends at most logn operations. So overall complexity of the solution is O(nlogn).

The last question is: why can we take the maximum by the number of problems topic each time? Suppose we have two contests with numbers of problems x and y, correspondingly. Let's consider the case when x<y. Let the number of problems of the first contest topic be cntx and the number of problems of the second contest topic be cnty. The case cntx≤cnty don't break our assumptions. The only case which can break our assumptions is cntx>cnty. So if it is then we can swap these topics (because x<y and cntx>cnty) and all will be okay. So this greedy approach works.

Solution1077F1 - Pictures with Kittens (easy version)

Tutorial1077F1 - Pictures with Kittens (easy version)Let's solve the problem using dynamic programming. Let dpi,j be the maximum total beauty of pictures if Vova is at the i-th picture now, the number of remaining reposts is j and Vova reposted the i-th picture. Initially, dp0,x=0 and all other values of dp are −∞.

Let's learn to do some transitions to calculate this dynamic programming. What is the way to do it? Let's iterate over the position of the previously reposted picture and try to update dpi,j using previously calculated values. Obviously, this position can be from i−1 to i−k. So let's iterate over the position (let it be p) and if dpp,j+1 (we need one more repost to repost the i-th picture) is not −∞ then try to update dpi,j=max(dpi,j,dpp,j+1+ai) (pictures are 1-indexed).

So, where can we find the answer? The answer is maxi=n−k+1ndpi. If this value is −∞ then the answer is -1.

Overall complexity is O(nkx).

Solution1077F2 - Pictures with Kittens (hard version)

Tutorial1077F2 - Pictures with Kittens (hard version)Let's use dynamic programming described in the previous tutorial to solve this problem too. But its complexity is O(nkx) so we have to improve some part of the solution.

Let's see how we do transitions in this dp: for p∈[i−k;i−1] dpi,j=max(dpi,j,dpp,j+1+ai). What can we do to optimize it? ai is the constant and we have to take the maximum value among dpi−k,j+1,dpi−k+1,j+1,…,dpi−1,j+1. You will say "segment tree"! I say no. Not a segment tree. Not a sparse table. Not a cartesian tree or some other logarithmic data structures. If you want to spend a lot of time to fit such solution in time and memory limits — okay, it is your choice. I prefer the queue with supporting the maximum on it.

The last part of this tutorial will be a small guide about how to write and use the queue with supporting the maximum on it.

The first part of understanding this data structure is the stack with the maximum. How do we support the stack with the maximum on it? That's pretty easy: let's maintain the stack of pairs, when the first value of pair is the value in the stack and the second one is the maximum on the stack if this element will be the topmost. Then when we push some value val in it, the first element of pair will be val and the second one will be max(val,s.top().second) (if s is our stack and top() is the topmost element). When we pop the element we don't need any special hacks to do it. Just pop it. And the maximum on the stack is always s.top().second.

Okay, the second part of understanding this data structure is the queue on two stacks. Let's maintain two stacks s1 and s2 and try to implement the queue using it. We will push elements only to s2 and pop elements only from s1. Then how to maintain the queue using such stacks? The push is pretty easy — just push it in s2. The main problem is pop. If s1 is not empty then we have to pop it from s1. But what do we do if s1 is empty? No problems: let's just transfer elements of s2 to s1 (pop from s2, push to s1) in order from top to bottom. And don't forget to pop the element after this transfer!

Okay, if we will join these two data structures, we can see that we obtain exactly what we want! Just two stacks with maximums! That's pretty easy to understand and implement it.

The last part of the initial solution is pretty easy — just apply this data structure (in fact, x+1 data structures) to do transitions in our dynamic programming. The implementation of this structure can be found in the authors solution.

Total complexity of the solution is O(nx).

Solution

Codeforces Round #520 TUTORIAL

By JATC, history, 4 years ago, In English1062A - A PrankSince 1≤ai≤103 for all i, let set a0=0 and an+1=1001. For every i,j such that 0≤i<j≤n+1, if aj−j=ai−i then we can erase all the elements between i and j (not inclusive). So just check for all the valid pairs and maximize the answer. Time complexity: O(n2).

1062B - MathBy factorizing n we get n=p1a1p2a2…pkak (k is the number of prime factors). Because we can't get rid of those prime factors then the smallest n is p1p2…pk. For each ai, let ui be the positive integer so that 2ui≥ai>2ui−1. Let U be max(ui). It's clear that we have to apply the "sqrt" operation at least U times, since each time we apply it, ai is divided by 2 for all i. If for all i, ai=2U then the answer is U, obviously. Otherwise, we need to use the operation "mul" 1 time to make all the ai equal 2U and by now the answer is U+1.

Complexity: O(sqrt(N))1062C - Banh-miFor each part that we choose, we need to calculate how many times that element is added to our score. You can see that, the first element that we choose is added 2k−1 times in our score (k=r−l+1), the second element is added 2k−2 times and so on. Therefore, we just need to choose all the 1s first and then all the remaining parts. The final score is (2x−1)⋅2y, where x is the number of 1s and y is the number of 0s. Complexity: O(n+Q).

1062D - Fun with IntegersFor every integer x (1≤x≤n), let's call D the set of integers that are able to be transformed into x. As you can see, if a could be transformed into b then −a could also be transformed into b. Therefore |D| is always even. Let's build a graph consists of 2n−2 nodes, numbered −n through n (except for −1, 0, and 1). There is an weighted undirected edge between node u and v if and only if u can be transformed into v. The weight of the edge is the score of the transformation. Every node in the graph has an even degree so you can split the graph into some connected components so that each components is an Euler circuit (a circuit that contains all the edges). Therefore you just need to find all those Euler circuits and maximize your score. Moreover, you can see that, if an integer a can be transformed into b then x and 2 are in the same component. Proof: Suppose a<b, there exists an integer x=b/a. If x=2 then it is proved, otherwise there exists an integer c=2x<b≤n. c and 2 are in the same component so x and 2 are also in the same component. Therefore, if we ignore all the nodes that have no edges attached to it, the graph will be connected. So you need to simply get the sum of all the weights of the edges.

The complexity is O(n+nlog(n)) since the number of edges can go up to nlog(n).

1062E - CompanyLet's call inu the time that we reach the node u in depth first search and outu=max(inv1,inv2,⋯,invk) where vi is a child of u. If node u is in charge of node v (u is an ancestor of v) then inu≤inv≤outu. Suppose we don't have to ignore any node then the answer to each query is the LCA of two nodes u and v (l≤u,v≤r), where u and v are chosen so that inu=max(inl,inl+1,…,inr) and inv=min(inl,inl+1,…,inr). Proof: Let r be the LCA of u and v, then inr≤inv≤inu≤outr. For every node w∈[l,r], inv≤inw≤inu⇒inr≤inw≤outr⇒r is an ancestor of w. Therefore, the node that needs to be ignored is either u or v. Suppose we ignore u, the query splits into two halves [l,u−1]∪[u+1,r]. We find the LCA to each half and get the LCA of them. We do similarly for v and optimize the answer.

Complexity: O(Nlog(N)+Qlog(N)).

1062F - Upgrading CitiesThe main idea of this problem is to calculate inu and outu for every node u, where inu denotes the number of nodes that can reach u and outu denotes the number of nodes that can be reached by u. If inu+outu=N+1 then u is important or N if u is semi-important.

However, it may not possible to calculate inu and outu for every node u in given time (please tell me if it's possible) so we have to do some tricks.

First of all, we need to find an arbitrary longest path (P)=s1→s2→...→sk on the graph (k is the number of nodes on this path). If a node is important then it must lie on this path (1). Proof: Assume there is a node u that is important and doesn't lie on (P). Let si be the rightmost node on (P) and can reach u. It's true that i<k, because if i=k then we have a longer path than the one we found so it's not possible. By definition of i, si+1 cannot reach u. Therefore u must be able to reach si+1 (because u is important). This leads to a conflict: We have a path that is longer than the one we found: s1→s2→⋯→si→u→si+1→⋯→sk. Therefore statement (1) is proved.

It takes O(N+M) to find (P).

Let's deal with important nodes first. Because all important nodes lie on the path (P) so it makes no sense to calculate in and out for those nodes that don't belong to (P). We can calculate out by iterate through P from sk to s1. At each node si, we just need to use bfs or dfs to search for the nodes that can be reached by si. Because we visit each node 1 time then it takes O(N+M) to do this. To calculate in we just need to reverse the direction of the edges and do similarly.

Now we need to find the semi nodes. There are two types of semi nodes: those belong to (P) and those don't. For the ones belong to (P), we just need to check if inu+outu=N. For the ones don't belong to (P), suppose we are dealing with node u. Let si be the rightmost node on (P) that can reach u and sj be the leftmost node on (P) that can be reached by u. It's obvious that i<j−1. Let Lu=i and Ru=j, let leng equal j−i−1. If leng>1 then u is not a semi node (because we have to delete all nodes between i and j not inclusive), or else we must erase si+1 to make u a semi important node. We can see that the path from si to u contains only si and u, and the path from u to sj contains only u and sj, because otherwise there exists a longer path than (P), which is false. So we consider u as a candidate. Moreover, if exists a node v that is a candidate and Lu=Lv (also leads to Ru=Rv) then both u and v are not semi important nodes. Proof: After we delete si+1, for u, exists a path that is as long as (P) and does not go through u (it goes through v) so u is not a important node, based on statement (1). Same for v. Briefly, at this point we have the path (P) and a list of nodes u1,u2,...,ut. For every i, ui is a candidate and Lui+1=Rui−1. For every i, j, Lui!=Luj.

So now we are going to calculate in and out for those candidate nodes. We can do this similarly as when we find the important nodes. To calculate out, iterate through sk to s1. At each node si, bfs or dfs to search for nodes that can be reached by si. Additionally, if there is a candidate node v that Rv=i−1, we start a search from v to find those nodes that can be reached by v, we have outv=outsi+ the number of nodes we just found. After that we pop those nodes from the stack (or whatever), mark them as not visited and continue to iterate to si−1. To calculate in we reverse the directs of the edges and do the same. Because each node is visited 1 time by nodes on (P) and at most 2 times by candidate nodes so it takes O(3(N+M)).

The total complexity is O(N+M).

Sorry if the tutorial for F is too long.

Codeforces Round #519 Editorial

By Anadi, history, 4 years ago, In English1043A — ElectionsTutorialWe can observe that result cannot exceed 201 — Awruk gets at least 101 votes from one person and Elodreip cannot get more than 100 votes from one person. So we can iterate over every possible integer from 1 to 201 and check if Awruk wins with k set to this integer. We have to remember that k — ai is always at least 0, so we have to check this condition too. Complexity O(n * M), where M denotes maximum possible value of ai. Try to solve it in O(n).

SolutionAuthor: Anadi

1043B — Lost ArrayTutorialFirst, let's observe that we can replace array ai with array bi = ai  -  ai - 1, because all we care about are differences between neighboring elements. Now, we can see that our lost array can have length d if and only if for every j such that j  +  d  ≤  n, bj  =  bj + d. So we can iterate over every possible d from 1 to n and check if it is correct in O(n). Complexity of whole algorithm is O(n2).

SolutionAuthor: Anadi

1043C — Smallest WordTutorialBasically in problem we are given a word in which for every i we can reverse prefix of first i elements and we want to get the smallest lexicographically word. We will show that we can always achieve word in form ajbn - j.

Let's say that we solved our problem for prefix of length i and for this prefix we have word ajbi - j (at the beginning it's just empty word). If our next letter is b then we do nothing, because we will get word ajbi - j + 1 which is still the smallest lexicographically word. Otherwise we want to reverse prefix of length i, add letter a and reverse prefix of length i  +  1, so we get a word aj + 1bi - j, which is still fine for us.

There is still a problem — what if we have already reversed prefix i and we just said that we will reverse it second time. But instead of reversing it second time, we can deny it's first reverse.

Final complexity is O(n).

SolutionAuthor: Anadi

1043D — Mysterious CrimeTutorialDeleting prefix and suffix is nothing more than taking a subarray. If subarray is common for all permutations then it has to appear in first permutation. We renumber all permutations such that first permutation is 1, 2, ..., n  -  1, n.

Now for every i in every permutation we count how long is subarray starting at i which looks like i, i  +  1, ..., i  +  k. It can be easily done in O(n) for one permutation with two pointers technique.

Now for every element i we compute reach[i] equal the longest subarray starting in i which looks like i, i  +  1, ..., i  +  k and it apears in all subarrays. It is just minimum over previously calculated values for all permutations.

Now we can see that our result is . Final complexity O(nm).

SolutionAuthor: Anadi

1043E — Train Hard, Win EasyTutorialLet's compute result if there are no edges, we can add them later. If there are no edges then result for pair (i, j) is min(xi  +  yj, xj  +  yi). First let's fix i for which we want to compute result. Then calculate result with all pairs j such that xi  +  yj  ≤  xj  +  yi. After some transformations we get that xi  -  yi  ≤  xj  -  yj. Similarly we have that yi  +  xj  <  xi  +  yj if xi  -  yi  >  yj  -  xj.

So let's sort over differences of xi  -  yi and compute prefix sums of xi and suffix sums of yi. Now we can compute for every i result in O(1). Then we can iterate over every edge (u, v) and subtract min(xu  +  yv, xv  +  yu) from result of u and v.

Complexity O(nlogn).

SolutionAuthor: Rzepa

1043F — Make It OneTutorialFirst let's observe that if there exists valid subset then it's size is at most 7 (because product of 7 smallest primes is bigger then 3 * 105). Let's define dp[i][j] — number of ways to pick i different elements such that their gcd is equal to j. We can use inclusion--exclusion principle to calculate it. Then dp[i][j] =  — , where cntj denotes number of ai such that j | ai. Because for k * j  >  3 * 105, dp[i][k * j]  =  0 we have to check only k * j  ≤  3 * 105.

Our answer is the smallest i such that dp[i][1] is non-zero. Since dp[i][j] can be quite big we should compute it modulo some big prime.

Final complexity is O(logM * (n + M)), where M is equal to maximum of ai.

Solution 1Solution 2Author: Anadi

1043G — Speckled BandTutorialLet's solve the problem for some string s for any time.

Let's say, that partition of string s into k strings s1s2... si1, si1 + 1... si2, ..., {sik - 1 + 1}... sik is good if at least one pair of this strings are equal. We want to find a minimal possible number of different strings in all good partitions.

It's easy to see, that the answer is  - 1 if and only if all symbols in s are different. And if we have two equal symbols si = sj (i < j) we can cut a string into strings s1... si - 1, si, si + 1... sj - 1, sj, sj + 1... sn and it is a good partition. In this partition there is at most 4 different strings.

So the answer can be  - 1, 1, 2, 3, 4.

The answer is  - 1 if all symbols in s are different (case 0).

The answer is 1 if the string s = aaa... a, for some string a (case 1).

The answer is 2 if the string s is aab, aba or baa for some strings a and b (case 2).

The answer is 3 if the string s is baac, bcaa or aabc for some strings a, b, c. In two last cases it's easy to see, that |a| = 1 (case 3).

To solve our problem let's build suffix array with lcp for string s. And let's find lti~--- minimal possible number r, such that sisi + 1... sr is a tandem (the string, that can be presented as aa for some string a) and rti~--- maximal possible number l such that slsl + 1... si is a tandem. This numbers can be found using Main and Lorentz algorithm for finding tandem repetitions in the string.

Now we can solve query for segment [l, r]: \begin{itemize} \item Case 0: if r - l ≥ 26, there exists equal symbols, otherwise we can check it by O(r - l); \item Case 1: to check that s[l... r] = aa... a we can see that |a| is a divisor of (r - l + 1) and (r - l + 1) / |a| is a prime number (if we take a longest possible string a). So we should check only O(log(n)) lenghts of string a; \item Case 2: s = aab  ltl ≤ r, s = baa  rtr ≥ l. In the last case we should check, that s[l... r] has a border. It's the most interesting part of the problem, let's solve it in the end; \item Case 3: s = abac  sl exists on sl + 1... sr (can be done using prefix sums), s = baca  sr exists on sl... sr - 1 (can be done using prefix sums). To check s = baac we can check, that lti ≤ r for some l ≤ i ≤ r, that can be done using minimum on segment in the array lt. \end{itemize}

Now we should the hardest part of this problem~--- we have some segments [l, r]. For all of them, we should check that the border of s[l... r] exists. Here I know two methods, that uses only suffix array. Easiest of them:

We have segment [l, r]. Let's check for all lengths , that s[l... (l + b - 1)] = s[(r - b + 1)... r]. If we don't find border, if it exists, it's length . Let's define i~--- maximal index i such that lcp(l, i) ≥ r - i + 1, and string s[i... r] is a border of s[l... r]. So . But it's easy to see, that the distance between l and i in suffix array  , so we need to check only  variants of i.

Another method can check that border exists for all segments [l, r] using offline algorithm by O(q·log(n)2) time.

So the total complexity will be  or O((n + q)·log(n)2).

Solution 1Solution 2Author: isaf27

Codeforces Round #518 — editorial

By kristevalex, history, 4 years ago, In English1068A - BirthdayTo get L new coins irrespective of the Ivan's collection he must get not less than L+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift X coins if X⋅M>N.

Complexity is O(1).

1068B - LCM[a,b]a=b(a,b), here (a,b) is greatest common divisor. Let's see how many different values can have c=(a,b). All values c that divides b are reachable if a=c and every value of (a,b) divides b. So answer is number of divisors of b.

It can be calculated in O(b√) time.

1068C - Colored RooksLet's put rooks with color i just on line number i. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i) for i from 1 to n. After that for any color there is a rook of this color on a board and for any two different colors a b union of set of rooks of color a and set of rooks of color b wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors a b: let j be index of first column without rooks, put rooks on cells (j,a) and (j,b). After that for colors a b union of set of rooks of color a and set of rooks of color b would become connected and for other pairs the connectedness doesn't change.

Total number of rooks is n+2⋅m.

1067A - Array Without Local MaximumsLet's find solution with complexity O(n⋅a2). We can count dp[prefix][a][flag] — quantity of ways to restore element from 1 to pref with last element equalls to a, flag=0 means that previous element is less then the last or last element is first, flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1].

Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag] on each prefix before counting all dp[pref], so we can recalculate dp in O(1) time.

Complexity is O(n⋅a).

1067B - MultihedgehogSolution 1:

Firstly let's find all vertices with degree 1. Now we can delete them and all, verticies which were incident to them must became verticies with degree 1. And also for each new veretice with degree 1 we must have already deleted not less then 3 verticies. If initial graph was k-multihedgehog, after deleting vertices with degree 1 it would became k−1-multihedgehog.

It could be realised using bfs starting from all initial vertices with degree 1.

Complexity is O(n).

Solution 2:

First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.

Complexity is O(n).

1067C - KnightsIf after some loops of the process we will have two neighboring lines with length x total complexity of knights would be not less than O(x24).

In this construction:



0 — initial placement.

1,2 — added knights.

Would be two neighboring lines with length O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29).

The possible way to facilitate the invention this (or over) solutions is to write process modeling.

Bonus: Solve this problem with complexity O(n26).

1067D - Computer GameLet's denote max(bipi) as M. Independent of our strategy we cannot get more than M in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipi and then try to complete only this quest each second, thus getting +M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M to expected value each second.

This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.

dpt+1=max(pi(ai+tM)+(1−pi)dpt).

If we succeed then we will get ai as a reward and for remaining t seconds we will get M each second, otherwise we get nothing and now only t seconds left. This solution works in O(nT) time which is too slow.

We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).

Now we can see that we take maximum value of functions pi⋅x+piai in point xt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn) solution.

But that's not all. We can actually prove that xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤M. This we will prove by actual meaning of dpt. Take optimal solution for t+1 seconds and do the same for t seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than M in one second, so this drop cannot decrease answer more than M. Thus the inequality is proven.

This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.

Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T from vector (dptt1)T we can apply linear transformation i.e. multiply by some matrix:

⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟To apply it k times just use binary exponentiation to get k-th power of transition matrix.

To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of x we should move to the next line and we know that x increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.

This is already O(n(logn+log2T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.

Final complexity is O(n(logn+logT))1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.

When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.

The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.

Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.

To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.

detA=∑π∏ni=1AiπiIf Aiπi≠0 then we have edge (i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 2. And that's all, there are no other cycles in forest (1 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi all cycles of permutation must have length 2 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.

OK, forest has full rank is equivalent to forest has perfect matching. Suppose that m is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m can have perfect matching. And there is a subgraph of size exactly 2m which does have perfect matching: the ends of edges in maximal matching.

Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken] is a size of maximal matching in subtree rooted at v where boolean flag taken means did we already cover vertex v or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag taken.

Complexity — O(n).

Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial

By Golovanov399, history, 4 years ago, In English1031A - Golden PlateThe number of gilded cells in the first (outer) ring is the number of border cells, that is, 2(w+h)−4, in the second ring — the number of border cells of the center rectangle with side lengths 4 less, that is, 2(w−4+h−4)−4, and so on. This sum can be calculated in a single loop.

1031B - Curiosity Has No LimitsLet's solve the problem for 0≤ai,bi,ti≤1, that is, for binary sequences. There are two options for t1, the remaining part can be determined one number by one after this:

If t1=0 and a1=0 and b1=0 then t2 = 0;If t1=0 and a1=0 and b1=1 then there is no such t2.If t1=0 and a1=1 and b1=0 then t2 = 1;If t1=0 and a1=1 and b1=1 then t2 = 1;If t1=1 and a1=0 and b1=0 then there is no such t2.If t1=1 and a1=0 and b1=1 then there is no such t2.If t1=1 and a1=1 and b1=0 then t2 = 0;If t1=1 and a1=1 and b1=1 then t2 = 1;One can similarly find all other ti-s (3≤i≤n) or get a contradiction.

For bitwise operations from the statement one can solve the problem independently for every bit and restore the original sequence t1,t2,…,tn.

1031C - Cram TimeConsider any answer with maximal n+m. If we used numbers d1,d2,…,dk (di>n+m), then we didn't use some numbers h1,h2,…,hk (hi≤n+m). Replacing all di by hi (1≤i≤k) doesn't violate the restriction. That means that we can assume that the answer consists of all numbers from 1 to x, and x=n+m. The sum of all numbers from 1 to x equals x(x+1)2. It's clear that the following inequality must hold: x(x+1)2≤a+b. Let's find the maximal x for which it's true. The answer can't exceed x, and we can build the answer for x iteratively. Let's iterate over all lecture notes from x to 1, and on each step we put it into the first day if we can, otherwise if in the first day we have w>0 free time then we put the lecture note w<x to the first day. All other lecture notes can be read during the second day since the either there are none of them, or the first day is full and hence the second day contains a sufficient amount of hours to read'em all.

1031D - Minimum pathFirst, let's find the number of a-s in the beginning of the answer. To do this one can calculate dp[i][j] standing for the minimal number of non-a-s among all paths from the initial corner to (i, j). The number of a-s is simply the greatest (i+j) among all pairs (i,j) such that dp[i][j]≤k (or 0, if there are no).

Consider all cells where we can go right after obtaining the prefix of a-s. Now we repeat the following: append the minimal symbol in these cells to the answer, choose those cells and go from them in both possible directions to obtain the new set of cells. One can see that the answer we obtain is indeed the required answer.

1031E - Triple FlipsThis problem has a lot of solutions including those ones which are difficult to prove. Let's describe one of the author's solutions.

We can find answer with bruteforce if size of array is rather small. For example we can check all combinations of arithmetic progressions with length equals to three.

We can find by hand or bruteforce that for 3≤n≤7 arrays with no solution exists but for n=8 (and consequently for n≥8) we always can make all elements be equal to zero.

We want solution with such steps:

If n is small just run bruteforceElse try to make all elements besides the first k (k≥8) be equal to zeroRun bruteforce on the first k elements.How to make the second step? Let's try to make three last elements of array be equal to zero with only one operation. We can use previous elements. So if we have array …,0,0,1 we can change values of the first, the fourth and the seventh elements from the end. But …,0,1,1 is counter-example.

Ok, let's try to make six last elements of array be equal to zero with two operations. We can check by hand or bruteforce that it can be done and n≥11 is enough.

So we have such solution:

Let k is the number of first elements of array which we didn't try to make be equal to zero. In the start k=nWhile k≥11 make k-th, (k−1)-th,.., (k−5)-th elements be equal to zero. Subtract 6 from k.If k≤10 run bruteforce on the first 10 elements or on the whole array if n<10.How many operations will be done?

In the second item the number of operations is less or equal than 2⋅⌊n6⌋≤⌊n3⌋In the third item the number of operations is less or equal than 6 (can be checked by hand or bruteforce)So the total number of operations is less or equal than ⌊n3⌋+6, what is good enough.1031F - Familiar OperationsNote that if a=∏i=1kpxii then d(a)=∏i=1k(xi+1). This implies that we can map a to vector (x1,x2,…,xk), where x1≥x2≥…≥xk, because the order of the powers doesn't matter. The operations correspond to adding 1 to some item or appending 1 to the end of the vector or decreasing 1 from some item and sorting the vector after that, erasing zeros. There are only 289 different such vectors for numbers up to 106, so we need to calculate only 41616 distances.

The first thought could be to just run Floyd-Warshall algorithm on these 289 vertices, which would fit in time. After that for each pair (x,d) we can find the minimum number of operations needed to make with vector x so that the generated number has d divisors. To find the answer for (x,y), we could simply iterate over all possible values of d. But there are some tricky cases. For example, for numbers 219 and 2236 the answer is 1, because after multiplying the first number by 2 both numbers have 21 divisors. But the number 220>106, and the vector (20) is not among these 289 vertices. So, we need to consider some other vectors too.

Anyway, let's run this algorithm to see what could be the maximal distance between the two numbers up to 106. It turns out that in 10 operations any two numbers can be led to have the same number of divisors when all numbers in the path don't exceed 106 too.

This means that each possible number in the optimal path satisfies ∑i=1kxi<30, because for the numbers in the input this sum doesn't exceed 19, and there can be no more than 10 operations with each number. This condition gives us all vectors of powers necessary to consider as middle points for the pairs which can be in the input. There are 28629 such vectors. Now we run 289 bfs instances on the generated graph with the start in each possible vector from the input and build the same data structure for pairs (x,d) as explained before, which allows us to find the answers for all vectors of numbers up to 106.

This solution works in 2.5s on cf servers, which is still too slow. But the thing is that we found answers for all pairs of the vectors from the input. So we can try to get rid of some unnecessary vertices and simply check if the sum of answers is unchanged. One of the possible speedups is to consider only vectors generating the number of divisors not more than some reasonable number. The maximum number of divisors of some necessary vector is 288, so magic constants like 300 or more will work. Another possible speedup is to decrease the border on the sum of powers from 30 to 22, which is precise.

1071E - Rain ProtectionFirst, let's find out if we can catch all raindrops for a fixed speed v.

Assume that the endpoints are at (e1,0) and (e2,h) at any moment. Consider the point (e1,e2) for this state (we call it the state point for this state). From now on we work with these points. We know that this state point can move with speed at most v in both directions independently, that is, if the state point is (x,y) at the moment t, then it'll be in [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt] at the moment t+dt.

It turns out that for each i one of the following takes place:

we cannot catch raindrops from 1 to i;we can catch these raindrops and there is exactly one possible option for the state point at the moment ti;we can catch these raindrops and there is a segment on the plane such that the state point at the moment ti can be in any point of this segment and nowhere else.Indeed, we prove this by induction. Its basis for t0=0 is trivial. Let's prove its step.

If we cannot catch raindrops from 1 to i then we cannot catch all raindrops from 1 to i+1.If there is some segment where the state point can be at ti (possibly a segment of length 0) then at the moment ti+1 the state point can be anywhere inside the convex hull of the union of two squares. The squares are [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt] for the endpoints (x,y) of the segment at ti, and here dt is ti+1−ti.But we also know that the rope must contain one particular point at the moment ti+1, which can be expressed as a linear equation of the state point at the moment ti+1. So to obtain the required segment for ti+1 one should intersect a line with a convex hull of 8 points (which is in fact no more than a hexagon).

However, it's not all: the endpoints of the rope mustn't leave the rails which means that the convex hull should be first intersected with the rectangle [0,w]×[0,w]. However, it can be done after intersecting with the required line.

So the solution now is the following:

First we check if the answer is −1. This is the case when there is a triple of non-collinear raindrop points which should be on the rope simultaneously or there is a raindrop which is not on the rope at the moment 0, while it should be. The simplest way to check it is to check if we can catch all raindrops with speed w. First, it involves no case handling; second, we will use this function later anyway.After this we run a binary search to find the minimal possible value for speed in such a way that it's possible to catch all the raindrops.That's the idea of the solution. Now let's consider precision issues.

The explanation below contains some notions which may be new for a particular reader. Please don't be afraid of them, I explain what they mean right after introducing them. I refer to them by their names first for readers familiar with these notions to get the point faster and maybe skip the explanation which follows. For anyone who doesn't want to read the full proof and wants to know the summary: long double precision should be enough to get AC with the solution above (handling lines intersections properly).

Define a function fi(v) as the ℓ∞-diameter of the set of possible locations of the state point at the moment ti for the speed v, that is,

fi(v)=0 if this set is empty or consists of a single point;fi(v)=max(|x1−x2|,|y1−y2|) if this set is a segment between (x1,y1) and (x2,y2).In other words, every time we calculate the length of any segment, we do it in this metric, since it'll be convenient for our purposes.

Let v^ be the correct answer, and let ε be a sufficiently small positive number (but still much bigger than the machine epsilon, of course).

One can see that all ti-s can be divided into two groups which differ a lot by their meaning:

those for which we must catch one raindrop at this moment (or many equal raindrops, which doesn't matter),those for which we must catch more than one raindrop at this moment.For the first ones we basically need to intersect a polygon with a line, but for the second ones the state point at ti can be determined and doesn't depend on the speed (or such ti-s force our algorithm to tell that the goal is impossible in the very beginning). Let's call the raindrops with ti of the first type simple, and the others complicated.

Let's prove the following lemmas:

Lemma 1a. Let i be an index of a simple raindrop. For v=v^+ε each fi(v) is at least ε.

Lemma 1b. Let i be an index of a complicated raindrop. For v=v^+ε the corresponding state point position at the moment ti is at least ε away from the border of a polygon before intersecting with [0,w]×[0,w].

Lemma 2. Let idx be the index of the first raindrop we cannot catch for a value of speed which is very close to v^ but is less than it. Then for v=v^−ε either our algorithm halts earlier than it handles the idx-th raindrop, or the corresponding line to this raindrop (or the corresponding point if the raindrop is complicated) is at least ε away from the corresponding state points polygon (again, in ℓ∞ metric).

One can see that proving these lemmas is sufficient to validate the solution. Indeed, comparing all intersections with quite good precision will move the binary search borders into the (v^−ε,v^+ε) interval which is enough to stop for some ε.

Proof of lemma 1 (both variations). Fix i. We know that the (i−1)-th set Si−1(v) of possible state points for v=v^ is not empty (from the definition of v^). It's clear that the (i−1)-th set for v=v^+ε is a superset of Si−1(v^), because we can move no faster than with the speed of v^<v^+ε. To get Si, we move from Si−1 no more than (ti−ti−1)(v^+ε)≤(ti−ti−1)v^+ε. This finishes the proof of 1b. Since Si(v^) is also not empty, Si(v^+ε) is at least the segment Si(v^) plus all the points on the corresponding line at the distance no more than ε, that is, at least ε longer than Si(v^), hence is at least ε long, qed.

Proof of lemma 2. Assume our algorithm made at least idx iterations. Consider the corresponding polygon at the moment tidx. We know that for v=v^this polygon intersects the required line/point, butits interior doesn't.That means that each point of the possible set of state points at the moment isn't inside the polygon. That means that if we reduce v by ε then the distance from every point of this set to the polygon is at least ε, qed.

To summarize, the only precision issue we can meet is when we intersect two or more lines for complicated raindrops. This part can be implemented in integers, but let's dive into this anyway.

One can see that catching raindrop at (x,y) means that

yx−e1=h−ye2−x,or

(e2−x)y=(x−e1)(h−y)⇒e1(h−y)+e2y=xh.Since the coefficients of this line equation are of order h, the coordinates of its solution are some rationals with the denominator of order 1/h2. If we then want to check if such point belongs to another line, we want to compare some integer divided by another integer which is ≤h2 with the third integer, so we need an epsilon less than 1/h2.

Codeforces Round #516 (by Moscow Team Olympiad) — Editorial

By cdkrot, history, 4 years ago, translation, In EnglishCredits:

Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_Makeev

Div2B (Equations of Mathematical Magic): Idea and development: Glebodin

Div1A (Oh Those Palindromes): Idea by Endagorion, development by Andreikkaa

Div1B (Labyrinth): Idea and development by qoo2p5

Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg

Div1D (Candies for Children): Idea by Endagorion, development by Flyrise

Div1E (Lasers and Mirrors): Idea and development by mingaleg

Div1F (String Journey): Original idea by GreenGrape,  solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape

1064A - Make a triangle!Suppose c is the largest stick. It is known, that we can build a triangle iff c≤a+b−1.

So if we can build a triangle the answer is zero. Otherwise we can just increase a or b until the inequality above holds.

So the answer is max(0,c−(a+b−1)).

Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100) and select the one with smallest a+b+c.

1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−x.

If you look in the xor definition, it is easy to see, that a⊕x≥a−x, no matter a and x (just look at the each bit of the a⊕x).

And the equality handles only if bits of x form a subset of bits of a.

So the answer is 2t, where t is the number of bits in a (also known as popcount).

1063A - Oh Those PalindromesOne possible solution is just to sort the string.

Why so?

Note that each palindrome have equal character at their ends. Suppose this character is c with x number of occurences. Then there are at most x(x+1)/2 palindromes with this character.

So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer.

1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).

Let's denote the number of taken moves to the right as R and number of moves to the left as L

Clearly, j0 + R - L = j1

That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.

So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.

To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.

Solution is O(nm).

1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!

We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.

Put a new point in the middle of the gap between white points and black points.

Depending on the color said by jury shrink the gap to the left or to the right.

In the end draw a diagonal line between white points and black points.



The initializing binary search may look complicated but it isn't.

Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109.

1063D - Candies for ChildrenSolution works in min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.

This adds few more cases but the idea stays the same. Basically in the formulas below just few −1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.

So how to solve problem in n2?

Note, that basically we have two parts of the circle — the part between [l;r] which get's candies one times more than the rest and the other one.

Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as x and y.

To solve in n2 let's bruteforce the number of sweet tooth on first part (a) and the number of sweet tooth on the second part (b).

Suppose that there were full t loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.

This should be equal to k. Since we just bruteforced the values of a and b we now just have linear equation. If it is solvable, consider relaxing answer with a+b.

How to solve problem in k/n?

So as the asymptotic suggests the amount of turns ≤k/n, so we can bruteforce it instead.

Also it is worthy to handle case of 0 turns specifically here since it produces some unpleasant effects otherwise.

So each person in "x" part of the circle eats candies t+1 times (so each person contributes t+1 or 2t+2) and the other persons have eaten candies t times (so each person contributes t or 2t).

Let's account all persons as if they are not sweet tooths.

So now each person in x contributes 0 or t+1 and each person in y contributes 0 or t.

So we basically have (t+1)a+tb=γ. A Diophantine equation.

Careful analysis or bits of theory suggest that the solutions are

a=a0−tz, b=b0+(t+1)z, for all integer z.

Where a0 and b0 some arbitrary solutions which we can get with formulas.

Also we need to have 0≤a≤x, 0≤b≤y, and the a+b→max.

These bounds imply that t takes values only in some range [t1;t2].

Since the a+b is linear function we can only consider t1 and t2 while searching for maximum a+b.

1063E - Lasers and MirrorsThe answer is always n (if the permutation is identity) lasers or n−1 (otherwise).

Clearly, we can't have more than n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\» and we lost two lasers now.

The proof of n−1 is constructive one.

Ignore all fixed points in permutation (all x, that px=x).

Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1 operations to fix all points in this cycle.

But we also need to fix all other cycles. We can do it in |cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.

But this is a bit too much lines.

The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.

See the following picture for an example (trash beam is the rightmost column):

1063F - String JourneyThis problem required quite a lot of nice observations!

Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.

All other journeys can be modified a bit to match the criterion above.

Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.

This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.

Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.

So let's calculate this dynamic programming from right to left.

How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?

There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases "left substring" or "right substring").

This almost gives us a solution, but we need few more observations to have , and not .

Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.

We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.

Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear.

?Observation? 4. We need to check whether such j exists in a fast way.

Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.

If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are "available" and some are not, and the border moves only left.

Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.

Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).

All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.

Then we just need to query this segment and check if the maximum on it is at least k - 1.

The solution is 

Codeforces Round #515 (Div. 3) Editorial

By vovuh, history, 4 years ago, translation, In English1066A - Vova and Train

Tutorial1066A - Vova and TrainWhat is the number of lanterns Vova will see from 1 to L? This number is ⌊Lv⌋. Now we have to subtract the number of lanters in range [l;r] from this number. This number equals to ⌊rv⌋−⌊l−1v⌋. So the answer is ⌊Lv⌋ - ⌊rv⌋ + ⌊l−1v⌋.

Solution1066B - Heaters

Tutorial1066B - HeatersLet's solve this problem greedily. Let last be the last position from the left covered by at least one heater. Initially, last equals -1. While last<n−1, lets repeat the following process: firstly, we have to find the rightmost heater in range (max(−1,last−r+1);last+r]. It can be done in time O(n) because of given constrains or in O(1) using precalculated prefix values for each i in range [0;n−1]. If there is no such heater then the answer is -1, otherwise let's set last:=pos+r−1, increase the answer by 1 and repeat the process if last<n−1.

There is another one solution to this problem. Assume that the initial answer equals to the total number of heaters. Let's calculate an array cnt of length n, where cnti means the number of heaters covering the i-th element. It can be done in O(n2). This array will mean that we are switch all the heaters on and we know for each element the number of heaters covers this element. Now if for at least i∈[0,n−1] holds cnti=0 then the answer is -1. Otherwise let's switch useless heaters off. Let's iterate over all heaters from left to right. Let the current heater have position i. We need to check if it is useless or not. Let's iterate in range [max(0,i−r+1),min(n−1,i+r−1)] and check if there is at least one element j in this segment such that cntj=1. If there is then the current heater is not useless and we cannot switch it off. Otherwise we can decrease the answer by 1, switch this heater off (decrease cntj for all j in range [max(0,i−r+1),min(n−1,i+r−1)]) and continue the process.

Solution 1Solution 21066C - Books Queries

Tutorial1066C - Books QueriesLet imagine our shelf as an infinite array. Let's carry the rightmost free position from the left of our shelf (let it be l and initially it equals to 0) and the leftmost free position from the right of our shelf (let it be r and initially it equals to 0). Also let's carry the array pos of length 2⋅105 where posi will be equal to the position in our imaginary array of the book with a number i.

Let's put the first book to the position 0. Also let's save that posid (where id is the number of the first book) equals to 0. How will change l and r? l will become −1 and r will become 1. Now let's process queries one by one. If now we have the query of type 1 with a book with a number id, then let's set posid:=l and set l:=l−1. The query of type 2 can be processed similarly. Now what about queries of type 3? The answer to this query equals to min(|posid−l|,|posid−r|)−1, where |v| is the absolute value of v.

Solution1066D - Boxes Packing

Tutorial1066D - Boxes PackingThe first solution is some kind of a straight-forward understanding the problem. Let's do binary search on the answer. So our problem is to find the smallest x such that the suffix of the array a starting from the position x can be packed in boxes. It is easy to see that if we can do it for some x then we always can do it for x+1. And to find the answer for the fixed x we have to simulate the process described in the problem statement starting from the position x. Okay, this is O(nlogn) solution.

The second solution is more interesting than the first one. The approach is to reverse the initial array, simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all.

Why it works?

Let's take a look on the last box in the best answer if we will go from left to right in the initial array. Let objects in this box be alst1,alst2,…,alstx. What do we see? ∑i=1xalsti≤k. So all these objects are fit in the last box (obviously). Now if we will iterate over objects from right to left, these objects will fit also! It means that we cannot do worse by such a transform (reversing) at least for the last box.

But what will happen if we can put some of the previous objects in this box? Well, it will not make worse for this box, but what about next boxes (previous boxes in straight notation)? Let objects in the penultimate box be a_{prev_1}, a_{prev_2}, \dots, a_{prev_y}}. What do we see? These objects are fit in this box (obviously again). What will happen if we will put in the last box one or more objects of this box? Then the left border of objects which we will put in it will not increase because we decrease the number of object in this box. So we can see that for previous boxes this condition is also satisfied.

So we can solve the problem with this approach. Time complexity of this solution is O(n).

Solution 1Solution 21066E - Binary Numbers AND Sum

Tutorial1066E - Binary Numbers AND SumTo solve this problem let's take a look which powers of 2 in a will be affected by powers of 2 in b. Firstly, let's reverse numbers. Let's carry the current power of 2 (let it be pw), the current sum of powers of 2 in a from the position 0 to the current position inclusive (let it be res) and the answer is ans. Initially, pw=1, res=0 and ans=0. Let's iterate over all bits of b from 0 to m−1. Let the current bit in b have the number i. Firstly, if i<n and ai=1 then set res:=res+pw (in other words, we add to the sum of powers of 2 in a the current power of 2). If bi=1 then this bit will add to the answer all the powers of 2 in a from 0 to i inclusive (in other words, res), so if it is, then set ans:=ans+res. And after all we can set pw:=pw+pw and go on to i+1. And don't forget to take all values modulo 998244353 to avoid overflow.

Solution1066F - Yet another 2D Walking

Tutorial1066F - Yet another 2D WalkingThe main idea is that we don't need more than 2 border points on each level. So if we consider than the point p=(xp,yp) is less than point q=(xq,yq) when px<qx or px=qx and py>qy then let's distribute all the points by their levels using std::map or something like it, sort points on each level by the comparator above and remain the first one and the last one on each level. Also let's add the fictive level 0 with the point (0,0). It is always true to remain at most 2 points and can be easily proved but this fact is very intuitive I think. Now let's do dynamic programming on the points. dpi,j means that now we are at the level i and stay in the first point (if j=0) or in the last point (if j=1) and we are already visit all the points on the level i. The value of this dynamic programming is the minimum possible total distance to reach this state. Initially, dp0,0=dp0,1=0, other values are equal to ∞. Let's calculate this dynamic programming in order of increasing levels. Let plvl,0 be the first key point at the level lvl and plvl,1 be the last key point at the level lvl. Now if we are at the level lvl and the previous level is plvl, these 4 transitions are sufficient to calculate states of dynamic programming on the current level:

dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0);dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0);dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1);dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1).There dist(p,q) means the distance between points p and q.

Let last level we have be lst. After calculating this dynamic programming the answer is min(dplst,0,dplst,1).

Solution

Codeforces Round #514 (Div. 2) Editorial

By SYury, history, 4 years ago, In English1059A - Cashier

Tutorial1059A - CashierThere are only n+1 possible segments of time when Vasya can take breaks: between the consecutive clients, before the first client, and after the last client. If the length of the i-th such segment is s, Vasya may take at most ⌊sa⌋ breaks, so we just sum those values over the n+1 possible segments. Time complexity is O(n).

Code1059B - Forgery

Tutorial1059B - ForgeryEach empty cell forbids to put a pen into every neighbor. Also, the border of the grid is forbidden. Let's mark all the forbidden cells. Now we have to check if for each filled cell there is at least one non-forbidden neighbor. Time complexity is O(nm).

Code1059C - Sequence Transformation

Tutorial1059C - Sequence TransformationThe answers for n≤3 are given in the samples. Now suppose that n≥4. The maximum result must have the earliest appearance of an integer different from 1. If n≥4, the earliest integer that may appear is 2. So initially we must remove all odd integers and for each of them append 1 to the answer. But now the rest of the answer is simply the answer for ⌊n2⌋ multiplied by 2. That gives us an O(n) solution.

Code1059D - Nature Reserve

Tutorial1059D - Nature ReserveIf there are both positive and negative yi, the answer is −1. Now assume that yi>0. Key observation: the answer can be binary searched. How to check if there is a valid circle with radius R? Firstly, the center of such circle is on the line y=R. Every point must be not farther than R from the center. It means that the center is inside or on the boundary of all circles (pi,R). The intersection of every such circle with y=R creates a segment (possibly empty). If the intersection of all such segments is non-empty, there exists some valid circle. Total complexity is O(nlogC). There is also an O(nlogn) solution, but it's much harder to implement.

Code1059E - Split the Tree

Tutorial1059E - Split the TreeThere are two solutions. Both of them find the answer for each subtree in dfs: firstly for children, then for the vertex itself. In both solutions, we firstly calculate for each vertex how far up a vertical path starting at this vertex may go. It can be done with binary lifting in O(nlogn).

Now let's describe the first solution. Let dpi be the answer for the subtree of the i-th vertex. Let dp_sumi be the sum of dpj where j is a child of i. Suppose we want to include the i-th vertex in the path starting at some vertex j. Let {vk} be the set of vertices on the path between i and j. Then the answer for i in this case equals 1+∑vk(dp_sumvk−dpvk) (if we assume that initially dpi=0). So we need to calculate the minimum such value for all j in the subtree of i, for which we can create a path from j to i. Let's build a segment tree over the Euler tour of the tree. After processing vertex i, we add dp_sumi−dpi on the segment that corresponds to the subtree of i. If after processing the vertex there are some vertices in it's subtree, for which there can be a vertical path to i, but there cannot be a vertical path to pi, we set the value at the corresponding position in the Euler tour to ∞.

The second solution is much simpler. When calculating the answers, in case of tie let's choose the answer where the path going through the root of the subtree may go further. Then the answers can be updated greedily.

Both solutions work in O(nlogn).

Code (first solution)Code (second solution)

Сodeforces Round 512 (and Technocup — Elimination Round 1) Editorial

By Roms, history, 4 years ago, translation, In English1030A - В поисках простой задачи

Tutorial1030A - In Search of an Easy ProblemCodebait. Comforting problem.

Find maxi=1..n(answeri), if it's equal to 1 then answer is HARD, otherwise — EASY.

Solution1030B - Вася и кукурузное поле

Tutorial1030B - Vasya and CornfieldFor each point (x,y) let's look at values of two diagonals: x+y and x−y. Borders of the cornfield, in fact, give limits to this values in the next way: d≤x+y≤2n−d and −d≤x−y≤d — that's all we need to check. There is a picture below for the further explanation.

Solution1030C - Вася и золотой билет

Tutorial1030C - Vasya and Golden TicketLet's iterate over all possible lengths len of the first segment of the partition. Now, knowing this length, we also can calculate sum S of each segment. Now we can form partition with greedy solution: starting from position len+1 we will find maximal prefix (strictly, segment starting at len+1) with sum lower or equal to S, cut it and again. If all formed segments have sums equal to S then it's valid partition and answer is "YES".

Otherwise, there is no valid length of the first segment, there is no valid partition, so answer is "NO".

Solution1030D - Вася и треугольник

Tutorial1030D - Vasya and TriangleDoubled area of any triangle with integer coordinates is always integer. That's why if 2nm is not divisible by k then there is no valid triangle.

Otherwise, it's always possible to find required triangle. We will construct the answer with next algorithm. At first, if k is even then divide it by 2. Next, find g=gcd(k,n), where gcd(x,y) is greatest common divisor of x and y. Denote k′=kg and assign a=ng as length of the first side. Next assign b=mk′ as length of the second side. Now, if k was odd we need to multiply one of the sides by 2. If a<n then a=2a, otherwise b=2b. b still won't be greater than m since if a=n then b was strictly lower than m.

The answer is the triangle with vertices (0,0),(a,0),(0,b). You can check that its area is equal to nmk.

Solution1030E - Вася и хорошие последовательности

Tutorial1030E - Vasya and Good SequencesSince we can swap any pair of bits in the number, so all we need to know is just the number of ones in its binary representation. Let create array b1,b2,…,bn, where bi is number of ones in binary representation of ai. Forget about array a, we will work with array b.

Let's find a way to decide whether fixed segment is good or not. It can be proven that two conditions must be met. At first, sum of bi at this segment should be even. At second, maximal element should be lower or equal to the sum of all other elements.

We will iterate over left borders of subsegments in descending order and for each left border l calculate number of right borders r such that [l,r] is good.

Let's, as first, "forget" about condition on maximum and calculate cntAll(l) — number of right borders r, such that sum on segment [l,r] is even and left border l is fixed. We can calculate it by counting S0 and S1 — the number of suffixes of array with even sum of bi and number of suffixes with odd sum. If the current sum ∑i=lnbi is even then cntAll(l)=S0 since ∑i=lrbi=∑i=lnbi−∑i=r+1nbi. If ∑i=lnbi is odd then cntAll(l)=S1.

Since we forgot about condition on maximum, some bad segments were counted. Since ai≤1018 then bi<61. That's why if length of the segment ≥61, condition on the maximum is always true. So, for a fixed l we can iterate over all right borders in the [l,l+61] and subtract number of segments with even sum and too large maximum (since these segments were counted in the answer).

Solution1030F - Сдвигаем ящики

Tutorial1030F - Putting Boxes TogetherFirstly, let's prove that it's always optimal to leave one of the boxes untouched. By contradiction: if all boxes will move, so some left part will move right and right part will move left. Let the total cost of shifting the whole left part by one be equal to Sl and cost of the right part be Sr. We can replace the move of one of the parts by extra move of the other part, so we can change max(Sl,Sr) by min(Sl,Sr) — total cost doesn't increase — contradiction.

Let S(l,r)=∑i=lrwi. Then, secondly, let's prove that for some segment [l,r] it's always optimal to choose untouched box k such that S(l,k−1)≤S(l,r)2, but S(l,k)≥S(l,r)2. Again: if it is not true then either S(l,k−1)>S(l,r)2 or S(k+1,r)>S(l,r)2. And we again can replace either S(l,k−1) by S(k,r) or S(k+1,r) by S(l,k). Total cost is decreasing — contradiction.

So, finally, all we need is to process the following queries: for given [l,r] find maximum k that S(l,k−1)≤S(l,r)2, but S(l,k)>S(l,r)2 (> or ≥ doesn't really matter). It can be done with binary search + BIT in O(log2n) time or by "descending" down the Segment Tree in O(logn) time.

Next part is how to calculate the answer for the known k. Since the cost of moving box i to the right place is equal to wi(ak−ai−(k−i)) if i<k and wi(ai−ak−(i−k)) otherwise so, if we shift from ai to ai−i then the cost to move all left indices are equal to ∑i=lk−1wi(ak−ai)=ak⋅S(l,k−1)−∑i=lk−1wiai. The right part transforms in the same way. Since answer is modulo 109+7 we can calculate ∑i=lk−1(wiaimod109+7) using another BIT.

Result complexity is O(nlogn+qlog2n) or O((n+q)logn) (which isn't really faster in this task).

Fenwick SolutionSegment Tree Solution1030G - Линейный конгруэнтный генератор

Tutorial1030G - Linear Congruential GeneratorEach generator f(k)i can be represented as functional graph so the number of different values equal to the legth of the cycle c plus the length of pre-period pp. Generalizing on tuples leads to next observation: number of different tuples equals to maxi=1..n(ppi)+lcmi=1..n(ci).

———— Some proof ————Let's take a look at some generator fi to find out its possible ci and ppi. If ai=0 then fi=xi,bi,bi,bi,…. the ci=1 and ppi=0 or ppi=1. If ai=1 then f(k)i=(xi+(k−1)bi)modpi. Since pi is a prime then ci=1 or ci=pi and ppi=0.

If ai>1 then exists a−1i and (ai−1)−1, thus ppi=0. Since there is not pre-period we need to find minimal positive k such thatxi≡akixi+bi∑j=0k−1aji⇔xi≡akixi+bi(aki−1)⋅(ai−1)−1⇔(aki−1)xi+bi(aki−1)⋅(ai−1)−1≡0⇔(aki−1)(xi+bi⋅(ai−1)−1)≡0modpi.Since pi is a prime if a⋅b≡0 then a≡0 or b≡0. So if (xi+bi⋅(ai−1)−1)≡0 and since it doesn't depend on k then k=1, so ci=1 and ppi=0. Otherwise, (aki−1)≡0 and by Lagrange's theorem k∣(pi−1). Finally, since pi is a prime there exist ai such that k=pi−1.

———— End of some proof ————At the end we can understand that only three cases are matter: (ci=1,ppi=1), (ci=pi,ppi=0) and (ci=pi−1,ppi=0).

Here some greedy ideas works: it always optimal try at first (pi,0), then (pi−1,0) and only then (1,1); we can process elements in the descending order. But there is one problem: since we maximaize maxi=1..n(ppi)+lcmi=1..n(ci) then there are cases, where we can make maxi=1..n(ppi)=1 without lowering lcmi=1..n(ci). Here comes two approaches:

The first solution (hard to prove correctness, the proven complexity):

Let's add to some structure pi in non ascending order: let's maintain lcm as pairs: maximal power of prime aj and number of maximums cntj for each prime number up to 2⋅106 .

For each pi we will try to add it as pi to the lcm. If this structure already have pi then we will add it as pi−1, so we need factorization of pi−1.

After that we will iterate over all pi again and check "can we remove it from structure without decreasing lcm". We will check it in the next way: for index i just check for each prime divisor pdj of pi−1 if it was added as pi−1 (or of pi if it was added as pi) is it true that (apdj > power of pdj) or (apdj = power of pdj and cntpdj>1).

If we can remove some index i so we can make max(ppi)=1 — profit. Otherwise, it's impossible to get max(ppi)=1. Here should be proof of correctness, but it is quite complicated (but I proved this solution to KAN and he agreed (hm, notorious coincidence)).

At the end, we need factorization of all numbers up to 2⋅106 it can be done with Sieve of Eratosthenes if we will remember minimal divisor for each number. So, the result complexity is O((n+MAX)log(n)).

The second solution (the proven correctness, hard to prove the complexity):

Let's maintain same structure for lcm but with some modification: we don't need cntj but for each prime we will have a flag markj — does this prime is occupied by pi from the input. Now, let's get to know a way to add arbitrary prime pi from the input to this structure. Name this function as insert(v). If the structure doesn't have v — just add it (recalc av and markv flag). Otherwise, we'll move to v−1 and for each prime divisor pdk of v−1 we'll try to update pdk in the structure — final trick is next: if we update pdk which have markpdk we will unmark it call a insert(pdk) recursively.

Now we can insert some pi. We will at first find maximum aj for each prime. Then we will make n quieries — calculate lcm without pi. This queries can be processed with dynamic connectivity. Final question is to evaluate number of operation done by insert(v). We can limit it with number of prime divisors of all different primes we can reach from each v up to 2⋅106. It was less than D=30.

So result complexity is O(nlog(n)⋅D).

P.S.: Main correct is the second solution.

Dynamic Connectivity SolutionGreedy Solution1053E - Эйлеров обход

Tutorial1053E - Euler tourFirst let's try to find some conditions whether it is possible to recover correct euler tour. Of course for every euler tour ai ≠ ai+1 and a1 = a2n−1 (because we start and finish in root). Moreover if there exist four index i1 < i2 < i3 < i4 such that ai1 = ai3 and ai2 = ai4 and ai1 ≠ ai2 than answer is NO (because vertex is an ancestor of another o there is no relation between them). There is one more tricky condition - parity of positions of all occurences of element x is the same. Also, between two equal elements with distance 2k there can be at most k distinct elements.

It turns out that those conditions are sufficient - we will prove it by constructing an answer.

So first let's observe that if we have to equal elements it means that there is subtree between them - we can solve it independently from the rest of a tree and then forget about this subtree. So as long as we have two equal elements i < j than we can first solve euler tour between them and then delete elements i+1,i+2...,j. So now we want to solve euler tour where no element occur more than once. Let's say that this tour has length 2k−1 then if we have less than k elements we can replace any 0 with any unused elements.

Now if there are three elements in a row with values x,y,0 or 0,y,x than we can replace them with x,y,x and forget about it. If we get rid of all triplets like this than we have tour in form of a1,0,a2,0,...,0,ak. It's easy to observe that we can replace every 0 with our root (subtree's root). There is a special case when we don't have any root (if solving for whole tree), than we have to find any vertex which can be root and then solve our problem. Straightforward implementation will be O(n2) but it can be easily reduced to O(nlogn) and it can be even reduced to O(n), but O(nlogn) was enough to be accepted.

More details about reducing O(n2) to O(n) in code.

Solution

Codeforces Round #511 Editorial

By ditoly, history, 4 years ago, In EnglishHi, here is the editorial. Sorry for a long waiting.

Have you enjoyed this round? I hope so. I know there are many things not so good and making some people unhappy :( I'm very sorry about that. Since this is my first round, I have many things not taken into consideration or done badly. I will try to improve them if I have my next round (I hope).

Let's talk about the problems. The problems are mainly prepared by me, ditoly, which can be seen in D1D as "Little D". Also, my friends ACMLCZH ("Little C") and FallDream ("Mr. F", I don't know whether this name can explain Chinese word "F大爷" well, maybe "Master F" is better?) provided great helps. The statements are mainly written by me (with the help of 300iq and cyand1317 and some others, thanks!). My English is not so good, so it's frequent that I just understand the problem but other people get AC :( So I try to explain the problems in short statements. Are you not the same with me in this round :p? By the way, why Little C loves "3" so much? He said, it's because C is the 3rd letter in alphabet :D

Div. 2 A — Little C loves 3 I

Problem Author: ditoly

This problem is set by Little C at first, and it's a problem about "Tic-Tac-Toe" for D2B. But after discussion with the coordinator, we thought it's just a implement problem and not so interesting. So I came up with a new problem as you saw.

SolutionIf n - 2 is not a multiple of 3, a = 1, b = 1, c = n - 2 is OK.

Otherwise, a = 1, b = 2, c = n - 3 is OK.

My CodeDiv. 2 B — Cover Points

Problem Author: ditoly and ACMLCZH

This is the former D2A :) After discussion with the coordinator, we thought this problem is too difficult for beginners so it became D2B. What do you think of it?

SolutionTo cover a point (xi, yi), the length of the shorter side of the triangle should be at least xi + yi.

So the answer is max(xi + yi).

My CodeDiv. 1 A — Enlarge GCD

Problem Author: FallDream

In the initial version, it's satisfied that the GCD of all the given integers is 1. So maybe it will be easier to find the standard solution?

SolutionFirst we divide all numbers by GCD of them. Then we should find a subset with maximum number of integers GCD of which is bigger than 1.

We can enumerate a prime p that GCD of the remaining integers can be divided by. And the number of integers can be divided by p is the maximum size of the subset.

We can use Sieve of Euler to factor all integers in  time. Then we find the prime that can divide most integers. The answer is n minus the number of integers can be divided by this prime. If all integers are 1 (after dividing their GCD), there is no solution.

My CodeAbout the ConstraintsIt seems that many people is unsatisfied with the constraints of this problem :( I'm sorry very very much!

Now I'll explain the reason of the constraints.

First, about the main idea of this problem, both FallDream and me thought it's only the prime factors must be considered (Certainly, when the GCD of all the integers is 1).

So I think solutions which consider each prime should be able to pass but which consider all the factors should not.

In the beginning, the maximum of n is 5·105 and of ai is 107, and the time limit is also 1s. My solution will run for less than 0.4s.

Then the tester cyand1317 submit a solution with  time (Let A denote the maximum of ai) which count the number of multiples for each number. His solution got TLE but just ran for about 1s. I think this solution do not use the main idea, so should be not able to pass. Then I increased the limit of ai a little to 1.5·107 so that his solution should run for about 1.5s. Since the solution with  time should use the main idea and I think it should be able to pass, I do not increase it too much. And according to cyand1317's suggestion, the time limit is unfriendly to some languages, I reduced n to 3·105 so that there will be less constant requirement for standard solutions. Then my solution will run for about 0.3s and  solutions will run for about 0.6s (and it seems that running on codeforces is a little bit faster than running on polygon). I thought this result is acceptable so it became the final constraints.

If the constraints make you feel unfriendly, I'm sorry very very much once again! There are so many conditions I should consider that I worried about it for a long time and do not receive a good result finally :( And I did not notice that the brute force can care only primes not bigger than  so many of them got AC :(

Also sorry for too weak pretests.

Hope you can forgive me for my mistakes.

Div. 1 B — Little C Loves 3 II

Problem Author: ACMLCZH

When ACMLCZH first told me this problem and the solution, I hacked him because of his mistake :p

SolutionFollowing the rules in the problem, the 1 × 6, 2 × 4, 2 × 5 and 3 × 4 grids full of chessmen can be easily constructed.

How to construct?Let the number denote the time when the chessman placed.

Grids of 1 × 6 :

1 2 3 1 2 3

Grids of 2 × 4 :

1 2 3 4

3 4 1 2

Grids of 2 × 5 :

1 3 2 1 5

2 4 5 3 4

Grids of 3 × 4 :

1 3 4 2

5 2 1 5

6 4 3 6

Assume that n ≤ m. Consider the following cases:

If n = 1, obviously the answer is .

If n = 2, only the 2 × 2, 2 × 3 and 2 × 7 grids cannot be completely constructed. The others can be constructed by using the 2 × 4, 2 × 5 and 2 × 6(constructed by two 1 × 6 grids) girds.

How to prove that they cannot be constructed?You can write a brute force or enumerate all the possibilities by yourself. If you consider each grid from left to right and choose the grid it matched with, there are only several possible conditions. So I think it can be proved in several minutes :)

If n > 2, the following things we can consider:

We know that using the 2 × 4 and 3 × 4 grids we can construct the 4 × x(x > 2) grid, and using several 1 × 6 grids we can construct the 6 × x(x > 2) grid, so using the 4 × x and 6 × x grids we can construct the x × y grid while x, y > 2 and y is an even number.

Therefore we only need to consider the n × m grid that n and m are both odd numbers.

Since n × m is an odd integer, we can place nm - 1 chessmen at most, so we try to reach the maximum.

Then we can easily construct the 3 × 3, 3 × 5 and 5 × 5 grids that have only one empty grid. According to the above-mentioned conclusions, any n × m grids can be reduce to one of the three grids by using some x × y(x or y is even) grids. The maximum is reached.

How to construct?My CodeHow to solve this problem quickly and safely without complex proof?This problem is a matching problem. And we found that two grids can be matched only if they have different parities of the sum of two coordinates. So it's actually a biparite graph matching problem :) So we can calculate the answer for all small n and m. When n = 1 or m = 1, the answer is easy to get. Otherwise, we found that if n or m is big enough, the answer will be the maximum. So just keep the answers for small n and m, you will get AC easily :)

Div. 1 C — Region Separation

Problem Author: ditoly

This problem seems to be a little difficult for its position. In fact, D1C is an easier problem with dp on a tree. For some reasons, it was replaced by this problem. But I think the new problem is very interesting, isn't it?

SolutionFirst, we try to find whether it's possible to separate the kingdom into k regions of level-2 with the same sum of values. We calculate S, the sum of all the values, so each region should have sum . Let si be the sum of values in the subtree of root i. We consider all the cities from the leaves to the root, when a subtree i has sum , separating it from the tree. We find that only the i with  will be considered. So there should be at least k cities satisfying this condition. And if there exist such k cities, we cut the edge to their father (if it is not the root), so the size of each connected part will be multiple of . Since all the values are positive, all the connected parts have size . So we just need to count how many cities i with  there are. Let the equation be , where x is a positive integer, so k should be a multiple of . Now we can use a simple dp with  time to find whether it's possible to separate the kingdom into k regions of level-2 for all the k.

And it's not difficult to find that there can be ki regions of level-i if and only if there can be ki regions of level-2 and ki - 1 is a factor of ki. Let fi be the number of plans with i regions of the last level, and we enumerate the factors of i to transform. So the total time of this solution is  (including the time to calculate the gcd).

My CodeSomething else about this problemIt seems that  solution can pass this problem? Some of the testers submit solutions which enumerate the multiples of  instead of keep them in an array and then use a  dp. I think its time complexity will be , but I can not prove it's a tight upper bound. I try to construct tests but get 1.5·108 times of calculation at most which their solutions should run for about 1.5s and my solution should run for about 1s.

And I could not construct tests whose answer is bigger than 109 + 7. So you may get AC even though you mistake the modulo number or do not modulo :D I guess the answer will be about  (just guess). Can someone tell me about it, please?

Lastly, about the generator, I spent a whole afternoon to write it and its length is about 4kb which seems to be longer than the total length of my code for all problems! (As you can see, my code is always a little shoter than most of people) I hope the tests are strong enough :)

Div. 1 D — Intervals of Intervals

Problem Author: ditoly and FallDream

A data structure problem! With a very interesting (I think) solution! But in the beginning, this problem is just asking you for the values of several intervals of intervals :( I try to improve it and come up with this new problem :) This problem seems to be a little difficult so that only scott_wu solved it, congratulations! In fact, I would like to set the scoring contribution to 2250 (so scott_wu may take the 1st place?) before the contest. But for some reasons I finally did not :(

Great thanks to cyand1317 for the revision of the tutorial.

SolutionFirst we consider how to calculate the value of an interval of intervals [l, r]. We can consider intervals in order from 1 to n and, for each position on the axis, maintain a timestamp denoting the last time it was covered. When the r-th interval is taken into consideration, the timestamps for positions [ar, br] should all be updated to r. Right after that, the desired answer of a query [l, r] is the number of positions whose timestamp is not smaller than l.

We would like to, for each r, keep the desired answer for every l. To achieve this, when we change the timestamps of k positions from r' to r, the answers for l in [r' + 1, r] should each be increased by k.

To do it fast, we can merge consecutive positions with the same timestamp into a segment, and use a balanced tree (e.g. std::set) to maintain the segments. O(1) new segments appear when adding an interval, and when a segment is completely covered by later intervals, it will be deleted. By amortized analysis, the total number of balanced tree operations and the number of range modifications of answers (see above) are both O(n). We spend  time in this part.

Now we consider how to get the answer. It's obvious that we will select the k largest values. We can use binary search to find the minimum we finally select, i.e. we should, for several integers x, count how many values of [l, r] are not smaller than x and count the sum of these values by the way to get the answer.

For each i, we will select all [l, i]'s such that their interval of intervals values is not smaller than x. As the value of [l, r] is not smaller than [l + 1, r] or [l, r - 1], it's obvious that all l's smaller than an integer Li will be taken and Li + 1 will be not smaller than Li. Now we can iterate i from 1 to n, maintaining the sum of values of [l, i] (1 ≤ l < Li) and the value of [Li, i] by maintaining the difference between the answers for l and l + 1 (in this way we carry out a range increment in O(1) time). Similar to the sliding-window method, we try to increase Li when i changes to i + 1. Therefore, we spend O(n) time for each x we check with.

Summing everything up, the total time complexity of this problem is .

My CodeDiv. 1 E — Little C Loves 3 III

Problem Author: ditoly

A common, artful, interesting solution for subset convolutions! Even though it can solve with modulo p which p is a small integer now, I can solve with modulo 109 + 7 using 1024-bit computers! :p

There seems to be many solutions with hard optimizations can pass this problem. I worried about whether I should allow these solutions before the contest and finally get the answer yes. Congratulations to people who solved this problem, nikanqilaizhenhaoxiao and consecutivelimit whose solutions are very close to the standard solution, and whzzt whose solution has an interesting optimization.

SolutionIf we only need to calculate  (j|k = i), we can do these:

Let  (j|i = i).

Let Ci = Ai·Bi, it can be found that  (j|i = i).

So  (j|i = i and j ≠ i).

To calculate Ai fast (Bi is the same), let f(x, i) be the sum of aj which j|i = i and the lower x binary bits of j is equal to i's.

So f(n, i) = ai, f(x - 1, i) = f(x, i) if i&2x = 0 , f(x - 1, i) = f(x, i) + f(x, i - 2x) if i&2x = 2x, and Ai = f(0, i).

We can calculate all Ai and Bi in O(n·2n) time.

Getting ci from Ci is the inversion of getting Ai from ai. So we can use f(x, i) once again. f(x, i) = f(x - 1, i) if i&2x = 0, f(x, i) = f(x - 1, i) - f(x - 1, i - 2x) if i&2x = 2x. So we can get all ci in O(n·2n) total time.

But in this problem we need to calculate  (j|k = i and j&k = 0).

In fact, there is a well-known algorithm for this problem.

The main idea of this algorithm is consider the number of "1" binary bits.

First, let BC(x) be the number of "1" binary bits in x.

Let  (j|i = i and BC(j) = x).

Then we calculate  (y + z = x), and  (j|i = i and j ≠ i).

So  (j|k = i and BC(j) + BC(k) = x).

Finally ci we need to calculate is equal to c(BC(i), i), because if j|k = i and BC(j) + BC(k) = BC(i), j&k must be 0.

This algorithm cost O(n2·2n) time. Unfortunately, it may be too slow in this problem.

In this problem, we only need to calculate ci&3, equal to ci modulo 4.

In fact, when the answer is modulo p, an arbitrary integer, my solution works.

Let .

Then we calculate Fi = Ai·Bi, and  (j|i = i and j ≠ i).

So  (j|k = i).

If j|k = i, BC(j) + BC(k) ≥ BC(i). If j|k = i and j&k = 0, BC(j) + BC(k) = BC(i).

We find that , because if BC(j) + BC(k) > BC(i), aj·bk·pBC(j) + BC(k) - BC(i) can be divided by p.

So the total time is O(n·2n).

A remainder problem is it can not be modulo p when calculating in this algorithm, so the number may be very large.

Fortunately, in this problem, p is only 4. We can use 128-bit integers or merge two 64-bit integers into one number when calculating.

But in fact, we only care  modulo p, so we can let all number be modulo pn + 1. Single 64-bit integer is enough.

How to come up with it?In fact, I did not come up with this solution directly.

When I learnt about Fast Walsh–Hadamard transform, I could not understand it well but came up with it:

Let's define a transform F(x0, x1) about a pair of integers (x0, x1) to be (ax0 + bx1, cx0 + dx1), and define (x0, x1)·(y0, y1) to be (x0y0, x1y1).

According to FWT, there is such a transform satisfies F(x0, x1)·F(y0, y1) = F(z0, z1), which z0 = x0y0 + x1y1, z1 = x0y1 + x1y0.

Then we can solve an equation to get a, b, c, d! After calculating, I get a = c = 1, b =  ± 1 and d =  ± 1, which is close to FWT!

Then I find that if b = d, there is no the inversion of this transform, so we can not get (z0, z1) from F(z0, z1).

If we do this transform for all the bits, it's actually FWT!

So we can use this method to solve bitwise xor convolution, and bitwise or convolution is similar, what about subset convolution?

After calculating, I get a = 0 or a = 1, c = 0 or c = 1, b = d = 0, which made me disappointed because it's difficult to find the inversion.

But at this time, I came up with a special idea — if we calculate in modulo p, p = 0 satisfied.

Let a = 1, b = 0, c = 1, d = p. We finally get a transform, which is actually my solution above!

And I'm really interested about how the others (such as nikanqilaizhenhaoxiao and consecutivelimit) came up with it?

My CodeHope it be useful to you!

Codeforces Round #510 (Div. 2) Editorial

By vovuh, history, 4 years ago, translation, In English1042A - Benches

Tutorial1042A - BenchesThe maximum value of k should be determined in the following way: let's find the maximum number of people already sitting on the same bench (i. e. the maximum value in the array a). Let this number be t. Then if all additional m people will seat on this bench, we will get the maximum value of k, so the answer is t+m.

To determine the minimum value of k let's perform m operations. During each operation we put a new person on the bench currently having minimum number of people occupying it. The answer is the maximum number of people on the bench after we perform this operation for each of m newcomers.

Solution1042B - Vitamins

Tutorial1042B - VitaminsLet's calculate the minimum cost of the juice containing only the vitamin "A", only the vitamin "B" and only the vitamin "C". Also let's calculate the minimum cost of the juice containing all three vitamins.

If there is at least one juice containing only the vitamin "A", at least one juice containing only the vitamin "B" and at least one juice containing only the vitamin "C", let's update the answer with the sum of the corresponding minimum costs.

If there is at least one juice containing all three vitamins, let's update the answer with its cost.

Only one case remains — when Petya has to buy two juices. Let's iterate over all pairs of juices using nested loops. Let the index of the first juice we iterate be a, the index of the second juice be b. We have to check that the strings sa and sb contain all three letters "A", "B", "C" (i.e. these juices contain all the vitamins). If they do, let's update the answer with the value ca+cb.

Solution1042C - Array Product

Tutorial1042C - Array ProductThere are several cases in the problem. Let the number of zeroes in the array be cntZero and the number of negative elements be cntNeg. Also let maxNeg be the position of the maximum negative element in the array, or −1 if there are no negative elements in the array.

Let the answer part be the product of all the numbers which will be in the answer and the removed part be the product of all the numbers which will be removed by the second type operation.

The first case is the following: cntZero=0 and cntNeg=0. Then the answer part is the product of all the numbers in the array. The removed part is empty.

The second case is the following: cntNeg is odd. Then the answer part is the product of all the numbers in the array except all zeroes and amaxNeg. The removed part is the product of all zeroes and amaxNeg.

And the third case is the following: cntNeg is even. Then the answer part is the product of all the numbers in the array except all zeroes. The removed part is the product of all zeroes in the array (be careful in case cntNeg=0 and cntZero=n).

Be careful with printing the answer because my first solution printed n operations instead of n−1 operations in case cntZero=n or cntZero=n−1 and cntNeg=1.

And the funniest part of this problem is the checker. The first thing I thought was "Well, I want to write a fair checker on this problem". I did exactly that. What do we need? Split all the numbers in the array into two parts? Okay, let's write DSU to do that. What's next? Multiply 2⋅105 numbers from 1 to 109? Okay, let's use FFT and Divide and Conquer! And the last part is the comparing two numbers of length about 2⋅106. So writing this checker was pretty easy problem. But the coordinator didn't like that and I replaced it with very easy checker which uses some ideas from the solution. :(

Solution1042D - Petya and Array

Tutorial1042D - Petya and ArrayLet's reformulate the problem. Now the problem is to calculate the difference between the prefix sums to the right border and to the left border instead of the sum on the segment.

Let pref[i]=∑j=1ia[j], a pref[0]=0.

Then the answer to the problem is ∑L=1n∑R=Lnpref[R]−pref[L−1]<t.

It's easy to see that the answer for the fixed L is ∑R=Lnpref[R]<t+pref[L−1]. We can calculate this formula using some data structure which allows us to get the number of elements less than given and set the value at some position. For example, segment tree or BIT (Fenwick tree).

Solution1042E - Vasya and Magic Matrix

Tutorial1042E - Vasya and Magic MatrixLet's iterate over all the elements of the matrix in order of increasing their values and calculate the expected value for these elements to solve the problem. Suppose that now we consider the element at intersection of the R-th row and the C-th column. Let the elements having value less than the value of the current element be (r1,c1),(r2,c2),…,(rk,ck), where ri is the row of the i-th element and ci is the column of the i-th element.

Then the expected value for the current element can be calculated as follows: ∑i=1k(evi+(R−ri)2+(C−ci)2)k, where evi is the expected value of the i-th element. We can rewrite the formula to the following form using equivalent transforms: ∑i=1kevik+R2+C2+∑i=1kri2k+∑i=1kci2k−2∑i=1kRrik−2∑i=1kCcik.

So we need to maintain five sums for the elements having value less than current element: sum of their values, sum of their row indices, sum of their column indices, sum of squares of their row indices and sum of squares of their column indices. We can maintain all these sums if we will iterate over all the elements continuously in order of increasing their values.

It is also necessary to note that we need to process all the elements having equal values at once and recalculate all the sums right after calculating the expected values for these elements.

Solution1042F - Leaf Sets

Tutorial1042F - Leaf SetsLet's use the following technique, which is pretty common for tree problems. Let the root of the tree be some none-leaf vertex. Run dfs from the root and let the vertex yield all the resulting sets in the optimal answer for its subtree. For each vertex you iterate over its children and merge the yielded sets.

The first thing to notice is that you only need the deepest vertex from each set to check its mergeability. Let's call the distance between the vertex v and the deepest vertex in some set u in its subtree du. Now two sets a and b can be merged only if da+db≤k. Moreover, d value of the resulting the set is max(da,db).

The time has come to reveal the merging process. We will heavily rely on a fact that the resulting d doesn't change after merging. Let's merge the sets with the smallest d to any other possible sets.

Now we can deduce the small-to-large solution from it. Let the vertex yield the whole multiset of the depths of the resulting sets. Now take the child with the largest number of resulting sets and add all the values from the other children to its multiset. Then merge the maximum possible number of sets and yield the result. The size of set yielded by the root is the answer.

The complexity of this solution is O(n⋅log2n), which still can be too slow.

You can notice that if you have a pair of sets a and b such that da≤db,da+db>k, set b will never affect the answer. If some set c could later be merged with b, it can be with a as well. Thus, you can erase set b from the result and add 1 to the answer. Then the vertex will always yield a single set. The solution mentioned above works in O(nlogn) with this modification.

This can later be modified a bit to a O(n) solution but that is totally unnecessary and works about the same time as O(nlogn). It still takes most of the time to read the input.

Solution (O(n log n))Solution (Small to Large, O(n log^2 n))Solution (O(n))

Codeforces Round #509 (Div. 2) Editorial

By Roms, history, 4 years ago, In English1041A - Heist

Tutorial1041A - HeistLet x — the minimal number from the given numbers and y — the maximal. So we consider that x and y were minimal and maximal keyboard numbers before the heist. All given numbers are distinct, so the answer is y−x+1−n (initial number of the keyboards is (y−x+1) minus the remaining number of keyboards n).

Solution1041B - Buying a TV Set

Tutorial1041B - Buying a TV SetFirstly let's make x and y coprime. To do so, we calculate g=gcd(x,y) and then divide both numbers by g.

Then the pair (w,h) is included in the answer if the following conditions are met: w≤a, h≤b, and there exists some positive integer k such that w=kx and h=ky. Furthermore, each such pair is uniquely determined by this integer k. So we can reduce our task to counting the number of positive integers k such that kx≤a and ky≤b, and that is just min(⌊ax⌋,⌊by⌋).

Solution1041C - Coffee Break

Tutorial1041C - Coffee BreakLet put in set the pairs in the following format: ai — the time for i-th break and the number of this break in the input data. So, we got pairs sorted by ai.

While set contains elements we will determine the breaks, which should be done in a single day. For the next day the first break should be dine in the time, which is at the beginning of the set (let this time is x). So, next break should be done after at least d minutes. We should find a pair in the set, where the first element not less than x+d+1. It can be done with lower_bound. In the same way, we can find the next breaks in this day. With help of the second elements of pairs, we can easily remember the answer days for breaks. Also, we should erase from set all considered pairs. If for some pair we cannot find the needed element, we should go to the next day.

Solution1041D - Glider

Tutorial1041D - GliderAt first, let's prove that it is always optimal to jump out at the beginning of any ascending air flows: if his point of jump is out of any air flow, he can move his point to +1 — answer will not decrease, in the same way, if his point of jump in some air flow but not in its beginning, he can move his point to −1.

Next observation: height of glider is non-ascending function for the fixed point of jump, so we can for each optimal point of jump use binary search of the answer. Let glider jump out at position x and we need to calculate its height at some position y≥x, then height is equal to h−(y−x)+sum(x,y), where sum(x,y) is a total length of all flows of segment [x,y] and can be calculated using prefix sums (yes, and lower_bound).

Result complexity — O(nlog(109)log(n)) of time and O(n) of memory.

Of course, you can note that this task can be solved with two pointers technique, what is faster, but it is not necessary since built in lower_bound function is fast enough (unlike some set or segment tree, which should be written optimally).

On the other hand, java-users need to do some extra work by writing its own lower_bound function for int[] since binary_search(List<>) will cause a slowdown.

Solution1041E - Tree Reconstruction

Tutorial1041E - Tree ReconstructionFirst of all, if there exists some bi<n, then the answer is clearly NO. Then let's consider that every bi=n and analyze only the values of ai (and furthermore, let's sort all values of ai beforehand).

Suppose that we have constructed a tree satisfying all the requirements and rooted it at vertex n. Then for any k such that 1≤k≤n−1 there exist no more than k subtrees containing only vertices with indices not exceeding k (because there are no more than k vertices that can be the roots of such subtrees). So, if for some constant k the number of ai≤k is greater than k, then the answer is NO since it would imply that there are more than k subtrees containing only values not greater then k.

Now we consider only the case such that for every k∈[1,n−1] the number of i such that ai≤k is not greater than k. In this case the answer is YES; let's prove it with an algorithm that constructs a tree meeting the constraints.

Actually, we can always build a bamboo (a tree where no vertex has degree greater than 2, or simply a path) according to these constraints. Let's put vertex n at one of the ends of the bamboo and start building a bamboo from the other end. It's obvious that if we make some vertex x a leaf, then the array a will contain only values not less than x. So, if we consider values of ai to be sorted, then the leaf has index a1.

Then let's repeat the following process for every i∈[2,n−1]:

if ai>ai−1, then let's use the vertex with index ai as the parent of the previous vertex;otherwise, let's find any index j such that j<ai and index j is not used yet, and use vertex with index j as the parent of the previous vertex (there will be at least one such vertex since for every k∈[1,n−1] the number of i such that ai≤k is not greater than k).It's easy to prove that the bamboo we construct in such a way meets the constraints given in the statement.

Solution1041F - Ray in the tube

Tutorial1041F - Ray in the tubeAt first, y coordinates don't matter. Let dx be signed difference between x coordinates of B and A, then on the first line all points with coordinates xA+dx⋅(2k) will be chosen, and on the second line all points with coordinates xA+dx⋅(2k+1) will be chosen.

Let's prove that it is always optimal to take dx=2l where l≥0. Let dx is not a power of two, then dx=m⋅2l, where m is odd. Note that dx/m hits all points which is hitted by dx that why answer will not decrease.

So, we need to check only dx=2l, number of such dx is equal to O(log(109)).

For the fixed dx note that ray hits both points on the same line iff x1≡x2mod(2⋅dx). Analogically, the ray hits both points on the different lines iff x1+dx≡x2mod(2⋅dx).

That's why we can split all point on the equivalent classes modulo 2⋅dx and take the size of the biggest class. We can do it by sort and two pointers or by map.

Result complexity is O(nlog(109)logn) time and O(n) memory.

Solution

Codeforces Round #508 (Div. 2) — Editorials

By Ashishgup, history, 4 years ago, In EnglishI hope you guys enjoyed the contest — I hope to host another one soon :D

With that said, here are the tutorials:

1038A - EqualityFirst we need to find the frequencies of the first k alphabets in the string. Let the minimum frequency among these frequencies be m. Then we cannot select m+1 characters of one kind, and we can definitely select m characters of each kind, hence the answer is given by min(frequency of first k characters) * kOverall Complexity: O(n)Author's Code: 42591712

1038B - Non-Coprime PartitionThere are many ways to solve this question. The easiest way perhaps was to note that the sum of first n numbers is given by n∗(n+1)2, and one of n2 or n+12 has to be an integer, suppose k. Then we can partition the numbers into two sets, one containing k and the other containing the remaining integers, both of which will have k as a common factor.

Special Case: There is no answer for n≤2Overall Complexity: O(n)Author's Code: 42591830

1038C - GamblingThis problem was greedy.

First, it is obvious that both the players will try to either take their own maximum value or remove the opponent's maximum value. Hence, the arrays should be sorted and two pointers should be maintained to keep track of how many elements from each array have been counted/removed already.

In every move, if the person has a choice to either take his own value A or remove his opponent's value B, then he will make the choice dependent on the values of A and B. In fact, it turns out that it is optimal just to select the choice with a greater number (in case of tie any will do).

How to prove it? One can show by induction that it does the same as the dynamic programming of size n2. However, there is a more nice way.

Let's say that initially each player gets 0.5 of all numbers in his list. This way when you choose a number from your own list you add the rest 0.5 of it to the score. And when you remove the number from opponent's list you remove the 0.5 of it from your opponent's score. Clearly, all moves become symmetrical to both players now! So each player can make a decision just based on which of the moves is greater.

If A>B, then he will take his number. If A<B, he will discard the opponent's number B. If A=B, he can make either of the above moves, it will not make a difference.

Complexity: O(nlogn)Author's Code: 42591846

1038D - SlimeFor every slime, its value will either be added in the final answer or subtracted. Let us give each slime a sign + or − to denote whether its value will be added or subtracted.

The key observation to solving the problem is that any combination of + and − is obtainable, except where all signs are + or all are − (exception n=1, where the answer is the value of the slime itself)

If the array contains a combination of non-zero positive elements and non-zero negative elements, then we can simply add all their absolute values (since we can put + in front of positive-valued slimes and − in front of negative-valued slimes)

However, if the array contains only positive-valued slimes, we put − in front of the least valued slime and + in front of all the others. Similarly, for negative-valued slimes, we put + in front of minimum absolute valued slime.

It could have also been solved with DP where we check if - sign has been taken or not, and + sign has been taken or not. (4n states)

Overall Complexity: O(n)Author's Code: 42591882

1038E - Maximum MatchingCreate a graph with 4 nodes 1−4 representing the colors. Then the value of a block serves as an edge between the two colors of that block.

Then the question reduces to finding an euler tour in the graph with the maximum sum of edges traveled. An euler tour may not exist with all the given edges, so the question is: Which edges do we remove?

One can note that there are 16 types of edges. (Edges connecting 1 to 1, 1 to 2 and so on). There may be multiple edges of a specific type, however atmost 1 of it will be removed to form a valid euler tour. This is because if we have 2x+y edges between node A and node B where 0≤y≤1, we can simply loop back and forth between A and B x times to end up at the node we started from.

Since there are only 16 types of edges, we can use bitmask to iterate over all the possibilities, and checking whether an euler tour exists in the graph with the marked edges removed (if there are multiple edges between node A and node B, we remove only one edge, the one with the least value).

Refer to author's solution/any AC codes to see implementation details.

Overall Complexity: O(216×n)Bonus: Can you solve this question in O(n2)? How about O(n)?

Author's Code: 42592019

1038F - Wrap AroundThe idea was to solve the problem using Dynamic Programming. The constraints of the question were set low to allow even the most basic Dynamic Programming approaches to pass (see the author's solution to see an easy, but time-costly implementation).

The solution idea was to use 2n4 DP with 4 states: DP[A][B][C][D]A = Current matching suffix length of string (n)B = Length of string t so far (n)C = Whether string t contains s as a substring (non-cyclical) so far (2)D = Length of the suffix of t that is a prefix of s (n2)

You can refer to AC codes for transitions. We may add more details by tomorrow.

You can see author's code for an unoptimised approach, and to tester's code for an optimised solution.

Overall Complexity: O(n4)Author's Code: 42592026

Tester(cdkrot)'s Code: 42593206

For O(n3) or O(n2) solution, refer to this comment by pranjal.ssh

Codeforces Round #507 (based on Olympiad of Metropolises) — Editorial

By cdkrot, history, 4 years ago, In EnglishDiv2A ("Palindrome Dance") was authored by jury members altogether, development: darnley

Div2B ("Skewers") was authored by jury members altogether, development: GlebsHP, Codeforces hardened version: KAN.

Div1A ("Timetable") was authored by Zlobober and meshanya, development: kraskevich.

Div1B ("Subway Pursuit") was authored by V--o_o--V, development: wrg0ababd

Div1C ("Network Safety") was authored by V--o_o--V, development: achulkov2.

Div1D ("You Are Given a Tree") was authored by GlebsHP, development and codeforces edition cdkrot, faster model solution: V--o_o--V.

Div1E ("Summer Oenothera Exhibition") was authored by Zlobober, development by malcolm.

Some editorials are being published, please wait a bit :)

1040A - Palindrome DanceConsider a pair of dancers located symmetrically with respect to the center of the stage. If they already have different suits, the answer is definitely "impossible". If they both have same suits, they are fine. If one of them doesn't have a suit, buy him a matching one. Finally, if both don't have suits, buy them two same suits of the cheaper color. Also, if n is odd and the central dancer doesn't have a suit, buy him a cheaper one.

1040B - Shashlik CookingThe funny thing about this problem that it is entirely based on real facts, in the real life the k was equal to 1 and one skewer really turned two more.

So it is easy to see, that answer is at least ⌈n2k+1⌉ (because in smaller number of operations we wouldn't simply able to touch all skewers), where the ⌈a⌉ denotes rounding up.

Set's build an answer with exactly this number of operations. We will make our answer in such way, that each skewer belongs exactly to one operation. That is, we need to put segments of length 2k+1 over the array, such that the ends are touching and that the first and last segments don't pop out of the array too much.

Let's define x=⌈n2k+1⌉(2k+1)−n, a=min(n,k), b=x−a.

Note that 0≤a,b≤k and a+b=x.

Let's make segments described above in such way, that the first segments outweighs over the array exactly by a and the last one exactly by b.

Since a,b≤k it follows, that the centre of this segments stays inside the array.

Some example: n=7, k=2, x=3, a=2, b=1The answer is then as in follows: [#|#|@|@|@] [@|@|@|@|#], where @ denotes skewer, and one block of square brackets corresponds to one operation.

1039A - TimetableIf there is at least one valid ordering p's (and it surely exists since the x is defined), then the ordering pi=i is also valid. Hence if for some i doesn't hold xi≥i then the answer is no. Also, from this follows that bi≥ai+t.

Otherwise, what it means that xi=c? It means that there is an ordering p, in which the i-th bus comes as c, where the other buses will come then? It turns out, that the least restricting way to complete the ordering is following:

i→c, i+1→i, i+2→i, ..., c→c−1.

Note that since ordering pi=i, it is also allowed for i to go to c (it wouldn't be too fast), but we can doubt whether i+1→i, i+2→i and etc are good.

More over, since xi=c (not, say, c+1), it must hold that i+1→i, i+2→i, ..., c→c−1 are "good" (not fast enough), but doesn't hold c+1→c (too fast).

So for each i we can use scanline to calculate whether it is good or not.

And then we can restore b's in negative order.

What conditions must hold on b? bi≥ai+i, and depending on whether some i is good or not bi≥ai+1+t or bi<ai+1+t.

We can go in reverse order and select the value of bi on the basis of the cases above. Also, since bi<bi+1 if there are many options for bi it is best to select the largest of them.

1039B - Subway PursuitNotice that we can make segment in which we are located small enough using binary search. Let [l;r] be the last segment about which we knew for sure that train is in it (at the beginning it's [1;n]). Let m=l+r2. Let's ask about segment [l;m]. If we receive answer «YES», after this query train for sure will be in segment [l−k;m+k], otherwise in [m−k;r+k]. So, after each query length of segment is divided by 2 and increased by 2k. After segment length becomes irreducible (4k), let's ask about some random station in this segment. If we guessed right, let's finish the program, otherwise make the binary search again.

To get the OK let's make one more observation: for all binary searches except the first one initial segment can be made [l−k;r+k] instead of [1;n].

1039C - Network SafetyConsider a virus containing a fixed number x. Let's investigate two servers connected by a data communication channel, denoting their encryption keys equal as a and b respectively. Since a≠b, it follows that a⊕x≠b⊕x. Therefore, if the servers are infected simultaneously the channel remains safe. The same can be said if neither of the servers is infected. When the virus infects exactly one of the two servers the channel between them can cease to be safe only when x=(a⊕b) (since a⊕x=b, it follows that x=x⊕(a⊕a)=(x⊕a)⊕a=(a⊕x)⊕a=b⊕a=a⊕b). Define a⊕b as the value of the respective data channel (connecting servers with keys a and b). From this it can be inferred that all servers connected by a path of channels with value x can only be infected simultaneously. Thus the answer when the parameter x is fixed is equal to 2q, where q is the number of connected components in a graph where servers are considered vertices and data channels with value x are considered edges. This value can be computed in time linearly proportional to the number of edges with value x. When processing the values which are not found on any edge separately this gives us a solution in total time O(E).

1039D - You Are Given a TreeLet's examine a solution in O(n2) first.

Introudce a dynamic programming on subtree, the dp of the vertex is the number of paths, which can be taken from the subtree and the maximum length of incomplete path, which ends exactly in vertex v.

Notice that this dp can be maximised as pair — the more of complete paths than better, and if the number of complete paths coincides, then it's better to have the incomplete path as long as possible.

This dp allows to get an answer in O(n) for a single kHow to calculate this dp for a vertex? We need to sum the number of complete paths over all children and also either take one of the incomplete path of children and attach the current vertex to it or try to form a new path from two longest incomplete paths of children.

It is possible to use O(n2) solution to get O(n(√n)log) solution.

Notice, that f(k)≤nk. From this we get, that f takes no more than O((√n)) values. Indeed, there are values f(1),f(2),…f((√n)) and for all m≥n−−√f(m)≤n−−√.

To find the corresponding bounds we can use binary search — this way we get solution in O(n(√n)log).

This is already enough to get Accepted on codeforces, however I want to share some more insights about faster, O(nlog2(n)) solution, it wasn't required to get OK, mostly because we found out that writing this solution is really complicated and making it work faster then sqrt-log solution is even more harder.

The funny thing is that we can do a dynamic programming for all k from 1 to n simultaneously.

In fact, we will use cartesian tree (more precisely, it is better to have segment tree for efficiency).

We will return from subtree of vertex v structure of size size[v], containing the dp values for all k from 1 to size[v], where size — it the size of the subtree.

So we need to be able to merge results from subtrees. In particular, from the subtree dp's of sizes s1,…,st (s1≥s2≥…≥st) we want to get ∑si.

Let's take the result corresponding to s1 as a basis, new-borned end can be appended naively. Also, more or less naively we can make the merge of prefix part of length s2 (because this work "is paid" by the fact that we will not return the dp structure of size s2).

So we have to deal with a part from s2 to s1.

In the structure we store pairs of numbers — how much complete paths, and the length of the incomplete path. Note that there are two types of relaxation — when we increase the number of complete paths and when we simply relax the length of incomplete path.

Notice, that f(k)≤nk, and hence ∑f(k)=O(nlog(n)). This way the number of transitions of first type is small and we can perform them naively, we just need to find all such transitions fast. We can maintain in the above mentioned data structure maximums on the segments and fast pull all such transitions.

Other transitions can be handled with max= on a suffix and +1 on the whole data structure, the latter we store together with the instance of data structures and handle them when we merge one data structure into the other.

The overall complexity is O(nlog2).

1039E - Summer Oenothera ExhibitionLet's reconsider this task in terms of segments: we need to split sequence of photos-segments into minimum number of contiguous groups such that there exists a subsegment in each group of length k, which contains inside of each segment of the group.

It's easy to see that if we move right edge of each segment to the left by k, it's required to find a single point which is inside of each segments of the group. Let's consider k as the length of each segment.

Next, it's always good to include in next group maximum number of segments until they have a on-empty intersection. Therefore, we have solution in O(n⋅q) — let's iterate through all segments. If we can add current segment to last group, we add it, else — we create a new group with single current segment.

Furthermore, to find next group, we can use segment tree to perform it in O(logn). Let's store minimum and maximum values of xi, then we descend the tree to find first segment such that maximum left edge is on the right of minimum left edge.

For each i and x≤n1/3 let's calculate minimum length of segments such that group that starts at element i contains at least next x segments. Let's sort all requests in increasing order. We will answer requests in exactly this order. Let's maintain pi — length of group for current k, starting at element i (but pi≤n1/3). There are n4/3 events of changing this value at most.

Let's also maintain values logi — minimum number of groups (and last element of last group) required to jump to element x≥i+n1/3 or to jump to element x such that px≥n1/3. It's easy to see that when pi changes, only area of radius O(n1/3) is changed for long. Therefore long may be recalculated in O(n5/3⋅logn) in total.

Now we can simulate requests: we jump using longi to the right at least on n1/3, therefore there will be O(q⋅n2/3) jumps in total.

The solution became O(n5/3⋅logn+n5/3) for n=q.

Let's speed up the solution to O(n5/3). Let's change the meaning of longi — we allow the last group to be not maximal. Therefore we are now allowed not to recalculate where exactly last maximal group ends. During simulation we need to perform request on segment tree to understand where exactly last maximal group ends.

Now let's do the following: after jump longi we iterate through next elements and try to add it to last non-maximal group. If we already added more than n2/3, let's perform a request on tree in logn.

Therefore the solution performs in O(n5/3+n4/3⋅logn).

Codeforces Round #506 (Div. 3) Editorial

By vovuh, history, 5 years ago, In English1029A - Many Equal Substrings

Tutorial1029A - Many Equal SubstringsLet's carry the current answer as ans, the last position we're checked as pos and the number of occurrences as cnt. Initially, the answer is t, cnt is 1 and pos is 1 (0-indexed). We don't need to check the position 0 because there is the beginning of the occurrence of t at this position. Also cnt is 1 by the same reason. Let's repeat the following algorithm while cnt<k: if pos>=|ans|, where |ans| is the length of the answer, let's add t to the answer, increase cnt and pos by 1. In the other case let's check if there is a prefix of t starting from pos. If it is, let len be its length. Then we need to add the suffix of t starting from len till the end of t, increase cnt and pos by 1. If there is no prefix of t starting from pos the we just increase pos.

The other idea is the following: we have to find the period of the string t. Let this period will be p. Then the answer is p repeated k−1 times and t. The period of the string s is the minimum prefix of this string such that we can repeat this prefix infinite number of times so the prefix of this infinite string will be s. For example, the period of the string ababa is ab, the period of the string abc is abc and the period of the string aaaaa is a. The period of the string can be found using prefix-function of the string or in O(n2) naively.

Solution (Vovuh, O(n^2))Solution (Vovuh, prefix-function)1029B - Creating the Contest

Tutorial1029B - Creating the ContestThe answer is always a segment of the initial array. The authors solution uses two pointers technique: let's iterate over all left bounds of the correct contests and try to search maximum by inclusion correct contest. Let's iterate over all i from 0 to n−1 and let the current left bound be i. Let j be the maximum right bound of the correct contest starting from the position i. Initially j=i. Now while j+1<n and aj+1≤aj⋅2 let's increase j. Try to update the answer with the value j−i+1. It is obvious that all positions from i+1 to j cannot be left bounds of the maximum by inclusion correct contests, so let's set i=j and go on. Because each element will be processed once, time complexity is O(n).

Solution (Vovuh)1029C - Maximal Intersection

Tutorial1029C - Maximal IntersectionIntersection of some segments [l1,r1],[l2,r2],…,[ln,rn] is [maxi=1nli;mini=1nri]. If this segment has its left bound greater than its right bound then the intersection is empty.

Removing some segment i makes the original sequence equal to [l1,r1],…,[li−1,ri−1],…[li+1,ri+1],…,[ln,rn]. That can be split up to a prefix of length i−1 and a suffix of length n−i. Intersections for them can be precalced separately and stored in some partial sum-like arrays. Finally, you have to iterate over the position of the removed segment and calculate the intersection of prefix and suffix without this segment.

Overall complexity: O(n).

Solution (PikMike)1029D - Concatenated Multiples

Tutorial1029D - Concatenated MultiplesLet's rewrite concatenation in a more convenient form. conc(ai,aj)=ai⋅10lenj+aj, where lenj is the number of digits in aj. Then this number is divisible by k if and only if the sum of (aj mod k) and ((ai⋅10lenj) mod k) is either 0 or k.

Let's calculate 10 arrays of remainders rem1,rem2,…,rem10. For each i ai adds (ai mod k) to remleni. That's the first term of the sum.

Now iterate over the second term, for i∈[1..n] and for j∈[1..10] you binary search for (k−((ai⋅10j) mod k)) in remj. The number of its occurrences should be added to answer.

You also might have calculated some pairs (i,i), iterate over them and subtract them naively.

Overall complexity: O(10⋅nlogn).

Solution (PikMike)1029E - Tree with Small Distances

Tutorial1029E - Tree with Small DistancesThe first idea is the following: it is always profitable to add the edges from the vertex 1 to any other vertex. The proof is the following: if we will add two edges (1,u) and (u,v) then the distance to the vertex u will be 1, the distance to the vertex v will be 2. But we can add edges (1,u) and (1,v) and this will be better (in fact, you cannot obtain the less answer by adding two edges in the other way).

The main idea is the following. Let's carry all vertices of the tree with the distance more than 2 in the set. Let the vertex with the maximum distance be v. What we will obtain if we will add the edge (1,v)? The distance to the vertex v will be 1 and the distance to the vertex pv (where pv is the parent of the vertex v if we will root the tree by the vertex 1) will be 2. So we will make reachable at most two vertices (if the vertex pv is already reachable then it will be not counted in the answer). Now what we will obtain if we will add the edge (1,pv)? We will make reachable all the vertices adjacent to the vertex pv and the vertex pv (the number of such vertices is not less than 1 so this move won't make the answer greater instead of any other way to add the edge). After adding such edge let's remove the vertex pv and all vertices adjacent to it from the set. We need to repeat this algorithm until the set will not become empty.

Time complexity is O(nlogn).

I sure that there exists the solution with the dynamic programming in the linear time, I will be very happy if someone will explain it to other participants.

Solution (Vovuh)1029F - Multicolored Markers

Tutorial1029F - Multicolored Markersa+b should be area of the outer rectangle. It means that its sides are divisors of a+b. The same holds for the inner rectangle. Let's assume that red color forms a rectangle, we'll try it and then swap a with b and solve the same problem again. Write down all the divisors of a up to a−−√, these are the possible smaller sides of the inner rectangle. Divisors of a+b up to a+b−−−−√ are possible smaller sides of the outer rectangle.

Let's put inner rectangle to the left bottom corner of the outer rectangle and choose smaller sides of both of them as bottom and top ones. Iterate over the divisors d1 of a+b, for each of them choose the greatest divisor d2 of a smaller or equal to it and check that a+bd1≥ad2. Update the answer with 2(d1+a+bd1) if it holds.

You can use both binary search or two pointers, both get AC pretty easily.

The number of divisors of n can usually be estimated as n13.

Overall complexity: O(a+b−−−−√).

Solution (PikMike)

Codeforces Round #505 Editorial

By GreenGrape, 5 years ago, In EnglishAuthor: GreenGrape

1025A - Doggo RecoloringIt's easy to see that, if there exists such a color x that at least two puppies share this color, the answer is "Yes" as we can eliminate colors one by one by taking the most numerous color and recoloring all puppies of this color into some other (the number of colors will decrease, but the more-than-one property for the most numerous color will hold, so apply induction).

If all puppies' colors are distinct, the answer is "No" except for the case when n=1 (since there's no need to recolor the only puppy).

Author: GreenGrape

1025B - Weakened Common DivisorThe obvious solution of finding all divisors of all numbers in O(n⋅amax−−−−√) definitely won't pass, so we have to come up with a slight optimization.

One may notice that is's sufficient to take a prime WCD (because if some value is an answer, it can be factorized without losing the answer property). To decrease the number of primes to check, let's get rid of the redundant ones.

Take an arbitrary pair of elements (ai, bi) and take the union of their prime factorizations. It's easy to see at this point that the cardinality of this union doesn't exceed 2⋅logamax. The rest is to check whether there exists such prime that divides at least one element in each pair in O(n⋅logamax) time.

Author: GreenGrape

1025C - Plasticine zebraImagine just for a second, that in reality our string is cyclic with a cut at point 0 and clockwise traversal direction.

Now let's apply the cut & reverse operation at point i. The key fact here is that nothing happens to the cyclic string — it's just the traversal direction and the cut point (now i instead of 0) that change.

Here's an example. Let the string be bwwbwbbw and we cut it after the 2-nd letter (1-indexed). It's easy to see that it transforms to wbwbbwbw, which equals the initial one after shifting it to the left by 2 and inverting the traversal direction.

This observation helps us see that all strings obtained within these operations are in fact just cuts of one cyclic strings with precision up to traversal direction. In other words, it's enough to find the longest zebra inside the cyclic string — this value will be the answer to the problem.

Author: GreenGrape

1025D - Recovering BSTLet dp(l,r,root) be a dp determining whether it's possible to assemble a tree rooted at root from the subsegment [l..r].

It's easy to see that calculating it requires extracting such rootleft from [l..root−1] and rootright from [root+1..right] that:

gcd(aroot,arootleft)>1;gcd(aroot,arootright)>1;dp(l,root−1,rootleft)=1;dp(root+1,r,rootright)=1.This can be done in O(r−l) provided we are given all dp(x,y,z) values for all subsegments of [l..r]. Considering a total of O(n3) dp states, the final complexity is O(n4). That's too much.

Let's turn our dp into dpnew(l,r,side) where side can be either 0 or 1 — is it possible to make a tree from [l..r] rooted at l−1 or r+1 respectively. It immediately turns out that dp(l,r,root) is inherited form dpnew(l,root−1,1) and dpnew(root+1,r,0). Now we have O(n2) states, but at the same time all transitions are performed in linear time; thus final complexity is O(n3) which is sufficient to pass.

Author: I_Remember_Olya_ashmelev

1025E - Colored CubesWe're gonna show how to turn an arbitrary arrangement of cubes into the arrangement where i-th cube is located at (i,i) (we call such an arrangement basic) in no more than 2∗n2 operations. For simplicity, we imply that we have exactly n cubes where n is even.

Say we have some arrangement where i-th cube occupies some cell (xi,yi). On the first step, we turn it into the arrangement where all cubes have distinct x coordinates. In order to do this, we sort cubes in ascending order of their x coordinates x (with ties broken arbitrarily) . If cube i is at position j in the sorted list, we say that its desired coordinates are (j,yi). It's easy to check that such choice always allows to move at least one cube from its current position to the desired one through the y=yi line. If we perform this operation n times, we'll move all cubes to their desired positions. In addition, the maximum number of operations will occur if all the cubes were initially located on the line x=1 or x=n, and in this case the number of operations will be equal to 0+1+...+(n−1) < n2/2.

The formal proof of this inequality can be given using the induction principle. Indeed, the base (n=1) is obvious. Now let the statement be true for all k≤n. Let's prove that if the number of cubes (and the size of the board) changes from n to (n+1), the upper limit of the number of operations increases by no more than n. Consider the cube i with maximum x coordinate which we have to move to xi=n. If initially xi is less than n, we move this cube to the desired position in no more than n operations, and other n cubes have coordinates xj≤n which implies the upper limit of n∗(n−1)/2 operations by definition. But if xi is initially n, we don't have to move it whereas each of the remaining n cubes requires one more additional (i.e n total) operation since we added only one diagonal. In total we'll make a total of n+n∗(n−1)/2=n∗(n+1)/2 operations.

Now all x coordinates are distinct and that means that nothing restricts us from changing their y coordinates. Let's move the cubes in such a way that i-th cube ends at position yi=i. One cube can be processed in no more than min(i−1,n−i) operations. According to this, we need at most (n−1)+(n−2)+...+n/2+n/2+...+(n−1)=2∗((n/2)∗(n/2+n−1)/2)=3∗n∗(n−2)/4≤3∗n2/4 operations in total. Now we obtain an arrangement where all y coordinates are also distinct. If we apply the same operation to cubes' x coordinates, we will end up with i-th cube at position (i,i). This requires no more than n2/2+2∗(3∗n2/4)=2∗n2 operations.

Now we can switch any arrangement to the basic one. Let's get the list of operations for turning the initial position to basic and the final position to basic. Now it's sufficient to reverse one of the lists and concatenate these actions. This yields no more than 4∗n2≤10000 operations in total.

Note that this estimate is quite rough; however, this is enough under given constraints.

Author: Errichto

1025F - Disjoint TrianglesThe most challenging part of the problem is to think of the way how to count each pair of triangles exactly once.

It turns out, that this can be done in a nice and geometrical way.

Each pair of triangles has exactly two inner tangents between them. Moreover, exactly one of them (if we direct tangent from point of the first polygon to the point of the second polygon) leaves the first rectangle on the right side and the other tangent leaves it on the left side.

So let's brute-force the inner tangent. If we continue the tangent to draw the line and count the number of points on the left and on the right of it, say k1 and k2 respectively, then we simply need to add k1(k1−1)2k2(k2−1)2 to our answer, since if we select arbitrary pair of vertices on each halfplanes, together with tangent points we will form a pair of triangles with such a tangent.

The question is how to count k1 and k2 for each tangent efficiently. If the points would be sorted by direction, perpendicular to the tangent, we could have answered this query with binary search (since points of one halfplane form a prefix of the sorted array and the other — suffix).

However, if we wrote down all the interesting directions, sort them by angle, and make a scanline on it, we could maintain the points in sorted order.

Basically, points ai and aj change their order in the sorted array at the direction rotate90(ai−aj), and, since there are no three points on one line, these points are neighbours in the sorted array at the moment of the swap.

The complexity is O(n2log(n)) since we need to sort all n2 directions and for each direction make a binary search on the sorted array.

Author: Lewin

1025G - Company AcquisitionsYou can solve this most likely by brute forcing small cases and looking for a pattern.

Here's a proof of the pattern. Let's define a potential of a startup with k followers to be equal to 2k−1. For example, an active startup with zero followers has potential zero.

Now, in one day, if we choose a startup with p followers, and a startup with q followers, the expected change in sum of potentials is equal to 12((2p+1−1−2p+1)−2q+1)+12((2q+1−1−2q+1)−2p+1)=1, regardless of the values of p and q.

The potential of the final state is 2n−1−1, and we can compute the current potential in linear time, so the expected number of turns is the difference between them.

To prove this more rigorously, we can use show that this process is a martingale, so we can use https://en.wikipedia.org/wiki/Optional_stopping_theorem to show that the expected number of days is exactly equal to this difference.

Codeforces Round 504 Editorial

By MikeMirzayanov, 5 years ago, In English1023A - Single Wildcard Pattern MatchingIf there is no wildcard character in the string s, the answer is "YES" if and only if strings s and t are equal. In the other case let's do the following thing: while both strings are not empty and their last characters are equal, let's erase them. Then do the same for the first characters, i.e. while both strings are not empty and their first characters are equal, let's erase them. Now if s is empty or s="*" the answer is "YES", otherwise the answer is "NO".

Problem idea: MikeMirzayanov, awoo; prepared by: vovuh.

1023B - Pair of ToysThe problem is to calculate the number of ways to choose two distinct integers from 1 to n with sum equals k.

If k≤n then the answer is ⌊k2⌋ because this is the number of ways to choose two distinct integers from 1 to k−1 with the sum equals k. Otherwise let mn=n−k will be the minimum possible term in the correct pair of integers. Also let mx=n will be the maximum possible term in the correct pair of integers. Then the answer is max(0,⌊mx−mn+12⌋) because this is the number of ways to choose two distinct integers from mn to mx with the sum equals k.

Problem idea: MikeMirzayanov, prepared by: MikeMirzayanov.

1023C - Bracket SubsequenceLet the array used of n boolean values describe if the corresponding bracket of string s is included in answer or not.

The algorithm goes like this: iterate over the string from 1 to n, maintain the stack of positions of currenly unmatched opening brackets st. When opening bracket is met at position i, push i to st, and when closing bracket is met, set used[st.top()]=True, used[i]=True and pop the top of st. When k values are marked True in used then break, iterate from 1 to n and print the brackets at positions where used[i]=True.

Obviously, this algorithm produces a subsequence of s of length k. Why will it be a regular bracket sequence? The requirements for it are:

no prefix contains more closing brackets than opening ones;the total number of closing bracket equals the total number of opening brackets.The first requirement is met by construction, we couldn't pop more elements from the stack than it had. The second requirement is also met as we marked brackets in pairs.

Overall complexity: O(n).

Problem idea: MikeMirzayanov, prepared by: awoo.

1023D - Array RestorationLet's firstly solve the problem as if there are no zeroes in the given array. Let li be the leftmost occurrence of i in the array and ri be the rightmost occurrence of i. The main observation is that you can choose segments (li;ri) for the corresponding queries and this sequence will be correct if and only if there exists any answer for the given array. If there is no occurrence of some value in the array then you can put the segment for it under the segment of some greater value. If there is no occurrence of q in the array then the answer doesn't exist.

For sure, segment (li,ri) is the minimum segment you can choose. You can expand it in both directions but it will never matter: these positions either will get covered by the segments of greater values or will replace the smaller values with i (and turn YES to NO if the answer existed). Finally, each position will be covered as each element is a left bound of a segment, a right bound of a segment or just covered by the segment of its value.

That problem can be solved with any data structure that allows you to assign values on segment and get the value of every position (segment tree, sqrt decomposition).

However, all the queries are performed offline (the resulting values are only needed after the queries) and the operation can be replaced with assigning maximum of the current value of element and the value of the query.

This can also be done using set. For each position you should keep the segments which start there and end there. For each segment (li,ri) you push i to the list for li and push i to the list for ri. Now you iterate from 1 to n, when entering i you add all values of opening segments to the set, assign the element at position i the maximum value of the set and remove all the values of closing segments from the set. The complexity of this algorithm is O(nlogq).

This algorithm can be easily applied to the problem with zeroes in the array. At the beginning you fill the resulting array with ones. After you performed the algorithm with set on the values from 1 to q, while constructing the segments from the non-zero elements of the given array, you check if the values you assigned are less or equal than the corresponding values of the given array. If that holds then the resulting array is already the correct one. Otherwise the answer doesn't exist. The only corner case there is if no value q was in array and there were some zeroes. That way you should just change any zero to q.

Overall complexity: O(nlogq).

Problem idea: vovuh, MikeMirzayanov; prepared by: awoo.

1023E - Down or RightHint: Move from (1,1) to the middle by asking queries 'query(row, col, n, n)', starting with row=col=1. Similarly, move from (n,n) to the middle by asking queries 'query(1, 1, row, col)'. How to ensure that we will meet in the same cell in the middle?

The unusual condition in this problem is (r2−r1)+(c2−c1)≥n−1 that must be satisfied in every query. Without it, the following simple code would solve the problem:

int row = 1, col = 1;while(row < n || col < n) {  if(row + 1 <= n && query(row + 1, col, n, n)) row++; // move down  else col++; // move right}This program starts in (1,1) and greedily moves down if after this move we could still reach the cell (n,n). Otherwise, it must move right.

But in this problem, we can only get half the way this method. We must stop at the antidiagonal (one of cells: (1,n),(2,n−1),…,(n,1)). So maybe it's a good idea to move backward from (n,n) the same way, and meet at the antidiagonal? Not really :(

We indeed can apply the same algorithm starting from (n,n) and going towards (1,1), but possibly we will end in a different cell in the middle. It's possible even for an empty grid, without any blocked cells. We are very close to a correct solution, but let's focus on a thought process for a moment. Analyzing some other possible approach might help with that.

The limitation about the distance at least n−1 is just enough to ask a query between (1,1) and a cell from the antidiagonal, and also that cell and (n,n).

for(int row = 1; row <= n; ++row) {  int col = n + 1 - row;  if(query(1, 1, row, col) && query(row, col, n, n)) {    print(row, col);  }}This pseudocode would print reasonable candidates for a middle cell in our path — a cell reachable from (1,1) and from which the (n,n) is reachable. But after choosing some cell like this, it isn't that easy to find a way to the corner cells.

In our first idea, we were able to get from (1,1) to one of the reasonable candidates and from (n,n) to one of the reasonable candidates, but maybe a different one. Now a very important observation is: the first piece of code in this editorial will reach the leftmost (equivalently: downmost) reasonable candidate, because we always prefer moving down instead of right. For example, in an empty we would reach the bottom left corner. Now we see that we need to guarantee the same when moving from (n,n). So we should prioritize left direction over the up direction:

row = n, col = n;while(row + col > n + 1) {  if(query(1, 1, row, col - 1)) col -= 1; // move left  else row -= 1; // move up}Problem idea: Errichto, prepared by: Errichto.

1023F - Mobile Phone NetworkConsider the forest of your edges.

Let's add edges into this forest greedily from our competitor's set in order of increasing weight until we have a spanning tree. Remember, we don't need to sort, the input is already given in sorted order.

Now, consider the competitor's edges one by one by increasing weight. Since we have a spanning tree, each competitor edge spans some path on our tree.

To process a competitor's edge, we can collapse all the nodes in the path into one single large node, and fix the cost of our edges along this path to be equal to the cost of the currently considered competitor's edge. We know this is an upper bound on cost since if any were higher, then by the cycle property of MSTs, the customer can ignore one of the higher cost edge on this cycle and choose the customer's edge instead.

In addition, this still allows us to satisfy the condition of the customer choosing all of our edges, since by Kruskal's algorithm, the customer will try to greedily add our edges first into their spanning tree and won't be able to add the customer edge since it now forms a cycle). This shows that this cost is the maximum possible profit since we have an upper bound on each edge, and this upper bound also gives a valid solution.

To determine if our answer can be unbounded, we can check if any of our edges remains uncollapsed after processing all competitor edges.

To do this efficiently, we can just do it naively (even without needing to compute LCAs!).

To show it's already fast enough, there are only a total of at most n merges overall and each merge can be done in α(n) time, where α(n) is the inverse ackermann function, so the overall complexity is O(m+(n+k)α(n)). Unfortunately, this is too hard to separate from solution with logarithms, so those were also allowed to pass (though TL might have been a bit more strict in those cases).

Problem idea: Lewin, prepared by: Lewin.

1023G - PiscesFirst, how do we find the answer in any time complexity? Let us construct a partially ordered set where each element is a single fish in one of the observations. For two elements x=(v1,d1) and y=(v2,d2) we put x<y if x and y could possibly be two occurences of the same fish one after the other, that is, there is enough time to get from one observation to another, so that ρ(v1,v2)≤d2−d1, where ρ(v1,v2) is the distance between the tree vertices, and d1 and d2 are respective day numbers of the two observations. We can now see that the answer is the smallest number of chains needed to cover all the vertices (a chain is a set of pairwise comparable elements of a p.o.set). By Dilworth's theorem, this is equal to the size of the largest antichain (a set of pairwise incomparable elements). Clearly, if a largest antichain contains a fish from an observation, than it must include all fish from this observation as well. We can now solve the problem in something like O(2k) time by trying all subsets of observations.

To get a better complexity we need to use the tree structure. To start, how do we check if a set of observations forms an antichain? Here's one criterion that works:

Proposition. A set S of observations is an antichain iff:

For each subtree of the root v, a subset of S lying in that subtree is an antichain.There exists a time moment T such that it is impossible to reach v at time T from any observation in S (possibly travelling back in time).Indeed, if both of these conditions hold, than for any two observations (v1,d1) and (v2,d2) happening in different subtrees we have ρ(v1,v2)=ρ(v,v1)+ρ(v,v2)>|d1−T|+|d2−T|≥|d1−d2|, hence these observations are incomparable. On the other hand, if S is an antichain, for any observation (vi,di)∈S there is an interval of time moments (li,ri) such that we cannot reach the root at any of times in (li,ri). If two observations i and j are incomparable, then(li,ri)∩(lj,rj)≠∅. But since we have a set of intervals with pairwise non-empty intersections, they must all share a common point, hence our time moment T exists.

Note that in some cases T is necessarily a non-integer: if there are two vertices at distance 1 from the root, and there are observations happening at days 1 and 2 respectively at these vertices, than any T∈(1,2) will suffice. However, T can always be either an integer or a half-integer, hence we can multiply all times and distances by 2 and assume T is integer.

The solution is going to be subtree dynamic programming dpv,t — the total weight of the largest antichain in the subtree of v such that no observation can reach v at time t. Recalculation is a bit tricky, so let's go step by step. First, if we have values of dpv,t, and no observations take place at v, how do we change dpv,t as we travel up the edge to the top of v? If the length of this edge is l, then the new values dp′v,t satisfy dp′v,t=maxt+lt′=t−ldpv,t′. Let's call this procedure "advancing l steps forward".

How do we account for observations at v? For an observation (v,t) with f fishes we cannot simply add f to dpv,t since we can obviously reach v at time t from this observation. Instead, the correct procedure is:

advance the values 1 step;apply dp′v,t=max(dp′v,t,dpv,t+f) for all observations;advance the new values l−1 steps.Finally, to combine the answers from the subtrees u1,…,uk of a vertex v (after the advancements were made in them), we simply add them element-wise for each t: dpv,t=∑uidpui,t.

Of course, we cannot store the DP values themselves since there are too much of them to store. Instead, we will need to use a data structure that will maintain a piecewise constant function. More specifically, let us maintain the positions where the function changes values: for each t such that dpv,t≠dpv,t+1 we store the pair (t,dpv,t+1−dpv,t). How all of the above manipulations look like in terms of this difference structure?

Element-wise sum of two functions is simply the union of the difference sets. (We may want to combine the differences with the same t value, but for most implementations this is not necessary)When we advance l steps forward, the borders with positive differences will more l units to the left, and negative differences will move to the right. When two borders collide, then some of them get eliminated. Consider the function 10,1,5, with two differences (1,−9) and (2,4). After advancing this one step, the new function is 10,10,5, so there is now a single difference (2,−5). If we keep track of when and where these collisions take place, we can make changes to the structure accordingly.The structure of choice here is a treap of differences. When we add two functions, we insert all elements of the smaller treap into the larger one; a standard argument shows that at most O(klogk) insertions will take place overall. To keep track of collisions, we'll have to maintain collision times for all adjacent border pairs, and store the minimal value in the root of each subtree. This may seem cumbersome, but every adjacent pair of elements occurs either as (the rightmost vertex in the left subtree of v, v), or (v, the leftmost vertex in the right subtree of v), hence the standard relax function in the treap implementation can handle this.

One further detail is that we don't want to change the time values in our treaps. Instead, we'll use "lazy" time shifting, that is, we'll keep an additional value Δ associated with each treap, and assume that for entries (t,d) with d>0 the actual time should be t−Δ, and with d<0 the time should be t+Δ. This way, we won't need to actually change anything in the treap when advancing (apart from resolving collisions).

The total complexity of this solution is O(n+klog2k).

Problem idea: Endagorion, prepared by: Endagorion.

Codeforces Round #503 (based on SIS olympiad) — Editorial

By cdkrot, history, 5 years ago, In EnglishThank your for participation!

Problem D2A (New Building) was authored and prepared by Burunduk2.

Problem D2B (Badge) was authored and prepared by me, the version in SIS's olympiad contained the version with n ≤ 105.

Problem D1A (Elections), D1B (Hat), D1D (Large Triangle) were authored by achulkov2, with D1A prepared by Schemtschik, D1B by achulkov2 and D1D prepared by achulkov2 and craborac.

Problem D1C (Sergey's Problem) was authored and prepared by Morokei.

Problem D1E (Raining Season) was authored and prepared by izban.

Editorials were written by izban and VArtem

1020A - New Building for SISIn this problem you need to find a shortest path between some locations in a building. You need to look at some cases to solve this problem. First, if locations are in the same tower (ta = tb), you don't need to use a passages between two towers at all, and answer is fa - fb. In other case, you have to use some passage between towers. Obviously, you need to use only passage on one floor. The easiest way to do this is to write down interesting floors in array — the floor where you start, the floor where you end your path, first and last floors with passages. After that you can choose interesting floor x where you will use a passage, check if there is a passage at this floor (a ≤ x ≤ b), and update answer with an expression like |ta - tb| + |fa - x| + |fb - x|.

Another method is to choose a floor where you use a passage by case handling. If you start on the floor fa, and there is a passage, you can just use this passage. Otherwise, you choose between floors a and b, whichever is closer to the start.

1020B - BadgeIn this problem you are given a graph, with one outgoing edge from each vertex. You are asked which vertex is first to be visited twice, if you start in some vertex, and go by outgoing edge from current vertex until you visited some vertex twice.

The problem can be solved by straightforward implementation. You choose a starting vertex (which student is first to get a hole in their badge), and keep the current vertex, and for all vertices how many times it was visited. After transition to the next vertex you just check if it has been already visited, and update visited mark for it.

This solution works in O(n2), and is very easy in implementation. It can be optimized to O(n), but it was not necessary in this problem. It an easy and useful exercise left to reader.

1019A - ElectionsLet's iterate over final number of votes for The United Party of Berland. We can see that all opponents should get less votes than our party, and our party should get at least our chosen number of votes.

We can sort all voters by their costs, and solve the problem in two passes. First, if we need to get x votes, we should definitely buy all cheap votes for parties that have at least x votes. Second, if we don't have x votes yet, we should by the cheapest votes to get x votes. We can see that this solution is optimal: consider the optimal answer, and see how many votes The United Party got. We tried such number of votes, and we tried to achieve this number of votes by cheapest way, so we couldn't miss the optimal answer. This can be implemented in O(n2logn) or even O(nlogn).

1019B - The hatLet a(i) be a number given to the i-th student. Let's introduce function . As n is even,  is integer, and b(i) is defined correctly. Notice two facts: first, , and second, . The problem is to find an i such that b(i) = 0.

Second note leads us to observation that all b(i) have the same oddity. So, let's find b(0), and if it is odd, then there is no answer, and we need to print  - 1 — all b(i) have the same oddity (odd), and zero, as a number of different oddity, won't appear in b(i).

Otherwise, suppose we know b(0), and it is equal to x (without loss of generality x > 0). Notice that . As we remember from second observation that all b(i) have the same oddity, and neighboring numbers differ by no more than 2, we can use discrete continuity.

Lemma: if you have two indices i and j with values b(i) and b(j), then on segment between i and j there are all values with the same oddity from min(b(i), b(j)) to max(b(i), b(j)). Indeed, as neighboring b differ by no more than 2, we couldn't skip any number with the same oddity.

Now we can use a binary search. At the start l = 0, , and values b(l) and b(r) are even numbers with the different signs. By lemma, on segment between l and r there is a zero that we want to find. Let's take . If b(m) = 0, we found the answer. Otherwise, based on sign of b(m) we can replace one of l, r in binary search to m, and reduce the problem to the same with smaller size. There will be no more than  iterations, and as calculation of b(i) requires two queries, we solved the problem in  queries.

1019C - Sergey's problemLet's build the solution by induction. Suppose we have to solve the problem for n vertices and we can solve this problem for all k (k<n). Take an arbitrary vertex A. Remove A from the graph, as well as all vertices that A has an outgoing edge to. Resulting graph has less than n vertices, so by induction, we can build the solution for it. Let's call the answer set for the new graph M. After this we have two cases: either there is an edge from set M to vertex A or there is not. If there is an edge from M to A, then M is a correct answer for initial graph, because every removed vertex can be reached from M in at most two steps. Otherwise, we can add A to M and, again, this set will satisfy the required condition. This also proves the answer always exists.

How to implement it? Let's iterate over all vertices in order from 1 to n and remember whether each vertex is currently present in the graph or not. Whenever we encounter a currently present vertex u, we save u and mark u and all vertices reachable from u in one step as removed. After that, we go over all saved vertices in reverse order and add them to answer set if it's not reachable from the answer set in one step.

This solutions works in O(V+E) time and space.

1019D - Large TriangleLet's fix one of edge of the triangle. We need to find a third point so the area of triangle is equal to s. Notice that area of triangle is proportional to scalar product of the normal vector to the chosen edge and radius-vector of third point. So, if we had all other points sorted by scalar product with normal to the edge, we could find the third point by binary search. It is the main goal of the solution.

There are O(n2) interesting directions — two normal vectors to each of edges, defined by all pairs of points. For each pair of points you can see that for some directions one of points has larger scalar product with this direction, and for some other direction another point has larger scalar product. We can see that points ai and aj have the same scalar product with vector rotate90(ai−aj) — with normal vector edge defined by these two points. If you look at all directions on unit circle, this vector and the opposite vector change the order of points ai and aj in sorted order by scalar product. Also, as there are no three points lying on one line, these two points will be neighboring in sorting order by this direction.

So, we can maintain the sorting order. Let's take all events on unit circle as all vectors of type rotate90(ai−aj), and for every such event swap two neighboring points ai and aj in sorting order. After swap we can do a binary search for third point to find a required triangle with area s. This works in O(n2logn) time.

1019E - Raining seasonLet's use centroid decomposition on edges of the tree to solve this task.

Centroid decomposition on edges is about finding an edge that divides a tree of n vertices into two subtrees, each of which contains no more than cn vertices for some fixed constant c<1. It is easy to see that such decomposition has only logarithmic depth in terms of initial number of nodes.

There is a problem — it is easy to construct an example, where it is impossible to choose such edge. For example, star tree with n vertices and n−1 leaves is fine for that — every edge has a leaf as one of its ends. To solve this problem, we can add new vertices and edges to the tree. Let's fix arbitrary root of the tree, and make tree binary: if some vertex v has more than two children — u1,u2,…,uk, we may replace vertex v to vertex v1 with children u1 and v2, v2 with children u2 and v3, and so on. Edge between vi and ui has the same length as in initial tree between v and ui, and edge between vi and vi+1 has length 0.

It is easy to see that the distance between any pair of vertices in new tree is the same as the distance between them in initial tree. Also, the degree of the each vertex is at most three, so we can take the centroid of the new tree, and there will be a subtree of centroid with [n3;n2] vertices, so, we will wind an edge that we need in centroid decomposition on edges.

After choosing an edge for decomposition, we should solve the problem recursively for subtrees, and find the diameters which contain the chosen edge. It is quite easy — we can calculate a linear function of length of path from . After that we need to take one linear function from both subtrees and get the sum of these functions.

We can say that if length of path looks like linear function at+b, then we have a point (a,b) on plane. Then it is obvious that we should only keep points on the convex hull of this set. Instead of choosing pairs of vertices in subtrees of edge we can just build a Minkowski sum of their convex hulls — we will get exactly the diameters that contain the chosen edge in linear time.

After computing the convex hulls of diameters containing each edge in decomposition, we can put all these points in one big array and build one big convex hull for all these points again. This way we get all interesting diameters in the tree. To get the length of diameter in time t, we have to find the most distant point on convex hull in direction (t,1).

Building the convex hull for all points for diameters containing the edge of decomposition works in O(klogk), where k is size of current connected component. With knowledge that we have logarithmic depth of decomposition, overall complexity is O(nlog2n).

Codeforces Round #502 (in memory of Leopoldo Taravilse, Div. 1 + Div. 2) —— Editorial

By Magolor, history, 5 years ago, In English1017A - The RankFor each student, add his/her 4 scores together and count how many students have strictly lower scores than Thomas.

Complexity: O(n) or O(nlogn).

Solution(arsijo)1017B - The BitsLet txy be the number of indexes i such that ai=x and bi=y.

The answer is t00⋅t10+t00⋅t11+t01⋅t10.

Solution(arsijo)1017C - The Phone NumberShow an example of n=22:

"' 19 20 21 22 15 16 17 18 11 12 13 14 7 8 9 10 3 4 5 6 1 2 "'

You can use [Dilworth's theorem](https://en.wikipedia.org/wiki/Dilworth So assume we've already known that LIS=L, then we can achieve LDS=⌈nL⌉. So after enumerating all possible L and find the minimum of function L⌈nL⌉, we can construct the sequence easily just as the case when n=22.

Actually, L=⌊n−−√⌋ will always work.

Complexity: O(n).

Solution(Magolor)1017D - The WuWe can regard a 01−string as a binary number.Wu(s,t)=∑i=0nwi[si=ti]=f(s⊕t)where ⊕ is bit-wise XOR and we can preprocess f.

Notice that n≤12, so n2≤6, so we can do something like meet-in-the-middle, split the numbers into higher 6 bits and lower 6 bits:

f[S1][S2][j] count the number of binary numbers with higher bits equal to S1 and f((lower bits)⊕S2)=j.

Then one can easily get g[S][k] stores the answer and then answer queries in O(1) time.

If you don't understand, see the code.

Complexity: O(|S|2n2+23n2+q).

Solution(Magolor)1017E - The Supersonic RocketThe statement is complicated, it is actually:

Given two sets of points, check whether their convex hulls are isomorphic.

The standard solution is: get the convex hulls, make it into a string of traversal: "edge-angle-edge-angle-edge-...". Then double the first string and KMP them.

There can be other ways to solve this problem, because there is a useful condition: all coordinates are integers.

Complexity: O(|S1|log|S1|+|S2|log|S2|).

Solution(Magolor)Solution(Kostroma)1017F - The Neutral ZoneFirst forget about the memory limit part.

Instead of enumerating all integers and count its exlogf value, we enumerate all primes and count its contribution.

It is obvious that prime p's contribution is:f(p)(⌊np⌋+⌊np2⌋+⌊np3⌋+...)(The second part is the number of times it occurs in total in integers less than or equal to n, you can examine and feel that manually).

Brute-force this thing is actually O(n): since there are only O(nlnn) primes less than or equal to n and calculate the second part for each of them cost O(logpn) times.

Now the problem is on sieving the primes. Use Eratosthenes's sieve instead of Euler's, then the only memory cost is the cross-out table.

Use a 'bitset' to store the cross-out table and you'll get a memory cost for about 37.5MB.

Key observation: except 2 and 3, all primes p satisfy p≡±1(mod6).

Then just store these positions with 37.5MB3=12.5MB.

You can also use this observation to optimize your code's running time.

Complexity: O(nloglogn). That's the running time of Eratosthenes's sieve.

Solution(Magolor,optimized by arsijo)Solution(000000)1017G - The TreeThe problem can be solved using HLD or sqrt-decomposition on queries. Here, I will explain to you the second solution.

Let s be a constant.

Let's split all queries on ns blocks. Each block will contain s queries.

In each block, since we have s queries, we will have at most s different vertices there. Therefore, we can squeeze the tree using only those s different vertices. There will be a directed edge from i to j if they are both in that set of s different vertices and i is an ancestor of j in the original tree. A weight of such edge will be the number of white vertices on the way between those two vertices (exclusively i and j).

If we want to find answers for the queries in the black, we need to make every operation in O(s). In each vertex, we will have pi — the number of operations of the first type that need to be processed on that vertex. Also, each vertex will have ci — the boolean variable that means that we need to clear the subtree. Obviously, when we are doing the second operation, we need to clear every pi in that subtree.

After we answer the queries of the i-th block, we need to update the full graph.

So, the complexity will be O(ns⋅n+n⋅s). If you make s=n−−√, the complexity will be O(n⋅n−−√).

For better understanding, you can check the code below.

Solution(arsijo)1017H - The FilmsFirst, we claim the probability is this:(mk+n−(r−l+1))n−(r−l+1)––––––––––––(mk+n)n––⋅∏i=1m(ti+k)c–iWhere ab–=Cbab!=a!(a−b)!, ti is the number of times ending i occurs in total and ci is the number of times ending i occurs in segment [l,r].

Proof:

For each position in [l,r] with ending i, you can choose any film with the same ending, there are (ti+k) of them for the first candidate, and (ti+k−1) of them for the second candidate, ...

So you can satisfy the conditions with ∏mi=1(ti+k)c–i number of ways.

After that, other n−(r−l+1) positions can be filled arbitrarily, there are (mk+n−(r−l+1))n−(r−l+1)–––––––––––– ways of doing that.

And the total number of ways is (mk+n)n–– obviously.

If k=0, we can maintain the expression using Mo-algorithm with complexity about O(nn−−√). More precisely, it is O(nq√) or O(nq√logm).

Key observation: There can only be O(n−−√) different occuring times at most.

Proof:

In the worst case, the occurring times are 1+2+3+...+x=x(x+1)2≤n, so x=O(n−−√).

Similarly, that there are at most O(n23) different combinations of ti and ci.

Proof:

In the worst case, pairs of (ti,ci) are like:

ti : 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 ...

ci : 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 ...

Let its length of same ci be A and repeat time be B. Then from the total occurring times we get A(A+1)2B≤n , and from the occurring times in segment we get B(B+1)2A≤r−l+1 . So around A=B=O(n13) we achieve the minimum.

Use a hash table (actually an array of size O(mn−−√)) to remember them, and brute-force them for each query. We're done.

About the (mk+n−(r−l+1))n−(r−l+1)–––––––––––––(mk+n)n–– part, since there are no more than K=100 different k value, preprocess that for each k.

Complexity: O(Kn+nq√+qn23logm).

Actually, due to limit of K, if one simply run mo-algorithm K times, it will reach a O(nqK−−−√). Under this limit it can be faster than standard solution.

**Bonus: can we have a solution that does not depend on K (if only ∏mi=1(ti+k)c–i part is calculated) and faster than O(nq√+qn23logm) ? **

Solution(Magolor)Solution(Kostroma)Bonus ProblemIt is the previous D1E and its standard solution is hacked. Can you solve it?

Bonus problemLegend

How can the man in the high castle, Abendsen, escape so many times? Because he has a full plan of escaping —— with his films.

The map of the cities can be described as a tree (i.e. connected graph with n vertices and n - 1 edges) rooted at node 1 —— where Abenden lives.

When he starts his escaping, he plans at most k travels: one travel is a simple path between two (not necessarily different) vertices. So he goes from 1 to some vertex v1, and then goes from v1 to v2, and so on ...

When he is visiting a vertex (even though he has visited this vertex before) he will get some films. But in some vertexes, he has to give some films. Note that Abendsen \textbf{can} have a negative amount of films. But after every travel, he has to have a non-negative amount of films. Note that when Abendsen is starting a new travel, he is visiting the starting vertex too. It sounds weird but it is a different world!

At first, Abendsen does not have any films.

He wants to maximize the number of the films he gets after the escape. So please help him find out the maximized films number he can get.

Input Format

The first line two contains two integers n and k (1 ≤ n ≤ 1000, 1 ≤ k ≤ 106) —— the number of vertices and the maximum number of travels allowed.

The second line contains n integers w1, w2, ..., wn (|wi| ≤ 108) —— how many films will Abendsen get (or give if wi is negative) if he visits the i-th vertex.

Each of the next n - 1 lines contains two integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) —— vertices connected by the i-th edge.

It is guaranteed that the input data describes a correct tree.

Output Format

Print one integer, the maximum number of films he can get.

Codeforces Round #501 (Div. 3) Editorial

By vovuh, history, 5 years ago, translation, In English1015A - Points in Segments

Tutorial1015A - Points in SegmentsIn this problem all you need is to check for each point from 1 to m if it cannot belongs to any segment. It can be done in O(n⋅m) by two nested loops or in O(n+m) by easy prefix sums calculation. Both solutions are below.

Solution (Vovuh, O(n + m))Solution (Vovuh, O(n * m))1015B - Obtaining the String

Tutorial1015B - Obtaining the StringThis problem can be solved using the next greedy approach: let's iterate over all i from 1 to n. If si=ti, go further. Otherwise let's find any position j>i such that sj=ti and move the character from the position j to the position i. If there is no such position in s, the answer is "-1".

Upper bound on time complexity (and the size of the answer) of this solution is O(n2).

Solution (Vovuh)1015C - Songs Compression

Tutorial1015C - Songs CompressionIf we will no compress songs, the sum of the sizes will be equal ∑i=1nai. Let it be sum. Now, if we will compress the j-th song, how do sum will change? It will decrease by aj−bj. This suggests that the optimal way to compress the songs is the compress it in non-increasing order of aj−bj. Let's create the array d of size n, where dj=aj−bj. Let's sort it in non-increasing order, and then iterate over all j from 1 to n. If at the current step sum≤m, we print j−1 and terminate the program. Otherwise we set sum:=sum−dj. After all we have to check again if sum≤m then print n otherwise print "-1".

Time complexity is O(nlogn) because of sorting.

Solution (Vovuh)1015D - Walking Between Houses

Tutorial1015D - Walking Between HousesThe solution for this problem is very simple: at first, if k>s or k⋅(n−1)<s the answer is "NO". Otherwise let's do the following thing k times: let dist be min(n−1,s−k+1) (we have to greedily decrease the remaining distance but we also should remember about the number of moves which we need to perform). We have to walk to any possible house which is located at distance dist from the current house (also don't forget to subtract dist from s).

The proof of the fact that we can always walk to the house at distance dist is very simple: one of the possible answers (which is obtained by the algorithm above) will looks like several moves of distance n−1, (possibly) one move of random distance less than n−1 and several moves of distance 1. The first part of the answer can be obtained if we are stay near the leftmost or the rightmost house, second and third parts always can be obtained because distances we will walk in every of such moves is less than n−1.

Time complexity is O(k).

Solution (BledDest)1015E1 - Stars Drawing (Easy Edition)

Tutorial1015E1 - Stars Drawing (Easy Edition)Since we are almost unlimited in the number of stars in the answer, the following solution will works. We iterate over all possible stars centers and try to extend rays of the current star as large as possible. It can be done by the simple iterating and checking in O(n). If the size of the current star is non-zero, let's add it to the answer. It is obvious that the number of stars in such answer will not exceed n⋅m. Then let's try to draw all these stars on the empty grid. Drawing of each star is also can be done in O(n). If after drawing our grid equals to the input grid, the answer is "YES" and our set of stars is the correct answer. Otherwise the answer is "NO".

Time complexity: O(n3).

Solution (MikeMirzayanov, O(n^3))1015E2 - Stars Drawing (Hard Edition)

Tutorial1015E2 - Stars Drawing (Hard Edition)I am sorry that some O(n3) solutions pass tests in this problem also. I was supposed to increase constraints or decrease time limit.

The general idea of this problem is the same as in the previous problem. But now we should do all what we were doing earlier faster. The solution is divided by two parts.

The first part. Let's calculate four matrices of size n×m — up, down, left and right. upi,j will denote the distance to the nearest dot character to the top from the current position. The same, downi,j will denote the distance to the nearest dot character to the bottom from the current position, lefti,j — to the left and righti,j — to the right. We can calculate all these matrices in O(n2) using easy dynamic programming. If we will iterate over all possible i from 1 to n and j from 1 to m, we can easy see the next: if the current character is dot, then upi,j=lefti,j=0. Otherwise if i>1 then upi,j=upi−1,j, and if j>1 then lefti,j=lefti,j−1. Rest two matrices can be calculated the as well as these two matrices but we should iterate over all i from n to 1 and j from m to 1. So, this part of the solution works in O(n2).

After calculating all these matrices the maximum possible length of rays of the star with center in position (i,j) is min(upi,j,downi,j,lefti,j,righti,j)−1.

The second part is to draw all stars in O(n2). Let's calculate another two matrices of size n×m — h and v. Let's iterate over all stars in our answer. Let the center of the current star is (i,j) and its size is s. Let's increase hi,j−s by one and decrease hi,j+s+1 by one (if j+s+1≤m). The same with the matrix v. Increase vi−s,j and decrease vi+s+1,j (if i+s+1≤n). Then let's iterate over all possible i from 1 to n and j from 1 to m. If i>1 then set vi,j:=vi,j+vi−1,j and if j>1 set hi,j:=hi,j+hi,j−1.

How to know that the character at the position (i,j) is asterisk character or dot character? If either hi,j or vi,j greater than zero, then the character at the position (i,j) in our matrix will be the asterisk character. Otherwise it is the dot character. This part works also in O(n2).

Time complexity of the solution: O(n2).

Solution (Vovuh, O(n^2))1015F - Bracket Substring

Tutorial1015F - Bracket SubstringAt first, let's calculate the matrix len of size (n+1)×2. Let leni,j will denote the maximum length of the prefix of s which equals to the suffix of the prefix of s of length i with the additional character '(' if j=0 and ')' otherwise. In other words, leni,j is denote which maximum length of the prefix of s we can reach if now we have the prefix of s of length i and want to add the character '(' if j=0 and ')' otherwise, and only one possible move is to remove characters from the beginning of this prefix with an additional character. This matrix can be easily calculated in O(n3) without any dynamic programming. It can be also calculated in O(n) using prefix-function and dynamic programming.

Now let's calculate the following dynamic programming dpi,j,k,l. It means that now we have gained i characters of the regular bracket sequence, the balance of this sequence is j, the last k characters of the gained prefix is the prefix of s of length k and l equals to 1 if we obtain the full string s at least once and 0 otherwise. The stored value of the dpi,j,k,l is the number of ways to reach this state.

Initially, dp0,0,0,0=1, all other values equal 0.

The following recurrence works: try to add to the current prefix character '(' if the current balance is less than n, then we will move to the state dpi+1,j+1,lenk,0,f | (lenk,0=|s|). |s| is the length of s and | is OR operation (if at least one is true then the result is true). Let's add to the number of ways to reach the destination state the number of ways to reach the current state.

The same with the character ')'. Try to add to the current prefix character ')' if the current balance is greater than 0, then we will move to the state dpi+1,j−1,lenk,1,f | (lenk,1=|s|). Also add to the number of ways to reach the destination state the number of ways to reach the current state.

After calculating this dynamic programming, the answer is ∑i=0|s|dp2n,0,i,1.

Time complexity is O(n3).

Solution (Vovuh)



