I have ceased posting up solutions here.

----------

Editorial of Codeforces Round 889 (Div. 1 + Div. 2)

By TheScrasse, 7 days ago, In English 1855A - Dalton the Teacher

Author: Kaey Preparation: akifpatel

Hint 1 Hint 2 Solution Let s be the number of sad students at the beginning. The answer is ⌈s2⌉ .

In one move, you can make at most 2 sad students happy (because you can change the position of at most two students), so you need at least ⌈s2⌉ moves.

In fact, you can make everyone happy in exactly ⌈s2⌉ moves:

while there are at least 2 sad students, you can swap them and both of them will be happy; if there is exactly 1 sad student left, you can swap it with any other student. Complexity: O(n) 1855B - Longest Divisors Interval

Author: TheScrasse Preparation: TheScrasse

Hint 1 Hint 2 Hint 3 Hint 4 Solution Suppose you find a valid interval [l,r] . Note that the interval [l,r] contains at least one multiple of x for each 1≤x≤r−l+1 . Then, the interval [1,r−l+1] is also valid and has the same length.

So, it's enough to check intervals with l=1 , i.e., find the smallest x that does not divide n . The answer is x−1 .

Complexity: O(log(maxn)) 1854A1 - Dual (Easy Version)

Author: TheScrasse Preparation: akifpatel

Hint 1 Hint 2 Hint 3 Hint 4 Solution If all the elements are negative, you can make suffix sums (they are nondecreasing) with moves (n−1,n),(n−2,n−1),… If there is at least one positive element ax ,

make ax>20 using 5 moves (x,x) ; make a2 the biggest element using 2 moves (2,x) ; make a3 the biggest element using 2 moves (3,2) ; ... This strategy requires 5+2(n−1)≤43 moves.

Complexity: O(n) 1854A2 - Dual (Hard Version)

Author: TheScrasse Preparation: akifpatel, dario2994

The hints and the solution continue from the easy version.

Hint 5 Hint 6 Hint 7 Hint 8 Hint 9 Solution If you either make everything positive or make everything negative, you can win in n−1≤19 moves by making prefix sums or suffix sums, respectively. So, you have to reach one of these configurations in 12 moves.

How to make everything positive? First, you create a big element with the maximum absolute value (this requires x1 moves), then you add it to every negative element (this requires x2 moves). y1 and y2 are defined similarly in the negative case.

So,

one of x1 and y1 is 0 (because the element with the maximum absolute value at the beginning is either positive or negative), and the other one is ≤5 (because you can make |ai|≥32 in 5 moves); x2 is the number of negative elements, y2 is the number of positive elements. So, x2+y2≤n≤20 . Therefore, you need additional min(x1+x2,y1+y2) moves. Since x1+x2+y1+y2≤25 , min(x1+x2,y1+y2)≤⌊252⌋=12 , as we wanted. Now you can simulate the process in both cases (positive and negative), and choose one that requires ≤31 moves in total.

Complexity: O(n) 1854B - Earn or Unlock

Author: TheScrasse Preparation: akifpatel

Hint 1 Hint 2 Hint 3 Hint 4 Hint 5 Solution Let's add n cards with value 0 at the end of the deck. Then, it's optimal to unlock x≤2n cards, and use moves of type 1,…,x , getting a1+⋯+ax−x+1 points.

Let's find the reachable x . Let dpi be a bitset that stores the reachable x after using the first i types of moves.

Base case: dp0,1=1 .

Transitions: first, dpi=dpi−1 << ai . If dpi,i=1 , you can update the answer with a1+⋯+ai−i+1 , but you can't unlock any other card, so you have to set dpi,i=0 before transitioning to i+1 .

Complexity: O(n2/w) 1854C - Expected Destruction

Author: TheScrasse Preparation: akifpatel

Hint 1 Hint 2 Hint 3 Hint 4 Hint 5 Hint 6 Solution Consider an (n+1)×(m+1) grid, where the i -th row initially contains a block in column Si , and row n+1 contains a block in column m+1 .

The set is empty if all the blocks are in column m+1 ; i.e., if every block has reached the block in the following row. Every "connected component" of blocks (except the last one) represents an element in the set. These components move equiprobably. Let's calculate the expected time required for the block in row x to "reach" the block in row x+1 . If you consider a single pair of blocks, every block moves with probability 1/2 , unless block x+1 is in column m+1 .

So, you can calculate dpi,j= expected number of moves required to let the block x reach the block x+1 , if the block x is in position i and the block x+1 is in position j .

The base cases are dpi,m+1=(m+1)−i (because only the block x can move) and dpi,i=0 (because block x has already reached block x+1 ). In the other cases, dpi,j=((dpi+1,j+1)+dpi,j+1)/2 .

By linearity of expectation, the answer is the sum of dpSi,Si+1 .

Complexity: O(m2) 1854D - Michael and Hotel

Author: TheScrasse Preparation: akifpatel

Hint 1 Hint 2 Hint 3 Hint 4 Solution The component with node 1 contains a cycle. If you know the whole cycle (of length x ), you can win in n−x queries by asking for each node if it ends up in the cycle after n moves.

You can get a node in the cycle in 9 queries, doing a binary search on the n -th successor of node 1 .

How to find the rest of the cycle?

First, find k nodes in the cycle, doing a binary search on the successor of the last node found. These nodes make a set C . Then, check for each node if it's "sufficiently close" to C , by asking (i,k,C) . Now, you know 2k nodes in the cycle. Repeat until you get the whole cycle. If you choose k=63 , you spend at most 9⋅63+(500−63)+(500−126)+(500−252)+(500−252)=1874 queries.

1854E - Game Bundles

Author: dario2994 Preparation: akifpatel, dario2994

Hint 1 Hint 2 Hint 3 Solution We describe a randomized solution that solves the problem for m up to 1011 (and, with some additional care, may be able to solve also m up to 1012 ). We decided to give the problem with the smaller constraint m≤1010 to make the problem more accessible and because there may be some rare cases below 1011 for which our solution is too slow (even though we could not find any). We don't know any provably correct solution, if you have one we would be curious to see it. We expect to see many different solutions for this problem.

Main idea: Choose suitably the values a1,a2,…,ah that belong to [1,29] and then find ah+1,ah+2,…,ak in [31,60] by solving a backpack-like problem.

Let us describe more precisely the main idea. Assume that a1,a2,…,ah≤30 are fixed and they satisfy a1+a2+⋯+ah<60 . For any s=0,1,2,…,29 , let f(s) be the number of subsets I⊆1,2,…,h so that ∑i∈Iai=s . If we can find some values 0≤s1,s2,…,sk−h≤29 so that f(s1)+f(s2)+⋯+f(sk−h)=s , then by setting ah+i=60−si for i=1,2,…,k−h we have found a valid solution to the problem.

There are two main difficulties:

How can we find s1,s2,…,sk−h ? How should we choose a1,a2,…,ah ? Since it is important to get a good intuitive understanding of the computational complexity of the algorithm, let us say now that we will choose h≤44 and (accordingly) k−h=16 . These values are flexible (the solution would still work with h≤45 and k−h=45 for example). We will say something more about the choice of these values when we will describe how a1,a2,…,ah shall be chosen.

The backpack problem to find s1,s2,…,sk−h .

The naive way to find s1,…,sk−h would be to try all of them. There are (k−h+2929) possible ways (up to order, which does not matter). Since k−h=16 this number is ≈2⋅1011 which is too much to fit in the time limit.

To speed up the process, we will do as follows. Partition randomly A∪B=0,1,…,29 into two sets of size 15 . We iterate over all possible s1,s2,…,s(k−h)/2∈A and over all possible s(k−h)/2+1,…,sk−h∈B and check whether the sum of one choice from the first group and one choice from the second group yields the result. This is a standard optimization for the subset sum problem. What is its complexity? It can be implemented in linear time in the size of the two groups we have to iterate over, which have size ((k−h)/2+1515)≈5⋅105 . Notice that in this faster way we will not visit all the (k−h+2929) possible choices s1,s2,…,sk−h because we are assuming that exactly half of them belong to A and exactly half of them belong to B . This is not a big deal because with sufficiently high probability we will find a solution in any case.

The choice of a1,a2,…,ah .

It remains to decide how we should select a1,a2,…,ah . The following choice works:

Approximately the first log2(m) values are set equal to 1 . Five additional values are chosen randomly from [1,6] so that the total sum stays below 60 . One should repeat the whole process until a solution is found.

Some intuition on the construction. The choice of a1,…,ah may seem arbitrary; let us try to justify it. The goal is to generate a set of values f(0),f(1),…,f(29) that are simultaneously ``random enough'' and with size smaller but comparable to m . These two conditions are necessary to expect that the backpacking problem finds a solution with high enough probability.

If a1=a2=⋯=ah=1 , then f(s)=(k−hs) and these numbers have size comparable to m if 2h is comparable to m . This observation explains why we start with approximately log2(m) ones. The issue is that we need some flexibility in the process as we may need to repeat it many times, this flexibility is provided by the addition of some additional random elements which don't change the magnitude of the values f(0),f(1),…,f(29) but that modify them as much as possible (if we added a large number it would not affect many f(s) and thus it would not be very useful).

1854F - Mark and Spaceship

Author: dario2994 Preparation: akifpatel, dario2994

Hint 1 Hint 2 Hint 3 Solution The 2 -dimensional case. Let us begin by cpnsidering the 2 -dimensional version of the problem. The solution to this simpler version provides the idea of the approach for the 4 -dimensional version.

We want to reach (a,b) . Can we do it with exactly k moves? Two simple necessary conditions are:

|a|+|b|≤1+2+⋯+k , a+b and 1+2+⋯+k shall have the same parity. It turns out that this two conditions are also sufficient! One can prove it by induction on k as follows. If k=0 or k=1 or k=2 the statement is simple, thus we may assume k≥3 .

Without loss of generality we may assume 0≤a≤b . If |a|+|b−k|≤1+2+⋯+k−1 , then the statement follows by inductive hypothesis. Assume by contradiction that such inequality is false. If b≥k then we have a contradiction because |a|+|b−k|=|a|+|b|−k≤(1+2+⋯+k)−k . Otherwise b<k and the contradiction is |a|+|b−k|=a+k−b≤k≤1+2+⋯+k−1 .

Hence, we have shown:

Lemma 1: The point (a,b) is reachable with exactly k moves if and only if |a|+|b|≤1+2+⋯+k and a+b has the same parity of 1+2+⋯+k .

The 4 -dimensional case. One may expect statement analogous to the one of Lemma 1 to hold also when there are 4 coordinates. It does not, but it almost does and this is the crucial idea of the solution. More precisely, the number of counter examples to such statement is rather small and we can find all of them. This is the intuition behind the following definition.

Definition: For k≥0 , let Ak be the set of points (a,b,c,d) such that |a|+|b|+|c|+|d|≤1+2+⋯+k and a+b+c+d has the same parity of 1+2+⋯+k but (a,b,c,d) is not reachable with exactly k moves.

As an immediate consequence of the definition, we have

Observation: The point (a,b,c,d) is reachable with exactly k moves if and only if |a|+|b|+|c|+|d|≤1+2+⋯+k and a+b+c+d has the same parity of 1+2+⋯+k and (a,b,c,d)∉Ak .

Thanks to this observation, if one is able to efficiently find Ak for all interesting values of k , then solving the problem is (comparatively) easy. The following lemma is our main tool for this purpose.

Lemma 2: Assume that (a,b,c,d)∈Ak with 0≤a≤b≤c≤d . Then, either k≤6 or (a,b,c,d−k)∈Ak−1 .

Proof: The strategy is the same adopted to show Lemma 1. In some sense, we are saying that the inductive step works also in dimension 4 , but the base cases don't.

If |a|+|b|+|c|+|d−k|≤1+2+⋯+k−1 , then it must be (a,b,c,d−k)∈Ak−1 because if (a,b,c,d−k were reachable with k−1 moves then (a,b,c,d) were reachable with k and we know that this is not true.

Assume by contradiction that |a|+|b|+|c|+|d−k|>1+2+⋯+k−1 . If d≥k then we reach the contradiction |a|+|b|+|c|+|d−k|=a+b+c+d−k≤(1+2+⋯+k)−k . Otherwise, d<k and thus we reach the contradiction |a|+|b|+|c|+|d−k|=a+b+c+k−d≤a+b+k≤3k−2≤1+2+⋯+k−1 (for k≥7 ).

We can now describe the solution. Assume that we know Ak−1 . First of all, notice that it is then possible to determine in O(1) whether a point belongs to Ak or not. To generate a list of candidate elements for Ak we proceed as follows:

If k≤6 , we simply iterate over all points with |a|+|b|+|c|+|d|≤1+2+⋯+k . Otherwise, we iterate over the points in Ak−1 and we consider as candidate elements for Ak the points that can be obtained by changing the value of one coordinate by k . Thanks to Lemma 2, we know that this process finds all the elements in Ak . Once A0,A1,A2,A3,… are known, the problem boils down to a (relatively) simple counting argument that we skip.

One can verify that to handle correctly all points with coordinates up to 1000 it is necessary to compute Ak for 0≤k≤62 .

One additional cheap trick is required to make Ak sufficiently small and get a sufficiently fast solution. Given (a,b,c,d) , the instance of the problem is equivalent if we change the signs of the coordinates or we change the order of the coordinates. Hence we shall always ``normalize'' the point so that 0≤a≤b≤c≤d . If we do this consistently everywhere in the process, the solution becomes an order of magnitude faster. In particular, this trick guarantees |Ak|≤5000 for all 0≤k≤62 .

Bonus question: Find an explicit closed form for the elements in Ak for any k . (in this way one can solve the problem also with larger constraints on A,B,C,D ; but it is tedious)

Tutorial of Codeforces Round 889 (Div. 1) Tutorial of Codeforces Round 889 (Div. 2) Tags editorial

Codeforces Round 887 (Div 1, Div 2) Tutorial

By cry, 7 weeks ago, In English We hope you enjoyed these problems :) This contest has been in the works for almost a year.

About the Authors 1853A - Desorting Problem Credits: buffering

Analysis: buffering

Hint 1 Solution To make a not sorted, we just have to make ai>ai+1 for one i .

In one operation, we can reduce the gap between two adjacent elements i,i+1 by 2 by adding 1 to 1…i and subtracting 1 from i+1…n .

It is clearly optimal to pick the smallest gap between a pair of adjacent elements to minimize the number of operations we have to do. If we have ai=x,ai+1=y , we can make x>y within ⌊(y−x)2⌋+1 operations.

Thus, we can just go through a , find the minimum difference gap, and calculate the minimum operations using the above formula. Note that if a is not sorted, we can just output 0 .

The time complexity is O(n) .

Code (C++) 1853B - Fibonaccharsis Problem Credits: ntarsis30, cry

Analysis: cry

Hint 1 Solution The terms of the fibonacci sequence will increase exponentially. This is quite intuitive, but mathematically, fibonnaci-like sequences will increase at a rate of phi to the power of n , where phi (the golden ratio) is about 1.618 . Thus, the maximum number of terms a sequence can have before it reaches 109 , or the maximum value of n , is pretty small (around logn ).

Instead of trying to fix the first two elements of the sequence and counting how many sequences s will have sk=n , note that we already have n fixed. If we loop over the k−1 th element of the sequence, the sequence is still fixed. If we know the x th element and x−1 th element of s , we can find that sx−2=sx−sx−1 .

Thus, we can just go backwards and simulate for k iterations in O(logn) since k is small, breaking at any point if the current sequence is not fibonnaci-like (there are negative elements or it is not strictly increasing). Otherwise, we add 1 to our answer.

The time complexity is O(n⋅logn) .

Code (C++) Bonus: Solve for n,k≤109 Bonus Solution 1852A - Ntarsis' Set Problem Credits: synths

Analysis: synths, buffering

Hint 1 Hint 2 Solution Suppose the numbers are arranged in a line in increasing order. Consider simulating backwards; instead of checking the first number after k operations, we instead start with the number 1 , try to insert dummy characters right after positions a1−1,a2−2,…,an−n so that the dummy characters will occupy positions a1,a2,…,an after the insertion, and after k insertions, we will check the position that 1 will end up at.

If a1 is not equal to 1 , the answer is 1 . Otherwise, each insertion can be processed in O(1) if we keep track of how many of a1−1,a2−2,…,an−n are before the current position x of 1 ; say a1−1 through ai−i are before x , then we will insert i dummy characters before x .

The time complexity is O(n+k) per test case. The editorial code additionally processes every insertion with the same i value in O(1) , for O(n) overall complexity.

There are alternative solutions using binary search with complexity O(klog1018) or O(klognlog1018) , and we allowed them to pass. In fact, this problem was originally proposed with k≤109 but we lowered the constraints.

Code (C++) -- Model Solution Code (C++) -- Simulating Deletions 1852B - Imbalanced Arrays Problem Credits: synths

Analysis: buffering, synths

Hint 1 Hint 2 Hint 3 Hint 4 Solution At the start, let x be an index such that bx has the greatest absolute value. If bx is negative, we have ax=0 , and else ax=n . Moreover, we can't have ax+ay=n for any y≠x , because that implies bx+by is both positive and negative, contradiction. Hence, the necessary and sufficient condition to check if we can determine an element in array b with maximum absolute value is (there exists an element of array a equal to 0 ) xor (there exists an element of array a equal to n ). Then, we can remove that element and re-calculate the a array, leading to an O(n2) solution. If the check fails at any moment, there is no valid solution.

To optimize it further, note that we can sort array a at the start and keep track of them in a deque-like structure. We only need to check the front and end of the deque to see if our key condition holds. Finally, we can use a variable to record the number of positive elements deleted so far and subtract it from the front and end of the deque when checking our condition, so that each check is O(1) . The overall complexity becomes O(nlogn) due to sorting.

Code (C++) 1852C - Ina of the Mountain Problem Credits: One

Analysis: One, EmeraldBlock, GusterGoose27

Hint One Hint 2 Hint 3 Tutorial Read the solution in Hint One before continuing with this tutorial; it provides important definitions.

To reduce the number of possibilities for each c[i] , we prove the following lemma: There exists an optimal choice of c (minimizing throws ) where all differences between adjacent c[i] have absolute value less than k .

Intuitively, this is because we can decrease a c[i] by k . Formally:

Proof of Lemma By the previous lemma, if we have determined c[i] , there are at most 2 choices for c[i+1] . (There is 1 choice when b[i]=b[i+1] , resulting in d[i]=0 , c[i]=c[i+1] , effectively merging the two octopuses.)

We can visualize this as a DAG in the 2D plane over all points (i,c[i]) (over all possible choices of c[i] ). Each point points to the points in the next column that are the closest above and below (if it exists), forming a grid-like shape. Our goal is to find a path of minimum cost from (0,0) to (k+1,0) .

This is the DAG for the second testcase in samples: 

Call each time we choose a c[i+1]>c[i] (i.e. positive d[i] ) an ascent. Note that the number of ascents is fixed because each nonzero d[i] is either x or x+k for some fixed negative x , and there must be a fixed number of +k 's to make the total change from c[0] to c[k+1] zero.

Each ascent brings the path up to the next "row" of descents. Since these rows slope downwards, the j th ascent must take place at or before some index ij , because otherwise c[ij+1] would be negative.

We can use the following strategy to find a path which we claim is optimal:

If we can descend, then we descend. Otherwise, either we ascend, or alternatively, we change a previous descent into an ascent so we can descend here. (This can be further simplified by having a hypothetical "descent" here, so you do not need to compare two possibilities in the implementation.) Now, the best such location for an ascent is the one with minimum cost.

Proof We can implement the above strategy with a priority queue, where for each descent we push on the cost of the corresponding ascent, and when an ascent is required, we then pop off the minimum element. In particular, if b[i]<b[i+1] , then the corresponding ascent has cost b[i+1]−b[i] , while if b[i]>b[i+1] , it has cost b[i+1]−b[i]+k . Also, since the bottom of the DAG corresponds to c[i]=b[i] , an ascent is required exactly when b[i]<b[i+1] .

Code 1852D - Miriany and Matchstick Problem Credits: ArielShehter

Analysis: ArielShehter, emorgan5289, Benq

Hint 1 Hint 2 Hint 3 Hint 4 Solution First, notice that the set of achievable k ’s is a contiguous interval of numbers [min,max] except for when:

The top row of the matchstick consists exclusively of A’s or B’s, in which case min+1 is not achievable The top row of the matchstick consists of alternating different characters, in which case max−1 is not achievable. This can be shown by assuming n≥5 , with b0…bn−1 being the bottom row. Suppose you fix b0=b1=s0 and bn−2=bn−1=sn−1 . Then, toggling zero, one, or both of b0 and bn−1 will increase the number of different adjacent pairs by 0 , 2 , or 4 .

Now, consider a sequence of toggles of b2...bn−3 that reaches every possible configuration, and let x0,x1,x2,… be the number of different adjacent pairs after each toggle. Then, |xi−xi+1| is in [1,3] , and by induction, we can show that U0≤i≤jxi,xi+2,xi+4 attains all integers in an interval [l,r] with the possible exception of l+1 and r−1 .

Knowing this, we can use dynamic programming. Let dp[i][c] represents all ranges of achievable k for a matchstick corresponding to the prefix of the length i of the given top row, such that the i th character in the bottom row is c . We can then work backwards from index i=n and add characters such that the desired k is within the dp range for the prefix of characters not yet added.

The implementation for this can be quite clean if you maintain intervals and merge them, but another way to go about it is also noticing that if a k=x is possible, then k=x+2 will also be possible iff k≤max . Therefore, we can also maintain all possible even interval answers and odd interval answers as 2 separate dp 's.

Code (C++) 1852E - Rivalries Problem Credits: buffering, ArielShehter, One

Analysis: oursaco

Hint 1 Hint 2 Hint 3 Hint 4 Solution Read the hints.

We can remove all intervals that will not affect the power by iterating over them in decreasing order of value and maintain a segment tree that stores for each left endpoint of any processed intervals, the right endpoint that corresponds to it. Checking if an interval is strictly contained then becomes a range minimum query.

Assume that we know the value x of the interval that we want to add. We can immediately fill the value for the interior of all intervals that correspond to a value greater than x . However, we also have to guarantee that x is strictly contained by an interval with greater value, so we can try each interval to contain x . If are no unfilled indices the left or right side of the interval, then we want to replace the smallest filled on either side value with x . Otherwise, we can just fill in all the unfilled indices with x . Note that it is also possible for x to not be able to be contained by any interval.

Thus, we can just try every possible x in decreasing order and maintain the filled indices as we iterate. There are only at most n values of x to check, which is just the set of ai−1 that does not appear in a .

Code (C++) 1852F - Panda Meetups Problem Credits: Benq

Analysis: Benq, oursaco

Hint 1 Hint 2 Hint 3 Hint 4 Solution Read the hints to understand the solution better.

We can answer the queries online. For each x -coordinate x , maintain a treap that stores for every x -coordinate, the minimum cut dp[x][t] associated with a polyline satisfying the condition above that starts at x=−∞ and ends at (x,t) when only considering events with x -coordinate at most x . When transitioning from to x to x+1 , we need to set for every dp[x+1][t]=min(dp[x][t−1],dp[x][t],dp[x][t+1]) for every t . To do this quickly, we maintain the values of t where dp[x][t+1]−dp[x][t]≠0 in increasing order, of which there are at most n . When x increases by one, each value of increases or decreases by one, depending on the sign of dp[x][t+1]−dp[x][t] , and some of the values of t merge, decreasing the size of our treap. As long as we can process each merge in logn time, our solution will run in O(nlogn) total time. When processing an event, we need to increase all dp values in a suffix for red panda events, and all dp values in a prefix for blue panda events. To answer a query, we just need to return the minimum prefix sum in our treap.

Code (C++) Tutorial of Codeforces Round 887 (Div. 1) Tutorial of Codeforces Round 887 (Div. 2)

Codeforces Round #886 (Div. 4) Editorial

By mesanu, history, 18 hours ago, In English Thank you for participating!

1850A - To My Critics

Idea: mesanu

Tutorial 1850A - To My Critics One way to solve the problem is to check if a+b+c−min(a,b,c)≥10 using an if statement.

Solution 1850B - Ten Words of Wisdom

Idea: flamestorm

Tutorial 1850B - Ten Words of Wisdom Let's iterate through all responses: if it has >10 words, ignore it. Otherwise, keep track of the maximum quality and its index, and update it as we go along. Then output the index with maximum quality. The time complexity is O(n) .

Solution 1850C - Word on the Paper

Idea: flamestorm

Tutorial 1850C - Word on the Paper You can iterate through the grid and then once you find a letter, iterate downwards until you get the whole word.

However there is an approach that is even faster to code: just input each character, and output it if it is not a dot. This works because we will input the characters in the same order from top to bottom. The complexity is O(1) regardless.

Solution 1850D - Balanced Round

Idea: SlavicG

Tutorial 1850D - Balanced Round Let's calculate the maximum number of problems we can take, and the answer will be n subtracted by that count.

An arrangement that always minimizes the absolute difference between adjacent pairs is the array in sorted order. What we notice, is that if the array is sorted, we will always take a subarray (all taken elements will be consecutive).

So, the problem converts to finding the largest subarray for which ai−ai−1≤k . It's easy to see that all the subarrays are totally different (don't share any intersection of elements), thus, we can maintain a count variable of the current number of elements in the current subarray, and iterate through array elements from left to right. If we currently are at i and ai−ai−1>k then we just set the count to 1 since we know a new subarray starts, otherwise, we just increase our count by 1 . The answer will be n subtracted by the largest value that our count has achieved.

Solution 1850E - Cardboard for Pictures

Idea: flamestorm

Tutorial 1850E - Cardboard for Pictures The key idea is to binary search on the answer. If you don't know what that is, you should read this Codeforces EDU article. Let's make a function f(x) , which tells us the total area of cardboard if we use a width of x . Then you can see that we can calculate f(x) in O(n) time as (a1+2x)2+(a2+2x)2+⋯+(an+2x)2 , because the side length of the i -th cardboard is ai+2x .

So this means that now we can binary search on the answer: let's find the largest w so that f(w)≤c . The maximum theoretical value of w can be seen not to exceed 109 , since c is not more than 1018 (you can set an even lower bound).

A quick note about implementation: the value of f(x) can exceed 64-bit numbers, so you need to exit the function as soon as you get a value greater than c , or else you risk overflow.

So the time complexity is O(nlog(109)) per test case, which is equal to O(n) with some constant factor. It's not that big to make it fail.

You can also use the quadratic formula, but be careful about implementation of square root and precision issues.

Solution 1850F - We Were Both Children

Idea: mesanu & SlavicG

Tutorial 1850F - We Were Both Children We disregard any ai larger than n since we can't catch them anyway. We keep in cnti how many frogs we have for each hop distance. We go through each i from 1 to n and add cnti to every multiple of i smaller or equal to n . This action is a harmonic series and takes O(nlogn) time. We go through all from 1 to n and take the maximum.

Solution 1850G - The Morning Star

Idea: flamestorm

Tutorial 1850G - The Morning Star Let's look at four directions of the line connecting the compass and morning star: vertical, horizontal, with slope 1 (looks like /), and with slope −1 (looks like \).

vertical: the two points need to have the same y -coordinate. If there are k points with the same y -coordinate, then how many pairs are possible for the morning star and compass? Well, there are k possibilities for the compass, and k−1 for the morning star, so there are a total of k(k−1) valid pairs. In this case, we can use a data structure like a C++ map to count the number of points at each y -coordinate, and add k(k−1) to the total for each k in the map. horizontal: the two points need to have the same x -coordinate. Similarly, we count pairs with the same x -coordinate using a map. slope 1 : note that all lines of this form can be written as x−y=c for a constant c . (Draw some examples out for c=−1,0,1 .) So we can use a map to count values of x−y , and add to the total. slope −1 : similarly, all such lines can be written as x+y=c for a constant c . The time complexity is O(nlogn) . Solution 1850H - The Third Letter

Idea: SlavicG

Tutorial 1850H - The Third Letter We can view the conditions and soldiers as a directed graph. The soldiers represent nodes and the conditions represent directed edges. Saying ai should be di meters in front of bi is equivalent to adding two weighted directed edges:

An edge from ai to bi with weight di . An edge from bi to ai with weight −di . Now, we iterate over all n soldiers, and do a standard dfs whenever we encounter an unvisited soldier, assigning coordinates respecting the weights of the edges. That is, for the first soldier in the set we can just set his coordinate to 0 , then for every neighbor we visit we set it's coordinate to the coordinate of the current node added by the weight of the edge between it and its neighbor.

Finally, we check at the end if all of the m conditions are satisfied.

Solution

Codeforces Round #885 (Div.2) Editorial

By diskoteka, 6 days ago, translation, In English 1848A - Vika and Her Friends

Idea: diskoteka

Tutorial 1848A - Vika and Her Friends Let's color the halls of a rectangle in a chess coloring. Then Vika will be able to escape from her friends infinitely only if none of her friends is on a cell of the same color as Vika.

This observation seems intuitively clear, but let's formalize it.

⇐) It is true, because if initially Vika and her friend were in halls of different colors, then after one move they will remain in halls of different colors.

⇒) Let's choose any of the friends who is in a hall of the same color as Vika. We will show how the friend will act to catch Vika in a finite time. First, let's define a quantity that we will call the area to Vika:

If Vika and the friend are in the same column, then the area to Vika is equal to the sum of the areas of all rows in the direction of Vika and the row where the friend is located. If Vika and the friend are in the same row, then the area to Vika is equal to the sum of the areas of all columns in the direction of Vika and the column where the friend is located. Otherwise, the area to Vika is equal to the area of the quadrant in which Vika is located relative to the friend. Now let's notice that after each action, the friend can improve the next ordered pair: (Manhattan distance to Vika, area to Vika). If Vika is in the same column as the friend. If Vika goes towards the friend, then the friend goes towards her, reducing the distance. If Vika goes in the opposite direction, then the friend also goes towards her, reducing the area to Vika. If Vika goes along the row, then the friend goes towards Vika along the column, which also reduces the area to Vika. If Vika is in the same row as the friend. If Vika goes towards the friend, then the friend goes towards her, reducing the distance. If Vika goes in the opposite direction, then the friend also goes towards her, reducing the area to Vika. If Vika goes along the column, then the friend goes towards Vika along the row, which also reduces the area to Vika. If Vika and the friend are in different rows and columns. If Vika goes towards the friend along the row, then the friend goes towards her along the column, reducing the distance. If Vika goes towards the friend along the column, then the friend goes towards her along the row, reducing the distance. If Vika goes away from the friend, then the friend makes a move in the same direction, thereby reducing the area to Vika. Since each of the quantities in the ordered pair cannot decrease infinitely many times, at some point the distance will become zero, which means a successful capture of Vika. Solution 1848B - Vika and the Bridge

Idea: diskoteka

Tutorial 1848B - Vika and the Bridge In a single linear pass through the array, let's calculate, for each color, the lengths of the two maximum steps between planks of that color. To do this, we will maintain when we last encountered that color.

Now we need to consider that we can repaint one of the planks. Let's say we repaint a plank in color c . It is easy to notice that we should repaint the plank in the middle of the longest step between planks of color c . After all, if we don't repaint such a plank, we will still have to make that longest step.

Therefore, the answer for a fixed color will be the maximum of two values: half the length of the longest step between planks of that color, and the length of the second largest step between planks of that color.

Knowing the answer for each individual color, we can determine the answer to the problem. To do this, we just need to take the minimum of the answers for all colors.

Solution 1848C - Vika and Price Tags

Idea: pavlekn

Tutorial 1848C - Vika and Price Tags First of all, if ai and bi are both zero, then all numbers in the sequence will be zero.

Otherwise, if one of the numbers ai,bi is not zero, then if ai≥bi , after one operation, the sum ai−bi+bi=ai will decrease relative to the original value, or if bi>ai , after two operations, the sum bi−ai+ai=bi will also decrease relative to the original value. Since the sum of non-negative integers cannot decrease infinitely, eventually one of the numbers ai,bi will become zero. Let the first such moment occur after cnti operations. Then, notice that now zeros will alternate with a period of 3 . Therefore, in the problem, we need to check that all cnti have the same remainder when divided by 3 . Thus, the problem reduces to finding cnti for each pair of non-zero ai,bi modulo 3 .

Solution 1: Without loss of generality, assume ai≥bi , otherwise apply one operation. Then, the sequence of numbers will have the form: (ai,bi,ai−bi,ai−2⋅bi,bi,ai−3⋅bi,ai−4⋅bi,bi,…) . Let ai=k⋅bi+r . Then, using simple formulas, we can find the first moment when the neighboring pair of numbers becomes r and bi in some order, and then simply find the answer for them. Thus, the problem can be solved using the generalized Euclidean algorithm.

Solution 2: We will build the sequence from the end. Let's find the first moment when we obtain 0 . Before this zero, there is some number d . It can be easily proven that d is exactly equal to gcd(ai,bi) . Now, let's divide each number in the sequence by d , and obtain a new sequence of numbers, where the last number is zero and the penultimate number is 1 . Then, let's denote even numbers as 0 and odd numbers as 1 . In this way, the sequence can be uniquely reconstructed from the end: (0,1,1,0,1,1,0,1,1,…) . Thus, we can determine the remainder cnti modulo 3 by looking at the pair (ai/d,bi/d) modulo 2 .

The complexity of both solutions will be O(n⋅logai) .

Solution 1848D - Vika and Bonuses

Idea: diskoteka

Tutorial 1848D - Vika and Bonuses First, let's note that the optimal strategy for Vika will be to accumulate bonuses first and then only get the discount. This simple observation is proved by greedy considerations.

Next, let's note that the last digit of the bonus number will either become zero after a few actions (in which case it makes no sense for Vika to accumulate more bonuses), or it will cycle through the digits 2 , 4 , 8 , 6 .

To begin with, let's consider two options: whether Vika will accumulate bonuses at all or always choose the option to get the discount. In the second case, the answer is trivially calculated, but in the first case, we can use the above statement.

Now let's consider four options for the last digit. With a fixed last digit, we can simulate the first actions until we reach that last digit. Then we need to determine how many times we will "scroll" through the digits 2 , 4 , 8 , 6 for the best result. Let's say that at the moment of obtaining the desired last digit, Vika has accumulated b bonuses and she can perform a more actions. Then, if the cycle is "scroll" x times, the discount will be (b+20⋅x)⋅(a−x) . This is a parabola equation. Its maximum can be found using the formula for the vertex of a parabola or by ternary search.

Solution 1848E - Vika and Stone Skipping

Idea: diskoteka

Tutorial 1848E - Vika and Stone Skipping The key observation is that the answer for coordinate x is the number of odd divisors of x . Let's prove this.

Let's see how far a pebble will fly with force f , which touches the water cnt times: f+(f−1)+…+(f−cnt+1)=x . If cnt is even, then x=(cnt/2)⋅(2⋅f−cnt+1)=(p)⋅(2⋅k+1) , where p=cnt/2,k=f−p . In this case, the condition f−cnt+1>0 is necessary, which is equivalent to p≤k .

If cnt is odd, then x=cnt⋅(f−(cnt−1)/2)=(2⋅k+1)⋅(p) , where p=(f−(cnt−1)/2),k=(cnt−1)/2 . Thus, the necessary condition f−cnt+1>0 is equivalent to p>k .

Therefore, for each odd divisor 2⋅k+1 of the number x , we can uniquely associate one of the decomposition options, and hence the number of possible answers is exactly equal to the number of different odd divisors in the factorization of the number x .

Using this observation, it is easy to obtain the answer. We will maintain the power of each prime number in the current coordinate. The answer is the product of (powers +1 ). In order to quickly understand how these quantities change, we will pre-calculate the factorization of all numbers from 1 to 106 . Then the query can be processed by quickly recalculating the powers using the pre-calculated factorizations.

Solution 1848F - Vika and Wiki

Idea: pavlekn

Tutorial 1848F - Vika and Wiki Let's denote next(i,delta)=(i+deltamodn)+1 , and a[cnt][i] represents the value of ai after cnt operations.

First, let's observe that if the array becomes all zeros, it will always remain all zeros. Therefore, we need to find the first moment in time when the array becomes all zeros.

Furthermore, let's see how the array looks like after 2t operations. We will prove by induction that a[2t][i]=a[0][i]⊕a[0][next(i,2t)] for each i . Indeed, for t=0 , this is true by definition, and for t≥1 :

a[2t][i]=a[2t−1][i]⊕a[2t−1][next(i,2t−1)]=a[0][i]⊕a[0][next(i,2t−1)]⊕a[0][next(i,2t−1)]⊕a[0][next(i,2t)]=a[0][i]⊕a[0][next(i,2t)] .

Thus, a[n][i]=a[2k][i]=a[0][i]⊕a[0][next(i,n)]=a[0][i]⊕a[0][i]=0 , which means that after n steps, the array becomes all zeros.

Now, we want to find the minimum number of operations c after which the array a becomes all zeros, knowing that c∈[0,n] . Let's check that c≤n/2 , by explicitly constructing the array a[n/2][i]=a[0][i]⊕a[0][next(i,n/2)] . The condition c≤n/2 is equivalent to all elements of the array a[n/2][i] being zeros.

The algorithm can be summarized as follows:

Check if ai=anext(i,n/2) for each i . If this is true, find the answer for the prefix of the array a of length n/2 . Otherwise, perform n/2 operations on the array a , specifically ai=ai⊕anext(i,n/2) . Now, the array satisfies the condition ai=anext(i,n/2) for each i , so we only need to find the answer for its prefix of size n/2 and add n/2 to it.

The overall complexity of the solution is O(n) .

Solution Tutorial of Codeforces Round 885 (Div. 2)

Codeforces Round #884 (Div. 1 + Div. 2) Editorial

By duality, 11 days ago, In English Video editorials for B, C, and D are available on ak2006's channel.

1844A - Subtraction Game Hint 1 Hint 2 Solution 1844A - Subtraction Game We present two approaches.

Approach 1

If a≥2 , then n=1 works.

Else if a=1 and b≥3 , n=2 works.

Otherwise, a=1 and b=2 , so n=3 works.

Approach 2

Printing a+b works because no matter what move the first player makes, the second player can respond with the opposite move.

The time complexity is O(1) per test case.

Implementation 1844B - Permutations & Primes Hint 1 Hint 2 Hint 3 Solution 1844B - Permutations & Primes The cases n≤2 can be handled separately. For n≥3 , any construction with a1=2,a⌊(n+1)/2⌋=1,an=3 is optimal.

We can prove this as follows: Note that since 2 and 3 are both prime, any (l,r) with l≤⌊n+12⌋≤r has a prime MEX(al,…,ar) except for possibly (l,r)=(1,n) , where MEX(a1,…,an)=n+1 . Therefore the primality of this array is ⌊n+12⌋⋅⌈n+12⌉−[n+1 is not prime] , where [P]=1 if proposition P is true and 0 if P is false. On the other hand, for any permutation of 1,…,n , let k be the index with ak=1 . The primality of this array cannot exceed k(n+1−k)−[n+1 is not prime] , since any pair (l,r) with prime MEX(al,…,ar)≥2 must satisfy l≤k≤r , and additionally MEX(a1,…,an)=n+1 no matter what the permutation is. The function f(k)=k(n+1−k) is a quadratic which is maximized at k=⌊n+12⌋ , so k(n+1−k)−[n+1 is not prime]≤⌊n+12⌋⋅⌈n+12⌉−[n+1 is not prime] as required.

The time complexity is O(n) (note that we don't even need to sieve for primes!).

Implementation 1844C - Particles Hint 1 Hint 2 Solution 1844C - Particles Consider the set of even-indexed particles and the set of odd-indexed particles. Observe that particles can only ever combine with other particles from the same set. It follows that the answer is at most max(∑odd imax(ci,0),∑even imax(ci,0)). On the other hand, this bound is almost always obtainable. We can first perform the operation on all negatively charged particles in the same set as the desired final particle, then perform the operation on all the particles from the opposite set. There is a corner case where all particles are negative, where the answer is just max(c1,…,cn) .

The time complexity is O(n) .

Implementation 1844D - Row Major Hint 1 Hint 2 Solution 1844D - Row Major The condition is equivalent to a graph of pairs of characters in s that need to be different. In graph-theoretic language, we need to find the chromatic number of this graph.

By considering the 1×n and n×1 grids, there is an edge between character u and u+1 for all 1≤u≤n−1 . By considering a nd×d grid (where d divides n ), there is an edge between character u and u+d for all 1≤u≤n−d whenever d divides n .

Let c be the smallest positive integer that does not divide n . There is an edge between every pair of the characters 1,…,c (in graph-theoretic language, this is a clique), so the answer is at least c . On the other hand, consider the string obtained by letting s1,…,sc be all distinct characters and repeating this pattern periodically (si=si+c for all 1≤i≤n−c ). Any pair of equal characters have an index difference that is a multiple of c , say kc . But since c does not divide n , kc also does not divide n , so these characters are not connected by an edge. Therefore this construction gives a suitable string with c distinct characters.

The time complexity is O(n) .

Implementation 1844E - Great Grids Hint 1 Hint 2 Hint 3 Hint 4 Solution 1844E - Great Grids We present two approaches.

Approach 1

Let the letters 'A', 'B', and 'C' correspond to the numbers 0 , 1 , and 2 modulo 3 respectively. Consider drawing an arrow between any two adjacent cells in a great grid pointing to the right or down, and label this arrow with the difference of the two cells modulo 3 .

The conditions imply that all labels are 1 or 2 , and in each contiguous 2×2 subgrid, the top arrow has the same label as the bottom arrow, and the left arrow has the same label as the right arrow. Hence we can associate a type to each of n−1 rows and m−1 columns which is its label. A constraint for cells (x,y) and (x+1,y+1) means that row x and column y must have different labels, and a constraint for cells (x,y+1) and (x+1,y) means that row x and y must have the same label.

These relations form a graph, and the problem reduces to a variant of 2 -colourability, which can be checked using DFS or a DSU.

Approach 2

In a great grid, draw a '/' or '\' for each 2×2 subgrid connecting the equal letters.

We can observe that these grids have a simple pattern: every two rows are either the same or opposite. Furthermore, any such pattern corresponds to a great grid (this can be proven with the idea in approach 1). We can associate a type to each row and column, a boolean variable 0 or 1 , such that an entry is '/' or '\' depending on whether the labels are the same or different.

The constraints correspond to entries needing to be '/' or '\', forming a graph of pairs of labels that must be the same or different. Thus the problem reduces to a variant of 2 -colourability, which can be checked using DFS or a DSU.

The intended time complexity is O(n+m+k) , although slower implementations with complexities like O(nm+k) or O(k(n+m)) can also pass.

Implementation 1844F1 - Min Cost Permutation (Easy Version) Hint 1 Hint 2 Hint 3 Solution (easy version) 1844F1 - Min Cost Permutation (Easy Version) Let the cost of a permutation b of a be the value ∑n−1i=1|bi+1−bi−c| .

When c≥0 , it can be proven that the minimum cost can be obtained by sorting a in nondecreasing order. As sorting a in nondecreasing order is also the lexicographically smallest array, this is the answer.

Similarly, when c<0 , it can be proven that the minimum cost can be obtained by sorting a in nonincreasing order. Furthermore, if we have fixed the values of b1,…,bk for some 1≤k<n , then intuitively, one optimal permutation bk+1,…,bn of the remaining elements is to sort them in nonincreasing order† .

To find the lexicographically smallest permutation, we can greedily loop through k=1,…,n , each time taking the smallest bk that does not increase the cost. If ak≥⋯≥an are the unused elements sorted in nonincreasing order, then the condition we need to check to determine if setting bk:=ai is good is whether |ai−1−ai−c|+|ai−ai+1−c|+|bk−1−ak−c|≥|ai−1−ai+1−c|+|bk−1−ai−c|+|ai−ak−c|(∗) (with some adjustments in the corner cases when k=1 or i=k,n ). This condition (∗) can be checked in constant time, and we try O(n) values of i for each of the O(n) values of k , so the time complexity is O(n2) .

The proofs of the claims used in this solution can be found at the end of the solution for the hard version.

† This is actually not true as stated (e.g. when c=−1 and we fix b1=2 , [2,1,9,8] is better than [2,9,8,1] ), but it turns out it is true for all states that the greedy algorithm can reach (i.e. in this example, the greedy algorithm could not have chosen b1=2 ).

Implementation 1844F2 - Min Cost Permutation (Hard Version) These hints and solution continue from the solution for the easy version, so please read the solution for the easy version first.

Hint 4 Hint 5 Hint 6 Solution (hard version) 1844F2 - Min Cost Permutation (Hard Version) Let c<0 .

We now simplify condition (∗) , which involves considering a few cases depending on the sign of the terms. It turns out that the condition is equivalent to (ai−1−ai+1≤|c| or ai−1=ai or ai=ai+1 ) and (bk−1−ai≤|c| ) (for full details, see the overall proof below).

Sort a in nonincreasing order so that a1≥a2≥⋯≥an . We can simulate the greedy algorithm from the easy version with the help of a linked list of the unused elements of a and a set of ai which satisfy the first part of the condition, (ai−1−ai+1≤|c| or ai−1=ai or ai=ai+1 ). Here, ai−1 and ai+1 actually refer to the closest unused elements of a , which are ai 's left and right pointers in the linked list, respectively.

Each time, we query the set for its smallest element ai that satisfies ai≥bk−1−|c| . If this element does not exist, then we take ai to be the largest element in the linked list. Then, we set bk:=ai , delete ai from the linked list, and update the set with the left and right elements of ai if they now satisfy the condition.

One small observation is that in the answer b , b1=a1 and bn=an . This may simplify the implementation since it means that some edge cases of (∗) actually don't need to be checked. It is also actually not necessary to check the ai−1=ai or ai=ai+1 condition.

The time complexity is O(nlogn) .

Proofs Implementation 1844G - Tree Weights Hint 1 Hint 2 Hint 3 Hint 4 Hint 5 Solution 1844G - Tree Weights Let xu be the sum of the weights of the edges on the path from node 1 to node u . We know that x1=0 and xi+xi+1−2xlca(i,i+1)=di for all 1≤i≤n−1 . This is a system of n linear equations in n variables.

As xu should be integers, let's first solve this system modulo 2 . The 2xlca(i,i+1) term disappears, so we just have xi+1≡di−xi(mod2) . Starting from x1≡0(mod2) , this uniquely determines x2(mod2) , then x3(mod2) , and so on.

Now that we know x1,…,xn(mod2) , write xu=2x′u+bu where bu is the first bit of xu . We can rewrite our system of equations as

(2x′i+bi)+(2x′i+1+bi+1)−2(2x′lca(i,i+1)+blca(i,i+1))=di ⟺x′i+x′i+1−2x′lca(i,i+1)=12(di−bi−bi+1+2blca(i,i+1)) which has the same form as the original system. Thus we can repeat this process to find x′u(mod2) (giving xu(mod4) ), then xu(mod8) , and so on. Note that each bit of xu is uniquely determined.

If a solution exists, it satisfies 0≤xu≤n⋅maxdi≤1017 for all u , so it suffices to repeat this process until we have found the first 57 bits of xu . Finally, we check that these 57 bits correspond to a valid solution where all the original weights are positive.

The time complexity is O(n(logn+logmaxdi)) , if the lca(i,i+1) are precomputed.

Remark: This idea is related to the method of Hensel Lifting.

Implementation 1844H - Multiple of Three Cycles Hint 1 Hint 2 Hint 3 Hint 4 Hint 5 Hint 6 Solution 1844H - Multiple of Three Cycles The partially formed permutation is composed of several paths and cycles, and only the length of each path/cycle modulo 3 matters. We can use a DSU to track the number of paths/cycles of each length (mod3) . If at any point a cycle whose length is not ≡0(mod3) is formed, the answer is 0 .

Thus, the problem reduces to the following:

Given a 1 s, b 2 s, and c 0 s, how many ways are there to build a permutation on these objects so that each cycle sums to a multiple of 3 ? Let f(a,b,c) be the answer to this problem. Note that f(a,b,c)=(a+b+c)f(a,b,c−1) for c>0 , as there are a+b+c ways to choose the next object of any 0 , and after merging this 0 with its next object, there are f(a,b,c−1) ways to build a permutation on the remaining objects. Repeatedly applying this recurrence gives f(a,b,c)=(a+b+c)!(a+b)!f(a,b,0) , so we can eliminate the c parameter and multiply the answer by a factorial and inverse factorial in the end.

Now let f(a,b)=f(a,b,0) . We have not one, but two recurrence relations f(a,b) satisfies:

f(a,b)=bf(a−1,b−1,1)+(a−1)f(a−2,b+1)=b(a+b−1)f(a−1,b−1)+(a−1)f(a−2,b+1) when a>0 (consider the next object of any 1 ) f(a,b)=af(a−1,b−1,1)+(b−1)f(a+1,b−2)=a(a+b−1)f(a−1,b−1)+(b−1)f(a+1,b−2) when b>0 (consider the next object of any 2 ) The key idea now is that because we have two equations relating the four values f(a,b),f(a−1,b−1),f(a+2,b−1),f(a−1,b+2) , given any two of these values, we can solve for the other two. For example, if we know f(a,b) and f(a−1,b−1) , we can calculate f(a−2,b+1)=f(a,b)−b(a+b−1)f(a−1,b−1)a−1 . Also note that the queried pairs (a,b) can be visualized as a walk in the plane, where each pair does not differ from the previous pair by much. By using these recurrences carefully, it is possible to calculate f(a,b) for all queries (a,b) while calculating only O(n) values of f .

The details can be tricky. The author's solution does the following: First, reverse the order of the updates, possibly adding dummy updates if a cycle whose length is not ≡0(mod3) is created early. Then we need to find f(ai,bi) for a sequence of pairs (a1,b1),(a2,b2),… where (a1,b1)=(0,0) and (ai+1,bi+1) is one of (ai,bi) , (ai−1,bi+2) , (ai+2,bi−1) , or (ai+1,bi+1) for all i . We loop through i in order, maintaining two values u:=f(ai,bi) and v:=f(ai+1,bi+1) at all times. Whenever we need a transition of the form (ai,bi)→(ai−1,bi+2) , we use the recurrence f(ai+1,bi+1)=(bi+1)(ai+bi+1)f(ai,bi)+aif(ai−1,bi+2) to solve for f(ai−1,bi+2) (the new value of u ), then use the recurrence f(ai,bi+3)=ai(ai+bi+2)f(ai−1,bi+2)+(bi+2)f(ai+1,bi+1) to find f(ai,bi+3) (the new value of v ). The (ai,bi)→(ai+2,bi−1) transition is similar. For (ai,bi)→(ai+1,bi+1) transitions, do both of the previous types of transitions once.

The time complexity of the main part of the problem is O(N) . The overall time complexity is O(Nα(N)) , dominated by the DSU operations.

Remark 1: Since 1 s and 2 s behave symmetrically, f(a,b,c)=f(b,a,c) .

Remark 2: The exponential generating function for f(a,b) is ∑a≥0∑b≥0f(a,b)a!b!xayb=(1−(x3+3xy+y3))−1/3 .

Implementation Tutorial of Codeforces Round 884 (Div. 1 + Div. 2)

Codeforces round 883 Editorial

By natalina, 2 weeks ago, translation, In English 1846A - Rudolph and Cut the Rope

Author: Sasha0738

Hint 1 Hint 2 Tutorial 1846A - Rudolph and Cut the Rope In order for the candy to be on the ground, it is necessary that all the ropes touch the ground. This means that the length of all ropes must be greater than or equal to the height of the nails to which they are attached. That is, you need to cut all the ropes, the length of which is less than the height of their nail. Then the answer is equal to the number of elements that have ai>bi .

Solution Rate the problem 1846B - Rudolph and Tic-Tac-Toe

Author: Sasha0738

Hint 1 Tutorial 1846B - Rudolph and Tic-Tac-Toe To solve this problem, it is enough to check the equality of elements on each row, column and diagonal of three elements. If all three elements are equal and are not ".", then the value of these elements is the answer. Note that a row of "." does not give you answer ".". Statement does not say that the players have equal amount of moves, which means that one player can have several winning rows.

Solution Rate the problem 1846C - Rudolf and the Another Competition

Author: vladmart

Hint 1 Hint 2 Tutorial 1846C - Rudolf and the Another Competition First of all, it is necessary to determine the optimal order of solving problems for each participant. It is claimed that it is most optimal to solve problems in ascending order of their solution time. Let's prove this:

Firstly, it is obvious that this strategy will allow solving the maximum number of problems. Secondly, this strategy will also result in the minimum total penalty time. Let's assume that the participant solves a total of m problems. The solution time of the first problem will be added to the penalty time for all m problems, the solution time of the second problem will be added to the penalty time for m−1 problems, and so on. Therefore, it is advantageous for the longest time to be added to the fewest number of problems. In other words, the problem with the longest solution time should be solved last. Then, the same reasoning is repeated for the remaining m−1 problems. Next, it is necessary to calculate the number of solved problems and the penalty time for each participant, based on the described strategy. To do this, sort the solution times of the problems for each participant and simulate the solving process. Finally, count the number of participants who outperform Rudolph in the results table. The overall time complexity is O(n⋅m⋅logm) .

Solution Rate the problem 1846D - Rudolph and Christmas Tree

Author: vladmart

Hint 1 Hint 2 Hint 3 Tutorial 1846D - Rudolph and Christmas Tree Let's consider the triangles in ascending order of yi . Let the current triangle have index i . There are two cases:

The triangle does not intersect with the (i+1) -th triangle (yi+1−yi≥h) . In this case, we simply add the area of the triangle to the answer. The area will be d⋅h2 . The triangle intersects with the (i+1) -th triangle (yi+1−yi<h) . We can add to the answer the area of the figure that does not belong to the intersection and move on to the next triangle. Note that this figure is a trapezoid with a lower base d and height h′=yi+1−yi . The upper base can be found based on the similarity of triangles. The heights of the triangles are in the ratio k=h−h′h . Then the upper base dtop=d⋅k . The area of the trapezoid is h′⋅d+dtop2 . Time complexity is O(n) .

Solution Rate the problem 1846E1 - Rudolf and Snowflakes (simple version)

Author: natalina

Hint 1 Hint 2 Hint 3 Tutorial 1846E1 - Rudolf and Snowflakes (simple version) For the current given constraint you can precalculate whether it is possible to obtain each n for some k . To do this, we can iterate through all possible 2≤k≤106 and for each of them calculate the values 1+k+k2 , 1+k+k2+k3 , ..., 1+k+k2+k3+...+kp , where p is such that 1≤1+k+k2+k3+...+kp≤106 . For this version of problem it is enougth to calculete valuse for p≤20 .

Note that the minimum number of snowflake layers is 3 . Therefore, the calculations start from the value 1+k+k2 .

We can store all the obtained values, for example, in a set. Alternatively, we can use an array called "used" and set the value 1 in the array element with the corresponding index for each obtained value.

It is better to perform this precalculation before iterating through the test cases.

Then, for each test, we only need to read the value of n and check if we have obtained it in the precalculation described above.

The time complexity of the solution using a set is O(n−−√⋅p⋅logn+tc⋅logn .

The time complexity of the solution using the "used" array is O(n−−√⋅p+tc) .

Here tc — number of test cases.

Solution Rate the problem 1846E2 - Rudolf and Snowflakes (hard version)

Author: natalina

Hint 1 Hint 2 Hint 3 Hint 4 Tutorial 1846E2 - Rudolf and Snowflakes (hard version) On these constraints, it is also possible to precalculate whether it is possible to obtain certain values of n for some k . To do this, we can iterate through all possible 2≤k≤106 and for each of them calculate the values 1+k+k2 , 1+k+k2+k3 , ..., 1+k+k2+k3+...+kp , where p is such that 1≤1+k+k2+k3+...+kp≤1018 . However, in order to obtain all possible values of n , we would have to iterate through k≤109 , which exceeds the time limits. Therefore, let's precalculate all possible values of n that can be obtained for 3≤p≤63 .

We will store all the obtained values, for example, in a set. We cannot use an array called "used" here due to the constraints on n .

It is better to perform this precalculation before iterating through the test cases of the current test case.

Next, for each test, we only need to read the value of n and check if we obtained it in the aforementioned precalculation.

If we obtained it, we output "YES" and move on to the next test.

If we did not obtain it, we need to separately check if we could obtain this value for p=2 . To do this, we solve the quadratic equation k2+k+1=n . If it has integer roots that satisfy the problem's constraints (k>1 ), then the answer is "YES". Otherwise, it is "NO".

The time complexity of the solution is O(n−−√3⋅p⋅logn+tc⋅logn) .

Here, tc is the number of tests in the test case.

Solution Rate the problem 1846F - Rudolph and Mimic

Author: Sasha0738

Hint 1 Hint 2 Tutorial 1846F - Rudolph and Mimic The strategy is to keep track of the number of objects of each type. When the number of objects of a certain type increases, that means the mimic has turned into an object of that type. Then you can delete all other objects. After the first such removal, all objects will become equal. Then, after maximum two stages, the mimic will be forced to turn into something else and it will be possible to unambiguously identify it.

Let's consider the worst case, where the mimic does not change its appearance between the first and second stages. Then we do not remove any element with the first two requests. Between the second and third steps, the mimic will be forced to transform, and then we can remove all objects except for those that have the same type as the mimic. The mimic may not change between the third and fourth stages, but will be forced to transform between the fourth and fifth. Then we will be able to unambiguously determine the mimic, since before the transformation all objects were the same.

Solution Rate the problem 1846G - Rudolf and CodeVid-23

Author: vladmart

Hint 1 Hint 2 Hint 3 Tutorial 1846G - Rudolf and CodeVid-23 Let's denote Rudolf's state as a binary mask of length n consisting of 0 and 1 , similar to how it is given in the input data. Then each medicine transforms Rudolf from one state to another.

Let's construct a weighted directed graph, where the vertices will represent all possible states of Rudolf. There will be 2n such vertices. Two vertices will be connected by an edge if there exists a medicine that transforms Rudolf from the state corresponding to the first vertex to the state corresponding to the second vertex. The weight of the edge will be equal to the number of days that this medicine needs to be taken. Note that in this case, we simply need to find the shortest path in this graph from the vertex s , corresponding to the initial state of Rudolf, to the vertex f , corresponding to the state without symptoms.

To find the shortest path in a weighted graph, we will use Dijkstra's algorithm. We will run it from the vertex s and if, as a result, we visit the vertex f , output the distance to it, otherwise −1 .

The time complexity is O(n⋅m⋅2n) .

Solution Rate the problem Tutorial of Codeforces Round 883 (Div. 3) Tags div3, editorial

Codeforces Round 882 Editorial

By PoPularPlusPlus, history, 2 weeks ago, In English 1847:A — The Man who became a God

Author — PoPularPlusPlus tutorial 1847A - The Man who became a God Let us find f(1,n) . Now, you need to divide the array into more K−1 parts. When you split an array b of size m into two parts, the suspicion changes from f(1,m) to f(1,i)+f(i+1,m) (1≤i<m ). Also, f(1,m)=f(1,i)+|bi−bi+1|+f(i+1,m) . Substituting this in previous change, we get f(1,i)+|bi−bi+1|+f(i+1,m) changes to f(1,i)+f(i+1,m) . That is, |bi−bi+1| gets subtracted. Now, to get minimum suspicion, we need to break the array a at i such that |ai−ai+1| gets maximised.

Now, we have array dif of size n−1 where difi=|ai+1−ai| (1≤i<n ). We can solve the problem using any of the two approaches.

- Find the least element in dif and remove that from dif and add that element to the answer. Do this exactly k−1 times. Time complexity - O(n2) .

- We can sort dif and don't take k−1 maximum elements (or take first (n−1)−(k−1) elements. Time Complexity - O(nlogn) .

solution 1847:B — Hamon Odyssey

Author — PoPularPlusPlus tutorial [problem:1847B] There are two cases in this problem. First, if f(1,n)>0 , then maximum number of groups becomes 1 . This is because there are some bits set in all the elements. Now, if we divide the array in more than one group, then these bits are taken more than once which will not give smallest AND. Second case is when f(1,n)=0 . This means the smallest AND is 0 . Now, we need to greedily divide the array into subarrays such that the AND of each subarray should be 0 . We keep taking elements in the subarray until the AND becomes 0 . When AND becomes 0 , we take remaining elements in the next subarray. If the last subarray has AND more than 0 , then we need to merge that subarray with the previous subarray.

Time complexity - O(n) .

solution 1847:C-Vampiric Powers, anyone?

Author — PoPularPlusPlus tutorial 1847C — Vampiric Powers, anyone? At the end of the array, you can only achieve xor of any subarray of the original array.

proof Now, we maintain a boolean array b where bi is 1 if there is some j such that a1⊕a2⊕⋯⊕aj=i . Initially, b is all 0 . We loop j from 1 to n and check for each k if bk=1 . If it is, then there is some position p<j such that a1⊕a2⊕⋯⊕ap=k . If we take xor of range from (p,j] , then it will be k⊕a1⊕a2⊕⋯⊕aj (as a1⊕a2⊕⋯⊕ap gets cancelled). This a1⊕a2⊕⋯⊕aj can be stored as we loop ahead. We are looping all possible prefix xors and not all prefix positions because n is large.

Time Complexity — O(n⋅28) .

solution 1847:D Professor Higashikata

Author — PoPularPlusPlus tutorial [problem:1847D] Lets assume you know string t . String t is made by positions in s . Lets denote f(i)= position in s from which ti is made. For maximising t you need to make the starting elements in t as large as possible. Now, to make t lexicographically as large as possible, we need to swap positions in s . We can swap positions greedily. We first try making sf(1)=1 . Then we try making sf(2)=1 and so on.

Now, suppose for two indices i ,j (1≤i<j≤|t| ) such that f(i)=f(j) , we know that index j is waste. t is basically the preference of indices in s which should be equal to 1 . If sf(j) is to be set 1 , then it would already be set 1 because before setting sf(j) equal to 1 we would have already set sf(i) equal to 1 because f(i) is equal to f(j) . Hence, for each index i in s , we only add its first occurrence in t . This makes the size of t bound by size of s . Now, this t can be found using various pbds like set,dsu,segment tree,etc.

Now, before answering the queries, we find the answer for the current string s . We know that there are x ones and n−x zeros in s . So, for each i (1≤i≤min(x,|t|) ), we make sf(i)=1 . Hence, the number of swaps needed will become number of positions i (1≤i≤min(x,|t|) ) such that si=0 .

Now, in each query, there is exactly one positions that is either getting flipped from 0 to 1 or from 1 to 0 . That is, x is either getting changed to x+1 or x−1 . You already know the answer for x . Now, if x is getting reduced, then you need to decrease the answer by one if x<=|t| and sf(x)=0 . If x is increasing by one, then you need to add one to the answer if x<|t| and sf(x+1)=0 .

Time complexity - O(nlogn+q) .

solution 1847:E Triangle Platinum?

Author — StArChAn tutorial [problem:1847E] First, notice that we can uniquely determine the multiset of numbers any three ai,aj,ak except for the collision between triples (1,4,4) and (2,2,3) . The issue is that even if we know the multiset we cannot always uniquely determine ai,aj,ak .

But what if all the elements of the multiset are equal? Then each element obviously has to be equal to the value of the multiset. So if for some three distinct i,j,k the area of ai,aj,ak is one of 3–√/4,3–√,93–√/4,43–√ , then they are all equal to 1,2,3 or 4 respectively, depending on the area.

Let us say we knew that ai=aj=ak=C for some C∈[1,4] after asking q queries. By querying (i,j,x) for every x other than i,j we can obtain the area of C,C,ax for each x . This will allow us to uniquely determine each ax . But wait! There is an important edge case here. We also require C,C,ax to form a valid triangle.

If C≥2 , this is not an issue because 2,2,4 can be just assigned an area of "0 " and we can still uniquely retrieve the values. So using this procedure, it takes us q+n−3 queries to determine all the values.

The only possibility remaining is when C=1 . In this case, the issue is that only [1,1,1] let us know the value of ax . When ax>1 , it's impossible to distinguish between ax=2,3,4 . So if we asked all questions, we would know which indices have value >1 and which indices have a value of 1 .

Now if we could find two equal elements among these indices with value >1 , we can repeat a similar linear scan as above and find all values. But how do we find two equal values? Notice that every value is among 2,3,4 . So if we had ≥4 such indices with value >1 some two of them would be equal, and we could find them by bruting queries of the form (i,m1,m2) over all pairs of indices m1,m2 with value >1 .

After this we can then again query all the other >1 indices and find answer. This would take around q+n′+2(n−n′)−O(1) queries, where n′ is the number of ones. Unfortunately this would QLE if n′ were around n/2 .

How do we fix this? The answer is surprisingly simple. When we were finding indices with value >1 we simply stop the minute we have at least 4 such indices (it's ok even if we don't).

Now we brute over all pairs. If we find two equal, we are done within at most q+n+16 queries. On the other hand if we cannot find two equal it means that we can never distinguish between them. This is because any query of the form (1,x,y) where x≠y are both ≥2 is always a degenerate query hence will have answer 0 . So if we do not find two equal, we will print −1 .

After all this work, there are still a few details left. First, q must be small. Otherwise all the above work is useless. Second there should be three equal elements in the first place.

The first observation is that if n≥9 then by Piegonhole Principle, some ⌈n/4⌉≥3 must be equal. So if n≥9 then by bruting over all 1≤i<j<k≤9 triples (i,j,k) we can always find some three equal. Here we would have q=(93)=84 and we are asking at most n+84+16 queries, which fits comfortably.

But what if n<9 ? In this case we can simply brute all possible (93)=84 queries and then for each of the 4n arrays possible check if the triples of that array match with the query answers obtained here. If there is exactly one such array, we have found it and we can print it, otherwise we print −1 because it is not possible to uniquely determine the values of the array. Notice that this takes at most 48⋅(83) operations, which is around 3.7⋅106 which fits in the TL.

This solves the problem.

You might wonder why 5500 queries were allowed even though the above solution does not use more than around 5100 queries. This is because we allowed randomisation as a valid way of finding three equal values ai,aj,ak . Suppose there are c1,c2,c3,c4 counts of 1,2,3,4 respectively. If we randomly queried a triple (i,j,k) each time, the probability all would be equal is precisely: (c13)+(c23)+(c33)+(c43)(n3) It is easy to see that the above is minimised when the ci are roughly equal. When n≥30 , the above is at most 117 , so we will find a equal triple very quickly. The other case is when n<30 . In this case, since (303)<5500 , we can simply query every triple and solve directly by finding three equal instead of relying on randomness. This sort of a method gives q≤400 with very high probability, so it will still pass with at most 5500 queries.

deterministic solution randomisation solution 1847:F The Boss's Identity

Idea — astoria Prepared by — PoPularPlusPlus tutorial [problem:1847F] Lets start with an example of n=5 . Let a=[a,b,c,d,e] where a ,b ,c ,d and e are variables. First 20 elements of a will be [a ,b ,c ,d ,e ,ab ,bc ,cd ,de ,abe ,abc ,bcd ,cde ,abde ,abce ,abcd ,bcde ,abcde ,abcde ,abcde ]. By removing and rearranging some elements we can get

b c d e ab bc cd de eab abc bcd cde deab eabc abcd bcde Here you can observe that each group will have a size of n−1 . The next group will be the previous group, _or_ed with the element immediately before the first element (circularly).

So we have the rule. Now let's solve the problem in binary (that is, every element is 0/1 ). Let's take a look at the element a in the rearranged version (the highlighted ones). If a is 0 , it won't contribute anything to the subsequent groups, so we can ignore it. Otherwise, it will contribute by keeping moving to the right. This will end when it meets a cell in the group that is already 1 . And after that, we can drop the act of moving a .

This algorithm can actually help us construct the whole array sparsely and incrementally. We can maintain the list of 1 in the initial array, and then update the array by moving all of them to the right. That is, if we have one group, we can obtain the next group by moving the 1 . After that, we can drop moving some 1 if it meets another 1 .

The whole action is O(n) , as there are at most n zeros to be updated.

So for the original problem, first of all, we can repeat the above algorithm bitlength=31 times, that is, repeat the algorithm for each bit. Secondly, there are at most O(logn) unique numbers for each position, so we can just find all O(nlogn) last positions of all numbers, and put them in a array.

You can either find all nlogn unique positions in ascending order and or in random order and sort the array. Then using binary search we can answer each query.

Time complexity of the former version is O(nlogn+qlog(nlogn)) and the latter version is O(nlognlog(nlogn)+qlog(nlogn)) .

solution Tutorial of Codeforces Round 882 (Div. 2)

CodeTON Round 5 Editorial

By platelet, 16 hours ago, In English 1842A - Tenzing and Tsondu Tutorial Let's view it as when monsters x and y fight, their health changes into max(x−y,0) and max(y−x,0) respectively. So any monster with 0 health is considered dead. Therefore, a player loses when the health of his monsters are all 0 .

Notice that max(x−y,0)=x−min(x,y) and max(y−x,0)=y−min(x,y) . Therefore, after each step, the sum of the health of monsters decrease by the same amount for both players.

Therefore, we only need to know ∑ai and ∑bi to determine who wins. If ∑ai>∑bi , Tsondu wins. Else if ∑ai<∑bi , Tenzing wins. Else, it is a draw.

Code 1842B - Tenzing and Books Tutorial Observe the bitwise OR: if a bit of the knowledge changes to 1 , it will never become 0 .

It tells us, if a book has difficulty rating y , and x|y≠x , Tenzing will never read this book because it will change a 0 bit in x to 1 .

We called a number y valid if x|y=x . For each sequence, we can find a longest prefix of it such that all numbers in this prefix are valid. Find the bitwise OR of the three prefix and check whether it equals to x .

Time complexity: O(n) per test case.

Code 1842C - Tenzing and Balls Tutorial Let us write down the original index of each range we delete.

Firstly, it is impossible to delete ranges (a,c) and (b,d) where a<b<c<d .

Secondly, if we delete ranges (a,d) and (b,c) where a<b<c<d , we must have deleted range (b,c) before deleting range (a,d) . Yet, the effect of deleting range (b,c) and then (a,d) is the same as only deleting (a,d) .

Therefore, we can assume that in an optimal solution, the ranges we delete are all disjoint. Therefore, we want to find some disjoint range [l1,r1],[l2,r2],...,[lm,rm] such that ali=ari and ∑(ri−li+1) is maximized.

We can write a DP. dpi denotes the minimum number of points we do not delete when considering the subarray a[1…i] . We have dpi=min(dpi−1+1,min{dpj|aj+1=ai,j+1<i}) .

This dp can be calculated in O(n) since we can store for each ai what the minimum dpj which satisfy aj+1=ai .

Code 1842D - Tenzing and His Animal Friends Tutorial Consider the restrictions on u , v , and y as a weighted edge between u and v with weight y . Obviously, the final answer will not exceed the shortest path from 1 to n .

One possible approach to construct the solution is to start with the set 1 and add vertexes one by one. If i is added to the set at time Ti , then we need to ensure that |Tu−Tv|≤y for any edge between u and v in the set. This can be modeled as a system of difference constraints problem and solved using shortest path algorithms.

To be more specific, we can add vertexes in increasing order of their distances from 1 . The time for each set can be calculated as the difference between the distances from 1 to the two adjacent vertexes in the sorted order.

Code 1842E - Tenzing and Triangle Tutorial Observe that all triangles will be disjoint, if two triangle were not disjoint, we can merge them together to such that the cost used is less. Therefore, we can consider doing DP.

Let dpi,j denote the cost when consider all points with coordinates i≤x and j is the minimum possible point such that (i,j) is in the triangle.

There are two transitions. The first transition is when there are point (i,y) . We will need to add the cost of the point to dpi,j for all y<j .

The second transition is when we add a new triangle or extend a triangle to the left.

These transitions can be handled using a segment tree.

Code 1842F - Tenzing and Tree Tutorial Let root be the centroid of all black vertexes and sizei be the number of black vertexes in the subtree of node i .

Then the value is ∑i≠rootk−2⋅sizei=(n−1)⋅k−2⋅∑i≠rootsizei .

Consider painting node i black, it will contribute 2⋅depthi to all of its ancestors, where depthi is the distance from root to i .

Since we want to maximize the value, we can greedily select the node with the smallest depthi .

But how do we ensure that root is the centroid after selecting other black vertexes? We can simply take the maximum of all possible root because if a node is not the centroid, some edges will have a negative weight, making it worse than the optimal answer.

Enumerate all possible root and use BFS to add vertexes based on their distance to root . The complexity is O(n2) .

Code 1842G - Tenzing and Random Operations Tutorial Before starting to solve this problem, let's establish two basic properties:

For two completely independent random variables x1,x2 , we have E(x1x2)=E(x1)E(x2) . For (a+b)×(c+d) , we have E((a+b)×(c+d))=E(ac)+E(ad)+E(bc)+E(bd) . Returning to this problem, let xi,j be a random variable: its value is v when the i -th operation sets aj to aj+v , otherwise it is 0 .

Then note that the answer is the expected value of ∏ni=1(ai+∑mj=1xj,i) .

Applying the second property above to split the product, each term is a product of some ai and x .

Specifically, each term has n factors, and for each i∈[1,n] , either ai is one of its factors, or some xj,i is one of its factors.

Let's investigate the expectation of a specific term. Note that if i1<i2 , then E(xj,i1×xj,i2)=E(xj,i1)×v , that is, if xj,i1 is 0 then the whole product is 0 , and if xj,i1 is v then xj,i2 must be v .

Therefore, for all the x factors in a term, we categorize them by the first index, i.e. we group all xj,... into category j . For each category, we only need to focus on the first variable. If it's v , then the remaining variables take value v , otherwise the result is 0 . Note that the variables in different categories are completely independent (because their values are determined by operations in two different rounds), so the expected product of the variables in two categories can be split into the product of the expected products of the variables within each category.

Our goal is to compute the expected sum of all the terms, which can be nicely combined with DP:

Let dp(i,j) be the value that we have determined the first i factors of each term and there are j categories that have appeared at least once (if adding the variable at position i+1 brings contribution v , otherwise the contribution is i+1n×v ). The transition can be easily calculated with O(1) , depending on whether to append ai+1 or x...,i+1 to each term, and if it's the latter, we discuss whether the variable belongs to one of the j categories that have appeared or the other m−j categories. The time complexity is O(n×min(n,m)) .

Code 1842H - Tenzing and Random Real Numbers Tutorial Assuming there is no variable equal to 0.5 , because the probability of being equal to 0.5 is 0 , we call variables smaller than 0.5 white points, and those larger than 0.5 black points. Each black-white coloring has equal probability, so we can calculate the probability of being legal for each black-white coloring, and then take the average.

For two variables smaller than 0.5 , the condition ≤1 is always satisfied, and the condition ≥1 is always not satisfied, so we do not need to consider the condition between same-colored points. The condition between white point u and black point v is satisfied if and only if xu≤1−xv . We define yu=min(xu,1−xu)={xu1−xu(u is white)(u is black) . Then yu can be regarded as a random variable on [0,0.5) . For the ≤1 condition, the y of white points must be less than or equal to the y of black points, so we connect white points to black points. For the ≥1 condition, we connect black points to white points.

We obtain a directed graph that limits the size relationship of y1⋯n . Let y1⋯n be sorted in ascending order as yp1,yp2,⋯,ypn . Each permutation p is equally probable, and p contributes if and only if it is a topological order, so the legal probability is the number of topological orders divided by n! .

Now the problem has been transformed into a counting problem. For each black-white coloring, we count the sum of the number of topological orders. Now we do not enumerate black-white coloring, but directly enumerate the topological order, that is, we enumerate a permutation p such that yp1<yp2<⋯<ypn , and count the number of black-white colorings that can satisfy the conditions. It can be found that the ≤1 condition limits the variables later in p to be <0.5 , and the other one without restrictions, the ≥1 condition limits the variables later in p to be >0.5 .

Next, we perform bit-mask DP. Let dpmask denote the topological order of mask already added. We enumerate the newly added point u . If mask contains all the variables that have ≤1 conditions with it, then it can be colored black. If mask contains all the variables that have ≥1 conditions with it, then it can be colored white.

The complexity is O(2nn) .

Code 1842I - Tenzing and Necklace Hint 1 Hint 2 Tutorial Add a constraint: "you must cut off m edges".

Consider enumerating the minimum cut edges from small to large.

Suppose the minimum cut edge chosen is a1 , and the subsequent optimal solution is a2,a3,...,am .

If another minimum cut edge is selected: b1 , and the subsequent optimal solution is b2,b3,...,bm .

Assume that ai<ai+1,bi<bi+1,b1>a1 .

1. It is possible to only adjust b2,b3,...,bm , so that ∀1≤i≤mbi≥ai , and the total cost after adjustment remains unchanged. The adjustment method is as follows:

Find the smallest i such that bi<ai , and find the first j such that bj≥aj after i , if it does not exist, let j=m+1 .

It can be observed that (bi,bi+1,bi+2,...,bj−1) can be replaced with (ai,ai+1,ai+2,...,aj−1) , which is still a valid solution. Moreover, the solution (ai,ai+1,ai+2,...,aj−1) can also be replaced with (bi,bi+1,bi+2,...,bj−1) , because bi−1≥ai−1 and bj≥aj .

Since a and b are both optimal solutions with fixed a1 and b1 , wbi+wbi+1+...+wbj−1=wai+wai+1+...+waj−1 . Therefore, replacing (bi,bi+1,bi+2,...,bj−1) with (ai,ai+1,ai+2,...,aj−1) does not increase the total cost.

Repeat the above adjustment until there is no bi<ai .

Similarly, it can be proven that only adjusting a2,a3,...,am is feasible, so that ∀1≤i≤mbi≥ai , and the total cost after adjustment remains unchanged.

2. If ∀1≤i≤mbi≥ai is already satisfied, it is possible to only adjust b2,b3,...,bm , so that ∀1≤i<mai≤bi≤ai+1 , and the total cost after adjustment remains unchanged. Assume that a1<b1≤a2 . The adjustment method is as follows:

Find the smallest i such that bi>ai+1 , and find the first j such that bj≤aj+1 after i (let am+1=+∞ ).

(bi,bi+1,bi+2,...,bj−1) can be replaced with (ai+1,ai+2,ai+3,...,aj) , which is still a valid solution. Moreover, the solution (ai+1,ai+2,ai+3,...,aj) can also be replaced with (bi,bi+1,bi+2,...,bj−1) , because bi−1≤ai and bj≤aj+1 .

Since a and b are both optimal solutions with fixed a1 and b1 , wbi+wbi+1+...+wbj−1=wai+1+wai+2+...+waj . Therefore, replacing (bi,bi+1,bi+2,...,bj−1) with (ai+1,ai+2,ai+3,...,aj) does not increase the total cost.

Similarly, it can be proven that only adjusting a2,a3,...,am is feasible, so that ∀1≤i<mai≤bi≤ai+1 , and the total cost after adjustment remains unchanged.

3. If b1>a2 , it is possible to adjust b1,b2,...,bm , so that b1≤a2 , and the total cost does not increase. The adjustment method is as follows:

Find the smallest j such that bj≤aj+1 (let am+1=+∞ ).

It can be observed that (a2,a3,a4,...,aj) can be replaced with (b1,b2,b3,...,bj−1) , which is still a valid solution. Moreover, the solution (b1,b2,b3,...,bj−1) can also be replaced with (a2,a3,a4,...,aj) , because bj≤aj+1 .

Since a is the optimal solution with fixed a1 and b1 , wb1+wb2+...+wbj−1≥wa2+wa3+...+waj . Therefore, replacing (b1,b2,b3,...,bj−1) with (a2,a3,a4,...,aj) does not increase the total cost.

Combining the above conclusions, we can obtain a solution that must cut off m edges:

Let a1=1 , find the optimal solution a1,a2,a3,...,am .

Then, it can be assumed that all bi satisfy ai≤bi≤ai+1 .

A divide-and-conquer algorithm can be used. Let solve((l1,r1),(l2,r2),(l3,r3),...,(lm,rm)) represent the optimal solution for all li≤bi≤ri .

If l1>r1 , then we are done. Otherwise, let x=⌊l1+r12⌋ , we can use DP to calculate the cost and solution for b1=x in O(∑ri−li+1) time complexity. Then, recursively calculate solve((l1,b1−1),(l2,b2),(l3,b3),...,(lm,bm)) and solve((b1+1,r1),(b2,r2),(b3,r3),...,(bm,rm)) .

Time complexity analysis: ∑ri−li+1=(∑ri−li)+m . If the sum of adjacent parts is ≤k , it can be merged, but it is definitely not the optimal solution. Therefore, m≤2⌈nk⌉ . Assuming that the length of the first segment is r1−l1+1=O(k) , the time complexity is O(nlogk+mk)=O(nlogk) .

Finally, we need to calculate the solution for all possible m and take the min as the final answer. After pruning the first edge, if the optimal solution requires cutting off m′ edges, similar to the previous proof, other solutions can be adjusted to satisfy |m−m′|≤1 and the total cost does not increase.

Code

Codeforces Round #881 (Div. 3) Editorial

By Sokol080808, history, 16 hours ago, translation, In English 1843A - Sasha and Array Coloring

Idea: EJIC_B_KEDAX, prepared: molney

Tutorial 1843A - Sasha and Array Coloring First, there exists an optimal answer, in which there are no more than two elements of each color.

Proof: let there exist an optimal answer, in which there are more elements of some color than 2. Then, take the median among the elements of this color and paint in another new color in which no other elements are painted. Then the maximum and minimum among the original color will not change, and in the new color the answer is 0, so the answer remains the same.

Also, if there are two colors with one element each, they can be combined into one, and the answer will not decrease.

It turns out that the numbers are paired (probably except for one; we'll assume it's paired with itself). Sort the array, and then the answer is ∑pairi<iai−∑i<pairiai (pairi is the number that is paired with i -th). Therefore, in the first summand you should take ⌊n2⌋ the largest, and in the second ⌊n2⌋ of the smallest elements of the array.

Total complexity: O(nlogn) for sorting.

Solution Rate the problem 1843B - Long Long

Idea: EJIC_B_KEDAX, prepared: molney

Tutorial 1843B - Long Long We can delete all zeros from the array, and it won't affect on answer.

Maximum sum is ∑ni=1|ai| . Minimum number of operations we should do — number of continuous subsequences with negative values of elements.

Total complexity: O(n) Solution Rate the problem 1843C - Sum in Binary Tree

Idea: Sokol080808, prepared: molney

Tutorial 1843C - Sum in Binary Tree It is easy to notice that the children of the vertex with number u have numbers 2⋅u and 2⋅u+1 . So, the ancestor of the vertex u has the number ⌊u2⌋ . Note that based on this formula, the size of the path from the root to the vertex with number n equals ⌊log2n⌋ . Therefore with given constraints we can write out the path to the root explicitly and calculate the sum of vertex numbers on it in O(logn) .

Total complexity: O(logn) for the test case.

Solution Rate the problem 1843D - Apple Tree

Idea: EJIC_B_KEDAX, prepared: Vladosiya

Tutorial 1843D - Apple Tree Let cntv be the number of vertices from which an apple can fall if it is in the vertex v . Then the answer to the query is cntv⋅cntu .

Note that the value of cntv is equal to the number of leaves in the subtree of vertex v . Then, these values can be computed using the DFS or BFS. The value cnt for a vertex will be equal to 1 if this vertex is a leaf, otherwise it will be equal to the sum of these values for all children of the vertex.

Total complexity: O(n+q) .

Solution Rate the problem 1843E - Tracking Segments

Idea: meowcneil, prepared: meowcneil

Tutorial 1843E - Tracking Segments Let's use a binary search for an answer. It will work, because if some segment was good, then after one more change it will not be no longer good, and if all segments were bad, then if you remove the last change, they will remain bad.

To check if there is a good segment for the prefix of changes, you can build the array obtained after these changes, and then count the prefix sums in O(n) . After that, you can go through all the segments and check for O(1) for a segment whether it is a good or not.

Total complexity: O((n+m)⋅logq) .

Solution Rate the problem 1843F1 - Omsk Metro (simple version)

Idea: EJIC_B_KEDAX, prepared: Sokol080808

Tutorial 1843F1 - Omsk Metro (simple version) Let mx be the maximal sum on the path subsegment, mn — the minimal sum on the path subsegment. Then it is said that a subsegment with sum x exists if and only if mn≤x≤mx .

Proof: Let us fix the subsegment with the minimum sum and the subsegment with the maximum sum. Now, we want to go from the first segment to the second one by consecutively removing or adding elements from the ends of the segment. Note that, due to the fact that x∈{−1,1} , for each such action, the sum on the segment will change by exactly 1 . In other words, no matter how we go from one segment to another, the sum will remain a discretely continuous value. Then, since this function takes values of the minimum and maximum sum, it also takes all values from the segment between them (by the intermediate value theorem). Thus, the set of all possible sums on the subsegments is the interval of integers between the minimum and maximum sum, from which the original assumption follows.

Now, we have turned the problem down to finding the subsegment with the minimum and maximum sum on the path in the tree. Let mxu be the maximum sum on the subsegment on the path from 1 to u , sufu — the maximum sum on the suffix of the path from 1 to u , pu — the ancestor of vertex u , xu — its weight. Then sufu=max(0,sufpu+xu) , mxu=max(mxpu,sufu) . Thus, we have learned to calculate the necessary values for a vertex immediately at the moment of its addition, which allows us to solve the problem online (but it is not required in the problem itself). The values for the minimum are counted in the same way.

Total complexity: O(n) .

Solution Rate the problem 1843F2 - Omsk Metro (hard version)

Idea: EJIC_B_KEDAX, prepared: Sokol080808

Tutorial 1843F2 - Omsk Metro (hard version) Like in F1 we should find maximum and minimum sum on subsegment on path. Let's use binary liftings. For each jump store maximum sum on prefix, suffix, subsegment and sum of segment as in problem finding maximum sum on subsegment in array. Same for minimum. For more details, read code.

Total complexity: O((n+q)⋅log(n)) Solution Rate the problem Tutorial of Codeforces Round 881 (Div. 3)

Codeforces Round 880 Editorial

By Anadi, history, 2 hours ago, In English 1836A - Destroyer

Author: kempusss Developer: kempusss First solve: Dauzhen Tutorial 1836A - Destroyer We can simplify the statement to the following — can we divide the input sequence into multiple arithmetic sequences starting with 0 and a common difference equal to 1 ?

Note that for each such arithmetic sequence, if a number x>0 belongs to it, then x−1 must also be included in it. Thus, if we denote cntx as the number of occurrences of x in the input, we must have cntx≥cntx+1 for each x≥0 . We can note that if such a condition is fulfilled, we can always divide the input into described arithmetic sequences.

We can implement it straightforwardly in O(N+L) , where L is the maximum value in the input.

Solution 1836B - Astrophysicists

Author: Fly_37 Developer: Okrut First solve: NTR_Lover Tutorial 1836B - Astrophysicists Note that in the perfect world, we'd give each astrophysicist precisely ⌊G−12⌋ , and we'd spare N⋅⌊G−12⌋ silver coins. Unfortunately, two things may happen:

First, we may run out of money. This is an easy case; it is enough to output K⋅G if it is less than ⌊G−12⌋ . Second, we may have some money left. It turns out that an acceptable solution is to give everything to one astrophysicist. The intuition behind it is simple — we are only interested in bonus sizes modulo G , and by decreasing the bonus of one astrophysicist, we can get at most 1 from another one, and by increasing it, we lose ⌊G−12⌋ . In both cases, it is not worth changing the value. Thus, we got a formula to calculate in O(1) .

Solution 1836C - k-th equality / 1835A - k-th equality

Author: Okrut Developer: w0nsh First solve: NTR_Lover / ksun48 Tutorial 1836C - k-th equality The largest possible value for a is 106−1 , so we can iterate over each possibility. When we fix a , we can find the range of values for b such that 10C−1≤a+b<10C , and 10B−1≤b<10B . For each such value, we have a correct equality.

We can easily find this range. We get that max{10C−1−a,10B−1}≤b<max{10C−a,10B} and from this inequality, we know how many equations for the given a we have. As we start by minimizing a , we can find its value for the k -th equation if we iterate from the smallest possible values of a .

When we have fixed a (or find out that there is no such equation), we iterate over all possible values of b and check if the resulting c has C digits. The complexity is O(10A+10B) .

Solution 1836D - Lottery / 1835B - Lottery

Author: Arti1990 Developer: Arti1990 First solve: Rotting / ecnerwala Tutorial 1836D - Lottery Tutorial is not available

Solution 1836E - Twin Clusters / 1835C - Twin Clusters

Author: Anadi, w0nsh Developer: Fly_37 First solve: GULAL_S_ZHENOY_UMNIKA / Um_nik Tutorial 1836E - Twin Clusters Deterministic solution:

Let us first look for segments that zeros first k (out of 2k ) bits. Since we have n=2k+1 , then we have n+1 prefix xors of the array (along with en empty prefix). Let us look at the xor prefix modulo 2k . Each time we have a prefix xor that has already occurred before let us match it with this previous occurrence. We will find at least 2k+1 such segments. Note that segments have pairwise different ends and pairwise different beginnings.

Each of those segments generates some kind of xor value on the other k bits. Since there is only 2k different possible values, due to pigeon principle there will be two segments that generate same xor. We select those two intervals. If they are disjoint then we already found the answer. Otherwise the final answer will be the xor of those two segments (values that are covered only by one of them). It can be showed that we will obtain two disjoint, non-empty segments.

Nondeterministic solution:

If there are any duplicates in the array, then we can take two one-element arrays and obtain answer. From now on we will assume that no duplicates occur in the array.

Let us observe that number of valid segments is equal to (n2)+n≥22k+1 which is over twice larger than all possible xor values for a segment which is 22k . This suggest, that chances of collision of two random segments is quite high. For simplicity let us assume there is exactly 22k+1 segments. Let us look at the final distribution over the xors used by segments. It can be showed by exchange argument, that the the distribution that needs the most random tosses to obtain collision is the one in which every xor value is used by exactly two segments. Since we choose segments randomly, by birthday paradox the expected time of obtaining a collision is around 2^k. Now there is a chance, that we will toss the same segment twice, but if we multiply the number of tossing by log(n) then chance that we find two different segments is very high (in reality even less random choices are necessary).

There is another issue, even if we find two different segments with the same xor values. They can use common elements. But then we can simply take only the elements that belong to the exactly one of them.

Still if the segments had common end one of the obtained segments would be empty. To omit this issue let us see that the second obtained segment would have xor equal to 0 . So now we can take any prefix and corresponding suffix as an answer. Unfortunately this segment can have length 1 . But in this case the only element in the segment has to be equal to 0 .

There must be at most one number 0 in the array, so we can simply get rid of it (shorten the array by one). The analysis still holds (with some slight modifications).

Solution 1836F - Doctor's Brown Hypothesis / 1835D - Doctor's Brown Hypothesis

Author: Okrut Developer: Okrut First solve: None / ksun48 Tutorial 1836F - Doctor's Brown Hypothesis As both vertices must visit each other, they must be in the same strongly connected component. We can compute all SCC and solve for them independently. Further, we will assume that we are solving for a fixed SCC.

The critical observation is that n3 is enormous, and we can visit an entire graph. This gives us hope that if we fix a vertex v , we can represent all vertices that are reachable from it.

If we compute the greatest common divisor of all cycles in our graph g , then all paths from a fixed vertex s to a vertex t have the same remainder modulo g . Moreover, we can always find such if we are looking for a long enough path and the correct remainder. It turns out that n3 is a large enough bound for such paths.

Now we have to find the greatest common divisor of all cycles in the graph. There are many ways (including linear), but we are going to present O(nlogn) here. First, find any cycle in the graph. As g has to divide it, we just have to consider its divisors.

We'll develop a quick way to find if a divisor d divides g . To do this, we check if there is a colouring with colours from 0 to d−1 , such that for every edge ⟨u,v⟩ , colour(v)=(colour(u)+1)modd . We can check for such colouring with a simple DFS in a linear time.

To obtain the right complexity, we'll only check prime divisors (and their powers, and take the least common multiple of the ones which divide g .

Now we have to find all pairs ⟨s,t⟩ such that there are paths from s to t and from t to s of length k . We have two cases. Either g|k and colour(s)=colour(t) or 2|g and k=g/2modg and colour(s)=(colour(t)+g/2)modg . After preprocessing, we can check both cases in O(g) time.

The final complexity is O(nlogn) or O(n) depending on the implementation.

Solution 1835E - Old Mobile

Author: Fly_37 Developer: maras First solve: tourist Tutorial 1835E - Old Mobile Let us make some observations. First of them is that if a phone number consists of two or more digits of the same kind then we will always pay exactly 1 click for each but the first occurrence of it (it follows from the fact, that we have to already the key responsible for this digit). This is why we can reduce the problem to finding a solution for a phone number with unique digits.

Secondly, since all the buttons are indistinguishable at the beginning then the order of digits in the input does not matter.

This leads to the conclusion that what we want to compute is some kind of dp[i][j] , which stands for expected time of completing number if i buttons that we have to eventually click are not yet discovered (good buttons), and j buttons that we don't need are also not yet discovered (bad buttons). Unfortunately the BackSpace key and necessity of clearing incorrect prefix of the phone number complicates things significantly.

We will create additional dimension of the dp responsible for the state of the prefix and the information about if we have already clicked backspace. Those four states will be:

EMPTY – empty prefix of digits on the screen GOOD – non empty, correct prefix of digits on the screen BAD – non empty prefix that is not prefix of the phone number BACKSPACE – when we have already found a backspace (we assume prefix is correct, or in other words paid in advance) Let us first compute dp[i][j][BACKSPACE] . If i=0 then dp[0][j][BACKSPACE]=0 . Else we try to click new buttons. If we guess correctly exactly the next button then we get dp[i][j][BACKSPACE]=1+dp[i−1][j][BACKSPACE] . Otherwise we could guess one of the remaining good buttons (with probability i−1i+j . Since we already know backspace location, we can remove it and in future we will pay only 1 for this digit. We hence get 3+dp[i−1][j][BACKSPACE] operations. Similarly if we guess bad button we get dp[i][j][BACKSPACE]=2+dp[i][j−1][BACKSPACE] .

Rest of the states can be computed using similar approach: dp[i][j][GOOD]=⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪0,1+dp[i−1][j][GOOD],3+dp[i−1][j][BAD],2+dp[i][j−1][BAD],2+dp[i][j][BACKSPACE],if i=0when tossing exactly correct digitfor one of the remaining good digits(in future we will have to remove it and use in correct place)for guessing bad digitwhen clicking backspace button(removing good digit from the prefix which we need to fix) dp[i][j][BAD]=⎧⎩⎨⎪⎪⎪⎪⎪⎪3+dp[i−1][j][BAD],2+dp[i][j−1][BAD],dp[i][j][BACKSPACE],when guessing any good digitfor bad digitwhen clicking backspace(this click was paid in advance) dp[i][j][EMPTY]=⎧⎩⎨⎪⎪⎪⎪⎪⎪1+dp[i−1][j][GOOD],3+dp[i−1][j][BAD],2+dp[i][j−1][BAD],1+dp[i][j][BACKSPACE],when tossing correct digitwhen guessing other good digitfor bad digitwhen clicking backspace Even though transitions may look scary, they are similar for different dimensions and common implementation can be used.

Solution 1835F - Good Graph

Author: Anadi Developer: Arti1990 First solve: rainboy Tutorial 1835F - Good Graph According to Hall's theorem, a graph is good if and only if a perfect matching exists. We run any reasonable algorithm to find a perfect matching (e.g. the Hopcroft-Karp's algorithm). We call the found matching M (any perfect matching is fine).

We look for a counterexample if we do not find a perfect matching. One way to find it is to run s similar DFS as in the Hopcroft-Karp algorithm from any unmatched vertex on the left side. As a reminder, we visit all neighbours of vertices on the left side and only the vertex with which we are matched for vertices on the right side. As we won't see any unmatched vertex on the right side (otherwise, we'd found an augmenting path), the set of visited vertices on the left side has fewer neighbours than its size — we found our counterexample.

As our graph is good, we should examine the construction of tight sets.

Lemma 1

Function N(S) is submodular.

Proof

Consider two sets A⊆B and a vertex v∉B . For each vertex u∈N(B+v)∖N(B) , we know that u∈N(A+v) and u∉N(A) , thus, u∈N(A+v)∖N(A) . We conclude that |N(B+v)∖N(B)|≤|N(A+v)∖N(A)| ; thus, the function is submodular.

Lemma 2

Tight sets are closed under intersection and sum.

Proof

Consider two tight sets, A and B . From Lemma 1, we get that |A|+|B|=|N(A)|+|N(B)|≥|N(A∪B)|+|N(A∩B)|≥|A∪B|+|A∩B|=|A|+|B| , where the last inequality results from the graph being good. As we get the same value on both sides, all inequalities become equalities. In particular, with the graph being good, we get that |N(A∪B)|=|A∪B| and |N(A∩B)|=|A∩B| . That proves that sets A∪B , and A∩B are tight.

We define T(v) as the minimal tight set containing vertex v . We know such a set exists as tight sets are closed under the intersection. From that, we can conclude that any tight set can be represented as a sum of minimal tight sets. Thus, we are only interested in keeping the same minimal tight sets. We can find the minimal tight sets using the same DFS algorithm as for finding a counterexample. As the graph is large, use bitsets to optimise it.

To find the smallest graph, we analyse these sets in order of nondecreasing sizes. For simplicity, we erase duplicates. When we analyse the set, we distinguish the new vertices (the ones that haven't been touched yet). There is always a new vertex, as this is the minimal tight set for at least one vertex (and we removed duplicates). If there is only one new vertex v , we can add an edge from v to M(v) . Otherwise, we have to connect these vertices v1,v2,…,vk into a cycle — we create edges ⟨v1,M(v1)⟩,⟨M(v1),v2,⟩…,⟨vk,M(vk)⟩,⟨M(vk),v1⟩ . If we have less than 2⋅k edges, then there exists a vertex vi with a degree equal to 1 — we could pick this vertex, and it'd create a minimal tight set.

We still have to handle other vertices in this (i.e. the ones which are not new). We pick a representative v for our cycle, which will become a representative for this set. Similarly, we have a representative for other sets. We find a partition of these vertices into a minimal number of tight sets. We add an edge between these representatives and our vertex v . We use a similar argument as before — if we didn't add this edge, we would find different minimal tight sets. To handle representatives, we use a disjoint set union structure.

The final complexity of this algorithm is O(N3/64) .

Solution Tutorial of Codeforces Round 880 (Div. 1) Tutorial of Codeforces Round 880 (Div. 2)

Codeforces Round #879 Editorial

By Ormlis, history, 5 hours ago, translation, In English Thank you for participating!

1834A - Unit Array was authored and prepared by Artyom123

1834B - Maximum Strength was authored by jury of the olympiad, and prepared by TheEvilBird

1834C - Game with Reversing was authored and prepared by sevlll777

1834D - Survey in Class was authored by vaaven and MIKHANGO and prepared by Alexdat2000

1834E - MEX of LCM was authored by TeaTime and prepared by teraqqq

1834F - Typewriter was authored and prepared by Ziware

1834A - Unit Array First, let's make the sum of the array elements ≥0 . To do this, we just need to change some −1 to 1 . The number of such replacements can be calculated using a formula or explicitly simulated.

After that, there are two possible situations: either the product of all elements is equal to 1 , or the product of all elements is equal to −1 . In the first case, we don't need to do anything else. In the second case, we need to replace one more −1 with 1 (note that in this case the sum will remain ≥0 ).

1834B - Maximum Strength Let's add leading zeros to L if necessary. Now we can represent the numbers L and R as their longest common prefix, the digit k at which the values differ, and the remaining digits. After digit k , any digits can be placed, so it is advantageous to put 9 in one number and 0 in the other. Then the answer is equal to (rk−lk)+9⋅(n−k) . For example, it is achieved with numbers A=l1l2…lk99…9n−k¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ and B=r1r2…rk00…0n−k¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ .

1834C - Game with Reversing Let's show that the specific choice of a turn by Bob (which of the strings to reverse) does not affect Alice's strategy and therefore the answer to the problem.

Reversing the string twice does not change anything → we are only interested in the parity of the number of reverses for both strings.

If Bob made an even number of moves in total, then the parity of the number of moves made by Bob with string s coincides with the parity of the number of moves made by Bob with string t→ pairs of characters at the same indices, after all reverses, will be (s1,t1),(s2,t2),…,(sn,tn) , possibly in reverse order, but it doesn't matter. Here s1,…,sn and t1,…,tn are the original indices of the strings, which do not change with reversing.

If Bob made an odd number of moves, then exactly one of the strings will be reversed, and the pairs of characters in the same indices will be: (s1,tn),(s2,tn−1),…,(sn,t1) (or in reverse order).

That is, the specific pairs of corresponding characters are determined only by the parity of the total number of moves made by Bob, and it does not matter which specific moves were made.

Therefore, Alice can choose one of two strategies:

Make s1=t1,s2=t2,…,sn=tn , and fix the end of the game when the number of moves made by Bob is even. Make s1=tn,s2=tn−1,…,sn=t1 , and fix the end of the game when the number of moves made by Bob is odd. Let's count cnt — the number of indices where s and t differ, and cntrev — the number of indices where s and rev(t) differ.

For the first strategy, Alice must make at least cnt moves herself, and it is also necessary that the number of moves made by Bob is even → it is easy to see that for this strategy the game will last 2⋅cnt−cnt%2 moves.

For the second strategy, everything is roughly similar: the game will last 2⋅cntrev−(1−cntrev%2) moves, but the case cntrev=0 needs to be handled separately.

And the answer to the problem will be the minimum of these two values. Asymptotic: O(n) .

1834D - Survey in Class Let's fix the students who will end up with the highest and lowest hands. Then, to maximize the difference, we can ask all the topics that the student with the highest hand knows. Then the second student will raise his hand for each topic in the intersection of their segments, and lower for each topic that only the first student knows. That is, the problem is to find 2 segments a and b such that the value of |a|−|a|∩b| is maximal, since the answer is 2⋅(|a|−|a∩b|) .

The segment b can intersect the segment a in four ways: intersect the beginning of a , intersect the end of a , be completely inside a , or not intersect it at all. So, if in the answer segment b intersects the beginning of a , then you can choose the segment with the minimal right end as the segment b — the intersection of such a segment with a will be no greater than the intersection of b with a . Similarly, for the right end, you can select the segment with the maximal left end. If the answer has one segment in another, then you can consider the shortest segment in the set as the inner segment. If the segments in the answer do not intersect, then the segment does not intersect one of the "edge" segments.

Thus, to find the segment with which it has the minimum intersection for a given segment, you need to check 3 candidates: the shortest segment in the set, the segment with the minimal right end, and the one with the maximal left end. In total, to find the answer, you need to check 3n pairs of segments.

1834E - MEX of LCM Notice that the MEX of n2 numbers will not exceed n2+1 . Let's calculate all possible LCM values on segments that do not exceed n2 . To do this, we will iterate over the right endpoint of the segments and maintain a set of different LCM values on segments with such a right endpoint.

Let these values be x1<x2<…<xk . Then k≤1+2log2n , indeed, for each 1≤i<k , it is true that xi+1 is divisible by xi , and therefore xi+1≥2xi , that is, n2≥x2≥2k−1 , from which the required follows. That is, the values x1,…,xk can be stored naively in some dynamic array. Now suppose we want to move the right endpoint, then the array (x1,…,xk) should be replaced by ([x1,ar],…,[xk,ak],ak) and remove values greater than n2+1 from the new array, as well as get rid of duplicates.

All these actions can be performed in O(nlogn) time, after which we just need to find the MEX among the known set of values. This solution can also serve as proof that the desired MEX does not exceed n⋅(1+2log2n) , which is less than 109 under the constraints of the problem. Thus, initially, we can only maintain numbers less than 109 and not worry about overflows of a 64-bit integer type.

1834F - Typewriter Let's solve the problem if there are no requests. The key object for us will be such cells that the number in them is less than the cell index. Note that for one carriage reset, we can transfer no more than one such number. So we have a lower bound on the answer.

Let's build a graph with edges i→a[i] . Then it will break up into cycles. Let's find the first position where a[i]≠i , take a number from this position, shift it to a[i] , take a number from position a[i] , and so on. Then we will put the whole cycle in its place. How many carriage drops will there be? Exactly as many edges as there are such that a[i]<i . That is, the answer is exactly equal to the number of positions where a[i]<i .

Let's learn how to solve for shifts. Let's find for each cell such positions of the beginning of the array that it will satisfy a[i]<i in this configuration. It is easy to see that for a particular cell, such indexes will form a segment (possibly a prefix + suffix). Let's create a separate array and add one on these segments. Then in the i-th position there will be an answer if the array starts from the i-th cell.

Now let's solve for an array flip. It is easy to see that for this you can simply maintain the entire previous structure, but with the inverted original configuration of cells. Asymptotic: O(n+q) .

Tutorial of Codeforces Round 879 (Div. 2)

Codeforces Round #878 (Div.3) Editorial

By diskoteka, 37 minutes ago, translation, In English 1840A - Cipher Shifer

Idea: isosto, preparation: isosto

Tutorial 1840A - Cipher Shifer Note that during encryption, only characters different from c are added after the character c . However, when the character c is encrypted with different characters, another c character is added to the string.

This means that for decryption, we only need to read the characters of the string after c until we find the first character equal to c . It signals the end of the block of characters that will be converted to the character c during decryption.

To decrypt the entire string, we decrypt the first character s1 . Let the next occurrence of the character s1 be at position pos1 . Then the next character of the original string is spos1+1 . We apply the same algorithm to find the next paired character and so on.

Solution Rate the problem 1840B - Binary Cafe

Idea: diskoteka, preparation: diskoteka

Tutorial 1840B - Binary Cafe On the one hand, if Tema had an infinite number of coins, he could buy any set of desserts offered in the coffee shop. This can be done in 2k ways, since each of the desserts can either be taken or not taken.

On the other hand, if the coffee shop offered an infinite number of desserts for tasting, Tema could spend any amount of coins he has - from 0 to n . Each number of coins corresponds to its unique set of desserts, since any number 0≤k≤n is uniquely represented as a sum of powers of two.

Combining these two observations, we get the final answer - min(2k,n+1) .

Solution Rate the problem 1840C - Ski Resort

Idea: pavlekn, preparation: playerr17

Tutorial 1840C - Ski Resort To simplify the task, let's replace all numbers in the array a . If the value of ai is greater than q , then replace it with 0 . Otherwise, replace it with 1 .

Now Dima can go on this day if ai=1 . Therefore, we need to consider segments consisting only of 1 .

Note that if the segment consists of less than k ones, then Dima will not be able to go on these dates, so the segment can be ignored.

For all remaining segments, we need to calculate the number of ways for Dima to choose travel dates on this segment. And for a segment of length l , the number of ways to choose a trip of at least length k is (l−k+2l−k) .

The answer to the problem will be the sum of the number of ways to choose travel dates for all segments.

Solution Rate the problem 1840D - Wooden Toy Festival

Idea: diskoteka, preparation: diskoteka

Tutorial 1840D - Wooden Toy Festival Let the carvers choose patterns x1 , x2 , x3 for preparation. For definiteness, let us assume that x1≤x2≤x3 , otherwise we will renumber the carvers.

When a person comes to the workshop with a request to make a toy of pattern p , the best solution is to give his order to the carver for whom |xi−p| is minimal.

It follows that the first cutter will take orders for toys with patterns from 1 to x1+x22 , the second - for toys with patterns from x1+x22 to x2+x32 , the third - for toys with patterns from x2+x32 to 109 . Therefore, if you look at the sorted array of patterns a , the first carver will make some prefix of toys, the third will make some suffix, and the remaining toys will be made by the second carver.

Then the answer can be found by binary search. To check if the time t is suitable, you need to give the maximum prefix of toys to the first carver and the maximum suffix of toys to the third carver, and then check that the patterns of the remaining toys are within a segment of length 2⋅t . The maximum prefix and maximum suffix can be found with a O(n) pass through the array a .

Solution Rate the problem 1840E - Character Blocking

Idea: diskoteka, preparation: diskoteka

Tutorial 1840E - Character Blocking Two strings are equal if and only if there is no position pos such that the characters at position pos are not blocked and s1[pos]≠s2[pos] (we will call such a position bad). We will use this observation to maintain the current number of bad positions, denoted by cnt .

Let Ipos be an indicator variable. Ipos=1 if position pos is bad, otherwise Ipos=0 .

During an operation (blocking or swapping), we only need to subtract the indicator variables of all positions affected by the operation from cnt . There will be O(1) of them. Then, we modify the string according to the operation and add new indicator variables to cnt .

To correctly handle blocking queries, or more precisely, to unblock positions in time, we will use a queue. After each blocking query, we will add a pair of numbers to the queue. The first number of the pair is the position to unblock, and the second number is the time to unblock. Now, before each operation, we will unblock positions by looking at the head of the queue.

Solution Rate the problem 1840F - Railguns

Idea: diskoteka, preparation: diskoteka

Tutorial 1840F - Railguns Let's first solve it in O(nmt) .

This can be done using dynamic programming. dp[i][j][k]=true if the character can be at coordinates (i,j) at time t , otherwise dp[i][j][k]=false . Such dynamics can be easily recalculated: dp[i][j][k]=dp[i−1][j][k−1]|dp[i][j−1][k−1]|dp[i][j][k−1] . If the cell is shot by one of the railguns at time t , then dp[i][j][k]=false .

Now let's notice that if the character can reach the final point (n,m) , then he will have to stand still no more than r times. To prove this, we can prove another statement: if the character can reach the final point along some trajectory, then for any such trajectory the character can stand still no more than r times. And this statement can already be proven by mathematical induction.

Thus, instead of the dp[n][m][t] dynamics, we can calculate the dp[n][m][r] dynamics, where the third parameter is the number of times the character stood still. The transitions here are made similarly.

Solution Rate the problem 1840G1 - In Search of Truth (Easy Version)

Idea: pavlekn, preparation: pavlekn

Tutorial 1840G1 - In Search of Truth (Easy Version) Let a1,a2,…,an be the numbers of the sectors in clockwise order, and let the arrow initially point to the sector with number a1 .

First, let's make 999 queries of "+ 1", then we will know the numbers of 1000 consecutive sectors. If n<1000 , then the number of the first query that gives the answer a1 is the desired n .

If we did not find n , this means that n≥1000 . Let's save a1,a2,…,a1000 . Now we will make queries of "+ 1000" until we get one of the numbers a1,a2,…,a1000 as the answer. Note that we will need no more than 1000 queries of this type, after which it is easy to determine the number n .

Thus, we can determine the number n in no more than 999+1000=1999≤2023 queries.

Solution Rate the problem 1840G2 - In Search of Truth (Hard Version)

Idea: pavlekn, preparation: pavlekn

Tutorial 1840G2 - In Search of Truth (Hard Version) Let's sample n by making k random queries "+ x" where we pick x each time randomly between 1 and 106 and get k random integers n1,n2,…,nk in the range [1,n] as the answers to the queries. Then, we can sample n with n0=max(n1,n2,…,nk) . Now, we can assume that n0≤n≤n0+d for some integer d . Let's talk about picking the right d a bit later.

Now we can perform an algorithm similar to G1 solution and determine n within 2⋅d−−√ queries.

So, we have 1000 queries in total, meaning that 2⋅d−−√+k is approximately equals to 1000 . Thus, for each k we can find optimal d=1000−k2 , the probability that n is not in the range [n0,n0+d] does not exceed (n−dn)k which is less than 8.5⋅10−18 for k=320 and for each 1≤n≤106 .

Therefore, by picking k somewhere between 300 and 400 , we can get a solution which passes a testcase with probability of p≥1−10−16 .

Solution Rate the problem Tutorial of Codeforces Round 878 (Div. 3)

Codeforces Round #877 (Div. 2) Editorial

By jdurie, history, 75 minutes ago, In English 1838A - Blackboard List

Solution 1838A - Blackboard List Note that any negative integers on the board must have been one of the original two numbers, because the absolute difference between any two numbers is nonnegative.

So, if there are any negative numbers, print one of those.

If there are only nonnegative integers, note that the maximum number remains the same after performing an operation, because for nonnegative integers a , b , where a≤b , we have |a−b|=b−a≤b Therefore, in this case, the maximum number in the list must be one of the original numbers.

Complexity: O(n) Code 1838B - Minimize Permutation Subarrays

Solution 1838B - Minimize Permutation Subarrays Let idxx be the position of the element x in p , and consider what happens if idxn is in between idx1 and idx2 . Notice that any subarray of size greater than 1 that is a permutation must contain idx1 and idx2 . So it must also contain every index in between, including idxn . Therefore, n is an element of the permutation subarray, so it must be of size at least n , and therefore must be the whole array.

Therefore, if idxn is in between idx1 and idx2 , the only subarrays that are permutations are [idx1,idx1] and [1,n] . These two subarrays will always be permutations, so this is minimal.

To achieve this, we have 3 cases:

If idxn lies in between idx1 and idx2 , swap idx1 and idx2 . If idxn<idx1,idx2 , swap idxn with the smaller of idx1 , idx2 . If idxn>idx1,idx2 , swap idxn with the larger of idx1 , idx2 . In all three of these cases, after the swap, idxn will lie in between idx1 and idx2 , minimizing the number of permutation subarrays.

Complexity: O(n) Code 1838C - No Prime Differences

Solution 1838C - No Prime Differences Note that if we fill in the numbers in order from the top left to the bottom right, for example, for n=5 , m=7 ,

the only adjacent differences are 1 and m . So if m is not prime, this solves the problem. We'll now rearrange the rows so that it works regardless of whether m is prime. Put the first ⌊n2⌋ rows in rows 2 , 4 , 6 , ... and the last ⌈n2⌉ rows in rows 1 , 3 , 5 , .... In the example above, this would give

Note that because we are just rearranging the rows from the above solution, all of the horizontal differences are 1 , and the vertical differences are multiples of m≥4 . Therefore, as long as none of the vertical differences equal m itself, they must be composite.

Because n≥4 , no row is next to either of its original neighbors in this ordering, and therefore all vertical differences are greater than m , and thus composite.

So we can use this final grid regardless of whether m is prime.

Complexity: O(nm) Code 1838D - Bracket Walk

Solution 1838D - Bracket Walk For a string to be walkable, we need n to be even, because the parity of the balance factor changes on each move, and it has to be zero at the end of the process. So if n is odd, the string is never walkable.

Now, consider the set A that contains all indices i (1 -indexed) satisfying one of the below conditions:

i is even and si= '(' i is odd and si= ')' Now, consider a few cases:

If A is empty, then s is of the form ()()()(), and is therefore trivially walkable by just moving to the right.

If min(A) is odd, then s is of the form ()()()).... We can show that it is never walkable, because for every ')' in the first section ()()(), when we land on this ')' (before leaving this section of the string for the first time), the balance factor must be 0 . Therefore, when we try to move across the "))", the balance factor will go to −1 , and the walk will no longer be valid.

If max(A) is even, then s is of the form ....(()()(), and we can show that it is never walkable using a somewhat symmetric argument to the previous case, but considering the ending of the walk instead of the beginning.

Otherwise, min(A) is even and max(A) is odd. We will prove that it is walkable. In this case, s is of the form ()()()((....))()(). To form a valid walk, keep moving to the right until you hit the "((", then alternate back and forth on the "((" 1018 times. After this, move to the right until you hit the "))". Note that during this process, the balance factor can never go negative, because it will always be at least 1018−n . Once you reach the "))", alternate back and forth on it until the balance factor hits 0 . Because n is even, this will happen on the rightmost character of the "))". At this point, just walk to the right until you hit the end, at which point the balance factor will once again be 0 .

So we just need to maintain the set A across all of the queries, and do these simple checks after each query to see if s is walkable.

Complexity: O((n+q)logn) Code 1838E - Count Supersequences

Solution 1838E - Count Supersequences Let's first consider a DP solution. Let dpi,j be the number of arrays of length i , such that the longest prefix of a that appears as a subsequence of the array is of length j .

To compute this DP, consider some cases. Let b′ be the subarray of the first i elements of b , and a′ be the subarray of the first j elements of a .

Every subsequence of b′ that equals a′ includes position i of b′ : In this case, position i must be part of the subsequence. This gives us dpi−1,j−1 solutions. At least one subsequence of b′ that equals a′ doesn't include position i , and j<n : In this case, the value in position i can be anything except for aj+1 , because that would create a subsequence of length j+1 . So this gives us (k−1)dpi−1,j solutions. At least one subsequence of b′ that equals a′ doesn't include position i , and j=n : This is the same as the previous case, except we don't have a "next" element to worry about, so anything can go in position i , and there are k⋅dpi−1,j solutions. So the final equation for the DP comes out to

dpi,j={dpi−1,j−1+(k−1)dpi−1,jdpi−1,j−1+k⋅dpi−1,jj<nj=n This would be O(nm) to compute, so it will TLE. However, we can notice that the DP does not depend on a ! This means we can change the ai values to anything we want, and it won't change the answer. To simplify the problem, let all ai=1 . Now, the problem becomes, how many arrays of size m , consisting of the values [1,k] , contain at least n ones?

To compute this, let's find the number of arrays of size m that contain less than n ones, and subtract it from km , the total number of arrays. There are (mi)(k−1)m−i arrays that contain exactly i ones, so the answer is

km−∑i=0n−1(mi)(k−1)m−i We use fast exponentiation to compute the powers of k−1 , and to compute the (mi) values, we use the fact that (m0)=1 and for i≥1 ,

(mi)=m(m−1)…(m−i+1)i(i−1)…1=m−i+1i(mi−1) So we can compute the first n (mi) values within the time limit.

Complexity: O(nlogM) where M=109+7 .

Code 1838F - Stuck Conveyor

Solution 1838F - Stuck Conveyor The key to our solution will be these two "snake" configurations:

We will initially query the first snake with the box on the top left, and the second snake with the box on the bottom left (or bottom right, depending on parity of n ).

Note that these two snakes, with the box on the given starting positions, each form a single path such that the box visits all squares, and the second snake visits squares in the reverse order of the first.

Now, consider some cases.

If the stuck conveyor belt directs items to an empty square, then for both of the above configurations, the box will end up in that empty square. This cannot be the "intended" behavior for both of them, because the intended behavior for both of them is different. So in one snake, we will know that this is unintended behavior. Because each possible empty square is only adjacent to one belt, we know exactly which belt must have sent it there, and therefore which one is broken.

If the stuck conveyor belt directs items to another belt, number the conveyor belts from 1 to n2 in the order they are visited by the first snake, and consider two subcases:

If the other belt has a lower number than the stuck belt, then the box will enter an infinite loop for the first snake query, and will terminate for the second snake query. Since the opposite will happen in the other case, this allows us to distinguish these two subcases. Consider what happens if we ask the first snake query again, but place the box on belt i instead of belt 1 . Assume the stuck belt is belt j . Because the stuck belt directs items to a belt with smaller number, if i≤j , the box will hit the stuck belt, and enter an infinite loop. If i>j , the box will never encounter the stuck belt, so it will eventually reach the end of the snake and stop moving.

So with one query, by checking whether the box enters an infinite loop, we can determine whether i≤j or i>j . This allows us to binary search for j in log(n2) queries.

The case where the other belt has a higher number than the stuck belt is analogous, using the second snake query rather than the first. So now, in all cases, we know which of the n2 belts is stuck. In order to determine the direction in which it is stuck, we use one more query. Place the box on the stuck conveyor, and direct all belts in the same row or column as the stuck belt away from it (all other belts can be directed arbitrarily). Here is one example for n=4 where the stuck belt is (2,2) :

So we will get a different final position for the box for each of the four directions in which it could be stuck, and can recover the direction.

The total number of queries for these steps is bounded by 2+log(n2)+1 . Since n≤100 , this is at most 17 .

Complexity: O(n2log(n2)) Code Tutorial of Codeforces Round 877 (Div. 2)

Codeforces Round #876 (Div. 2) Editorial

By valerikk, history, 57 minutes ago, In English 1839A - The Good Array

Hint Hint Solution 1839A - The Good Array Let's find lower bound for answer. In any good array, there are at least ⌈n−1k⌉ ones among the first n−1 elements. Also, an is always 1 , as ⌈1k⌉=1 .

So there are at least ⌈n−1k⌉+1 ones in any good array.

This lower bound can always be achieved by placing ones on position n and on positions 1+k⋅x for all integers x such that 0≤x≤⌊n−2k⌋=⌈n−1k⌉−1 .

The answer to the probelm is ⌈n−1k⌉+1 .

1839B - Lamps

Hint Solution 1839B - Lamps Let's denote number of lamps with ai=k as ck .

If ck≥k and you turn k lamps with ai=k lamps on, all ck of them will break and you will not be able to receive points for the other ck−k lamps.

If we denote values bi for all i such that ai=k as dk,1,dk,2,…,dk,ck (dk,1≥dk,2≥…≥dk,ck ), then you can't get more than sk=dk,1+dk,2+…+dk,min(ck,k) points for lamps with ai=k .

So, the total number of points is not bigger than s1+s2+…+sn .

This bound can always be achieved in the following way: while there is at least one lamp that is not turned on and not broken, turn on the one with minimum ai (if there are multiple lamps with minimum ai , choose the one with maximum bi ).

This works because if at least k lamps are turned on, then all lamps with ai<k are already broken.

1839C - Insert Zero and Invert Prefix

Hint Hint Hint Solution 1839C - Insert Zero and Invert Prefix It's easy to see that last element of b is always zero, so if an is 1 , then the answer is "NO".

It turns out that if an is 0 , then answer is always "YES".

First, let's try to get b equal to array of form [1,1,…,1k,0] for some k≥0 . Further in the editorial I will call such arrays simple. We can insert zero before the first element k times and then insert zero after the last element, inverting all previously inserted zeroes into ones.

To get arbitrary b with bn=0 , you can notice that such array can always be divided into simple arrays. For example, array [1,1,0,0,1,1,1,1,0,1,0] can be divided into [1,1,0] , [0] , [1,1,1,1,0] , [1,0] .

Also it's easy to see that if you can get array a1 with sequence of operation p1 and array a2 with sequence of operations p2 , then you can get concatenation of arrays a1 and a2 by first performing all the operations from p2 and then performing all the operations from p1 .

So, the solution is as follows:

If an is 1 , output "NO". Otherwise, divide array a into simple arrays of lengths s1,s2,…,sm (s1+s2+…+sm=n ). Then, you can get b=a with sequence of operations p=[0,0,…,0sm−1,sm−1,0,0,…,0sm−1−1,sm−1−1,…,0,0,…,0s1−1,s1−1] . 1839D - Ball Sorting

Hint Hint Solution 1839D - Ball Sorting Let's solve the problem for some fixed k .

Consider the set S of all balls that were never moved with operation of type 2 . Let's call balls from S fixed and balls not from S mobile.

The relative order of fixed balls never changes, so their colors must form an increasing sequence.

Let's define f(S) as the number of segments of mobile balls that the fixed balls divide sequence into. For example, if n=6 and S={3,4,6} , then these segments are [1,2],[5,5] and f(S) is equal to 2 .

As every mobile ball has to be moved at least once, there must be at least one zero-colored ball in each such segment, whicn means that f(S)≤k . Also, it means that we will need at least n−|S| operations of type 2 .

In fact, we can always place mobile balls at correct positions with exactly n−|S| operations. The proof is left as exercise for reader.

So the answer for k is equal to minimum value of n−|S| over all sets S of balls such that f(S)≤k and the colors of balls in S form an increasing sequence. This problem can be solved with dynamic programming: let dpi,j be maximum value of |S| if only balls from 1 to i exist, ball i belongs to S and f(S) is equal to j . To perform transitions from dpi,j you need to enumerate t —the next ball from S after i . Then, if t=i+1 , you transition to dpt,j , otherwise you transition to dpt,j+1 . After each transition |S| increases by 1 , so you just update dpt,j/j+1 with value dpi,j+1 .

There are O(n2) states and at most n transitions from each state, so the complexity is O(n3) .

Solution can be optimized to O(n2logn) with segment tree, but this was not required.

1839E - Decreasing Game

Hint Hint Hint Hint Solution 1839E - Decreasing Game I claim that the second player wins if and only if array a can be divided into two sets with equal sum, or, equivalently, there is a subset of a with sum a1+a2+…+an2 .

The strategy for the second player in this case is quite simple: before the game starts, the second player splits a into two parts with equal sum. On each round, if the first player selected i from the first part, the second player selects j from the second part. Otherwise, he selects j from the first part. Before and after every round, sums of elements in both parts are equal, so if there is a positive element in one part, there is also a positive element in the other part. So the second player is always able to make a correct move.

The strategy for the first player in the other case is even simplier: he can just make any correct move on each round. Why?

Let's suppose the second player won the game, which lasted k rounds, and elements selected by players on each round were (i1,j1),(i2,j2),…,(ik,jk) . After k -th round, all elements of a are zeroes, otherwise the first player would still be able to make a correct move.

Let's consider graph G with set of vertices V={1,2,…,n} and set of edges E={(i1,j1),(i2,j2),…,(ik,jk)} . It's easy to see that this graph is always a tree (proof left as exercise for reader; hint: after each round, at least one of ai and aj becomes zero). If graph is a tree, then it is bipartite, which means that its vertices can be divided into two sets such that each edge connects vertices from different sets. As each operation decreases ai and aj by same value, these two sets have the same sum of elements. So we have a contradiction.

Tutorial of Codeforces Round 876 (Div. 2)

Codeforces Round #875 (Div.1 + Div. 2) Editorial

By Gheal, 12 days ago, In English 1831A — Twin Permutations Author: Gheal

Hints Solution Since ai+bi≤ai+1+bi+1 , then ai+bi can be equal to ai+1+bi+1 .

Therefore, any permutation b which satisfies a1+b1=a2+b2=…=an+bn is a valid answer.

If bi=n+1−ai , then:

b is a permutation; a1+b1=a2+b2=…=an+bn=n+1 Consequently, b=[n+1−a1,n+1−a2,…,n+1−ai,…,n+1−an] is a valid answer.

Time complexity per test case : O(N) Code (Gheal, C++) Rate Problem 1831B — Array Merging Author: tibinyte

Hints Solution Let maxa(x) be the length of the longest subarray from a containing only elements equal to x . If x doesn't appear in a , then maxa(x)=0 .

Similarly, let maxb(x) be the length of the longest subarray from b containing only elements equal to x . If x doesn't appear in b , then maxb(x)=0 .

maxa and maxb can be computed in O(N) by scanning the array while updating current maximal subarray.

When merging two arrays, it is possible to force a particular subarray [al1,al1+1,…,ar1] to be adjacent to another particular subarray [bl2,bl2+1,…,br2] in the merged array.

Proof If al1=bl2 , then the merged array will have a subarray consisting of (r1−l1+1)+(r2−l2+1) equal elements.

Therefore, the answer is equal to:

max2⋅ni=1(maxa(i)+maxb(i)) Time complexity per testcase: O(N) .

Code (tibinyte, C++) Rate problem 1830A — Copil Copac Draws Trees Author: alecs

Hints Solution This problem can be solved via dynamic programming. From here on out, step 1 from the statement will be called a "scan".

Let dp[i] be the number of scans needed to activate node i , and id[i] be the index (in the order from the input) of the edge which activated node i .

Intially, since only 1 is active, dp[1]=1 and id[1]=0 .

We will perform a dfs traversal starting from node 1 . When we process an edge (u,v) , one of the following two cases can happen:

If index((u,v))≥id[u] , we can visit v in the same scan as u : dp[v]=dp[u] , id[v]=index((u,v)) If index((u,v))<id[u] , v will be visited in the next scan after dp[u] : dp[v]=dp[u]+1 , id[v]=index((u,v)) The answer is maxni=1(dp[i]) .

Time complexity per test case: O(n) Code (Gheal, C++) Code (alecs, C++) Rate problem 1830B — The BOSS Can Count Pairs Author: Gheal

Hints Solution Since bi≤n and bj≤n , bi+bj=ai⋅aj≤2⋅n . Therefore, min(ai,aj)≤2⋅n−−−−√ .

Let lim=2⋅n−−−−√ and fr[ai][bi] be the number of pairs (ai,bi) from the input such that ai≤lim .

A pair (i,j) is good if it satisfies ai⋅aj=bi+bj .

Firstly, we'll count the number of good pairs (i,j) such that ai=aj . Since min(ai,aj)≤lim , we can see that ai=aj≤lim .

This sum can be written as:

∑ni=1fr[ai][ai⋅ai−bi]−∑limi=1fr[i][i⋅i2]2 The remaining good pairs will have ai≠aj , and instead of counting the pairs which have i<j , we can count the pairs which have ai>aj .

Since aj=min(ai,aj) , we can say that aj≤lim .

Substituting aj for j , this second sum can be written as:

∑ni=1∑min(ai−1,2⋅nai)j=1fr[j][ai⋅j−bi] Since we've already established that j≤lim=2⋅n−−−−√ , calculating this sum takes O(nn−−√) time.

Be especially careful when calculating these sums, as ai⋅ai−bi and ai⋅j−bi can end up being either negative or greater than n .

Time complexity per testcase: O(nn−−√) Code (Gheal, C++) Code (Vladithur, Python) Rate problem 1830C — Hyperregular Bracket Strings Author: Gheal

Hints Solution First and foremost, the number of regular bracket strings of length 2⋅n is equal to Cn=1n+1(2nn) .

Secondly, for a bracket string s1s2…sk¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ , let:

f(si)={1,−1,if si='('if si=')'

Δi=∑ij=1f(sj) A bracket string s1s2…sk¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ is a regular bracket string if both of the following statements are true:

Δk=0 Δi≥0,i=1,k¯¯¯¯¯¯¯ From now on we'll call a set of indices i1<i2<…<ik a group if si1si2…sik¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ must be an RBS.

There are two main cases to consider, both of which can be proven with the aforementioned conditions for a string to be an RBS:

Case 1: Included intervals Case 2: Partially overlapping intervals By taking both of these cases into account, we can conclude that all indices ik covered by the same subset of intervals are part of the same group.

Finding the subset of intervals which cover a certain index i can be implemented using difference arrays and xor hashing.

How does xor hashing on difference arrays work? Time complexity: O(maxn⋅log(mod)) for precomputing every Cn , and O(k⋅log(k)) per test case.

Code (Gheal, C++) Rate problem 1830D — Mex Tree Author: Gheal

Hints Solution Disclaimer: I ( tibinyte ) wanted to cut O(nn−−√) memory because I thought that setting 1024 MB memory limit would spoil the solution. So only blame me for this.

If we analyze how good a bipartite coloring of the given tree is we can note that it achieves a total cost of n⋅(n+1)−O(n) .

Now suppose the tree has a connected component of size k . We can note that this decreses the maximum cost by O(k2) .

By the 2 claims above, we can note that in an optimal coloring, the maximum size of a connected component is O(n−−√) .

Now let dpi,j,color be the minimum loss if we color the subtree of i and the connected component of vertex i has size j . We can calculate this in a knapsack style by adding subtrees successively. The computation takes O(n⋅n−−√) if we use the 7 -th trick from this blog.

Now we are only left to optimize memory, since now it's O(n⋅n−−√) . We can directly apply this to get linear memory.

Code (tibinyte, C++) Rate problem 1830E — Bully Sort Author: valeriu

Thanks to errorgorn for the solution!

Solution First of all, we notice that if some element moves left, it will never move right.

Proof Obviously, if an element moves right, it will never move left since it will continue to move right until it reaches its final position.

By the 2 claims above, we conclude that left and right movers are distinct.

Now suppose we swap indicies i and j and note that such swap kills 2⋅(j−i)−1 inversions and the left mover j moves j−i steps.

Now the magic is that if we let s be the sum over 2⋅(i−pi) for all left movers we have s−ans=inversions , thus our answer is just s−inversions .

Now to handle the data structure part, we just need to be able to calculate inversions while being able to perform point updates. There are many ways to do this, for example for using a fenwick tree and a bitwise trie/ordered_set in O(nlog2n) .

Code (tibinyte, fenwick tree + ordered_set C++) Code (tibinyte, sqrt decomposition, C++) Code (errorgorn, divide and conquer, C++) Rate problem 1830F — The Third Grace Author: tibinyte

Thanks to errorgorn for the editorial!

Solution Let dpi be the maximum sum of costs of activated points that are <i over all states that has point i activated.

When we transition from dpi to dpj , we need to add the cost contributed by point i . The number of ranges where point i is the largest coordinate within it are the ranges [l,r] which satisfy l≤i≤r<j . So we have dpj=maxi<j(dpi+pi⋅Si,j) where Si,j is the number of ranges [l,r] which satisfy l≤i≤r<j . Now, we note that Si,jz With some work, we can get calculate this dp in O(n2) . But this will be too slow, let's try to speed this up.

Let us define dpi,j=maxk≤i(dpk+pk⋅Sk,j) . We have dpj−1,j=dpj . Our goal is to go from (implictly) storing dpi,i+1,dpi,i+2,…,dpi,n to dpi+1,i+2,dpi+1,i+3,…,dpi+1,n . As dpi+pi⋅Si,j looks like a linear function w.r.t. Si,j , we can try to use convex hull data structures to maintain it.

Let's figure out how Si+1,j relates to Si,j . We need to subtract the number of ranges with r=i and add the number of ranges with l=i+1 and r<j . This corresponds to Si,∗ and Si+1,∗ differing by amortized O(1) suffix increment updates. Also, note that Si,∗ is non-decreasing.

So we want to support the following data structure: Initially we have an arrays A and X that are both initially 0 . Handle the following updates:

1 m c Ai←max(Ai,m⋅Xi+c) for all i 2 j k Xi←Xi+k for all j≤i . It is guaranteed that X will always be non-decreasing. 3 i find Ai This can be maintained in a lichao tree in O(log2) time. In each lichao node, we need to store s,m,e , the start, middle and end indices and their corresponding X values Xs,Xm,Xe respectively. This way, we can support operations 1 and 3 already.

To support operation 2 , note that in a lichao tree, you can use O(log2) time to push down all lines that covers a certain point (refer to https://codeforces.com/blog/entry/86731). This way, all lines in the li chao tree are in [1,j) or [j,n] , so you can do lazy updates on both the coordinates of the lines and the X values.

The time complexity is O(nlog2) .

There is another solution that works in O(mlog3) that we are unable to optimize further yet. Let us flip the array so that the condition is on the activated point with the smallest coordinate. Then we have dpj=maxi<j(dpi+pj⋅Si,j) where Si,j counts the number of ranges [l,r] such that i<l≤j≤r .

Now, we want to store the linear function dpi+x⋅Si,j in some sort of data structure so that we can evaluate the maximum value with x=pj . Unfortunately, the value of Si,j can change by suffix additions, similar to above.

But since Si,j is non-increasing here, that means the optimal i that maximizes dpi+x⋅Si,j decreases when x increases. That is, for l1≤r1<l2≤r2 and we have two data structures that can get the maximum fj(x)=dpi+x⋅Si,j for lj≤i≤rj respectively. We can combine these 2 data structures to make it for [l1,r1]∪[l2,r2] by binary searching the point X where for all x≤X , f1(x)≤f2(x) and for all X≤x,f1(x)≥f2(x) . Since querying this data structure takes O(logn) , it takes O(log2) time to combine two such data structures. If we use a segment tree, we only need to rebuild O(log3) different data structures (the rest can be handled using lazy tags), giving us a time complexity of O(log3) .

Code (errorgorn, C++) Code (valeriu, C++) Rate problem If there is anything wrong or unclear in this editorial, feel free to ping me or any of the other authors in the comments.

Tutorial of Codeforces Round 875 (Div. 1)

Codeforces Round #874 (Div. 3) Editorial

By Vladosiya, history, 21 hour(s) ago, In English 1833A - Musical Puzzle

Idea: Vladosiya, prepared: Vladosiya

Tutorial 1833A - Musical Puzzle Let's construct the melody sequentially. In the first step, we can record the notes s1 and s2 . In the next step, we need to record s2 and s3 , because there must be a common symbol when gluing and so on.

That is, we need to have recorded melodies si +si+1 for all 1≤i<n . We only need to count how many different ones among them, because we don't need to record one melody twice.

Solution 1833B - Restore the Weather

Idea: myav, prepared: myav

Tutorial 1833B - Restore the Weather Let's solve the problem using a greedy algorithm.

Based on the array a , form an array of pairs {temperature, day number} and sort it in ascending order of temperature. Also sort the array b in ascending order. Now, the values a[i].first and b[i] are the predicted and real temperature on day a[i].second .

Indeed, consider the minimum temperatures b[1] and a[1].first . The difference between them is t=|b[1]−a[1].first| . If we consider the value |b[i]−a[1].first| or |b[1]−a[i].first| at i>1 , there will be at least t since a[1]≤a[i] and b[1]≤b[i] .

Since it is guaranteed that it is possible to rearrange the elements in the array b , and the elements b[1] and a[1].first have the smallest difference, it is definitely not greater than k .

Solution 1833C - Vlad Building Beautiful Array

Idea: Vladosiya, prepared: Vladosiya

Tutorial 1833C - Vlad Building Beautiful Array If all the numbers in the array already have the same parity, then for each i it is sufficient to assign bi=ai .

Otherwise, it is impossible to make all the numbers even by leaving them positive, because the parity changes only when subtracting an odd number, and we cannot make the minimum odd number an even number.

It remains only to make all numbers odd, that is, subtract odd numbers from even numbers. This can be done if the minimum number in the array is odd, because we can subtract it from every even number.

Solution 1833D - Flipper

Idea: Gornak40, prepared: Aris

Tutorial 1833D - Flipper In these constraints we could solve the problem for O(n2) . Let us note that there can be no more than two candidates for the value r . Since the first number in the permutation will be either pr+1 if r<n , or pr if r=n . Then let's go through the value of r and choose the one in which the first number in the resulting permutation is as large as possible. Next, if pn=n , then we can have two candidates for r is n,n−1 , but note that it is always advantageous to put r=n in that case, since it will not spoil the answer. Then we can go through l and get the solution by the square, but we can do something smarter.

Notice now that the answer already contains all the numbers pi where i>r . And then we write pr,pr−1,…,pl where l is still unknown, and then p1,p2,…,pl−1 . In that case, let's write pr as l≤r and then write pr−1,pr−2,… as long as they are larger than p1 . Otherwise, we immediately determine the value of l and finish the answer to the end. Thus, constructively we construct the maximal permutation.

Solution 1833E - Round Dance

Idea: MikeMirzayanov, Vladosiya, prepared: DmitriyOwlet

Tutorial 1833E - Round Dance Let's build an undirected graph, draw the edges i→ai . Let's split this graph into connectivity components, denote their number by k . There could not be more than k round dances.

Since the degree of each vertex is no more than two, the connectivity components are simple cycles and bamboos. If we connect the vertices of degree one in each bamboo, we get a partition into k round dances.

Now let's try to get the minimum number of round dances. Nothing can be done with cycles, and all bamboos can be combined into one. If you get b bamboos and c cycles, then the answer is ⟨c+min(b,1),c+b⟩ .

Time complexity is O(n) .

Solution 1833F - Ira and Flamenco

Idea: Gornak40, prepared: Gornak40

Tutorial 1833F - Ira and Flamenco Reformulate the definition of magnificent dance. A dance [x1,x2,…,xm] is called magnificent if there exists such a non-negative integer d that [x1−d,x2−d,…,xm−d] forms a permutation.

Let's build an array b such that it is sorted, all the numbers in it are unique and each number from a occurs in b . For each element bi , set ci as its number of occurrences in the array a . This process is called coordinate compression. For example, if a=[4,1,2,2,3] , then b=[1,2,3,4] , c=[1,2,1,1] .

Let the constructed array b has length k . In every magnificent dance there is a dancer with a minimum level. Let's fix this minimal level in the array b , let its index be i , then the desired magnificent dance exists if i+m≤k and bi+m=bi+m−1 .

If the desired magnificent dance exists, the number of such dances must be added to the answer, which is equal to ci⋅ci+1⋅…⋅ci+m . How to quickly calculate such a number?

Let's build prefix products pi=c1⋅c2⋅…⋅pi−1 . Then by Fermat's small theorem ci⋅ci+1⋅…⋅ci+m=pi+m⋅p(109+7)−2i . Time complexity is O(nlogC) . Let's build a segment tree on a product modulo. Time complexity is O(nlogn) and we don't use that the module is prime. We will use the idea of building a queue on two stacks, but we will support prefix products modulo in these stacks. Time complexity is O(n) and we don't use that the module is prime. Solution 1833G - Ksyusha and Chinchilla

Idea: Gornak40, prepared: Gornak40

Tutorial 1833G - Ksyusha and Chinchilla Let's hang the tree by the vertex 1 . This problem can be solved by dynamic programming.

dpcv — the ability to cut a subtree of v if the edges in all children of v must be cut off. dpov — the ability to cut a subtree of v if exactly one edge needs to be saved from v to the child. dpv — ability to cut a subtree of v if an edge above v is cut off. Obviously, the answer will be dp1 . Recalculation in such dynamics is offered to the reader as an exercise.

There is a simpler greedy solution. Let's call light a vertex that is not a leaf and whose children are all leaves. Let's call heavy a vertex that is not a leaf and that has a light child.

If there is a light vertex with at least three children, the desired cut does not exist. If the light vertex v has exactly one child, we will cut off all children from its parent except v . If the light vertex v has exactly two children, we cut the edge into the parent v .

It is easy to understand that in this way the desired cut is restored uniquely. This problem can be solved by an elegant DFS, but the author considers BFS easier to understand.

First, let's count the number of children and the number of light children for each vertex. We will store all light vertices in the queue and process them sequentially. Cutting edges will change the number of children and the number of light children at some vertices. It should be handled carefully.

This solution works for O(n) .

Solution

Codeforces Round #873 (Div. 1 & 2) Editorial

By thenymphsofdelphi, 8 days ago, In English 1828A - Divisible Array Idea: thenymphsofdelphi Preparation: Mike4235

Hint 1 Hint 2 Solution Consider the array a=[1,2,…,n] that satisfies the second condition. It has the sum of 1+2+⋯+n=n(n+1)2 .

One solution is to notice that if we double every element (a=[2,4,6,…,2n]) , the sum becomes n(n+1)2×2=n(n+1) , which is divisible by n .

Another solution is to increase the value of a1 until the sum becomes divisible by n . This works because every integer is divisible by 1 , and we only need to increase a1 by at most n .

Time complexity: O(n) Implementation 1 Implementation 2 1828B - Permutation Swap Idea: thenymphsofdelphi Preparation: Mike4235

Hint 1 Solution In order to move pi to position i , it is easy to see that |pi−i| has to be divisible by k .

So, |p1−1|,|p2−2|,…,|pn−n| has to be all divisible by k . The largest possible value of k turns out to be the greatest common divisor of integers |p1−1|,|p2−2|,…,|pn−n| .

Time complexity: O(n+logn) Implementation 1827A - Counting Orders Idea: Mike4235 Preparation: thenymphsofdelphi

Hint 1 Solution First, we can sort the array b , as it does not change the answer.

Let's try to choose the values of a from an to a1 . How many ways are there to choose the value of ai ?

The new ai must satisfies ai > bi . But some of the candidates are already chosen as aj for some j>i . However, since aj>bj≥bi , we know that there are exactly (n−i) candidates already chosen previously by all values of j>i . So, there are (number of k such that ak>bi ) −(n−i) ways to choose the value of ai .

We can use two pointers or binary search to efficiently find the (number of k such that ak>bi ) for all i .

Time complexity: O(nlogn) .

Implementation 1827B2 - Range Sorting (Hard Version) Idea: lanhf Preparation: Mike4235

Hint 1 Hint 2 Hint 3 Hint 4 Solution Let a[l..r] denotes the subarray al,al+1,…,ar .

Observation 1: In an optimal sequence of operations for one subarray, there will be no two operations that intersect each other. In other words, a subarray will be divided into non-overlapping subarrays, and we will apply a range-sort operation to each subarray.

Proof: Suppose there are two operations [l1,r1] and [l2,r2] that intersect each other, we can replace them with one operation [min(l1,l2),max(r1,r2)] which does not increase the cost.

Observation 2: Consider k positions l≤i1<i2<…<ik<r , then we can sort subarrays a[l..i1], a[i1+1..i2], …, a[ik+1..r] independently iff max(a[l..ix])<min(a[ix+1..r]) for all 1≤x≤k .

Proof: The obvious necessary and sufficient condition required to sort subarrays a[l..i1], a[i1+1..i2], …, a[ik+1..r] independently is max(a[ix−1+1..ix])<min(a[ix+1..ix+1]) for all 1≤x≤k , here we denote x0=l−1 and xk+1=r . It is not hard to prove that this condition is equal to the one stated above.

With these observations, we can conclude that the answer for a subarray a[l..r] equals the r−l minus the number of positions k such that l≤k<r and max(a[l..k])<min(a[k+1..r]) (∗) . Let us analyze how to calculate the sum of this value over all possible l and r .

Consider a position i (1≤i≤n ), let's count how many triplets (l,k,r) satisfy (∗) and min(a[k+1..r])=ai . It means that k must be the closest position to the left of i satisfying a[k]<a[i] . Denotes x as the closest position to the left of k such that a[x]>a[i] , and y as the closest position to the right of i such that a[y]<a[i] .

We can see that a triplet (l,k,r) with x<l≤y and i≤r<y will match our condition. In other words, we will add to the answer (k−x)⋅(y−i) .

In the easy version, we can find such values of x,k,y for each i in O(n) and end up with a total complexity of O(n2) . We can further optimize the algorithm by using sparse table and binary lifting and achieve a time complexity of O(nlogn) , which is enough to solve the hard version.

Implementation 1827C - Palindrome Partition Idea: lanhf Preparation: lanhf

Hint1 Hint2 Solution For the simplicity of the solution, we will abbreviate even palindrome as evp.

Lemma: Consider a beautiful string t , we can find the unique maximal partition for it by greedily choosing the smallest possible evp in each step from the left. Here maximal means maximum number of parts.

Proof: Suppose t[0..l) is smallest prefix which is an evp and t[0..r) is the first part in the partition of t , here t[l..r) mean substring tltl+1…tr−1 . We consider two cases:

2l≤r : In this case, it is clear that t[0..l) , t[l..r−l) and t[r−l..r) are evps, so we can replace t[0..r) with them. 

2l>r : In this case, due to the fact that t[r−l..l) and t[0..l) are evps, t[0..2r−l) is also an evp, which contradicts to above assumption that t[0..l) is the smallest. 

We can use dynamic programming to solve this problem. Let dpi be the number of beautiful substrings starting at i . For all i from n−1 to 0 , if there are such nexti satisfying s[i..nexti) is the smallest evp beginning at i , then dpi=dpnexti+1 , otherwise dpi=0 . The answer will be the sum of dpi from 0 to n−1 .

To calculate the next array, first, we use Manacher algorithm or hashing to find the maximum pali satisfying s[i−pali..i+pali) is an evp for each i . Then for all 0≤i<n , nexti=2j−i where j is smallest position such that i<j and j−palj≤i . The time complexity is O(nlogn) .

Implementation Bonus 1827D - Two Centroids Idea: Mike4235 Preparation: lanhf

Hint1 Hint2 Solution Observation: The answer for the tree with n vertices equals n−2⋅mx where mx is the largest subtree among the centroid's children.

Lemma: After one query, the centroid will move at most one edge, and when the centroid move, the tree before the query already has two centroids.

Proof:



Suppose the tree before the query has n vertices and the current centroid is u . Let v1,v2,…,vk are the children of u and the next query vertex x is in subtree v1 . Clearly, the centroid is either u or in the subtree v1 . Consider the latter case, because the size of subtree v1 does not greater than ⌊n2⌋ , the size of newly formed subtree including u is greater or equal to ⌈n2⌉ . Moving one or more edges away from v1 will increase the size of this new subtree by one or more, and the vertex can not become centroid because ⌈n2⌉+1>⌊n+12⌋ .

The second part is easy to deduce from the above proof.

We will solve this problem offline. First, we compute the Euler tour of the final tree and use "range add query" data structures like Binary indexed tree (BIT) or Segment tree to maintain each subtree's size. We will maintain the size of the largest subtree among the centroid's children mx . In the case where the centroid does not move, we just update mx with the size of the child including the newly added vertex, otherwise, we set mx to ⌊n2⌋ due to the lemma. The time complexity is O(nlogn) .

Implementation flowerletter :pensive: 1827E - Bus Routes Idea: Mike4235 Preparation: thenymphsofdelphi

Hint 1 Hint 2 Solution First, notice that for a pair of nodes (u,v) such that u is not a leaf, we can find a leaf l such that path (l,v) fully covers path (u,v) . Therefore, we only need to care about whether all pairs of leaves can reach each other using at most 2 routes.

Lemma

The condition above is equivalent to: There exists a node c such that c can reach all leaves by using at most one route.

Proof

The necessity part is trivial, so let's prove the sufficiency part.

Let the leaves of the tree be l1,l2,…,lm .

Let S(u) be the induced subgraph of all nodes reachable by u using at most one route. If u and v is reachable within two routes, then the intersection of S(v) and S(u) is non-empty. We need to prove that the intersection of all S(li) is non-empty.

If li , lj , and lk are pairwise reachable within two paths, then the intersection of S(li) , S(lj) , and S(lk) must be pairwise non-empty. Since the graph is a tree, it follows trivially that intersection of S(li) , S(lj) , and S(lk) must be non-empty. We can generalize this to all leaves, thus proving the sufficiency part.

To check if an answer exists or not, we can use this trick from ko_osaga to find how many S(li) covers each node in O(n) . The answer is YES when there is a node c that is covered by all S(li) .

To find the two candidates when the answer is NO, notice that one of them is the first leaf lx such that there is no node c that is covered by S(l1),…,S(lx) . We can find lx with binary search. To find the other one, root the tree at lx and define liftu as the lowest node reachable by u using at most one route. The other candidate is a node ly such that liftly is not in S(lx) .

Time complexity: O(nlogn) .

There exist other solutions found by testers that used only the array lift .

Implementation sorry gamegame 1827F - Copium Permutation Idea: lanhf Preparation: lanhf

Solution The solution to this problem will be posted later.

Implementation

CodeForces Round 872(Div. 1&2) Editorial

By Kevin114514, history, 67 minutes ago, In English A. LuoTianyi and the Palindrome String Consider the substring of s from the second character to the last, or s2s3⋯sn . If it's not palindrome, then the answer must be n−1 . What if it's palindrome? This implies that s2=sn , s3=sn−1 , and so on. Meanwhile, the fact that s is palindrome implies s1=sn , s2=sn−1 , etc. So we get s1=sn=s2=sn−1=⋯ or that all characters in s is the same. In this situation, every subsequence of s is palindrome of course, so the answer should be −1 .

B. LuoTianyi and the Grid Assume that n>m . Greedily thinking, we want the maximum possible a to appear as the maximum value of as many subtables as possible, meanwhile, we also want the minimum possible a to appear as the minimum value of as many subtables as possible. This gives us two choices: making the upper-left square the minimum or the maximum. It's symmetrical so we'll only consider the minimum situation.

Now all the subtables have the same minimum value, we want to maximize the number of subtables where the maximum a appears as the maximum value. Placing it at (1,2) and (2,1) makes the number n(m−1),m(n−1) each, because n>m , we have m(n−1)>n(m−1) , so we place the largest a at (2,1) and the second largest at (1,2) , the answer for this case is m(n−1)×max+m×second max−mn×min .

C. LuoTianyi and the Show First we can notice that, if someone with a specific favourite seat(i.e. not −1 nor −2 ) has got his seat taken by a −1 guy or a −2 guy, it's better to let the first man go first, and the −1 or −2 one go after him.

Now, we know it's better to make those with a favourite seat go in first. After they have seated, now we consider filling the space between them with −1 and −2 . It's easy to notice that we can find two non-overlapping prefix and suffix, and fill the blank seats in the prefix with −1 , and the blanks in the suffix with −2 . We now only need to find the answer greedily for each division point between the prefix and the suffix.

The time complexity is O(n) .

D. LuoTianyi and the Floating Islands Call a node special if there is a person in it.

When k is odd, we find that there is only one node satisfying the conditions.

Proof. Assume distinct node x and node y are good nodes. Let x be the root of the tree. Define si as the number of special nodes in subtree i . Think about the process we move from x to y . If we try to move the chosen node from its father to i , the variation of cost is k−2si . When move from x to its son i which szi is maximal, k−2si≥0 is held (Otherwise, x isn't a good node). And we can get k−2si>0 further because k is odd and 2si is even. Since min1≤j≤nk−2sj=k−2si , we find k−2sj>0 for all j . So y can't be good node.

Then think about the situation that k is even. Choose a node as root arbitrarily. With the same method, we find that good nodes satisfy 2si=k . It's also sufficient. Define pi as the possibility that szi=k2 , then the answer is ∑ni=1pi .

Define Si as the size of subtree i . When szi=k2 , there are k2 special nodes in subtree i and k2 in the other part. The number of ways to place special nodes is (nk) , and (Sik2)(n−Sik2) of them satisfying the condition. So pi=(Sik2)(n−Sik2)(nk) .

So we can solve the problem in O(n) .

E. LuoTianyi and XOR-Tree Hint: Consider a brute force dynamic programming solution and try to optimize it.

Denote the minimum number of operations needed to make every path from a leaf inside the subtree of u to the root have the xor value of w as fu,w . Observe that for every u , there are only 2 possible different values for fu,w . This is because if fu,w1−fu,w2>1 , we can use an operation of xor-ing au with w1 xor w2 to make all the xor values from w2 to w1 , which takes fu,w2+1 steps instead of fu,w1 .

Now we only need to calculate minnu=minfu,w , and the set Su of w that makes fu,w minimum. We have minnv=0 and Sv=the xor value from root to v for leaf v . It's trivial to calculate minnu .

Note that Su contains of the numbers appearing the most times in the sets of u 's son. We can maintain Su using a map and merging it heuristically. Consider when merging sets into a new set S′ . If every element of S′ appears only once in the original sets, then we keep S′ as the result, otherwise, brute force the whole set S′ and find the elements appearing the most times. For the second situation, every element's count of appearance is at least halved(those appearing once have 0 and others have 1 afterwards), so the number of brute force checking operations is O(nlogn) .

The final time complexity is O(nlog2n) .

F. LuoTianyi and the Function Consider an alternative method of calculating g . Notice that g(i,j) is the minimum of the last appearing position of all colors(let's call different values of ax colors for short) in the interval [i,j] .

Consider the sequence from an to a1 . Adding ai to the front of the sequence only affects the values g(i,x)(i≤x<nxti) , where nxti is the next position after i having the same a value as it. Or it's to say to modify g values in the submatrix of [(1,i),(i,nxti−1)] to i , which can be done in O(nlog2n) , but it's not fast enough.

Because the queries happen after all modifications take place, you can store the queries offline, and calculate a submatrix using 4 queries of submatrixes having (1,1) as the upper-left corner. Now we need to maintain a data structure that can: 1. set all values in an interval as a same value x , 2. query the history sum(sum of values on all previous editions). We can maintain the segments of adjacent positions with the same values, and turn the modification into 'range add' for a segment.

An operation makes at most O(1) new segments, and now there's only O(n) range add modifications and O(m) range history sum queries, now the problem can be solved in O(nlogn) time complexity with segment tree.

G. LuoTianyi and Cartridge Consider finding the maximum value of B+D for every min(A,C) . Denote min(A,C) as x . We call a vertex u satisfying au≥x or an edge satisfying ce≥x optional. Denote as V the optional vertex set and as E0 the optional edge set.

Firstly, if all optional vertices are on the same side of an edge, this edge mustn't be chosen. Delete these edges from E0 and we get the edge set E . Formally, an edge e is in E if and only if ce≥x and there exists u,v so that e is on the path between them.

Lemma. There exists an optimal Tans=(Vans,Eans) that either V=Vans or E=Eans .

Proof. Assume an optimal T′=(V′,E′) with V′≠V,E′≠E . Choose an edge e that is in E but not in E′ . Because V′≠V , there must exist two vertices u,v on different sides of edge e and u∈V′,v∉V′ . Consider adding the edge e and the vertex v into our chosen tree, the resulting graph is obviously a tree. Note that bv,de≥0 , so the resulting choice is no worse than T′ .

When we delete the edges in E from the original tree, we get some connected components. Shrink one component into a single vertex to get V′ , and then for all edges (u,v)∈E , connect u 's and v 's component together in the new graph and get E′ . Obviously, the new graph T′=(V′,E′) is a tree.

For any leaf vertex u′ on the new tree T′ , there must exist a vertex u in the component u′ that is chosen, otherwise the edge connecting to u′ , let's say, e′ is not chosen either. Adding u and e′ into our answer tree achieves a better answer.

Assume that now we have chosen a vertex u for every leaf u′ , denote the set of chosen vertices as Vx . Consider an arbitary choice of vertex for components Vc and edge choice Ec satisfying Vx⊆Vc⊆V,Ec⊆E,|Vc|−1=|Ec| . It's easy to prove that the choice is a legal answer, given the fact that every e∈Ec has at least one leaf component on each side and every leaf component contains a chosen vertex.

Reconsider the lemma, and we can get a solution for a fixed x :

Find V,E . Calculate the components and get V′,E′ . Find the vertex with the maximum b in every leaf-component in V′ and get Vx . Let m be min(|V|,|E|+1) , and m′ be |Vx| . Choose the vertices in V∖Vx with the first m−m′ largest b , and the edges in E with the first m−1 largest d and get the answer. Consider the process when x gets larger, the sets V,E get smaller and smaller while the components merge into each other. We use segment trees to maintain the b value of the vertices and the d value of the edges, when merging two components, we simply merge the two segment trees.

The final time complexity is O(nlogn) .

Codeforces Round 871 (Div. 4) Editorial

By flamestorm, 8 minutes ago, In English We hope you enjoyed the contest! We will add implementations soon, but we wanted to publish the solutions first.

1829A - Love Story

Idea: SlavicG

Tutorial 1829A - Love Story You need to implement what is written in the statement. You need to compare the given string s with the string "codeforces" character by character, counting the number of differences. We know that the length of s is 10 , so we can simply iterate through both strings and compare each character at the same index.

If the characters are the same, we move on to the next index. If they are different, we count it as a difference and move on to the next index. Once we have compared all 10 characters, we output the number of differences.

1829B - Blank Space

Idea: mesanu

Tutorial 1829B - Blank Space We can iterate through the array a and keep track of the length of the current blank space. Whenever we encounter a 0 , we increase the length of the current blank space, and whenever we encounter a 1 , we check if the current blank space is longer than the previous longest blank space. If it is, we update the length of the longest blank space. Finally, we return the length of the longest blank space.

The time complexity of this algorithm is O(n) .

1829C - Mr. Perfectly Fine

Idea: SlavicG

Tutorial 1829C - Mr. Perfectly Fine Tutorial is not available

1829D - Gold Rush

Idea: flamestorm

Tutorial 1829D - Gold Rush We can solve this problem recursively. Let the current pile have n gold nuggets.

If n=m , then we can make a pile with exactly m gold nuggets by not doing any operations. If n is not a multiple of 3 , then it is not possible to make a move, because after a move we split n into x and 2x , so n=x+2x=3x for some integer x , meaning n has to be a multiple of 3 . Finally, if n is a multiple of 3 , then we can split the pile into two piles with n3 and 2n3 gold nuggets, and we can recursively check if we can make a pile with exactly m gold nuggets. See the implementation for more details. By the Master Theorem, the time complexity is O(nlog32)≈O(n0.631) . Most compilers and languages optimize the recursion enough for this to pass comfortably. (The model solution in C++ runs in 15 milliseconds.)

1829E - The Lakes

Idea: mesanu

Tutorial 1829E - The Lakes We can approach this problem using Depth First Search (DFS) or Breadth First Search (BFS) on the given grid.

The idea is to consider each cell of the grid as a potential starting point for a lake, and explore all the cells reachable from it by only moving up, down, left or right, without stepping on any cell with depth 0 . If we reach a dead end, or a cell with depth 0 , we backtrack and try another direction.

During this exploration, we keep track of the sum of depths of all the cells that we have visited. This sum gives us the volume of the current lake. When we have explored all the reachable cells from a starting point, we compare the volume of this lake with the maximum volume found so far, and update the maximum if necessary.

To implement this approach, we can use a nested loop to iterate through all the cells of the grid. For each cell, we check if its depth is greater than 0 , and if it has not already been visited in a previous lake. If these conditions are satisfied, we start a DFS/BFS from this cell, and update the maximum volume found so far. See the implementation for more details.

The time complexity is O(mn) .

1829F - Forever Winter

Idea: flamestorm

Tutorial 1829F - Forever Winter The degree of a vertex is the number of vertices connected to it. We can count the degree of a vertex by seeing how many times it appears in the input.

Let's count the degrees of the vertices in a snowflake graph.

The starting vertex has degree x . Each of the x newly-generated vertices has degree y+1 (they have y new neighbors, along with the starting vertex). Each of the x×y newly-generated vertices has degree 1 (they are only connected to the previous vertex). Thus, we can make this table: Count	Degree 1 x x y+1 xy 1 So we can simply count the degrees, see which degree appears only once (it is x ) and see the number of vertices with degree 1 (it is xy ), and from here we can compute x and y . However, there is an edge case. If x=y+1 , then the first two rows combine:

Count	Degree x+1 x=y+1 xy 1 We can still compute xy by counting the number of vertices with degree 1 , and from here we can see that the other degree has x+1 vertices of that type, so we can subtract one to extract x and from there, extract y . The time complexity is O(n+m) per test case.

1829G - Hits Different

Idea: flamestorm

Tutorial 1829G - Hits Different The cans are hard to deal with, but if we replace them with a different shape, a diamond, we get the following:

Now the cans that fall just form a rectangle. In fact, let's rotate the picture: What we can see is that each query is just a 2D prefix sum! So we can precompute all prefix sums in the grid in O(M) time, where M=106 is the maximum value of the input, and answer each sum in O(1) time. To avoid finding the row and column, we can instead iterate through the cells in order 1,2,3,… , that is, we go diagonal-by-diagonal in the grid above. Now, make a separate array ans , and keep track of the answer for each cell from 1 to 106 as we find its prefix sum. This avoids having to do any complicated math or binary search to find the row and column for the prefix sum. See the implementation for more details.

The time complexity is O(n) precomputation with O(1) per test case.

1829H - Don't Blame Me

Idea: SlavicG

Tutorial 1829H - Don't Blame Me We can notice that the numbers are pretty small (up to 63 ) and the AND values will be up to 63 as well. Thus, we can count the number of subsequences that have AND value equal to x for all x from 0 to 63 .

We can do this using dynamic programming. Let's denote dpij as the number of subsequences using the first i elements that have a total AND value of j . The transitions are quite simple. We can iterate over all j values obtained previously and update the values respectively:

We have three cases:

The first case is when we don't use the i -th value. Here we just update the dpij in the following way: dp[i][j]=dp[i][j]+dp[i−1][j] .

The second case is when we use the i -th value. Here we update the dp[i][a[i]&j] in the following way: dp[i][a[i]&j]=dp[i][a[i]&j]+dp[i−1][j] .

The third case is starting a new subsequence with just the i -th element. Thus, we update dp[i][a[i]]=dp[i][a[i]]+1 .

Codeforces Round #870 (Div. 2) Editorial

By okwedook, 2 hours ago, In English The problems were named after songs of my favorite musical group, Hippie Sabotage. Give them a try!

1826A - Trust Nobody

Hint1 Hint2 Solution 1826A - Trust Nobody Let's iterate over the number x of liars in the group. Now everyone, who says li>x is a liar, and vice versa. Let's count the actual number of liars. If those numbers match, output the answer.

Now that we've checked all possible x 's, we can safely output −1 , since no number of liars is possible.

1826B - Lunatic Never Content

Hint1 Hint2 Solution 1826B - Lunatic Never Content For the sequence to be a palindrome, it has to satisfy bi=bn−i+1 . In our case bi=ai(modx) . We can rewrite the palindrome equation as ai(modx)=an−i+1(modx) . Moving all the terms to the left we get ai−an−i+1≡0(modx) , which basically says ai−an−i+1 divides x .

Now, how to find the biggest x , which satisfies all such conditions? Greatest common divisor of course! We just need to calculate the GCD of the numbers ai−an−i+1 for all i .

This results in a O(n+log(109)) solution, since computing the gcd of n numbers up to 109 takes exactly this much time.

A useful assumption here is that GCD(x,0)=x for any number x . This holds true for standard template library implementations. And do not forget that this function should work correctly for negative numbers too. An easy trick here is to just use the absolute value of ai−an−i+1 .

1826C - Dreaming of Freedom

Hint1 Hint2 Hint3 Solution 1826C - Dreaming of Freedom First we need to notice, that in order to keep some amount of options indefinetely, this number has to be at least 2 and divide n . Let's find the smallest such number d . Now, if d≤m , let's always vote for the first d options evenly. In the other case (d>m) each round would force us to to decrease the number of remaining options, so eventually it will become one. So the answer is YES if and only if d>m .

Now on how to find the number d fast. Since d is a divisor of n we can say, that d is the smallest divisor of n not equal to 1 .

We can find the number d using different approaches. A more straightforward one, is checking all the numbers from 2 up to n−−√ . If no divisors found, then n is prime and d=n . This results in a O(t⋅n−−√) solution.

The solution presented before is good, but not fast enough in some languages, like Python. We've decided not to cut it off to not make the problem heavy in IO. We can optimize it via finding the smallest divisor using the sieve of Eratosthenes. This would result in O(nlogn) or even faster precomputation and O(1) to answer a test case, so the total time complexity is O(nlogn+t) .

1826D - Running Miles

Hint1 Hint2 Solution 1826D - Running Miles There is a fairly straightforward solution using DP, but I'll leave that for the comment section and present a very short and simple solution.

First we need to notice, that at two of the maximums are at the ends of [l,r] , otherwise we can move one of the boundaries closer to the other and improve the answer.

Using this observation we can reduce the problem to the following: choose three indices l<m<r , such that bl+bm+br−(r−l) is maximum.

Now, let's iterate over the middle index m and rewrite the function as bm+(bl+l)+(br−r) . We can see, that values in the braces are pretty much independent — on of them depends only on the index l and the second one depends only on the index r . So, for a given m we can choose the numbers l and r greedily! To make it fast enough we can precalculate the prefix maximum for the array bl+l and the suffix maximum for array br−r . This results in a O(n) time complexity solution.

1826E - Walk the Runway

Hint1 Hint2 Hint3 Solution 1826E - Walk the Runway At first, let's define the relation between two models, that go one after another in the show. Their ratings must satisfy ri,j<ri,k for all cities i . Now let's precompute this relations for all pairs of models naively in O(n2m) , which is ok for now.

Now, we have the relations "model i can go before model j ", let's build a graph of such relations. This graph has no cycles, since the ratings are strictly increasing. Now we can build the topological sorting of this graph and compute dpi= the biggest profit, if the last model is model i in O(n2) .

Now, how to calculate this relation for all pairs of models fast enough? Let's process each city one by one and update the relations using bitsets! More formally, let's store a bitset of all the models, that can be before model j in city i . If we process the models in order of increasing rating, we can update each models bitset of relations in O(n64) , so the total time complexity would be O(n2m64) , which is fast enough.

1826F - Fading into Fog

Hint1 Hint2 Hint3 Solution 1826F - Fading into Fog At first let's query two non-parallel lines. In this general case building perpendicular lines from projections and intersecting them will give us O(n2) candidates for the answer. This gives us the intuition, that 2 queries isn't enough. Also, the constraint from the statement suggests, that asking x=0 and y=0 will guarantee, that no two candidates are closer, than 1 from each other, which will come in handy later.

Now let's prove we can solve the problem in 3 queries. Indeed, there will always some space between the candidates. A simple proof of that would go something like this: there are O(n2) candidates and O(n4) pairs of candidates; now we can sort the directional vectors by the angle, and there will be at least one angle of at least 2πO(n4) between some two neighbouring vectors by the pigeonhole principle, which is big enough.

One way to choose such a line is by queriying random lines, till we find a good enough one, or query some constant amount of lines and choose the one with the biggest distance. Checking one line can be done in O(n2logn) with a simple sort. How many exactly do we need is an exercise to the reader, but it can be proven, that under the given constraints this number is O(1) .

Now, when we have the line, let's query it and check all the candidates in O(n3) or O(n2logn) or even O(n2) . It doesn't really affect the runtime.

The total complexity is O(n2logn) per testcase.

Tags editorial

Codeforces Round #869 (Div.1, Div.2) Editorial

By jeroenodb, 7 hours ago, In English 1818A - Politics

Problem idea: adamant Preparation: adamant

Editorial [problem:1818A] The members that stay in the end must have the same take about each of the discussed opinions (if takes about some opinion differ for two members, at least one of them should have left during the discussion of that opinion). It means that the people that are left must all have the same takes as the president. On the other hand, all such people can stay if you expel everybody else in advance, so the problem just asks you to count the number of people with the same takes on all opinions as the president.

Solution 1818B - Indivisible

Problem idea: adamant Preparation: adamant

Editorial [problem:1818B] If n>1 is odd, there is no solution, as the sum of the whole array n(n+1)2 is always divisible by n . Otherwise, the solution is as follows:

Start with the identity permutation 1,2,…,n . Swap the adjacent pairs to get 2,1,4,3,6,5,...,n,n−1 . Indeed, consider the sum of a sub-array al,…,ar . There are 2 cases:

l and r have different parity: the sum is (r−l+1)(l+r)2 and its greatest common divisor with r−l+1 is r−l+12 , as l+r is not divisible by 2 ; l and r have the same parity: the sum is (r−l+1)(l+r)2+1 or (r−l+1)(l+r)2−1 , depending on the parity. The first summand is divisible by r−l+1 , as l+r is even. So, the whole sum has the remainder 1 or −1 modulo r−l+1 , thus it can't be divisible by it. Solution 1817A - Almost Increasing Subsequence

Problem idea: dario2994 Preparation: jeroenodb

Editorial [problem:1817A] It is not obvious how the condition in the statement for an almost-increasing subsequence can be turned into a fast data structure that can support queries. So instead of tackling the problem head on, let's try to make an upperbound for how many elements can be in the maximum length almost-increasing subsequence.

Assume you're given a query about the subarray of the original array [al,al+1,…,ar] . Let's partition this array into decreasing subarrays. This means everytime when ai<ai+1 we place a cut between ai and ai+1 . For example, consider the array [4,6,7,2,2,3] , it will be cut into [4],[6],[7,2,2],[3] . All these small subarrays are non-increasing, which means that any subsequence of such a subarray is non-increasing. Because an almost-increasing subsequence cannot have three consecutive elements x≥y≥z , in each of the subarrays of our partition at most 2 elements can be chosen to insert into our almost-increasing subsequence.

Actually we can put exactly min(|subarray|,2) elements of each subarray into the increasing subsequence, by taking the first and the last element of each subarray. This is valid, because the cuts for the partition were made at places where ai<ai+1 , so every bi≥bi+1 in our candidate subsequence is preceded and followed by a bj<bj+1 . By our upperbound, this construction is optimal.

The sum, ∑partitionmin(|subarray|,2) can be calculated for one query in linear time, giving a O(nq) solution.

To optimize this, the sum ∑partitionmin(|subarray|,2) can be rewritten to ∑partition|subarray|−|inner elements| , where inner elements of a subarray are all the elements that are not the first or last element. For such elements ai , we know that ai−1≥ai≥ai+1 . The sum of lengths over the partition sums to r−l+1 . So we're left with counting the number of special indices l<i<r such that ai−1≥ai≥ai+1 . This can be done with O(n) preprocessing and O(1) queries using prefix sums. For a query we can output r−l+1−|special indices| . There are some literal edgecases, where some care in the implementation is needed.

The total time complexity is O(n+q) .

Solution 1817B - Fish Graph

Problem idea: jeroenodb Preparation: jeroenodb

Hint 1 Hint 2 Hint 3 Editorial [problem:1817B] Can you find a necessary condition for whether a Fish Subgraph exists?

For the Fish Subgraph to exist, the graph must have a cycle with one node in the cycle having degree at least 4.

When the necessary condition is satisfied, actually, you can always find a Fish Subgraph. Try to prove this, and see if your proof can be turned into an algorithm.

Firstly, let's try to find some necessary conditions for a Fish Subgraph to exist. Because the Fish Graph has a cycle with two extra edges attached, the original must contain a cycle with a node in the cycle having degree at least 4. It turns out this condition is actually sufficient, let's prove this:

So, assume a graph contains a cycle, and one of the nodes in the cycle has deg(u)≥4 . We will only look at this cycle, and two extra edges connected to the special node that are not cycle edges, and remove all the other edges from consideration.

These two extra edges could have both endpoints inside the cycle, creating diagonal(s) and not the fins of the Fish Graph we want. If both edges don't form diagonals of the cycle, we've found a Fish Graph. Otherwise, let's label the nodes in the cycle v1v2…vk , and label the two extra edges e1 and e2 . Look at the diagonal that connects nodes v1 and vd , with d>2 as small as possible. Using it, we find a smaller cycle v1v2...vd . To finish the proof, we notice that one of the edges from {e1,e2} and the edge v1vk now have become free to use as fins of the Fish Graph, as they are no longer diagonals of the smaller cycle. □ This proof can be turned into an algorithm solving the problem.

First off, we need to find any cycle with a node with degree ≥4 . Let's brute force the node u , which must have degree ≥4 . Then brute force the first edge of the cycle uv (by looping over the adjacency list of node u ). Now to find any cycle, it suffices to find a path from v to u , temporarily deleting the edge uv . This can be done with DFS or BFS. When a cycle is found, all edges except 2 extra edges can be removed from consideration, and the proof for sufficiency can be implemented to fix possible diagonals. For BFS it is even easier, because it already finds the shortest path from u to v , making diagonals impossible. The time complexity will be O(m⋅(n+m)) , because the algorithm loops over all edges, and does a graph traversal for each of them.

Bonus: How do you make this algorithm O(n+m) ?

Solution 1817C - Similar Polynomials

Problem idea: adamant Preparation: adamant

Editorial 1817C - Similar Polynomials Not that if polynomials are equivalent, they must have the same leading coefficient k .

Let A(x)=⋯+axd−1+kxd and B(x)=⋯+bxd−1+kxd . Then

B(x−s)=⋯+(b−ksd)xd−1+xd. So, if A(x) and B(x) are equivalent, then A(x)≡B(x−s) , where a=b−ksd , or s=b−akd .

General remark. On a more intuitive level, you can perceive s as the value by which you should shift the argument of A(x) , so that the sums of roots of A(x) and B(x) coincide, as the coefficient near xd−1 is just the negated sum of roots of the polynomials.

Lagrange interpolation approach. Generally, if f(x0)=y0,…,f(xd)=yd , it is possible to represent f(x) as

f(x)=∑i=0dyi∏j≠ix−xjxi−xj. From this, it is possible to find the coefficients near xd and xd−1 , that is a sum of corresponding coefficients in each individual summand. Altogether it sums up as

[xd]f(x)=∑i=0dyi∏j≠i1xi−xj=∑i=0dyi∏j≠i1i−j=∑i=0dyi(−1)d−ii!(d−i)! Let's denote ci=(−1)d−ii!(d−i)! , then it simplifies a bit as

[xd]f(x)=∑i=0dyici, and for the coefficient near d−1 we should note that [xd−1](x−x1)…(x−xn)=−(x1+⋯+xn) , thus

[xd−1]f(x)=−∑i=0dyici∑j≠ij=−∑i=0dyici(d(d+1)2−i). Knowing the coefficients near xd and xd−1 for both A(x) and B(x) , it is easy to find a=[xd−1]A(x) , b=[xd−1]B(x) and k=[xd]A(x)=[xd]B(x) , which in turn allow us to compute s with the formula above.

Finite differences approach. You can consider adjacent differences in values ΔA(i)=A(i)−A(i+1) . The result ΔA(i) is a polynomial in i that has a degree d−1 . Taking the differences d−1 times, we get the values of Δd−1A(x) and Δd−1B(x) in x={0,1} . On the other hand, Δd−1B(x)=Δd−1A(x+s) , so you still need to find s , but Δd−1A(x) and Δd−1B(x) are the polynomials of degree 1 , which makes the whole problem trivial.

Note: To compute Δd−1A(0) and Δd−1A(1) in O(d) , one can use the binomial formula:

ΔkA(x)=∑i=0k(−1)i(ki)A(x+i). Indeed, if we denote by S an operator such that SA(x)=SA(x+1) , then

ΔkA(x)=(I−S)kA(x)=∑i=0k(−1)i(ki)SiA(x)=∑i=0k(−1)i(ki)A(x+i). Solution 1817D - Toy Machine

Problem idea: adamant Preparation: jeroenodb

Editorial [problem:1817D] Instead of caring about the positions of all the toys, we only need to care about the position of the special toy with index k . The other toys can be treated as undistinguishable.

The intended way of solving this problem is playing the game in the webpage, trying to come up with some simple combinations of operations that make the special toy move to another position in a predictable way. Using these building blocks in a smart way, finding a way to move the special toy to the topleft.

As the size of the grid can be up to 100000 and we can make 1000000 moves, we will be aiming for a solution which does a linear number of moves.

There are lots of potential solutions which use a linear number of moves, here is a relatively painless one:

Do casework on k :

- Case 1 : If 1≤k<n−12 , we initally make one R button press to align the toys with the right boundary. After this, there is an easy pattern to expose all the toys in the left halve, one by one: DRURDRUR... repeated. When the special toy is exposed, the repeating pattern is stopped, and DL are pressed. Toy k will be moved to the topleft corner.

- Case 2 : If k=n−12 , the puzzle can be solved in two moves: DL.

- Case 3 : If n−12<k≤n−2 , we try to reduce back to case 1 , by moving the special toy to the left halve, and ensuring that all other toys are in the top row. Using symmetry, we can apply case 1 to k′=n−1−k , but mirror all horizontal moves, to move the toy to the topright corner. The other toys are no longer all in the top row. To fix this, the last pattern we need is again DRURDRUR... repeated. After a while of repeating this, all toys will be in the right halve of the board, occupying the top and bottom row. To finish moving the special toy (which stayed in the topright corner), we do the buttons presses LDRU. All toys end up in the top row, and the special toy will be at position knew=n−12−1 , so this successfully reduces to case 1 .

How many moves does this take? In case 1 the pattern DRUR needs to be repeated at most ≈n2 times. In case 3 , we need to use the first pattern n2 times, and we use the second pattern n2 times. We reduce down to case 1 , but luckily the special toy is already close to the correct position, so only a constant number of extra moves are done.

So in total, this solution uses O(1)+max(4n2,4⋅2n2)=4n+O(1) moves. SO this solution fits well within the constraints, although it is pretty wasteful.

Bonus: Can you prove that the optimal number of moves needed in the worstcase (over all k ) for a width of n is Ω(n) ? We only did some testing of small cases, with a bruteforce BFS solution, and found that the worstcase is around n/2 button presses.

Solution 1817E - Half-sum

Problem idea: adamant Preparation: adamant

Editorial [problem:1817E] Similar to the Huffman encoding, the process described in the statement can be represented as constructing a tree, in which on every step we take two trees with weights a and b , and connect them with a shared root into a single tree with weight a+b2 .

In the end of the process, we have two trees with weights A and B , and we want to maximize |A−B| . In these trees, let hi be the height of the leaf corresponding to ai . Then ai contributes to the final answer with the coefficient either 2−hi , or −2−hi , depending on which tree it is in.

If we fix any set {h1,…,hn} and would need to distribute a1,…,an between the heights, assuming A<B , it would always be better to send smaller numbers to the A -tree and bigger numbers to the B -tree, so that the positive impact belongs to bigger numbers and the negative impact belongs to the smaller numbers. That being said, if a1≤a2≤⋯≤an , it is always optimal to choose a number 1≤k<n and send a1,a2,…,ak to the A -tree, while sending ak+1,ak+2,…,an to the B -tree. Now we need to understand, how to pick an optimal k and how to construct optimal trees with a fixed k .

Assume that a1,a2,…,ak will all go to the A -tree, for which we want to minimize the weight. What is the optimal distribution of h1,h2,…,hk ? Turns out, there always exists an optimal configuration, in which the constructed tree is very skewed, in a way that each vertex has at most 1 child that is not a leaf.

Indeed, consider a vertex v which has two children L and R , both of which have children of its own. Let x be a leaf with the smallest weight in the whole sub-tree of v (without loss of generality, assume that it's a descendant of L ). If we swap x with R , we will effectively swap coefficients with which x and R contribute to the weight of A overall.

In other words, if the initial contribution was 2−hx⋅x+2−hR⋅R , it will become 2−hx⋅R+2−hR⋅x . Note that x≤R and hx>hR . As a consequence, the later sum is not worse than the former and it's always optimal to swap x and R due to the rearrangement inequality.

Similar argument works for the tree B , except for we want to maximize sum in it, rather than minimize it.

With this in mind, if the split is a1,a2,…,ak and ak+1,ak+2,…,an , then the heights are 1,2,3,…,k−2,k−1,k−1 for the first block, and similar (but reversed) for the second block. This allows us to find a specific value of |A−B| for each specific k in O(n) .

How to improve from that? We suggest two possible approaches here.

Divide and conquer approach. Assume that the optimal k belongs to the interval [l,r] . In this case, all numbers outside the interval will have the same coefficients regardless of specific k , as long as k itself is from the interval. This means that we can solve the problem with divide and conquer approach:

Let m=⌊r−l2⌋ ; Find best k recursively on [l,m] and [m,r] ; Compare them on the whole [l;r] , and return the best of them. Which makes overall O(nlogn) complexity.

Alternative approach. Let's compare the distribution of coefficients for |A|=k and |A|=k−1 :

|A|=k −a12−1 −a22−2 … −ak−22−(k−2) −ak−12−(k−1) −ak2−(k−1) ak+12−(n−k−1) ak+22−(n−k−1) … an−12−2 an2−1 |A|=k−1 −a12−1 −a22−2 … −ak−22−(k−2) −ak−12−(k−2) ak2−(n−k) ak+12−(n−k) ak+22−(n−k−1) … an−12−2 an2−1 As you see, almost all coefficients stay the same, except for coefficients near ak−1 , ak and ak+1 :

|A|=k |A|=k−1 ak−1⋅□ −2−(k−1) −2−(k−2) ak⋅□ −2−(k−1) 2−(n−k) ak+1⋅□ 2−(n−k−1) 2−(n−k) Therefore, let f(k) be the optimal answer for |A|=k , and let α=k−1 , β=n−k we may say that

f(k)−f(k−1)=(ak+1−ak)2−β−(ak−ak−1)2−α. Or, multiplying it with 2n we get

2n[f(k)−f(k−1)]=(ak+1−ak)2k−(ak−ak−1)2n−k+1. We can sum it up to get the difference between f(k) and f(j) for arbitrary j<k :

2n[f(k)−f(j)]=(dk2k+⋯+dj+12j+1)−(dk−12n−(k−1)+⋯+dj2n−j), where di=ai+1−ai . Then, assuming dk>0 , we can bound it as

2n[f(k)−f(j)]≥2k−2n−jmaxdi=2k−2n−j+logmaxdi. The later means that f(k)>f(j) when k+j>n+logmaxdi , which is the case when k>n2+logmaxdi and j≥n2 . By the same argument, we may show that f(k)>f(j) when k<n2−logmaxdi and k<j<n2 . In other words, it means that one of the following holds for the value k , on which the maximum value of f(k) is achieved:

k is the first position in the array, at which dk=ak+1−ak>0 , k is the last position in the array, at which dk=ak+1−ak>0 , k belongs to the segment [n2−logmaxdi,n2+logmaxdi]⊂[n2−30,n2+30] . Therefore, there are at most 64 positions of interest in the array which can be checked manually. Moreover, optimal value in the segment [n2−30,n2+30] can be found by checking every possible position while ignoring all the elements outside of the segment (due to the result from the divide and conquer approach). This allows, assuming a1≤a2≤⋯≤an , to resolve the problem in O(n) .

Solution 1817F - Entangled Substrings

Problem idea: adamant Preparation: adamant

Editorial [problem:1817F] Suffix automaton approach. For every substring a of s we can define the longest string a^ such that a only occurs in s as a specific substring of a^ . To find a^ , we find the longest strings x and y such that the occurrences of a are always preceded by x and always succeeded by y . Then, we can say that a^=xay .

If you're familiar with suffix structures you would recognize that in this terms, xa is the longest string that belongs to the same state of the suffix automaton of s as a . Knowing that, how would we find a^=xay ? When we add a new character at the end of a substring, we make a transition in the suffix automaton via this character.

Generally, if the state of the string xa has transitions via two different characters, it would mean that the string y is empty, as it means that different strings may succeed the occurrences of xa . Also, if the state is terminal, it would mean that the last occurrence of xa is at the suffix of s and it can not be succeeded by any non-empty string. If the state is not terminal, and its only transition is by a character c , it means that the string xa is always succeeded by c .

The facts above mean that to find xay , we may start with the state of the suffix automaton that corresponds to the string a , and then, while the state is non-terminal, and it only has a single out-going transition, we move to a next state via this transition. In the end, xay would be the longest string of the state we ended up in.

Now back to the problem. Note that if a string a only occurs in s as a substring of another string t , it means that a^=t^ . In terms of the strings a , b and c from the statement it means that a^=b^=acbˆ .

Assume that we grouped together the states of the suffix automaton that end up in the same state if you follow unique out-going transitions from them until you get into a state with two possible transitions, or a terminal state. Each group corresponds to a unique largest string such that any string that belongs to any state from the group only occurs in s as a specific substring of the largest string.

Note that for strings that belong to the same state of the suffix automaton, they also have the same string y . The length |y| determines the unique position in which all the strings from the state occur in the largest string as set of nested suffixes. So, for the largest string t , their right position of occurrences will be |t|−|y| , and their lengths form the contiguous segment [len(link(q))+1,len(q)] . Thus, the whole problem reduces for each group of states to the following:

We have a bunch of triplets (l1,l2,r) . Each triple denotes a set of segments [l1,r],[l1+1,r],…,[l2,r] . You need to count the number of non-overlapping pairs of segments. This can be done in O(nlogn) with the help of segment tree.

Suffix array approach. There is an alternative solution using suffix arrays (suggested by Dario).

Let a0,…,an−1 be the suffix array and b0,…,bn−2 be the longest common prefix of adjacent elements of the suffix array.

We say that [l,r] is good for length len if the positions a[l,r] are exactly the occurrences of a sub-string of length len . This is equivalent to bl−1,br<len and bi≥len for all l≤i<r . There are at most O(n) good intervals (an interval is good if it is good for any length). Indeed they are a subset of the sub-trees of the Cartesian tree of the array b . Now we iterate over the good intervals. Let [l,r] be a good intervals for the lengths [u,v] . Consider a translation t and check if by adding t to all elements al,al+1,..,ar one gets a good interval. This can be checked in O(1) . This check can be done from t=u to t=v and one can stop as soon as a bad t is found. If t is a good translation; then we can count in O(1) the corresponding good pairs of sub-strings A,B . And this concludes the problem. It remains to perform quickly step 3. Given two good intervals I,J we say that J follows I if a[J] coincides with the array one obtains adding 1 to all elements of a[I] . The "following" relationship creates a family of chains on the good intervals. One performs step 3 independently on the various chains. Solution

Codeforces Round #868 (Div.2) Editorial

By Igor_Parfenov, history, 3 hours ago, In English 1823A - A-characteristic

Editorial [problem:1823A] Note that the A -characteristic depends only on the number of 1 -s. Let the number of 1 -s be equal to x , then the number of −1 -s is equal to n−x , and the A -characteristic is equal to f(x)=(x−1)⋅x2+(n−x−1)⋅(n−x)2 .

Let's iterate over all x from 0 to n , and check if there is such x that f(x)=k . Then print x numbers 1 and n−x numbers −1 .

Solution C++ Solution Python 1823B - Sort with Step

Editorial [problem:1823B] Let's fix a number 0≤x<k and consider all indices i such that imodk=x . Note that numbers in these positions can be reordered however we want, but they can't leave this set of positions, since imodk stay the same. Moreover, in the sorted permutation these positions must contain numbers j such that (j−1)modk=x . In total, itm means that the permutation can be sorted if (p[i]−1)modk=imodk holds for all i .

By preliminary exchange, we can swap two elements from different sets. Therefore, if the last equality fails for exactly two elements, they can be swapped, making sorting possible. Otherwise, the answer is −1 .

Solution C++ Solution Python 1823C - Strongly Composite

Editorial [problem:1823C] Let's understand criteria for a number x being strongly composite. Let's factorize the number x=p1d1⋅p2d2⋅⋯⋅pmdm . The number of all divisors of x is D=∏i=1m(di+1) .

Since the number of prime divisors is m , then the number of composite divisors of x is D−m−1 . Then a number x is strongly composite if m≤D−m−1 or 2⋅m+1≤D . Since m is the number of di+1≥2 , then D≥2m .

Consider a weakened condition for a strongly composite number: 2⋅m+1≤2m . If m=1 , then the condition is satisfied only if d1≥2 . If m=2 , then the condition is satisfied only if max(d1,d2)≥2 . If m≥3 , then the condition is always satisfied.

In summary, a number is not strongly composite if it is either a prime or the product of two distinct primes.

Now let's solve the problem. Let's split all numbers into primes. Assume we have pairs (pi,ci) , where pi is a prime number and ci is the number of its occurrences. We can take either two same prime numbers or three of any prime numbers.

The optimal strategy is to create the maximum number of pairs of same prime numbers ∑i⌊ci2⌋ , and when there will be only r=∑i(cimod2) different prime numbers remaining. We can merge these remaining primes in triples to get extra ⌊r3⌋ strongly composite numbers.

If, after merging triples, we have some primes left, we can add them to any already strongly composite number, and it won't change its total number.

Solution C++ Solution Python 1823D - Unique Palindromes

Editorial [problem:1823D] Let us estimate the possible number of unique palindromes P :

for n=1 : P=1 ; for n=2 : P=2 (in both cases: if symbols are equal and if not); for n≥3 : 3≤P≤n . Any combination of the first three characters gives P=3 . If you add a character to the string, P will increase by either 0 or 1 . This can be proven by contradiction. Assume Pnew−Pold≥2 . Choose 2 of any new palindromes. The shorter one is both a suffix and a prefix of the larger one (since both are palindromes), but we've added all the palindromes. So the smaller one was added earlier. An example of a string with P=3 : abcabc.... An example of a string with P=n : aaaaaa.... For solving the task for only one condition k=1 , let's combine the ideas: let's build a string aaa...aaabcabc... By choosing the prefix of appropriate length that consists of a characters, we can achieve all the values of 3≤P≤n . Print k−3 characters a and then characters abc until the end of the string.

Let solve the initial task for k>1 conditions. Firstly, we build the answer for the first condition. After that, assume we have answer for first t conditions. If ct+1−ct>xt+1−xt , then we can't build an answer by lemma. Otherwise, we can do the following: take a symbol, that wasn't used and append it ct+1−ct times to answer; then append symbols ...abcabca.... The final string will look as following, where | symbol shows conditions boundaries:

aaaaaaaaabcabcab|dddddcabcabca|eeebcab Note that, in order not to create unnecessary palindromes, if we finished the previous abcabc... block with some character (for example, a), the next abcabc... block should start with the next character (b).

Solution C++ Solution Python 1823E - Removing Graph

Editorial [problem:1823E] The solution requires knowledge of the Sprague-Grundy theory. Recall that a⊕b means the bitwise exclusive or operation, and mex(S) is equal to the minimum non-negative number that is not in the set S .

The fact that l≠r is important.

The given graph is a set of cycles, and the game runs independently in each cycle. If we can calculate nim-value for a cycle of each size, then nim-value of the whole game is equal to XOR of these values.

To calculate nim-value for the cycle of length x (cycle[x] ), we need to take mex of nim-values from all transitions. But since all transitions transform a cycle to a chain, then we will calculate nim-values for chains as well, or cycle[x]=mex(chain[x−r],chain[x−r+1],…,chain[x−l]) .

To calculate nim-value for the chain chain[x] , we need to consider all possible transitions. We can either cut off from the end of the chain, or from the middle of the chain. In either case, we end up with two smaller chains (maybe one of them is empty), which are themselves independent games, so chain[x]=mex{chain[a]⊕chain[b]∣∀a,b≥0:x−r≤a+b≤x−l} .

Implementing this directly requires O(n3) time. A more accurate implementation with recalculations requires O(n2) time. For a complete solution, something needs to be noticed in nim-values.

Consider an example. Let l=4 , r=14 .

index	0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19 chain 0	0	0	0	1	1	1	1	2	2	2	2	3	3	3	3	4	4	4	4 cycle 0	0	0	0	1	1	1	1	2	2	2	2	3	3	3	3	4	4	0	0 ↑ l+r chain[x] on [0,l−1] is obviously equal to 0 ; chain[x]=⌊xl⌋ on segment [0,r+l−1] (proof is below); chain[x]>0 for all x≥l : since l<r you can always split the chain x in two equal chains a . This transition adds nim-value chain[a]⊕chain[a]=0 into mex , that's why chain[x]=mex{…}>0 . cycle[x] is equal to chain[x] up to r+l−1 : it's because cycle[x] is equal to mex{chain[0],chain[1],…,chain[x−l]} ; cycle[x]=0 for x≥l+r , it's because chain[x]>0 for x≥l . So, if x≤r+l−1 , then cycle[x]=⌊xl⌋ , otherwise cycle[x]=0 . We have to calculate the sizes of all cycles in the graph and calculate XOR of those values. If it is zero, the winner is Bob, otherwise, winner is Alice.

Let's prove that chain[x]=⌊xl⌋ on segment [0,r+l−1] :

chain[x]≥⌊xl⌋ : there are transitions to pairs of chains (a,b) where a=0 and b is any number from [0,x−l] . Their nim-value is equal to chain[0]⊕chain[b] = chain[b] , so chain[x]≥mex{chain[b]∣0≤b≤x−l}=⌊xl⌋ . chain[x] is exactly equal to ⌊xl⌋ : we can prove that for any pair of chains (a,b) with a+b≤x−l value chain[a]⊕chain[b] ≤ ⌊xl⌋−1 : chain[a]⊕chain[b]≤chain[a]+chain[b]=⌊al⌋+⌊bl⌋≤⌊a+bl⌋≤⌊x−ll⌋=⌊xl⌋−1 Solution C++ Solution Python 1823F - Random Walk

Editorial [problem:1823F] Let deg(v) be the number of neighbors of vertex v . Let's fix a vertex v and its neighboring vertices c1,…,cdeg(v) . According to the linearity of the expected values: ev=∑u∈{c1,…,cdeg(v)}eudeg(u) This gives the system of equations, which, however, cannot be directly solved.

Solution by Igor_Parfenov:

Let's solve the subproblem: given a bamboo with vertices numbered in order from 1 to n , and s=1 and t=n . It is easy to see that the equation is satisfied by the expected values {n−1,2⋅(n−2),2⋅(n−3),…,6,4,2,1} .

Now let's solve the problem. Consider the path from s to t (it is the only one in the tree). The chip must go through it, but at the vertices of the path, it can go to third-party vertices. Let us represent a tree as non-intersecting trees whose roots are vertices lying on the path from s to t , and all other vertices do not lie on this path. Let's place the numbers {n−1,n−2,…,2,1,0} at the vertices of the path. Let's now fix a tree rooted at vertex v in the path, and let its number be equal to x . Then we can see that the equation is satisfied by the values of the mathematical expectation eu=x⋅deg(u) . Separately, you need to make et=1 .

Solution by adedalic:

Let's take a path from s to t and call it r0,r1,…,rk , where r0=s and rk=t . Now we will assume that each of the vertices ri form its own rooted subtree. Consider a leaf v in an arbitrary subtree: ev=1deg(p)ep , where p is the ancestor of v .

Now, by induction on the subtree size, we prove that for any vertex v in any subtree ri the expected value is ev=deg(v)deg(p)ep . For the leafs, it's obvious. Further, by the inductive hypothesis: ev=∑to≠p1deg(to)eto+1deg(p)ep=∑to≠pdeg(to)deg(to)⋅deg(v)ev+1deg(p)ep=deg(v)−1deg(v)ev+1deg(p)ep 1deg(v)ev=1deg(p)ep↔ev=deg(v)deg(p)ep .

Now consider the vertices on the path: er0=1+∑to≠r11deg(to)eto+1deg(r1)er1=1+deg(r0)−1deg(r0)er0+1deg(r1)er1 er0=deg(r0)(1+1deg(r1)er1) er1=1deg(r0)er0+∑to≠r0;to≠r21deg(to)eto+1deg(r2)er2=(1+1deg(r1)er1)+deg(r1)−2deg(r1)er1+1deg(r2)er2 er1=deg(r1)(1+1deg(r2)er2) And so on. For rk−1 we get: erk−1=deg(rk−1)(1+0)=deg(rk−1) Now let's expand: erk−2=deg(rk−2)(1+1deg(rk−1)erk−1)=deg(rk−2)(1+1)=2⋅deg(rk−2) erk−3=deg(rk−2)(1+2)=3⋅deg(rk−2) erk−i=i⋅deg(rk−i) That's all. For any vertex v in the subtree of ri we get ev=(k−i)⋅deg(v) .

Solution C++ Solution Python

Codeforces Round #867 (Div. 3) Editorial

By diskoteka, 16 hours ago, translation, In English 1822A - TubeTube Feed

Idea: diskoteka, prepared: Vladosiya

Tutorial 1822A - TubeTube Feed This problem can be solved by going through all the options of the video that the Mushroom will choose to watch.

Let the Mushroom choose the i -th video. He can view it if a[i]+i−1 does not exceed t . Since he will have to spend i−1 a second scrolling the TubeTube feed and a[i] watching the video.

As an answer, it is enough to choose a video with the maximum entertainment value from the appropriate ones.

Solution Rate the problem 1822B - Karina and Array

Idea: playerr17, prepared: playerr17

Tutorial 1822B - Karina and Array In the problem, we are not required to minimize the number of deletions, so we will search for the answer greedily.

First, let's find two numbers in the array whose product is maximal. Note that the product of this pair of numbers will be the answer, since we can remove all elements from the array except this pair, then they will become neighboring.

It is easy to see that the product of a pair of positive numbers is maximal when both numbers in the pair are maximal. So we need to consider the product of the two largest numbers. But it's worth remembering that the product of two negative numbers is positive, so the product of the two smallest numbers is also worth considering. The answer to the problem will be the maximum of these two products.

To find the two largest and two smallest numbers, you can simply sort the array. The final asymptotics of the solution will be O(nlogn) .

Solution Rate the problem 1822C - Bun Lover

Idea: diskoteka, prepared: diskoteka

Tutorial 1822C - Bun Lover Let's separate the complex chocolate layer into three simple parts.

Note that the cyan and lilac parts can be turned into polylines with links of increasing length (1,2,3…) , if the last link is 'straightene' so that it complements the penultimate one. Now it is not difficult to calculate the total length of the three parts.

The length of the light-yellow segment 1 .

Length of the cyan polyline 1+2+⋯+n=n⋅(n+1)2 .

Length of the lilac polyline 1+2+⋯+(n+1)=(n+1)⋅(n+2)2 .

Total length of chocolate (n+1)⋅(n+2)2+n⋅(n+1)2+1=(n+1)⋅(n+2)+n⋅(n+1)2+1=2⋅(n+1)22+1=(n+1)2+1 Solution Rate the problem 1822D - Super-Permutation

Idea: isosto, pavlekn, prepared: diskoteka

Tutorial 1822D - Super-Permutation Let k be the position of the number n in the permutation a , that is, ak=n , then if k>1 , then bk=(bk−1+ak)modn=bk−1 therefore, b is not a permutation, so k=1 .

Now note that if n>1 is odd, then bn=(a1 + a2 + … + an)modn=(1+2+ … +n)modn=n⋅(n+1)2modn=0=b1 . So there is no answer.

If n is even, then one possible example would be a=[n, 1, n−2, 3, n−4, 5, …, n−1, 2] , since then b=[0, 1, n−1, 2, n−2, 3, n−3, …, n2] .

Solution Rate the problem 1822E - Making Anti-Palindromes

Idea: pavlekn, prepared: pavlekn

Tutorial 1822E - Making Anti-Palindromes If n is odd, then there is no solution, since s[(n+1)/2]=s[(n+1)−(n+1)/2] .

If n is even, then all symbols are split into pairs s[i],s[n+1−i] . Let's denote the number of occurrences of the symbol c as cnt[c] .

Note that if cnt[c]>n/2 for some c , then after applying the operations there will be a pair where both characters are equal to c , then it is impossible to make the string s anti-palindrome.

Otherwise, we will calculate k — the number of pairs, where s[i]=s[n+1−i] , we will also find m — the maximum number of pairs, where s[i]=s[n+1−i]=c , for all characters c . Let x be a symbol for which the number of such pairs is equal to m . Note that ans≥m , because in one operation the number of pairs where s[i]=s[n+1−i]=x cannot decrease by more than 1 . Also note that ans≥⌈k2⌉ , because for each operation we reduce the number of pairs where s[i]=s[n+1−i] by no more than 2 . It turns out that ans=max(m,⌈k2⌉) , to show this, you can act greedily — until k>0 :

If k=m , then we find a pair s[i]=s[n+1−i]=x , since cnt[x]≤n/2 , then there is a pair where s[j]≠x and s[n+1−j]≠x . Then swap s[i] and s[j] . Otherwise, find the pair s[i]=s[n+1−i]=x , and the pair s[j]=s[n+1−j]≠x . Then swap s[i] and s[j] . It is not difficult to check that in both cases, max(m,⌈k/2⌉) will decrease by exactly 1 , which means ans is achieved with this algorithm.

Solution Rate the problem 1822F - Gardening Friends

Idea: playerr17, prepared: playerr17

Tutorial 1822F - Gardening Friends Let's first calculate its depth for each vertex. Let for a vertex v its depth is depth[v] . All the values of depth[v] can be calculated by a single depth-first search.

We introduce several auxiliary quantities. Let for vertex v the values down1[v],down2[v] are the two largest distances to the leaves in the subtree of vertex v of the source tree. We will also introduce the value up[v] - the maximum distance to the leaf outside the subtree of the vertex v .

The values of down1[v] and down2[v] are easily recalculated by walking up the tree from the bottom and maintaining two maximum distances to the leaves.

Let p be the ancestor of the vertex v . Then to recalculate up[v] , you need to go up to p and find the maximum distance to a leaf outside the subtree v . If the leaf farthest from p is in the subtree v , then you will need to take down2[p] , otherwise down1[p] .

For v , we define the maximum distance to the leaf, as dist[v]=max(down1[v],up[v]) .

Now let's calculate for each vertex v the cost of the tree if v becomes the root. It is not profitable for us to take extra steps, so the cost of operations will be equal to c⋅depth[v] . Then the cost of the tree will be equal to the value of k⋅dist[v]−c⋅depth[v] .

It remains to go through all the vertices, take the maximum of the tree values and get an answer. It is easy to see that such a solution works for O(n) .

Solution Rate the problem 1822G1 - Magic Triples (Easy Version)

Idea: pavlekn, prepared: pavlekn

Tutorial 1822G1 - Magic Triples (Easy Version) Let M=maxai , obviously M≤106 , cnt[x] — the number of occurrences of the number x in the array a .

Separately, let's count the number of magic triples for b=1 . The total number of such triples will be ∑ni=1(cnt[ai]−1)⋅(cnt[ai]−2) .

Next, we will count b≥2 . Note that ai⋅b⋅b=ak , so b≤ak/ai−−−−−√≤M−−√ . Thus, after sorting through all possible i from 1 to n , as well as all b≤M−−√ and adding cnt[ai⋅b]⋅cnt[ai⋅b⋅b] to the answer, we get a solution for O(M−−√⋅n) .

Solution Rate the problem 1822G2 - Magic Triples (Hard Version)

Idea: pavlekn, prepared: pavlekn

Tutorial 1822G2 - Magic Triples (Hard Version) Let M=maxai , obviously M≤109 , cnt[x] — the number of occurrences of the number x in the array a .

Separately, let's count the number of magic triples for b=1 . The total number of such triples will be ∑ni=1(cnt[ai]−1)⋅(cnt[ai]−2) . Next, we will count b≥2 . We will iterate over aj , if aj≥M23 , then aj⋅b=ak≤M , then b≤M13 . Otherwise, aj≤M23 , since ai⋅b=aj , then b is a divisor of aj , which means it is enough to iterate as b the divisors of the number aj , the divisors of such the numbers can be found for O(M13) , which means the total complexity will be O(n⋅M13) if you use the hash table cnt[x] , or O(n⋅M13⋅logn) if you use std::map.

Solution Rate the problem

Codeforces Round #866 (Div.1, Div.2, based on Lipetsk Team Olympiad) Editorial

By DishonoredRighteous, history, 71 minute(s) ago, In English 1820A - Yura's New Name

Author: FairyWinx

Preparation: FairyWinx

Editorial 1820A - Yura's New Name Let's see that if initial name contains "__" as a substring, we have to add character "^" between these two characters because both smiley faces start and end with character "^" and don't contain "__" as a substring. Also let's see that the resulting name have to start and end with character "^" and it's length have to be at least two.

To calculate the answer we have to count the number of indices i such that si=si+1= "_". After that we have to increment the answer if the first character of the name equals to "_" and increment the answer if the last character of the name equals to "_".

Also we shouldn't forget about the case when the initials name equals to "^" — in this case the answer equals to one.

Time complexity: O(|s|) .

1820B - JoJo's Incredible Adventures

Author: golikovnik

Preparation: teraqqq

Editorial 1820B - JoJo's Incredible Adventures First of all, consider the cases if the given string consists only of ones and only of zeros. It's easy to see that answers for these cases are n2 and 0 .

In all other cases let's split all strings into segments that consist only of ones. Also if the first and the last characters of the string equals to "1", these two characters will be in one segment. In other words, the pair of ones will lay inside one group if there exists some cyclic shift that these two ones are consecutive. Let the maximum length of such segment be equal to k . Then it can be shown that the answer equals to ⌊k+12⌋⋅⌈k+12⌉ .

We will proof this fact in such way. If there exists some rectangle of size a×b . Considering its first row, we can see that it has a+b−1 consecutive ones. But it means that a+b≤k+1 . Without loss of generality, if a≤b , we can do the following replacements: a=⌊k+12⌋−λ , b=⌈k+12⌉+λ . It means that ab=⌈k+12⌉⋅⌊k+12⌋−λ2≤⌈k+12⌉⋅⌊k+12⌋ .

Time complexity: O(n) .

1819A - Constructive Problem

Author: TeaTime

Preparation: golikovnik

Editorial 1819A - Constructive Problem Let the current value of mex equal to m and the value of mex after performing operation equals to m′ . It's easy to see that in the resulting array there should exist element equals to m+1 (if it doesn't exist, the value of mex won't be equal to m+1 ). Also notice that k should be equal to m because this value didn't appear in the array before the operation and must appear there after performing the operation. Consider the following cases.

If there exists such i that ai=m+1 , let's find the minimum value l and the maximum value r such that al=ar=m+1 . It's easy to see that the performed operation should cover these elements. We already know which value of k to select. Now notice that there are no profits from using longer segments because m′ is already not greater than m+1 (there are no elements equal to m+1 ) and longer segments may make m′ less. If there is no such i that ai=m but there exists i such that ai>m+1 , m′ is already not greater than m+1 . Similarly with the previous case, we can find any i such that ai>m+1 and replace ai with m . In all other cases if there exist two indices i≠j such that ai=aj , we can replace one of these elements with m . In this case we will make m′ equals to m+1 . If there are no such indices, m equals to the length of the array and we cannot increment m . The only thing we have to do after considering cases is to check if the performed operation leads to correct value of m′ .

Time complexity: O(nlogn) .

1819B - The Butcher

Author: Tikhon228

Preparation: Kon567889

Editorial 1819B - The Butcher Note that we know the area of the original rectangle. This value can be calculated as the sum of the areas of the given rectangles. Now let's consider two similar cases: the first cut was horizontal or the first cut was vertical. We will present the solution for the first case, the second one is considered similarly.

If the first cut was horizontal, then there exists a rectangle which width is equal to the width of the entire original rectangle. Moreover, it's easy to notice that this is a rectangle with the maximum width. Knowing the width and area, we also know the height of the rectangle we need. The only thing left is to come up with an algorithm that, for given h and w , tells us whether it is possible to construct a rectangle with such dimensions.

We will perform the following procedure: let us have a rectangle {h′,w′} for which h′=h or w′=w holds, and cut off our current rectangle with the rectangle {h′,w′} . Formally, if w′=w , we will make h−=h′ , if h=h′ , we will make w−=w′ . Note that this greedy algorithm is correct, since at each iteration we performed either a horizontal cut or a vertical cut. Thus, at each iteration of our algorithm, we should have only one option: to remove some rectangle corresponding to a vertical cut or to remove a rectangle corresponding to a horizontal cut. We can choose any of these rectangles.

Having performed this algorithm in the case where the first cut was vertical and in the case where the first cut was horizontal, we will check both potential answers.

Time complexity: O(nlogn) .

1819C - The Fox and the Complete Tree Traversal

Author: golikovnik

Preparation: DishonoredRighteous

Editorial 1819C - The Fox and the Complete Tree Traversal Note that if the tree contains the subgraph shown below, then there is no answer. To prove this it is enough to consider all possible cases for how a cyclic route can pass through the upper vertex and understand that it is impossible to construct such route.

Let's assume that the tree does not contain the subgraph shown. It is easy to see that in this case, the tree can be represented as a path and vertices directly attached to it. To check that the tree can be represented in this way, we will find the diameter of the tree and check that all other vertices are directly connected to it. Now we need to learn how to build a cyclic route.

Number the vertices of the diameter from 1 to k in the order of traversal of the diameter from one end to the other. Now let's build the route as follows. Firstly, visit vertex 1 , then visit all vertices not on the diameter attached to vertex 2 , then move to vertex 3 , then to all vertices not on the diameter attached to vertex 4 , and so on. When we reach the end of the diameter, we will visit all vertices of the diameter with even numbers, as well as all vertices of the tree not on the diameter attached to the vertices of the diameter with odd numbers. Now let's make the same route in the opposite direction along the diameter, but through vertices of a different parity, which reaches vertex 2 .

Time complexity: O(n) .

1819D - Misha and Apples

Author: Um_nik

Preparation: dshindov

Editorial 1819D - Misha and Apples In this problem, we need to choose which types of apples will be sold in stores with ki=0 . Let's fix some arrangement of apples and consider the last moment in it when the apples disappeared from the backpack. All the apples that we took after this moment will go into the final answer, and if there was also a store with ki=0 among these stores, then the answer is equal to m .

Depending on the arrangement of apples, the moments of the last zeroing may change, so let's find all such moments of time after which disappearance may occur, and for all such moments, let's check if we can reach the end without zeroing, and if we can, then what is the maximum number of apples we can collect after that.

Formally, let's calculate canZeroi for all 0≤i≤n , equal to 1 if there is such an arrangement of apples that after purchases in stores on the segment [1,i] , the backpack will be empty, and 0 otherwise, with canZero0=1 . Also, let's calculate maxRemaini for all 0≤i≤n , equal to 0 if after passing on the segment [i+1,n] with an initially empty backpack, we are guaranteed to empty the backpack at least once, otherwise equal to m if there is a store with ki=0 on this segment, otherwise equal to the total number of apples on this segment, with maxRemainn=0 .

The second array is easily calculated by definition. Let's consider one of the ways to build the first array. We will build it from left to right. If ki=0 , then we can guarantee that the backpack will be empty after this store, so the value of canZeroi for such i is 1. Otherwise, consider all the apples in this store. After the i -th store, the apples will disappear if one of these apples was already in the backpack before. Let's find the maximum such j<i that the store j contains one of the apples in the store i , or kj=0 . Now let's find the maximum such s<j that canZeros=1 . Then we check that there will be no disappearances on the segment [s+1,j−1] . In this case, canZeroi=1 , otherwise it is equal to 0.

Then the answer will be maxcanZeroi=1maxRemaini .

Time complexity: O(n) .

1819E - Roads in E City

Author: Tikhon228

Preparation: grphil

Editorial 1819E - Roads in E City Let's consider city as a graph. We will call an edge good if the road is repaired, and bad if the road is not repaired.

Since we know that we can reach any vertex from any other vertex using good edges, we will find the minimum spanning tree of the graph built on good edges. To do this, we will iterate through the edges one by one and check if the graph remains connected by good edges after removing that edge. If the graph remains connected, we will remove the edge. After this actions, only the good edges that form the minimum spanning tree of the graph will remain.

Let's find out how to check if the graph remains connected after removing an edge. Suppose we are trying to remove an edge between vertices A and B . If the graph remains connected after removing this edge, then the answer to any query will be 1 . Otherwise, the graph will be divided into 2 connected components. Let the starting vertex for the next query be S . This vertex will be in one of the two connected components. If we choose a random vertex from A and B as the finishing vertex, there will be no path between the starting and finishing vertices using good edges with probability 1/2 . Therefore, if we make 45 such queries, then with probability 1/245 , start and finish will be in same components for all queries. In the remaining cases, there will be no path at least in one query, which will indicate that the graph will no longer be connected by good edges after removing the edge.

This way, we can obtain the minimum spanning tree in m⋅47 queries.

After obtaining the minimum spanning tree, we will check if all other edges are good. Let's check the edge between vertices C and D . We can find a path between vertices C and D in the minimum spanning tree, remove any edge from it, and then vertices C and D will be in different connected components. After that, we will add the edge CD , and using an algorithm similar to the previous one, we will check if the graph is connected by good edges. To do this, we will ask about a random vertex C or D 45 times.

This way, we can find all other good edges in m⋅49 queries.

1819F - Willy-nilly, Crack, Into Release!

Author: teraqqq

Preparation: teraqqq

Editorial 1819F - Willy-nilly, Crack, Into Release! There are two ways to approach this problem. Let's start with a solution that does not involve associations with known images. Consider a cyclic sequence of strings that satisfies the condition of the problem. Consider the longest common prefix of all the strings in this sequence. It is not very interesting to us, since by definition it does not change with the operations.

There are two cases. Either the sequence of operations has a length of 2 , when we perform some action and then immediately "cancel" it with a second action. This case is only possible if there are no more than two important strings in the set. In this case, the required condition can be easily checked in O(n) time.

Otherwise, our sequence consists of more than two operations and this is much more like a cycle. Let's say, for example, that the first non-constant character in the sequence of strings initially equals "a". Then after the first change it will be equal to either "b" or "d". Note that after this the first character will no longer be able to immediately turn into "a", since the only way to do this is to "cancel" the operation …acccc…c→…caaaa…a , but this is only possible in the first case. Thus, the first character will be required to go "around the cycle" abcda . This cycle can be divided into four segments based on the value of the first character of the string. In each of these segments, we are interested in the sequence of operations that transforms the string with the suffix zx…x into a string that matches the original in the prefix, but its suffix is zy…y , where x≠y≠z≠x and the pair of characters {x,y} is "good".

With the help of a not very complicated analysis of cases, we can see that for each prefix we are interested in 6 groups of paths that connect strings whose characters, except for the suffix being considered, match, and these paths visit all important strings with the prefix being considered. Within each group of paths, we are interested in the minimum and maximum path, respectively. Note that these values can be easily calculated using dynamic programming. We can calculate all these states in O(4n) time. Then we need to iterate over the length of the common prefix of all the strings and answer the query in O(n) time.

So far, we can only calculate the states of interest to us in some galactic time. But this is not entirely scary! Let's say, for example, that when we add or remove one string from the set of important strings, only O(n) states change, since only the states responsible for the prefixes of the added/deleted string s will change. To some extent, this is reminiscent of a segment tree, or rather, a quadtree.

We just need to figure out how to get rid of the O(4n) term in the asymptotic complexity. But this is also simple. Let's notice that if there are no strings with the given prefix in the set of important strings, then the states responsible for this prefix will depend only on the length of the remaining suffix, and all these values can be precomputed in O(n) time. Thus, we store a trie with strings from the queries, in each node of which we store the state of the dynamic programming, and in case we need the values of the dynamic programming from non-existent trie nodes during recalculation, we can replace them with precomputed values.

Time complexity: O(nq) .

The author's code is not very complicated, but if you suddenly want to understand it, I warn you that it uses several "hacks" of questionable justification. For example, instead of 6 dynamic programming states, only 3 really useful ones are stored there. The combinatorial structure MinMaxValue is used to simplify the support of simultaneous maximum and minimum values, and much more. I think that it will be especially useful for beginners to familiarize themselves with how to simplify their lives in implementing combinatorial problems.

Now let's turn to the geometric interpretation of the problem. Imagine a square with a size of (2n−1)×(2n−1) . In its corners, we can draw squares with sizes of (2n−1−1×2n−1−1) each. Let's say that strings starting with the character a go to the upper-left square, strings starting with the character b go to the upper-right, the character c corresponds to the lower-right corner, and the character d corresponds to the lower-left. Then we can divide the four resulting squares into four parts each in the same way and divide the strings by corners already by the second character, and so on. In the end, each string is associated with an integer point with coordinates from the interval [0,2n−1] . We also have lines from the drawn squares, which are naturally divided into vertical and horizontal segments of length 1 each.

This picture is useful because it depicts a graph whose vertices correspond to the strings being considered, and its edges connect pairs of strings that are obtained from each other by means of one move. Thus, looking at the picture, much of the structure of simple cycles in the problem being considered becomes clear and obvious, and with the help of such a picture it is much easier to describe the transitions in the dynamic programming and not get confused.

Editorial of Codeforces Round #865

By culver0412, history, 17 hours ago, In English Thanks for participating, and happy Easter!

1816A - Ian Visits Mary Editorial Let us show that Ian can get to Mary within two moves. Indeed, consider (x1,y1) and (x2,y2) where x2−x1=1 , since the value of the x -coordinates of a point lying on the segment joining (x1,y1) and (x2,y2) , and is not at the endpoints, is strictly between x1 and x2 , but there are no integers strictly between x1 and x2 , the point must not be a lattice point. Similarly, no lattice points lie on the segment joining (x1,y1) and (x2,y2) with y2−y1=1 except for the endpoints. Therefore, Ian can jump from (0,0) to (x−1,1) to (x,y) .

Implementation Remark 1816B - Grid Reconstruction Hint Editorial Observe that ai,j will be added if (i+j) is odd, and will be subtracted otherwise. This forms a checkered pattern.

Obviously, it is optimal for all values that will be added to be strictly larger than all values that will be subtracted. Also, the difference between the value of adjacent grids should be \textit{almost} equal (by some definition of \textit{almost}).

We construct array a as follows:

a1,1=2n−1 and a2,n=2n For 2≤i≤n and i is even, a1,i=i and a2,i−1=i−1 For 2≤i≤n and i is odd, a1,i=n+i−1 and a2,i−1=n+(i−1)−1 For example, when n=10 , the output will be

19 1 11 3 13 5 15 7 17 9 2 12 4 14 6 16 8 18 10 20 Proof Implementation Question 1815A - Ian and Array Sorting Hint 1 Hint 2 Editorial We consider the difference array bi=ai+1−ai (1≤i≤n−1 ). Then the original array is non-decreasing if and only if all elements of the difference array is non-negative. We can see that either bi is increased by 1 and bi+2 is decreased by 1 or vice versa for 1≤i≤n−3 , b2 is increased or decreased by 1 or bn−2 is increased or decreased by 1 .

If n is odd, then n−2 is odd. What we can do is to increase b2 and bn−2 enough number of times, and then do bi increase by 1 and bi+2 decrease by 1 or vice versa enough times to distribute the values to other elements of b . Doing this, we can make all of the elements of b non-negative, which is what we want. So we output 'YES' no matter what for odd n .

For even n , n−2 is even. So by increasing b2 and bn−2 enough number of times, then distributing, we can only ensure that the elements of b with even indices are non-negative. Since the only operation that affects odd indices is increasing bi by 1 and decreasing bi+2 by 1 or vice versa, we can see that the sum of the elements of b with odd indices will not change. If the sum of the elements of b with odd indices is at least 0 , we can distribute the values such that in the end, all of them are non-negative, so we should output 'YES'. But if the sum of elements of b with odd indices is negative, there must exist a negative bi in the end, and we should output 'NO'.

Implementation 1815B - Sum Graph Hint 1 Hint 2 Editorial There are many ways to solve this problem. My original solution is rather difficult to implement correctly, and a bit complicated. During round testing, tester rsj found an alternative solution, which is, in my opinion, one that's a lot easier to understand and implement.

Firstly, use a type 1 operation on x=n+1 and x=n+2 (or you can do x=n and x=n+1 ). Then, the graph should look like a chain (e.g. when n=6 , it should look like 1−6−2−5−3−4 ). Note that there are actually two edges between each pair of directly connected nodes, but it is irrelevant to the task.

Next, use a type 2 query on all pairs of (1,i) where 2≤i≤n . Take the maximum of the query results. Let k be one of the values such that the query result of (1,k) is maximum among all (1,i) . It is easy to see that, node pk is one of the endpoints of the chain.

Afterwards, use a type 2 query on all pairs of (k,i) where 1≤i≤n and i≠k . Since node pk is an endpoint of the chain, all the query results are distinct and you can recover the exact node that each query result corresponds to.

A problem arises that it is unclear about which endpoint node pk actually is. But this issue can be solved easily: since the problem allows outputting two permutations that can be p , just try both endpoints and output the corresponding permutations.

In total, 2 type 1 operations and 2n−2 type 2 operations are used, which sums up to 2n operations. As stated in the sample description, you don't even need any operations when n=2 . It is also easy to see that the actual number of operations required is 2n−1 since there is a pair of duplicate type 2 operations, but we allow duplicating the operation anyway.

Implementation 1815C - Between Editorial Construct a graph with n vertices and add a directed edge a→b if between every two a there must be a b .

Let va be the number of occurrences of a . The key observation is that if a→b , then va≤vb+1 .

Suppose ak→ak−1→⋯a1 is a directed path, where a1=1 . Then since v1=1 , we must have vai≤i . In other words, vs≤ds . where ds is one plus the length of the shortest directed path from s to 1 .

Therefore, the total array length does not exceed ∑ni=1di . We claim that we can achieve this.

It is easy to calculate the ds by a BFS. Let Ti consists of vertices x such that vx=s . Let M the largest value of di among all i∈1,2⋯n . Consider

[TM],[TM−1][TM],[TM−2][TM−1][TM],⋯[T1][T2][T3]⋯[Tm] where for each i , vertices in various occurrences of Ti must be arranged in the same order.

It is easy to check that this construction satisfies all the constraints and achieve the upper bound ∑ni=1di . Thus, this output is correct.

The sequence can be arbitrarily long if and only if there is some v that does not have a path directed to 1 . To see this, let S be the set of vertices that do not have path directed to 1 , then the following construction gives an arbitrarily long output that satisfy all constraints:

1[S][S][S]⋯ Implementation 1815D - XOR Counting Hint 1 Hint 2 Editorial If m=1 , it is clear that we only can have a1=n so the answer is n .

If m≥3 , [x,n−x2,n−x2,0,0,...] gives a xor of x , so all x with the same parity as n and at most n can be achieved. Notice xor and sum are identical in terms of parity, and a⊕b≤a+b . So these restrict that only values of x that has same parity with n and is at most n is possible as a result of the xor. Therefore, we can use O(1) to calculate the sum of all non-negative integers at most n and have same parity as n .

It remains to handle the case when m=2 . We create the functions f(n) and g(n) , where f(n) is the sum of all possible values of the xor and g(n) counts the number of all possible values of the xor. We then consider the following:

If n is odd, then one of a1,a2 is even and the other is odd. WLOG assume a1 is even and a2 is odd. Then we let a′1=a12 and a′2=a2−12 . We can see that a′1+a′2=n−12 and a1⊕a2=2(a′1⊕a′2)+1 . Hence we know that g(n)=g(n−12) , and f(n)=2f(n−12)+g(n−12) .

If n is even, there are two cases. If a1 and a2 are both even, we let a′1=a12 and a′2=a22 . We can see that a′1+a′2=n2 and a1⊕a2=2(a′1⊕a′2) . If a1 and a2 are both odd, we let a′1=a1−12 and a′2=a2−12 . We can see that a′1+a′2=n2−1 and a1⊕a2=2(a′1⊕a′2) . Hence we know that f(n)=2f(n2)+2f(n2−1) , and g(n)=g(n2)+g(n2−1) .

So we can simply DP. It can be seen that the time complexity is O(logn) per test case, so we are done.

Implementation 1815E - Bosco and Particle Hint 1 Hint 2 Observation 1 Editorial Firstly, we can easily see that removing cycles for the oscillator strings does not affect the answer. To help us calculating the answer easier, we have to remove cycle. You can remove cycle using any fast enough string algorithm such as KMP.

It is not difficult to see that if all strings are non-periodic, then being periodic with respect to the particle position x is the same as being periodic with respect to both x and all oscillator states.

Let ai be the number of times the particle hits oscillator i when moving downwards and bi be the number of times the particle hits oscillator i when moving upwards in each cycle.

For each oscillator i , consider the case when n=1 and oscillator i is the only oscillator. Let a′i be the number of times the particle hits oscillator i when moving downwards and b′i be the number of times the particle hits the oscillator i when moving upwards in each cycle.

Then we must have ai=ka′i and bi=kb′i for some positive integer k. Also, we must have ai=bi−1 as the number of times the particle goes from oscillator i−1 to oscillator i is same as the number of times the particle goes from oscillator i to oscillator i−1 . It can be shown that the smallest integers ai and bi satisfying the above constraints must be the period.

We can calculate the the smallest such integers, by factoring each k and maintain the primes. In other words, we can separately consider the p -adic valuation of the a′i 's and b′i 's to get the p -adic valuation of ai 's and bi 's for each prime. Below is a visualisation:



Notice the answer is 2(a1+a2+...+an+bn) , which can be easily calculated. So we are done.

Implementation 1815F - OH NO1 (-2-3-4) Key Idea 1 Key Idea 2 Editorial Let's try to decide the final weights of 1 through n in this order. For a triangle a<b<c , we call a the first vertex, b the second vertex, c the third vertex. Consider each triangle individually, if we can achieve the following task then we are done: By only adjusting edges of this triangle:

There is at least one option for the first vertex After fixing a particular option for the first vertex, there are at least two options for the the second vertex After fixing particular options for the first two vertices, there are at least three options for the third vertex To see this is enough: Suppose a vertex v is in A triangles as the first vertex, B triangles as the second vertex, and C triangles as the third vertex. It is not difficult to see v have exactly B+2×C neighbours that are of smaller index, and there are at least B+2×C+1 options.

Finally, by using the following specific edge weights, the goal can be achieved:

1,4,4 gives weights 5,5,8 2,3,3 gives weights 5,5,6 3,2,2 gives weights 5,5,4 1,4,3 gives weights 5,4,7 2,3,2 gives weights 5,4,5 3,2,1 gives weights 5,4,3 These numbers aren't exactly just completely random. You can see that they are composed of two components: A (+1,−1,−1) part and a (0,0,−1) part. Upto two copies of the first option and upto one copy of the second option have been used.

There is also a simple solution in this specific case where G consists of triangles and use only weights 1,2,3.

This is a special case of 1-2-3 conjecture, which states that the above statement holds for arbitrary graph and using only the weights 1,2,3 (and no 4). Recently (March 2023) it has a claimed proof. The claimed algorithm is far from a linear time algorithm however.

Implementation (Tester: gamegame)

Codeforces Round 864 (Div. 2) Editorial

By rui_er, history, 4 hours ago, In English 1797A - Li Hua and Maze

Tutorial 1797A - Li Hua and Maze We can put obstacles around (x1,y1) or (x2,y2) and the better one is the answer. More formally, let's define a function f :

f(x,y)=⎧⎩⎨2,3,4,(x,y) is on the corner(x,y) is on the border(x,y) is in the middle Then the answer is min{f(x1,y1),f(x2,y2)} .

Without loss of generality, assume that f(x1,y1)≤f(x2,y2) . As the method is already given, the answer is at most f(x1,y1) . Let's prove that the answer is at least f(x1,y1) .

If (x1,y1) is on the corner, we can always find two paths from (x1,y1) to (x2,y2) without passing the same cell (except (x1,y1) and (x2,y2) ).

Similarly, we can always find three or four paths respectively if (x1,y1) is on the border or in the middle.

As the paths have no common cell, we need to put an obstacle on each path, so the answer is at least f(x1,y1) .

In conclusion, the answer is exactly f(x1,y1) . As we assumed that f(x1,y1)≤f(x2,y2) , the answer to the original problem is min{f(x1,y1),f(x2,y2)} .

Time complexity: O(1) .

Solution (rui_er) 1797B - Li Hua and Pattern

Tutorial 1797B - Li Hua and Pattern We can calculate the minimum needed operations kmin easily by enumerating through the cells and performing an operation if the color of the cell is different from the targeted cell. Obviously, if k<kmin , the problem has no solution.

Otherwise, there are two cases:

If 2∣n , the solution exists if and only if 2∣(k−kmin) , as we must perform two operations each time to meet the requirement. If 2∤n , the solution always exists, as we can perform the remaining operations at the center of the pattern. Time complexity: O(n2) .

Solution (rui_er) 1797C - Li Hua and Chess

Tutorial 1797C - Li Hua and Chess We can first ask (1,1) and get the result k . Obviously, the king must be on the following two segments:

from (1,k+1) to (k+1,k+1) . from (k+1,1) to (k+1,k+1) . Then, we can ask (1,k+1) and (k+1,1) and get the results p,q . There are three cases:

If p=q=k , the king is at (k+1,k+1) . If p<k , the king is at (p+1,k+1) . If q<k , the king is at (k+1,q+1) . Solution (rui_er) 1797D - Li Hua and Tree

Tutorial 1797D - Li Hua and Tree Denote Tx as the subtree of x .

The "rotate" operation doesn't change the tree much. More specifically, only the importance of Tfax,Tx,Tsonx changes. We can use the brute force method to maintain useful information about each vertex when the operations are performed.

What we need to do next is to find the heavy son of a vertex in a reasonable time. We can use a set to maintain the size and index of all the sons of each vertex.

Time complexity: O((n+m)logn) .

Solution (rui_er) 1797E - Li Hua and Array

Tutorial 1797E - Li Hua and Array Denote w=maxi=1n{ai} . Also denote φk(x)={x,φ(φk−1(x)),k=0k∈N∗ .

It can be proven that after O(logw) operations, any ai will become 1 and more operations are useless. In other words, φlog2w+1(ai)=1 .

Let's construct a tree of size w , where 1 is the root and the father of k is φ(k) . The height of the tree is O(logw) . After some precalculating, we can find the LCA of two vertices within O(loglogw) .

We can use a dsu to maintain the next not-1 element of each ai and use a segment tree to maintain the LCA, minimal depth, and answer in the range. We can brute force the changes using the dsu and meanwhile do point update on the segment tree. The queries can be solved using a range query on the segment tree.

With the potential method, we denote Φ(ai) as the minimum integer k which satisfies φk(ai)=1 . Since each successful operation on ai will decrease Φ(ai) by 1 , the maximum number of successful operations we can perform on ai is Φ(ai) . Therefore, the maximum number of successful operations is ∑i=1nΦ(ai)=O(nlogw) .

For each successful operation, we visit O(logn) nodes on the segment tree and merge the information of two subtrees for O(logn) times. Because of the time complexity of calculating LCA, We need O(loglogw) time to merge the information. So all the operations will take up O(nlognlogwloglogw) time. We need to initialize φ within O(w) time and binary lifting the ancestors on the tree within O(wloglogw) time. We also need O(lognloglogw) for each query.

In conclusion, the time complexity is O(wloglogw+nlognlogwloglogw+mlognloglogw) .

The above algorithm is enough to pass this problem. However, it has a mass number of information merging operations, so it runs quite slowly.

We use the segment tree not only to maintain the LCA, minimal depth, and answer of the ranges, but also whether Φ(lu;ru)=∑i∈[lu,ru]Φ(ai)=0 . If we enter a node whose Φ(lu;ru)=0 , we can just ignore it. Otherwise, we recursively work on the segment tree until leaf and brute force update its information.

Time complexity is the same but it's much more efficient.

Bonus: Can you solve this problem within O(mlogn) ?

Solution (rui_er) 1797F - Li Hua and Path

Tutorial 1797F - Li Hua and Path There exists an acceptable O(nlog2n+m) solution using centroid decomposition, but there is a better O(nlogn+m) solution using reconstruction trees.

The initial tree is shown in the following picture:

Consider the following reconstruction trees. We will define two reconstruction trees called min-RT and max-RT where "RT" means reconstruction tree.

For the max-RT, we enumerate vertices in increasing order. We create a new vertex u in the max-RT, then find each vertex v such that v<u and v is adjacent to u in the original tree, make u become the father of the root of v on the max-RT. We can use a dsu to build the max-RT.

The max-RT is shown in the following picture:

The property that LCA(u,v) on the max-RT is the maximum index on the path between (u,v) on the original tree is satisfied.

The min-RT is similar to the max-RT.

The min-RT is shown in the following picture:

After designing the reconstruction trees, I found out that the reconstruction trees are related to Kruskal reconstruction trees (KRT) to a certain extent. Here is another way to understand the two reconstruction trees. For the max-RT, since we want to calculate the maximum index on the path, we define the weight of an edge (u,v) as max{u,v} . We build a (minimum spanning) KRT of the original tree and merge the vertices with the same weight into one vertex. For the min-RT, define the weight of an edge (u,v) as min{u,v} and use the (maximum spanning) KRT.

The max-RT and the (minimum spanning) KRT: (left: maximum valued graph; middle: KRT; right: max-RT)

The min-RT and the (maximum spanning) KRT: (left: minimum valued graph; middle: KRT; right: min-RT)

We will solve the problem using the two reconstruction trees. Let's call the two restrictions in the statement I and II.

Denote K as the number of pairs satisfying exactly one of I and II (which is the answer), A as the number of pairs satisfying I, B as the number of pairs satisfying II and C as the number of pairs satisfying both I and II. It's obvious that K=A+B−2C .

We can easily calculate A and B using the depth of each vertex on two reconstruction trees. Due to the property mentioned above, C is the number of pairs (u,v) satisfying the condition that u is an ancestor of v on min-RT and v is an ancestor of u on max-RT, which can be solved using dfs order and Fenwick tree.

Finally, we calculated the original answer. If we add a vertex with the largest index as a leaf, paths ending with this vertex will satisfy II, so we can use min-RT to calculate the paths ending with this vertex not satisfying I and update the answer.

Time complexity: O(nlogn+m) .

Solution (Celtic, centroid decomposition) Solution (rui_er, reconstruction trees)

Codeforces Round 863 (Div. 3) Editorial

By Vladosiya, 5 hours ago, translation, In English 1811A - Insert Digit

Idea: DmitriyOwlet, prepared: DmitriyOwlet

Tutorial 1811A - Insert Digit Note that numbers of the same length are compared lexicographically. That is, until some index the numbers will match, and then the digit in our number should be greater.

Let's write out the numbers s1,s2,…si until si≥d . As soon as this condition is false or the line ends, insert the digit d .

We got the lexicographically maximum number, which means just the maximum number.

Solution 1811B - Conveyor Belts

Idea: Vladosiya, prepared: DmitriyOwlet

Tutorial 1811B - Conveyor Belts Note that the conveyor matrix n×n consists of n cycles, through each of which we can move without wasting energy. Now you need to find the distance between the cycles where the start and end cells are located. In one step from any cycle, you can go either to the cycle that is closer to the edge of the matrix, or to the cycle that is further from the edge of the matrix. It turns out that it is enough to find on which cycles there are cells on the edge and take their difference modulo.

Solution 1811C - Restore the Array

Idea: MikeMirzayanov, prepared: myav

Tutorial 1811C - Restore the Array To solve the problem, you can build an array a as follows

a1=b1 ai=min(bi,bi+1) at 2≤i≤n−1 an=bn−1 Let's show that from the constructed array a we can get an array B equal to the original array b :

B1=max(a1,a2)=max(b1,min(b1,b2)) If b1>b2 , then max(b1,b2)=b1 If b2≥b1 , then max(b1,b1)=b1 So B1=b1 Bi=max(ai,ai+1)=max(min(bi−1,bi),min(bi,bi+1)) at 2≤i≤n−2 If bi+1≥bi and bi−1≥bi , then max(min(bi−1,bi),min(bi,bi+1)=min(bi,bi)=bi If bi+1≥bi≥bi−1 , then max(bi−1,bi)=bi If bi−1≥bi≥bi+1 , then max(bi,bi+1)=bi By the construction of the array b it is not possible that bi>bi+1 and bi>bi−1 . So Bi=bi

Bn−1=max(an−1,an)=max(min(bn−2,bn−1),bn−1) If bn−2>bn−2 , then max(bn−1,bn−1)=bn−1 If bn−1≥bn−2 , then max(bn−2,bn−1)=bn−1 So Bn−1=bn−1 We get that Bi=bi for 1≤i≤n−1 , so B=b and array a is built correctly.

Solution 1811D - Umka and a Long Flight

Idea: Gornak40, prepared: Gornak40

Tutorial 1811D - Umka and a Long Flight F20+F21+…+F2n=Fn⋅Fn+1 , which can be proved by induction: Fn⋅Fn+1=Fn⋅(Fn−1+Fn)=Fn−1⋅Fn+F2n . If the partition exists, it has the form [F0,F1,…,Fn] , since the area of the rectangle with another partition will be greater than Fn⋅Fn+1 . We will cut the rectangles in the order Fn,Fn−1,…,F0 . Denote the coordinates of the colored cell at the step n as ⟨xn,yn⟩ . If Fn−1<yn≤Fn and n>1 , then there is no partition, since the square Fn at any location overlaps the colored cell. Cut off the square Fn from the right or left edge, depending on the location of the colored cell, that is, ⟨xn−1,yn−1⟩=⟨yn,xn⟩ or ⟨xn−1,yn−1⟩=⟨yn−Fn,xn⟩ . Suppose that it was advantageous to cut it not from the edge, then it is necessary to cut the rectangles z×Fn and (Fn−1−z)×Fn , where 1≤z<Fn+1−Fn=Fn−1 using the set [F0,F1…Fn−1] . Then Fn−1 will not enter the partition, but 2⋅F2n−2<(2Fn−2+Fn−3)2+1=(Fn−2+Fn−1)2+1 , so F21+F22+…+2⋅F2n−2<F20+F21+…+F2n−1=Fn−1⋅Fn=z⋅Fn+(Fn−1−z)⋅Fn . We came to a contradiction. Solution 1811E - Living Sequence

Idea: Aris, prepared: Aris

Tutorial 1811E - Living Sequence Note that any number in the sequence can be made up of 9 possible digits (all digits except 4 ). Then let's find the first digit of the answer, notice that it is just x or x+1 , where x⋅9l−1≤k (where l — the length of the number we're looking for) and x — the maximum. Note that x simply corresponds to a digit in the base-9 numeral system.

Why is this so? Because without the first digit we can assemble any numbers with 9 possible digits, and we can put the digits 0...x except 4 in the first place. Thus, in the answer, the first digit will be x if x<4 and x+1 if x≥4 .

Note that once the first digit is determined, the rest can be found the same way, since the prefix does not affect anything.

Solution 1811F - Is It Flower?

Idea: Vladosiya, prepared: Vladosiya

Tutorial 1811F - Is It Flower? Note a few things:

There are exactly k2 vertices in the k -flower, since from each of the k vertices of the main cycle comes another cycle of size k ; in the k -flower, all vertices have degree 2 , except for the vertices of the main cycle, whose degrees are 4 ; it follows that in k -flower k2+k edges; The listed properties do not take into account only the connectivity of the graph and the sizes of our k cycles. To check connectivity we run a bfs or dfs from any vertex and check that all vertices have been visited. To check the cycle lengths, we cut out the edges of the main one and make sure that the graph has fell apart into components of size k .

Solution 1811G1 - Vlad and the Nice Paths (easy version)

Idea: Vladosiya, prepared: Vladosiya

Tutorial 1811G1 - Vlad and the Nice Paths (easy version) Let's use the dynamic programming. Let dp[i][j] be the number of paths on the prefix i of j blocks of the same color. To make transitions in such dynamics, for the position i , we will iterate over the position p in which the block started. Denote as s the number of the same elements as ci and cp between them, then such a transition creates dp[p−1][j−1]⋅Csk−2 combinations. This solution works in O(n3) complexity.

Solution 1811G2 - Vlad and the Nice Paths (hard version)

Idea: Vladosiya, prepared: Vladosiya

Tutorial 1811G2 - Vlad and the Nice Paths (hard version) To solve the hard version, let's modify the simple version solution. Note that the j parameter can be discarded, since we only need paths of maximum length on each prefix. Now, as dp[i] , we denote a pair of the number of maximum paths and the number of blocks in them. For the position i , we will find the position closest to the left, from which we can start a block, and so we will find out what is the maximum for i . We will update dp[i] until the maximum of the position being sorted is suitable for us.

Solution

Editorial of Codeforces Round #862 (Div. 2)

By Alexdat2000, 6 hours ago, translation, In English Thank you for participating! We hope you enjoyed the problems!

1805A - We Need the Zero Idea and preparation: Alexdat2000

Hint 1 Hint 2 Editorial 1805A - We Need the Zero Note that (a1⊕x)⊕(a2⊕x)⊕... equals a1⊕a2⊕…⊕an if n is even, or a1⊕a2⊕…⊕an⊕x if n is odd. Then, if the length of the array is odd, you must print ⊕ of the whole array. And if the length is even, we can't change the value of the expression with our operation. It turns out that if ⊕ of the whole array is 0 , we can output any number, but otherwise there is no answer.

Solution Rate the problem 1805B - The String Has a Target Idea and preparation: Alexdat2000

Hint 1 Hint 2 Editorial 1805B - The String Has a Target At first, note that the operation should be applied only to the position of the minimal element of the string (since the 1st position in the final string should always contain the minimal letter).

Next, let the positions of the minimum letter are a1,a2,…,ak . Then we must apply the operation to the last position (ak ). Indeed, let us apply the operation to another occurrence: then the prefixes will coincide, and after that there will be a character that is equal to the minimal one if we applied the operation to ak and will not be equal to it otherwise, which contradicts the minimal string.

Solution Rate the problem 1805C - Place for a Selfie Idea and preparation: Alexdat2000

Hint 1 Hint 2 Hint 3 Editorial 1805C - Place for a Selfie Let's find the answers for the parabolas one at a time. Suppose we are given a parabola ax2+bx+c and a line kx . Then their difference is the parabola ax2+(b−k)x+c . In order for the line and the parabola not to intersect, the difference must never equal 0 , that is, the parabola ax2+(b−k)x+c must have no roots. And this is true only when the discriminant is less than 0 , that is, (b−k)2<4ac . In this case, a,b and c are given to us, and we need to choose k . (b−k)2<4ac⟹|b−k|<4ac−−−√⟹b−4ac−−−√<k<b+4ac−−−√ .

Now let us have a list of straight line coefficients sorted in increasing order. We need to check if there is a coefficient that belongs to [b−4ac−−−√;b+4ac−−−√] . To do this, check the smallest number greater than b , and the largest number less than b . If one of these numbers satisfies the condition, then we have found the answer. If not, then there are definitely no suitable coefficients, because we took 2 closest coefficients to the center of the segment.

Note that in this solution, we don't need to use non-integer numbers, which is good for both the time and the absence of errors due to precision.

Solution Rate the problem 1805D - A Wide, Wide Graph Idea: FairyWinx, preparation: Alexdat2000

Hint 1 Hint 2 Editorial 1805D - A Wide, Wide Graph Find the diameter (the longest path) in the original tree. Now if the number k is greater than the length of the diameter, then there will be no edges in the graph. Otherwise, the ends of this diameter are connected to each other, and possibly to other vertices as well. Then we can pre-calculate the answer for each k in descending order. Let's maintain the set of vertices already reachable. Then for updating the answer for k=x only vertices at a distance x from one end of the diameter can be added to the answer.

Solution Rate the problem 1805E - There Should Be a Lot of Maximums Idea and preparation: Alexdat2000

Hint 1 Hint 2 Hint 3 Editorial 1805E - There Should Be a Lot of Maximums First, find MAD of the initial tree. If each number in the tree occurs no more than once, then for each query the answer is 0 . Then, if MAD occurs at least 3 times in the tree, then for each query the answer will be MAD , because by pigeonhole principle there will be at least 2 MAD in one of the two trees.

At last, in the case where MAD occurs exactly 2 times in the tree: if the deleted edge is not on the path between two occurrences of MAD , then the answer — MAD of the whole tree. And for edges between entries, you need to maintain sets of values in each tree and traverse the edges, changing the sets accordingly.

Solution Rate the problem 1805F2 - Survival of the Weakest (hard version) Idea and preparation: sevlll777

Hints for the simple version:

Hint 1 Hint 1.1 Hint 2 Hint 2.2 Hints for the hard version:

Hint 3 Hint 4 Hint 5 Editorial 1805F2 - Survival of the Weakest (hard version) Firstly, we will sort the array a1,a2,…,an , and in the future we will always assume that all arrays in this problem are sorted.

Let's solve the problem for n≤200 .

It may seem that with such constraints, the problem is solved quite trivially: we implement the function F for O(n2logn) , and run it n−1 times to get an answer. But there is one nuance, with each iteration of F , the numbers in the array can increase by 2 times (for example, if the array consists entirely of identical numbers), which means that after only 40 operations, we may have an overflow. Note that it is impossible to take the numbers by modulo in the function F itself, since then the sorted order will be lost, and it will be impossible (or very difficult) to restore it using the remainder when dividing by 109+7 instead of the numbers themselves.

To avoid this, we note an important property of the function F :

F([a1,a2,…,an])=F([a1−x,a2−x,…,an−x])+x⋅2n−1 The intuition of this property is that if you subtract the same number from all the elements, then the relative order of the elements will not change, and will not change when using the F function. Just after the first iteration of F , 2x will be subtracted from all the numbers, then 4x , 8x , etc., in the end, the original answer will be minus x⋅2n−1 . This property can be proved more strictly by induction on n .

What does this wonderful property give us? Now we can subtract the same number x from all the elements by first adding x⋅2n−1 to the answer. It would be logical enough in any situation to subtract the minimum of the array from all its elements. Thanks to this, the minimum of the array will always be 0 , and now we can work only with arrays whose minimum element is 0 , which greatly simplifies our life. This is one of the two key ideas in this problem.

So let's notice something interesting about the array F([0,a1,a2,…,an]) .

Observation: (F([0,a1,a2,…,an]))1=a1 . The proof is obvious (let me remind you that the array is sorted).

Observation: (F([0,a1,a2,…,an]))n≤an .

Proof: since [0,a1,a2,…,an] has length n+1 , F([0,a1,a2,…,an]) has length n . Among all pairs of array elements [0,a1,a2,…,an] there are n pairs of the form 0+ai , and a1≤a2≤…≤an . This means that the original array has n pairs in which the sum is ≤an . So, observation is proved.

These two observations give us that F([0,a1,a2,…,an])=[a1,…,≤an] . And after subtracting the minimum (a1) →[0,…,≤an−a1] .

Thus, if we always subtract the minimum, each time after applying the F function, the maximum in the array will be not increase. Which allows us to work only with arrays of numbers from 0 to 109 , where there naturally can be no problems with overflow.

So, we got the solution for O(n3logn) . Let's improve it to O(n2logn) .

The cornerstone in our previous solution is that we implement the function F for O(n2logn) , which is pretty slow. Let's learn how to implement it for O(nlogn) . This is a fairly standard problem.

Note that if some pair of the form ai+aj is included in the array F([a1,a2,…,an]) , then all pairs ai+ai+1,ai+ai+2,…,ai+aj−1 will also be included in the array F([a1,a2,…,an]) , since the sum in these pairs is no more than ai+aj .

We will build the array F([a1,a2,…,an]) one element at a time, starting with the smallest. Let's denote the array in which we will add these numbers for B , initially B is empty. For each index i , we will store the minimum index ji>i such that the pair ai+aj is still not taken in B . Initially, ji=i+1 .

We will mantain all numbers of the form ai+aji in std::priority_queue. Then to add the next element to B , we will remove the minimum element from the queue, then increase the corresponding ji by one and add the element ai+aji to the queue again. After n−1 of such iteration we will get F([a1,a2,…,an]) . Each iteration takes O(logn) , which means that the asymptotics of finding the function F is O(nlogn) .

In total, we learned how to solve the problem in O(n2logn) .

Now we move on to the full solution, for n≤2⋅105 .

First we will show what the solution looks like and intuition behind it, and a more strict proof will be at the end.

Let's ask ourselves: when does the last element of the array 0,a1,a2,…,an affect the answer to the problem?

Very often we will lose any mention of the an element after the first transition: [0,a1,…,an]→F([0,a1,…,an]) .

The minimum sum of a pair of elements including an is 0+an . And there is an n−1 pair with not bigger sum: 0+a1 , 0+a2 , ..., 0+an−1 .

So the only case when an will enter the array F([0,a1,…,an]) is if a1+a2≥an , because otherwise the pair a1+a2 will be less than 0+an , and there will be n pairs with a sum less than an — n−1 pairs of the form 0+ai and the pair a1+a2 .

Well, let's assume it really happened that a1+a2≥an . Then F([0,a1,…,an])=[0+a1,0+a2,…,0+an] .

After subtracting the minimum: [0,a2−a1,a3−a1,…,an−a1] .

If we run F on this array again, we get: [a2−a1,…,≤an−a1] . After subtracting the minimum: [0,…,≤an−a2] .

But remember that a1+a2≥an . Which means 2⋅a2≥an . Which means an−a2≤an2 .

It turns out that if an somehow remains in the array after two applications of the F functions, then the last element of the array will be reduced by at least half!

This means that after just 2⋅log2an iterations of the F function, either the an element will be completely evicted from the array, or the array will shrink into [0,0,…,0] ! In both cases, the original element an in no way will be taken into account in the final answer. In no way!

The total number of times when the maximum is halved is no more than log2an , which means intuitively it is approximately clear that elements with indexes greater than 2⋅log2an will not affect the answer in any way.

Therefore, the full solution would be to leave the first K=64 elements of the array a . (a little more than 2⋅log2109 ).

Then apply the function F to this array n−K times, but writing out K minimal elements, not K−1 .

After that, the length of the real array will also be equal to K , and it remains only to run the function F K−1 times to get the final answer.

Final asymptotics: O(n⋅(KlogK)) , where K=2log2an+2≤64 .

Now let's give a strict proof that this solution works.

We are following K minimal elements —[0,a1,…,aK−1] .

Technically, there are also [aK,…,alen] elements in the array. But we have no information about their values. However, we know that all these elements are ≥aK−1 since we maintain sorted order. This means that the minimum sum of a pair of elements about which we have no information is also ≥aK−1 . The whole proof is based on this simple observation.

Firstly, it is not difficult to understand that K minimum elements are exactly enough to recalculate K−1 minimum element in F(a) . Since we have pairs of elements 0+a1 , 0+a2 , ..., 0+aK−1 . And the sum in each of these pairs is no more than aK−1 , which means no more than the sum in any pair about which we have no information.

Therefore, in any incomprehensible situation, we can recalculate with the loss of one of the elements. Let's see when it is possible to recalculate all K minimal elements.

Again, the minimum element about which we have no information from [0,a1,…,aK−1] is 0+aK≥0+aK−1 . So if we find K elements that ≤aK−1 , then we can recalculate K minimal elements of F(a) through K minimal elements of a . We have a K−1 pair of the form 0+ai , as well as a pair a1+a2 . So if a1+a2<aK−1 , then we can recalculate all K minimal elements.

And if recalculation is not possible, then a1+a2≥aK−1 is executed. Then, having encountered such a situation, we will recalculate twice with the loss of the last element, thus reducing K by 2 . After such a recalculation, the last element will be at least half as small as it was before (this is part of the main tutorial). So after 2log2(A) of such element removals, the array will slide into [0,0,…,0] and everything is clear. And if the number of removals is less than 2log2(A) , then one of the K elements will certainly live to the end, and will be the answer to the problem. Thus, the correctness of the solution has been successfully proved.

Bonus for those who are still alive: find a more accurate estimate for K and build a test on which this solution, but keeping track of the K−1 minimum element (one less than necessary), will give the wrong answer.

Solution Rate the problem

Editorial of CodeTON Round 4 (Div. 1 + Div. 2, Rated, Prizes!)

By RDDCCD, history, 27 hours ago, In English A. Beautiful Sequence

Hint Tutorial The necessary and sufficient condition for a beautiful sequence is that there exist one i , such that ai≤i . Just check the sequence for the condition.

Hint Tutorial First, we notice that after each operation, the number of candies is always a odd number. So even numbers can not be achieved.

Then consider how the binary representation changes for a odd number x , after turn it into 2x+1 or 2x−1 .

For the 2x+1 operation: …1¯¯¯¯¯¯¯¯¯ turns into …11¯¯¯¯¯¯¯¯¯¯¯¯ .

For the 2x−1 operation: …1¯¯¯¯¯¯¯¯¯ turns into …01¯¯¯¯¯¯¯¯¯¯¯¯ .

So, the operation is just insert a 0/1 before the last digit. And the answer for an odd n is just the binary representation of n , after removing the last digit.

Hint 1 Hint 2 Tutorial Firstly, we need to remove numbers such that each number appears at most once, this part of cost is unavoidable. Then, let's sort the array a1,a2…am (1≤ai<a2<⋯<am ).

Secondly, assume we enumerate the length of the permutation n . We need to remove all the ai greater than n , and insert some numbers x (x≤n ) but does not appear in the array a . We can find some i such that ai≤n<ai+1 , the cost here is simply (m−i)⋅a+(n−i)⋅b . Here, m is the length of array a , after removing the repeated numbers.

However, n can up to 109 and can not be enumerated. But for all the n∈[ai,ai+1) , the smaller n has a smaller cost. (see that (m−i)⋅a do not change, and (n−i)⋅b decreases). Thus, the possible n can only be some ai , and we can caculate the cost in O(n) in total.

Don't forget the special case: remove all the numbers and add a 1 .

Hint Tutorial The main idea is to that for each a,b,n , the possible L is a interval [l,r] . We will show how to calculate that.

In the first n−1 days, the snail will climb (n−1)⋅(a−b) meters. And in the daytime of the n -th day, the snail will climb a meters. So after n days, the snail climbs at most (n−1)⋅(a−b)+a meters, which means L≤(n−1)⋅(a−b)+a . Also, the snail can not reach L before n days, which means L>(n−2)⋅(a−b)+a . So L∈[(n−2)⋅(a−b)+a+1,(n−1)⋅(a−b)+a] . n=1 is a special case, where L∈[1,a] .

Now after each operation 1 , we can maintain a possible interval [Lmin,Lmax] . When a snail comes, we let the new [L′min,L′max] be [Lmin,Lmax]∩[l,r] , where [l,r] is the possible interval for the new snail. If the new interval is empty, we ignore this information, otherwise adopt it.

Now let's focus on another problem: for a fixed L,a,b , how to calculate the number of days the snail needs to climb? We can solve the equation (n−2)(a−b)+a<L≤(n−1)(a−b)+a , and get n−2<L−aa−b≤n−1 , which means n equals to ⌈L−aa−b⌉+1 . Still, special judge for L≤a , where n=1 in this case.

Then, for each query of type 2 , we just calculate the number of days we need for Lmin and Lmax . If they are the same, output that number. Otherwise output −1 .

Hint 1 Hint 2 Tutorial For some vertex set T , let's define E(T) as the ''neighbours'' of vertex set T . Formally, v∈E(T) if and only if v∉T , but there exist some vertex u , such that there's an edge (u,v) in the graph, and u∈T .

Now let's consider how to solve the problem for some fixed starting vertex u ? Let's maintain the set S(u) and E(S(u)) . Initially, S(u)=u . We keep doing the procedure: choose a vertex v∈E(S(u)) with minimal value av . If av≤|S(u)| , we add v into set S(u) , and update set E(S(u)) simultaneously. Since S(u) is always connected during the procedure, we are actually doing such a thing: find a vertex v that is ''reachable'' now with minimal value av , and try to defeat the monster on it. Our goal is to find some u such that |S(u)|=n .

Then let's move to a lemma: if v∈S(u) , then S(v)⊆S(u) .

Proof Then we can tell, if |S(u)|<n , then for v∈S(u) , |S(v)|<n . So it's unnecessary to search starting from v . And we can construct such an algorithm: Search from 1,2,3,…n in order, if some i has been included in some S(j) before, do not search from it.

Surprisingly, this algorithm is correct. We can prove it's time complexity. For each vertex v , if v∈S(u) now, and when searching from vertex u′ , v is add into S(u′) again, then |S(u′)|>2|S(u)| . Thus, one vertex can not be visited more than log(n) times, which means the time complexity is O(nlog2(n)) .

This problem has many other methods to solve. This one I think is the easiest to implement.

Hint 1 Hint 2 Tutorial Let numi be the number of occurances of integer i in the array a . To check whether the answer can be ≤x or not, we can do the following greedy: Starting with a single vertex written x , which is the root. For each i (from large ones to small ones), if the number of current leaves is smaller than numi , then we can not make the answer ≤x . Otherwise, let numi leaves stop, and other leaves ''grow'' m children each(these vertices are no longer leaves, but their children are). We can discover that each round, the ''stopped'' vertices have dep=x−i , which represents their value is x .

We can use the following code to calculate it.

Since a negtive number multiplies m is still a negtive number, the code can be as following:

Find out something? The final d is just mx−∑xi=1numi⋅mi , which represents it's equivalent to checking mx≥∑ni=1mai ! So now the answer is just ⌈logm∑ni=1mai . This is the highest bit plus one of ∑mai in m -base representation(except for that it's just some mx . In this case the answer is x but not x+1 ). We can use a segment tree, supporting interval min/max query and interval covering to solve the question. G and H will coming soon.

Codeforces Round #861 (Div. 2) Разбор

By kartel, history, 8 hours ago, translation, In English 1808A - Lucky Numbers

Solution 1808A - Lucky Numbers Let r−l≥100 . Then it is easy to see that there exists a number k such that l≤k≤r , and k≡90mod100 . Then the number k is the answer.

If r−l<100 , you can find the answer by trying all the numbers.

Despite the impressive constant, from the theoretical point of view we obtain a solution with asymptotics O(1) for the answer to the query.

1808B - Playing in a Casino

Solution 1808B - Playing in a Casino You may notice that the problem can be solved independently for each column of the input matrix. The answer is then the sum ∑i=1n∑j=i+1n|ai−aj| , where a — array representing a column.

Let's try to calculate this sum for each column. Let's sort all elements of the current column. Let's calculate the answer for some element in the sorted list. The answer for it will be ai⋅i−sum , where sum is the sum on the prefix. Why is this so? Because we say that this number is larger than the others and the modulus will then decompose as ai−aj , and this is already easy to count.

1808C - Unlucky Numbers

Solution 1808C - Unlucky Numbers Check all pairs (l , r ) — the minimum and maximum digits of the number from the answer. Discard the common prefix of l and r . Now we are left with some digits a and b as the leftmost digits of the number, with a < b . If b−a≥2 , then we can put a+1 at the beginning of the number, and then put any digit from the interval [l,r] .

Otherwise, we try a , and then always put the largest digit of [l,r] that we can. Similarly, then try putting b , and then always put the smallest digit of [l,r] you can.

Of all l and r , for which it is possible to construct a given number, choose such that r−l is minimal, and the number constructed at these l and r .

1808D - Petya, Petya, Petr, and Palindromes

Solution 1808D - Petya, Petya, Petr, and Palindromes Let us see when 1 is added to the palindrome. Let there be some string s of odd length k , consider the index i to the left of the central one. If this character and the corresponding one on the right side of the string are different, we can replace one of the characters with the other and get +1 to the answer.

Now the problem is as follows: count the number of indices on all substring of length k such that they differ from the corresponding character in that substring. Let's solve the inverse problem: count the number of indices for all substring of length k such that the given symbol and its corresponding one are equal. Then simply subtract from the maximum possible number of differences the required number of matches.

Try some symbol c and count for it the number of matches in all substring. Create a new array a of length n , that ai=1 when si=c , otherwise ai=0 . Now we have to count the number of indices i and j such that i<j , ai⋅aj=1 , j−i<k and (j−i) mod 2=0 (i.e. the distance between indices is even). Let's fix some j where aj=1 , then indexes j−2 , j−4 , etc. fit the parity condition. Then we can calculate prefix sums for each parity of indices. That is, pfi,par means the sum on prefix length i over all indices with parity equal to par . Then pfj−2,par , where par=j mod 2 is subtracted from the answer for some fixed j . Total we get the solution for O(n⋅maxA) , where maxA is the number of different characters of the string.

To solve the problem faster, we will use the work from the previous solution. Write out separately for each character all its occurrences in the string. Let's go through the symbol and write out all positions with even and odd indices. Solve the problem for even ones (odd ones are solved similarly). We will maintain a sliding window, where the difference between right and left elements is no more than k . When we finish iterating after removing the left element, we will subtract the window length −1 from the answer, because for the left element of the window exactly as many elements have the same parity on the right at a distance of no more than k .

P.S. The solution for O(n⋅maxA) can also be reworked into O(nn−−√) using the trick with «heavy» and «light» numbers.

1808E1 - Minibuses on Venus (easy version)

Solution 1808E1 - Minibuses on Venus (easy version) First, let's rephrase the problem condition a bit. A ticket number is lucky if (ai – the digit that stands at position i in the number) is satisfied: ai≡(a1+a2+…+ai−1+ai+1+…+an−1+an)(modk) Let S be the sum of all digits of the number. Then we can rewrite the surprise condition: ai≡S−ai(modk) 2⋅ai≡S(modk) Thus, if among the digits of the ticket there is such a digit x that: 2⋅x≡S(modk) Then the ticket is lucky.

Also note that there are kn numbers of tickets in total. Let's count how many nosurprising tickets exist. Then, by subtracting this number from kn , we will get the answer to the original problem. So now our goal is to count the number of non-surprising tickets.

Given a fixed sum S , there are numbers x that: 2⋅x≡S(modk) Therefore, in order for a number with sum S to be unlucky, it must not contain these digits.

Let us fix what S modulo k will equal.

Now, let's make a DP f[i][sum] , where:

i – index of the digit to be processed in the ticket sum – the current sum of digits of the ticket, modulo k The basis of DP – f[0][0]=1 . We will build transitions from the state f[i][sum] by going through the digit y , which we will put at position i . Keep in mind that we cannot use such y that: 2⋅y≡S(modk) Depending on y we recalculate sum . The number of unlucky ticket numbers, with sum S modulo k will be stored in f[n][S] .

1808E2 - Minibuses on Venus (medium version)

Solution 1808E2 - Minibuses on Venus (medium version) First, read the editorial of problem E1. This section is a continuation and improvement of ideas from the previous section.

Let us improve the solution for O(nk3) . To do this, note that the transitions from i to i+1 can be given by a matrix g of size k×k . Then by multiplying f[i] (i.e., multiplying exactly 1×k matrix of the form [f[i][0],f[i][1],…,f[i][k−1]] ) by this g matrix, we get f[i+1] .

Now note that for a fixed sum S modulo k , the matrix g will be the same for any i . Then let us take g to the power of n . Then f[n] can be obtained by calculating f[0]⋅gn . We can use multiplication algorithm for O(k3logn) to get the matrix powered n .

1808E3 - Minibuses on Venus (hard version)

Solution 1808E3 - Minibuses on Venus (hard version) First read the editorial for problems E1 and E2. This section is a continuation and improvement of ideas from previous sections.

Let's calculate how many such digits x can exist in total for a fixed S modulo k that: 2⋅x≡S(modk) . To do this we need to consider two cases:

k is odd. Then there can exist exactly one such digit x from 0 to k−1 , provided that S – is odd (and it will equal exactly S+k2 ). k is even. Then there can be two such digits x1,x2 from 0 to k−1 , provided that S – is even (with x1=k2,x2=S+k2 ). Let's solve the problem when k is odd. Calculate how many different S exist that for them there exists a digit x (denote the set of such S as cnt1 ), and calculate how many different S exist that for them there is no such digit x (denote the set of such S as cnt0 ).

If S enters cnt0 , then the number of unsurprising ticket numbers will be kn−1 (Since the total numbers kn are exactly 1k of them will have some S from 0 to k−1 modulo k ). So it is sufficient to add |cnt0|⋅kn−1 to the number of unsurprising tickets.

If S enters cnt1 , let's use the following trick: subtract from each digit in the number x . Now we have reduced the original problem to the case where x=0 .

Now let's count the DP f[i][flag] – the number of unlucky numbers, where:

i – how many digits of the ticket we've already looked at flag=1 if the current sum of digits is greater than zero, and flag=0 otherwise. This DP can be counted in O(logn) , again using the binary exponentiation of the matrix 2×2 (the content of the matrix is justified by the fact that the numbers must not contain x=0 ): (01k−1k−2) After calculating the DP, it is necessary to enumerate all possible variants of x and variants of S′ . If the condition is satisfied: 2⋅x≡(S′+x⋅n)(modk) .

Then we can add to the number of unsurprising numbers:

f[n][0] if S′=0 f[n][1]k−1 if S′≠0 (note that division must be done modulo m ). The reason for division is that f[n][1] is the number of all numbers with S′≠0 , and we need the number of numbers with some particular sum of S′ . The approach to solving for even k will be almost identical to the approach for odd k . The difference will be that we can now have either two x1,x2 when S is fixed, or none. When there are no x -ones, the solution is the same as the solution for cnt0 of odd k . When there is x1,x2 , we can see that they differ by k2 . So let's again subtract x1 from each digit in the number and then double each digit after that. That is, we now work with the numbers 0,2,…,2⋅(k−2),0,2,…(k−2) . The matrix for DP transitions will now have the form: (02k−2k−4) After calculating the DP, it is necessary to enumerate all matching pairs x1,x2 and variants of S′ . If the condition is satisfied: 2⋅x1≡(S′+x1⋅n)(modk) Then we can add to the number of unsurprising numbers:

f[n][0]2 if S′=0 (note that division must be done modulo m ). The division is justified by the fact that f[n][0] is the number of all numbers with S′=0 , but now we have two different "zero" sums (since we have dominated all numbers by 2). f[n][1]k−2 if S′≠0 (note that division must be done modulo m ). The reason for division is that f[n][1] is the number of all numbers with S′≠0 , and we need the number of numbers with some particular sum of S′ .

Editorial of Codeforces Round 860 (Div. 2)

By sevlll777, history, 5 days ago, translation, In English Thank you all for participating, I hope you enjoyed the problems! You can rate the problems of the round in the corresponding spoilers. Submissions links will be added after system testing.

1798A - Showstopper

Hint 1 Hint 2 Tutorial [problem:1798A] The first solution: Fix the position of the numbers an,bn . And for each other index i , let's check whether the conditions ai≤an and bi≤bn are met. If not, swap ai and bi and check again. If the conditions are not met for some index in both variants — the answer is "No", otherwise "Yes".

The second solution: Let M be the maximum of all the numbers a1,a2,…,an,b1,b2,…,bn . Then if an<M and bn<M the answer is — "No", since in the one of the arrays where the number M appears after the operations, the maximum will be M , which is greater than an and bn . Otherwise, either an=M or bn=M . If an=M , then swap an and bn , now bn=M . So the condition bn=max(b1,b2,…,bn) will always be met, regardless of the numbers b1,b2,…,bn−1 . Therefore, it would be best to put in bi the maximum of the numbers ai,bi for each i . After that, it remains to check the condition for the array a1,a2,…,an , and if it is met, the answer is —"Yes", otherwise —"No"

Solution Rate the problem 1798B - Three Sevens

Hint 1 Hint 2 Tutorial [problem:1798B] Let's calculate the array last , where lastX is the last day of the lottery in which the person X participated. Then the only day when X could be a winner is the day lastX . Then on the day of i , only the person with lastX=i can be the winner. It is also clear that if there are several such participants for the day i , you can choose any of them as the winner, since these participants cannot be winners on any other days. In total, we need to go through all the days, if for some day there are no participants with last equal to this day, then the answer is −1 . Otherwise, we choose any participant with lastX=i as the winner on the day of i .

Solution Rate the problem 1798C - Candy Store

Hint 1 Hint 1.1 Hint 1.2 Hint 2 Tutorial [problem:1798C] To begin with, let's understand when 1 price tag will be enough.

Let the total cost of all packs of candies be cost . Two conditions are imposed on cost :

The first condition: cost must be divided by each of the numbers bi , because cost=bi⋅di . This is equivalent to the fact that cost is divided by lcm(b1,…,bn) , where lcm denotes the least common multiple.

The second condition: ai is divided by di . We want cost to somehow appear in this condition. Therefore, multiply both parts by bi , and we get that ai⋅bi is divisible by bi⋅di=cost . That is, ai⋅bi is divided by cost . This is equivalent to gcd(a1⋅b1,…,an⋅bn) is divided by cost .

Thus, if one price tag is enough, it is necessary that gcd(a1⋅b1,…,an⋅bn) was divided by cost and cost was divided by lcm(b1,…,bn) .

So a necessary and sufficient condition for one price tag will be "gcd(a1⋅b1,…,an⋅bn) is divided by lcm(b1,…,bn) ".

It is not difficult to understand that if one price tag is enough for a set of candies, then if you remove any type of candy from this set, one price tag will still be enough.

This means that a simple greedy algorithm will work. Let's select the largest prefix of candies such that one price tag is enough for it, "paste" a price tag on this prefix, and repeat for the remaining candies until the array ends.

Solution Rate the problem 1798D - Shocking Arrangement

Hint 1 Hint 1.1 Hint 2 Tutorial [problem:1798D] If the array consists entirely of zeros, then this is impossible, since max(a)−min(a)=0 .

Otherwise, we will put all zeros at the beginning. Now our array is without zeros.

We will add the elements into the array in order.

If now the sum of the added elements is ≤0 , we will take any of the remaining positive numbers as the next element. Since the sum of all the numbers is 0 , a positive number is guaranteed to be found (if there are still numbers left).

If now the sum is >0 , then we will take any of the remaining negative numbers as the next element. Again, since the sum of all the numbers is 0 , a negative number is bound to be found.

Why it works:

The maximum number of the form |al+al+1+...+ar| is the same as maxPrefSum(a)−minPrefSum(a) (including 0 )

According to the structure of the algorithm, it is clear that in the resulting array maxPrefSum≤max(a) , and minPrefSum>min(a) .

In total, the condition will be met.

Solution Rate the problem 1798E - Multitest Generator

Hint 1 Hint 2 Hint 2.1 Hint 3 Tutorial [problem:1798E] The first idea: you can make a multitest from any array using 2 operations. To do this, replace the first element with 1 , and the second with n−2 , where n is the length of the array.

It remains to learn how to determine whether it is possible to make a multitest from an array for 0 and for 1 change.

First let's deal with the 0 changes.

Question: when is the array ai,…,an a multitest? Answer: when ai+1,…,an represents exactly ai of tests written in a row.

For convenience, let's call the index i good if ai,…,an represents a certain number of tests written in a row. For all indexes, we want to find out if they are good, and if so, how many tests the corresponding suffix consists of. Denote goi=i+ai+1 . The logic is that if i is the first element of a certain test, then goi is the first element of the next test. Then the index i will be good if the chain i→goi→gogoi→… ends in n+1 . To find out if this chain ends in n+1 and if so, how many tests it consists of can be simple dynamic programming by suffixes. In total, to determine whether the suffix ai,…,an is a multitest in itself, it is necessary to check that i+1 is good and its suffix consists of exactly ai tests.

Now it remains to determine whether it is possible to make a multitest for 1 change. If the array has become a multitest after the change, then the element responsible for either the number of tests or the first element of some test has been changed.

Case one: the number of tests changes. Then the array can be made a multitest if and only if i+1 is a good index.

Case two: the index after the change will become the first element of some test. We will consider "the maximum number of tests that can be achieved by changing one element" as the dynamics of the suffix. Then one change can make the suffix a multitest if the dynamics value from i+1 is greater than or equal to ai . How to calculate this dynamics for i+1 : The index being changed then must be one of i+1 , goi+1 , gogoi+1 , … , otherwise the test chain of i+1 will remain the same and the change will not affect anything. Then if goi+1,gogoi+1,… changes, then this change will be reflected in the dynamics value from goi+1 , through which it can be recalculated. And if i+1 changes, then you need to make a change so that goi+1 is a good index (after the change). goi+1 can become any index of ≥i+2 after the change. And of all these, you need to choose a good index with the maximum number of tests. This value can be maintained separately when recalculating the dynamics.

Solution Rate the problem 1798F - Gifts from Grandfather Ahmed

Hint 1 Hint 2 Hint 3 Hint 3.1 Hint 4 Tutorial [problem:1798F] Incredible mathematical fact: from any 2n−1 integers, you can choose n with a sum divisible by n (Erdős–Ginzburg–Ziv theorem) The proof can be found in the world wide Web. Brief idea: first prove for primes, and then prove that if true for n=a and n=b , then true for n=ab .

Sort the class sizes: s1≤s2≤…≤sk . Let's distribute the available boxes into the first k−1 classes in order. Then considering the i class, we have si+…+sk−1 boxes at our disposal. sk≥si , which means there are at least 2⋅si−1 boxes from which you can always allocate si to send to the i class. And for the last class, we can add a box with the necessary number of gifts ourselves to ensure divisibility.

The question remains how to allocate si numbers with a sum divisible by si among 2⋅si−1 numbers. Restrictions allow you to do this in a straight dynamics for n3 . dp[i][j][k] — is it possible to choose j among the first i numbers so that their sum gives the remainder of k by the required modulus. Restore of the answer is done by the classical method.

Solution Rate the problem

Codeforces Round #859 (Div. 4) Editorial

By mesanu, history, 2 hours ago, In English Thank you for participating!

1807A - Plus or Minus

Idea: flamestorm

Tutorial 1807A - Plus or Minus You need to implement what is given in the statement; for example, you can use an if-statement to output + if a+b=c , and - otherwise.

Solution 1807B - Grab the Candies

Idea: mesanu

Tutorial 1807B - Grab the Candies Let se be the total number of candies with all bags with an even number of candies, and so — the total of all bags with an odd number of candies. If se≤so , then the answer is NO, because at the end Mihai (who takes only even numbers of candies) will have less candies than Bianca.

Otherwise if se>so the answer is YES. The construction is to simply put all even bags first, and then all odd bags: since all even bags come before all odd bags and se>so , at any point in time Mihai will have more candies than Bianca.

The time complexity is O(n) .

Solution 1807C - Find and Replace

Idea: flamestorm

Tutorial 1807C - Find and Replace Let's solve a harder problem: given a string s and a binary string t , can we make s into t using the find and replace operations?

We can simply iterate through each character of s and see the bit it has turned to in t (that is, si→ti for each i ). Keep track of each change, and see if there is some letter that needs to be turned into both 0 and 1 . If there is some letter, it is impossible, since each operation requires changing all occurrences of a letter into the same bit. Otherwise, it is possible, and we can directly change each letter into the bit it needs to be. (See the implementation for a better understanding.)

Now for this problem, since there are only two alternating binary strings of length n (01010... and 10101... ), we can simply check both. (Actually, we only have to check one — do you see why?) The time complexity is O(n) .

Solution 1807D - Odd Queries

Idea: SlavicG

Tutorial 1807D - Odd Queries Note that for each question, the resulting array is [a1,a2,…,al−1,k,…,k,ar+1,ar+2,…,an]. So, the sum of the elements of the new array after each question is a1+⋯+al−1+(r−l+1)⋅k+ar+1+⋯+an. We can compute a1+⋯+al−1 and ar+1+⋯+an in O(1) time by precomputing the sum of all prefixes and suffixes, or alternatively by using the prefix sums technique. So we can find the sum each time in O(1) per question, and just check if it's odd or not. The time complexity is O(n+q) .

Solution 1807E - Interview

Idea: SlavicG

Tutorial 1807E - Interview Consider this question: if we take some range [al,…,ar] of piles, how do we know if it contains the special pile?

If it doesn't contain the special pile, then the total weight should be al+al+1+⋯+ar grams, since each stone weighs one gram. If it does contain the special pile, then the total weight should be al+al+1+⋯+ar+1 grams, since each stone weighs one gram except for the special stone, which weighs two grams. So we can determine if a range [al,…,ar] contains the special pile using a single query. Now we can binary search for the answer: first check the range [a1,…,an2] . If it has the special pile, then split it into two parts and check if one of them has the special stone; otherwise, check the other half. This will take at most ⌈log2(2⋅105)⌉=18 queries, which is well below the limit of 30 .

The time complexity is O(n) (for reading the input).

Solution 1807F - Bouncy Ball

Idea: mesanu

Tutorial 1807F - Bouncy Ball We can see that there are at most 4⋅n⋅m states the ball can be in, because there are n⋅m cells and 4 states of direction. We can simulate the bouncing process, keeping count of the bounces until we arrive at the finish cell when we can output the answer, or we arrive at a previously visited state and end up in a loop, then we can output -1.

Bonus: Can you prove there are at most 2⋅n⋅m states for any given starting position?

Solution 1807G1 - Subsequence Addition (Easy Version)

Idea: flamestorm

Tutorial 1807G1 - Subsequence Addition (Easy Version) Firstly, let's note that it doesn't matter in what order we add the elements to the array, since if we can add an element in any position, if it's possible to get the said elements of the array, then we can obtain them in any order.

Now, let's note that it's always optimal to obtain the needed elements in sorted order (since we only use smaller values in order to obtain the current one), so we will consider the array c as sorted. If the first element of the array isn't 1 then we immediately know such an array doesn't exist. Otherwise, we can use dynamic programming for finding out if the remaining n−1 elements are obtainable. Let's denote dps a boolean array which tells us whether sum s is obtainable. Initially, dp1=1 (since the first element is guaranteed to be 1 ). We will go in increasing order of ci and if we calculated an element to be obtainable in the past, we update all obtainable values with the new ci value. We do this in O(n⋅5000) , by going through all sums s and updating dps=dps|dps−ci (dps is true if it already was true, or if dps−ci was true and we add to that sum the new value ci .

The total time complexity of this solution is O(n⋅5000) .

Solution 1807G2 - Subsequence Addition (Hard Version)

Idea: flamestorm

Tutorial 1807G2 - Subsequence Addition (Hard Version) Let's prove that for an array a that was created by using a number of operations, with a sum of elements s we can add into a any number x (1≤x≤s ).

Suppose that it is true that in the array a with some length l we introduce a number x (1≤x≤suma ). Then after introducing we can create using the initial elements of the array any number b (1≤b≤suma ) and using the element x and some subset of the initial elements we can create any number b (x≤b≤suma+x ), and because x≤suma we proved that for the new array of length l+1 we can still create any number between 1 and suma+x .

Since it is true for the initial array, we can use induction and this fact to prove it is true for all arrays. So we just need to verify if our array satisfies this condition. We should sort the array and check for each i (2≤i≤n ) if ci≤∑i−1j=1cj .

Solution

Codeforces Round #858 (Div. 2) Editorial 

By mazihang2022, 3 hours ago, In English We are really sorry that C is tough and E is easier than D. But anyway hope you can enjoy the problems themselves and learn something from them. 

1806A - Walking Master 

Solution 1806A - Walking Master Hint 1: The value of b is always non-decreasing, and the value of a−b is always non-increasing. 

It is possible to move from (a,b) to (c,d) if and only if d≥b and a−b≥c−d , since the value of b is always non-decreasing and the value of a−b is always non-increasing. 

If it is possible, the answer is (d−b)+((a+d−b)−c) . One possible way is (a,b)→(a+d−b,d)→(c,d) . 

Another way to understand this: (a,b)→(a+d−b,d)→(c,d) is always a valid path if it is possible to move from (a,b) to (c,d) . So first let a←a+(d−b) and b←d , then the answer only depends on a and c . 

Code 1806B - Mex Master 

Solution 1806B - Mex Master Hint 1: ans≤2 . 

First, let's determine if ans can be 0 . That means we can't place two 0 s next to each other. This is achievable when the number of 0 s is not greater than ⌈n2⌉ . 

Then determine if ans can be 1 . That means we can't place 0 and 1 next to each other. Therefore, if there is no 1 in a or there exist an element x≥2 in a , we can simply rearrange a as [0,0,…,0,x,1,1,…] to make ans=1 . 

The last case：there are only 0 and 1 in a and the number of 0 s is greater than ⌈n2⌉ . We want to make ans=2 which is the minimum. Since the number of 1 s is not greater than the number of 0 s, we can rearrange a as [0,1,0,1,…,0,1,0,0,…] to make ans=2 . 

Code 1806C - Sequence Master 

Solution 1806C - Sequence Master Hint 1: The number of good sequences is small. 

Hint 2: Consider two cases: all elements in q are (not) equal. 

In case that all elements in q are equal, we have qn1=nq1 . The integer solutions to this equation is q1=0 , n=1 or (q1,n)=(2,2) . 

In the other case, we can see that the constraints are strong, so let's list some equations to find good sequences, using the property that not all elements are equal. 

Let q be such a good sequence. WLOG q1≠q2 . Then we have: 

q1⋅q3q4⋯qn+1=q2+qn+2+qn+3+⋯+q2n(1) q2⋅q3q4⋯qn+1=q1+qn+2+qn+3+⋯+q2n(2) Substract (2) from (1) : 

(q1−q2)q3q4⋯qn+1=q2−q1⟺(q1−q2)(q3q4⋯qn+1+1)=0 Since q1−q2≠0 , there must be q3q4⋯qn+1=−1 . 

Similarly, for each exactly n−1 numbers in q3,q4,⋯,q2n , their product will be −1 , which leads to q3=q4=⋯=q2n . Therefore, we have qn−13=−1 , which leads to 2∣n and q3=q4=⋯=q2n=−1 . 

Bringing it back to (1) , we have q1+q2=n−1 . 

Since q1q2⋯qn=qn+1+⋯q2n , we know q1q2=−n . 

The only solution is {q1,q2}={−1,n} . Q.E.D. 

Back to the problem. For the first case, it is easy to calculate the distance. For the second case, let S=∑ni=1|qi−(−1)| , the answer is min1≤j≤n{S−|qj−(−1)|+|qj−n|} . 

Code 1806D - DSU Master 

Solution 1806D - DSU Master We record an operation of adding edge as (i,i+1,ai) . 

Hint 1: Only operation (i,i+1,0) can contribute. 

Hint 2: Using dynamic programming, let fi denote the number of ways to let vertices 1∼i form a tree with root 1 , considering only the first i−1 operations. 

We can observe: 

Only operation (i,i+1,0) can contribute. If vertices 1∼i have already formed a tree with root 1 , then operation (i,i+1,0) can contribute. Using dynamic programming, let fi denote the number of ways to let vertices 1∼i form a tree with root 1 , considering only the first i−1 operations. 

For f , we have f1=1 and fi+1=fi⋅(i−ai) . 

Explanation: Consider inserting the operation (i,i+1,ai) in the sequence of the first i−1 operations. If ai=0 , no matter where it is inserted, it will always form a tree with root 1 , so fi+1=fi⋅i . If ai=1 , only inserting at the end is invalid, so fi+1=fi⋅(i−1) . 

For computing the answer, we have ansi=i⋅ansi−1+[ai=0]fi+1 . 

Explanation: i⋅ansi−1 represents the contribution of previous i−1 operations. No matter where operation (i,i+1,ai) is inserted, the contribution of previous i−1 operations won't change. [ai=0]fi+1 means the contribution of operation (i,i+1,ai) . 

Code 1806E - Tree Master 

Solution 1806E - Tree Master Hint 1: The time complexity of the solution is O(nn−−√) . 

Hint 2: Brute force with something to store the answer. 

The solution turns out quite easy: just store the answer to each pair of (x,y) when computing the answer by climbing up on the tree. If we see the time complexity of hash table as O(1) , then the time complexity and memory complexity are both O(nn−−√) . Let's prove it. 

We will see n=q in the following proof. It is clear that the above solution's time complexity depends on the number of different pairs (x,y) which we encounter when climbing. Assume the i -th depth of the tree has si nodes, then its contribution to things above is min(s2i,n) . It's easy to discover that when si>n−−√ , the contribution of it will equal to the contribution when si=n−−√ . So, making all si not greater than n−−√ will contribute more. Therefore, the time complexity is O(∑ki=1s2i) . When si=n−−√ , the formula above has a maximum value of nn−−√ , because (a+b)2≥a2+b2 . 

In fact, we don't need to use hash table in this problem. If there exists a pair of (x,y) of depth i such that si>n−−√ , then we don't need to store (x,y) . Since the amount of i such that si>n−−√ are not greater than n−−√ , the time complexity won't change. For other pairs of (x,y) we can simply store them in an array, then the memory complexity won't change. 

Code 1806F2 - GCD Master (hard version) 

Solution 1806F2 - GCD Master (hard version) Hint 1: There is a easy strategy for dealing with repeated elements. Suppose that all elements in a are pairwise distinct in the following hints. 

Hint 2: We will always perform an operation on the minimum element. 

Hint 3: The best way is to choose k+1 elements, delete them, and add the gcd of them to the sequence. 

Hint 4: After sorting the sequence, you may guess that choosing a prefix is optimal. But actually it is wrong. Try fixing the strategy! 

Solution for F1: 

First, suppose that all elements in a are pairwise distinct. 

The problem can be rewritten as: Divide the sequence into n−k groups to maximize the sum of the gcd of each group. Let Si represent the elements of a group. 

Lemma 1 : When k>0 , the group which the minimum element of the original sequence belongs to satisfies |Sa|>1 . 

Proof: 

If |Sa|=1 , we can find a group Sx such that |Sx|>1 . Then replacing the maximum element of Sx with the minimum element of the original sequence makes the answer greater. 

Let a be the minimum of the sequence and b be the maximum of Sx . 

the original answer is a+gcd(Sx) . replacing the maximum element of Sx with the minimum element, the answer is b+gcd(Sx∖{b}∪{a})>b . gcd(Sx)≤maxSx−minSx=b−minSx<b−a , so a+gcd(Sx)<a+b−a=b<b+gcd(Sx∖{b}∪{a}) . Q.E.D. 

Tips: When maxSx=minSx , gcd(Sx)≰maxSx−minSx . That's why all elements in a need to be pairwise distinct. 

Lemma 2 : When k>0 , there's only one Sx such that |Sx|>1 。 

Proof: 

Let Sa be the group with the minimum element. 

Referring to Lemma 1 , we know |Sa|>1 . Then we remove all the elements of Sa from the sequence, add gcd(Sa) to the sequence and subtract |Sa|−1 from k . It's obvious that gcd(Sa) is the minimum element of the newly formed sequence. We can continue the process until k=0 , which tells us that only |Sa|=k+1>1 . Q.E.D. 

We can enumerate gcd(Sa) to solve it in O(n+mlnm) so far. 

How about repeated elements? 

We can find that for those repeated elements, the best strategy is to merge them with the same element. In other word, a repeated element x only decreases the answer by x . So it's independent of the previous part. We just need to enumerate the number of operations we perform for repeated elements. 

Solution for F2: 

Still suppose that all elements in a are pairwise distinct. 

Suppose a is sorted. 

Lemma 3 : When k>0 , we will choose the first k elements, and an element from the remaining elements. 

That is, S={a1,a2,…,ak,ax} , where k<x≤n , is the only group with more than one element. 

Proof: 

Suppose T={a1,a2,…,ap,ac1,ac2,…,act} , where p+1<c1<c2<⋯<ct , t≥2 and p+t=k+1 . Then we can prove that T′={a1,a2,…,ap,ap+1,ac1,ac2,…,act−1} is always a better choice. 

Let g=gcd(T) and g′=gcd(T′) . We have act−ap+1>act−act−1≥g . 

Δ=ans(T′)−ans(T)=act−ap+1+g′−g>g′>0 . 

So repeating the process, finally we will know that S={a1,a2,…,ak,ax} , where k<x≤n . Q.E.D. 

When there're repeated elements, we need to calculate the answer for k prefixes. Note that there're only O(logm) different prefix gcd. So we can do it in O(nlog2m) (another O(logm) comes from calculating gcd). Let gi be the prefix gcd. When finding the best pair, we calculate gcd(gi,aj) , which leads to O(nlog2m) . gi∣gi−1 , so gcd(gi,aj)=gcd(gi,gcd(gi−1,aj)) . The gcd is non-increasing so the total complexity is O(nlogm) . 

Code 

Nebius Welcome Round Editorial 

By GlebsHP, history, 43 hours ago, In English1804A - Lame KingObservation 1. Let |a|=|b|. The king can reach (a,b) in 2⋅|a| moves by alternating moves along rows and moves along columns. 

Observation 2. Let |a|≠|b|, in particular a>b≥0 (without loss of generality due to the board symmetry). The king can reach (a,b) in 2a−1 moves. He moves towards a on turns 1,3,5,…,2a−1. The remaining a−1 moves are enough to reach b. Finally, the remaining slots can be filled with "skip" moves. 

Thus, the answer is |a|+|b| if |a|=|b| and 2⋅max(|a|,|b|)−1 otherwise. 

1804B - VaccinationObservation 1. There exists an optimal answer where each pack of vaccine is used for a consecutive segment of patients. Indeed, if there are three patients a<b<c such that a and c are vaccinated using the dose from one pack and b is vaccinated using the dose from the other pack we can swap the packs used for b and c and the answer will still be valid. 

Observation 2. It always makes sense to ask new patients to wait as long as possible before opening a new pack. 

From these two observations we derive a very easy strategy. Consider patients one by one in order of non-decreasing ti. If we consider some patient i and there is an open pack that still valid and still has some doses remaining, use it immediately. If there is no valid open pack of vaccines and there is no one waiting, ask patient i to wait till ti+w moment of time. If there is no valid pack of vaccines, but there is someone already waiting for moment x, ask patient i to wait for moment x as well. 

As a courtesy to our participants the values of d and w are limited by 106 to avoid a potential overflow of a signed 32-bit integer type. 

1804C - Pull Your LuckAssuming the constraint on the the sum of n over all test cases we might want to simulate the process for each test case. However, we need an O(n) (or other quasilinear complexity) solution. 

The key observation is that the sum of all integers from 1 to 2n inclusive is divisible by n. Indeed, ∑2ni=1i=(2n+1)⋅2n2=(2n+1)⋅n. 

As the remainders of x of modulo n will repeat after 2n steps there is no point in trying values of x for more than min(2n,p). 

Question, can you build the test that required Vesper to use x more than 100k? There is exactly one such test. 

1804D - AccommodationThe number of one-bedroom and two-bedroom apartments is the same for each floor and each floor can have its own independent apartments layout. Thus, we can independently solve the problem for each floor and then just sum the results. Below is given the solution for one floor in O(m) time. 

First, lets introduce some variables. 

B is the total number of bright windows.D is the total number of dark windows.O0 is the number of one-bedroom apartments that are not occupied (0 bright windows).O1 is the number of one-bedroom apartments that are occupied (1 bright window).T0 is the number of two-bedroom apartments that are not occupied (0 bright windows).T1 is the number of two-bedroom apartments that are occupied and have 1 bright window.T2 is the number of two-bedroom apartments that are occupied and have 2 bright windows.A is the total number of occupied apartments.We know that A=O1+T1+T2 and B=O1+T1+2⋅T2. Thus, A=B−T2, so in order to minimize the number of occupied apartments we need to maximize T2 and vice versa. 

Maximizing T2 is easier, you just determine the length of all maximal segments of bright windows, denote these lengths as l0,l1,l2,…,lx. Then you pack each segment with as many two-bedroom apartments as possible. So, the maximum possible value of T2=min(∑xi=0⌊li2⌋,m4. Here we must note the importance of having exactly m4 two-bedroom apartments and exactly m2 one-bedroom apartments. If the actual number of apartments of each type was given in the input we won't be able to guarantee the value of T2 defined above. It could be the case that it is not actually possible to place all the remaining apartments and close the gaps between the placement of two-bedroom apartments with two bright windows. However, as we have m2 one-bedroom apartments we can guarantee that such a placement is always possible. 

Now we would like to minimize T2. Actually, we will do it in exactly the same way as the maximization, but instead of taking maximal segments of bright windows, we will find and use maximal segments that have at least one dark window and do not have two consecutive bright windows. Denote the lengths of such maximal segments as l′0,l′1,l′2,…,l′y. Then, the minimum possible T2=min(0,m4−∑yi=0⌊l′i2⌋). Again, thanks to m2 one-bedroom apartments we will be able to fill all the gaps and achieve the desired placement. 

1804E - RoutingA directed graph where each node has an out-degree equal to 1 (exactly one arc starts at this node) is called functional. By setting auxiliary servers a(v) for each server v we define a functional graph. 

The following condition is necessary and sufficient. The answer exists if and only if there exists a functional graph defined by a(v) that contains a cycle C such that NG(C)=V(G). That means that each node should be neighbouring to at least one node of this cycle in the original graph. Note that cycles of length 1 are not allowed as a(v)≠v by definition. The proof is easy. If such a cycle C exists we can reconstruct all other a(v) to lead to this cycle. This will allow WRP to construct a path to each server after the procedure gets to the cycle. If such a cycle doesn't exists, we can pick any node of any cycle (functional graph always has at least one) and some servers will be unreachable from it. 

Wow we need to find a cycle of length ≥2 such that each server belongs to this cycle or is directly connected to at least one server of the cycle. 

First we run a dynamic programming similar to Hamiltonian path and identify all the subsets of servers that can form a cycle. This will take O(2n⋅n2) if we use the following meaning of d(m,v). d(m,v)=0 if there exists a path that starts from node u, visits all nodes of a subset defined by bitmask m and ends in node v. Here node u is the node with minimum index in subset m, as you can always pick the minimum-indexed node as the beginning of the cycle. 

After we compute d(m,v) we take all m such that there exists d(m,v)=1 and check whether NG(m)=V(G). This can be done in O(2n⋅n2) as well. 

Thus, the overall complexity is O(2n⋅n2). 

1804F - Приближение диаметраLet's recall some definitions to start with. 

ρG(u,v) is the length of the shortest path between vertices u and v in graph G.Define as cG(u) the maximum distance from vertex u to some other vertex of graph G. cG(u)=maxv∈V(G)ρ(u,v).d(G)=maxu,v∈V(G)ρ(u,v)=maxu∈V(G)cG(u) is called the diameter of graph G. It is the maximum distance between some pair of vertices of graph G.r(G)=minu∈V(G)maxv∈V(G)ρ(u,v)=minu∈V(G)c(u) is called the radius of graph G. It is the minimum possible distance from one vertex of the graph to the farthest from it vertex of this graph.The key inequality we will use for this problem solution is the following. Let v be arbitrary vertex of graph G. 

d(G)2≤r(G)≤cG(v)≤d(G)≤2⋅r(G)≤2⋅cG(v)≤2⋅d(G)r(G)≤cG(v)≤d(G) by definition.d(G)≤2⋅r(G) because of triangle inequality.All other inequalities are derived from the first two items.The good thing is that we can compute cG(v) in linear time using BFS algorithm. Now we can solve the problem in O(q⋅(n+m+q)) time. It is important to note that the task tolerates errors both ways, so any value between cGi(v) and 2⋅cGi(v) will be a correct approximation of d(Gi). 

The next key observation is that the sequence of di(G) is non-increasing. If i<j and cGi(v)≤2⋅cGj(v) we can use 2⋅cGj(v) as an approximation for d(Gi+1),d(Gi+2),…,d(Gj−1). 

Using the idea above we can do one of the following. 

Having the correct value of c(Gi)(v) we can use the binary search to find the maximum j such that cGi(v)≤2⋅cGj(v) in logq iterations.Use divide&conquer with the stop condition cGl(v)≤2⋅cGr(v). That would actually work a way more faster (up to five times) as it re-uses the information very efficiently.Thus, we have a solion that runs BFS no more than logn⋅logq times. The overall complexity is O(logn⋅logq⋅(n+m+q). 

How did we get the correct answers for the checker? We precomputed them using the power of distributed computing. We are a cloud technology company after all! 

Bonus question, can you guess the total number of cpu-days we have used to compute all the answers? Post you version in the comments! 

G. The Maximum Prefix

Hint Tutorial Consider this method to find maximal prefix sum: let fn+1=0 and fi=max(fi+1,0)+ai . We can discover that the only influence [ai+1,ai+2…an] has(to the whole array's maximal prefix sum) is its maximal prefix sum. Then we let dpi,j be : the expect score we can get, if we assume that the maximal prefix sum of [ai+1,ai+2…an] is j (Read the definition carefully). The answer for each k is dpk,0 , since if the maximal prefix sum for [ak+1,ak+2…an] is 0 , that is equivalent to removing them from the array. And also dp0,j=hj .

And we have dpi,j=pi⋅dpi−1,j+1+(1−pi)⋅dpi−1,max(j−1,0) . The first section represents chosing ai=1 and the second one represents chosing ai=−1 .

We also have other solutions, using inclusion-exclusion or generate function. Actually all the testers' solutions differs from each other.

Solution H.Last Number

Hint Tutorial Assume that the moment before the x -th operation(but after x−1 -th), the first time we have Smax≤2Smin . Let's divide the operation into two part: before x and equal or after x .

Still, at the moment just before the x -th operation, let us sort the elements in the multiset in non-decreasing order, S0,S1…Sk . We will show that the answer is S0⋅(−1)k+∑ki=1Si⋅(−1)i+1 .

Proof Let di be the Smax value in the i -th operation. Let's prove that before the x -th operation, di=n−⌈iϕ⌉+1 , where ϕ=5√+12 .

Proof Then, by solve n−⌈xϕ⌉+1≤2x , we can get x=⌈(n+1)ϕ−1ϕ⌉ . Now let's prove for k≥x , dk=n−⌈kϕ⌉+1 also holds !

Proof Till now, the lemmas told us the solving the problem is actually solving something like ∑(−1)i⋅(n−⌈iϕ⌉+1) . We can divide them into positive part and negtive part, and then solving ∑⌊C⋅i⌋ , where i range from some l to r , and C is a irrational constant. Since n is not very large, we can approximate C by ab , where a,b are integers, and turn it into a traditional task. (Maybe it is called floor sum or something like, I'm not sure about the algorithm's english name).

The marvelous jiangly told me a,b in long long range is enough. But the tester used int128.

We can dig more about the ϕ . Let bi=Si+1−Si (sorted, before the x -th operation), and what we care is b1+b3+b5… . We can find that array b is actually a consecutive substring of fibonacci string. More over, let Fn be the starting point of array b in the fibonacci string when the initial size is n , we have the conclusion for n≥5 :

F[5…inf]=[3,0],[4,1],[8,0],[12,1]…[fi+3+(−1)i+1,1+(−1)i] , where fi=fi−1+fi−2,f1=f2=1 . [r,l] represents a list of numbers [r,r−1,r−2…l+1,l] .

Now the only left problem is to find the prefix sum of fibonacci string(of even positions, or of odd positions). This is quite a simple task by using any log(n) or log2(n) solution.

1804G - Flow Control The problem is inspired by AIMD algorithm for TCP flow and congestion control. 

The key solution idea comes from a real-world networking, every time the congestion happens the difference between the maximum active ti and the minimum active ti halves. Thus, if all users were to start and to stop at the same time there will be no more than two distinct values of ti in just logC congestions. Here C stands for the upper limit on values di and b . 

Let's store all the unique values of active ti in a hash-map together with a supplementary information. Information we need is the sum of all ti right after the last congestion, the number of milliseconds past since the last congestion and so on. Using this information we can compute the time of the next congestion in O(1) . 

The processing of one congestion will work in O(d) time where d is the current number of distinct values of ti . We also need to be able to merge two groups when congestion happens, this information will be used to process delete operations. That can be done using DSU with path compression and doesn't add much to the total complexity. 

We will call the period between two consecutive congestions an epoch. There are epochs of two types: general and repetitive. A repetitive epoch is an epoch that goes in exactly the same way as the previous epoch. That means no new users appear, no users turn off, the epoch starts with exactly the same values of ti as the previous epoch and gets to exactly the same state after the closest congestion happens. All other epochs are called general. 

Though the total number of epochs can be large (up to max(fi) ), there will be no more than nlogC general epochs. Indeed, if no users start or finish data transmission, the process will converge to a repetitive epoch in no more than logC congestions. Here, C is the upper bound for b and values di . 

Repetitive epochs contain no more than two distinct value of ti , they can be identified and simulated efficiently. How do we simulate general epochs? There is no need to this efficiently, doing this in O(d) (d is the number of distinct ti ) will be efficient enough. One can prove this using amortized analysis with the following potential function. Let d be the number of distinct values of ti and t0<t1<…<td−1 be the sequence of these values. P(epoch)=d+∑d−2i=0log(ti+1−ti) . 

The total complexity is O(nlogC+nlogn) . 

1804H - Code Lock First, let's solve the task for the case of linear arrangement of letters instead of a circle. Then we will upgrade the solution. 

Let c(x,y) be the number of positions i of the password string s such that si=x and si+1=y . In other words, c(x,y) is the number of times Lara has to enter letter y after entering letter x . We need to find any permutation of letters p0,p1,p2,…,pk−1 of minimum cost. Integer pi stands for the index of the letter that will be placed at position i . The cost of a permutation is computed as w(p)=∑0≤i,j<k,i≠jc(pi,pj)⋅|i−j| . 

Pointwise weights are much more convenient to use rather than pairwise weights. Re-write the cost function as follows. w(p)=∑0≤i,j<k,i≠jc(pi,pj)⋅|i−j|=∑0≤i<j<k(c(pi,pj)+c(pj,pi))⋅(j−i)=∑i=0i<ki⋅(∑j=0j<i(c(pj,pi)+c(pi,pj))−∑j=i+1j<k(c(pj,pi)+c(pi,pj))) Usage of pointwise weights allows us to obtain the permutation step by step from left to right. When we place the new element x we only need to know the subset of all already placed elements and the optimal cost of the prefix. 

Define d(mask) as the minimum total cost of a permutation prefix containing first |mask| elements. The update function looks as follows. d(mask)=minx∈mask(d(mask−x)+|mask|⋅(∑y∈mask,y≠x(c(y,x)+c(x,y))−∑y∉mask(c(y,x)+c(x,y)))) The above solution works in O(2n⋅n) . However, in can be updated to O(2n⋅n) with some precomputations of the sums in the formula above. 

Now we need to learn how to apply the similar idea for a positioning on a circle. The cost function now looks as follows. w(p)=∑0≤i,j<k,i≠jc(pi,pj)⋅min(|i−j|,k−|i−j|)=∑i=0k−1pw(p,i) In order to write the cost function using pointwise weights we need to distinguish between two halves. The pointwise cost of an element in the first half is: pw(p,i)=i⋅∑j=0j<i(c(pi,pj)+c(pj,pi))−i⋅∑j=i+1j≤i+⌊k2⌋(c(pi,pj)+c(pj,pi))+(i+n)⋅∑j=i+⌊k2⌋+1k−1(c(pi,pj)+c(pj,pi)) Similarly, the poinwise cost of an element in the second half is: pw(p,i)=−i⋅∑j=0j<i−⌊k2⌋(c(pi,pj)+c(pj,pi))+i⋅∑j=i−⌊k2⌋j<i(c(pi,pj)+c(pj,pi))−i⋅∑j=i+1k−1(c(pi,pj)+c(pj,pi)) The above formulas show that it makes sense to first split all elements in two parts: left and right halves of the circle. Then we will alternate steps in adding one element to the first unoccupied position of the left part, then to the first unoccupied position of the right part. This way we will always be able to compute the value of a pointwise cost function. 

So we compute the dynamic programming d(S,M) , where S is the subset identifying the way to split the set of all letters in two equal (or almost equal for the case of odd size) parts, and M is the subset of already added elements. Elements S∩M are placed at the beginning of the first half and elements S¯¯¯∩M are placed at the beginning of the second half. 

The simpliest complexity estimation is O(4n⋅n) . However, we should consider the following optimizations. 

We only use |S|=⌈k2⌉ . We only use states such that |S∩M|=|S¯¯¯∩M| or |S∩M|=|S¯¯¯∩M|+1 . The character s0 is always located at the first sector of the code lock, so Lara doesn't have to make any moves to enter the first character of her password. Thus, we only consider s0∈S and s0∈M . Considering all the above optimizations we end up with only 82818450≈83⋅106 states. The problem statement asks you to compute the number of permutations as well. That doesn't add anything to the difficulty of this dynamic programming solution and is just used to cut away all the heuristic optimizations like annealing simulation. 

Codeforces Round #857 Editorial 

By vaaven, 21 hour(s) ago, translation, In English1802A - LikesIdea: Aleks5d, Preparation: vaaven 

SolutionLet's show a construction that maximizes the number of likes. We need to first leave all the likes that we can put, and only then delete them. 

To minimize the number of likes, we need to delete the like (if we can) immediately after we post it. 

The code below implements these constructs. 

Code1802B - Settlement of Guinea PigsIdea and preparation: Aleks5d 

SolutionTodo 

Code1801A - The Very Beautiful BlanketIdea and preparation: 4qqqq 

SolutionThe maximum number of different numbers we can type is always n⋅m. Let's show how you can build an example for any n and m. 

Note that if we were able to construct a correct matrix, then any of its submatrix is also a correct matrix of a smaller size. Therefore, let's build a correct matrix for some N and M, and as an answer we will output the upper left corner of this matrix of the desired size. 

Take N=M=28 and construct the matrix using the following algorithm. Let's break it into blocks of size 2×2. Let's number the blocks from left to right and from top to bottom in order, starting from zero. The $i$th block will have the form 

4i+0 4i+14i+2 4i+3With this construction, the bitwise exclusive OR any submatrix of size 2×2 will be zero. You can verify this as follows. Let's look at the upper left corner of (i,j) of an arbitrary submatrix of size 2×2. There are 4 cases: 

both coordinates are even;i is even, j is odd;i odd, j even;both coordinates are odd.Immediately note that i,j<200<28Consider the most unpleasant case — the last one. The remaining cases are treated in a similar way. In this case, the submatrix will have the form: 

4i+3 4(i+1)+24(i+28)+1 4(i+28+1)+0Note that the second part of each term is less than 4, and the first part of each term is greater than or equal to 4. Therefore, they can be considered independently. 

3⊕2⊕1⊕0 = 0. 

If i=1, then 

4i⊕4(i+1) = 12, 

4(1+28)⊕4(2+28) = 12. 

If i≠1, then 

4i⊕4(i+1) = 44(i+28)⊕4(i+28+1)=4 (for i=0, you can check with your hands, for 1<i<28 4(i+28) will be reduced and 4 will remain from the second term). 

4⊕4⊕0 = 0. Thus, in the selected submatrix, the bitwise exclusive OR is zero. 

Code1801B - Buying giftsIdea: Tikhon228, Preparation: DishonoredRighteous 

SolutionTo begin with, let's sort all departments in descending order bi (and if ~--- is equal, in ascending order ai). Now let's go through the i department, in which the most expensive gift for the second girlfriend will be bought. Note that in all departments with numbers j<i, Sasha must buy a gift for the first girlfriend, otherwise the gift i will not have the maximum value among the gifts bought for the second girlfriend. Therefore, we will immediately find the value of m=maxj<iaj. Thus, we can already get the answer |m−bi|. 

In all departments with numbers j>i, for which aj≤m, Sasha can buy a gift for any of her friends, and this will not affect the answer in any way. Now consider all departments with numbers j>i for which aj>m. If you buy a gift for your first girlfriend in some of these departments, the value of m will increase, which means the answer may improve. Therefore, let's iterate through all these departments and update the response with the value |aj−bi|. 

Time O(n2). 

Let's optimize this solution. To begin with, instead of calculating the value of m anew at each iteration, we will maintain its value in some variable. Then, when moving from department i−1 to department i, we will update the value of m as follows: m:=max(m,ai). 

It remains to learn how to quickly find the optimal department number j, such that j>i, aj>m, as well as |aj−bi| is minimal. Let's choose on the suffix of the array the minimum aj, such that aj≥bi, and also the maximum aj, such that aj≤bi. You can notice that the optimal aj is one of the two selected numbers (you also need to remember to check the condition aj>m). Therefore, it is enough to update the answer only with the help of them. 

You can search for these two elements using the \texttt{set} data structure. We will support in the set all aj located on the suffix. Then you can find the necessary two elements for O(logn). When moving from department i−1 to department i, you need to remove the value ai−1 from the data structure. 

Time O(nlogn)Code1801C - Music FestivalIdea: vaaven, Preparation: ViktorSM 

SolutionLet's introduce the concept of a compressed album for an album, which is obtained from the original one by removing all elements except those that are the first maxima on their corresponding prefixes. 

For example: 

For the album [1,4,4,3,6,5,6] the album will be compressed [1,4,6]. 

Now we note that the solution of the original problem is reduced to solving the same problem, but on compressed albums. Indeed, the answer to them will not be different, because if some element increased the impression on ordinary albums, then it will increase if you compress albums and vice versa. Next, it will be assumed that all albums have been compressed beforehand. 

Let's introduce dpc — the maximum impression that can be obtained if there were no albums such that they have elements larger than c. Then, dpc is equal to dpc−1, or you can add another element or two if c is the maximum element for some album. Then for all compressed albums, it can be recalculated through the value of dp at the point before the first element of the album, or through c−1. Thus, for recalculation, it is enough to know for each c which albums ended in this index, as well as for each album its first element. Solution for O(K)Let's now solve the complete problem. For each value of c, let's remember the indexes of albums that contain an element equal to c. We go in order of increasing c, we maintain for each album the value of dpi — the maximum impression that can be obtained if there were no elements of large c and Masha listened to the last i album. Suppose for the next c there is an album i, that there is a song with the coolness of c in it. Then dpi should be taken as the maximum of dpi+1 and the values for all dpj+1, such that the maximum element in the jth album is less than the maximum element of ith, since she could listen to this track, either next in this album, or after listening to some other album completely. Note that you can store the value of mx — maximum for all albums for which the maximum value in them is less than c and recalculate it when moving to c+1, storing those albums that have ended, then you will get a solution for O(K+C). 

Code1801D - The way homeIdea: Tikhon228, Preparation: Ormlis 

SolutionNote that the show can be done "postponed". As soon as we don't have enough money to walk along the edge, we can do several shows in advance among the peaks that we have already passed, so as to earn the maximum amount of money. 

For the general case, you can write dp[v][best]=(min show,max money), where v is the number of the vertex where we are, and best is the vertex with max. wi, which we have already passed through. It can be shown that it is optimal to minimize the number of shows first, and then maximize the amount of money. This dynamics can be recalculated using Dijkstra's algorithm. Asymptotics of O(mnlogn)Code1801E - Gasoline pricesIdea and preparation: Kirill22 

SolutionTo begin with, let's understand what is required of us. A tree is given, in each vertex of which the price range for this vertex is recorded. A query is a pair of paths of equal length, the prices at the i-th vertices along these paths should be equal for all i. We need to find the number of ways to place prices at the vertices for each prefix of restrictions 

Let's start with a slow solution of the problem. We will store the connectivity components (in each vertex prices should be equal). For each of them, we store an acceptable price range. The answer will be the product of the lengths of the ranges over all components. We will go along the paths and combine 2 vertices into one component using DSU. It is clear that to speed up this solution, it is necessary to search faster for the moments when two vertices are combined into one component. 

First, let's analyze the long solution. Let's make a heavy-light decomposition, with which we will hash the paths in the tree, taking the root number of its components as a symbol for the vertex. Now, with the help of bin search, we will look for the first moment when the hashes on the path prefixes differ, that is, two vertices are combined into one component. With the help of transfusions, we will update the roots of their components for vertices and the tree of segments for hld. We will get n unions, we will find each one for O(log2(n)) using hld. There will also be O(n⋅log(n)) updates in the segment tree due to overflows. For each request there will be O(log2(n)) from hld. The final asymptotic O((n+q)⋅log2(n))Now let's give a beautiful solution to this problem. Let's start with bamboo. 

Replace the equality of prices on a pair of paths with two pairs of paths with lengths equal to the maximum power of two, less than the length of the original path (as in sparse table). Now the path lengths of all constraints have become powers of two. We will iterate over the powers of two in descending order 2k, for each path of length 2k we will get a vertex in the graph, we will also get a vertex for each such path in reverse order. Now the constraints define edges in such a graph. Let's spend them, select the spanning tree. For each edge from the backbone, we divide the constraints into 2 constraints with path lengths half as long and continue the process. On a layer with lengths 1, we will get the spanning tree we need, which will be responsible for the first moments when some pairs of vertices were combined into components. Note that no more than 2n edges will be added down from each layer, as well as no more than 2q edges from queries. That is, each layer will work for O((n+q)⋅α(n)), where α(n) is the average operating time in DSU, the inverse of the Ackerman function. We got the solution in O((n+q)⋅α(n)⋅log(n))For a complete solution on the tree, first we divide a pair of paths into three pairs of corresponding vertical paths (take from the 4 end vertices of these paths the pair of vertices closest to the lca on its path, then we pair this path with a vertical path (part of another path), now we get one vertical path and an arbitrary path in the tree, let's split the second path by lca and the first by the corresponding lengths). Next, we will proceed similarly to bamboo, only the place of the vertex responsible for the segment, we will get the vertex responsible for the binary ascent in the tree to a height equal to the power of two. 

Code1801F - Another n-dimensional chocolate barIdea and preparation: Tikhon228 

SolutionFor A we denote the maximum value of aiTo begin with, let's solve the problem for O(n⋅k⋅f(k,A)) using dynamic programming. 

Let's put dp[i][j]— the maximum possible volume of the smallest piece, if by the first i measurements we divided the chocolate into j parts. If we have divided into more than k parts, we will also put the result in dp[i][k]. In terms of calculation, we need to decide how many hours to divide the chocolate bar along the next dimension. Let's look at several ways to do this. 

It is possible for O(k) to sort out the state to which we are moving, and from this calculate how many parts you need to divide the chocolate bar along the next dimension. — We get O(n⋅k2)It is possible for O(A) to sort out how many parts we divide the chocolate bar along the next dimension. 

Being in the state of dp[i][j], you can iterate over bi — into how many parts to divide the chocolate until j⋅bi≤k. It can be shown that such a solution will work for O(n⋅k⋅lnk)The key idea 

suppose we need to divide a chocolate bar into 10 parts, and along the first measurements we have already divided it into 5 parts, or 6 parts, or 7,8 or 9 parts. All these states are not distinguishable for us, because in all these cases we need to divide the chocolate bar into at least 2 parts. It remains to understand how many such <> states there are and learn how to store them. There are several approaches for this, let's analyze one of them: 

we are interested in all the values of ⌈ki⌉ for i=1,2,…k— this is how many parts the chocolate bar may still need to be divided into. Among them, only O(k−−√)different, since either i≤k−−√, or the value of ⌈ki⌉≤k−−√ itself. If we make all these numbers states, and recalculate, iterating over the state to which to go, we get O(n⋅k−−√⋅k−−√)=O(n⋅k)— this is still not enough to solve the hollow problem. 

Last observation 

If we are in the state of dp[i][remain] where remain=⌈ki⌉ for some i, we will apply the same idea to it. From it, we are interested in transitions to the states ⌈remainj⌉ for j=1,2,…remain. What kind of asymptotics will be obtained if we iterate over only interesting transitions? 

n⋅(∑r=1k√2⋅r√+2⋅⌈kr⌉−−−√)it can be shown that this is O(n⋅k3/4)— which solves the problemCode1801G - A task for substringsIdea and preparation: grphil 

SolutionLet's use the Aho-Korasik structure to store strings from S. Let's build compressed suffix links on it. This way it is a little more optimal to find all the lines from S ending in this position t. 

Denote by pref[i] the number of substrings of S in the prefix t of length i. 

Denote by suf[i] the number of substrings of S in the suffix t starting from the position i. 

Note that pref[r]+suf[l]−priv[|T|] is equal to the number of substrings of the string for t from S on the segment [l,p] minus the number of substrings of t from S that begin before l and end later than r. 

For each query, we will find a substring t that matches si, which covers the string t[l,r] and ends as close as possible to r. If there is no such thing, then the answer can be calculated using the previous formula. Otherwise, t[l,r] is invested in si[l′,r′]. At the same time, there are no substrings of S in the string si that begin before l′ and end later than r′. To get the answer, we apply the previous formula with the string si and the sub-section [l′,r′]. 

Asymptotics: O(S+t+mlogm)Code 

Codeforces Round 856 (Div. 2) Editorial 

By MateoCV, history, 14 hours ago, In EnglishThanks for participating in the round! I hope you enjoyed the problems! 

1794A - Prefix and Suffix Array 

Solution[problem:1794A]Observe that there are exactly two strings of length n−1 (one prefix and one suffix). We will call them x and y. Then, s is a palindrome if and only if rev(x)=y, where rev(x) is the reversal of string x. 

So, to solve the problem it is enough to find the two strings of length n−1 and check if one of them is equal to the reversal of the other. This solution also works for any length greater or equal to ⌊n2⌋. 

Intended complexity: O(n2) per test case. (reading the input) 

CodeFeedback1794B - Not Dividing 

Solution[problem:1794B]First, we add one to all the numbers in the array equal to 1. This uses at most n operations. Then, we iterate through the elements of the array from left to right, starting from the second element. At each step, let ax be the element we are iterating. If ax is divisible by ax−1, we add one to ax. Now this element is not divisible by ax−1, because otherwise both ax and ax+1 are divisible by ax−1, but that means 1 is also divisible by ax−1 which cannot happen since all the elements in the array are at least 2 (because of the first step we did). This part also uses at most n operations, so we used at most 2n operations in total. The resulting array will satisfy the statement property. 

Intended complexity: O(n) per test case. 

CodeAdditional commentFeedback1794C - Scoring Subsequences 

Solution[problem:1794C]We will first see how to find the cost of a single non-decreasing sequence s1,s2,…,sℓ. 

If we choose a subsequence with k elements, to achieve the maximum score it is optimal to choose the k largest elements. As the sequence is in non-decreasing order, the k largest elements will be the last k elements of the sequence. Thus, all possible candidates to be the answer are the suffixes of the sequence. 

Now let's divide the i-th element from the right by i. The sequence now turns into s1ℓ,s2ℓ−1,…,sℓ−12,sℓ1. Observe that the score of a suffix in the original sequence is equal to the product of the suffix of the same size in the new sequence. 

The original sequence satisfies s1≤s2≤…≤sℓ−1≤sℓ. It also true that 1ℓ≤1ℓ−1≤…≤12≤11 then combining these two inequalities we have s1ℓ≤s2ℓ−1≤…≤sℓ−12≤sℓ1 so the new sequence is also in non-decreasing order. 

In order to maximize the product of a suffix in the new sequence, we will choose all the elements in the new sequence which are greater or equal to 1 (these elements form a suffix because the new sequence is non-decreasing). If there are elements equal to 1 in the new sequence, we have to choose them in order to get the subsquence with maximum length (among all the ones with maximum score). 

Therefore, the cost of a sequence s1,s2,…,sℓ is the maximum length of a suffix of s1ℓ,s2ℓ−1,…,sℓ−12,sℓ1 such that each element is at least 1. 

Now, we have to find the cost of every prefix of the given sequence [a1,a2,…,an]. For a fixed k, the cost of [a1,a2,…,ak] will be the maximum length of a suffix of a1k,a2k−1,…,ak−12,ak1 such that each element is at least 1. We can find this length using binary search. Observe that we cannot compute the transformed sequence for every prefix, as that will be too slow. Instead, we can compute in each step of the binary search what would the number in that position be in the transformed sequence. By doing these, we can find the score of each prefix in O(logn) time. 

Intended complexity: O(nlogn) per test case. 

CodeFeedback1794D - Counting Factorizations 

Solution[problem:1794D]First, we will count how many times each different element in a occurs and check which of these elements are prime numbers. This can be done by checking for each element if it has a divisor up to its square root or using the Sieve of Eratosthenes. 

To construct a number m such that f(m)={a1,a2,…,a2n} we have to choose n elements of a to be the primes in its factorization and n elements to be the exponents. The numbers we choose to be the primes in the factorization have to be prime numbers and distinct. If there are less than n distinct primes in a, then there is no number m satisfying the property. So, from now on we will assume there are at least n distinct prime numbers in a. 

Let b1,b2,…,bs be the number of occurrences of each non-prime number in a and let c1,c2,…,ct be the number of occurrences of each prime number in a. After we choose the primes for the factorization, let c′1,c′2,…,c′t be the remaining number of occurrences of each prime number. As we can choose each prime number at most once, then c′i=ci or c′i=ci−1. For each way of choosing the primes, the number of possible values for m is n!b1!b2!…bs!c′1!c′2!…c′t! because this is the number of ways to choose where to place the exponents. The answer to the problem is the sum of all these numbers over all ways of choosing the prime numbers. 

Observe that when we sum terms of the form n!b1!b2!…bs!c′1!c′2!…c′t!, the value n!b1!b2!…bs! is a common factor over all these terms. Thus, we just need to find the sum of the terms 1c′1!c′2!…c′t! and then multiply by the common factor. 

To find this sum, we will use dynamic programming. Let g(x,y) be the sum considering only the primes from the x-th of them and assuming that y primes need to be chosen (or that n−y primes are already chosen). Then g(x,y)=1cx!×g(x+1,y)+1(cx−1)!×g(x+1,y−1). The value of g(1,n) will give the desired sum. 

Intended complexity: O(n2) (plus the complexity of primality checking) 

CodeAdditional commentFeedback1794E - Labeling the Tree with Distances 

Solution[problem:1794E]First, count the number of occurrences of each element in the list a. Let these numbers be c0,c1,…,cn−1. Then, compute the polynomial hash of the array c, that is H=∑i=0n−1cibi where b is the base of the hash. Because the tree is unweighted, there are only n possible values to write in the unlabeled vertex (all integers between 0 and n−1). Including this extra number, the hash has n possibilities: H+bi for each i=0,1,…,n−1. 

Now, let's compute the same hash for each vertex of the tree. That is, for each vertex x count how many vertices are at distances 0,1,…,n−1, and if these numbers are d0,d1,…,dn−1 compute the value hx=∑i=0n−1dibi. 

To compute these values efficiently, we will use rerooting dynamic programming: We will make two DFS. In the first one, compute the parent of each node and the hash of each node only considering the nodes in its subtree. For each vertex x, if we call this hash dpx then dpx=1+b∑childidpi. In the second one (which must be performed after the first one), for each vertex x compute the hash of the parent of x considering the nodes which are not in the subtree of vertex x. If we call this hash dp2x then dp2x=dppax−bdpx+bdp2pax where pax is the parent of x. 

Now, observe that hx=dpx+bdp2x. With these hashes, we can compute the good vertices. A vertex x will be good if and only if hx=H+bi for some i=0,1,…,n−1. Doing a two pointers algorithm with the two sorted lists h1,h2,…,hn and H+1,H+b,H+b2,…,H+bn−1 is enough to find for each hx if there is a number on the other list equal to it. 

To make the solution pass, it is advisable to use hashing with multiple modules or just one big modulo. 

Intended complexity: O(nlogn). 

CodeFeedback 

Codeforces Round 855 (Div. 3) Editorial 

By Vladosiya, history, 34 hours ago, translation, In English1800A - Is It a Cat? 

Idea: Vladosiya, MikeMirzayanov 

Tutorial1800A - Is It a Cat?To solve the problem, you may convert the string to lower case, strip all duplicated characters from it and compare the result to "meow" string. 

To exclude duplicate characters, you can, for example, use the unique function in C++. 

Solution1800B - Count the Number of Pairs 

Idea: myav 

Tutorial1800B - Count the Number of PairsCount two arrays big and small, such that big[i] contains the number of occurrences of ith letter of the alphabet in the string in upper case, while small[i] — in lower case. 

Let's add all existing pairs to the answer, so let's add min(small[i],big[i]) to it for each letter. Subtract this minimum from small[i] and big[i] to get the number of unpaired identical letters. 

Next, we will act greedily: if there is some set of at least two identical letters in the same case, we can apply the operation to half of them and get new pairs. Therefore, for each letter we will add min(k,max(small[i],big[i]))2 to the answer and decrease k by that amount. 

Solution1800C1 - Powering the Hero (easy version) 

Idea: Vladosiya 

Tutorial1800C1 - Powering the Hero (easy version)To solve it, it should be noted that despite the way the deck with bonuses works, the order in which they will be applied is not important. Then, when we meet the hero card, we just need to add to the answer the maximum of the available bonuses. 

Constraints allow you to sort the current array with bonus values each time and remove the maximum element. 

Solution1800C2 - Powering the Hero (hard version) 

Idea: Vladosiya 

Tutorial1800C2 - Powering the Hero (hard version)To solve it, it should be noted that despite the way the deck with bonuses works, the order in which they will be applied is not important. Then, when we meet the hero card, we just need to add to the answer the maximum of the available bonuses. 

Constraints make you use structures such as a priority queue to quickly find and extract the maximum. 

Solution1800D - Remove Two Letters 

Idea: MikeMirzayanov 

Tutorial1800D - Remove Two LettersConsider deleting characters with numbers i and i+1, as well as characters with numbers i+1 and i+2. In the first case, the symbol with the number i+2 remains, in the second - i. Symbols with numbers less than i or more than i+2 remain in both cases. Therefore, the same strings will be obtained if the characters with the numbers i and i+2 match. Therefore, we just need to count the number of i:1≤i≤n−2:si=si+2, and subtract this value from n−1. 

Solution1800E1 - Unforgivable Curse (easy version) 

Idea: Aris, talant 

Tutorial1800E1 - Unforgivable Curse (easy version)In these constraints , the problem could be solved as follows: 

Note that for strings of length 6 and more, it is enough to check that the strings s and t match character by character, that is, up to permutation, since each character can be moved to the desired half, and then moved to the desired side by length 1 by applying two operations on the length is 3 and 4. 

For example, there was a string "abudance" and we want to shift the c character to the left, then we can first get the string "acudab" and then the string "aaudcb". Well, we can restore the used symbols by putting them in their place "budka". That is, we were able to simply swap two adjacent characters. 

Thus, with such a clipping, it was possible to solve the problem by brute force for n≤5. To iterate, it was possible to store map of strings, which we can get and iterate through all the strings using bfs. 

Solution1800E2 - Unforgivable Curse (hard version) 

Idea: Aris, Vladosiya 

Tutorial1800E2 - Unforgivable Curse (hard version)The solution of the problem E1 hints to us that with the help of such operations, it is possible to move the symbol in the right direction by 1 using two operations. Then we can show that among the symbols that we can swap with at least one other symbol, we can get any permutation. 

For example, you can apply such a greedy solution: we will build an answer from the boundaries of the string t to the middle. Since we can move the symbol by a distance of 1, we can move it to the border and thus we can build any string t. 

Thus, it is enough to check that the sets of characters that can be swapped with some other match. And for the rest of the characters, check that they just match. 

Solution1800F - Dasha and Nightmares 

Idea: Gornak40 

Tutorial1800F - Dasha and NightmaresObservation 1: the product of odd numbers is odd, so the condition for the length of nightmare is automatically completed. 

Denote by f(x) the number of ones in binary representation of x. Let's enumerate the letters of the Latin alphabet from 0 to 25. 

Observation 2: for each word, it is enough to know the set of letters included in it and the evenness of their numbers. There are only 26 letters in the alphabet, so it is convenient to store the word characteristic si as a pair of masks ⟨ai,bi⟩. The bit with the number j in ai will be responsible for the availability of the letter j in si. The bit with the number j in bi will be responsible for the evenness of the number of letters j in si. 

Observation 3: strings sisj creates nightmare if and only if f(ai|aj)=f(bi⊕bj)=25. 

Let's fix the number k — the index of the letter that will not be in nightmares. Let's throw out all the words with the letter k, now we can look at the words in turn and look for a pair of them among those already considered. It is easy to see that the condition f(ai|aj)=25 follows from the condition f(bi⊕bj)=25 if one letter is banned. 

To count the number of pairs that include our word, we need to count the number of words with the characteristic bj=bi⊕(226−1). We can do this by bin-searching through a sorted array of b or using standard data structures. We got the solution for O(∑|s|+26⋅n⋅logn). 

Solution1800G - Symmetree 

Idea: Vladosiya 

Tutorial1800G - SymmetreeNote that if one subtree is a mirror image of another, then they are isomorphic (that is, equal without taking into account the vertex numbers). To check the subtrees for isomorphism, we use hashing of root trees. 

Now we just have to learn how to check trees for symmetry. To do this, let's calculate how many children of each type our vertex has (let's denote the hash of its subtree by the vertex type). In order for the vertex subtree to be symmetric, each child must have a pair of the same type, except perhaps one, which must also be symmetric. We can calculate the symmetry of the subtrees while counting their hash to simplify this task. 

Solution 

Codeforces Round #854 Editorial 

By subscriber, history, 83 minutes ago, In English1799A - Recent ActionsNote, that posts will be removed in the order n,n−1,…,1. 

The post n−k+1 will be removed at the first time, when there are at least k different numbers among p1,p2,…,pi. 

So let's calculate the number of different numbers among p1,p2,…,pi for each i using boolean array of length m iterating i from 1 to m. Using them we can calculate the answer. 

Time complexity: O(n+m). 

1799B - Уравняй делениемIf all numbers are equal initially — we can do nothing. 

Otherwise if some ai=1, answer do not exist: this ai can't became bigger during operations and all other elements can't be equal to 1 simultaniously, because after the last operation aj>1 (otherwise we can remove this operation). 

If all ai≥2, the answer exists and we can simulate such algorithm: let's take i, such that ai is maximum possible and j, such that aj is smallest possible. Make operation with (i,j). Note, that after at most 30n operations all elements will be equal. 

It is true, because after each operation ai decreases at least by 2 times (and rounded up) and all elements are bounded ax≥2 after each operation. Each number can't be decreased more than 30 times. 

Time complexity: O(n2logC), where C=109. 

1799C - Double Lexicographically MinimumLet's iterate all symbols of s in order from smallest to largest and construct an answer tmax. 

Let the current symbol be x. 

If there are at least 2 remaining symbols equal to x, we should add them to the current prefix and suffix of tmax and continue.If there are at most one other symbol y is left (there are x and c times y left in s) we should add ⌈c2⌉ symbols y, symbol x and ⌊c2⌋ symbols y to the prefix of tmax and break.Otherwise we should add all remaining symbols of s (excluding x) to prefix of tmax in the sorted order and after it symbol x.Time complexity: O(n+A), where A=26. 

1799D2 - Hot Start Up (hard version)Consider maintaining the following 2-dimensional DP: dpi,j will be the minimum time needed to run all previous programs such that the last program run on CPU 1 was program i, and the last program run on CPU 2 was program j. Initially we have dp0,0=0 (here, 0 is a placeholder program) and dpi,j=INF for (i,j)≠(0,0). 

When we come to a program x, we can transition as follows. First, create a new DP array ndp, initialized to all INF. Then: 

For all dpi,j with i≠x, set ndpx,j=min(ndpx,j,dpi,j+coldx).For all dpx,j, set ndpx,j=min(ndpx,j,dpx,j+hotx).For all dpi,j with j≠x, set ndpi,x=min(ndpi,x,dpi,j+coldx).For all dpi,x, set ndpi,x=min(ndpi,x,dpi,x+hotx).After all updates, replace dp with ndp. 

This works in O(nk2). To optimize it, we can notice that after processing a program x, only entries in dp with the row or column equal to x will be non-INF. Consider instead the following 1-dimensional DP array: dpi contains the minimum time to run previous programs if one CPU last ran program x, and the other last ran program i. 

Initially, dp0=0 and all other dpi=INF. Also, we add a dummy program with ID 0, and hot0=cold0=0 (this will make implementation easier). 

When we come to a program x, again, let's create a new DP array ndp, again initialized to all INF. Then, we can case on whether the previous program was equal to x. 

If the last program run was also x:For all i, set ndpi=min(ndpi,dpi+hotx).For all i≠x, set ndpx=min(ndpx,dpi+coldx).Set ndpx=min(ndpx,dpx+hotx).Otherwise, let y be the last program run.For all i, set ndpi=min(ndpi,dpi+coldx).For all i≠x, set ndpy=min(ndpy,dpi+coldx).Set ndpy=min(ndpy,dpx+hotx).This gets us a O(nk) solution which gets accepted in the easy version. 

To optimize it further, we can use a data structure to perform updates (since with each transition we either add some value to every dp element, or add some value to a single index). It is possible to do this in constant time per update, or using a segment tree or some other range update structure (though this is somewhat overkill). The overall complexity then becomes O(n+k) or O(nlogk+k) per test. 

1799E - City UnionLet's note, that the resulting grid is correct if and only if filled cells form continious segment in each row and column (condition *) and there is one city. 

So we can define a filling operation: given a grid, fill all cells between the most left and most right cells in each row and the most up and most down cells in each column. Doing this operation (n+m) times we get that condition * is satisfied and we filled cells that definitely should be filled. If now there is one city, we solved the problem. 

But if there are still two cities, their projections to horisontal and vertical axes do not intersect. So we need to connect them with some path. 

Let's consider the case when one city is upper left than the other city (otherwise we can apply rotation and get this case). Let's define the lowest row of the first city as i1, the right column of the first city as j1, the upper row of the second city as i2 and the left column of the second city as j2. We can fill cells on any Manhattan shortest path between cells (i1,j1), (i2,j2). After that again using filling operation we will fill cells that should be filled. 

It is easy to see, that by this solution we will get the smallest possible number of filled cells. 

Time complexity: O(nm(n+m)). 

1799F - Halve or SubtractFor convenience, let half(x) denote ⌈x2⌉, and sub(x) denote max(x−b,0). 

First, notice that if we apply both operations to some element, it will be optimal to apply halving first, then subtraction. We can prove this with 2 cases: 

ai≤2b. In this case, half(ai)≤b, and so sub(half(ai))=0. Since applying either function to a nonnegative integer results in a nonnegative integer, 0=sub(half(ai))≤half(sub(ai)).Otherwise, ai>2b. Then sub(half(ai))=ai−⌊ai2⌋−b, and half(sub(ai))=ai−b−⌊ai−b2⌋. Since ⌊ai−b2⌋≤⌊ai2⌋, sub(half(ai))≤half(sub(ai)).Next, suppose there are exactly p elements to which we apply both operations. Then, it will be optimal to apply both operations to the p greatest elements in the array. This should be somewhat intuitive, but here's a proof: 

Suppose there are some ai,aj such that ai<aj. Suppose we apply both operations to ai, and only one operation to aj. Then applying both operations to aj and a single operation to ai instead won't increase the resulting sum. We can prove this with two cases:We apply half to aj. Note that since it's optimal to apply half first when applying both operations, this case is essentially: halve both elements, then choose one to apply sub to. And it's better to subtract b from the greater element, since x−sub(x)≤y−sub(y) for x≤y.We apply sub to aj. We can analyze this with (surprise!) a few cases:ai,aj≤2b. Then whichever element we apply both operations to will be 0, and the result will depend only on the other element. sub(x)≤sub(y) for x≤y, so it's better to apply both operations to the greater element.aj>2b. If we apply both operations to the greater element, we subtract min(ai,b)+⌊aj2⌋+b from the sum. But applying both operations to the lesser element subtracts ⌊ai2⌋+min(half(ai),b)+b≤min(ai,b)+⌊ai2⌋+b from the sum. So it's optimal to apply both operations to the greater element.And this covers all cases where ai<aj.Let's fix p, the number of elements we apply both operations to. After taking them out, we will be left with the n−x smallest elements in the array. Suppose we have v1 operations of type 1 left, and v2 operations of type 2 left. We'll assume v1+v2≤n−x (otherwise we can apply both operations to more elements). 

Notice that it's optimal to apply our v1+v2 operations to the v1+v2 greatest remaining elements: subtracting from a greater element can't decrease the amount we subtract, and halving a greater element can't decrease the amount we take away. So we're left with v1+v2 elements, and we want to choose v1 of them to apply the halving to. 

Let's consider a few cases and try to analyze them. Let ai≤aj, and suppose we want to apply half to one of them and sub to the other. 

ai,aj≤b. Then it will be optimal to apply sub to the greater element.b≤ai,aj. Then it will be optimal to apply sub to the smaller element.Using this information, we can form the final lemma we need for our solution: 

Let ai≤aj≤ak. Suppose we apply sub to ai and ak, and half to aj. Then it will not increase the answer to apply half to one of ai or ak instead.There are 4 cases we should consider to prove this lemma: 

ak≤b. Then we should apply half to ai and sub to the others.b≤ai. Then we should apply half to ak and sub to the others.ai,aj≤b≤ak. Then we should apply half to ai and sub to the others.ai≤b≤aj,ak. Then we should apply half to ak and sub to the others.You can verify that doing this produces the optimal answer. And using this lemma, we find that the optimal answer has all sub operations applied to some of the middle elements, with all half operations applied to the endpoints. 

To summarize, the optimal answer will have a form like this (assuming a is sorted in non-increasing order, a1≥a2≥a3≥…≥an): 

First come some elements to which we apply both operations.Second come some elements to which we apply only half.Third come some elements to which we apply only sub.Fourth come some elements to which we apply only half.Finally come some elements to which we apply no operations.Note that some of these segments may be empty. 

It's easy to verify that it's optimal to use all given operations. So if we loop through all possible sizes for the first two segments, we can uniquely determine the sizes of the last three. Finally, using prefix sums to quickly find the sums of elements in a segment, we get an O(n2) solution. 

There is an interesting fact: if we will fix the size of the first group p and calculate the answer f(p) for it, the function f is convex. So the ternary or binary search can be used here to find the minimum in O(nlogn) time, but it was not necessary. 

Codeforces Round #853 (Div. 2) Editorial 

By Serval, history, 48 minutes ago, In English1789A - Serval and Mocha's ArrayIdea & Preparation: Bazoka13 

TutorialConsidering an array a of n (n≥2) positive integers, the following inequality holds for 2≤i≤n: 

gcd(a1,a2,⋯,ai)≤gcd(a1,a2)≤2Therefore, when the prefix [a1,a2] of a is good, we can show that all the prefixes of a whose length is no less than 2 are good, then a is beautiful. It is obvious that [a1,a2] is good when a is beautiful. So we get the conclusion that a is beautiful if and only if the prefix [a1,a2] is good. 

We can check if there exist ai,aj (i≠j) such that gcd(ai,aj)≤2. If so, we can move ai,aj to the front of a to make it beautiful, then the answer is Yes. If not, the answer is No. 

Time complexity: O(n2). 

1789B - Serval and Inversion MagicIdea & Preparation: Bazoka13 

TutorialIf s is palindromic initially, we can operate on the interval [1,n], the answer is Yes. 

Let's consider the other case. In a palindrome s, for each i in [1,⌊n/2⌋], si=sn−i+1 must hold. For those i, we may check whether si=sn−i+1 is true in the initial string. For all the illegal positions i, the operation must contain either i or n+1−i, but not both. For the legal positions, the operation must contain neither of i nor n+1−i, or both of them. 

If the illegal positions is continuous (which means that they are l,l+1,…,r−1,r for some l and r), we may operate on the interval [l,r] (or [n+1−r,n+1−l]), making the string palindromic. The answer is Yes. 

Otherwise, there must be some legal positions that lie between the illegal ones. Suppose the illegal positions range between [l,r] (but not continuous), and the operation is [o1,o2]. Without loss of generality, let the operation lies in the left part of the string. Then o1≤l,r≤o2<n+1−r must hold to correct all the illegal positions. This interval covers all the legal positions that lie between the illegal ones but does not cover their symmetrical positions. Thus, such kind of operation will produce new illegal positions. In other words, there are no valid operations in this situation. The answer is No. 

Time complexity: O(n). 

1789C - Serval and Toxel's ArraysIdea & Preparation: Toxel 

TutorialConsider the contribution of each value. We only need to count the number of concatenated arrays each value appears in, and sum all those counts up. The answer to this problem only depends on the number of appearances of this value. Notice that the appearance of each value forms some intervals. Each interval starts when it modifies another element (or in the initial array), and ends when it is modified (or in the m-th array). As there are no duplicate elements, the intervals do not intersect, so we can simply sum their lengths up. 

Let's use an array appear to track the appearance of each value. We first set the appearance of the initial elements to 0, and other elements to −1, which means the value does not appear. Then, in the i-th modification, suppose we modified some elements from x to y, then we should add i−appearx to countx, and set appearx to −1. We should also set appeary to i. After all operations, for all x, add m−appearx to countx if appearx is not −1. 

Value x appears in m(m+1)2−(m−countx)(m−countx+1)2 concatenated arrays. 

Time complexity: O(n+m). 

1789D - Serval and Shift-Shift-ShiftIdea & Preparation: Toxel 

TutorialFirst of all, it could be proven that the answer exists if and only if a and b are both zero or a and b are both non-zero. 

If a is zero, it remains zero after any operations. Therefore it cannot become b if b is non-zero. If a is non-zero, logical left shift it will definitely increase its lowest bit or make it zero, thus changing it into a different number. The same applies to logical right shift. Therefore, the xor result must be non-zero and there are no possible operations if b is zero. 

We will show that it is always possible to change a into b in the other cases. We denote lb(a) as the lowest bit of a and hb(a) as the highest bit of a. If a and b are both zero, no operations are needed. If they are both non-zero, the construction consists of four steps: 

If hb(a)<lb(b), logical left shift a by lb(b)−hb(a) bits. Then hb(a) must be equal or greater than lb(b).For each bit i of lb(b)−1,lb(b)−2,…,1, if ai=1, we may logical right shift a by hb(a)−i bits to erase it. After that, we have lb(a)≥lb(b).If lb(a)>lb(b), logical right shift a by lb(a)−lb(b) bits. Now it is guaranteed that lb(a)=lb(b).For each bit i of lb(b)+1,lb(b)+2,…,n, if ai≠bi, we may logical left shift a by i−hb(a) bits to erase it. After that, we must have a=b.Step 2 and step 4 require at most n−1 operations. We may also note that step 1 and step 3 never appear simultaneously. If step 1 is operated, then lb(a)=lb(b) is guaranteed after step 2. Thus, we need not operate step 3 in this case. In conclusion, we may use no more than n operations to change a into b if they are both non-zero. 

Time Complexity: O(n2) or O(n2w) by using std::bitset. 

1789E - Serval and Music GameIdea & Preparation: Serval 

TutorialConsider the following two cases: 

Case 1: x is not a factor of sn. 

In this case we have ⌊snx⌋+1=⌈snx⌉. Let k=⌊snx⌋. It can be shown that there are at most 2sn−−√ different values of k. The constraint of si can be written in the following form: 

si=pi⋅k+qi⋅(k+1)=(pi+qi)⋅k+qiFor a certain k, such pi and qi do not exist if and only if simodk>⌊sik⌋. To prove it, we show the contradiction that qimodk=simodk>⌊sik⌋≥qi, and we can give a construction of pi and qi when simodk≤⌊sik⌋ that qi=simodk and pi=⌊sik⌋−qi. 

By observation, these si are in one of the following k−2 intervals: 

[1,k−1],[k+2,2k−1],…,[(i−1)k+i,ik−1],…,[(k−2)k+(k−1),(k−1)k−1]We can count the number of these si by pre-calculating the prefix sums to calculate f(x). 

This case can be solved in O(sn) time, and we will show this fact: 

When k≤sn−−√, there are k−2 intervals that need to be considered for a certain k. Since ∑k≤sn√k≤sn, this part can be solved in O(sn) time.When k>sn−−√, notice that there are at most ⌈snk⌉≤sn−−√ intervals that need to be considered for a certain k. Recall that there are at most sn−−√ different values of k in this part, so it can be solved in O(sn) time.Case 2: x is a factor of sn. 

In this case we have ⌊snx⌋=⌈snx⌉. Let k=snx. The constraint of si becomes: 

si=(pi+qi)⋅kTo calculate f(x), we only need to count the number of multiples of x. To do this, we can first calculate s′i=gcd(si,sn) for all 1≤i≤n in O(nlogsn) time. It is obvious that s′i is a factor of sn. For a certain x, we can enumerate all the factors of sn, find out the multiples of x among them, and sum up the times that they occurred in s′. Recall that sn has at most 2sn−−√ factors, so this takes O(sn) time. 

This case can be solved in O(nlogsn+sn) time in total. 

Time complexity: O(nlogsn+sn). 

O(sn+σ(sn)) solutions can pass all the tests, where σ(n) denotes the sum of all the factors of n. A well-implemented O(snlogsn) solutions may pass the tests, too. 

Bonus: Solve this problem in O(n+sn) time. 

1789F - Serval and Brain PowerIdea & Preparation: Serval 

TutorialAssume that the longest powerful subsequence of the given string S is T, which can be obtained by concatenating k copies of string T′. Noticing that |S|≤80, we have the observation that k⋅|T′|≤|S|≤80, so it is impossible that both k and |T′| is large. 

When k<5, we only need to consider the k=2 case and the k=3 case. The k=4 case is covered by k=2 case, since T=T′+T′+T′+T′=(T′+T′)+(T′+T′). 

For the k=2 case, we split S into two parts S=S1+S2, then calculate the maximal length of LCS(S1,S2) by dynamic programming over all the possible splits. This case can be solved in O(w2⋅|S|3) time, where w2 is a small constant. 

It is similar to solve the k=3 case. We split S into three parts S=S1+S2+S3, then calculate the maximal length of LCS(S1,S2,S3) over all the possible splits. This case can be solved in O(w3⋅|S|5) time, where w3 is a small constant. We will estimate w3 later. 

When k≥5, we have |T′|≤|S|k≤|S|5. It can be shown that, if we split S into 5 parts, T′ will be the subsequence of at least one of them. We can split S into equal lengths, then enumerate all the subsequences of these substrings as the possible T′. For a possible T′, we can find out corresponding k by matching T′ and S greedily. This case can be solved in O(5⋅2|S|/5|S|). 

Now let us roughly estimate how small w3 could be. The time that dynamic programming consumed for certain S1,S2,S3 is |S1|⋅|S2|⋅|S3|. Since |S1|+|S2|+|S3|=|S|, we have |S1|⋅|S2|⋅|S3|≤127|S|3. Recall that there are (|S|−12)≤12|S|2 possible splits, then w3≤154 holds. 

Time complexity: O(w3⋅|S|5+5⋅2|S|/5|S|). 

Codeforces Round #852 Editorial 

By vaaven, 13 days ago, translation, In English1793A - Yet Another Promotion was authored and prepared by Ormlis 

1793B - Fedya and Array was authored and prepared by TheEvilBird 

1793C - Dora and Search was authored by fedoseev.timofey and prepared by vaaven 

1793D - Moscow Gorillas was authored and prepared by Gornak40 

1793E - Velepin and Marketing was authored and prepared by Tikhon228 

1793F - Rebrending was authored by Tikhon228 and prepared by vaaven 

1793A - Yet Another PromotionLet n=(m+1)⋅q+r. 

Note that you need to use a promotion if a⋅m≤b⋅(m+1). In this case, we will buy potatoes q times for the promotion. The remaining potatoes (or all if the promotion is unprofitable) can be bought at min(a,b) per kilogram. 

Then the answer is: 

q⋅min(a⋅m,b⋅(m+1))+r⋅min(a,b)Thus this solution works in O(1)Code1793B - Fedya and ArrayNote that the local minimums and maximums will alternate, and there will be the same number of them k. Let's call the i-th local maximum by ai, the i-th local minimum by bi. Without loss of generality, consider that ai goes before bi. To get bi from ai we need to write out ai−bi numbers, to get a(i+1)modk from bi we need to write out a(i+1)modk−bi numbers. 

Thus, (a1−b1)+(a2−b1)+(a2−b2)+…+(ak−bk)+(a1−bk)= 

=2⋅(a1+a2+…+ak)−2⋅(b1+b2+…+bk)=2⋅(A−B)=nThe array [y,y+1,y+2,…,x−1,x,x−1,x−2,…,y+1] will satisfy the condition. 

Code1793C - Dora and SearchSuppose we want to check whether the entire array satisfies the claim. If this is the case, then we can output the entire array as an answer. Otherwise, one of the two extreme elements does not meet our requirements. From this we can conclude that all segments containing an element that does not meet our requirements will also be incorrect, because this extreme element will remain the minimum/maximum. 

The algorithm follows from the fact above: let's look at the sub-section [l;r], which is initially equal to [1;n]. If al=min(al,al+1,…,ar) or al=max(al,al+1,…,ar), then we proceed to the segment [l+1;r]. A similar reasoning is also needed for ar. Thus, either after some iterations we will get the required sub-section, or we will get l==r and the answer will be −1. 

Final asymptotics: O(nlogn) or O(n) depending on the implementation. 

Code1793D - Moscow GorillasDenote by posx the index of the number x in the permutation. Subsegments with MEX>1 are as follows 1≤l≤pos1≤r≤n. 

Denote by: lx=min[pos1,pos2,…,posx], rx=max[pos1,pos2,…,osx]. 

Subsegments with MEX>x are as follows 1≤l≤lx≤rx≤r≤n. Let's find all subsegments with MEX=x. 

If posx+1<lx, then the subsegments with MEX=x+1 are as follows posx+1<l≤lx≤rx≤r≤nIf lx≤posx+1≤rx, then there is no subsegment with MEX=x+1If rx<posx+1, then the subsegments with MEX=x+1 are as follows 1≤l≤lx≤rx≤r<posx+1It remains only to intersect the sets of such subsegments for p and q, which is done trivially. 

Code1793E - Velepin and MarketingLet's sort people by their group size requirement. Suppose we have such a person i that he is not satisfied, and we have a person j>i who is satisfied. Then we can replace person j in his group with i and the answer for us will not be worse. It follows that for a particular k the answer is some prefix of the people we can make satisfied. 

Let us also prove that there exists some arrangement of groups that covers the same prefix, and that each group is a continuous segment. Let's take some correct partitioning into groups. Then each group will be a set of unconnected segments. Let's take the leftmost such segment. Note that we can swap it to the nearest segment of the same group to the right without breaking anything. 

Thus we obtained that we can look for a solution in the form of partitioning each prefix into valid groups, which are segments. We will solve this problem using dynamic programming. 

Let dp[i] -- the maximum number of groups into which ith prefix can be partitioned, so that everyone is satisfied (and no elements beyond the prefix can be used). Dynamics base: dp[0]=0 (empty prefix maximum can be divided into 0 groups). Transition: for ith person his group must have size at least a[i], so the transition looks like this dp[i]=max0⩽j⩽i−a[i]dp[j]+1. But what if a[i]>i? Then we can't dial the ith prefix. Then we put dp[i]=−∞. This dynamics can be calculated using prefix maximums. This part of the solution works for O(n). 

Earlier we said that the answer would be some prefix of people who would be satisfied. If we can partition the prefix into some number of groups, then that answer can be the prefix for all k⩽dp[i]+n−i. (we partition our prefix into dp, and the rest of the people one by one into the group) 

If we can't make the whole prefix satisfied (dp[i]=−∞), then we need to add people from outside. Thus, the maximum number of groups we can split into if ith prefix is completely satisfied is n−a[i]+1. 

Note that if by some prefix we can score k, then we can also score k−1 (combining two groups into one). Then we need to find the largest prefix that fits the given k in the query. This can be done by an array of suffix maximums over O(q) total. The final asymptotic of the solution is O(nlogn+q). 

Code1793F - RebrendingLet's go through all the elements from left to right. The main task will be to support the current version of dp[i] -- the minimum difference of ai with the elements to the right of it that we managed to consider. Let us correctly calculate dp for the first r elements. Let's move on to r+1. Let's show how to update the answer for all j<i, such that a[j]>a[i]. For j<i, such that a[j]<a[i] is solved similarly. 

Let's take the first element a[j] to the left of i, such that a[j]>a[i]. Note that if there is l<j<i such that a[l]>a[j]>a[i], then we will not update dp[l] for it, because |a[l]−a[j]|<|a[l]−a[i]|. Also, we will not update the answer for l such that |a[l]−a[j]|<|a[l]−a[i]|, that is, if a[l]>a[i]+a[j]−a[i]2. Therefore, further we will be interested only in the numbers from the segment [a[i],a[i]+a[j]−a[i]2]. 

Let's note that we have reduced the length of the segment by 2 times. That is, there will be no more such iterations than O(logn). You can find the rightmost number belonging to a segment using the segment tree. The answer for the segment li,ri will be minli⩽j<rdp[l] at the moment ri. This can also be efficiently found using the segment tree. The final asymptotics of the solution is O(nlog2n+qlogn). 

There is also a solution for O(nn−−√+qlogq) that passes all the tests. 

Code 

Codeforces Round #851 (Div. 2) Editorial 

By azberjibiou, 2 weeks ago, In English1788A - One and Two 

Problem idea: azberjibiou 

Tutorial1788A - One and TwoThere should be same number of 2 at a1,a2,⋯ak and ak+1,⋯,an. 

By checking every k, we can solve the problem at O(N2). By sweeping k from 1 to n−1, we can solve the problem in O(N). Not counting the number of 2 but naively multiplying using sweeping in python was accepted since it has time complexity O(N2). 

Checking every k and naively multiplying solutions are O(N3), so those solutions won't fit in time limit. 

1788B - Sum of Two Numbers 

Problem idea: azberjibiou 

Tutorial1788B - Sum of Two NumbersLet's assume that there is no carry while adding x and y. Denote n=a9⋯a1a0, x=b9⋯b1b0, y=c9⋯c1c0 in decimal system. The condition can be changed as the following condition. 

- ai=bi+ci for all 0≤i≤9. - Sum of bi and sum of ci should differ by at most 1. 

If ai is even, let bi=ci=ai/2. Otherwise, let bi and ci be ai+12 or ai−12. By alternating between (bi,ci)=(ai+12,ai−12) and (bi,ci)=(ai−12,ai+12), we can satisfy the condition where sum of bi and sum of ci differ by at most 1. 

There is an alternative solution. If n is even, divide it into (n2,n2). If remainder of n divided by 10 is not 9, divide it into (n+12,n−12). If remainder of n divided by 10 is 9, recursively find an answer for ⌊n10⌋ which is (x′,y′) and the answer will be (10x′+4,10y′+5) or (10x′+5,10y′+4) depending on what number has a bigger sum of digits. 

The following solution has a countertest. 

1. Trying to find x and y by bruteforce from (1,n−1). 2. Trying to find x and y by bruteforce from (n+12,n−12) 

A solution that randomly finds (x,y) passes. 

1788C - Matching Numbers 

Problem idea: azberjibiou 

Tutorial1788C - Matching NumbersLet's assume that 1 to 2n is paired and each sum of pair is k,k+1,⋯,k+n−1. Sum from 1 to 2n should equal to the sum of k to k+n−1. So we obtain n(2n+1)=(2k+n−1)n2, which leads to 4n+2=2k+n−1. Since 4n+2 is even, 2k+n−1 should be even. So if n is even, we cannot find such pairing. 

If n is odd, there are various ways to make such pairing. Let m=n−12. (1,3m+3),(2,3m+4),…(m,4m+2),(m+1,2m+2),(m+2,2m+3),…(2m+1,3m+2) can be such pairing. 

1788D - Moving Dots 

Problem idea: azberjibiou 

Tutorial1788D - Движущиеся точкиLet's think about the original problem where we do not think about subsets. 

We can easily observe that each dot does not change direction during moving. 

Assume that dots gather at coordinate x. Rightmost dot of dots that have smaller coordinate than x should move right, and leftmost dot which has bigger coordinate than x should move left. We can observe that the number of adjacent dot where each move toward each other will be the answer. 

Now let's solve the problem for subsets. Instead of counting number of adjacent dot that moves toward each other for each subset of dots, we will count the number of subset for each possible 1≤i<j≤N where dot i moves right and dot j moves left and there are no dots between i and j. 

Let the coordinate of a dot in a subset be k. We will try to find out which k can be in a subset where dot i and dot j move toward each other. 

Since there are no dot between i and j, dots satisfying xi<k<xj should not be in the subset. Since dot i should move right, dots that satisfy k<xi and xi−k≤xj−xi should not be in the subset. As the same way for dot j, dots that satisfy k>xj and k−xj<xj−xi should not be in the subset. Summing these up, dots satisfying 2xi−−xj≤k<2xj−−xi should not be in the subset. By using binary search, we can find the number of dots that cannot be in the subset in O(logN). 

If there are p dots that can be in the subset, the number of subset where i and j moves toward each other will be 2p. Summing all 2p will give us the answer. Since there are O(N2) pairs of (i,j), we can solve the problem in O(N2logN). 

Instead of using binary search, we can use the monotonicity of 2xj−xi and 2xi−xj when j increases, we can solve the range of dots that cannot be in the subset in O(N2) by sweeping. Both O(N2logN) and O(N2) solutions will be accepted. 

There were some dynamic programming solutions from some testers. 

1788E - Sum Over Zero 

Problem idea: azberjibiou 

Problem solver: YeongTree 

Tutorial1788E - Sum Over ZeroDenote p as the prefix sum of a. For a segment [x+1,y] to be an element of S, px≤py should be satisfied. 

Let's denote dpi as the maximum value of the sum of length of segment smaller than i in S. Segment [x,y] is smaller than i if y≤i. If there is no segment ending at i, dpi=dpi−1. If there is segment [k+1,i] in S, dpi=maxpk≤pi(dpk+i−k). By summing up, dpi=max(dpi−1,maxpk≤pi(dpk+i−k) With this dp, we get an O(N2) solution. 

Now let's try to speed up the dp transition using segment tree. First, use coordinate compression on pi since we only see whether one prefix sum is bigger than the other. We will maintain a segment tree that stores dpk−k in position pk. 

Let's find dpi in order of i. dpi=max(dpi−1,maxpk≤pi(dpk−k)+i) We can solve maxpk≤pi(dpk−k) by range query [0,pi] on a segment tree. So we can solve dpi in O(logN) for each i. 

The entire problem is solved in O(NlogN). 

There is an alternative solution that maintains pair (dpk−k,pk) monotonically with a set. This solution also runs in O(NlogN). 

1788F - XOR, Tree, and Queries 

Problem idea: azberjibiou 

Tutorial1788F - XOR, Tree, and QueriesLet's denote pi as xor of edges in path from node 1 to node i. Edges in path from i to j is 

(edges in path from 1 to i) + (edges in path from 1 to j) — 2×(edges in path from 1 to lca(i,j)) 

where lca(i,j) denotes the least common ancestor of i and j. Since xor of two same number is 0, we can observe that xor of path from i to j is pi⊕pj. 

If we know every pi for all i, weight of edge connecting i and j is pi⊕pj, so deciding weight of every edge is equivalent to deciding every pi for i≥2. 

Let G be the original tree graph. Let's make a undirected weighted graph G′ from the given condition. Condition (u, v, x) makes an edge connecting u and v with weight x. This edge means that pv=pu⊕x. Now if u and v are connected by edges in G′, this means that pv=pu⊕ (xor of edges in path from u to v). 

First, let's check if it is possible to make a graph that satisfies the conditions. 

If G′ is a connected graph, we can solve pi using dfs from node 1. For edges not used in dfs (back edges), we have to check if it is valid with the solved pi. Specifically, if there is an edge (u, v, x), we need to check if pu⊕pv=x. 

Now let's think when G′ is not a connected graph. By dividing the graph into connected components, we can solve if it is impossible to make a graph that satisfies the conditions in a same fashion. 

Now let's try to minimize a1⊕a2⊕⋯⊕an−1. 

For edge (u,v) in G, weight of edge is pu⊕pv. By substituting ai into pxi⊕ pyi, a1⊕a2⊕⋯⊕an−1 can be written as xor of pi where node i has odd degree. Let the connected components of G′ be G1,G2,…,Gk. Pick any vertex rk in each component Gk. For every vertex i in Gk, pi is expressed as prk⊕ (xor of edges in path from rk to i). 

Let's define a set L as L={i|Gi has odd number of odd degree vertices}. 

By substituting pi into (prk⊕ (xor of edges in path in G′ from rk to i)), we can rewrite "xor of pi where node i has odd degree" into ⨁k∈Lprk⊕c where c is a constant. 

If L is empty, the answer is constant and any solution that satisfy the given conditions will be the answer. 

If L is not empty, set one of prk to c and other prk as 0 so that a1⊕a2⊕⋯an−1 is 0. 

We can solve the problem in O(N). 

Fast O(NlogX) solution might be accepted, including the solution where you divide the weight of edge by bits. 

Codeforces Round #850 Editorial 

By tourist, 10 days ago, translation, In English1786A2 - Alternating Deck (hard version) 

Problem author: KAN 

Explanation1786A2 - Alternating Deck (hard version)Note that on the i-th step, Alice takes i cards from the deck. It means that after k steps, k(k+1)2 steps are taken from the deck. Thus, after O(n−−√) steps, the deck is empty. We can simulate the steps one by one by taking care of whose turn it is and what is the color of the top card. Using this information, we can keep track of how many cards of what color each player has. Print this information in the end. 

Code by KAN1786B - Cake Assembly Line 

Problem author: KAN 

Explanation1786B - Cake Assembly LineObviously, the i-th cake should be below the i-th dispenser. The leftmost possible position of the cake is when the chocolate would touch the right border. If ci is the new position of the cake's center, then in this case ci+w=bi+h. The rightmost possible position is, similarly, when ci−w=bi−h. Thus, the new position of the center should be between bi+h−w and bi−h+w. 

This means that the i-th cake should be shifted by any length between (bi+h−w)−ai and (bi−h+w)−ai. Since all cakes on the conveyor move at the same time, the shift p should satisfy (bi+h−w)−ai≤p≤(bi−h+w)−ai for all i at the same time. This is possible if and only if a value p exists such thatmaxi(bi+h−w−ai)≤p≤mini(bi−h+w−ai),which in turn is possible whenmaxi(bi+h−w−ai)≤mini(bi−h+w−ai),Thus, it is enough to find the maximum and minimum values of the formulas above and compare them. The time complexity is linear. 

Code by KAN1785A - Monsters (easy version) 

Problem author: tourist 

Explanation1785A - Monsters (easy version)First, let's prove that it's always optimal to use a spell of type 2 as your last spell in the game and kill all monsters with it. Indeed, suppose you use a spell of type 2 earlier and it deals x damage to all monsters. Suppose that some monsters are still alive. For any such monster, say they had y health points before the spell of type 2, and y>x. Then, you will need to cast y−x more spells of type 1 to kill it afterwards. But you could just cast these y−x spells of type 1 on this monster before casting the spell of type 2. Thus, you can move all usages of spells of type 1 before the usage of the spell of type 2 without changing the answer. 

Without loss of generality, assume that a1≤a2≤…≤an. Let bi be the amount of health points monster i has right before the spell of type 2 is cast (1≤bi≤ai). Then, the number of spells of type 1 needed is ∑i=1n(ai−bi), which means we want to maximize ∑i=1nbi. 

Note that we can rearrange b so that b1≤b2≤…≤bn: since a is sorted too, the bi≤ai condition will still hold. 

Also, since all monsters must be killed by a spell of type 2 afterwards, bi+1−bi≤1 must hold. 

Thus, we should go through all monsters in non-decreasing order of ai and decide their bi greedily, picking the largest value satisfying both bi≤ai and bi≤bi−1+1. Specifically, we should choose b1=1 and bi=min(ai,bi−1+1). 

Code by tourist1785B - Letter Exchange 

Problem author: tourist 

Explanation1785B - Letter ExchangeFor each person, there are three essential cases of what they could initially have: 

Three distinct letters: "win". No need to take part in any exchanges.Two equal letters and another letter, e.g. "wii". An extra 'i' must be exchanged with someone's 'n'.Three equal letters, e.g. "www". One 'w' must be exchanged with someone's 'i', another 'w' must be exchanged with someone's 'n'.Let's create a graph on three vertices: 'w', 'i', 'n'. Whenever person i has an extra letter x and is lacking letter y, create a directed edge x→y marked with i. 

Once the graph is built, whenever you have a cycle of length 2, that is, x→iy→jx, it means person i needs to exchange x for y, while person j needs to exchange y for x. Thus, both of their needs can be satisfied with just one exchange. 

Finally, once there are no cycles of length 2, note that the in-degree and the out-degree of every vertex are equal. If e.g. there are p edges 'w' → 'i', it follows that there are p edges 'i' → 'n' and p edges 'n' → 'w'. It means we can form p cycles of length 3. (The cycles could also go in the opposite direction: 'w' → 'n' → 'i' → 'w'.) In any case, each cycle of length 3 can be solved using 2 exchanges. 

Code by PavelKunyavskiy1785C - Monsters (hard version) 

Problem author: tourist 

Explanation1785C - Монстры (сложная версия)Continuing on the solution to the easy version: now we have a set of integers A, we need to add elements into A one by one and maintain the answer to the problem. 

Recall that for every i, either bi=bi−1 or bi=bi−1+1. Note that bi=bi−1 can only happen when bi=ai. Let's call such an element useless. If we remove a useless element, the answer does not change. 

If there are no useless elements, we have b1=1 and bi=bi−1+1 for i>1: that is, bi=i. Thus, the answer to the problem can be easily calculated as ∑i=1m(ai−bi)=∑i=1mai−m(m+1)2, where m is the current size of the set. 

We can formulate the condition "there are no useless elements" as follows. For any x, let kx be the number of elements in A not exceeding x. Then, kx≤x. 

On the other hand, suppose that for some x, we have kx>x. Let's find the smallest such x. Then, we can see that A contains a useless element equal to x, and we can safely remove it. 

We can check this condition after adding each new element to A using a segment tree. In every cell x of the array maintained by the segment tree, we will store the difference x−kx. Initially, cell x contains value x. When a new element v appears, we should subtract 1 from all cells in range [v;n]. Then, if a cell with a negative value appears (that is, x−kx<0, which is equivalent to kx>x), we should find the leftmost such cell x and remove an element equal to x. In particular, we should add 1 to all cells in range [x;n]. 

Thus, we can use a segment tree with "range add" and "global min". At most one useless element can appear every time we enlarge A, and if that happens, we can identify and remove it in O(logn), resulting in an O(nlogn) time complexity. 

Code by tourist1785D - Wooden Spoon 

Problem author: tourist 

Explanation1785D - Wooden SpoonLet's focus on the sequence of players beating each other 1=a0<a1<…<an: a0 is the tournament champion, a0 beats a1 in the last match, a1 beats a2 in the second-to-last match, …, an−1 beats an in the first match. 

For a fixed such sequence, how many ways are there to fill the tournament bracket? 

Let's look at the sequence in reverse. 

There are 2n ways to put player an somewhere. 

Player an−1 has to be the opponent of player an in the first match. 

Player an−2 has to beat some player b>an−2 in the first match, and then beat an−1 in the second match. There are 2n−an−2−2 ways to choose player b (since it can not be equal to an−1 and an), and there are also 2 ways to order an−2 and b. 

Player an−3 has to be the winner of a subbracket containing 3 other players c1,c2,c3>an−3, and then beat an−2 in the third match. There are 2n−an−3−4 players to choose ci from (since they can not be equal to an−2, an−1, an, and b), and there are (2n−an−3−43) ways to do so, and there are also 4! ways to order an−3, c1, c2, and c3. 

In general, player an−i has to be the winner of a subbracket containing 2i−1−1 other players, and there are 2n−an−i−2i−1 players to choose from, and there are (2n−an−i−2i−12i−1−1) ways to choose, and also (2i−1)! ways to order this subbracket. 

You can see that the total number of brackets for a fixed sequence 1=a0<a1<…<an can be represented as f(a0,0)⋅f(a1,1)⋅…⋅f(an−1,n−1)⋅f(an,n), where f(ai,i) is some function of a player number and a round number. 

Now let's use dynamic programming: let d(ai,i) be the sum of products of f(a0,0)⋅f(a1,1)⋅…⋅f(ai,i) over all sequences 1=a0<a1<…<ai. Then: 

d(1,0)=f(1,0);d(a0,0)=0 for a0>1;d(ai,i)=f(ai,i)⋅∑ai−1=1ai−1d(ai−1,i−1) for i>0.The answer for player x is d(x,n). 

This DP has O(n⋅2n) states, and note that the inner sums in the formulas for d(ai,i) and d(ai+1,i) only differ by one summand. Thus, by using cumulative sums for transitions, we can achieve an O(n⋅2n) time complexity. 

Code by tourist1785E - Infinite Game 

Problem author: tourist 

Explanation1785E - Infinite GameFor a fixed game scenario s, let's build a weighted functional graph on 4 vertices that correspond to set scores 0:0, 1:0, 0:1, and 1:1. For each score x, traverse the scenario from left to right, changing the score after each letter, and starting a new set whenever necessary. If the set score by the end of the scenario is y, add a directed edge from x to y. The weight of this edge is the number of sets Alice wins during the process, minus the number of sets Bob wins. 

When we have built such a graph for a game scenario s, we can easily decide whether s is winning for Alice, tied, or winning for Bob. Starting from vertex 0:0, move by the outgoing edges until you arrive at a cycle. In the cycle, find the sum the edge weights. If the sum is positive, the scenario is winning for Alice; if the sum is 0, the scenario is tied; if the sum is negative, the scenario is winning for Bob. 

Now we can use dynamic programming. Let f(i,{u0,u1,u2,u3},{w0,w1,w2,w3}) be the number of ways to choose s1s2…si so that edges from vertices 0,1,2,3 go to vertices u0,u1,u2,u3 and have weights w0,w1,w2,w3, respectively. Even though this DP has O(n5) states, it might be possible to get this solution accepted if you only visit reachable states and optimize your solution's constant factor. 

However, here's an idea that drastically improves the time complexity. Note that in the end, we are only interested in the sum of some wj, and not in every value separately. Outside of our DP, let's fix the mask of vertices that will lie on the cycle reachable from 0:0. In the DP state, we can just store the sum s of wj over j belonging to this mask: f(i,{u0,u1,u2,u3},s). In the end, we will look at the values of u0,u1,u2,u3 and check if the cycle in our graph is indeed the one we want; only if that's true, we will add the DP value to the overall answer. 

This way, at the cost of running the DP 24 times, we have cut the number of states to O(n2). The overall time complexity of this solution is O(n2) too, although the constant factor is huge. 

Code by tourist1785F - Minimums or Medians 

Problem author: tourist 

Explanation1785F - Минимумы или медианыLet's denote removing minimums with L, and removing medians with M. Now a sequence of Vika's actions can be described with a string s of length k consisting of characters L and M. 

Observe that if we have a substring LMM, we can replace it with MLM, and the set of removed numbers will not change. We can keep applying this transformation until there are no LMM substrings in s. 

Now, a string s of our interest looks as a concatenation of: 

p letters M, for some 0≤p≤k;if p<k, then a letter L;max(0,k−1−p) letters L and M, without two letters M in a row.Let's denote the number of letters M in part 3 above as q. 

Can different strings still lead to equal sets in the end? 

First, let's suppose that k≤n−12. We will prove that all strings that match the above pattern result in distinct integer sets. 

Part 1 in the above concatenation means that integers from n−p+1 to n+p are removed. Since there are k−p−q letters L in s in total, integers from 1 to 2(k−p−q) are removed too. However, integers in the range [2(k−p−q)+1;n−p] are not removed, and note that 2(k−p−q)+1≤n−p is equivalent to k≤n+p+2q−12. Hence, this range is never empty when k≤n−12. Thus, we can see that for all pairs of p and q, the leftmost non-removed ranges are distinct. 

Now, also note that in part 3 of the concatenation, any letter M always removes some two consecutive integers (since there is no substring MM), and letters L serve as "shifts" for these removals, and different sets of "shifts" result in different final sets of integers. This finishes the proof. 

It is easy to find the number of ways to fill part 3 for fixed p and q: there are ((k−1−p)−(q−1)q) ways to choose q positions out of (k−1−p) so that no two consecutive positions are chosen. Now we have just iterate over all valid pairs of p and q to get an O(n2) solution for the k≤n−12 case. 

Before optimizing it to O(n), let's get back to the k>n−12 case. Some strings can result in the same final set. Let x be the smallest integer in the final set. Note that x is always odd. We will only look for a string that contains x−12 letters L: that is, a string that removes integers from 1 to x−1 only via removing minimums. We can see that there is always a unique such string. 

Recall the uniqueness proof for k≤n−12. When p>0, we will now force that leftmost non-removed range, [2(k−p−q)+1;n−p], to be non-empty. If the range is empty, our sequence of actions does not satisfy the condition from the previous paragraph, so we can skip this pair of p and q. 

When p=0, things are a bit different. Suppose we have fixed q. It means there are k−q letters L in the string. These operations remove integers from 1 to 2(k−q). Thus, we need the first letter M to remove integers strictly greater than 2(k−q)+1, which gives us a lower bound on the number of letters L at the start of the string. Otherwise, we can use the same binomial coefficient formula for counting. 

This should finish the O(n2) solution for any k. 

To optimize it, let's iterate over q first and iterate over p inside. It turns out that all valid values of p form a range, and if we look at what we are summing up, it is (0q)+(1q)+…+(rq) for some integer r. This sum is equal to (r+1q+1) by the hockey-stick identity. Thus, we finally have an O(n) solution. 

Code by tourist, O(n^2)Code by tourist, O(n) 

Codeforces Round #849 (Div. 4) Editorial 

By flamestorm, 3 weeks ago, In EnglishWe hope you enjoyed the contest! 

1791A - Codeforces Checking 

Idea: flamestorm 

Tutorial1791A - Codeforces CheckingYou need to implement what is written in the statement. You can either use an if-statement for each of the characters {c,o,d,e,f,r,s}, or you can iterate through the string codeforces check if the current character equals c. 

Solution1791B - Following Directions 

Idea: flamestorm 

Tutorial1791B - Following DirectionsWe can keep track of our current point (x,y) as we iterate over the string: 

if si=L, then decrement x (set x←x−1);if si=R, then increment x (set x←x+1);if si=U, then increment y (set y←y+1);if si=D, then decrement y (set y←y−1).Initially, set x=y=0. If x=y=1 is ever true, then we should output YES; otherwise, we output NO.The time complexity is O(n). 

Solution1791C - Prepend and Append 

Idea: flamestorm 

Tutorial1791C - Prepend and AppendLet's perform the process in reverse: we will remove the first and last character of the string, if these two characters are different. We should do this as long as possible, since we need to find the shortest initial string. 

So the algorithm is straightfoward: keep track of the left and right characters, and if they are different, remove both. Otherwise, output the length of the current string (or output 0 if the string became empty). 

There are a few ways to implement this. For example, you can keep two pointers, one at the beginning of the string and one at the end, say, l=1 and r=n, and check if sl=sr. If it's true, then we increment l and decrement r. Otherwise, we output r−l+1. We stop when l≥r. 

Alternatively, you can use deque to simulate the operations directly. The time complexity is O(n). 

Solution1791D - Distinct Split 

Idea: SlavicG 

Tutorial1791D - Distinct SplitLet's check all splitting points i for all (1≤i≤n−1). We denote a splitting point as the last index of the first string we take (and all the remaining characters will go to the second string). We need to keep a dynamic count of the number of distinct characters in both strings a (the first string) and b (the second string). We can do this using two frequency arrays (and adding one to the distinct count of either string a or b when the frequency of a character is greater than zero. 

Solution1791E - Negatives and Positives 

Idea: SlavicG 

Tutorial1791E - Negatives and PositivesWe can notice that by performing any number of operations, the parity of the count of negative numbers won't ever change. Thus, if the number of negative numbers is initially even, we can make it equal to 0 by performing some operations. So, for an even count of negative numbers, the answer is the sum of the absolute values of all numbers (since we can make all of them positive). And if the count of negative numbers is odd, we must have one negative number at the end. We will choose the one smallest by absolute value and keep the rest positive (for simplicity, we consider −0 as a negative number). 

Solution1791F - Range Update Point Query 

Idea: flamestorm 

Tutorial1791F - Range Update Point QueryLet S(n) denote the sum of the digits of n. The key observation is the following: after the operation is applied to index i thrice, it won't change after any further operations. The proof† is provided at the bottom of the editorial. 

So we only need to update ai if it's been updated at most 2 times so far; otherwise, we can ignore it. This allows us to do the following solution: store the current "active" indices (that is, indices that have been updated ≤2 times) in a sorted list (for example, set in C++). Then: 

1 l r — search for the smallest active index at least l (since the list is sorted, we can do it in O(logn)). Afterwards, update that index (replace ai with S(ai)), remove it if it's no longer active, and binary search for the next largest active index in the sorted list, until we pass r.2 x — just output ax.Although it looks like we take O((r−l+1)log(r−l+1)) time for each update, we actually only ever update each element of the array at most 3 times, so we will do no more than 3nlogn binary searches.Therefore the time complexity is amortized O(q+nlogn). 

† To show this, note that initially 1≤ai≤109. The maximum possible value of the sum of the digits of ai is 81, achieved when ai=999,999,999. So 1≤S(ai)≤81. 

Now considering the numbers from 1 to 81, the one with maximum sum of digits is 79, with S(79)=16. Hence 1≤S(S(ai))≤16. Finally, considering the numbers from 1 to 16, the one with maximum sum of digits is 9, so 1≤S(S(S(ai)))≤9. That is, after three operations, ai becomes a single digit. Any further operations, and it won't change any more. 

Solution1791G1 - Teleporters (Easy Version) 

Idea: flamestorm 

Tutorial1791G1 - Teleporters (Easy Version)It's easy to see that it's optimal to only move right or to use a portal once we are at it. We can notice that when we teleport back, the problem is independent of the previous choices. We still are at point 0 and have some portals left. Thus, we can just find out the individual cost of each portal, sort portals by individual costs, and take them from smallest to largest by cost as long as we can. The cost of portal i is i+ai (since we pay ai to use it and need i moves to get to it). 

Solution1791G2 - Teleporters (Hard Version) 

Idea: flamestorm 

Tutorial1791G2 - Teleporters (Hard Version)Please also refer to the tutorial for the easy version. 

If we are not at the first taken portal, the problem is still independent for each portal, but this time the cost of a portal is min(ai+i,ai+n+1−i) (since we can come to a portal either from point 0 or point n+1). So, we again sort the portals by their costs. But this time, we need to make sure that the first taken portal is taken from point 0, so we will iterate over all portals and check the maximum amount of portals we can take if we use it as the first one. We can check this using prefix sums over the minimum cost array and binary searching, checking if the amount of considered portals taken doesn't exceed the number of coins we initially have (we also have to deal with the case when the portal we are considering is included both times as the initial portal and in the minimum cost prefix). 

Solution 

Codeforces Round #848 (Div. 2) Editorial 

By adnan_toky, 3 weeks ago, In English1778A - Flip Flop Sum 

Tutorial1778A - Flip Flop SumLet's say we've chosen index i. What will happen? 

If the values of ai and ai+1 have opposite signs, flipping them won't change the initial sum.if ai = ai+1 = 1, flipping them will reduce the sum by 4.if ai = ai+1 = −1, flipping them will increase the sum by 4.So, for each i<n, we can check the values of ai and ai+1, and we can measure the effects on the sum based on the three cases stated above. Among the effects, take the one that maximizes the sum. 

Time complexity: In each test case, O(n)Code1778B - The Forbidden Permutation 

Tutorial1778B - The Forbidden PermutationIf the array a is good, the answer is obviously 0. Now, how can we optimally transform a not good array a to a good array? Let, we are on the index i (i<m) and x=ai, y=ai+1. If we observe carefully, we will find that there are basically two cases that will make the array a good: 

Move x and y in the permutation p in such a way that pos(y) becomes greater than pos(x)+d. To do that, in the permutation p, we can swap x to the left and y to the right. The total number of swaps needed is =d−(pos(y)−pos(x))+1. We need to check if there is enough space to the left of pos(x) and to the right of pos(y) to perform the needed number of swaps.Move x and y in the permutation p in such a way that pos(y) becomes smaller than pos(x). To do that, In the permutation p, we can simply swap y to the left until the condition is satisfied. The number of swaps needed is pos(y)−pos(x).For each i<m, calculate the minimum number of swaps needed among these two cases. The minimum number of swaps among all i<m will be the desired answer. 

Time complexity: In each test case, O(n)Code1778C - Flexible String 

Tutorial1778C - Flexible StringIf we can replace all the characters of the string a, we can transform the string a to the string b. So, replacing more characters is always beneficial. For a fixed string a and another fixed string b, if the answer is x1 for k1 and x2 for k2 (k1<k2), it can be shown that x1≤x2 always satisfies. 

That is to say, we can safely consider the size of the set q to be the maximum limit min(k,u) where u is the number of unique characters in the string a. Now, we can generate all possible sets of characters having size min(k,u). Obviously, we won't take the characters that are not present in the string a because they have no effect on the answer. There are many ways to generate the sets, like backtracking, bitmasking, etc. If we can calculate the number of valid pairs (l,r) for each set efficiently, the rest task will be just taking the maximum of them. 

To calculate the number of pairs for each set efficiently, we can observe the fact that if a[l,r]=b[l,r] is true, a[p,q]=b[p,q] satisfies for any l≤p≤q≤r. So, we will get c×(c+1)2 number of valid pairs from here where c=r−l+1. Now, we can start iterating from the beginning of the string a. We can say that ai matches bi if they are equal or ai exists in the currently generated set. 

While iterating, when we are on the jth index, we need to find the rightmost index r such that a[j,r]=b[j,r] satisfies. Then we need to add the number of valid pairs in this range to the contribution of this set. After that, we need to set the value of j to r+1 and repeat the steps again. The rest of the tasks are trivial. 

Time complexity: In each test case, O(n×(um)), where m=min(k,u)Code1778D - Flexible String Revisit 

Tutorial1778D - Flexible String RevisitLet k be the number of indices where the characters between two strings are different and f(x) be the expected number of moves to make two strings equal given that the strings have x differences. We have to find the value of f(k). 

For all x where 1≤x≤n−1, 

f(x)=xn⋅[1+f(x−1)]+n−xn⋅[1+f(x+1)]or, f(x)=1+xn⋅f(x−1)+n−xn⋅f(x+1)Now, f(0)=0 and f(1)=1+n−1nf(2). 

We can represent any f(i) in the form f(i)=ai+bi⋅f(i+1). 

Let, a1=1 and b1=n−1n. So, we can write f(1)=a1+b1⋅f(2). 

When 1<i<n, f(i)=1+in⋅f(i−1)+n−in⋅f(i+1). We can substitute the value of f(i−1) with ai−1+bi−1⋅f(i) and calculate the value of f(i). Thus we can get the value of ai and bi using the value of ai−1 and bi−1 by considering a1 and b1 as the base case. 

We get, ai=n+i⋅ai−1n−i⋅bi−1 and bi=n−in−i⋅bi−1 for 2≤i≤n. 

CalculationSimilarly, f(n)=1+f(n−1). 

We can represent any f(i) in the form f(i)=ci+di⋅f(i−1). 

Let, cn=1 and dn=1. So, we can write f(n)=cn+dn⋅f(n−1). 

When 1<i<n, f(i)=1+in⋅f(i−1)+n−in⋅f(i+1). We can substitute the value of f(i+1) with ci+1+di+1⋅f(i) and calculate the value of f(i). Thus we can get the value of ci and di using the value of ci+1 and di+1 by considering cn and dn as the base case. 

We get, ci=n+(n−i)⋅ci+1n−(n−i)⋅di+1 and di=in−(n−i)⋅di+1. 

CalculationNow, f(i)=ci+di⋅f(i−1) and f(i−1)=ai−1+bi−1⋅f(i). By solving these two equations, we find that f(i)=ci+di⋅ai−11−di⋅bi−1. 

Time Complexity: O(n⋅logm). 

Alternative SolutionCodeAlternative Code1778E - The Tree Has Fallen! 

Tutorial1778E - The Tree Has Fallen!At first, we can think of another problem. Given an array. You need to find the maximum subset XOR. How can we solve it? We can solve this problem very efficiently using a technique called "XOR Basis". You can read about it from here. 

In problem E, at first, we can fix any node as the root of the tree. Let's call this rooted tree the base tree. After that, start an Euler tour from the root and assign discovery time du and finishing time fu to each node u. In each query, three types of cases can occur (node r and node v are from the query format): 

r=v. In this case, we need to calculate the maximum subset XOR of the whole tree.Node v is not an ancestor of node r in the base tree. So, the subtree of node v will remain the same.Node v is an ancestor of node r in the base tree. What will be the new subtree of node v in this case? This is a bit tricky. Let's denote such a node c that is a child of node v and an ancestor of node r in the base tree. Then the new subtree of node v will contain the whole tree except the subtree (in the base tree) of node c.Let's say, inu is the XOR basis of all the values in node u's subtree (in the base tree). We can build inu by inserting the value au to inu and merging it with all of its children w's basis inw. Two basis can be merged in O(log2(d)) complexity, where d is their dimension. If we can build the basis inu for each node u, we are able to answer the case 1 and case 2. To answer case 2, we need to find the maximum subset XOR in the corresponding basis. To answer case 1, we need to do a similar thing in the basis inroot, where root is the root node of the base tree. 

For case 3, let's say outu is the XOR basis of all the values of the base tree except the node u's subtree (in the base tree). Then the answer of the case 3 will be the maximum subset XOR in the basis outc. To build the basis outu for each node u, we can utilize the properties of the discovery time du and finishing time fu. Which nodes will be outside the subtree of node u? The nodes w that have either dw<du or dw>fu. To merge their basis easily, we can pre-calculate two basis arrays pre[] and suf[] where the basis prei includes all the values of the nodes w such that dw≤i and the basis sufi includes all the values of the nodes w such that dw≥i. 

To find the node c in the case 3, we can perform a binary search on the children of node v. We can use the fact that the order of the discovery times follows the order of the children and a node c is only an ancestor of a node r iff dc≤dr && fc≥fr. 

Time complexity: O(n×log2(d)), where d=max(ai) 

Code1778F - Maximizing Root 

Tutorial1778F - Maximizing RootLet, xu be the value of node u and dp[u][d] be the minimum number of moves required to make the GCD of the subtree of u equal to a multiple of d. 

Now, dp[u][d]=0 if the subtree GCD of node u is already a multiple of d and dp[u][d]=∞ if (xu⋅xu) is not a multiple of d. 

For each divisor y of d, suppose, we want to perform the move on the subtree of u by multiplying each node value of the subtree with y iff (xu⋅y) is a multiple of d and y is a divisor of xu. In this case, we have to make the GCD of all the subtree of child nodes of u equal to a multiple of LCM(dy,y) before performing the move on the subtree of u. This is because we have to make each node of the subtree a multiple of dy to get the multiple of d after performing the move on the subtree of node u using y. Also, to perform the move of multiplying by y, the value of each subtree node should be a multiple of y. So we have to make each node value a multiple of LCM(dy,y). 

So, dp[u][d] will be calculated from dp[v][LCM(dy,y)] for each divisor y of d for all child v of u. 

Now, x1⋅D is the answer where D is the largest divisor of x1 such that k≥dp[1][D]. 

Time Complexity: O(n⋅m2) where m is the number of divisors of x1. 

Code 

Codeforces Round #848 (Div. 2) Editorial 

By adnan_toky, 3 weeks ago, In English1778A - Flip Flop Sum 

Tutorial1778A - Flip Flop SumLet's say we've chosen index i. What will happen? 

If the values of ai and ai+1 have opposite signs, flipping them won't change the initial sum.if ai = ai+1 = 1, flipping them will reduce the sum by 4.if ai = ai+1 = −1, flipping them will increase the sum by 4.So, for each i<n, we can check the values of ai and ai+1, and we can measure the effects on the sum based on the three cases stated above. Among the effects, take the one that maximizes the sum. 

Time complexity: In each test case, O(n)Code1778B - The Forbidden Permutation 

Tutorial1778B - The Forbidden PermutationIf the array a is good, the answer is obviously 0. Now, how can we optimally transform a not good array a to a good array? Let, we are on the index i (i<m) and x=ai, y=ai+1. If we observe carefully, we will find that there are basically two cases that will make the array a good: 

Move x and y in the permutation p in such a way that pos(y) becomes greater than pos(x)+d. To do that, in the permutation p, we can swap x to the left and y to the right. The total number of swaps needed is =d−(pos(y)−pos(x))+1. We need to check if there is enough space to the left of pos(x) and to the right of pos(y) to perform the needed number of swaps.Move x and y in the permutation p in such a way that pos(y) becomes smaller than pos(x). To do that, In the permutation p, we can simply swap y to the left until the condition is satisfied. The number of swaps needed is pos(y)−pos(x).For each i<m, calculate the minimum number of swaps needed among these two cases. The minimum number of swaps among all i<m will be the desired answer. 

Time complexity: In each test case, O(n)Code1778C - Flexible String 

Tutorial1778C - Flexible StringIf we can replace all the characters of the string a, we can transform the string a to the string b. So, replacing more characters is always beneficial. For a fixed string a and another fixed string b, if the answer is x1 for k1 and x2 for k2 (k1<k2), it can be shown that x1≤x2 always satisfies. 

That is to say, we can safely consider the size of the set q to be the maximum limit min(k,u) where u is the number of unique characters in the string a. Now, we can generate all possible sets of characters having size min(k,u). Obviously, we won't take the characters that are not present in the string a because they have no effect on the answer. There are many ways to generate the sets, like backtracking, bitmasking, etc. If we can calculate the number of valid pairs (l,r) for each set efficiently, the rest task will be just taking the maximum of them. 

To calculate the number of pairs for each set efficiently, we can observe the fact that if a[l,r]=b[l,r] is true, a[p,q]=b[p,q] satisfies for any l≤p≤q≤r. So, we will get c×(c+1)2 number of valid pairs from here where c=r−l+1. Now, we can start iterating from the beginning of the string a. We can say that ai matches bi if they are equal or ai exists in the currently generated set. 

While iterating, when we are on the jth index, we need to find the rightmost index r such that a[j,r]=b[j,r] satisfies. Then we need to add the number of valid pairs in this range to the contribution of this set. After that, we need to set the value of j to r+1 and repeat the steps again. The rest of the tasks are trivial. 

Time complexity: In each test case, O(n×(um)), where m=min(k,u)Code1778D - Flexible String Revisit 

Tutorial1778D - Flexible String RevisitLet k be the number of indices where the characters between two strings are different and f(x) be the expected number of moves to make two strings equal given that the strings have x differences. We have to find the value of f(k). 

For all x where 1≤x≤n−1, 

f(x)=xn⋅[1+f(x−1)]+n−xn⋅[1+f(x+1)]or, f(x)=1+xn⋅f(x−1)+n−xn⋅f(x+1)Now, f(0)=0 and f(1)=1+n−1nf(2). 

We can represent any f(i) in the form f(i)=ai+bi⋅f(i+1). 

Let, a1=1 and b1=n−1n. So, we can write f(1)=a1+b1⋅f(2). 

When 1<i<n, f(i)=1+in⋅f(i−1)+n−in⋅f(i+1). We can substitute the value of f(i−1) with ai−1+bi−1⋅f(i) and calculate the value of f(i). Thus we can get the value of ai and bi using the value of ai−1 and bi−1 by considering a1 and b1 as the base case. 

We get, ai=n+i⋅ai−1n−i⋅bi−1 and bi=n−in−i⋅bi−1 for 2≤i≤n. 

CalculationSimilarly, f(n)=1+f(n−1). 

We can represent any f(i) in the form f(i)=ci+di⋅f(i−1). 

Let, cn=1 and dn=1. So, we can write f(n)=cn+dn⋅f(n−1). 

When 1<i<n, f(i)=1+in⋅f(i−1)+n−in⋅f(i+1). We can substitute the value of f(i+1) with ci+1+di+1⋅f(i) and calculate the value of f(i). Thus we can get the value of ci and di using the value of ci+1 and di+1 by considering cn and dn as the base case. 

We get, ci=n+(n−i)⋅ci+1n−(n−i)⋅di+1 and di=in−(n−i)⋅di+1. 

CalculationNow, f(i)=ci+di⋅f(i−1) and f(i−1)=ai−1+bi−1⋅f(i). By solving these two equations, we find that f(i)=ci+di⋅ai−11−di⋅bi−1. 

Time Complexity: O(n⋅logm). 

Alternative SolutionCodeAlternative Code1778E - The Tree Has Fallen! 

Tutorial1778E - The Tree Has Fallen!At first, we can think of another problem. Given an array. You need to find the maximum subset XOR. How can we solve it? We can solve this problem very efficiently using a technique called "XOR Basis". You can read about it from here. 

In problem E, at first, we can fix any node as the root of the tree. Let's call this rooted tree the base tree. After that, start an Euler tour from the root and assign discovery time du and finishing time fu to each node u. In each query, three types of cases can occur (node r and node v are from the query format): 

r=v. In this case, we need to calculate the maximum subset XOR of the whole tree.Node v is not an ancestor of node r in the base tree. So, the subtree of node v will remain the same.Node v is an ancestor of node r in the base tree. What will be the new subtree of node v in this case? This is a bit tricky. Let's denote such a node c that is a child of node v and an ancestor of node r in the base tree. Then the new subtree of node v will contain the whole tree except the subtree (in the base tree) of node c.Let's say, inu is the XOR basis of all the values in node u's subtree (in the base tree). We can build inu by inserting the value au to inu and merging it with all of its children w's basis inw. Two basis can be merged in O(log2(d)) complexity, where d is their dimension. If we can build the basis inu for each node u, we are able to answer the case 1 and case 2. To answer case 2, we need to find the maximum subset XOR in the corresponding basis. To answer case 1, we need to do a similar thing in the basis inroot, where root is the root node of the base tree. 

For case 3, let's say outu is the XOR basis of all the values of the base tree except the node u's subtree (in the base tree). Then the answer of the case 3 will be the maximum subset XOR in the basis outc. To build the basis outu for each node u, we can utilize the properties of the discovery time du and finishing time fu. Which nodes will be outside the subtree of node u? The nodes w that have either dw<du or dw>fu. To merge their basis easily, we can pre-calculate two basis arrays pre[] and suf[] where the basis prei includes all the values of the nodes w such that dw≤i and the basis sufi includes all the values of the nodes w such that dw≥i. 

To find the node c in the case 3, we can perform a binary search on the children of node v. We can use the fact that the order of the discovery times follows the order of the children and a node c is only an ancestor of a node r iff dc≤dr && fc≥fr. 

Time complexity: O(n×log2(d)), where d=max(ai) 

Code1778F - Maximizing Root 

Tutorial1778F - Maximizing RootLet, xu be the value of node u and dp[u][d] be the minimum number of moves required to make the GCD of the subtree of u equal to a multiple of d. 

Now, dp[u][d]=0 if the subtree GCD of node u is already a multiple of d and dp[u][d]=∞ if (xu⋅xu) is not a multiple of d. 

For each divisor y of d, suppose, we want to perform the move on the subtree of u by multiplying each node value of the subtree with y iff (xu⋅y) is a multiple of d and y is a divisor of xu. In this case, we have to make the GCD of all the subtree of child nodes of u equal to a multiple of LCM(dy,y) before performing the move on the subtree of u. This is because we have to make each node of the subtree a multiple of dy to get the multiple of d after performing the move on the subtree of node u using y. Also, to perform the move of multiplying by y, the value of each subtree node should be a multiple of y. So we have to make each node value a multiple of LCM(dy,y). 

So, dp[u][d] will be calculated from dp[v][LCM(dy,y)] for each divisor y of d for all child v of u. 

Now, x1⋅D is the answer where D is the largest divisor of x1 such that k≥dp[1][D]. 

Time Complexity: O(n⋅m2) where m is the number of divisors of x1. 

Code 

Codeforces Round #847 (Div. 3) Editorial 

By Vladosiya, history, 4 weeks ago, translation, In English1790A - Polycarp and the Day of Pi 

Idea: MikeMirzayanov 

Tutorial[problem:1790A]In the problem, you had to find the largest common prefix(LCP) of the first 30 characters of the number π and the string n. To do this, we will go from the beginning and compare the characters until we find a non-matching one, or until the string n ends. 

Solution1790B - Taisia and Dice 

Idea: Gornak40 

Tutorial1790B - Taisia and DiceIt is easy to find the value on the cube that the cat stole, it is equal mx=s−r. All other values must be no more than mx. Let's try to get r by taking mx ⌊rmx⌋ times and adding the remainder there if it is non-zero. 

We could not get more than n−1 cubes this way, because otherwise (n−1)mx>r, but we are guaranteed that the answer exists. Now, until we get the n−1 cube, let's find the cube with the maximum value, reduce it by 1 and add the cube with the value of 1. 

We can definitely get n−1 dice, because otherwise r<n−1, but we are guaranteed that the answer exists. It remains only to add a cube with the value of mx to our n−1 cubes. 

We obtained a solution with O(n2) asymptotics. 

Solution1790C - Premutation 

Idea: MikeMirzayanov 

Tutorial[problem:1790C]When Kristina writes sequences on the whiteboard, she removes an element with each index exactly once. Thus, the first element of the permutation will be deleted only once — on the first step. All sequences except one will start with it 

To solve the problem, find a sequence pi such that: 

it starts with some element yall sequences other than this one begin with some element xThen this permutation will describe the sequence of numbers remaining after removing the 1th element, and the first element itself will be equal to the number x. The initial permutation will look like [x,y=pi1,pi2,…,pin]. 

Solution1790D - Matryoshkas 

Idea: MikeMirzayanov 

Tutorial1790D - MatryoshkasFirst, for each size, let's count cnts — the number of dolls of this size. 

Then, let's create a set, in which for each doll of size s we add the numbers s and s+1. This will allow you to process all the segments, as well as the dimensions adjacent to them. 

We will iterate over the set in ascending order of size. Let x be the number of matryoshkas of the current size, y — of the previous one considered (0 at the beginning). If the numbers do not match, then you need to close (if x<y), or open (if x>y) |x−y| segments. It is enough to add only the opening of the segments to the answer. 

Solution1790E - Vlad and a Pair of Numbers 

Idea: Vladosiya 

Tutorial1790E - Vlad and a Pair of NumbersConsider the answer by bits. We know that if the ith bit of the number x is zero, then these bits are the same for a and b, otherwise they differ. Then let's first make a=x, b=0. Note that a⊕b is already equal to x, but a+b2 is not yet. So we need to dial another x with matching bits, we will add them to both integers greedily, going from the highest bit to the lowest, skipping those bits that are already one in a. If after this algorithm a and b do not satisfy the conditions, then the answer is −1. In total, this solution works for O(logx). 

You can see that in the solution above, we actually just added x2 to both numbers, which could only be done with one set of bits, so if the answer exists, the pair a=3⋅x2fits, b=x2. 

Solution1790F - Timofey and Black-White Tree 

Idea: molney 

Tutorial1790F - Timofey and Black-White TreeLet's store for each vertex the minimum distance from it to the nearest black one, let's call it d[v]. We will also store the global answer, which for obvious reasons does not increase, we will call it ans. 

Let's now color the vertex ci, let's set d[ci]=0 and run a depth first search from it. This DFS will visit only the vertices v with d[v]<ans. Let us consider the vertex v and its neighbour u. If we can relax d[u] through d[v]+1, let's do it and start from u. Otherwise, u has a closer black neighbour, let's try to update the answer through it ans=min(ans,d[v]+1+d[u]). Also, do not forget to update the answer via d[v] from all black vertices v that we visited. 

The correctness of the algorithm is obvious, let's evaluate its time complexity. It is easy to notice that after the first ⌈n−−√⌉ operations, ans≤⌈n−−√⌉. We enter only the vertices, d from which, firstly, does not exceed ans, and secondly, was relaxed by the parent (that is, decreased by at least 1). 

So, we allowed ourselves a complete tree bypassing for the first ⌈n−−√⌉ operations, and then amortized performed no more than n⌈n−−√⌉ operations. The final asymptotics will be O(nn−−√). 

Solution1790G - Tokens on Graph 

Idea: DmitriyOwlet 

Tutorial1790G - Tokens on GraphLet's calculate the shortest paths to the finish along the vertices containing bonuses. 

We will try to reach the finish line with the chip that is closest to it, and mark it. If there is none, we lose. 

Other chips will give her extra moves. 

Find all connected components from vertices containing bonuses. Then, for each component, we find all the tokens that are not selected, located at the vertex of this component, and at the vertices adjacent to at least one vertex of this component. 

Consider the size of the connectivity component. If it is equal to 1, then the chip located in the neighboring vertex gives 1 an additional move. Otherwise, the chip located at the top of the component or at the neighboring vertex, as well as the selected chip, will be able to move indefinitely in turn, which gives us a victory. Otherwise, you need to count the number of extra moves and compare it with the shortest distance to the finish line. 

Solution 

Codeforces Round #846 (Div. 2) — Tutorial 

By AndreyPavlov, history, 4 weeks ago, translation, In English1780A - Hayato and School 

Idea: AndreyPavlovPreparation: AndreyPavlovEditorialist: AndreyPavlov 

TutorialNote that there are two variants of which numbers to take to make their amount odd: 3 odd number; 2 even and 1 odd. Let’s save all indices of even and odd numbers into two arrays, and check both cases. 

Implementation (Python)Implementation (C++)1780B - GCD Partition 

Idea: 74TrAkToRPreparation: qualdoomEditorialist: qualdoom 

TutorialLet's note that it doesn't make sense for us to divide into more than k=2 subsegments. Let's prove it. 

Let us somehow split the array a into m>2 subsegments : b1,b2,…,bm. Note that gcd(b1,b2,…,bm)≤gcd(b1+b2,b3,…,bm), since if b1 and b2 were multiples of gcd(b1,b2,…,bm), so b1+b2 is also a multiple of gcd(b1,b2,…,bm). This means that we can use b1+b2 instead of b1 and b2, and the answer will not worsen, thus it is always beneficial to use no more than k=2 subsegments. 

How to find the answer? Let s be the sum of the array a. Let's say prefi=∑ij=1aj, then the answer is max1≤i<n(gcd(prefi,s−prefi). 

Implementation (Python)Implementation (С++)1780D - Bit Guessing Game 

Idea: AndreyPavlovPreparation: qualdoom, AndreyPavlovEditorialist: qualdoom, AndreyPavlov 

TutorialThere are two similar solutions to this problem, we will tell you both. 

Tutorial (AndreyPavlov)Tutorial (qualdoom)Implementation (Python)Implementation (С++)1780E - Josuke and Complete Graph 

Idea: T4M0FEYPreparation: T4M0FEYEditorialist: T4M0FEY 

TutorialLet’s fix g and check that the g weight edge exists in G′. The first number, which is divided into g, starting with L — ⌈Lg⌉⋅g, and the second — (⌈Lg⌉+1)⋅g, note that their gcd is g, so the edge between these vertices weighs g. If the second number is greater R, the edge with weight g in the G′ doesn't exist, because on the segment from L to R at most one vertex, which is divided by g. That is, we should calculate the number of such g, which is (⌈Lg⌉+1)⋅g≤R. 

For g≥L: (⌈Lg⌉+1)⋅g=2⋅g. Get the upper limit on the g≤⌊R2⌋. That is, all g on segment from L to ⌊R2⌋ occur in the G′ as weight some edge. Add them to the answer. 

Look at g<L. 

Note that ⌈Lg⌉ takes a O(L−−√) of different values. Let's fix some f=⌈Lg⌉. Note that f corresponds to a consecutive segment l≤g≤r. Let's brute this segments in ascending order f. Then, if there is a left border l of the segment, you can find r either by binary search or by writing the formula. The next left border is r+1. Then note, if f is fixed, then (f+1)⋅g≤R is equivalent to g≤⌊Rf+1⌋. That is, with a fixed segment from l to r, g occurs in the G′ as weight some edge if l≤g≤min(r,⌊Rf+1⌋). Then brute all these segments and sum up of all good g. 

Overall time complexity is O(L−−√) or O(L−−√⋅log(L)). 

Implementation (Python)Implementation (С++)1780F - Three Chairs 

Idea: AndreyPavlovPreparation: AndreyPavlovEditorialist: qualdoom 

TutorialLet's sort the array and process the triples i,j,k, assuming that i<j<k and ai<aj<ak. Now if gcd(ai,ak)=1, then the number of ways to take the index j is k−i−1. 

We will consider the answer to the problem for each k from 1 to n, assuming that ak is the maximum number in the triple. Now let c be the number of numbers that are mutually prime with ak on the prefix from 1 to k−1, and sum is the sum of their indices. Then you need to add c⋅i−sum−c to the answer. 

It remains to find out the number of numbers that are mutually prime with ak and the sum of their indices. This can be done using the inclusion and exclusion method. Let cnti be the number of numbers aj that are divisible by i, si be the sum of the indices j of numbers aj that are divisible by i. Let's look at the prime numbers p1,p2,...,pm included in the factorization of the number ak. 

Then let c initially be equal to the number of numbers on the prefix, and sum to the sum of the indices on the prefix. Note that then we took into account the extra elements — numbers that are divisible by p1,p2,...,pm, since they will not be mutually simple with ak, we subtract them from c and sum. But having done this, we again took into account the extra elements that are multiples of the numbers of the form pi∗pj, where i≠j, add them back, etc. So we can iterate over the mask mask of the primes p1,p2,...,pm. And depending on the parity of the bits in the mask, we will subtract or add elements that are multiples of d, where d is the product of the primes included in mask. Having received c and sum, we can recalculate the answer for the position i. 

To move from position i to position i+1, update the values of cnt and s by adding the element ai−1 by iterating over the mask of the simple element ai−1. 

Implementation (С++)1780G - Delicious Dessert 

Idea: T4M0FEYPreparation: T4M0FEY, AndreyPavlovEditorialist: T4M0FEY, AndreyPavlov 

TutorialThis problem has several solutions using different suffix structures. We will tell two of them — using suffix array, and using suffix automaton. 

Suffix array (t4m0fey)Suffix automaton (AndreyPavlov)Implementation (t4m0fey)Implementation (AndreyPavlov) 

Codeforces Round #845 (Div. 2) and ByteRace 2023 Editorial 

By ShivanshJ, history, 6 weeks ago, In EnglishWe hope you enjoyed the contest!. Thank you for your participation! Do vote under the Feedback section, and feel free to give your review of the problems in the comments. 

1777A - Everybody Likes Good Arrays! 

Idea: ShivanshJPreparation: ShivanshJEditorialist: ShivanshJ 

HintsSolution1777A - Everybody Likes Good Arrays!Solution Replace even numbers with 0 and odd numbers with 1 in the array a. Now we observe that the given operation is equivalent to selecting two equal adjacent elements and deleting one of them. 

Now the array can be visualized as strips of zeros (in green) and ones (in red) like this [0,0,0,1,1,1,1,0,1,1]. Note that since the number of adjacent elements (a[i],a[i+1]) such that a[i]≠a[i+1] remains constant (nice invariant!), every strip can be handled independently. The size of every strip must be 1 in the final array and performing an operation reduces the size of the corresponding strip by 1. 

So, for a strip of length L, it would require L−1 operations to reduce its size to 1. So, every strip would contribute −1 to the number of operations apart from its length. So, the answer is (n− total no. of strips) which also equals (n−x−1) where x is number of adjacent elements (a[i],a[i+1]) such that (a[i]≠a[i+1]). 

Implementation (C++)Implementation (Python)Feedback1777B - Emordnilap 

Idea: TimeWarp101 quantauPreparation: TimeWarp101Editorialist: TimeWarp101 

HintsSolution1777B - EmordnilapObservation: Every permutation has the same beauty. 

Consider two indices i and j (i<j) in a permutation p. 

These elements appear in the order [pi,pj,pj,pi] in array A. 

Now we have two cases: 

Case 1: pi>pjThe first pi appears before both pj's in this case, accounting for 2 inversions. 

Case 2: pi<pjBoth the pj's appear before the second pi, accounting for 2 inversions again. 

Hence, any pair of indices in p account for 2 inversions in A. 

Thus, beauty of every permutation p=(n2)⋅2=n⋅(n−1)Sum of beauties of all permutations =n⋅(n−1)⋅n!Implementation (C++)Implementation (Python)Feedback1777C - Quiz Master 

Idea: quantauPreparation: TimeWarp101 quantauEditorialist: TimeWarp101 

HintsSolution1777C - Quiz MasterWe can sort the smartness values and use two pointers. 

The two pointers indicate the students we are considering in our team. Let l be the left pointer and r be the right pointer. 

al is the minimum smartness of our team and ar is the maximum. If this team is collectively proficient in all topics, then the difference would be ar−al. 

Now, if l is increased, the team may lose proficiency in some topics. r would either stay the same or increase as well for the team to become proficient again. 

For a team to be proficient, each number from 1 to m should have a smartness value which is a multiple of it. 

To check for proficiency, we can maintain a frequency array f of size m and a variable count to indicate the number of topics that have found a multiple. 

When we add a student to the team, we iterate through all the factors of their smartness which are less than or equal to m and increase their frequency. If an element had a frequency of 0 before, then count is increased by 1. 

Similarly, when we remove a student from the team, we go through all the factors less than or equal to m and decrease their frequency. If an element now has 0 frequency, then count is decreased by 1. 

count being equal to m at any point indicates a collectively proficient team. 

Implementation (C++)Feedback1777D - Score of a Tree 

Idea: AwakeAnayPreparation: mayankfrost ShivanshJEditorialist: AwakeAnay 

HintsSolution1777D - Score of a TreeWe will focus on computing the expected value of F(A) rather than the sum, as the sum is just 2n×E(F(A)). 

Let Fu(A) denote the sum of all values at node u from time 0 to 10100, if the initial configuration is A. 

Clearly, F(A)=∑Fu(A). 

With linearity of expectations, 

E(F(A))=∑E(Fu(A))Define Vu(A,t) as the value of node u at time t, if the initial configuration is A. 

Observe that Vu(A,t) is simply 0 if there is no node in u's subtree at a distance of t from u, otherwise, the value is the bitwise xor of the initial values of all nodes in the subtree of u at a distance of t from u. 

Thus, define du as the length of the longest path from u to a leaf in u's subtree. Now, E(Vu(A,t)) is half if t is less than or equal to du, otherwise it's 0. This is because the expected value of xor of k boolean values is 0 is k is zero, otherwise it's half. This fact has multiple combinatorial proofs. For example, one can simply count the number of ways of choosing odd number of boolean values, among the k values as 1 to get ∑odd i(ki)=2k−1We use this to get:E(Fu(A))=E(∑010100Vu(A,t))=∑010100E(Vu(A,t)=du+12All the du values can be computed by a single traversal of the tree. 

Our final result is: 

2n×∑du+12Time complexity: O(n)Implementation (C++)Feedback1777E - Edge Reverse 

Idea: CrocutaPreparation: mayankfrostEditorialist: mayankfrost 

HintsSolution1777E - Edge ReverseIf the cost for completing the task is c, we can reverse any edge with cost ≤c. This is equivalent to making those edges bidirectional since when checking for reachability, we only need to traverse an edge once, and we can choose to reverse it or not, depending upon the need. 

We can apply a binary search on the minimum cost and check if there exists at least one node such that all nodes are reachable from it if all edges with cost less than or equal to the current cost become bidirectional. 

To check in linear time if there exists such a suitable node, we will use a suppressed version of the Kosa Raju algorithm. We condense the nodes into Strongly Connected Components (SCCs) and perform a topological sort on them. If there exists an SCC from which all SCCs are reachable, then the first element in the topological sort will be that SCC (since in a topological sort, an element can only reach elements coming after it). So, we can choose any node from the first SCC in the topological sort and apply DFS to check if all the nodes are reachable from that node. If they aren't, we conclude it is impossible to complete the task with the current cost. 

Overall time complexity: O((N+M)⋅logC)Implementation (C++)Feedback1777F - Comfortably Numb 

Idea: CrocutaPreparation: TimeWarp101Editorialist: Crocuta 

HintsSolution1777F - Comfortably NumbThe problem can be solved recursively. Keep dividing the array into subarrays at the maximum element of the current subarray. 

Let's say the maximum element of the initial array is at index x, so the array gets divided into two subarrays a[1...x−1] and a[x+1,...n]. Say we have already calculated the answer for the left and right subarrays. Now, we need to calculate the answer for all the subarrays containing a[x] to complete the process for the array. 

To do this, we will maintain two separate tries for both the left and right parts. This trie will contain all the prefix xor values for all the indices in the respective part. We will iterate over the smaller subarray out of the two. For every index, we will try to find the largest answer that can be obtained from a subarray with one end at this index. This can be done by moving the prefix xor value at the current index (xor'ed with a[x]) over the 'prefix xor trie' of the other subarray. This will cover all the subarrays containing a[x], and so the entire array will now get covered. After the process, we will merge the two tries into one by again iterating over the smaller subarray. 

Similarly, we can solve for left subarray and right subarray by finding their respective maximum element, and dividing the subarray at that element. 

As we follow small-to-large merging, there are about nlogn operations on the trie, and so the overall time complexity is O(nlognlogA). 

Implementation (C++)Feedback 

Codeforces Round #844 Editorial 

By tourist, 5 weeks ago, In English1782A - Parallel Projection 

Explanation1782A - Parallel ProjectionNote that bending the cable on the wall is not necessary: we can always bend it on the floor and on the ceiling, while keeping the vertical part of the cable straight. Thus, we can just disregard the height of the room, view the problem as two-dimensional, and add h to the answer at the end. 

In the two-dimensional formulation, we need to connect points (a,b) and (f,g) with a cable that goes parallel to the coordinate axes and touches at least one side of the (0,0) — (w,d) rectangle. We can now casework on the side of the rectangle (the sides are referred to as in the picture from the problem statement): 

If the cable touches the front side, its length will be b+|a−f|+g.If the cable touches the left side, its length will be a+|b−g|+f.If the cable touches the back side, its length will be (d−b)+|a−f|+(d−g).If the cable touches the right side, its length will be (w−a)+|b−g|+(w−f).Out of these four values, the smallest one (plus h) is the answer. 

Source1782B - Going to the Cinema 

Explanation1782B - Going to the CinemaLet's fix the number of people going to the cinema k and try to choose a set of this exact size. What happens to people with different ai? 

If ai<k, person i definitely wants to go.If ai>k, person i definitely does not want to go.If ai=k, there is actually no good outcome for person i. If person i goes to the cinema, there are only k−1 other people going, so person i will be sad (since k−1<ai). If person i does not go, there are k other people going, so person i will be sad too (since k≥ai).Thus, for a set of size k to exist, there must be no people with ai=k, and the number of people with ai<k must be exactly k. We can easily check these conditions if we use an auxiliary array cnt such that cnt[x] is equal to the number of people with ai=x. 

Alternative solution: 

Notice that if a set of k people can go to the cinema, it must always be a set of people with the smallest ai. Thus, we can start with sorting the array a in non-decreasing order. 

Then, for each length k of a prefix of this array, we can check whether the first k elements are all smaller than k, and the remaining n−k elements are all greater than k. 

However, since the array is sorted, it is enough to check that the k-th element is smaller than k, and the k+1-th element is greater than k. 

Source 1Source 21782C - Equal Frequencies 

Explanation1782C - Equal FrequenciesInstead of "finding t that differs from s in as few positions as possible", let's formulate it as "finding t that matches s in as many positions as possible", which is obviously the same. 

First of all, let's fix k, the number of distinct characters string t will have. Since the string must consist of lowercase English letters, we have 1≤k≤26, and since the string must be balanced, we have nmodk=0. For each k that satisfies these conditions, we will construct a balanced string that matches s in as many positions as possible. In the end, out of all strings we will have constructed, we will print the one with the maximum number of matches. 

From now on, we are assuming k is fixed. Suppose we choose some character c to be present in string t. We need to choose exactly nk positions in t to put character c. 

Let freqc be the number of occurrences of c in s. 

Then, in how many positions can we make s and t match using character c? The answer is: in min(nk,freqc) positions. 

Now, since we want to maximize the total number of matches, we should choose k characters with the largest values of min(nk,freqc). This is also equivalent to choosing k characters with the largest values of freqc. 

How to construct the desired string? For each chosen character c, pick any min(nk,freqc) of its occurrences in s and put c in the corresponding positions in t. Then, if freqc<nk, save the information about nk−freqc unused characters c; otherwise, if freqc>nk, save the information about freqc−nk empty positions in t. In the end, match the unused characters with the empty positions arbitrarily. 

Source1782D - Many Perfect Squares 

Explanation1782D - Many Perfect SquaresThe answer is obviously at least 1. 

Can we make it at least 2? In this case, let's check all possible pairs of indices i<j and try to figure out for what values of x both ai+x and aj+x are perfect squares. 

We can write down two equations: ai+x=p2 and aj+x=q2, for some non-negative integers p<q. 

Let's subtract the first equation from the second one and apply the formula of difference of two squares: aj−ai=q2−p2=(q−p)(q+p). It follows that q−p is a positive integer divisor of aj−ai. It is well-known how to enumerate all divisors of aj−ai in O(aj−ai−−−−−−√). For each such divisor d, we have a simple system of equations for p and q: 

{q−p=dq+p=aj−aidthat we can solve: 

{p=12(aj−aid−d)q=12(aj−aid+d)and if both p and q turn out to be integers, that means we have found a candidate value for x: x=p2−ai=q2−aj. 

For each candidate value of x, we can just calculate its squareness and find the maximum. 

The complexity of this solution is O(n2⋅an−−√+n3⋅f(an)), where f(an) is the maximum number of divisors an integer between 1 and an can have. The first part corresponds to finding all divisors of aj−ai for all pairs i<j. The second part corresponds to checking all candidate values of x: there are O(n2⋅f(an)) of them, and we need O(n) time to calculate the squareness of each. 

Bonus: The first part can be optimized by using faster factorization methods. Can you see how to optimize the second part to O(n2⋅f(an))? 

Source1782E - Rectangle Shrinking 

Explanation1782E - Сжатие прямоугольниковIt turns out that it is always possible to cover all cells that are covered by the initial rectangles. 

If the grid had height 1 instead of 2, the solution would be fairly simple. Sort the rectangles in non-decreasing order of their left border li. Maintain a variable p denoting the rightmost covered cell. Then, for each rectangle, in order: 

If ri≤p, remove this rectangle (note that since we process the rectangles in non-decreasing order of li, it means that this rectangle is fully covered by other rectangles).Otherwise, if li≤p, set li=p+1 (shrink the current rectangle). Then, set p=ri (this is the new rightmost covered cell).Let's generalize this approach for a height 2 grid. Again, sort the rectangles in non-decreasing order of li, and maintain two variables p1 and p2 denoting the rightmost covered cell in row 1 and row 2, respectively. Then, for each rectangle, in order: 

If it is a height 1 rectangle (that is, ui=di), proceed similarly to the "height 1 grid" case above:If ri≤pui, remove this rectangle.Otherwise, if li≤pui, set li=pui+1. Then, set pui=ri.If it is a height 2 rectangle (that is, ui=1 and di=2):If ri≤p1, set ui=2 (remove the first row from the rectangle) and go back to the "height 1 rectangle" case above.If ri≤p2, set di=1 (remove the second row from the rectangle) and go back to the "height 1 rectangle" case above.Otherwise, consider all processed rectangles j that have rj≥li, i.e., intersect the i-th rectangle. If lj≥li, remove rectangle j; otherwise, shrink rectangle j by setting rj=li−1. Finally, set p1=p2=ri.Here, only the last case is tricky and different from our initial "height 1 grid" solution, but it is also necessary: in a height 2 grid, sometimes we have to shrink rectangles on the right, not only on the left. 

Now, if we implement this solution in a straightforward fashion, iterating over all j<i for every i, we'll arrive at an O(n2) solution — again, purely because of the last case. To optimize it, note that once a rectangle is shrinked in this last case, it never has to be shrinked again. Thus, we can maintain all rectangles in a priority queue ordered by their ri, and once we pop a rectangle from the priority queue, we will never have to push it again, which will help us arrive at an amortized O(nlogn) solution. 

Instead of a priority queue, we can use some stacks as well — one for each row and maybe an extra one for height 2 rectangles. The overall time complexity will still be O(nlogn) due to sorting. 

Source1782F - Bracket Insertion 

Explanation1782F - Bracket InsertionInstead of looking at a probabilistic process, we can consider all possible ways of inserting brackets. There are 1⋅3⋅5⋅…⋅(2n−1)=(2n−1)!! ways of choosing places, and 2n ways of choosing "()" or ")(" at every point. Let r be the sum of pk⋅(1−p)n−k over all such ways that lead to a regular bracket sequence, where k is the number of strings "()" inserted during the process (and n−k is then the number of strings ")(" inserted). Then, r(2n−1)!! is the answer to the problem. 

Consider the sequence of "prefix balances" of the bracket sequence. The first (empty) prefix balance is 0, and each successive balance is 1 larger than the previous one if the next bracket is '(', and 1 smaller if the bracket is ')'. 

Initially, when the bracket sequence is empty, the sequence of prefix balances is [0]. Whenever we insert "()" into the bracket sequence in a place with prefix balance x, essentially we are replacing x with [x,x+1,x] in the sequence of prefix balances. Whenever we insert ")(" instead, that's equivalent to replacing x with [x,x−1,x]. 

A bracket sequence is regular if and only if its corresponding sequence of prefix balances does not have any negative integers (and ends with 0; however, this is guaranteed in our setting). 

Thus, we can reformulate the problem as follows: 

Initially, we have an integer array [0].n times, we choose an integer from the array uniformly at random.Say this integer is x, then we replace x with [x,x+1,x] with probability p, and with [x,x−1,x] with probability 1−p.What is the probability that the sequence will not contain negative integers at any point?Let f(n,x) be the sought probability multiplied by (2n−1)!! if we start with [x] Here, we multiply by (2n−1)!! to simplify the formulas, and to keep thinking about "numbers of ways" instead of "probabilities", as described in the first paragraph of this tutorial. 

The base cases are f(0,x)=1 if x≥0, and f(0,x)=0 otherwise. When n>0: 

f(n,x)==∑i=0n−1∑j=0n−1−ip⋅(n−1i)⋅(n−1−ij)⋅f(i,x)⋅f(j,x+1)⋅f(n−1−i−j,x)++∑i=0n−1∑j=0n−1−i(1−p)⋅(n−1i)⋅(n−1−ij)⋅f(i,x)⋅f(j,x−1)⋅f(n−1−i−j,x). 

What does this formula mean? Essentially, since we start with an array of a single integer [x], the first operation has to be applied to x. After that, once x gets replaced with [x,x±1,x], i operations will be applied to the left x (including everything produced from it), j operations will be applied to x±1 (again, together with its production), and n−1−i−j operations will be applied to the right x (and to its production). 

Thus, we can find the sum over i and j of the product of the corresponding values of f and the binomial coefficients: since the sequences of i, j, and n−1−i−j operations can be interleaved arbitrarily, we have (n−1i) ways to choose the positions of i operations applied to the left x in the global sequence of n−1 operations, and then (n−1−ij) ways to choose the positions of j operations applied to x±1 out of the remaining n−1−i positions in the global sequence. 

This results in an O(n4) solution, since there are O(n2) values of f to calculate, and each of them is calculated in O(n2). 

To optimize it, let's rewrite the formula a little bit by moving the loop over j outside: 

f(n,x)=∑j=0n−1(p⋅f(j,x+1)+(1−p)⋅f(j,x−1))⋅(n−1j)⋅∑i=0n−1−j(n−1−ji)⋅f(i,x)⋅f(n−1−j−i,x).Now, let's introduce an auxiliary function: 

g(k,x)=∑i=0k(ki)⋅f(i,x)⋅f(k−i,x).Now, let's rewrite the formula for f using g: 

f(n,x)=∑j=0n−1(p⋅f(j,x+1)+(1−p)⋅f(j,x−1))⋅(n−1j)⋅g(n−1−j,x).Now, both g(n,x) and f(n,x) can be computed in O(n) time, resulting in an O(n3) solution. 

Source1782G - Diverse Coloring 

Explanation1782G - Разнообразная раскраскаIt turns out that it is always possible to construct a diverse coloring with disbalance 0 or 1 (depending on the parity of n), except for the case of a tree with 4 vertices with one vertex of degree 3 (which is given in the example). 

Let's traverse the tree from bottom to top. For each subtree, we will try to construct a diverse coloring where the subtree root is colored white. We will define the disbalance of the subtree coloring to be the number of vertices colored white, minus the number of vertices colored blue. This is equivalent to the original definition, except that now the number also has a sign. 

We will aim at obtaining disbalances 0 and +1, if possible. In some small cases, it will be impossible. We will say "subtree has disbalance x" or "vertex has disbalance x", meaning that we have constructed a coloring of the (vertex's) subtree with disbalance x. 

Let u be the root of the subtree (colored white): 

If u has no children, the only coloring has disbalance +1; however, it is not diverse. Thus, we will have to be careful about the leaf case in the future.If u has one child v, flip the colors in v's subtree to create a blue neighbor for u:If v had disbalance 0 before the flip, now u has disbalance +1.If u had disbalance +1 before the flip, now u has disbalance 0.If u has two children v and w:If both have disbalance 0, flip the colors in at least one of v's and w's subtrees, now u has disbalance +1.If both have disbalance +1, flip the colors in either v's or w's subtree, now u has disbalance +1.If one has disbalance 0 and the other has disbalance +1, flip the colors in the one with 0, now u has disbalance 0.The only issue happens when u has two children that are both leaves: we have to recolor both v and w into blue, which will force u to have disbalance −1. Let's add new cases to the analysis above based on the existence of subtrees with disbalance −1: 

If u has one child v with disbalance −1:Flip the colors in v's subtree, now u has disbalance +2.If u has two children v and w, where v has disbalance −1:If w has disbalance −1, flip the colors in either v's or w's subtree, now u has disbalance +1.If w has disbalance 0, flip the colors in w's subtree, now u has disbalance 0.If w has disbalance +1, flip the colors in both v's and w's subtrees, now u has disbalance +1.We can see that, once again, a new case appears where a subtree has disbalance +2 (described at the beginning of this tutorial), and unfortunately we can't avoid that. We can see that this case only happens for a specific subtree of 4 vertices. Let's proceed with the case analysis... 

If u has one child v with disbalance +2:Flip v's color (not the whole subtree, but just v), now u has disbalance +1.If u has two children v and w, where v has disbalance +2:If w has disbalance −1, flip the colors in both v's and w's subtrees, now u has disbalance 0.If w has disbalance 0, flip v's color, now u has disbalance +1.If w has disbalance +1, flip v's color and the colors in w's subtree, now u has disbalance 0.If w has disbalance +2, flip the colors in either v's or w's subtree, now u has disbalance +1.It follows that for any other tree, except two special cases of a 3-vertex tree and a 4-vertex tree, it is possible to obtain disbalance 0 or +1. 

From this point, one way to implement the solution is to carefully consider all the cases. Note that whenever we say "flip the colors in v's subtree", we can just set some flag in vertex v. Then, as we traverse the tree from top to bottom, we can construct the correct coloring in O(n) time. 

Another way is to use dynamic programming f(u, d, hasNeighbor) = true/false: whether it is possible to color u's subtree to obtain disbalance d so that all vertices except u have neighbors of opposite color, and u has such a neighbor iff hasNeighbor = true. Since it is enough to limit disbalance by O(1), we can conclude that the number of states, the number of transitions, and the time complexity are all O(n). 

Source (2nd approach)1782H1 - Window Signals (easy version) 

Explanation1782H1 - Window Signals (easy version)Let's iterate over the dimensions of the bounding box of the image of windows with lights on, h′×w′ (1≤h′≤h;1≤w′≤w), count images with such bounding box, and sum all these values up. 

An image has a bounding box of size exactly h′×w′ if and only if: 

it fits inside an h′×w′ rectangle;it has a light on each of its four borders.To account for the second condition, we can use inclusion-exclusion principle. This way, we will have an "it does not have a light on some of its borders" condition instead, at the cost of an extra 24 time factor. We will disregard this condition in the rest of this tutorial. 

There are 2h′w′ possible images fitting in an h′×w′ rectangles. How many of them are impossible to show because of broken lights? Let's find this number and subtract it. 

Consider all possible ways to place a rectangle of size h′×w′ on the given h×w grid: 

If there are no broken lights inside, any image of size h′×w′ is possible to show, so we don't need to subtract anything for this size at all.If there is 1 broken light inside, its relative position in the h′×w′ rectangle must be turned on (for an image to be impossible to show).If there are 2 broken lights inside, find their relative positions in the h′×w′ rectangle. For an image to be impossible to show, at least one of the two positions must be turned on.Unless a placement with no broken lights exists, we have some cells in the rectangle where the light must be turned on — let's call the set of these cells X, and some pairs of cells where at least one light must be turned on — let's call the set of these pairs Y. 

If a pair from Y contains a cell from X, this pair can be removed from Y. Once we do that, note that the pairs from Y form several chains — that happens because the coordinate-wise distance between the cells in each pair is equal to the distance between the broken lights, which is (r2−r1,c2−c1). 

If we have a chain of length p, it can be seen that there are f(p) ways to turn lights on so that every pair of neighboring cells has at least one light, where f(p)=f(p−1)+f(p−2) are Fibonacci numbers. 

Thus, the number to subtract is the product of: 

2w, where w is the number of cells not included in X and Y;f(p) over all chains formed by Y, where p is the length of a chain.Every subgrid size h′×w′ is processed in O(hw) time, and there are hw different sizes, thus, the overall time complexity is O(h2w2). 

It is possible to optimize the constant factor of this solution to pass the hard version too. However, a solution of O(hw2) time complexity exists as well. Here is a sketch of it: 

Instead of fixing both dimensions of the lights image, h′ and w′, let's only fix w′.Use inclusion-exclusion like described at the beginning of this tutorial; however, only use it for the top, left, and right borders. We will not use it for the bottom border, since we are not fixing the height of the image.Go through all top-left corners (i,j) of the lights image in lexicographic order (1≤i≤h;1≤j≤w−w′+1).For each top-left corner, count how many images of width w′ can be shown using this top-left corner, which can not be shown using any previous top-left corner.Similarly to the previous solution, consider cases of 0, 1, and 2 broken lights inside the current subgrid. Note, however, that we are not fixing the height of the subgrid, so just assume that it stretches all the way down to the bottom border of the whole grid.Maintain the set of cells X using an array, and maintain the set of pairs Y using linked lists.Once a cell joins set X, remove all pairs that touch it from set Y. Once a pair joins set Y, if neither of its ends belongs to X, merge two corresponding linked lists.Maintain a variable denoting the product of f(p) over all chains formed by Y. Once any split or merge happens to the lists, update this variable using O(1) multiplications/divisions.Whenever i (the row number of the top-left corner) increases by 1, the maximum available height of the lights image decreases by 1. Thus, we have to "remove" the cells in the current bottom row: that is, for any future image, we won't be able to light up those cells. If any such cell belongs to X, just stop: we won't get any new images. Otherwise, if such a cell belongs to a pair in Y, add the second end of this pair to X.For fixed width w′ and for each top-left corner (i,j), we need to spend O(1) time. Moreover, for fixed width w′, once i increases (which happens O(h) times), we need to spend O(w) time to process cell removals. Hence, the time complexity of both parts is O(hw2).Source for easy versionSource for hard version 

Codeforces Round #843 (Div. 2) Editorial 

By kartel, history, 6 weeks ago, translation, In English1775A1 - Gardener and the Capybaras (easy version) 

Solution1775A1 - Gardener and the Capybaras (easy version)To solve this problem, it was enough just to consider all options of splitting the string into three substrings, and there are only O(n2) ways to do it. 

1775A2 - Gardener and the Capybaras (hard version) 

Solution1775A2 - Gardener and the Capybaras (hard version)Consider five cases to solve the task: 

If the string starts with aa, then we can split it into a=s[0], b=s[1], c=s[2...n−1].If the string starts with bb, then we can split it into a=s[0], b=s[1], c=s[2...n−1].If the string starts with ba, then we can split it into a=s[0], b=s[1], c=s[2...n−1].If the string starts with ab, and then there is another letter a at position i>1, then we can split it into a=s[0], b=s[1...i−1], c=s[i...n−1].If the string starts with ab, and all other letters are b, then we can split it into a=s[0...n−3], b=s[n−2], c=s[n−1].1775B - Gardener and the Array 

Solution1775B - Gardener and the ArrayThe problem can be solved as follows: for each bit count the number of its occurrences in all numbers in the test. If each number has a bit which occurs in all numbers exactly once, then the answer is "NO", otherwise the answer is "YES". 

Let's try to prove this solution. Let there be a number in which all bits occurs in all numbers at least 2 times. But then it is possible to construct a sequence a using all numbers, and a sequence b using all numbers except the given one. 

If each number has "unique" bits, then all f(x) will be different. 

1775C - Interesting Sequence 

Solution1775C - Interesting SequenceNote that the answer −1 will be when n AND x≠x. This holds if there is a bit with number b which exists in number x, but it does not exist in number n. What is clear now is that some bits in n must be zeroed. Since we have bitwise AND going sequentially with numbers larger than n, we change the bits from the lowest to the highest. Thus, in number n some bit prefix is zeroed out, so if number x is not number n with a zeroed prefix (possibly empty) of bits, then there is no answer. 

Now we can calculate for each bit i the minimal number mi such that n AND n+1 AND … AND mi has 0 in the i-th bit. 

Now calculate mzero as the maximum mi on all bits to be zeroed, and mone as the minimum mi on all bits to be left untouched. Then, if mzero<mone, we will take mzero as the answer, otherwise there is no answer. The problem can also be solved by binary search: we will use it to find m, and check the answer by the formula: for each bit find the nearest m, at which it will be zeroed. We can do this using the following fact: for i-th bit, the first 2i numbers (starting from zero) will not contain it, then 2i will, then 2i again will not and so on. Such a solution works for O(log2n). 

1775D - Friendly Spiders 

Solution1775D - Friendly SpidersNote that if we construct the graph by definition, it will be large. This will lead us to the idea to make it more compact. Let us create a bipartite graph whose left part consists of n vertices with numbers ai. And in the right part each vertex corresponds to some prime number, not larger than the maximal number from the left part. Draw an edge from the vertex v of the left part to the vertex u of the right lpart if and only if av is divisible by a prime number corresponding to the vertex u. In this graph from vertex s to vertex t, run bfs and output the distance divided by 2. 

Now about how to construct such a graph quickly. Obviously, the number ai will have at most logai different prime divisors. Then let us factorize av and draw edges from vertex v to each prime in factorization. 

1775E - The Human Equation 

Solution1775E - The Human EquationLet's calculate an array of prefix sums. What do the operations look like in this case? If we calculate the array of prefix sums, we'll see that the operations now look like "add 1 on a subsequence" or "take away 1 on a subsequence". Why? If we take the indices i and j and apply our operation to them (i.e. ai=ai+1 and aj=aj−1), it will appear that we added 1 on the segment [i...j−1] in the prefix sums array. 

We still need to make the array all zeros. How? We will add 1 to all elements that are less than zero, then subtract 1 from all elements that are greater than 0. 

From this we get that the answer is the difference between the maximum and minimum prefix sums. 

1775F - Laboratory on Pluto 

Solution1775F - Laboratory on PlutoLet us find out the minimal perimeter for a fixed n in O(1). 

Let a=⌊n−−√⌋: 

If a2<n and n≤a⋅(a+1), then the minimum perimeter will be 2⋅(2⋅a+1).If a⋅a+a<n and n≤(a+1)2, then the minimum perimeter will be 4⋅(a+1).If 1) and 2) are not satisfied, then the minimum perimeter is 4⋅a.For convenience, we denote the semiperimeter by p. Let's check one of the rectangle's side x from 1 to p. We will immediately get y=p−x. Then if the area of the rectangle is at least n, then for tests with u=1 we can derive a rectangle with sides x and y by removing some number of cells from the 1st row or column of this matrix. 

Consider a matrix with sides x and y with minimal perimeter and area at least n. It is easy to see that if we gradually remove one corner cell of a given figure, the perimeter will not change. Suppose we have some good figure. Let's look at all four figures that form empty cells in the matrix. These figures form a kind of 'staircase', that is, the number of cells in the past row is not less than the number of cells. Why is this so? Suppose that in some line we delete a cell so that the figure ceases to form a staircase. In that case the perimeter of the piece will increase by 2, which will be the bad piece. 

Now the problem is reduced to the following: 

For each matrix with dimensions x by y with minimal perimeter and area not less than n, calculate the number of ways to arrange the staircases in 4 corners such that the sum of cells occupied by the staircases equals x⋅y−n. How to do this? 

Assume DP dpangles,sum,last — the number of ways to arrange staircases in angles, not more than 4, so that the sum of all cells occupied by staircases equals sum and the length of the last line of staircase equals last. Then how to count the given DP? Go through angles,sum,last and cur≤last - the length of the line we will add to the current staircase, then go from dpangles,sum,last to dpangles,sum+cur,cur. Or go to the next corner dpangles+1,sum,maxP. This DP works for O(n⋅n−−√). 

To answer n we go through all good rectangles, as specified above, and add f4,x⋅y−n,maxP to the answer. 

To solve the problem for a full score, you must optimize the above DP to O(n). The final difficulty is O(n+t⋅n−−√). 

Now it is time for the bonus task and author solutions! 

BonusProblem A can be solved for O(n) even if the alphabet consists of all letters. Think about how this can be done. 

Bonus answerThe size of the second string is 1. You can just go through it. 

Code for Problem A (solution for large alphabet)Code for Problem BCode for Task CCode for Task DCode for Task ECode for Task F 

Codeforces Round #842 (Div. 2) Editorial 

By Vladithur, history, 2 months ago, In EnglishHope you liked the problems! 

(from thanhchauns2) Before the round starts1768A - Greatest Convex 

Author: thanhchauns2 

HintsTutorial1768A- Greatest ConvexIs x=k−1 always suitable? 

The answer is yes, as x!+(x−1)!=(x−1)!×(x+1)=((k−1)−1)!×((k−1)+1)=(k−2)!×(k), which is clearly a multiple of k. 

Therefore, x=k−1 is the answer. 

Time complexity: O(1)SolutionFeedback1768B - Quick Sort 

Author: Vladithur Preparation: Vladithur and Alexdat2000 

HintsTutorial1768B - Quick SortSuppose we can make operations so that x elements do not participate in any operation. Then these x elements in the final array will end up at the beginning in the order in which they were in the initial array. And since this x must be maximized to minimize the number of operations, we need to find the maximal subsequence of the numbers [1,2,…]. Let this sequence have w numbers, then the answer is ⌈n−wk⌉=⌊n−w+k−1k⌋. 

SolutionFeedback1768C - Elemental Decompress 

Author: thanhchauns2 

HintsTutorial1768C- Elemental DecompressTwo cases produce no answers: 

One element appears more than twice in a. 

After sorting, there is some index that a[i]<i (1-indexed). 

ProofOtherwise, solutions always exist. One method is to constructively attach each element in a to p or q: 

Traverse from the biggest element to the smallest in a, if that number haven't appeared in p then attach it to p, otherwise attach it to q. 

Traverse from the biggest element to the smallest in a again, if we attached it to p, find the biggest number that did not appear in q and attach to q, vice versa. 

A naive solution requires the O(n2) method to solve. We can reduce to O(nlogn) by sorting elements in a as pairs <element, index>. 

Time complexity: O(nlog(n))SolutionYet another better solutionFeedback1768D - Lucky Permutation 

Author: Vladithur Preparation: Vladithur and Alexdat2000 

HintsTutorial1768D - Lucky PermutationFor some fixed n, there are n−1 permutations that have exactly 1 inversion in them (the inversion is colored): 

2,1,3,4,…,n−1,n1,3,2,4,…,n−1,n1,2,4,3,…,n−1,n... 

1,2,3,4,…,n,n−1Let's build a directed graph with n vertices where the i-th vertex has an outgoing edge i→pi. It is easy to see that the graph is divided up into cycles of the form i→pi→ppi→pppi→…→i. 

Let cycles be the number of cycles in this graph. It is a well know fact that n−cycles is the minimum number of swaps needed to get the permutation 1,2,3,…,n from our initial one (in other words, to sort it). 

Suppose we now want to get the k-th permutation from the list above. Let x and y be such that px=k and py=k+1. 

Let us remove the edges x→k and y→k+1 from the graph and instead add the edges x→k+1 and y→k. Let cycles′ be the number of cycles in this new graph. The minimum number of swaps needed to get the k-th permutation in the list is equal to n−cycles′. 

Turns out that we can easily calculate cycles′ if we know cycles: 

cycles′=cycles+1 if the vertices k and k+1 were in the same cycle in the initial graph,cycles′=cycles−1 otherwise.To quickly check if two vertices u and v are in the same cycle, assign some id to each cycle (with a simple dfs or with a DSU) and the compare u-s cycle id with v-s cycle id. 

The answer is just the minimum possible value of n−cycles′ over all 1≤k≤n−1. 

Time complexity: O(n). 

PS: you can also find cycles′ with data structures (for example, by maintaining a treap for each cycle). 

SolutionFeedback1768E - Partial Sorting 

Author: thanhchauns2 

HintsTutorial1768E- Partial SortingWe need at most 3 operations to sort the permutation: 1−>2−>1For f(p)=0, there is only one case: the initially sorted permutation.Calculatereturn (38912738912739811 & 1) 

For f(p)≤1, this scenario appears when the first n numbers or the last n numbers are in the right places.CalculateBoth cases have n fixed positions, so there will be (2n!) permutations in each case. 

Intersection: since both cases share the n middle elements, (n!) permutation will appear in both cases. 

So there will be 2×(2n!)−(n!) such permutations. 

For f(p)≤2, this scenario appears when the smallest n elements' positions are in range [1,2n], or the largest n numbers' positions are in range [n+1,3n].CalculateIf the smallest n elements are all in position from 1 to 2n, then: 

There are Cn2n ways to choose n positions for these numbers. 

For each way to choose these positions, there are n! ways to choose the position for the smallest n numbers, and 2n! ways for the rest. 

The total number of valid permuations are: Cn2n×n!×2n!If the largest n elements are all in position from n+1 to 3n, we do the same calculation. 

Intersection: intersection appears when the first n numbers are all in range [1,2n] and the last n numbers are all in range [n+1,3n]. 

Let intersection = 0 

Sketch and calculation in detailsThe number of intersections will be equal to: ∑ni=0Cn−in×Cin×Cn2n−i×n!×n!×n!So, the answer will be 2×Cn2n×n!×2n!−∑ni=0Cn−in×Cin×Cn2n−i×n!×n!×n!For f(p)≤3, it will be the count of all valid permutations.Calculatereturn __factorial(n * __number_of_sides_of_a_triangle) 

Time complexity: O(n) 

SolutionFeedback1768F - Wonderful Jump 

Author: Vladithur Preparation: Vladithur and Alexdat2000 

HintsTutorial1768F - Wonderful JumpThere is a very easy O(n2) dp solution, we will show one possible way to optimize it to O(n⋅A−−√), where A is the maximum possible value of ai. 

Let dpk be the minimum number of eris required to reach index k, dp1=0. 

Suppose we want to calculate dpj and we already know dp1,dp2,…,dpj−1. Let's look at our cost function more closely. 

We can notice that it is definitely not optimal to use the transition i→j if min(ai…aj)⋅(j−i)2>A⋅(j−i). That is, it will be more optimal to perform j−i jumps of length 1. 

Transforming this inequality, we get j−i>Amin(ai…aj). So if min(ai…aj) is quite large, we only need to look at a couple of i close to j, and then do something else for the small values of min(ai…aj). 

1. min(ai…aj)≥A−−√To handle this case, we can just iterate over all i from max(j−A−−√,1) to j−1, since the transition i→j could be optimal only if j−i≤Amin(ai…aj)≤A−−√. 

Time complexity: O(A−−√). 

2. min(ai…aj)<A−−√Another useful fact is that if there exists an index k such that i<k<j and ak=min(ai…aj), the transition i→j also cannot be optimal, since i→k followed by k→j will cost less. 

Proof:min(ai…aj)⋅(j−i)2>min(ai…ak)⋅(k−i)2+min(ak…aj)⋅(j−k)2ak⋅(j−i)2>ak⋅(k−i)2+ak⋅(j−k)2(j−i)2>(k−i)2+(j−k)2This leaves us two subcases two handle. 

2.1 min(ai…aj)=aiJust maintain the rightmost occurrences <j of all values from 1 to A−−√. Time complexity: O(A−−√). 

2.2 min(ai…aj)=ajInitially set i to j−1 and decrease it until ai≤aj becomes true. Time complexity: O(A−−√) amortized. 

Total time complexity: O(n⋅A−−√)SolutionShorter solution (tfg)Feedback 

Codeforces Round #841 (Div. 2) and Divide By Zero 2022 Editorial 

By s_jaskaran_s, history, 2 months ago, In EnglishUPD: Code links are working now 

1731A - Джо нужны деньги 

Idea: s_jaskaran_s 

HintSolution1731A - Joey Takes MoneyIf we take two elements a1 and a2 and do the operation on it as a1⋅a2=x⋅y, then it is easy to observe that x+y will attain its maximum value when one of them is equal to 1. So, the solution for this is x=1 and y=a1⋅a2. 

Let n be the total number of elements and P (P=a1⋅a2⋅…⋅an) be the product of all elements. 

Now if we do the above step for every pair of elements, then the maximum value of the sum is achieved when a1=1, a2=1, …, an−1=1 and an=P. 

In the final array, assign P to a1 and assign 1 to all the remaining elements a2,a3,…an. 

So, our answer is simply P+n−1 multiplied by 2022, of course. 

Time complexity: O(n). 

Code1731B - Уничтожение демодогов 

Idea: s_jaskaran_s 

HintSolution1731B - Уничтожение демодоговTo kill the maximum number of demodogs, El can travel in zigzag fashion, i.e. from (1,1) to (1,2) to (2,2) and so on. Thus the answer would be the sum of elements at (1,1), (1,2), (2,2) … (n,n). i.e. the answer is∑i=1ni⋅i+∑i=1n−1i(i+1)=n(n+1)(4n−1)6. 

And the answer you need to print is2022n(n+1)(4n−1)6=337⋅n(n+1)(4n−1)(mod109+7)Proof: 

Let killsi,j be the maximum number of kills of all possible paths from (1,1) to (i,j). 

killsn−1,n−1≥killsi,n−1 + number of demodogs from (i+1,n−1) to (n−1,n−1) (∀i∈[1,n−2]). 

killsn−1,n−1≥killsi,n−1+∑j=i+1n−1j⋅(n−1)killsn−1,n−1≥killsi,n−1+(n−1−i)((i+1)(n−1)+(n−2−i)(n−1))2 (sum of A.P.)killsn−1,n−1≥killsi,n−1+(n−1−i)(n−1)22 (1)Let killsZ be the number of kills if El travels in zigzag fashion, i.e. she goes to (n,n) after passing through (n−1,n−1):killsZn,n=killsn−1,n−1+n(n−1)+n⋅nLet killsNZ be the maximum number of kills If El goes to (n,n) after passing through (i,n) for some i in range of [1…n−1], i.e. El goes from (1,1) to (i,n−1) to (i,n) to (n,n):killsNZn,n=killsi,n−1+no of demigods from (i,n) to (n,n)killsNZn,n=killsi,n−1+∑j=inj⋅nkillsNZn,n=killsi,n−1+(n+1−i)(n+i)n2killsZn,n−killsNZn,n=killsn−1,n−1+n(n−1)+n⋅n−killsi,n−1−(n+1−i)(n+i)n2 from (1)killsZn,n−killsNZn,n≥killsi,n−1+(n−1−i)(n−1)22+n(n−1)+n⋅n−killsi,n−1−(n+1−i)(n+i)n2killsZn,n−killsNZn,n≥2n2−3n−n⋅i−i−12killsZn,n−killsNZn,n≥0since 2n2−3n−n⋅i−i−1≥0 for all i∈[1,n−2]. 

In other words, killsZn,n≥killsNZn,n Therefore zigzag path guarantees maximum number of demodog kills. 

Now, the last thing was taking the modulus. Modulus should always be taken after every multiply operation to avoid the overflow. You can refer to modular arithmetic for more details. 

And the main reason we told you to multiply the answer by 2022 is that we needed to divide it by 6. For division, we have to take inverse modulo in modular arithmetic. So, in order to avoid that, we gave you a multiple of 6, which is 2022. 

Code1731C - Четные подмассивы 

Idea: ka_tri 

Hint 1Hint 2Hint 3Solution1731C - Четные подмассивыLet's calculate the number of subarrays whose XOR sum has an odd number of divisors and subtract them from total no of subarrays. 

Note: A number has an odd number of divisors only if it is a perfect square. So we have to calculate number of subarray having XOR sum a perfect square. 

For the given constraints for elements in the array, the maximum possible XOR sum of any subarray will be less than 2n, so the number of possible elements with odd divisors ≤2n−−√. Number of subarrays with a given XOR sum can be calculated in O(n). 

Therefore, calculate the same for each perfect square less than 2n and add all these to get the number of subarrays whose XOR sum has an odd number of divisors. Subtract from total number of subarrays to get the required answer. 

Time complexity : O(n⋅n−−√). 

Code(C++)Code(Python)1731D - Новая карта Valiant 

Idea: s_jaskaran_s 

Hint 1Hint 2Hint 3Solution1731D - Valiant's New MapThe basic brute force solution for this problem was to just iterate through all the values of sides possible. Note that the value of sides can range only from 1 to 1000 as product of n⋅m can't exceed 106, so there can't be a cube having all sides greater than 1000. After setting side length (let's say s) we look into all possible submatrices of dimensions s×s and see if we can form a cube from any one of those. This could only be possible if there exists a submatrix with its minimum ≥s. 

Now, we need to do all these operations efficiently, looking at the constraints. The main thing that we need to do is Binary search on the answer. As obviously, it is possible to make a cube with a smaller side if it is possible to make the one with the current side length. 

Now from here, we have two different approaches - 

Sparse Table - For a particular side s, check for all submatrices of size s×s, if their minimum is greater than equal to s. If you find any such submatrix, then this value of side is possible. A minimum can be calculated in O(1) using sparse tree. You might have tried using segment tree, which takes logm⋅logn time per query. But it may not to pass with these constraints. 

So, the time complexity to solve this problem is O(n⋅m⋅log(min(n,m))). It would pass these constraints. 

Another O(n⋅m⋅min(n,m)) solution where you don't use binary search is also there but would fail with these constraints. The segment tree solution takes O(n⋅m⋅logn⋅logm⋅log(min(n,m))) . So, only sparse tree can be used. 

Prefix Sum - This is a much simpler solution. First, we create another n×m matrix, let's say B. Now, for a particular side length s, we take all the indices where the building heights are greater than equal to s and set the elements of B at those indices to 1. Other elements are set to 0. 

Now we precalculate the prefix sum for this matrix. Then for each index (i,j) of the matrix B, we check if the square starting from that index has a prefix sum equal to s2. If anyone of it does, then this side length for the cube is possible. 

Time Complexity is again O(n⋅m⋅log(min(n,m))). 

Code(Prefix Sum)Code(Sparse Table)1731E - Стоимость графа 

Idea: s_jaskaran_s 

Hint 1Hint 2Solution1731E - Graph CostIn each step, adding e edges to the graph with weights e+1 costs one more than the number of edges added. So, the total cost of adding m edges in s steps will be m+s. Since the number of edges is given, i. e. fixed, to find the minimum cost, we need to minimize the number of steps. 

Firstly, let's calculate the number of pairs (x,y) where 1≤x<y≤n with gcd(x,y)=k for each k∈[1..n] in O(nlogn) time. It can be solved in a standard way using the Möbius function μ(x) or using Dynamic Programming, where dp[k] is the required number that can be calculated as: 

dp[k]=12⌊nk⌋(⌊nk⌋−1)−dp[2k]−dp[3k]−⋯−dp[⌊nk⌋k]Knowing all dp[k] we can calculate the maximum number of steps s[k] we can perform using edges of weight k. And s[k]=⌊dp[k]k−1⌋. 

Note that array s[k] is non-increasing (s[k]≥s[k+1]) and if we have at least one pack of size x then we have at least one pack of each size y where 1≤y<x. So, our task is an "extension" of the task where you need to take a subset of 1,2,…,n of minimum size with sum equal to m and can be solved with the same greedy strategy. 

Let's just take packs greedily, starting from weight n down to weight 2. We'll take packs as many packs as possible. For a fixed weight k we can calculate the maximum number of packs we can take as min(s[k],m′k−1). 

If m edges can't be constructed, then we return −1. Otherwise, we return m+s where s is the total number of packs. 

Time Complexity: O(nlogn)Code1731F - Сумма функций 

Idea: nishkarsh and s_jaskaran_s 

Solution1731F - Function SumLet's try to write a brute force solution of this using combinatorics. Let's say that a[i]=t now we will try to see that in how many permutations this is contributing towards the answer. Using combinatorics, it can be calculated asF(t)=t⋅∑i=1n∑x=0i−1∑y=x+1n−i((i−1x)(t−1)x(K+1−t)i−1−x⋅(n−iy)(K−t)y⋅tn−i−y). 

Here x represents lsl(i) and y represents grr(i). 

LetP(u)=∑t=1uF(t)be a polynomial whose degree will be ≤n+2. And now our answer will be P(k). 

Now, we can evaluate this polynomial for smaller values (by brute force) and will use the technique of polynomial interpolation to find the answer. 

Code 

Codeforces Round #840 (Div. 2) and Enigma 2022 — Cybros LNMIIT Editorial 

By SoCloseButStillSoFar, 2 months ago, In EnglishWe hope you liked the problems! Unfortunately, problem C turned out to be harder than usual. Please read its editorial, we hope you'll find that the intended solution is not that hard. 

1763A - Absolute MaximizationIdea: DreadArceusPrepared by: DreadArceus 

Hint 1Hint 2Need more hints?SolutionIn the minimum element, we want to make every bit 0 when possible, it won't be possible to set a particular bit to 0 when that bit is set in all the elements of a. Therefore, the minimum value we can achieve after performing the operations is the bitwise AND of all the elements of a. 

In the maximum element, we want to make every bit 1 when possible, it won’t be possible to set a particular bit to 1 when that bit is not set in any of the elements of a. Therefore, the maximum value we can achieve after performing the operations is the bitwise OR of all the elements of a. 

Therefore the answer is (OR of the array — AND of the array). 

Time Complexity: O(n)1763B - IncinerateIdea: og_Prepared by: og_ 

Hint 1Hint 2Solution 1Sort the monsters in ascending order of their powers. 

Now we iterate through the monsters while maintaining the current attack power and the total damage dealt. 

Only the monsters with health greater than the total damage dealt are considered alive, and every time we encounter such a monster it will be the weakest one at the current time, thus we need to attack until the total damage dealt exceeds the current monster's health while lowering our attack power by its power each time. 

If we can kill all the monsters in this way, the answer is YES, otherwise it is NO. 

Time Complexity: O(nlogn)Sort by power solutionSolution 2Sort the monsters in ascending order of their health. 

Now we maintain a count of monsters alive after each attack. This could be achieved by applying upperbound() on h array for each attack. The total damage dealt could be stored and updated in a separate variable. 

To find the power of the weakest monster alive, we could just precompute the minimum power of monsters in a suffix array. In other words, 

pi=min(pi,pi+1).Time Complexity: O(nlogn)Sort by health solution1763C - Another Array ProblemIdea: .utk.Prepared by: .utk. 

Hint 1Hint 2SolutionLet’s first consider the case for n≥4. The key observation to make here is that we can make all the elements of a subarray al,...ar zero by applying the operation on range [l,r] twice. Then let’s assume the maximum element mx of the array is at an index m>r. We can apply the operation on the range [l,m] and turn all its elements into mx. 

Using the above information we can see that to achieve the final array with maximum sum we need to make all the elements in it equal to the maximum element in the array. Regardless of the given array this can be achieved by making the last two elements (n-1,n) zero. Then applying the operation on subarray [m,n] to make all its elements equal to mx. Then making the first two elements (1,2) zero and applying the operation on the whole array making all the elements equal to mx. Thus the maximum sum for the final array will always be n∗mx. (In case m=n−1 or n, we can operate on the left side first to reach the same solution). 

For n=2 the maximum final sum would be max(a1+a2,2∗(|a1−a2|)). 

For n=3, when the maximum element is present at index 1 or 3 we can make all the elements of the array into mx. When the maximum element is at index 2, we have the following options. 

Case 1: We can apply the operation on (1,2), then we can convert all the elements of the array into max(a3,|a2−a1|). 

Case 2: We can apply the operation on (2,3), then we can convert all the elements of the array into max(a1,|a2−a3|). 

Case 3: We can apply the operation on (1,3) making all the elements in the array |a1−a3|. This is redundant since a2>a1,a3 either case 1 or case 2 will give a larger sum as a2−min(a1,a3)>max(a1,a3)−min(a1,a3). 

Now considering case 1, if 3∗max(a3,|a2−a1|)≤a1+a2+a3 the maximum sum possible would be the current sum of the array (see sample 1 and 3). Therefore no operations are required. Similar case for case 2. 

So the maximum possible sum for n=3 will be max(3∗a1,3∗a3,3∗|a1−a2|,3∗|a3−a2|,a1+a2+a3). 

To avoid doing this casework for n=3, we can see that there are only 3 possible operations -> (1,2) , (2,3), (1,3). We will be required to perform operations (1,2) and (2,3) at most two times. So we can brute force all possible combinations of operations [(1,2),(1,2),(2,3),(2,3),(1,3)] to find the maximum sum. 

Brute force solutionCase work solution1763D - Valid Bitonic PermutationsIdea: warksPrepared by: warks 

Hint 1Hint 2Hint 3SolutionFor simplicity, if x>y, perform i′=n−j+1, j′=n−i+1, x′=y, and y′=x. Hereafter, the variables i, j, x, and y, will refer to these values. Now, i<j and x<y. 

For now, assume that y<n. We shall consider the case where y=n at a later stage.Let us consider solving the problem for fixed k. Valid values for k are [2,i−1], [i+1,j−1], [j+1,n−1].If we think about it, when x<y, k cannot lie in the range [2,i−1]. So, we can discard them as possible values for k. 

Let us consider the case where k belongs to [i+1,j−1].The permutation adheres to the following pattern: B1<..<Bi=x<..<Bk=n>..>Bj=y>..>Bn. 

Numbers to the left of i must lie in the range [1,x−1]. We choose i−1 elements from [1,x−1] and place them to the left of i. There are (x−1i−1) ways to do this. The remaining x−i elements from [1,x−1] lie to the right of j by default.Numbers to the right of j must lie in the range [1,x−1] or [x+1,y−1]. Since numbers in the range [1,x−1] have already been placed, therefore, we choose numbers in the range [x+1,y−1], and place them in the n−j−(x−i) remaining positions. There are (y−x−1n−j−(x−i)) ways to do this. The remaining elements in the range [x+1,y−1] lie between i and k by default.Numbers between k and j must lie in the range [y+1,n−1]. We choose j−k−1 elements from [y+1,n−1] and place them between k and j. There are (n−y−1j−k−1) ways to do this. Afterwards, the remaining elements in the range lie between i and k by default, and the permutation is full.Multiplying the ways for the above three actions, we get that the answer for a fixed k, when between i and j as:(x−1i−1)∗(y−x−1n−j−(x−i))∗(n−y−1j−k−1)Let us consider the case where k belongs to the range [j+1,n−1].The permutation adheres to the following pattern: B1<..<Bi=x<..<Bj=y<..<Bk=n>..>Bn. 

Similar to above, the numbers to the left of i must lie in the range [1,x−1]. We choose i−1 elements from [1,x−1], and place them to the left of i. The remaining x−i elements from [1,x−1] lie to the right of k by default.Numbers between i and j must lie in the range [x+1,y−1]. We choose j−i−1 elements from [x+1,y−1] and place them between i and j. There are (y−x−1j−i−1) ways to do this, and the remaining elements from [x+1,y−1] lie to the right of k by default.Numbers between j and k must lie in the range [y+1,n−1]. We choose k−j−1 elements from [y+1,n−1] and place them in these positions. Afterwards, the remaining elements in the range get placed to the right of k by default, and the permutation is full.Multiplying the ways for the above three actions, we get the answer for a fixed k, when between j+1, and n−1 as:(x−1i−1)∗(y−x−1j−i−1)∗(n−y−1k−j−1)The answer to the problem is the sum of individual answers for all iterated values of k. 

ans=(x−1i−1)∗(y−x−1n−j−(x−i))∗∑j−1k=i+1(n−y−1j−k−1) + (x−1i−1)∗(y−x−1j−i−1)∗∑n−1k=j+1(n−y−1k−j−1)Let us now consider the case where y=n.The permutation adheres to the following pattern: B1<..<Bi=x<..<Bj=Bk=n>..>Bn. 

Again, the numbers to the left of i must lie in the range [1,x−1]. We choose i−1 elements from [1,x−1] and place them to the left of i. The remaining x−i elements from [1,x−1] lie to the right of j (here, k) by default.Numbers between i and j must lie in the range [x+1,y−1]. We choose j−i−1 elements form [x+1,y−1] and place them between i and j. The remaining elements from [x+1,y−1] lie to the right of j (here, k) by default, and the permutation is full.Multiplying the ways for the above two actions, we get the answer for k=j (y=n) as:(x−1i−1)∗(y−x−1j−i−1)With O(nmax∗log(109+7−2)) precomputation for factorials and their modular inverses, each individual test can be solved as above in O(n). Therefore, the overall complexity of this approach is O(nmax∗log(109+7−2)+t∗n), but the constraints allowed for slower solutions as well. 

Bonus: Can you solve the problem when 1≤t,n≤105. 

Code1763E - Node PairsIdea: crimsonredPrepared by: ...nvm, DreadArceus, crimsonred 

Hint 1Hint 2SolutionFor two nodes u and v to be reachable from each other, they must lie in the same strongly connected component (SCC). Let's define f(i) as the minimum number of nodes required to construct an i-reachable graph. We can use dynamic programming and calculate f(i) as f(i)=min(f(i—s(s—1)2)+s) over all the valid SCC sizes s for which s(s—1)2≤i, i.e., over those s which have less pairs of the required type than i. Thus, f(p) gives us the minimum number of nodes required to create a p-reachable graph. 

In all p-reachable graphs with f(p) nodes, the upper bound on the number of unidirectional pairs of nodes is (f(p)2)−p, because we have exactly p pairs of nodes which are reachable from each other. It is possible to achieve this upper bound using the following construction: let s1,s2,…,sk be any sequence of SCC sizes which agrees with the dp values we calculated earlier. Let the first SCC contain the nodes [1,s1], the second one contain [s1+1,s1+s2], and so on. We add a directed edge from u to v if u<v. 

Time Complexity: O(pp–√)Code1763F - Edge QueriesIdea: ...nvm, DreadArceusPrepared by: ...nvm, DreadArceus 

Hint 1Hint 2Hint 3Hint 4SolutionFirst, let us see examples of graphs that are valid or invalid according to the statement. 

Valid Graph ExampleInvalid Graph ExampleThe queries ask us to count all non-bridge edges in any simple path from u to v. 

There are many ways to proceed with the solution. We will first go into a simple one that gives more insight into the problem. 

We can see our graph as a tree of BiConnected Components (BCCs). 

The edges of the tree are all bridges.Let’s define a few things before continuing further. 

The first node of a BCC that is visited in the DFS tree will represent that BCC.Let rep[u] be the representative of the BCC of node u.cnt[u] be the number of edges in the BCC of u.Root node of our tree of BCCs is root.lca(u,v) is the lowest common ancestor of u and v.With all that set, let us now look at the DFS tree. 

We can build an array dp to store the answer to query(root,u), for all u, and to answer queries, we can use LCA. 

In a typical LCA use case, query(u, v) would be dp[u]+dp[v]−2∗dp[lca(u,v)], But is that the case here? 

Let us bring attention to a few things. 

FirstSecondThirdIn conclusion, in this setup, we need to determine how the simple paths from u to v cross through the BCC of lca(u,v), then the queries will be answered. 

How to distinguish?Or make a better graph to deal with this… 

Codeforces Round #839 (Div. 3) Editorial 

By awoo, history, 2 months ago, In English1772A - A+B? 

Idea: BledDest 

Tutorial1772A - A+B?There are multiple ways to solve this problem. 

Most interpreted languages have some function that takes the string, evaluates it as code, and then returns the result. One of the examples is the eval function in Python. If the language you use supports something like that, you can read the input as a string and use it as the argument of such a function. 

Suppose you use a language where this is impossible. There are still many approaches to this problem. The most straightforward one is to take the first and the last characters of the input string, calculate their ASCII codes, and then subtract the ASCII code of the character 0 from them to get these digits as integers, not as characters. Then you can just add them up and print the result. 

Solution (BledDest)1772B - Matrix Rotation 

Idea: BledDest 

Tutorial1772B - Matrix RotationSure, you can just implement the rotation operation and check all 4 possible ways to rotate the matrix, but it's kinda boring. The model solution does the different thing. 

If a matrix is beautiful, then its minimum is in the upper left corner, and its maximum is in the lower right corner (and vice versa). If you rotate it, the element from the upper left corner goes to the upper right corner, and the element from the lower right corner goes to the lower left corner — so these elements are still in the opposite corners. No matter how many times we rotate a beautiful matrix, its minimum and maximum elements will be in the opposite corners — and the opposite is true as well; if you have a 2×2 matrix with minimum and maximum elements in opposite corners, it can be rotated in such a way that it becomes beautiful. 

So, all we need to check is that the minimum and the maximum elements are in the opposite corners. There are many ways to do it; in my opinion, the most elegant one is to read all four elements in an array of size 4; then the opposite corners of the matrix correspond either to positions 0 and 3, or to positions 1 and 2 in this array. So, we check that the sum of positions of minimum and maximum is exactly 3. 

Solution (BledDest)1772C - Different Differences 

Idea: BledDest 

Tutorial1772C - Different DifferencesWe can transform the problem as follows. Let di=ai+1−ai. We need to find an array [d1,d2,…,dk−1] so that the sum of elements in it is not greater than n−1, all elements are positive integers, and the number of different elements is the maximum possible. 

Suppose we need f different elements in d. What can be the minimum possible sum of elements in d? It's easy to see that d should have the following form: [2,3,4,…,f,1,1,1,…,1]. This array contains exactly f different elements, these different elements are as small as possible (so their sum is as small as possible), and all duplicates are 1's. So, if the sum of this array is not greater than n−1, then it is possible to have the number of different elements in d equal to f. 

The rest is simple. We can iterate on f, find the maximum possible f, construct the difference array, and then use it to construct the array a itself. 

Solution (BledDest)1772D - Absolute Sorting 

Idea: BledDest 

Tutorial1772D - Absolute SortingWhat does it actually mean for an array a1,a2,…,an to be sorted? That means a1≤a2 and a2≤a3 and so on. 

For each pair of adajacent elements, let's deduce which values x put them in the correct order. Any value of x that puts all pairs in the correct order will be the answer. 

Consider any ai and ai+1 and solve the inequality |ai−x|≤|ai+1−x|. If ai=ai+1, then any value of x works. Let ai be smaller than ai+1. 

If x is smaller than or equal to ai, then the inequality becomes ai−x≤ai+1−x⇔ai≤ai+1. Thus, they don't change their order, and any x≤ai works. 

If x is greater than or equal to ai+1, then the inequality becomes x−ai≤x−ai+1⇔ai≥ai+1. Thus, they always change their order, and none of x≥ai work. 

If x is between ai and ai+1, then the inequality becomes x−ai≤ai+1−x⇔2x≤ai+ai+1⇔x≤ai+ai+12. Thus, they only remain in the same order for any integer x such that ai≤x≤⌊ai+ai+12⌋. 

In union, that tells us that all values of x that work for such a pair are x≤⌊ai+ai+12⌋. 

The similar analysis can be applied to ai>ai+1, which results in the required x being x≥⌈ai+ai+12⌉ for such pairs. 

Finally, how to find out if some value of x passes all conditions? Among all conditions of form x≤vali, in order for some x to work, it should be less than or equal to even the smallest of them. Similarly, among all conditions of form x≥vali, in order for some x to work, it should be greater than or equal to even the largest of them. 

Thus, take the minimum over the pairs of one type. Take the maximum over the pairs of another type. If two resulting values are contradictory, then there is no answer. Otherwise, any value inside the resulting range of x works. 

Overall complexity: O(n) per testcase. 

Solution (BledDest)1772E - Permutation Game 

Idea: BledDest 

Tutorial1772E - Permutation GameNote that it makes no sense to use the first type of operation if it does not lead to an instant win, because the opponent can return the previous state of the array with their next move. 

So the winner is the one who has time to color "their" elements in blue first. Let's denote a as the number of elements that only the first player needs to color, b as the number of elements only the second player needs to color, c — both players needs to color. 

To win, the first player needs to have time to paint a+c elements, and they have no more than b moves to do it, because otherwise the second player can prevent the win of the first player. So the winning condition for the first player is a+c≤b. Similarly, for the second player, with the only difference that they have 1 move less (because they go second), which means the condition is b+c<a. If none of these conditions are met, then neither player has a winning strategy, which means they will both reduce the game to a draw. 

Solution (Neon)1772F - Copy of a Copy of a Copy 

Idea: BledDest 

Tutorial1772F - Copy of a Copy of a CopyNotice the following: once you apply the recolor operation to some cell, you can never recolor it again. That happens because you can't recolor its neighbors too as each of them has at least one neighbor of the same color — this cell itself. 

In particular, that implies that applying a recolor operation always decreases the possible number of operations that can be made currently. It doesn't always decrease them by 1: from 1 to 5 operations can become unavailable, but it always decreases. 

That gives us an order of copies. Just sort them in the decreasing order of the number of recolor operations that can be made currently. If the numbers are the same, the copies must be equal, so their order doesn't matter. 

The only thing remains is to apply the operations. Turns out, their order doesn't matter at all. Consider all different cells for a pair of adjacent pictures. It's never possible that there are two different cells that are adjacent to each other. Thus, no operation can interfere with another one. Just print all positions of different cells in any order you want and make a copy. 

Overall complexity: O(nmk+klogk). 

Solution (awoo)1772G - Gaining Rating 

Idea: BledDest 

Tutorial1772G - Gaining RatingAfter parsing the statement, you can understand that Monocarp plays cyclically: in one cycle, he chooses some order of opponents and play with them in that order. Then repeats again and again, until he gains desired rating at some moment. 

So, firstly, let's prove that (in one cycle) it's optimal to play against opponents in increasing order of their skills. Suppose you play with opponents in some order ord and there is a position where a[ordi]>a[ordi+1], if you swap ordi and ordi+1 you won't lose anything and may even gain extra wins. It means that the total gain after playing one cycle in increasing order in greater or equal than playing in any other order. 

In other words, we can sort array a and play against them cyclically in that order. Monocarp's list of games will look like several full cycles and some prefix. The problem is that there can be many cycles, and we need to skip them in a fast way. 

How one cycle looks? Monocarp starts with some x wins first p games and then loses all other games (m games where m=n−p). The maximum rating he gains is x+p and the resulting rating after all games is x+p−m. 

We can already find several conditions of leaving a cycle: if x+p≥y then Monocarp gets what he wants and stops; otherwise, if x+p−m≤x (or p−m≤0) he will never gain the desired rating, since in the next cycle the number of wins p′≤p, since his starting rating x+p−m≤x. 

Otherwise, if x+p<y and p−m>0, he will start one more cycle with rating x′=x+p−m and will gain the desired rating y, eventually. So, how to find the number of games p he will win for a starting rating x? 

Let's calculate two values for a given sorted skill array a: for each i let's calculate ti — the minimum starting rating Monocarp need to win opponent i (and all opponent before) and bi — the rating he'll get after winning the i-th opponent. 

We can calculate these values in one iteration (we'll use 0-indexation): t0=a0, b0=a0+1; then for each i>0 if bi−1≥ai then ti=ti−1 and bi=bi−1+1, otherwise ti=ai−i and bi=ai+1. 

Now, knowing values ti it's easy to find the number of wins p for a starting rating x: p is equal to minimum j such that tj>x (don't forget, 0-indexation). Or the first position in array t with value strictly greater than x. We can search it with standard upper_bound function, since array t is sorted. 

Okay, we found the number of wins p for the current x. Let's just calculate how many cycles k Monocarp will make with exactly p wins. There are only two conditions that should be met in order to break this cycle: either Monocarp reaches rating y — it can be written as inequality x+k(p−m)+p≥y, or the number of wins increases (starting rating becomes greater or equal than tp), i.e. x+k(p−m)≥tp. 

From the first inequality, we get minimum k1=⌈y−x−pp−m⌉ and from the second one — k2=⌈tp−xp−m⌉. As a result, we can claim that Monocarp will repeat the current cycle exactly k=min(k1,k2) times and either finish in the next turn or the number of wins will change. 

So, we can skip these k equal cycles: we can increase answer by kn and current rating by k(p−m). Since we skip equal cycles, then at each step we either finish (with success or −1), or the number of wins p increases. Since p is bounded by n, we will make no more than n skips, and total complexity is O(nlogn) because of initial sorting and calls of upper_bound. 

Solution (adedalic) 

Codeforces Round #838 (Div. 2) Editorial 

By satyam343, 2 months ago, In EnglishThank you for participation! I hope you liked atleast one problem from the set (: 

We tried hard to have an interesting problemset. 

It is sad to see people disliking the round only because some problems were hard. Please read the intended solutions to know why we decided to put the problems(especially D) at current positions. 

1762A - Divide and Conquer 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionWe are assuming initial sum is odd. Suppose f(x)(1≤x≤106) gives the minimum number of operations needed to change parity of x. 

Iterate from i=1 to n and calculate f(ai) for each i. 

Answer is minimum among all the calculated values. 

Time complexity is O(n⋅log(Amax)). 

Code1762B - Make Array Good 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionSuppose f(x) gives the smallest power of 2 which is greater than x. 

Iterate from i=1 to n and change ai to f(ai) by adding f(ai)−ai to i-th element. 

Time complexity is O(n⋅log(Amax)). 

Code1762C - Binary Strings are Fun 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionNow we know how to solve for whole string s. 

We can similarly solve for all prefixes. 

To find f(s[1,i]), we need to find the longest suffix of s[1,i] containing same character. 

We can easily calculate this all prefixes while moving from i=1 to n. 

Time complexity is O(n). 

Code1762D - GCD Queries 

Idea:amurto Prepared by:errorgorn 

Hint 1Hint 2Hint 3SolutionSo suppose we have three distinct indices i, j and k. 

Let us assume l=query(i,k) and r=query(j,k)Now we have only three possibilities. 

l=r In this case, pk cannot be 0. Why? pi and pj are distinct, and we have gcd(0,x)≠gcd(0,y) if x≠yl>r In this case, pj cannot be 0. Why? Note gcd(0,pk)=pk and gcd(m,pk) can be atmost pk for any non negative integer. If l>r, this means r cannot be pk. Thus pr≠0 for surel<r In this case, pi cannot be 0. Why? Refer to the above argument.This we can eliminate one index on using 2 queries. We will perform this operation n−2 times. Refer to attached code for details. 

Time complexity is O(n). 

Code1762E - Tree Sum 

Idea:satyam343 Improved by:TheScrasse 

Hint 1Hint 2Hint 3SolutionTime for one more interesting claim. The weight of edge e is (−1)l if there are l nodes on one side and n−l nodes on other side of e, irrespective of the structure of tree. 

We can prove this claim by induction, similar to what we did in hint 3. 

To find answer we will look at contribution of each edge. 

Here's detailed explanation on how to dot it. 

In total, we have nn−2⋅(n−1) edges. 

Suppose for some edge(say e), we have l nodes(including node 1) on left side and r nodes(including node n) on right side. 

Among nn−2⋅(n−1) edges, how many possibilities do we have for e? 

It is (n−2l−1)⋅l⋅r⋅ll−2⋅rr−2. Why? First we select l−1 nodes(as node 1 is fixed to be on left side) to be on left side, we get (n−2l−1) for this. 

Now we have l nodes on left side and r nodes on right side. Edge e will connect one among l nodes on left and one among r nodes on right. So edge e will exist between l⋅r pairs. We know that number of distinct trees having x nodes is xx−2. 

Now on selecting one node from left and one from right, we have fixed the root of subtree on left side, and have also fixed the root of subtree on right side. So, number of distinct subtrees on left side is ll−2, and number of distinct subtrees on right side is rr−2. 

Thus, on mutliplying all(since they are independent), we get (nl)⋅l⋅r⋅ll−2⋅rr−2 possibilities for e. 

Now this edge lies on the path from 1 to n as both lie on opposite sides of this node. 

So this edge contributes (−1)l⋅(n−2l−1)⋅l⋅r⋅ll−2⋅rr−2 to answer. 

Hence d(1,n)=∑n−1l=1(−1)l⋅(n−2l−1)⋅l⋅r⋅ll−2⋅rr−2 where l+r=n. Note that we assumed that we are always going from left subtree to right subtree while calculating contribution. As we have tried all possibilties for l, all cases get covered. We used left and right subtrees just for our own convention. 

Time complexity is O(n⋅log(n)). 

Code1762F - Good Pairs 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionHow to prove the claim in hint 3? 

Suppose we have a good pair (l,r) such that al≠ar. Now using exchange arguments we can claim that there always exists a sequence(say s) starting at index l and ending at index rsuch that difference between adjacent elements of a is atmost kstrictly increasing if al<arstrictly decreasing if al>arThus (l,r) will be counted in F(a,k) if al<ar and (l,r) will be counted in F(rev(a),k) if al>ar. 

Time complexity is O(n⋅log(n)). 

Code1762G - Unequal Adjacent Elements 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionLet us continue from where we left off. 

So our motivation is to break the original array into multiple beautiful subarrays and the elements in those subarrays, as mentioned before. Now for condition 1 to be satisfied, we should not have two adjacent subarrays such that the elements at the end positions of both subarrays(after rearranging the elements) are the same. 

Here is one construction using which we can achieve our goal. 

Suppose l denotes the leftmost point of our concerned subarray. 

If al≠al+1, we move forward, as subarray a[l,l] is good. 

Otherwise, we keep moving towards the right till index r(here, r should be the smallest possible) such that the subarray a[l,r] is beautiful and al≠ar+1. So it is easy to notice the following observations about the subarray a[l,r]length of this subarray is odd 

al occurs exactly ⌈r−l+12⌉ times in this subarray 

Now we can rearrange the elements of this subarray a[l,r]. 

Do note that the subarray a[1,r] satisfies both the conditions stated in the statement. 

So our task is to make the subarray a[r+1,n] good now. 

We can now update l=r+1 and continue searching for the corresponding r and so on. 

Now it might be the case that we did not get a valid r for the last search. 

From here, I assume we did not get valid r for the last search. We could print the obtained permutation if we got it, as a would satisfy both conditions. 

Assume that we had started at pos=l and couldn't find r. 

Subarray a[1,pos−1] is already good. 

To fix this issue, we will do a similar search that we did before. 

We start from the back(from index n) and move towards left till index m such that 

m<posa[m,n] is beautifulapos occurs exactly ⌈n−m+12⌉ times in this subarrayapos≠am−1Now we arrange elements of this subarray in the same fashion that we did before. 

Are we done? 

No. First, we must prove that we will always get some m. 

Let us have function f(a,l,r,x), which denotes the score of the subarray a[l,r] for the element x. f(a,l,r,x)=freqx−(r−l+1−freqx), where freqx denotes the frequency of element x in the subarray a[l,r] 

It is easy to note that f(a,pos,n,apos)>1 

(Hint — Prove that f(a,pos,r,apos)≠0 for pos≤r≤n. Why?(If it does then a[pos,r−1] would be beautiful )) 

Now we start from the back and move towards the right to find m with n as our right endpoint of the concerned subarray. 

Note that f(a,1,n,apos)≤1 (Why? apos would have occurred at most ⌈n2⌉ times in a) 

So while moving from pos to 1 we will indeed find a m such that f(a,m,n,apos)=1, and am−1≠apos (assuming a0=−1) 

Are we done? 

Not still :p. We can observe that condition 1 is satisfied, but sometimes condition 2 would not be. For example, simulate the above approach on the array a=[1,1,2,3,3]. 

How to fix this issue? It's pretty easy to fix this issue. 

HintYou can refer to the attached code for implementation details. 

Code 

Codeforces Round #837 (Div. 2) Editorial 

By 4qqqq, history, 2 months ago, In EnglishWe apologize for the delay in editorial of the tasks. 

A. Hossam and Combinatorics 

Idea: _HossamYehia_ 

Tutorial1771A - Hossam and CombinatoricsFirstly, let's find max1≤p,q≤n|ap−aq|=max(a)−min(a)if it's equal to zero, then any pair is valid, so answer if n⋅(n−1)Otherwise, let's calculate count_min and count_max. Answer is 2⋅count_min⋅count_maxSolution(_HossamYehia_)B. Hossam and Friends 

Idea: _HossamYehia_ 

Tutorial1771B - Hossam and FriendsJust ai<bi in non-friends pairs. Let's calculate ri= minimum non-friend for all people. So, we can't start subsegment in ai and finish it righter ri. 

Let's process people from right to left and calculate the rightmost positions there subsegment can end. Initially, R=n−1. Then we go to ai just do R=min(R,ri) and add R−i+1 to answer. 

Solution(_HossamYehia_)C. Hossam and Trainees 

Idea: _HossamYehia_ 

Tutorial1771C - Hossam and TraineesIf exists x≥2 such that ai divides x and aj divides x then exists prime number p such that ai and aj divides p. We can choose p= any prime divisor of x. 

So, let's factorize all numbers and check, if two of them divides one prime number. We can use default factorization, and it will be O(n⋅A−−√). It's too long, so just calculate prime numbers ≤A−−√ and check if ai divides this numbers. It will be O(n⋅A√logA) - fast enouth. 

Solution(_HossamYehia_)D. Hossam and (sub-)palindromic tree 

Idea: 4qqqq 

Tutorial1771D - Hossam and (sub-)palindromic treeLet's use dynamic programming method. Let dpv,u as length of the longest maximal sub-palindrome on the path between vertexes v and u. Then the answer to the problem is max1≤v,u≤ndpv,u. 

Define gov,u (v≠u) vertex x such that it is on way between v and u and distance between v and x is 1. If v=u, then we put gov,u equal to v. 

So, there are three cases: 

The answer for (v,u) equals to the answer for (gov,u,u);The answer for (v,u) equals to the answer for (v,gou,v);If sv=su, then the answer for (v,u) equals to the answer for (gov,u,gou,v)+2. In this case we took best sub-palindrome strictly inside the path v,u and added to it two same symbols in v and u.Formally , the transitions in dynamics will look like this: 

dpv,u:=max(dpv,gou,v,dpgov,u,u,dpgov,u,gou,v+2⋅(sv=su)).Dynamic's base:dpv,v:=1,dpv,w:=1+(sv=sw),for v,w, such that distance between them equals to one. 

In order to calculate the values in dp, you need to iterate through pairs of vertices in ascending order of the distance between the vertices in the pair (note that this can be done by counting sort). 

The question remains: how to calculate the array go? Let's iterate all vertexes and let the current vertex is v. Let v be the root of the tree. Consider all sons of this vertex. Let current son is x. Then for all u from subtree of x the value of gov,u will be number of x. 

Thus, time and memory complexity of this solution is O(n2). 

Solution(4qqqq)E. Hossam and a Letter 

Idea: _HossamYehia_ 

Tutorial1771E - Hossam and a LetterLet's preprocess the following data for each cell. 

1. first medium cell above current cell. 2. first medium cell below current cell. 3. first bad cell above current cell. 4. first bad cell below current cell. 

Then we will try to solve the problem for each row (i), and 2 columns (j, k). 

Now we have a horizontal line in row (i), and we can calculate the length of vertical line by the following. 

There is two cases: 

In case of the horizontal line contains one letter 'm'. 

For each column (j, k): get first cell above it the don't contain ('#' or 'm') and first cell below it the don't contain ('#' or 'm'). 

In case of the horizontal line doesn't contain any letter 'm'. 

We will try to get the 4 cells as it contains letter 'm', but in this case we will 4 trials. 

for each cell from the 4 cells, we allow to have only one letter 'm' in that line. 

After getting above cells and below cells for each line. the starting cell will be the maximum between the two above cells, and the ending cell will be the minimum between the two below cells. 

Then we need to check that starting cell is above the current row (i) to avoid making letter n instead of H 

And check that ending cell is below the current row (i) to avoid making letter u instead of H. 

Since n, m has the same maximum limit 400. 

Thus, time complexity of this solution is O(n3). 

Solution(_HossamYehia_)F. Hossam and Range Minimum Query 

Idea: 4qqqq 

Tutorial1771F - Hossam and Range Minimum QueryNote that we were asked to solve the problem in online mode. If this were not the case, then the Mo Algorithm could be used. 

How to solve this task in online mode? Consider two ways. 

The first way is as follows. Let's build a persistent bitwise trie T on a given array, where the i-th version of the trie will store numbers x such that x occurs on the subsegment a[1…i] an odd number of times. 

This can be done as follows. Let T0 be an empty trie, and Ti will be obtained as follows: first we assign Ti=Ti−1; then, if ai occurs in Ti−1, then we will erase the number ai from Ti, otherwise we will insert it there. 

Suppose we need to get answer on the query [l,r]. Note that if x is included in Tr, but is not included in Tl−1 (or is included in Tl−1, but is not included in Tr), then this means that the number x on the segment a[l…r] occurs an odd number of times. Otherwise, the number x occurs an even number of times (recall that 0 is an even number). Thus, we need to find a minimum number x such that it occurs either in Tl−1 or in Tr, but not in both at once. If there is no such number, then you need to output 0. 

Let's go down Tl−1 and Tr in parallel on the same prefix of the number. If Tl−1 and Tr are equal, then the same numbers are contained there, and then the answer is 0. Next, we will assume that the answer is not 0. The left subtree of the vertex is the son to whom the transition along the edge of 0 is going, and the right subtree is the vertex to which the transition along the edge of 1 is going. Let us now stand at the vertices v and u, respectively. If the left subtrees of v and u are equal, it means that the same numbers are contained there, so there is no point in going there, so we go along the right edge. Otherwise, the left subtree of v contains at least one number that is not in the left subtree of u (or vice versa), so we will go down the left edge. The number in which we ended up will be the answer. 

Note that in order to compare two subtrees for equality, you need to use the hashing technique of root trees. Then we can compare the two subtree for O(1). 

Thus, we get the asymptotics O((n+q)logmax(a)). If we compress the numbers of the sequence a in advance, then we can get the asymptotics of O((n+q)logn). 

Let's consider the second way. Let's compress the numbers in the sequence a in advance. Let prefij=0 if the prefix i contains the number aj an even number of times, and prefij=1 if the prefix i contains the number aj an odd number of times. 

Then, in order to get an answer to the query [l…r], we need to take the "bitwise exclusive OR" arrays prefl−1 and prefr and find in it the minimum j such that prefij=1. The number j will be the answer. 

Obviously, now this solution need much time and memory. 

In order to optimize the amount of memory consumed, we will use bitsets. However, even in this case, we consume memory of the order of o(h2/64), which is still a lot. So let's not remember about all prefi, but only some. For example, let's get some constant k and remeber only about pref0,prefk,pref2k,\dataprefpk. 

Then, when we need to answer the next query [l…r], we will find the right block on which we store almost all the numbers we are looking for, and then we will insert/erase for O(k) missing numbers. 

If you select k∼n−−√, then this solution will fit in memory. However, if you use std::bitset<> in C++, then most likely this solution will still receive the verdict Time Limit. Therefore, to solve this problem, you need to write your own fast bitset. 

The asymptotics of such a solution would be O(n(n+q)/64). However, due to a well-chosen k and a self-written bitset, the constant in this solution will be very small and under given constraints, such a solution can work even faster than the first one. 

Solution(4qqqq, trie)Solution(Aleks5d, bitset) 

Codeforces Round #836 (Div. 2) Editorial 

By ScarletS, 3 months ago, In EnglishThank you for participating in our contest! We hope you enjoyed it. Implementations will be added soon (when Codeforces lets authors submit solutions!). 

Please let us know what you thought of the problems by voting! 

1758A - SSeeeeiinngg DDoouubbllee 

HintSolution1758A - SSeeeeiinngg DDoouubblleeOutput s+reverse(s). 

It works, since each character in s occurs exactly twice (once in s, once in reverse(s)), and the result is a palindrome. 

Implementation (C++)Implementation (Java)Implementation (Python)Feedback1758B - XOR = Average 

HintSolution1758B - XOR = AverageLet us consider the cases when n is odd and when its even. 

n is odd: We can see that printing 1,…,1n times will lead to an average of 1 and an XOR of 1 (since 1⊕1=0). Similarly, you could print any integer n times to pass this case.n is even: We use a slight modification of the solution for odd n here. Instead of printing the same number n times, we print 1,3,2,…,2n−2 times. Both the XOR and the average of 1 and 3 are 2. Therefore the average of the total sequence remains 2, and the XOR of the whole sequence is also 2.Note that there are other possible solutions, but the simplest one is described here. 

Implementation (C++)Implementation (Java)Implementation (Python)Video EditorialFeedback1758C - Almost All Multiples 

HintSolution1758C - Almost All MultiplesWe start by giving the answer for n=12, k=2:[2,4,3,12,5,6,7,8,9,10,11,1]and for n=12, k=3:[3,2,6,4,5,12,7,8,9,10,11,1].As you can see, the array is almost the identity permutation, with certain elements rotated to the left. In particular, these are the elements that you get when you find the longest sequence ai such that x∣a1∣a2∣⋯∣n (recall a∣b means a divides b). For example, 3∣6∣12 and 2∣4∣12. To find this longest sequence, you need to prime factorize nx. The complexity is O(nlogn). 

The main idea is intuitive, but the proof is rather long. We include it below. 

The idea is to look at cycles in the permutation. Consider any cycle of length greater than 1, say c1,c2,…,ck (that is, pc1=c2, pc2=c3,…,pck=c1). We claim that for at least one element ci of the cycle, pci is not a multiple of ci. 

In fact, we'll show a more general claim: for one element of the cycle pci<ci, which implies that pci cannot be a multiple of ci. Indeed, let's sum pci−ci over all elements of the cycle. This sum is 0, because each element appears once before the − sign and once afterwards. Since none of these equal 0, it follows that at least one of these terms is negative (and at least one is positive). If pci−ci<0, then pci<ci, as desired. 

So in each cycle, we must have at least one element breaking the key claim in the problem. But this claim holds for all 1≤i≤n−1, so the only cycle we can have goes through pn! Indeed, since pn=1 and p1=x, the cycle goes n→1→x→⋯→n. For all arrows except the first one, we a∣b to write a→b, because only pn can break the condition. Since we want the permutation to be lexicographically minimal, we want the longest such chain. 

So we should find the longest sequence of numbers from x to n, such that each number divides the previous. If there are multiple such sequences, we need to pick the one that puts smaller numbers earlier, since we want smaller elements earlier on in the sequence. To do this, we can just find the prime factorization of nx (it is the longest, since the primes cannot be broken up into smaller factors), sort it, and cycle it. 

Implementation (C++)Implementation (Java)Implementation (Python)Video EditorialFeedback1758D - Range = √Sum 

HintSolution1758D - Range = √SumLet us consider the cases when n is odd and when its even. 

n is odd: First, we can start with the n consecutive distinct numbers centered at n. The minimum-maximum difference is n−1, and the sum is n2. If we add 2 to each number, the minimum-maximum difference remains the same, and the sum increases to n2+2n.Now, we can decrease the minimum by 1 and the increase the maximum by 1. The sum remains at n2+2n, while the difference increases to n+1. To make the sum equal (n+1)2=n2+2n+1, we can increase the 2nd last number by 1, which we can do since we previously increased the maximum by 1. 

As an example, this sequence is followed for n=5: 

[3, 4, 5, 6, 7] (centered at 5)[5, 6, 7, 8, 9] (increase by 2)[4, 6, 7, 8, 10] (shift min/max)[4, 6, 7, 9, 10] (shift 2nd last)n is even: We can let [a1,…,an]=[n/2,n/2+1,…,n−1,n+1,…,3n/2]. The difference between the minimum and maximum is n, and the sum of the numbers equals n2, so this is valid.Other solutions exist, only one is described here. 

Implementation (C++)Implementation (Java)Implementation (Python)Video EditorialFeedback1758E - Tick, Tock 

HintSolution1758E - Tick, TockNotice that a relationship between two clocks with assigned values on the grid on different rows but the same column, that is, gx,z and gy,z, can be represented as gy,z≡gx,z+d(modh), where 0≤d<h. Now, for every 1≤i≤m, gy,i≡gx,i+d(modh). Using these relationships, we can create a weighted directed graph using our rows as nodes. 

Obviously, no solutions exist if there are discrepancies in the graph (modh), no solution exists. Now, for each connected component, if there is an assigned value in one of the rows it contains, we can determine all of the other values for that column in the connected component. We can merge different connected components i,j by choosing a common difference di,j for these components. This needs to be done (connected components - 1) times, and there are h different ways to choose a common difference when combining different components, resulting in hconnected components−1 different ways to combine all components into one connected component. 

This leaves us with columns that are fully empty, i.e., they consist only of unassigned clocks. As all rows are in one connected component at this point, assigning a clock in one empty column results in all other clocks in that column becoming assigned values too. There are hempty columns different ways to assign clocks to these empty columns. 

Thus, overall, our solution is hconnected components+empty columns−1. 

Implementation (C++)Implementation (Java)Implementation (Python)Feedback1758F - Decent Division 

HintSolution1758F - Decent DivisionAfter each update, we want to maintain the invariant that each interval is balanced, and additionally that there is a gap containing at least one zero in between each pair of consecutive intervals. Since every 1 must be contained in an interval, this is equivalent to having non-empty gaps between consecutive intervals after an update. 

There are several cases we need to handle. 

Case 1: Bit ai is changed from 0 to 1.Case 1a: Bit ai is contained in an interval after the previous updateIf we are inside an interval, then we want to grow the interval that contains it by 2 zeros to maintain balance. If the interval containing ai is [l,r], then we can expand it to [l,r+1]. Since there is at least one 0 after each interval, ar+1=0, so this contains one of the two zeroes we need. 

If there is another interval r+2∈[l′,r′], then increasing the right bound again by 1 would overlap with this interval. In this case, We know that ar′+1=0 as well, so we can merge both intervals together into [l,r′+1] to get a total of two new zeros. [l′,r′] was also previously balanced, so the interval is still balanced. In this case, we removed two intervals and added one interval, so a total of three operations were used. 

If there is no intervals where r+2∈[l′,r′], then ar+2=0, so we can simply expand the current interval once more to [l,r+2]. One interval was removed and one interval was added, so a total of two operations were used. 

Case 1b: Bit ai is not contained in an interval.If there exists an interval where i+1∈[i+1,r], then we can expand it to [k,r+1]. This interval is directly after ai, so expanding it by one to the left will include an extra 1. ar+1=0 since it is part of the gap between two intervals, so including it balances ai. One interval was removed and one interval was added, so a total of two operations were used. 

If there is no interval where i+1∈[i+1,r], then ai+1=0. Therefore, we can simply add [i,i+1], which is balanced. One interval was added, so a total of one operation was used. 

In both cases, after adding a new interval to the set, we can merge with any adjacent intervals to the left or right. This will maintain the invariant that there is a gap between consecutive ranges as mentioned earlier. We merge at most once to the left and one to the right. Since the maximum number of operations done earlier is 3, the maximum number of operations in total is 5 in this case. 

Case 2: Bit ai is changed from 1 to 0.Suppose that i∈[l,r]. In this case, we want to somehow split the interval into two balanced portions. Now, suppose we compute the prefix sums of the balance, where 0 corresponds to −1 and 1 corresponds to +1. If x is the first location where the prefix sum equals −2, then we claim that we can split the interval into [l,x−2] and [x+1,r]. 

To prove this, note that the balance of the empty prefix is 0, so before the prefix sum equals −2 for the first time, it must have gone ...,0,−1,−2. To have two decreases in a row, we must have ax−1=ax=0. In the interval [l,x−2], the final balance prefix sum is 0, so the first interval is balanced. Since we changed a 1 to a 1 and removed two 0s, the first interval being balanced implies that the second interval is balanced as well. In addition, since the original interval satisfied the separation invariant, and the new intervals are separated by two 0s, the separation invariant is still satisfied. 

To compute the first time when the balance prefix sum equals -2, we can use binary search on the interval using a lazy segment tree. The segment tree represents a global balance prefix sum, and we can range query the minimum balance on an interval. We can binary search for the lowest index on the interval where the minimum prefix sum is less than -2. 

In this case, we removed one interval and added two new intervals, for a total of three operations. 

In both cases, we use at most 5 operations in a single step, so we in total use at most 5n operations, which fits in our bound. In practice, this upper bound is quite loose. 

Because of the binary search on the lazy segment tree, the time complexity for this solution is O(nlog2n). Note that this can be optimized to O(nlogn) by optimizing the binary search, but this was not required. 

Implementation (C++)Implementation (Python)Feedback 

Codeforces Round #835 (Div. 4) Editorial 

By flamestorm, 3 months ago, In EnglishWe hope you enjoyed the contest! Sorry for the late editorial. 

1760A - Medium Number 

Idea: flamestorm 

Tutorial1760A - Medium NumberHere are two ways to implement what's given in the problem: 

Take input as an array [a1,a2,a3], and sort it. Output the middle element.Write two if-statements. The first: if (a>b and a<c) or (a<b and a>c), output a. Else, if (b>a and b<c) or (b<a and b>c), output b. Else, output c.Solution1760B - Atilla's Favorite Problem 

Idea: SlavicG 

Tutorial1760B - Atilla's Favorite ProblemTo solve the problem we need to find the character with the highest alphabetical order in our string, since Atilla will need at least that alphabet size and won't need more. To do this iterate through the string and find the character with the highest alphabetical order. Output the maximum alphabetical order found. The solution can be done in O(n).Solution1760C - Advantage 

Idea: Errichto 

Tutorial1760C - AdvantageMake a copy of the array s: call it t. Sort t in non-decreasing order, so that t1 is the maximum strength and t2 — the second maximum strength. 

Then for everyone but the best person, they should compare with the best person who has strength t1. So for all i such that si≠t1, we should output si−t1. Otherwise, output si−t2 — the second highest strength, which is the next best person. 

Solution1760D - Challenging Valleys 

Idea: mesanu 

Tutorial1760D - Challenging ValleysOne possible solution is to represent a range of equal element as a single element with that value. Construct this array b and loop through it and check how many element bi satisfy the conditions i=0 or bi−1<bi and i=n−1 or bi>bi+1. If exactly one index satisfies these conditions, print "YES" and othewise "NO". 

Complexity: O(n)Solution1760E - Binary Inversions 

Idea: SlavicG 

Tutorial1760E - Binary InversionsLet's find out how to count the number of binary inversions, without flips. This is the number of 1s that appear before a 0. To do this, iterate through the array and keep a running total k of the number of 1s seen so far. When we see a 0, increase the total inversion count by k, since this 0 makes k inversions: one for each of the 1s before it. 

Now let's see how to maximize the inversions. Consider the flip 0→1. We claim that it is best to always flip the earliest 0 in the array. It's never optimal to flip a later 0, since we have strictly fewer 0s after it to form inversions. Similarly, we should flip the latest 1 in the array. 

Now recalculate the answer for these two choices for flipping, and pick the maximum. The complexity is O(n). 

Solution1760F - Quests 

Idea: flamestorm 

Tutorial1760F - QuestsLet's fix k and find the maximum number of coins we can get. Here we can do a greedy solution: at every step, we should always take the most rewarding quest. (Intuitively, it makes sense, since doing more rewarding quests earlier allows us to do them again later.) If no quests are available, we do nothing. 

To implement this, sort the quests in decreasing order, and 0-index them. On day i we should do quest imodk, provided that this value is less than n. This is because after every k days, we cycle back to the first quest. Thus we solved the problem for a fixed k in O(d) with O(nlogn) precomputation to sort the array. 

Now to solve the problem, we can binary search on the answer, since if some k works, then all smaller k work. The minimum value of k is 0, and the maximum value is n (for larger k, we won't be able to do the same quest multiple times anyways, so it's useless to consider them). 

If we find that k always goes towards the smaller end of our binary search and k=0 still fails, we output Impossible. If we find that k always goes towards the larger end of our binary search and k=n still fails, we output Infinity. Otherwise, just output k. 

The overall time complexity is O(nlogn+dlogn). 

Remark. It is not hard to improve the solution to O(nlogn). Originally, I proposed the problem this way, but we ended up removing this part of the problem because the implementation of this solution was tricky enough. 

Solution1760G - SlavicG's Favorite Problem 

Idea: SlavicG 

Tutorial1760G - SlavicG's Favorite ProblemLet's ignore the teleporting, and decide how to find the answer. Note that we don't need to ever go over an edge more than once, since going over an edge twice cancels out (since a XOR a=0 for all a). In other words, the only possible value of x equals the XOR of the edges on the unique path from a to b. We can find it through a BFS from a, continuing to keep track of XORs as we move to each adjacent node, and XORing it by the weight of the corresponding edge as we travel across it. 

Now let's include the teleport. It means that we travel from a→c, then teleport to d, and go from d→b, for some nodes c and d. Also, we cannot pass b on the path from a→c. 

Again, note that the value of x is fixed on each of the paths from a→c and d→b, since there is a unique path between them. Let x1 be the XOR of the first path and x2 be the XOR of the second. Then we need x1 XOR x2=0⟹x1=x2. So we need to find if there are two nodes c, d such that the XORs from a and b to those nodes are the same. To do this, we can do our BFS from before, but instead run one BFS from a and another from b, and check if any two values are the same. 

Make sure not to include nodes past b while we look for c on our BFS from a. 

The time complexity is O(nlogn). 

Solution 

Codeforces Round #834 (Div. 3) Editorial 

By Vladosiya, history, 3 months ago, translation, In English1759A - Yes-Yes? 

Idea: MikeMirzayanov 

Tutorial1759A - Yes-Yes?Note that it is enough to consider the string full=YesYes...Yes, where Yes is written 18 times, since 18⋅3=54, and our substring s has size |s|≤50. 

Then we just use the built-in function find to find out if our string s is a substring of the string full. 

Solution1759B - Lost Permutation 

Idea: MikeMirzayanov 

Tutorial1759B - Lost PermutationLet us add to s the sum of the elements of the array b and try to find a suitable permutation. To do this, greedily add elements 1,2,…,cnt until their sum is less than s. And at the end we will check that the sum has matched. 

Also check that the maximal element from b: max(b)≤cnt, and that the total elements in b: n≤cnt. 

Solution1759C - Thermostat 

Idea: Vladosiya 

Tutorial1759C - ThermostatFirst let's consider the cases when the answer exists: 

If a=b, then the thermostat is already set up and the answer is 0.else if |a−b|≥x, then it is enough to reconfigure the thermostat in 1 operation.else if exist such temperature c, that |a−c|≥x and |b−c|≥x, then you can configure the thermostat in 2 operations. If such c exists between l and r, we can chose one of bounds: a→l→b or a→r→b.we need to make 3 operations if times if we cannot reconfigure through one of the boundaries as above, but we can through both: a→l→r→b or a→r→l→bIf we can't get the temperature b in one of these ways, the answer is −1. 

Solution1759D - Make It Round 

Idea: MikeMirzayanov 

Tutorial1759D - Make It RoundThe answer is n⋅k. 

First, count two numbers: cnt2,cnt5 which denote the degree of occurrence of 2 and 5 in the number n respectively, that is n=2cnt2⋅5cnt5⋅d. Where d is not divisible by either 2 or 5. Now while cnt2≠cnt5 we will increase the corresponding value. For example, if cnt2<cnt5, then as long as cnt2≠cnt5 and at that k⋅2≤m we will increase cnt2 by 1 and multiply k by 2 times. 

That way we can get the most round number possible by spending the least possible k. 

Now we either have cnt2=cnt5, or k⋅5>m or k⋅2>m. Then in the first case, we will multiply the number k by 10 as long as we can. That is, until k⋅10≤m. 

Now in either case we have: k⋅10>m. Then ⌊mk⌋=x<10. Then we multiply k by x times and get our desired answer. 

In the last step, we can no longer get a rounder number, but just find the maximal possible number. 

Solution1759E - The Humanoid 

Idea: Gornak40 

Tutorial1759E - The HumanoidLet's make two obvious remarks: 

If we can absorb two astronauts with power x≤y, then we can always first absorb an astronaut with power x, and then an astronaut with power y;If we can absorb some astronaut, it is effective for us to do it right now.Let's sort the astronauts powers in increasing order. 

Now let's lock the sequence of serums we use. There are only three of them: blue serum can be the first, second or third. 

Let's absorb the astronauts in increasing order of their powers, and if we can't, then use the next serum in a locked sequence or stop. 

This solution works for O(n). 

Solution1759F - All Possible Digits 

Idea: DmitriyOwlet 

Tutorial1759F - All Possible DigitsIf all digits from 0 to p−1 are initially present in the number, then the answer is 0. 

Each time we will increase the number by 1. If the last digit is less than p−1, then only it will change. Otherwise, all digits equal to p−1 at the end will become equal to 0, and the previous one will increase by 1 (or a new digit equal to 1 will be added if all digits were equal to p−1). 

For a p−1 operation, the last digit will run through all possible values. However, we can get all the numbers earlier. We will solve the problem using binary search, sorting through the number of operations. 

We can have 2 options: whether 0 was at the end or not. Depending on this, one or two subsegments of the segment [0,p−1] — a subsegment in the middle or a prefix and a suffix remained uncovered by the last digit of the number. They need to be completely covered with numbers that were already in positions, except for the last one — these are the original numbers and, in case there was 0 at the end, the number into which the transfer was made. There are at most n+1 of them. 

Solution1759G - Restore the Permutation 

Idea: MikeMirzayanov 

Tutorial1759G - Restore the PermutationFirst, let's check the b array for correctness, that is, that it has no repeating elements. 

Then let's look at the following ideas: 

each number bi must be paired with another permutation element pj, with pj<bi by the definition of array b. Then, since we want a lexicographically minimal permutation, it is always more advantageous to put element pj before bi.for the permutation to be lexicographically minimal, the smallest possible numbers must be placed at the beginning. Consequently, the largest numbers must be placed at the end.Let's proceed as follows: 

Let's select the set of unused numbers that are not included in the b array.For an element bn2, find the maximum number k of the set unused such that bn2>k and put that number in front of the element bn2.moving from the end of the array to its beginning, each element bi will be matched with such an element. If at some point k can not be matched — array b is not composed correctly, and the answer to the query — "NO".Otherwise, print "YES" and the resulting permutation p.Solution 

Codeforces Round #833 (Div. 2) Editorial 

By Gheal, history, 4 months ago, In EnglishA — The Ultimate SquareAuthor: Gheal 

HintsSolutionIf n is odd, let k=n+12 be the width of the last block. It is possible to create a square of side length k using every block as follows: 

Line 1 contains a 1×k block;Line 2 contains a 1×1 block and a 1×(k−1) block;Line 3 contains a 1×2 block and a 1×(k−2) block;…Line i contains a 1×(i−1) block and a 1×(k−i+1) block;…Line k contains a 1×(k−1) block and a 1×1 block.Since the area of this square is k2, and the n+1-th block has a width of k tiles, the total area of the first n+1 blocks is equal to k2+k<(k+1)2. Therefore, the answer for n+1 is also k. 

In conclusion, the answer for each testcase is ⌊n+12⌋. 

Time complexity per testcase: O(1). 

Code (C++)Rate ProblemB — Balanced SubstringsAuthor: Gheal 

HintsSolutionIn a diverse string, there are at most 10 distinct characters: '0', '1', …, '9'. Therefore, each of these characters can appear at most 10 times in a diverse string. 

With all this in mind, the maximum possible length of a diverse string is 102=100. To solve this problem, we only need to check whether each substring of length l≤100 is diverse. 

Time complexity per testcase: O(n⋅102)Code(C++)Rate problemC — Zero Sum PrefixesIdea: Gheal, Solution: IgorI 

HintsSolutionLet's consider the prefix sum array s=[a1,a1+a2,…,a1+a2+…+an]. 

For every index i such that ai=0, if we change the value of ai to x, then every element from the suffix [si,si+1,…,sn] will be increased by x. Therefore, if ai1=ai2=…=aik=0, we'll partition array s into multiple subarrays: 

[s1,s2,…,si1−1];[si1,si1+1,…,si2−1];[si2,si2+1,…,si3−1];…[sik,sik+1,…,sn];Since none of the elements from the first subarray can be changed, it will contribute with the number of occurences of 0 in [s1,s2,…,si1−1] towards the final answer. 

For each of the other subarrays [sl,sl+1,…,sr], let x be the most frequent element in the subarray, appearing fr[x] times. Since al=0, we can change the value of al to −x. In this case, every x in this subarray will become equal to 0, and our current subarray will contribute with fr[x] towards the final answer. 

Time complexity per testcase: O(NlogN)Code(C++)Rate problemD — ConstructORAuthor: Gheal 

HintsSolutionLet k=lsb(d), where lsb(d) represents the least significant bit of d. 

Since a|x and b|x are multiples of d, the last k bits of a and b (and also x) must be equal to 0. 

Otherwise, there are no solutions and we can print −1. 

To simplify the construction process, we will try to find some x such that a|x=b|x=x. Since we already know that the last k bits of a, b and x are 0, we will consider that the other 30−k of the 30 least significant bits of x are equal to 1: 

x(2)=p 1 1 1 … 1 0 0 … 0This gives the following general formula for x: 

x=2k⋅(p⋅230−k+(230−k−1))Now, we'll try to find some p for which x is a multiple of d=2k⋅d′: 

x=2k⋅(p⋅230−k+(230−k−1)≡0mod2k⋅d′⇔⇔(p⋅230−k+(230−k−1)≡0modd′⇔⇔(p+1)⋅230−k≡1modd′⇔⇔p+1≡2k−30modd′⇔⇔p+1≡(2−1)30−kmodd′⇔⇔p+1≡(d′+12)30−kmodd′⇒⇒p=((d′+12)30−k+d′−1)modd′Time complexity per testcase: O(logd)Note that if a|b is already a multiple of d, we can consider x=a|b. 

Code(C++)Rate problemE — Yet Another Array Counting ProblemAuthor: Gheal 

HintsSolutionLet f(i,j) be the position of the leftmost maximum in the interval (i;j), 1≤i≤j≤n. 

Let's consider an interval (l;r) such that f(l,r)=m. For the sake of simplicity, let's assume that l<m<r. 

Let p=f(l,m−1) and p2=f(m+1,r). Since am is the leftmost maximum in (l;r), p<m and p2>m, the following conditions must hold for array b: 

bm>bpbm≥bp2Let's consider a binary tree where the children of node u=f(l,r) are nodes p=f(l,u−1) and p2=f(u+1,r), for every 1≤u≤n. 

Note that if u=l, f(l,l−1) is not defined, and, as such, node u will have no left child. Similarly, if u=r, then node u will have no right child. 

Let dp[u][x] be equal to the number of ways to assign values to every element bv from the subtree rooted in u, if bu=x. 

If u has a left child and x=1, then dp[u][x]=0;Otherwise, if u has two children, then dp[u][x]=(∑x−1i=1dp[p][i])⋅(∑xi=1dp[p2][i]);If u only has a left child, then dp[u][x]=∑x−1i=1dp[p][i];If u only has a right child, then dp[u][x]=∑xi=1dp[p2][i];If u has no children, then dp[u][x]=1.To optimise the transitions, we'll also need to compute sum[u][x]=∑xi=1dp[u][x] alongside our normal dp. 

Intended time complexity per testcase: O(n⋅m+n⋅log(n))Additional implementation detailsCode(C++)Rate problemF — Circular Xor ReversalIdea: Gheal, Solution: IgorI 

HintsSolutionIf m=dist(i,j)=((j+n−i)modn), m>0 and bk=a(i+k)modn, let f(i,j) be a sequence of operations that performs: 

b0=b0⊕bm−1;b1=b1⊕bm−2;b2=b2⊕bm−3;…b⌊m−12⌋=b⌊m−12⌋⊕b⌊m+22⌋If n is even, we can reverse array a by performing f(0,n−1), f(n2,n2−1) and f(0,n−1), in this order. 

Otherwise, if n is odd, we can perform f(0,n−1), f(n+12,n−32) and f(0,n−1), in this order. 

One possible way to construct f(i,j) is as follows: 

Perform an operation on every i from m−1 to 0:⇒b=[(0..m),(1..m),(2..m)…,(i..m),…,bm]Perform an operation on every i from 1 to m−1:⇒b=[(0..m),b1,b2,…,bi,…,bm]Perform an operation on every i from m−2 to 1:⇒b=[(0..m),(1..m−1),(2..m−1),…,(i..m−1),…,bm−1,bm]Perform an operation on every i from 2 to m−2:⇒b=[(0..m),(1..m−1),b2,b3,…,bi,…,bm−1,bm]…⇒b=[(0..m),(1..m−1),(2..m−2),…,(i..m−i),(⌊m−12⌋..⌊m+22⌋),b⌊m+12⌋,…,bj,bm−1]The last step is to perform an operation on every i from 0 to ⌊m−22⌋:⇒b=[a0⊕am,a1⊕am−1,…,ai⊕am−i,…,b⌊m−12⌋⊕b⌊m+22⌋,b⌊m+12⌋,…,bj,…,bm]Here, (l..r) denotes bl⊕bl+1⊕…⊕br. 

The number of operations needed for f(i,j) is equal to m+(m−1)+…+1+(m2)=m⋅(m+1)2+m2=m2+2⋅m2, therefore the total number of operations needed to reverse the array is 32⋅(m2+2⋅m). Since m≤n−1, 32⋅(m2+2⋅m)≤32⋅(3992+2⋅399)<250000. 

Time complexity per testcase: O(N2)Code(C++)Rate problemIf there is anything wrong or unclear in this editorial, feel free to ping me in the comments. 

Codeforces Round #832 (Div. 2) Editorial 

By rivalq, history, 4 months ago, In EnglishI hope you all liked the round. Please share your feedback in the comments section. 

1747A — Two GroupsHintTutorialLet S denotes sum of element of array a. 

Claim: Answer is |S|. 

Proof: Let sum of all positive elements is Spos and sum of all negative elements Sneg. Put all positive numbers in first group and negative numbers in second group. We get ||Spos|−|Sneg||=|S|. 

Let's prove that we can not do better than that. Let S1 denotes sum of elements of first group and S2 denotes sum of elements of second group. We have |S1|−|S2|≤|S1+S2|=|S|. Hence |S| is the upperbound for the answer. 

Solution1747B — BAN BANHint 1Hint 2Hint 3TutorialNo subsequences of string BAN would also mean no substrings of BAN in original string. Let minimum number of operations to have no substrings of BAN be x, it would be also be the lower bound for having no subsequences of string BAN. 

Claim: x=⌈n2⌉. 

Proof: Swap i-th B from start with i-th N from end for 1≤i≤⌈n2⌉. We can see that, no substrings of BAN exists after performing ⌈n2⌉ operations. Since we can only destroy atmost 2 substrings in one operations, ⌈n2⌉ is minimum possible. 

Now if you see clearly, after performing above operations, there does not exist any subsequence of string BAN in original string. Hence ⌈n2⌉ is also the answer for the original problem. 

Solution1747C — Swap GameHint 1Hint 2TutorialCase 1: a1>min(a) 

Alice can force the Bob to always decrease the minimum element by always choosing minimum element of a in her turn. Where as Bob can not do much, all other elements he would swap with would be greater than or equal to min(a). Even if there exists multiple minimums in a, In first move Alice would decrease from a1, hence in this case Alice would always win. 

Case 2: a1=min(a) 

In this case optimal startegy for Bob would be to always chhose minimum element of the array, which is a1. Alice would always be swapping the element greater than a1 in her turn, hence in the case Bob would always win 

Solution1747D — Yet another ProblemHint 1Hint 2Hint 3TutorialFirst forget queries, solve for single array a. 

Let's make some observations. 

Xor of array does not change after each operation 

Look at the set of prefix XORs while doing operations. Its size always decreases or remains same after each operation. Infact we can further reduce it to parities. Let S0, S1 be sets of prefix XOR's of parities 0 and 1 respectively. After each operation new sets S′0, S′1 will be subsets of S0 and S1 respectively. 

So necessary conditions for answer to exist is that xor of array should be 0 and S1 should contains 0. 

Now comes to minimum operations. 

Claim: If above conditions are satisfied, its always possible to make all elements 0 in less than or equal to 2 operations 

Proof: Let length of array be n. 

Case 1: n is odd 

Just apply the operation on whole array. 

Case 2: n is even 

There will exists some odd size prefix j such that xor of its elements is 0. Apply operation on [1,j] and [j+1,n]. It can happen that j=1 or j=n−1, in that case we only need one operation, because other remaining element would already be equal to 0. 

To solve for queries, you just need to check for odd prefix, which can be done using some data structure like std::map or std::set in C++. Do not forget to check the case when all elements are already 0. 

Solution1747E — List GenerationHint 1Hint 2TutorialGiven problem is equivalent to: 

You are currently at cell (0,0). From any cell (x,y) you can jump to cell (x′,y′) such that x≤x′≤n , y≤y′≤m and (x,y)≠(x′,y′). Find sum of number of visited cells over all paths starting from (0,0) and ending at (n,m). Denote the required value by f(n,m). 

Directly thinking in 2 dimensions is difficult, lets first solve for case when n=0 or m=0. WLOG, assuming m=0. We can solve this case using some binomials. 

f(n,0)=2n−1⋅n+32, n>0. 

Now, we can divide all possible paths from (0,0) to (n,m) into several classes of one dimensional paths. 

These classes are defined by what I call breakpoints. When we passes the breakpoint we turns right. Hence we can group paths by fixing the number of breakpoints. 

WLOG, Assuming n≥m. For k breakpoints there are (nk)⋅(mk) ways to select for 0≤k≤m. For a path with k breakpoints, n+m−k points are optional, that is there will exist 2n+m−k paths with k breakpoints. It is not difficult to see that sum of number of visited cells over paths with k breakpoints turned out to be f(n+m−k,0)+2n+m−k−1⋅k. Hence we can write f(n,m)=∑k=0m(nk)⋅(mk)⋅(f(n+m−k,0)+2n+m−k−1⋅k) 

Time complexity of the solution would be O(min(n,m)) 

Solution 

Codeforces Round #832 (Div. 2) Editorial 

By rivalq, history, 4 months ago, In EnglishI hope you all liked the round. Please share your feedback in the comments section. 

1747A — Two GroupsHintTutorialLet S denotes sum of element of array a. 

Claim: Answer is |S|. 

Proof: Let sum of all positive elements is Spos and sum of all negative elements Sneg. Put all positive numbers in first group and negative numbers in second group. We get ||Spos|−|Sneg||=|S|. 

Let's prove that we can not do better than that. Let S1 denotes sum of elements of first group and S2 denotes sum of elements of second group. We have |S1|−|S2|≤|S1+S2|=|S|. Hence |S| is the upperbound for the answer. 

Solution1747B — BAN BANHint 1Hint 2Hint 3TutorialNo subsequences of string BAN would also mean no substrings of BAN in original string. Let minimum number of operations to have no substrings of BAN be x, it would be also be the lower bound for having no subsequences of string BAN. 

Claim: x=⌈n2⌉. 

Proof: Swap i-th B from start with i-th N from end for 1≤i≤⌈n2⌉. We can see that, no substrings of BAN exists after performing ⌈n2⌉ operations. Since we can only destroy atmost 2 substrings in one operations, ⌈n2⌉ is minimum possible. 

Now if you see clearly, after performing above operations, there does not exist any subsequence of string BAN in original string. Hence ⌈n2⌉ is also the answer for the original problem. 

Solution1747C — Swap GameHint 1Hint 2TutorialCase 1: a1>min(a) 

Alice can force the Bob to always decrease the minimum element by always choosing minimum element of a in her turn. Where as Bob can not do much, all other elements he would swap with would be greater than or equal to min(a). Even if there exists multiple minimums in a, In first move Alice would decrease from a1, hence in this case Alice would always win. 

Case 2: a1=min(a) 

In this case optimal startegy for Bob would be to always chhose minimum element of the array, which is a1. Alice would always be swapping the element greater than a1 in her turn, hence in the case Bob would always win 

Solution1747D — Yet another ProblemHint 1Hint 2Hint 3TutorialFirst forget queries, solve for single array a. 

Let's make some observations. 

Xor of array does not change after each operation 

Look at the set of prefix XORs while doing operations. Its size always decreases or remains same after each operation. Infact we can further reduce it to parities. Let S0, S1 be sets of prefix XOR's of parities 0 and 1 respectively. After each operation new sets S′0, S′1 will be subsets of S0 and S1 respectively. 

So necessary conditions for answer to exist is that xor of array should be 0 and S1 should contains 0. 

Now comes to minimum operations. 

Claim: If above conditions are satisfied, its always possible to make all elements 0 in less than or equal to 2 operations 

Proof: Let length of array be n. 

Case 1: n is odd 

Just apply the operation on whole array. 

Case 2: n is even 

There will exists some odd size prefix j such that xor of its elements is 0. Apply operation on [1,j] and [j+1,n]. It can happen that j=1 or j=n−1, in that case we only need one operation, because other remaining element would already be equal to 0. 

To solve for queries, you just need to check for odd prefix, which can be done using some data structure like std::map or std::set in C++. Do not forget to check the case when all elements are already 0. 

Solution1747E — List GenerationHint 1Hint 2TutorialGiven problem is equivalent to: 

You are currently at cell (0,0). From any cell (x,y) you can jump to cell (x′,y′) such that x≤x′≤n , y≤y′≤m and (x,y)≠(x′,y′). Find sum of number of visited cells over all paths starting from (0,0) and ending at (n,m). Denote the required value by f(n,m). 

Directly thinking in 2 dimensions is difficult, lets first solve for case when n=0 or m=0. WLOG, assuming m=0. We can solve this case using some binomials. 

f(n,0)=2n−1⋅n+32, n>0. 

Now, we can divide all possible paths from (0,0) to (n,m) into several classes of one dimensional paths. 

These classes are defined by what I call breakpoints. When we passes the breakpoint we turns right. Hence we can group paths by fixing the number of breakpoints. 

WLOG, Assuming n≥m. For k breakpoints there are (nk)⋅(mk) ways to select for 0≤k≤m. For a path with k breakpoints, n+m−k points are optional, that is there will exist 2n+m−k paths with k breakpoints. It is not difficult to see that sum of number of visited cells over paths with k breakpoints turned out to be f(n+m−k,0)+2n+m−k−1⋅k. Hence we can write f(n,m)=∑k=0m(nk)⋅(mk)⋅(f(n+m−k,0)+2n+m−k−1⋅k) 

Time complexity of the solution would be O(min(n,m)) 

Solution 

Remember to convert line breaks into blanks. 

Recent Rounds Here: 

---------- 

Codeforces Round 855 (Div. 3) Editorial 

By Vladosiya, history, 116 minutes ago, translation, In English1800A - Is It a Cat? 

Idea: Vladosiya, MikeMirzayanov 

Tutorial1800A - Is It a Cat?To solve the problem, you may convert the string to lower case, strip all duplicated characters from it and compare the result to "meow" string. 

To exclude duplicate characters, you can, for example, use the unique function in C++. 

Solution1800B - Count the Number of Pairs 

Idea: myav 

Tutorial1800B - Count the Number of PairsCount two arrays big and small, such that big[i] contains the number of occurrences of ith letter of the alphabet in the string in upper case, while small[i] — in lower case. 

Let's add all existing pairs to the answer, so let's add min(small[i],big[i]) to it for each letter. Subtract this minimum from small[i] and big[i] to get the number of unpaired identical letters. 

Next, we will act greedily: if there is some set of at least two identical letters in the same case, we can apply the operation to half of them and get new pairs. Therefore, for each letter we will add min(k,max(small[i],big[i]))2 to the answer and decrease k by that amount. 

Solution1800C1 - Powering the Hero (easy version) 

Idea: Vladosiya 

Tutorial1800C1 - Powering the Hero (easy version)To solve it, it should be noted that despite the way the deck with bonuses works, the order in which they will be applied is not important. Then, when we meet the hero card, we just need to add to the answer the maximum of the available bonuses. 

Constraints allow you to sort the current array with bonus values each time and remove the maximum element. 

Solution1800C2 - Powering the Hero (hard version) 

Idea: Vladosiya 

Tutorial1800C2 - Powering the Hero (hard version)To solve it, it should be noted that despite the way the deck with bonuses works, the order in which they will be applied is not important. Then, when we meet the hero card, we just need to add to the answer the maximum of the available bonuses. 

Constraints make you use structures such as a priority queue to quickly find and extract the maximum. 

Solution1800D - Remove Two Letters 

Idea: MikeMirzayanov 

Tutorial1800D - Remove Two LettersConsider deleting characters with numbers i and i+1, as well as characters with numbers i+1 and i+2. In the first case, the symbol with the number i+2 remains, in the second - i. Symbols with numbers less than i or more than i+2 remain in both cases. Therefore, the same strings will be obtained if the characters with the numbers i and i+2 match. Therefore, we just need to count the number of i:1≤i≤n−2:si=si+2, and subtract this value from n−1. 

Solution1800E1 - Unforgivable Curse (easy version) 

Idea: Aris, talant 

Tutorial1800E1 - Unforgivable Curse (easy version)In these constraints , the problem could be solved as follows: 

Note that for strings of length 6 and more, it is enough to check that the strings s and t match character by character, that is, up to permutation, since each character can be moved to the desired half, and then moved to the desired side by length 1 by applying two operations on the length is 3 and 4. 

For example, there was a string "abudance" and we want to shift the c character to the left, then we can first get the string "acudab" and then the string "aaudcb". Well, we can restore the used symbols by putting them in their place "budka". That is, we were able to simply swap two adjacent characters. 

Thus, with such a clipping, it was possible to solve the problem by brute force for n≤5. To iterate, it was possible to store map of strings, which we can get and iterate through all the strings using bfs. 

Solution1800E2 - Unforgivable Curse (hard version) 

Idea: Aris, Vladosiya 

Tutorial1800E2 - Unforgivable Curse (hard version)The solution of the problem E1 hints to us that with the help of such operations, it is possible to move the symbol in the right direction by 1 using two operations. Then we can show that among the symbols that we can swap with at least one other symbol, we can get any permutation. 

For example, you can apply such a greedy solution: we will build an answer from the boundaries of the string t to the middle. Since we can move the symbol by a distance of 1, we can move it to the border and thus we can build any string t. 

Thus, it is enough to check that the sets of characters that can be swapped with some other match. And for the rest of the characters, check that they just match. 

Solution1800F - Dasha and Nightmares 

Idea: Gornak40 

Tutorial1800F - Dasha and NightmaresObservation 1: the product of odd numbers is odd, so the condition for the length of nightmare is automatically completed. 

Denote by f(x) the number of ones in binary representation of x. Let's enumerate the letters of the Latin alphabet from 0 to 25. 

Observation 2: for each word, it is enough to know the set of letters included in it and the evenness of their numbers. There are only 26 letters in the alphabet, so it is convenient to store the word characteristic si as a pair of masks ⟨ai,bi⟩. The bit with the number j in ai will be responsible for the availability of the letter j in si. The bit with the number j in bi will be responsible for the evenness of the number of letters j in si. 

Observation 3: strings sisj creates nightmare if and only if f(ai|aj)=f(bi⊕bj)=25. 

Let's fix the number k — the index of the letter that will not be in nightmares. Let's throw out all the words with the letter k, now we can look at the words in turn and look for a pair of them among those already considered. It is easy to see that the condition f(ai|aj)=25 follows from the condition f(bi⊕bj)=25 if one letter is banned. 

To count the number of pairs that include our word, we need to count the number of words with the characteristic bj=bi⊕(226−1). We can do this by bin-searching through a sorted array of b or using standard data structures. We got the solution for O(∑|s|+26⋅n⋅logn). 

Solution1800G - Symmetree 

Idea: Vladosiya 

Tutorial1800G - SymmetreeNote that if one subtree is a mirror image of another, then they are isomorphic (that is, equal without taking into account the vertex numbers). To check the subtrees for isomorphism, we use hashing of root trees. 

Now we just have to learn how to check trees for symmetry. To do this, let's calculate how many children of each type our vertex has (let's denote the hash of its subtree by the vertex type). In order for the vertex subtree to be symmetric, each child must have a pair of the same type, except perhaps one, which must also be symmetric. We can calculate the symmetry of the subtrees while counting their hash to simplify this task. 

Solution 

Codeforces Round #854 Editorial 

By subscriber, history, 83 minutes ago, In English1799A - Recent ActionsNote, that posts will be removed in the order n,n−1,…,1. 

The post n−k+1 will be removed at the first time, when there are at least k different numbers among p1,p2,…,pi. 

So let's calculate the number of different numbers among p1,p2,…,pi for each i using boolean array of length m iterating i from 1 to m. Using them we can calculate the answer. 

Time complexity: O(n+m). 

1799B - Уравняй делениемIf all numbers are equal initially — we can do nothing. 

Otherwise if some ai=1, answer do not exist: this ai can't became bigger during operations and all other elements can't be equal to 1 simultaniously, because after the last operation aj>1 (otherwise we can remove this operation). 

If all ai≥2, the answer exists and we can simulate such algorithm: let's take i, such that ai is maximum possible and j, such that aj is smallest possible. Make operation with (i,j). Note, that after at most 30n operations all elements will be equal. 

It is true, because after each operation ai decreases at least by 2 times (and rounded up) and all elements are bounded ax≥2 after each operation. Each number can't be decreased more than 30 times. 

Time complexity: O(n2logC), where C=109. 

1799C - Double Lexicographically MinimumLet's iterate all symbols of s in order from smallest to largest and construct an answer tmax. 

Let the current symbol be x. 

If there are at least 2 remaining symbols equal to x, we should add them to the current prefix and suffix of tmax and continue.If there are at most one other symbol y is left (there are x and c times y left in s) we should add ⌈c2⌉ symbols y, symbol x and ⌊c2⌋ symbols y to the prefix of tmax and break.Otherwise we should add all remaining symbols of s (excluding x) to prefix of tmax in the sorted order and after it symbol x.Time complexity: O(n+A), where A=26. 

1799D2 - Hot Start Up (hard version)Consider maintaining the following 2-dimensional DP: dpi,j will be the minimum time needed to run all previous programs such that the last program run on CPU 1 was program i, and the last program run on CPU 2 was program j. Initially we have dp0,0=0 (here, 0 is a placeholder program) and dpi,j=INF for (i,j)≠(0,0). 

When we come to a program x, we can transition as follows. First, create a new DP array ndp, initialized to all INF. Then: 

For all dpi,j with i≠x, set ndpx,j=min(ndpx,j,dpi,j+coldx).For all dpx,j, set ndpx,j=min(ndpx,j,dpx,j+hotx).For all dpi,j with j≠x, set ndpi,x=min(ndpi,x,dpi,j+coldx).For all dpi,x, set ndpi,x=min(ndpi,x,dpi,x+hotx).After all updates, replace dp with ndp. 

This works in O(nk2). To optimize it, we can notice that after processing a program x, only entries in dp with the row or column equal to x will be non-INF. Consider instead the following 1-dimensional DP array: dpi contains the minimum time to run previous programs if one CPU last ran program x, and the other last ran program i. 

Initially, dp0=0 and all other dpi=INF. Also, we add a dummy program with ID 0, and hot0=cold0=0 (this will make implementation easier). 

When we come to a program x, again, let's create a new DP array ndp, again initialized to all INF. Then, we can case on whether the previous program was equal to x. 

If the last program run was also x:For all i, set ndpi=min(ndpi,dpi+hotx).For all i≠x, set ndpx=min(ndpx,dpi+coldx).Set ndpx=min(ndpx,dpx+hotx).Otherwise, let y be the last program run.For all i, set ndpi=min(ndpi,dpi+coldx).For all i≠x, set ndpy=min(ndpy,dpi+coldx).Set ndpy=min(ndpy,dpx+hotx).This gets us a O(nk) solution which gets accepted in the easy version. 

To optimize it further, we can use a data structure to perform updates (since with each transition we either add some value to every dp element, or add some value to a single index). It is possible to do this in constant time per update, or using a segment tree or some other range update structure (though this is somewhat overkill). The overall complexity then becomes O(n+k) or O(nlogk+k) per test. 

1799E - City UnionLet's note, that the resulting grid is correct if and only if filled cells form continious segment in each row and column (condition *) and there is one city. 

So we can define a filling operation: given a grid, fill all cells between the most left and most right cells in each row and the most up and most down cells in each column. Doing this operation (n+m) times we get that condition * is satisfied and we filled cells that definitely should be filled. If now there is one city, we solved the problem. 

But if there are still two cities, their projections to horisontal and vertical axes do not intersect. So we need to connect them with some path. 

Let's consider the case when one city is upper left than the other city (otherwise we can apply rotation and get this case). Let's define the lowest row of the first city as i1, the right column of the first city as j1, the upper row of the second city as i2 and the left column of the second city as j2. We can fill cells on any Manhattan shortest path between cells (i1,j1), (i2,j2). After that again using filling operation we will fill cells that should be filled. 

It is easy to see, that by this solution we will get the smallest possible number of filled cells. 

Time complexity: O(nm(n+m)). 

1799F - Halve or SubtractFor convenience, let half(x) denote ⌈x2⌉, and sub(x) denote max(x−b,0). 

First, notice that if we apply both operations to some element, it will be optimal to apply halving first, then subtraction. We can prove this with 2 cases: 

ai≤2b. In this case, half(ai)≤b, and so sub(half(ai))=0. Since applying either function to a nonnegative integer results in a nonnegative integer, 0=sub(half(ai))≤half(sub(ai)).Otherwise, ai>2b. Then sub(half(ai))=ai−⌊ai2⌋−b, and half(sub(ai))=ai−b−⌊ai−b2⌋. Since ⌊ai−b2⌋≤⌊ai2⌋, sub(half(ai))≤half(sub(ai)).Next, suppose there are exactly p elements to which we apply both operations. Then, it will be optimal to apply both operations to the p greatest elements in the array. This should be somewhat intuitive, but here's a proof: 

Suppose there are some ai,aj such that ai<aj. Suppose we apply both operations to ai, and only one operation to aj. Then applying both operations to aj and a single operation to ai instead won't increase the resulting sum. We can prove this with two cases:We apply half to aj. Note that since it's optimal to apply half first when applying both operations, this case is essentially: halve both elements, then choose one to apply sub to. And it's better to subtract b from the greater element, since x−sub(x)≤y−sub(y) for x≤y.We apply sub to aj. We can analyze this with (surprise!) a few cases:ai,aj≤2b. Then whichever element we apply both operations to will be 0, and the result will depend only on the other element. sub(x)≤sub(y) for x≤y, so it's better to apply both operations to the greater element.aj>2b. If we apply both operations to the greater element, we subtract min(ai,b)+⌊aj2⌋+b from the sum. But applying both operations to the lesser element subtracts ⌊ai2⌋+min(half(ai),b)+b≤min(ai,b)+⌊ai2⌋+b from the sum. So it's optimal to apply both operations to the greater element.And this covers all cases where ai<aj.Let's fix p, the number of elements we apply both operations to. After taking them out, we will be left with the n−x smallest elements in the array. Suppose we have v1 operations of type 1 left, and v2 operations of type 2 left. We'll assume v1+v2≤n−x (otherwise we can apply both operations to more elements). 

Notice that it's optimal to apply our v1+v2 operations to the v1+v2 greatest remaining elements: subtracting from a greater element can't decrease the amount we subtract, and halving a greater element can't decrease the amount we take away. So we're left with v1+v2 elements, and we want to choose v1 of them to apply the halving to. 

Let's consider a few cases and try to analyze them. Let ai≤aj, and suppose we want to apply half to one of them and sub to the other. 

ai,aj≤b. Then it will be optimal to apply sub to the greater element.b≤ai,aj. Then it will be optimal to apply sub to the smaller element.Using this information, we can form the final lemma we need for our solution: 

Let ai≤aj≤ak. Suppose we apply sub to ai and ak, and half to aj. Then it will not increase the answer to apply half to one of ai or ak instead.There are 4 cases we should consider to prove this lemma: 

ak≤b. Then we should apply half to ai and sub to the others.b≤ai. Then we should apply half to ak and sub to the others.ai,aj≤b≤ak. Then we should apply half to ai and sub to the others.ai≤b≤aj,ak. Then we should apply half to ak and sub to the others.You can verify that doing this produces the optimal answer. And using this lemma, we find that the optimal answer has all sub operations applied to some of the middle elements, with all half operations applied to the endpoints. 

To summarize, the optimal answer will have a form like this (assuming a is sorted in non-increasing order, a1≥a2≥a3≥…≥an): 

First come some elements to which we apply both operations.Second come some elements to which we apply only half.Third come some elements to which we apply only sub.Fourth come some elements to which we apply only half.Finally come some elements to which we apply no operations.Note that some of these segments may be empty. 

It's easy to verify that it's optimal to use all given operations. So if we loop through all possible sizes for the first two segments, we can uniquely determine the sizes of the last three. Finally, using prefix sums to quickly find the sums of elements in a segment, we get an O(n2) solution. 

There is an interesting fact: if we will fix the size of the first group p and calculate the answer f(p) for it, the function f is convex. So the ternary or binary search can be used here to find the minimum in O(nlogn) time, but it was not necessary. 

Codeforces Round #853 (Div. 2) Editorial 

By Serval, history, 48 minutes ago, In English1789A - Serval and Mocha's ArrayIdea & Preparation: Bazoka13 

TutorialConsidering an array a of n (n≥2) positive integers, the following inequality holds for 2≤i≤n: 

gcd(a1,a2,⋯,ai)≤gcd(a1,a2)≤2Therefore, when the prefix [a1,a2] of a is good, we can show that all the prefixes of a whose length is no less than 2 are good, then a is beautiful. It is obvious that [a1,a2] is good when a is beautiful. So we get the conclusion that a is beautiful if and only if the prefix [a1,a2] is good. 

We can check if there exist ai,aj (i≠j) such that gcd(ai,aj)≤2. If so, we can move ai,aj to the front of a to make it beautiful, then the answer is Yes. If not, the answer is No. 

Time complexity: O(n2). 

1789B - Serval and Inversion MagicIdea & Preparation: Bazoka13 

TutorialIf s is palindromic initially, we can operate on the interval [1,n], the answer is Yes. 

Let's consider the other case. In a palindrome s, for each i in [1,⌊n/2⌋], si=sn−i+1 must hold. For those i, we may check whether si=sn−i+1 is true in the initial string. For all the illegal positions i, the operation must contain either i or n+1−i, but not both. For the legal positions, the operation must contain neither of i nor n+1−i, or both of them. 

If the illegal positions is continuous (which means that they are l,l+1,…,r−1,r for some l and r), we may operate on the interval [l,r] (or [n+1−r,n+1−l]), making the string palindromic. The answer is Yes. 

Otherwise, there must be some legal positions that lie between the illegal ones. Suppose the illegal positions range between [l,r] (but not continuous), and the operation is [o1,o2]. Without loss of generality, let the operation lies in the left part of the string. Then o1≤l,r≤o2<n+1−r must hold to correct all the illegal positions. This interval covers all the legal positions that lie between the illegal ones but does not cover their symmetrical positions. Thus, such kind of operation will produce new illegal positions. In other words, there are no valid operations in this situation. The answer is No. 

Time complexity: O(n). 

1789C - Serval and Toxel's ArraysIdea & Preparation: Toxel 

TutorialConsider the contribution of each value. We only need to count the number of concatenated arrays each value appears in, and sum all those counts up. The answer to this problem only depends on the number of appearances of this value. Notice that the appearance of each value forms some intervals. Each interval starts when it modifies another element (or in the initial array), and ends when it is modified (or in the m-th array). As there are no duplicate elements, the intervals do not intersect, so we can simply sum their lengths up. 

Let's use an array appear to track the appearance of each value. We first set the appearance of the initial elements to 0, and other elements to −1, which means the value does not appear. Then, in the i-th modification, suppose we modified some elements from x to y, then we should add i−appearx to countx, and set appearx to −1. We should also set appeary to i. After all operations, for all x, add m−appearx to countx if appearx is not −1. 

Value x appears in m(m+1)2−(m−countx)(m−countx+1)2 concatenated arrays. 

Time complexity: O(n+m). 

1789D - Serval and Shift-Shift-ShiftIdea & Preparation: Toxel 

TutorialFirst of all, it could be proven that the answer exists if and only if a and b are both zero or a and b are both non-zero. 

If a is zero, it remains zero after any operations. Therefore it cannot become b if b is non-zero. If a is non-zero, logical left shift it will definitely increase its lowest bit or make it zero, thus changing it into a different number. The same applies to logical right shift. Therefore, the xor result must be non-zero and there are no possible operations if b is zero. 

We will show that it is always possible to change a into b in the other cases. We denote lb(a) as the lowest bit of a and hb(a) as the highest bit of a. If a and b are both zero, no operations are needed. If they are both non-zero, the construction consists of four steps: 

If hb(a)<lb(b), logical left shift a by lb(b)−hb(a) bits. Then hb(a) must be equal or greater than lb(b).For each bit i of lb(b)−1,lb(b)−2,…,1, if ai=1, we may logical right shift a by hb(a)−i bits to erase it. After that, we have lb(a)≥lb(b).If lb(a)>lb(b), logical right shift a by lb(a)−lb(b) bits. Now it is guaranteed that lb(a)=lb(b).For each bit i of lb(b)+1,lb(b)+2,…,n, if ai≠bi, we may logical left shift a by i−hb(a) bits to erase it. After that, we must have a=b.Step 2 and step 4 require at most n−1 operations. We may also note that step 1 and step 3 never appear simultaneously. If step 1 is operated, then lb(a)=lb(b) is guaranteed after step 2. Thus, we need not operate step 3 in this case. In conclusion, we may use no more than n operations to change a into b if they are both non-zero. 

Time Complexity: O(n2) or O(n2w) by using std::bitset. 

1789E - Serval and Music GameIdea & Preparation: Serval 

TutorialConsider the following two cases: 

Case 1: x is not a factor of sn. 

In this case we have ⌊snx⌋+1=⌈snx⌉. Let k=⌊snx⌋. It can be shown that there are at most 2sn−−√ different values of k. The constraint of si can be written in the following form: 

si=pi⋅k+qi⋅(k+1)=(pi+qi)⋅k+qiFor a certain k, such pi and qi do not exist if and only if simodk>⌊sik⌋. To prove it, we show the contradiction that qimodk=simodk>⌊sik⌋≥qi, and we can give a construction of pi and qi when simodk≤⌊sik⌋ that qi=simodk and pi=⌊sik⌋−qi. 

By observation, these si are in one of the following k−2 intervals: 

[1,k−1],[k+2,2k−1],…,[(i−1)k+i,ik−1],…,[(k−2)k+(k−1),(k−1)k−1]We can count the number of these si by pre-calculating the prefix sums to calculate f(x). 

This case can be solved in O(sn) time, and we will show this fact: 

When k≤sn−−√, there are k−2 intervals that need to be considered for a certain k. Since ∑k≤sn√k≤sn, this part can be solved in O(sn) time.When k>sn−−√, notice that there are at most ⌈snk⌉≤sn−−√ intervals that need to be considered for a certain k. Recall that there are at most sn−−√ different values of k in this part, so it can be solved in O(sn) time.Case 2: x is a factor of sn. 

In this case we have ⌊snx⌋=⌈snx⌉. Let k=snx. The constraint of si becomes: 

si=(pi+qi)⋅kTo calculate f(x), we only need to count the number of multiples of x. To do this, we can first calculate s′i=gcd(si,sn) for all 1≤i≤n in O(nlogsn) time. It is obvious that s′i is a factor of sn. For a certain x, we can enumerate all the factors of sn, find out the multiples of x among them, and sum up the times that they occurred in s′. Recall that sn has at most 2sn−−√ factors, so this takes O(sn) time. 

This case can be solved in O(nlogsn+sn) time in total. 

Time complexity: O(nlogsn+sn). 

O(sn+σ(sn)) solutions can pass all the tests, where σ(n) denotes the sum of all the factors of n. A well-implemented O(snlogsn) solutions may pass the tests, too. 

Bonus: Solve this problem in O(n+sn) time. 

1789F - Serval and Brain PowerIdea & Preparation: Serval 

TutorialAssume that the longest powerful subsequence of the given string S is T, which can be obtained by concatenating k copies of string T′. Noticing that |S|≤80, we have the observation that k⋅|T′|≤|S|≤80, so it is impossible that both k and |T′| is large. 

When k<5, we only need to consider the k=2 case and the k=3 case. The k=4 case is covered by k=2 case, since T=T′+T′+T′+T′=(T′+T′)+(T′+T′). 

For the k=2 case, we split S into two parts S=S1+S2, then calculate the maximal length of LCS(S1,S2) by dynamic programming over all the possible splits. This case can be solved in O(w2⋅|S|3) time, where w2 is a small constant. 

It is similar to solve the k=3 case. We split S into three parts S=S1+S2+S3, then calculate the maximal length of LCS(S1,S2,S3) over all the possible splits. This case can be solved in O(w3⋅|S|5) time, where w3 is a small constant. We will estimate w3 later. 

When k≥5, we have |T′|≤|S|k≤|S|5. It can be shown that, if we split S into 5 parts, T′ will be the subsequence of at least one of them. We can split S into equal lengths, then enumerate all the subsequences of these substrings as the possible T′. For a possible T′, we can find out corresponding k by matching T′ and S greedily. This case can be solved in O(5⋅2|S|/5|S|). 

Now let us roughly estimate how small w3 could be. The time that dynamic programming consumed for certain S1,S2,S3 is |S1|⋅|S2|⋅|S3|. Since |S1|+|S2|+|S3|=|S|, we have |S1|⋅|S2|⋅|S3|≤127|S|3. Recall that there are (|S|−12)≤12|S|2 possible splits, then w3≤154 holds. 

Time complexity: O(w3⋅|S|5+5⋅2|S|/5|S|). 

Codeforces Round #852 Editorial 

By vaaven, 13 days ago, translation, In English1793A - Yet Another Promotion was authored and prepared by Ormlis 

1793B - Fedya and Array was authored and prepared by TheEvilBird 

1793C - Dora and Search was authored by fedoseev.timofey and prepared by vaaven 

1793D - Moscow Gorillas was authored and prepared by Gornak40 

1793E - Velepin and Marketing was authored and prepared by Tikhon228 

1793F - Rebrending was authored by Tikhon228 and prepared by vaaven 

1793A - Yet Another PromotionLet n=(m+1)⋅q+r. 

Note that you need to use a promotion if a⋅m≤b⋅(m+1). In this case, we will buy potatoes q times for the promotion. The remaining potatoes (or all if the promotion is unprofitable) can be bought at min(a,b) per kilogram. 

Then the answer is: 

q⋅min(a⋅m,b⋅(m+1))+r⋅min(a,b)Thus this solution works in O(1)Code1793B - Fedya and ArrayNote that the local minimums and maximums will alternate, and there will be the same number of them k. Let's call the i-th local maximum by ai, the i-th local minimum by bi. Without loss of generality, consider that ai goes before bi. To get bi from ai we need to write out ai−bi numbers, to get a(i+1)modk from bi we need to write out a(i+1)modk−bi numbers. 

Thus, (a1−b1)+(a2−b1)+(a2−b2)+…+(ak−bk)+(a1−bk)= 

=2⋅(a1+a2+…+ak)−2⋅(b1+b2+…+bk)=2⋅(A−B)=nThe array [y,y+1,y+2,…,x−1,x,x−1,x−2,…,y+1] will satisfy the condition. 

Code1793C - Dora and SearchSuppose we want to check whether the entire array satisfies the claim. If this is the case, then we can output the entire array as an answer. Otherwise, one of the two extreme elements does not meet our requirements. From this we can conclude that all segments containing an element that does not meet our requirements will also be incorrect, because this extreme element will remain the minimum/maximum. 

The algorithm follows from the fact above: let's look at the sub-section [l;r], which is initially equal to [1;n]. If al=min(al,al+1,…,ar) or al=max(al,al+1,…,ar), then we proceed to the segment [l+1;r]. A similar reasoning is also needed for ar. Thus, either after some iterations we will get the required sub-section, or we will get l==r and the answer will be −1. 

Final asymptotics: O(nlogn) or O(n) depending on the implementation. 

Code1793D - Moscow GorillasDenote by posx the index of the number x in the permutation. Subsegments with MEX>1 are as follows 1≤l≤pos1≤r≤n. 

Denote by: lx=min[pos1,pos2,…,posx], rx=max[pos1,pos2,…,osx]. 

Subsegments with MEX>x are as follows 1≤l≤lx≤rx≤r≤n. Let's find all subsegments with MEX=x. 

If posx+1<lx, then the subsegments with MEX=x+1 are as follows posx+1<l≤lx≤rx≤r≤nIf lx≤posx+1≤rx, then there is no subsegment with MEX=x+1If rx<posx+1, then the subsegments with MEX=x+1 are as follows 1≤l≤lx≤rx≤r<posx+1It remains only to intersect the sets of such subsegments for p and q, which is done trivially. 

Code1793E - Velepin and MarketingLet's sort people by their group size requirement. Suppose we have such a person i that he is not satisfied, and we have a person j>i who is satisfied. Then we can replace person j in his group with i and the answer for us will not be worse. It follows that for a particular k the answer is some prefix of the people we can make satisfied. 

Let us also prove that there exists some arrangement of groups that covers the same prefix, and that each group is a continuous segment. Let's take some correct partitioning into groups. Then each group will be a set of unconnected segments. Let's take the leftmost such segment. Note that we can swap it to the nearest segment of the same group to the right without breaking anything. 

Thus we obtained that we can look for a solution in the form of partitioning each prefix into valid groups, which are segments. We will solve this problem using dynamic programming. 

Let dp[i] -- the maximum number of groups into which ith prefix can be partitioned, so that everyone is satisfied (and no elements beyond the prefix can be used). Dynamics base: dp[0]=0 (empty prefix maximum can be divided into 0 groups). Transition: for ith person his group must have size at least a[i], so the transition looks like this dp[i]=max0⩽j⩽i−a[i]dp[j]+1. But what if a[i]>i? Then we can't dial the ith prefix. Then we put dp[i]=−∞. This dynamics can be calculated using prefix maximums. This part of the solution works for O(n). 

Earlier we said that the answer would be some prefix of people who would be satisfied. If we can partition the prefix into some number of groups, then that answer can be the prefix for all k⩽dp[i]+n−i. (we partition our prefix into dp, and the rest of the people one by one into the group) 

If we can't make the whole prefix satisfied (dp[i]=−∞), then we need to add people from outside. Thus, the maximum number of groups we can split into if ith prefix is completely satisfied is n−a[i]+1. 

Note that if by some prefix we can score k, then we can also score k−1 (combining two groups into one). Then we need to find the largest prefix that fits the given k in the query. This can be done by an array of suffix maximums over O(q) total. The final asymptotic of the solution is O(nlogn+q). 

Code1793F - RebrendingLet's go through all the elements from left to right. The main task will be to support the current version of dp[i] -- the minimum difference of ai with the elements to the right of it that we managed to consider. Let us correctly calculate dp for the first r elements. Let's move on to r+1. Let's show how to update the answer for all j<i, such that a[j]>a[i]. For j<i, such that a[j]<a[i] is solved similarly. 

Let's take the first element a[j] to the left of i, such that a[j]>a[i]. Note that if there is l<j<i such that a[l]>a[j]>a[i], then we will not update dp[l] for it, because |a[l]−a[j]|<|a[l]−a[i]|. Also, we will not update the answer for l such that |a[l]−a[j]|<|a[l]−a[i]|, that is, if a[l]>a[i]+a[j]−a[i]2. Therefore, further we will be interested only in the numbers from the segment [a[i],a[i]+a[j]−a[i]2]. 

Let's note that we have reduced the length of the segment by 2 times. That is, there will be no more such iterations than O(logn). You can find the rightmost number belonging to a segment using the segment tree. The answer for the segment li,ri will be minli⩽j<rdp[l] at the moment ri. This can also be efficiently found using the segment tree. The final asymptotics of the solution is O(nlog2n+qlogn). 

There is also a solution for O(nn−−√+qlogq) that passes all the tests. 

Code 

Codeforces Round #851 (Div. 2) Editorial 

By azberjibiou, 2 weeks ago, In English1788A - One and Two 

Problem idea: azberjibiou 

Tutorial1788A - One and TwoThere should be same number of 2 at a1,a2,⋯ak and ak+1,⋯,an. 

By checking every k, we can solve the problem at O(N2). By sweeping k from 1 to n−1, we can solve the problem in O(N). Not counting the number of 2 but naively multiplying using sweeping in python was accepted since it has time complexity O(N2). 

Checking every k and naively multiplying solutions are O(N3), so those solutions won't fit in time limit. 

1788B - Sum of Two Numbers 

Problem idea: azberjibiou 

Tutorial1788B - Sum of Two NumbersLet's assume that there is no carry while adding x and y. Denote n=a9⋯a1a0, x=b9⋯b1b0, y=c9⋯c1c0 in decimal system. The condition can be changed as the following condition. 

- ai=bi+ci for all 0≤i≤9. - Sum of bi and sum of ci should differ by at most 1. 

If ai is even, let bi=ci=ai/2. Otherwise, let bi and ci be ai+12 or ai−12. By alternating between (bi,ci)=(ai+12,ai−12) and (bi,ci)=(ai−12,ai+12), we can satisfy the condition where sum of bi and sum of ci differ by at most 1. 

There is an alternative solution. If n is even, divide it into (n2,n2). If remainder of n divided by 10 is not 9, divide it into (n+12,n−12). If remainder of n divided by 10 is 9, recursively find an answer for ⌊n10⌋ which is (x′,y′) and the answer will be (10x′+4,10y′+5) or (10x′+5,10y′+4) depending on what number has a bigger sum of digits. 

The following solution has a countertest. 

1. Trying to find x and y by bruteforce from (1,n−1). 2. Trying to find x and y by bruteforce from (n+12,n−12) 

A solution that randomly finds (x,y) passes. 

1788C - Matching Numbers 

Problem idea: azberjibiou 

Tutorial1788C - Matching NumbersLet's assume that 1 to 2n is paired and each sum of pair is k,k+1,⋯,k+n−1. Sum from 1 to 2n should equal to the sum of k to k+n−1. So we obtain n(2n+1)=(2k+n−1)n2, which leads to 4n+2=2k+n−1. Since 4n+2 is even, 2k+n−1 should be even. So if n is even, we cannot find such pairing. 

If n is odd, there are various ways to make such pairing. Let m=n−12. (1,3m+3),(2,3m+4),…(m,4m+2),(m+1,2m+2),(m+2,2m+3),…(2m+1,3m+2) can be such pairing. 

1788D - Moving Dots 

Problem idea: azberjibiou 

Tutorial1788D - Движущиеся точкиLet's think about the original problem where we do not think about subsets. 

We can easily observe that each dot does not change direction during moving. 

Assume that dots gather at coordinate x. Rightmost dot of dots that have smaller coordinate than x should move right, and leftmost dot which has bigger coordinate than x should move left. We can observe that the number of adjacent dot where each move toward each other will be the answer. 

Now let's solve the problem for subsets. Instead of counting number of adjacent dot that moves toward each other for each subset of dots, we will count the number of subset for each possible 1≤i<j≤N where dot i moves right and dot j moves left and there are no dots between i and j. 

Let the coordinate of a dot in a subset be k. We will try to find out which k can be in a subset where dot i and dot j move toward each other. 

Since there are no dot between i and j, dots satisfying xi<k<xj should not be in the subset. Since dot i should move right, dots that satisfy k<xi and xi−k≤xj−xi should not be in the subset. As the same way for dot j, dots that satisfy k>xj and k−xj<xj−xi should not be in the subset. Summing these up, dots satisfying 2xi−−xj≤k<2xj−−xi should not be in the subset. By using binary search, we can find the number of dots that cannot be in the subset in O(logN). 

If there are p dots that can be in the subset, the number of subset where i and j moves toward each other will be 2p. Summing all 2p will give us the answer. Since there are O(N2) pairs of (i,j), we can solve the problem in O(N2logN). 

Instead of using binary search, we can use the monotonicity of 2xj−xi and 2xi−xj when j increases, we can solve the range of dots that cannot be in the subset in O(N2) by sweeping. Both O(N2logN) and O(N2) solutions will be accepted. 

There were some dynamic programming solutions from some testers. 

1788E - Sum Over Zero 

Problem idea: azberjibiou 

Problem solver: YeongTree 

Tutorial1788E - Sum Over ZeroDenote p as the prefix sum of a. For a segment [x+1,y] to be an element of S, px≤py should be satisfied. 

Let's denote dpi as the maximum value of the sum of length of segment smaller than i in S. Segment [x,y] is smaller than i if y≤i. If there is no segment ending at i, dpi=dpi−1. If there is segment [k+1,i] in S, dpi=maxpk≤pi(dpk+i−k). By summing up, dpi=max(dpi−1,maxpk≤pi(dpk+i−k) With this dp, we get an O(N2) solution. 

Now let's try to speed up the dp transition using segment tree. First, use coordinate compression on pi since we only see whether one prefix sum is bigger than the other. We will maintain a segment tree that stores dpk−k in position pk. 

Let's find dpi in order of i. dpi=max(dpi−1,maxpk≤pi(dpk−k)+i) We can solve maxpk≤pi(dpk−k) by range query [0,pi] on a segment tree. So we can solve dpi in O(logN) for each i. 

The entire problem is solved in O(NlogN). 

There is an alternative solution that maintains pair (dpk−k,pk) monotonically with a set. This solution also runs in O(NlogN). 

1788F - XOR, Tree, and Queries 

Problem idea: azberjibiou 

Tutorial1788F - XOR, Tree, and QueriesLet's denote pi as xor of edges in path from node 1 to node i. Edges in path from i to j is 

(edges in path from 1 to i) + (edges in path from 1 to j) — 2×(edges in path from 1 to lca(i,j)) 

where lca(i,j) denotes the least common ancestor of i and j. Since xor of two same number is 0, we can observe that xor of path from i to j is pi⊕pj. 

If we know every pi for all i, weight of edge connecting i and j is pi⊕pj, so deciding weight of every edge is equivalent to deciding every pi for i≥2. 

Let G be the original tree graph. Let's make a undirected weighted graph G′ from the given condition. Condition (u, v, x) makes an edge connecting u and v with weight x. This edge means that pv=pu⊕x. Now if u and v are connected by edges in G′, this means that pv=pu⊕ (xor of edges in path from u to v). 

First, let's check if it is possible to make a graph that satisfies the conditions. 

If G′ is a connected graph, we can solve pi using dfs from node 1. For edges not used in dfs (back edges), we have to check if it is valid with the solved pi. Specifically, if there is an edge (u, v, x), we need to check if pu⊕pv=x. 

Now let's think when G′ is not a connected graph. By dividing the graph into connected components, we can solve if it is impossible to make a graph that satisfies the conditions in a same fashion. 

Now let's try to minimize a1⊕a2⊕⋯⊕an−1. 

For edge (u,v) in G, weight of edge is pu⊕pv. By substituting ai into pxi⊕ pyi, a1⊕a2⊕⋯⊕an−1 can be written as xor of pi where node i has odd degree. Let the connected components of G′ be G1,G2,…,Gk. Pick any vertex rk in each component Gk. For every vertex i in Gk, pi is expressed as prk⊕ (xor of edges in path from rk to i). 

Let's define a set L as L={i|Gi has odd number of odd degree vertices}. 

By substituting pi into (prk⊕ (xor of edges in path in G′ from rk to i)), we can rewrite "xor of pi where node i has odd degree" into ⨁k∈Lprk⊕c where c is a constant. 

If L is empty, the answer is constant and any solution that satisfy the given conditions will be the answer. 

If L is not empty, set one of prk to c and other prk as 0 so that a1⊕a2⊕⋯an−1 is 0. 

We can solve the problem in O(N). 

Fast O(NlogX) solution might be accepted, including the solution where you divide the weight of edge by bits. 

Codeforces Round #850 Editorial 

By tourist, 10 days ago, translation, In English1786A2 - Alternating Deck (hard version) 

Problem author: KAN 

Explanation1786A2 - Alternating Deck (hard version)Note that on the i-th step, Alice takes i cards from the deck. It means that after k steps, k(k+1)2 steps are taken from the deck. Thus, after O(n−−√) steps, the deck is empty. We can simulate the steps one by one by taking care of whose turn it is and what is the color of the top card. Using this information, we can keep track of how many cards of what color each player has. Print this information in the end. 

Code by KAN1786B - Cake Assembly Line 

Problem author: KAN 

Explanation1786B - Cake Assembly LineObviously, the i-th cake should be below the i-th dispenser. The leftmost possible position of the cake is when the chocolate would touch the right border. If ci is the new position of the cake's center, then in this case ci+w=bi+h. The rightmost possible position is, similarly, when ci−w=bi−h. Thus, the new position of the center should be between bi+h−w and bi−h+w. 

This means that the i-th cake should be shifted by any length between (bi+h−w)−ai and (bi−h+w)−ai. Since all cakes on the conveyor move at the same time, the shift p should satisfy (bi+h−w)−ai≤p≤(bi−h+w)−ai for all i at the same time. This is possible if and only if a value p exists such thatmaxi(bi+h−w−ai)≤p≤mini(bi−h+w−ai),which in turn is possible whenmaxi(bi+h−w−ai)≤mini(bi−h+w−ai),Thus, it is enough to find the maximum and minimum values of the formulas above and compare them. The time complexity is linear. 

Code by KAN1785A - Monsters (easy version) 

Problem author: tourist 

Explanation1785A - Monsters (easy version)First, let's prove that it's always optimal to use a spell of type 2 as your last spell in the game and kill all monsters with it. Indeed, suppose you use a spell of type 2 earlier and it deals x damage to all monsters. Suppose that some monsters are still alive. For any such monster, say they had y health points before the spell of type 2, and y>x. Then, you will need to cast y−x more spells of type 1 to kill it afterwards. But you could just cast these y−x spells of type 1 on this monster before casting the spell of type 2. Thus, you can move all usages of spells of type 1 before the usage of the spell of type 2 without changing the answer. 

Without loss of generality, assume that a1≤a2≤…≤an. Let bi be the amount of health points monster i has right before the spell of type 2 is cast (1≤bi≤ai). Then, the number of spells of type 1 needed is ∑i=1n(ai−bi), which means we want to maximize ∑i=1nbi. 

Note that we can rearrange b so that b1≤b2≤…≤bn: since a is sorted too, the bi≤ai condition will still hold. 

Also, since all monsters must be killed by a spell of type 2 afterwards, bi+1−bi≤1 must hold. 

Thus, we should go through all monsters in non-decreasing order of ai and decide their bi greedily, picking the largest value satisfying both bi≤ai and bi≤bi−1+1. Specifically, we should choose b1=1 and bi=min(ai,bi−1+1). 

Code by tourist1785B - Letter Exchange 

Problem author: tourist 

Explanation1785B - Letter ExchangeFor each person, there are three essential cases of what they could initially have: 

Three distinct letters: "win". No need to take part in any exchanges.Two equal letters and another letter, e.g. "wii". An extra 'i' must be exchanged with someone's 'n'.Three equal letters, e.g. "www". One 'w' must be exchanged with someone's 'i', another 'w' must be exchanged with someone's 'n'.Let's create a graph on three vertices: 'w', 'i', 'n'. Whenever person i has an extra letter x and is lacking letter y, create a directed edge x→y marked with i. 

Once the graph is built, whenever you have a cycle of length 2, that is, x→iy→jx, it means person i needs to exchange x for y, while person j needs to exchange y for x. Thus, both of their needs can be satisfied with just one exchange. 

Finally, once there are no cycles of length 2, note that the in-degree and the out-degree of every vertex are equal. If e.g. there are p edges 'w' → 'i', it follows that there are p edges 'i' → 'n' and p edges 'n' → 'w'. It means we can form p cycles of length 3. (The cycles could also go in the opposite direction: 'w' → 'n' → 'i' → 'w'.) In any case, each cycle of length 3 can be solved using 2 exchanges. 

Code by PavelKunyavskiy1785C - Monsters (hard version) 

Problem author: tourist 

Explanation1785C - Монстры (сложная версия)Continuing on the solution to the easy version: now we have a set of integers A, we need to add elements into A one by one and maintain the answer to the problem. 

Recall that for every i, either bi=bi−1 or bi=bi−1+1. Note that bi=bi−1 can only happen when bi=ai. Let's call such an element useless. If we remove a useless element, the answer does not change. 

If there are no useless elements, we have b1=1 and bi=bi−1+1 for i>1: that is, bi=i. Thus, the answer to the problem can be easily calculated as ∑i=1m(ai−bi)=∑i=1mai−m(m+1)2, where m is the current size of the set. 

We can formulate the condition "there are no useless elements" as follows. For any x, let kx be the number of elements in A not exceeding x. Then, kx≤x. 

On the other hand, suppose that for some x, we have kx>x. Let's find the smallest such x. Then, we can see that A contains a useless element equal to x, and we can safely remove it. 

We can check this condition after adding each new element to A using a segment tree. In every cell x of the array maintained by the segment tree, we will store the difference x−kx. Initially, cell x contains value x. When a new element v appears, we should subtract 1 from all cells in range [v;n]. Then, if a cell with a negative value appears (that is, x−kx<0, which is equivalent to kx>x), we should find the leftmost such cell x and remove an element equal to x. In particular, we should add 1 to all cells in range [x;n]. 

Thus, we can use a segment tree with "range add" and "global min". At most one useless element can appear every time we enlarge A, and if that happens, we can identify and remove it in O(logn), resulting in an O(nlogn) time complexity. 

Code by tourist1785D - Wooden Spoon 

Problem author: tourist 

Explanation1785D - Wooden SpoonLet's focus on the sequence of players beating each other 1=a0<a1<…<an: a0 is the tournament champion, a0 beats a1 in the last match, a1 beats a2 in the second-to-last match, …, an−1 beats an in the first match. 

For a fixed such sequence, how many ways are there to fill the tournament bracket? 

Let's look at the sequence in reverse. 

There are 2n ways to put player an somewhere. 

Player an−1 has to be the opponent of player an in the first match. 

Player an−2 has to beat some player b>an−2 in the first match, and then beat an−1 in the second match. There are 2n−an−2−2 ways to choose player b (since it can not be equal to an−1 and an), and there are also 2 ways to order an−2 and b. 

Player an−3 has to be the winner of a subbracket containing 3 other players c1,c2,c3>an−3, and then beat an−2 in the third match. There are 2n−an−3−4 players to choose ci from (since they can not be equal to an−2, an−1, an, and b), and there are (2n−an−3−43) ways to do so, and there are also 4! ways to order an−3, c1, c2, and c3. 

In general, player an−i has to be the winner of a subbracket containing 2i−1−1 other players, and there are 2n−an−i−2i−1 players to choose from, and there are (2n−an−i−2i−12i−1−1) ways to choose, and also (2i−1)! ways to order this subbracket. 

You can see that the total number of brackets for a fixed sequence 1=a0<a1<…<an can be represented as f(a0,0)⋅f(a1,1)⋅…⋅f(an−1,n−1)⋅f(an,n), where f(ai,i) is some function of a player number and a round number. 

Now let's use dynamic programming: let d(ai,i) be the sum of products of f(a0,0)⋅f(a1,1)⋅…⋅f(ai,i) over all sequences 1=a0<a1<…<ai. Then: 

d(1,0)=f(1,0);d(a0,0)=0 for a0>1;d(ai,i)=f(ai,i)⋅∑ai−1=1ai−1d(ai−1,i−1) for i>0.The answer for player x is d(x,n). 

This DP has O(n⋅2n) states, and note that the inner sums in the formulas for d(ai,i) and d(ai+1,i) only differ by one summand. Thus, by using cumulative sums for transitions, we can achieve an O(n⋅2n) time complexity. 

Code by tourist1785E - Infinite Game 

Problem author: tourist 

Explanation1785E - Infinite GameFor a fixed game scenario s, let's build a weighted functional graph on 4 vertices that correspond to set scores 0:0, 1:0, 0:1, and 1:1. For each score x, traverse the scenario from left to right, changing the score after each letter, and starting a new set whenever necessary. If the set score by the end of the scenario is y, add a directed edge from x to y. The weight of this edge is the number of sets Alice wins during the process, minus the number of sets Bob wins. 

When we have built such a graph for a game scenario s, we can easily decide whether s is winning for Alice, tied, or winning for Bob. Starting from vertex 0:0, move by the outgoing edges until you arrive at a cycle. In the cycle, find the sum the edge weights. If the sum is positive, the scenario is winning for Alice; if the sum is 0, the scenario is tied; if the sum is negative, the scenario is winning for Bob. 

Now we can use dynamic programming. Let f(i,{u0,u1,u2,u3},{w0,w1,w2,w3}) be the number of ways to choose s1s2…si so that edges from vertices 0,1,2,3 go to vertices u0,u1,u2,u3 and have weights w0,w1,w2,w3, respectively. Even though this DP has O(n5) states, it might be possible to get this solution accepted if you only visit reachable states and optimize your solution's constant factor. 

However, here's an idea that drastically improves the time complexity. Note that in the end, we are only interested in the sum of some wj, and not in every value separately. Outside of our DP, let's fix the mask of vertices that will lie on the cycle reachable from 0:0. In the DP state, we can just store the sum s of wj over j belonging to this mask: f(i,{u0,u1,u2,u3},s). In the end, we will look at the values of u0,u1,u2,u3 and check if the cycle in our graph is indeed the one we want; only if that's true, we will add the DP value to the overall answer. 

This way, at the cost of running the DP 24 times, we have cut the number of states to O(n2). The overall time complexity of this solution is O(n2) too, although the constant factor is huge. 

Code by tourist1785F - Minimums or Medians 

Problem author: tourist 

Explanation1785F - Минимумы или медианыLet's denote removing minimums with L, and removing medians with M. Now a sequence of Vika's actions can be described with a string s of length k consisting of characters L and M. 

Observe that if we have a substring LMM, we can replace it with MLM, and the set of removed numbers will not change. We can keep applying this transformation until there are no LMM substrings in s. 

Now, a string s of our interest looks as a concatenation of: 

p letters M, for some 0≤p≤k;if p<k, then a letter L;max(0,k−1−p) letters L and M, without two letters M in a row.Let's denote the number of letters M in part 3 above as q. 

Can different strings still lead to equal sets in the end? 

First, let's suppose that k≤n−12. We will prove that all strings that match the above pattern result in distinct integer sets. 

Part 1 in the above concatenation means that integers from n−p+1 to n+p are removed. Since there are k−p−q letters L in s in total, integers from 1 to 2(k−p−q) are removed too. However, integers in the range [2(k−p−q)+1;n−p] are not removed, and note that 2(k−p−q)+1≤n−p is equivalent to k≤n+p+2q−12. Hence, this range is never empty when k≤n−12. Thus, we can see that for all pairs of p and q, the leftmost non-removed ranges are distinct. 

Now, also note that in part 3 of the concatenation, any letter M always removes some two consecutive integers (since there is no substring MM), and letters L serve as "shifts" for these removals, and different sets of "shifts" result in different final sets of integers. This finishes the proof. 

It is easy to find the number of ways to fill part 3 for fixed p and q: there are ((k−1−p)−(q−1)q) ways to choose q positions out of (k−1−p) so that no two consecutive positions are chosen. Now we have just iterate over all valid pairs of p and q to get an O(n2) solution for the k≤n−12 case. 

Before optimizing it to O(n), let's get back to the k>n−12 case. Some strings can result in the same final set. Let x be the smallest integer in the final set. Note that x is always odd. We will only look for a string that contains x−12 letters L: that is, a string that removes integers from 1 to x−1 only via removing minimums. We can see that there is always a unique such string. 

Recall the uniqueness proof for k≤n−12. When p>0, we will now force that leftmost non-removed range, [2(k−p−q)+1;n−p], to be non-empty. If the range is empty, our sequence of actions does not satisfy the condition from the previous paragraph, so we can skip this pair of p and q. 

When p=0, things are a bit different. Suppose we have fixed q. It means there are k−q letters L in the string. These operations remove integers from 1 to 2(k−q). Thus, we need the first letter M to remove integers strictly greater than 2(k−q)+1, which gives us a lower bound on the number of letters L at the start of the string. Otherwise, we can use the same binomial coefficient formula for counting. 

This should finish the O(n2) solution for any k. 

To optimize it, let's iterate over q first and iterate over p inside. It turns out that all valid values of p form a range, and if we look at what we are summing up, it is (0q)+(1q)+…+(rq) for some integer r. This sum is equal to (r+1q+1) by the hockey-stick identity. Thus, we finally have an O(n) solution. 

Code by tourist, O(n^2)Code by tourist, O(n) 

Codeforces Round #849 (Div. 4) Editorial 

By flamestorm, 3 weeks ago, In EnglishWe hope you enjoyed the contest! 

1791A - Codeforces Checking 

Idea: flamestorm 

Tutorial1791A - Codeforces CheckingYou need to implement what is written in the statement. You can either use an if-statement for each of the characters {c,o,d,e,f,r,s}, or you can iterate through the string codeforces check if the current character equals c. 

Solution1791B - Following Directions 

Idea: flamestorm 

Tutorial1791B - Following DirectionsWe can keep track of our current point (x,y) as we iterate over the string: 

if si=L, then decrement x (set x←x−1);if si=R, then increment x (set x←x+1);if si=U, then increment y (set y←y+1);if si=D, then decrement y (set y←y−1).Initially, set x=y=0. If x=y=1 is ever true, then we should output YES; otherwise, we output NO.The time complexity is O(n). 

Solution1791C - Prepend and Append 

Idea: flamestorm 

Tutorial1791C - Prepend and AppendLet's perform the process in reverse: we will remove the first and last character of the string, if these two characters are different. We should do this as long as possible, since we need to find the shortest initial string. 

So the algorithm is straightfoward: keep track of the left and right characters, and if they are different, remove both. Otherwise, output the length of the current string (or output 0 if the string became empty). 

There are a few ways to implement this. For example, you can keep two pointers, one at the beginning of the string and one at the end, say, l=1 and r=n, and check if sl=sr. If it's true, then we increment l and decrement r. Otherwise, we output r−l+1. We stop when l≥r. 

Alternatively, you can use deque to simulate the operations directly. The time complexity is O(n). 

Solution1791D - Distinct Split 

Idea: SlavicG 

Tutorial1791D - Distinct SplitLet's check all splitting points i for all (1≤i≤n−1). We denote a splitting point as the last index of the first string we take (and all the remaining characters will go to the second string). We need to keep a dynamic count of the number of distinct characters in both strings a (the first string) and b (the second string). We can do this using two frequency arrays (and adding one to the distinct count of either string a or b when the frequency of a character is greater than zero. 

Solution1791E - Negatives and Positives 

Idea: SlavicG 

Tutorial1791E - Negatives and PositivesWe can notice that by performing any number of operations, the parity of the count of negative numbers won't ever change. Thus, if the number of negative numbers is initially even, we can make it equal to 0 by performing some operations. So, for an even count of negative numbers, the answer is the sum of the absolute values of all numbers (since we can make all of them positive). And if the count of negative numbers is odd, we must have one negative number at the end. We will choose the one smallest by absolute value and keep the rest positive (for simplicity, we consider −0 as a negative number). 

Solution1791F - Range Update Point Query 

Idea: flamestorm 

Tutorial1791F - Range Update Point QueryLet S(n) denote the sum of the digits of n. The key observation is the following: after the operation is applied to index i thrice, it won't change after any further operations. The proof† is provided at the bottom of the editorial. 

So we only need to update ai if it's been updated at most 2 times so far; otherwise, we can ignore it. This allows us to do the following solution: store the current "active" indices (that is, indices that have been updated ≤2 times) in a sorted list (for example, set in C++). Then: 

1 l r — search for the smallest active index at least l (since the list is sorted, we can do it in O(logn)). Afterwards, update that index (replace ai with S(ai)), remove it if it's no longer active, and binary search for the next largest active index in the sorted list, until we pass r.2 x — just output ax.Although it looks like we take O((r−l+1)log(r−l+1)) time for each update, we actually only ever update each element of the array at most 3 times, so we will do no more than 3nlogn binary searches.Therefore the time complexity is amortized O(q+nlogn). 

† To show this, note that initially 1≤ai≤109. The maximum possible value of the sum of the digits of ai is 81, achieved when ai=999,999,999. So 1≤S(ai)≤81. 

Now considering the numbers from 1 to 81, the one with maximum sum of digits is 79, with S(79)=16. Hence 1≤S(S(ai))≤16. Finally, considering the numbers from 1 to 16, the one with maximum sum of digits is 9, so 1≤S(S(S(ai)))≤9. That is, after three operations, ai becomes a single digit. Any further operations, and it won't change any more. 

Solution1791G1 - Teleporters (Easy Version) 

Idea: flamestorm 

Tutorial1791G1 - Teleporters (Easy Version)It's easy to see that it's optimal to only move right or to use a portal once we are at it. We can notice that when we teleport back, the problem is independent of the previous choices. We still are at point 0 and have some portals left. Thus, we can just find out the individual cost of each portal, sort portals by individual costs, and take them from smallest to largest by cost as long as we can. The cost of portal i is i+ai (since we pay ai to use it and need i moves to get to it). 

Solution1791G2 - Teleporters (Hard Version) 

Idea: flamestorm 

Tutorial1791G2 - Teleporters (Hard Version)Please also refer to the tutorial for the easy version. 

If we are not at the first taken portal, the problem is still independent for each portal, but this time the cost of a portal is min(ai+i,ai+n+1−i) (since we can come to a portal either from point 0 or point n+1). So, we again sort the portals by their costs. But this time, we need to make sure that the first taken portal is taken from point 0, so we will iterate over all portals and check the maximum amount of portals we can take if we use it as the first one. We can check this using prefix sums over the minimum cost array and binary searching, checking if the amount of considered portals taken doesn't exceed the number of coins we initially have (we also have to deal with the case when the portal we are considering is included both times as the initial portal and in the minimum cost prefix). 

Solution 

Codeforces Round #848 (Div. 2) Editorial 

By adnan_toky, 3 weeks ago, In English1778A - Flip Flop Sum 

Tutorial1778A - Flip Flop SumLet's say we've chosen index i. What will happen? 

If the values of ai and ai+1 have opposite signs, flipping them won't change the initial sum.if ai = ai+1 = 1, flipping them will reduce the sum by 4.if ai = ai+1 = −1, flipping them will increase the sum by 4.So, for each i<n, we can check the values of ai and ai+1, and we can measure the effects on the sum based on the three cases stated above. Among the effects, take the one that maximizes the sum. 

Time complexity: In each test case, O(n)Code1778B - The Forbidden Permutation 

Tutorial1778B - The Forbidden PermutationIf the array a is good, the answer is obviously 0. Now, how can we optimally transform a not good array a to a good array? Let, we are on the index i (i<m) and x=ai, y=ai+1. If we observe carefully, we will find that there are basically two cases that will make the array a good: 

Move x and y in the permutation p in such a way that pos(y) becomes greater than pos(x)+d. To do that, in the permutation p, we can swap x to the left and y to the right. The total number of swaps needed is =d−(pos(y)−pos(x))+1. We need to check if there is enough space to the left of pos(x) and to the right of pos(y) to perform the needed number of swaps.Move x and y in the permutation p in such a way that pos(y) becomes smaller than pos(x). To do that, In the permutation p, we can simply swap y to the left until the condition is satisfied. The number of swaps needed is pos(y)−pos(x).For each i<m, calculate the minimum number of swaps needed among these two cases. The minimum number of swaps among all i<m will be the desired answer. 

Time complexity: In each test case, O(n)Code1778C - Flexible String 

Tutorial1778C - Flexible StringIf we can replace all the characters of the string a, we can transform the string a to the string b. So, replacing more characters is always beneficial. For a fixed string a and another fixed string b, if the answer is x1 for k1 and x2 for k2 (k1<k2), it can be shown that x1≤x2 always satisfies. 

That is to say, we can safely consider the size of the set q to be the maximum limit min(k,u) where u is the number of unique characters in the string a. Now, we can generate all possible sets of characters having size min(k,u). Obviously, we won't take the characters that are not present in the string a because they have no effect on the answer. There are many ways to generate the sets, like backtracking, bitmasking, etc. If we can calculate the number of valid pairs (l,r) for each set efficiently, the rest task will be just taking the maximum of them. 

To calculate the number of pairs for each set efficiently, we can observe the fact that if a[l,r]=b[l,r] is true, a[p,q]=b[p,q] satisfies for any l≤p≤q≤r. So, we will get c×(c+1)2 number of valid pairs from here where c=r−l+1. Now, we can start iterating from the beginning of the string a. We can say that ai matches bi if they are equal or ai exists in the currently generated set. 

While iterating, when we are on the jth index, we need to find the rightmost index r such that a[j,r]=b[j,r] satisfies. Then we need to add the number of valid pairs in this range to the contribution of this set. After that, we need to set the value of j to r+1 and repeat the steps again. The rest of the tasks are trivial. 

Time complexity: In each test case, O(n×(um)), where m=min(k,u)Code1778D - Flexible String Revisit 

Tutorial1778D - Flexible String RevisitLet k be the number of indices where the characters between two strings are different and f(x) be the expected number of moves to make two strings equal given that the strings have x differences. We have to find the value of f(k). 

For all x where 1≤x≤n−1, 

f(x)=xn⋅[1+f(x−1)]+n−xn⋅[1+f(x+1)]or, f(x)=1+xn⋅f(x−1)+n−xn⋅f(x+1)Now, f(0)=0 and f(1)=1+n−1nf(2). 

We can represent any f(i) in the form f(i)=ai+bi⋅f(i+1). 

Let, a1=1 and b1=n−1n. So, we can write f(1)=a1+b1⋅f(2). 

When 1<i<n, f(i)=1+in⋅f(i−1)+n−in⋅f(i+1). We can substitute the value of f(i−1) with ai−1+bi−1⋅f(i) and calculate the value of f(i). Thus we can get the value of ai and bi using the value of ai−1 and bi−1 by considering a1 and b1 as the base case. 

We get, ai=n+i⋅ai−1n−i⋅bi−1 and bi=n−in−i⋅bi−1 for 2≤i≤n. 

CalculationSimilarly, f(n)=1+f(n−1). 

We can represent any f(i) in the form f(i)=ci+di⋅f(i−1). 

Let, cn=1 and dn=1. So, we can write f(n)=cn+dn⋅f(n−1). 

When 1<i<n, f(i)=1+in⋅f(i−1)+n−in⋅f(i+1). We can substitute the value of f(i+1) with ci+1+di+1⋅f(i) and calculate the value of f(i). Thus we can get the value of ci and di using the value of ci+1 and di+1 by considering cn and dn as the base case. 

We get, ci=n+(n−i)⋅ci+1n−(n−i)⋅di+1 and di=in−(n−i)⋅di+1. 

CalculationNow, f(i)=ci+di⋅f(i−1) and f(i−1)=ai−1+bi−1⋅f(i). By solving these two equations, we find that f(i)=ci+di⋅ai−11−di⋅bi−1. 

Time Complexity: O(n⋅logm). 

Alternative SolutionCodeAlternative Code1778E - The Tree Has Fallen! 

Tutorial1778E - The Tree Has Fallen!At first, we can think of another problem. Given an array. You need to find the maximum subset XOR. How can we solve it? We can solve this problem very efficiently using a technique called "XOR Basis". You can read about it from here. 

In problem E, at first, we can fix any node as the root of the tree. Let's call this rooted tree the base tree. After that, start an Euler tour from the root and assign discovery time du and finishing time fu to each node u. In each query, three types of cases can occur (node r and node v are from the query format): 

r=v. In this case, we need to calculate the maximum subset XOR of the whole tree.Node v is not an ancestor of node r in the base tree. So, the subtree of node v will remain the same.Node v is an ancestor of node r in the base tree. What will be the new subtree of node v in this case? This is a bit tricky. Let's denote such a node c that is a child of node v and an ancestor of node r in the base tree. Then the new subtree of node v will contain the whole tree except the subtree (in the base tree) of node c.Let's say, inu is the XOR basis of all the values in node u's subtree (in the base tree). We can build inu by inserting the value au to inu and merging it with all of its children w's basis inw. Two basis can be merged in O(log2(d)) complexity, where d is their dimension. If we can build the basis inu for each node u, we are able to answer the case 1 and case 2. To answer case 2, we need to find the maximum subset XOR in the corresponding basis. To answer case 1, we need to do a similar thing in the basis inroot, where root is the root node of the base tree. 

For case 3, let's say outu is the XOR basis of all the values of the base tree except the node u's subtree (in the base tree). Then the answer of the case 3 will be the maximum subset XOR in the basis outc. To build the basis outu for each node u, we can utilize the properties of the discovery time du and finishing time fu. Which nodes will be outside the subtree of node u? The nodes w that have either dw<du or dw>fu. To merge their basis easily, we can pre-calculate two basis arrays pre[] and suf[] where the basis prei includes all the values of the nodes w such that dw≤i and the basis sufi includes all the values of the nodes w such that dw≥i. 

To find the node c in the case 3, we can perform a binary search on the children of node v. We can use the fact that the order of the discovery times follows the order of the children and a node c is only an ancestor of a node r iff dc≤dr && fc≥fr. 

Time complexity: O(n×log2(d)), where d=max(ai) 

Code1778F - Maximizing Root 

Tutorial1778F - Maximizing RootLet, xu be the value of node u and dp[u][d] be the minimum number of moves required to make the GCD of the subtree of u equal to a multiple of d. 

Now, dp[u][d]=0 if the subtree GCD of node u is already a multiple of d and dp[u][d]=∞ if (xu⋅xu) is not a multiple of d. 

For each divisor y of d, suppose, we want to perform the move on the subtree of u by multiplying each node value of the subtree with y iff (xu⋅y) is a multiple of d and y is a divisor of xu. In this case, we have to make the GCD of all the subtree of child nodes of u equal to a multiple of LCM(dy,y) before performing the move on the subtree of u. This is because we have to make each node of the subtree a multiple of dy to get the multiple of d after performing the move on the subtree of node u using y. Also, to perform the move of multiplying by y, the value of each subtree node should be a multiple of y. So we have to make each node value a multiple of LCM(dy,y). 

So, dp[u][d] will be calculated from dp[v][LCM(dy,y)] for each divisor y of d for all child v of u. 

Now, x1⋅D is the answer where D is the largest divisor of x1 such that k≥dp[1][D]. 

Time Complexity: O(n⋅m2) where m is the number of divisors of x1. 

Code 

Codeforces Round #848 (Div. 2) Editorial 

By adnan_toky, 3 weeks ago, In English1778A - Flip Flop Sum 

Tutorial1778A - Flip Flop SumLet's say we've chosen index i. What will happen? 

If the values of ai and ai+1 have opposite signs, flipping them won't change the initial sum.if ai = ai+1 = 1, flipping them will reduce the sum by 4.if ai = ai+1 = −1, flipping them will increase the sum by 4.So, for each i<n, we can check the values of ai and ai+1, and we can measure the effects on the sum based on the three cases stated above. Among the effects, take the one that maximizes the sum. 

Time complexity: In each test case, O(n)Code1778B - The Forbidden Permutation 

Tutorial1778B - The Forbidden PermutationIf the array a is good, the answer is obviously 0. Now, how can we optimally transform a not good array a to a good array? Let, we are on the index i (i<m) and x=ai, y=ai+1. If we observe carefully, we will find that there are basically two cases that will make the array a good: 

Move x and y in the permutation p in such a way that pos(y) becomes greater than pos(x)+d. To do that, in the permutation p, we can swap x to the left and y to the right. The total number of swaps needed is =d−(pos(y)−pos(x))+1. We need to check if there is enough space to the left of pos(x) and to the right of pos(y) to perform the needed number of swaps.Move x and y in the permutation p in such a way that pos(y) becomes smaller than pos(x). To do that, In the permutation p, we can simply swap y to the left until the condition is satisfied. The number of swaps needed is pos(y)−pos(x).For each i<m, calculate the minimum number of swaps needed among these two cases. The minimum number of swaps among all i<m will be the desired answer. 

Time complexity: In each test case, O(n)Code1778C - Flexible String 

Tutorial1778C - Flexible StringIf we can replace all the characters of the string a, we can transform the string a to the string b. So, replacing more characters is always beneficial. For a fixed string a and another fixed string b, if the answer is x1 for k1 and x2 for k2 (k1<k2), it can be shown that x1≤x2 always satisfies. 

That is to say, we can safely consider the size of the set q to be the maximum limit min(k,u) where u is the number of unique characters in the string a. Now, we can generate all possible sets of characters having size min(k,u). Obviously, we won't take the characters that are not present in the string a because they have no effect on the answer. There are many ways to generate the sets, like backtracking, bitmasking, etc. If we can calculate the number of valid pairs (l,r) for each set efficiently, the rest task will be just taking the maximum of them. 

To calculate the number of pairs for each set efficiently, we can observe the fact that if a[l,r]=b[l,r] is true, a[p,q]=b[p,q] satisfies for any l≤p≤q≤r. So, we will get c×(c+1)2 number of valid pairs from here where c=r−l+1. Now, we can start iterating from the beginning of the string a. We can say that ai matches bi if they are equal or ai exists in the currently generated set. 

While iterating, when we are on the jth index, we need to find the rightmost index r such that a[j,r]=b[j,r] satisfies. Then we need to add the number of valid pairs in this range to the contribution of this set. After that, we need to set the value of j to r+1 and repeat the steps again. The rest of the tasks are trivial. 

Time complexity: In each test case, O(n×(um)), where m=min(k,u)Code1778D - Flexible String Revisit 

Tutorial1778D - Flexible String RevisitLet k be the number of indices where the characters between two strings are different and f(x) be the expected number of moves to make two strings equal given that the strings have x differences. We have to find the value of f(k). 

For all x where 1≤x≤n−1, 

f(x)=xn⋅[1+f(x−1)]+n−xn⋅[1+f(x+1)]or, f(x)=1+xn⋅f(x−1)+n−xn⋅f(x+1)Now, f(0)=0 and f(1)=1+n−1nf(2). 

We can represent any f(i) in the form f(i)=ai+bi⋅f(i+1). 

Let, a1=1 and b1=n−1n. So, we can write f(1)=a1+b1⋅f(2). 

When 1<i<n, f(i)=1+in⋅f(i−1)+n−in⋅f(i+1). We can substitute the value of f(i−1) with ai−1+bi−1⋅f(i) and calculate the value of f(i). Thus we can get the value of ai and bi using the value of ai−1 and bi−1 by considering a1 and b1 as the base case. 

We get, ai=n+i⋅ai−1n−i⋅bi−1 and bi=n−in−i⋅bi−1 for 2≤i≤n. 

CalculationSimilarly, f(n)=1+f(n−1). 

We can represent any f(i) in the form f(i)=ci+di⋅f(i−1). 

Let, cn=1 and dn=1. So, we can write f(n)=cn+dn⋅f(n−1). 

When 1<i<n, f(i)=1+in⋅f(i−1)+n−in⋅f(i+1). We can substitute the value of f(i+1) with ci+1+di+1⋅f(i) and calculate the value of f(i). Thus we can get the value of ci and di using the value of ci+1 and di+1 by considering cn and dn as the base case. 

We get, ci=n+(n−i)⋅ci+1n−(n−i)⋅di+1 and di=in−(n−i)⋅di+1. 

CalculationNow, f(i)=ci+di⋅f(i−1) and f(i−1)=ai−1+bi−1⋅f(i). By solving these two equations, we find that f(i)=ci+di⋅ai−11−di⋅bi−1. 

Time Complexity: O(n⋅logm). 

Alternative SolutionCodeAlternative Code1778E - The Tree Has Fallen! 

Tutorial1778E - The Tree Has Fallen!At first, we can think of another problem. Given an array. You need to find the maximum subset XOR. How can we solve it? We can solve this problem very efficiently using a technique called "XOR Basis". You can read about it from here. 

In problem E, at first, we can fix any node as the root of the tree. Let's call this rooted tree the base tree. After that, start an Euler tour from the root and assign discovery time du and finishing time fu to each node u. In each query, three types of cases can occur (node r and node v are from the query format): 

r=v. In this case, we need to calculate the maximum subset XOR of the whole tree.Node v is not an ancestor of node r in the base tree. So, the subtree of node v will remain the same.Node v is an ancestor of node r in the base tree. What will be the new subtree of node v in this case? This is a bit tricky. Let's denote such a node c that is a child of node v and an ancestor of node r in the base tree. Then the new subtree of node v will contain the whole tree except the subtree (in the base tree) of node c.Let's say, inu is the XOR basis of all the values in node u's subtree (in the base tree). We can build inu by inserting the value au to inu and merging it with all of its children w's basis inw. Two basis can be merged in O(log2(d)) complexity, where d is their dimension. If we can build the basis inu for each node u, we are able to answer the case 1 and case 2. To answer case 2, we need to find the maximum subset XOR in the corresponding basis. To answer case 1, we need to do a similar thing in the basis inroot, where root is the root node of the base tree. 

For case 3, let's say outu is the XOR basis of all the values of the base tree except the node u's subtree (in the base tree). Then the answer of the case 3 will be the maximum subset XOR in the basis outc. To build the basis outu for each node u, we can utilize the properties of the discovery time du and finishing time fu. Which nodes will be outside the subtree of node u? The nodes w that have either dw<du or dw>fu. To merge their basis easily, we can pre-calculate two basis arrays pre[] and suf[] where the basis prei includes all the values of the nodes w such that dw≤i and the basis sufi includes all the values of the nodes w such that dw≥i. 

To find the node c in the case 3, we can perform a binary search on the children of node v. We can use the fact that the order of the discovery times follows the order of the children and a node c is only an ancestor of a node r iff dc≤dr && fc≥fr. 

Time complexity: O(n×log2(d)), where d=max(ai) 

Code1778F - Maximizing Root 

Tutorial1778F - Maximizing RootLet, xu be the value of node u and dp[u][d] be the minimum number of moves required to make the GCD of the subtree of u equal to a multiple of d. 

Now, dp[u][d]=0 if the subtree GCD of node u is already a multiple of d and dp[u][d]=∞ if (xu⋅xu) is not a multiple of d. 

For each divisor y of d, suppose, we want to perform the move on the subtree of u by multiplying each node value of the subtree with y iff (xu⋅y) is a multiple of d and y is a divisor of xu. In this case, we have to make the GCD of all the subtree of child nodes of u equal to a multiple of LCM(dy,y) before performing the move on the subtree of u. This is because we have to make each node of the subtree a multiple of dy to get the multiple of d after performing the move on the subtree of node u using y. Also, to perform the move of multiplying by y, the value of each subtree node should be a multiple of y. So we have to make each node value a multiple of LCM(dy,y). 

So, dp[u][d] will be calculated from dp[v][LCM(dy,y)] for each divisor y of d for all child v of u. 

Now, x1⋅D is the answer where D is the largest divisor of x1 such that k≥dp[1][D]. 

Time Complexity: O(n⋅m2) where m is the number of divisors of x1. 

Code 

Codeforces Round #847 (Div. 3) Editorial 

By Vladosiya, history, 4 weeks ago, translation, In English1790A - Polycarp and the Day of Pi 

Idea: MikeMirzayanov 

Tutorial[problem:1790A]In the problem, you had to find the largest common prefix(LCP) of the first 30 characters of the number π and the string n. To do this, we will go from the beginning and compare the characters until we find a non-matching one, or until the string n ends. 

Solution1790B - Taisia and Dice 

Idea: Gornak40 

Tutorial1790B - Taisia and DiceIt is easy to find the value on the cube that the cat stole, it is equal mx=s−r. All other values must be no more than mx. Let's try to get r by taking mx ⌊rmx⌋ times and adding the remainder there if it is non-zero. 

We could not get more than n−1 cubes this way, because otherwise (n−1)mx>r, but we are guaranteed that the answer exists. Now, until we get the n−1 cube, let's find the cube with the maximum value, reduce it by 1 and add the cube with the value of 1. 

We can definitely get n−1 dice, because otherwise r<n−1, but we are guaranteed that the answer exists. It remains only to add a cube with the value of mx to our n−1 cubes. 

We obtained a solution with O(n2) asymptotics. 

Solution1790C - Premutation 

Idea: MikeMirzayanov 

Tutorial[problem:1790C]When Kristina writes sequences on the whiteboard, she removes an element with each index exactly once. Thus, the first element of the permutation will be deleted only once — on the first step. All sequences except one will start with it 

To solve the problem, find a sequence pi such that: 

it starts with some element yall sequences other than this one begin with some element xThen this permutation will describe the sequence of numbers remaining after removing the 1th element, and the first element itself will be equal to the number x. The initial permutation will look like [x,y=pi1,pi2,…,pin]. 

Solution1790D - Matryoshkas 

Idea: MikeMirzayanov 

Tutorial1790D - MatryoshkasFirst, for each size, let's count cnts — the number of dolls of this size. 

Then, let's create a set, in which for each doll of size s we add the numbers s and s+1. This will allow you to process all the segments, as well as the dimensions adjacent to them. 

We will iterate over the set in ascending order of size. Let x be the number of matryoshkas of the current size, y — of the previous one considered (0 at the beginning). If the numbers do not match, then you need to close (if x<y), or open (if x>y) |x−y| segments. It is enough to add only the opening of the segments to the answer. 

Solution1790E - Vlad and a Pair of Numbers 

Idea: Vladosiya 

Tutorial1790E - Vlad and a Pair of NumbersConsider the answer by bits. We know that if the ith bit of the number x is zero, then these bits are the same for a and b, otherwise they differ. Then let's first make a=x, b=0. Note that a⊕b is already equal to x, but a+b2 is not yet. So we need to dial another x with matching bits, we will add them to both integers greedily, going from the highest bit to the lowest, skipping those bits that are already one in a. If after this algorithm a and b do not satisfy the conditions, then the answer is −1. In total, this solution works for O(logx). 

You can see that in the solution above, we actually just added x2 to both numbers, which could only be done with one set of bits, so if the answer exists, the pair a=3⋅x2fits, b=x2. 

Solution1790F - Timofey and Black-White Tree 

Idea: molney 

Tutorial1790F - Timofey and Black-White TreeLet's store for each vertex the minimum distance from it to the nearest black one, let's call it d[v]. We will also store the global answer, which for obvious reasons does not increase, we will call it ans. 

Let's now color the vertex ci, let's set d[ci]=0 and run a depth first search from it. This DFS will visit only the vertices v with d[v]<ans. Let us consider the vertex v and its neighbour u. If we can relax d[u] through d[v]+1, let's do it and start from u. Otherwise, u has a closer black neighbour, let's try to update the answer through it ans=min(ans,d[v]+1+d[u]). Also, do not forget to update the answer via d[v] from all black vertices v that we visited. 

The correctness of the algorithm is obvious, let's evaluate its time complexity. It is easy to notice that after the first ⌈n−−√⌉ operations, ans≤⌈n−−√⌉. We enter only the vertices, d from which, firstly, does not exceed ans, and secondly, was relaxed by the parent (that is, decreased by at least 1). 

So, we allowed ourselves a complete tree bypassing for the first ⌈n−−√⌉ operations, and then amortized performed no more than n⌈n−−√⌉ operations. The final asymptotics will be O(nn−−√). 

Solution1790G - Tokens on Graph 

Idea: DmitriyOwlet 

Tutorial1790G - Tokens on GraphLet's calculate the shortest paths to the finish along the vertices containing bonuses. 

We will try to reach the finish line with the chip that is closest to it, and mark it. If there is none, we lose. 

Other chips will give her extra moves. 

Find all connected components from vertices containing bonuses. Then, for each component, we find all the tokens that are not selected, located at the vertex of this component, and at the vertices adjacent to at least one vertex of this component. 

Consider the size of the connectivity component. If it is equal to 1, then the chip located in the neighboring vertex gives 1 an additional move. Otherwise, the chip located at the top of the component or at the neighboring vertex, as well as the selected chip, will be able to move indefinitely in turn, which gives us a victory. Otherwise, you need to count the number of extra moves and compare it with the shortest distance to the finish line. 

Solution 

Codeforces Round #846 (Div. 2) — Tutorial 

By AndreyPavlov, history, 4 weeks ago, translation, In English1780A - Hayato and School 

Idea: AndreyPavlovPreparation: AndreyPavlovEditorialist: AndreyPavlov 

TutorialNote that there are two variants of which numbers to take to make their amount odd: 3 odd number; 2 even and 1 odd. Let’s save all indices of even and odd numbers into two arrays, and check both cases. 

Implementation (Python)Implementation (C++)1780B - GCD Partition 

Idea: 74TrAkToRPreparation: qualdoomEditorialist: qualdoom 

TutorialLet's note that it doesn't make sense for us to divide into more than k=2 subsegments. Let's prove it. 

Let us somehow split the array a into m>2 subsegments : b1,b2,…,bm. Note that gcd(b1,b2,…,bm)≤gcd(b1+b2,b3,…,bm), since if b1 and b2 were multiples of gcd(b1,b2,…,bm), so b1+b2 is also a multiple of gcd(b1,b2,…,bm). This means that we can use b1+b2 instead of b1 and b2, and the answer will not worsen, thus it is always beneficial to use no more than k=2 subsegments. 

How to find the answer? Let s be the sum of the array a. Let's say prefi=∑ij=1aj, then the answer is max1≤i<n(gcd(prefi,s−prefi). 

Implementation (Python)Implementation (С++)1780D - Bit Guessing Game 

Idea: AndreyPavlovPreparation: qualdoom, AndreyPavlovEditorialist: qualdoom, AndreyPavlov 

TutorialThere are two similar solutions to this problem, we will tell you both. 

Tutorial (AndreyPavlov)Tutorial (qualdoom)Implementation (Python)Implementation (С++)1780E - Josuke and Complete Graph 

Idea: T4M0FEYPreparation: T4M0FEYEditorialist: T4M0FEY 

TutorialLet’s fix g and check that the g weight edge exists in G′. The first number, which is divided into g, starting with L — ⌈Lg⌉⋅g, and the second — (⌈Lg⌉+1)⋅g, note that their gcd is g, so the edge between these vertices weighs g. If the second number is greater R, the edge with weight g in the G′ doesn't exist, because on the segment from L to R at most one vertex, which is divided by g. That is, we should calculate the number of such g, which is (⌈Lg⌉+1)⋅g≤R. 

For g≥L: (⌈Lg⌉+1)⋅g=2⋅g. Get the upper limit on the g≤⌊R2⌋. That is, all g on segment from L to ⌊R2⌋ occur in the G′ as weight some edge. Add them to the answer. 

Look at g<L. 

Note that ⌈Lg⌉ takes a O(L−−√) of different values. Let's fix some f=⌈Lg⌉. Note that f corresponds to a consecutive segment l≤g≤r. Let's brute this segments in ascending order f. Then, if there is a left border l of the segment, you can find r either by binary search or by writing the formula. The next left border is r+1. Then note, if f is fixed, then (f+1)⋅g≤R is equivalent to g≤⌊Rf+1⌋. That is, with a fixed segment from l to r, g occurs in the G′ as weight some edge if l≤g≤min(r,⌊Rf+1⌋). Then brute all these segments and sum up of all good g. 

Overall time complexity is O(L−−√) or O(L−−√⋅log(L)). 

Implementation (Python)Implementation (С++)1780F - Three Chairs 

Idea: AndreyPavlovPreparation: AndreyPavlovEditorialist: qualdoom 

TutorialLet's sort the array and process the triples i,j,k, assuming that i<j<k and ai<aj<ak. Now if gcd(ai,ak)=1, then the number of ways to take the index j is k−i−1. 

We will consider the answer to the problem for each k from 1 to n, assuming that ak is the maximum number in the triple. Now let c be the number of numbers that are mutually prime with ak on the prefix from 1 to k−1, and sum is the sum of their indices. Then you need to add c⋅i−sum−c to the answer. 

It remains to find out the number of numbers that are mutually prime with ak and the sum of their indices. This can be done using the inclusion and exclusion method. Let cnti be the number of numbers aj that are divisible by i, si be the sum of the indices j of numbers aj that are divisible by i. Let's look at the prime numbers p1,p2,...,pm included in the factorization of the number ak. 

Then let c initially be equal to the number of numbers on the prefix, and sum to the sum of the indices on the prefix. Note that then we took into account the extra elements — numbers that are divisible by p1,p2,...,pm, since they will not be mutually simple with ak, we subtract them from c and sum. But having done this, we again took into account the extra elements that are multiples of the numbers of the form pi∗pj, where i≠j, add them back, etc. So we can iterate over the mask mask of the primes p1,p2,...,pm. And depending on the parity of the bits in the mask, we will subtract or add elements that are multiples of d, where d is the product of the primes included in mask. Having received c and sum, we can recalculate the answer for the position i. 

To move from position i to position i+1, update the values of cnt and s by adding the element ai−1 by iterating over the mask of the simple element ai−1. 

Implementation (С++)1780G - Delicious Dessert 

Idea: T4M0FEYPreparation: T4M0FEY, AndreyPavlovEditorialist: T4M0FEY, AndreyPavlov 

TutorialThis problem has several solutions using different suffix structures. We will tell two of them — using suffix array, and using suffix automaton. 

Suffix array (t4m0fey)Suffix automaton (AndreyPavlov)Implementation (t4m0fey)Implementation (AndreyPavlov) 

Codeforces Round #842 (Div. 2) Editorial 

By Vladithur, history, 2 months ago, In EnglishHope you liked the problems! 

(from thanhchauns2) Before the round starts1768A - Greatest Convex 

Author: thanhchauns2 

HintsTutorial1768A- Greatest ConvexIs x=k−1 always suitable? 

The answer is yes, as x!+(x−1)!=(x−1)!×(x+1)=((k−1)−1)!×((k−1)+1)=(k−2)!×(k), which is clearly a multiple of k. 

Therefore, x=k−1 is the answer. 

Time complexity: O(1)SolutionFeedback1768B - Quick Sort 

Author: Vladithur Preparation: Vladithur and Alexdat2000 

HintsTutorial1768B - Quick SortSuppose we can make operations so that x elements do not participate in any operation. Then these x elements in the final array will end up at the beginning in the order in which they were in the initial array. And since this x must be maximized to minimize the number of operations, we need to find the maximal subsequence of the numbers [1,2,…]. Let this sequence have w numbers, then the answer is ⌈n−wk⌉=⌊n−w+k−1k⌋. 

SolutionFeedback1768C - Elemental Decompress 

Author: thanhchauns2 

HintsTutorial1768C- Elemental DecompressTwo cases produce no answers: 

One element appears more than twice in a. 

After sorting, there is some index that a[i]<i (1-indexed). 

ProofOtherwise, solutions always exist. One method is to constructively attach each element in a to p or q: 

Traverse from the biggest element to the smallest in a, if that number haven't appeared in p then attach it to p, otherwise attach it to q. 

Traverse from the biggest element to the smallest in a again, if we attached it to p, find the biggest number that did not appear in q and attach to q, vice versa. 

A naive solution requires the O(n2) method to solve. We can reduce to O(nlogn) by sorting elements in a as pairs <element, index>. 

Time complexity: O(nlog(n))SolutionYet another better solutionFeedback1768D - Lucky Permutation 

Author: Vladithur Preparation: Vladithur and Alexdat2000 

HintsTutorial1768D - Lucky PermutationFor some fixed n, there are n−1 permutations that have exactly 1 inversion in them (the inversion is colored): 

2,1,3,4,…,n−1,n1,3,2,4,…,n−1,n1,2,4,3,…,n−1,n... 

1,2,3,4,…,n,n−1Let's build a directed graph with n vertices where the i-th vertex has an outgoing edge i→pi. It is easy to see that the graph is divided up into cycles of the form i→pi→ppi→pppi→…→i. 

Let cycles be the number of cycles in this graph. It is a well know fact that n−cycles is the minimum number of swaps needed to get the permutation 1,2,3,…,n from our initial one (in other words, to sort it). 

Suppose we now want to get the k-th permutation from the list above. Let x and y be such that px=k and py=k+1. 

Let us remove the edges x→k and y→k+1 from the graph and instead add the edges x→k+1 and y→k. Let cycles′ be the number of cycles in this new graph. The minimum number of swaps needed to get the k-th permutation in the list is equal to n−cycles′. 

Turns out that we can easily calculate cycles′ if we know cycles: 

cycles′=cycles+1 if the vertices k and k+1 were in the same cycle in the initial graph,cycles′=cycles−1 otherwise.To quickly check if two vertices u and v are in the same cycle, assign some id to each cycle (with a simple dfs or with a DSU) and the compare u-s cycle id with v-s cycle id. 

The answer is just the minimum possible value of n−cycles′ over all 1≤k≤n−1. 

Time complexity: O(n). 

PS: you can also find cycles′ with data structures (for example, by maintaining a treap for each cycle). 

SolutionFeedback1768E - Partial Sorting 

Author: thanhchauns2 

HintsTutorial1768E- Partial SortingWe need at most 3 operations to sort the permutation: 1−>2−>1For f(p)=0, there is only one case: the initially sorted permutation.Calculatereturn (38912738912739811 & 1) 

For f(p)≤1, this scenario appears when the first n numbers or the last n numbers are in the right places.CalculateBoth cases have n fixed positions, so there will be (2n!) permutations in each case. 

Intersection: since both cases share the n middle elements, (n!) permutation will appear in both cases. 

So there will be 2×(2n!)−(n!) such permutations. 

For f(p)≤2, this scenario appears when the smallest n elements' positions are in range [1,2n], or the largest n numbers' positions are in range [n+1,3n].CalculateIf the smallest n elements are all in position from 1 to 2n, then: 

There are Cn2n ways to choose n positions for these numbers. 

For each way to choose these positions, there are n! ways to choose the position for the smallest n numbers, and 2n! ways for the rest. 

The total number of valid permuations are: Cn2n×n!×2n!If the largest n elements are all in position from n+1 to 3n, we do the same calculation. 

Intersection: intersection appears when the first n numbers are all in range [1,2n] and the last n numbers are all in range [n+1,3n]. 

Let intersection = 0 

Sketch and calculation in detailsThe number of intersections will be equal to: ∑ni=0Cn−in×Cin×Cn2n−i×n!×n!×n!So, the answer will be 2×Cn2n×n!×2n!−∑ni=0Cn−in×Cin×Cn2n−i×n!×n!×n!For f(p)≤3, it will be the count of all valid permutations.Calculatereturn __factorial(n * __number_of_sides_of_a_triangle) 

Time complexity: O(n) 

SolutionFeedback1768F - Wonderful Jump 

Author: Vladithur Preparation: Vladithur and Alexdat2000 

HintsTutorial1768F - Wonderful JumpThere is a very easy O(n2) dp solution, we will show one possible way to optimize it to O(n⋅A−−√), where A is the maximum possible value of ai. 

Let dpk be the minimum number of eris required to reach index k, dp1=0. 

Suppose we want to calculate dpj and we already know dp1,dp2,…,dpj−1. Let's look at our cost function more closely. 

We can notice that it is definitely not optimal to use the transition i→j if min(ai…aj)⋅(j−i)2>A⋅(j−i). That is, it will be more optimal to perform j−i jumps of length 1. 

Transforming this inequality, we get j−i>Amin(ai…aj). So if min(ai…aj) is quite large, we only need to look at a couple of i close to j, and then do something else for the small values of min(ai…aj). 

1. min(ai…aj)≥A−−√To handle this case, we can just iterate over all i from max(j−A−−√,1) to j−1, since the transition i→j could be optimal only if j−i≤Amin(ai…aj)≤A−−√. 

Time complexity: O(A−−√). 

2. min(ai…aj)<A−−√Another useful fact is that if there exists an index k such that i<k<j and ak=min(ai…aj), the transition i→j also cannot be optimal, since i→k followed by k→j will cost less. 

Proof:min(ai…aj)⋅(j−i)2>min(ai…ak)⋅(k−i)2+min(ak…aj)⋅(j−k)2ak⋅(j−i)2>ak⋅(k−i)2+ak⋅(j−k)2(j−i)2>(k−i)2+(j−k)2This leaves us two subcases two handle. 

2.1 min(ai…aj)=aiJust maintain the rightmost occurrences <j of all values from 1 to A−−√. Time complexity: O(A−−√). 

2.2 min(ai…aj)=ajInitially set i to j−1 and decrease it until ai≤aj becomes true. Time complexity: O(A−−√) amortized. 

Total time complexity: O(n⋅A−−√)SolutionShorter solution (tfg)Feedback 

Codeforces Round #841 (Div. 2) and Divide By Zero 2022 Editorial 

By s_jaskaran_s, history, 2 months ago, In EnglishUPD: Code links are working now 

1731A - Джо нужны деньги 

Idea: s_jaskaran_s 

HintSolution1731A - Joey Takes MoneyIf we take two elements a1 and a2 and do the operation on it as a1⋅a2=x⋅y, then it is easy to observe that x+y will attain its maximum value when one of them is equal to 1. So, the solution for this is x=1 and y=a1⋅a2. 

Let n be the total number of elements and P (P=a1⋅a2⋅…⋅an) be the product of all elements. 

Now if we do the above step for every pair of elements, then the maximum value of the sum is achieved when a1=1, a2=1, …, an−1=1 and an=P. 

In the final array, assign P to a1 and assign 1 to all the remaining elements a2,a3,…an. 

So, our answer is simply P+n−1 multiplied by 2022, of course. 

Time complexity: O(n). 

Code1731B - Уничтожение демодогов 

Idea: s_jaskaran_s 

HintSolution1731B - Уничтожение демодоговTo kill the maximum number of demodogs, El can travel in zigzag fashion, i.e. from (1,1) to (1,2) to (2,2) and so on. Thus the answer would be the sum of elements at (1,1), (1,2), (2,2) … (n,n). i.e. the answer is∑i=1ni⋅i+∑i=1n−1i(i+1)=n(n+1)(4n−1)6. 

And the answer you need to print is2022n(n+1)(4n−1)6=337⋅n(n+1)(4n−1)(mod109+7)Proof: 

Let killsi,j be the maximum number of kills of all possible paths from (1,1) to (i,j). 

killsn−1,n−1≥killsi,n−1 + number of demodogs from (i+1,n−1) to (n−1,n−1) (∀i∈[1,n−2]). 

killsn−1,n−1≥killsi,n−1+∑j=i+1n−1j⋅(n−1)killsn−1,n−1≥killsi,n−1+(n−1−i)((i+1)(n−1)+(n−2−i)(n−1))2 (sum of A.P.)killsn−1,n−1≥killsi,n−1+(n−1−i)(n−1)22 (1)Let killsZ be the number of kills if El travels in zigzag fashion, i.e. she goes to (n,n) after passing through (n−1,n−1):killsZn,n=killsn−1,n−1+n(n−1)+n⋅nLet killsNZ be the maximum number of kills If El goes to (n,n) after passing through (i,n) for some i in range of [1…n−1], i.e. El goes from (1,1) to (i,n−1) to (i,n) to (n,n):killsNZn,n=killsi,n−1+no of demigods from (i,n) to (n,n)killsNZn,n=killsi,n−1+∑j=inj⋅nkillsNZn,n=killsi,n−1+(n+1−i)(n+i)n2killsZn,n−killsNZn,n=killsn−1,n−1+n(n−1)+n⋅n−killsi,n−1−(n+1−i)(n+i)n2 from (1)killsZn,n−killsNZn,n≥killsi,n−1+(n−1−i)(n−1)22+n(n−1)+n⋅n−killsi,n−1−(n+1−i)(n+i)n2killsZn,n−killsNZn,n≥2n2−3n−n⋅i−i−12killsZn,n−killsNZn,n≥0since 2n2−3n−n⋅i−i−1≥0 for all i∈[1,n−2]. 

In other words, killsZn,n≥killsNZn,n Therefore zigzag path guarantees maximum number of demodog kills. 

Now, the last thing was taking the modulus. Modulus should always be taken after every multiply operation to avoid the overflow. You can refer to modular arithmetic for more details. 

And the main reason we told you to multiply the answer by 2022 is that we needed to divide it by 6. For division, we have to take inverse modulo in modular arithmetic. So, in order to avoid that, we gave you a multiple of 6, which is 2022. 

Code1731C - Четные подмассивы 

Idea: ka_tri 

Hint 1Hint 2Hint 3Solution1731C - Четные подмассивыLet's calculate the number of subarrays whose XOR sum has an odd number of divisors and subtract them from total no of subarrays. 

Note: A number has an odd number of divisors only if it is a perfect square. So we have to calculate number of subarray having XOR sum a perfect square. 

For the given constraints for elements in the array, the maximum possible XOR sum of any subarray will be less than 2n, so the number of possible elements with odd divisors ≤2n−−√. Number of subarrays with a given XOR sum can be calculated in O(n). 

Therefore, calculate the same for each perfect square less than 2n and add all these to get the number of subarrays whose XOR sum has an odd number of divisors. Subtract from total number of subarrays to get the required answer. 

Time complexity : O(n⋅n−−√). 

Code(C++)Code(Python)1731D - Новая карта Valiant 

Idea: s_jaskaran_s 

Hint 1Hint 2Hint 3Solution1731D - Valiant's New MapThe basic brute force solution for this problem was to just iterate through all the values of sides possible. Note that the value of sides can range only from 1 to 1000 as product of n⋅m can't exceed 106, so there can't be a cube having all sides greater than 1000. After setting side length (let's say s) we look into all possible submatrices of dimensions s×s and see if we can form a cube from any one of those. This could only be possible if there exists a submatrix with its minimum ≥s. 

Now, we need to do all these operations efficiently, looking at the constraints. The main thing that we need to do is Binary search on the answer. As obviously, it is possible to make a cube with a smaller side if it is possible to make the one with the current side length. 

Now from here, we have two different approaches - 

Sparse Table - For a particular side s, check for all submatrices of size s×s, if their minimum is greater than equal to s. If you find any such submatrix, then this value of side is possible. A minimum can be calculated in O(1) using sparse tree. You might have tried using segment tree, which takes logm⋅logn time per query. But it may not to pass with these constraints. 

So, the time complexity to solve this problem is O(n⋅m⋅log(min(n,m))). It would pass these constraints. 

Another O(n⋅m⋅min(n,m)) solution where you don't use binary search is also there but would fail with these constraints. The segment tree solution takes O(n⋅m⋅logn⋅logm⋅log(min(n,m))) . So, only sparse tree can be used. 

Prefix Sum - This is a much simpler solution. First, we create another n×m matrix, let's say B. Now, for a particular side length s, we take all the indices where the building heights are greater than equal to s and set the elements of B at those indices to 1. Other elements are set to 0. 

Now we precalculate the prefix sum for this matrix. Then for each index (i,j) of the matrix B, we check if the square starting from that index has a prefix sum equal to s2. If anyone of it does, then this side length for the cube is possible. 

Time Complexity is again O(n⋅m⋅log(min(n,m))). 

Code(Prefix Sum)Code(Sparse Table)1731E - Стоимость графа 

Idea: s_jaskaran_s 

Hint 1Hint 2Solution1731E - Graph CostIn each step, adding e edges to the graph with weights e+1 costs one more than the number of edges added. So, the total cost of adding m edges in s steps will be m+s. Since the number of edges is given, i. e. fixed, to find the minimum cost, we need to minimize the number of steps. 

Firstly, let's calculate the number of pairs (x,y) where 1≤x<y≤n with gcd(x,y)=k for each k∈[1..n] in O(nlogn) time. It can be solved in a standard way using the Möbius function μ(x) or using Dynamic Programming, where dp[k] is the required number that can be calculated as: 

dp[k]=12⌊nk⌋(⌊nk⌋−1)−dp[2k]−dp[3k]−⋯−dp[⌊nk⌋k]Knowing all dp[k] we can calculate the maximum number of steps s[k] we can perform using edges of weight k. And s[k]=⌊dp[k]k−1⌋. 

Note that array s[k] is non-increasing (s[k]≥s[k+1]) and if we have at least one pack of size x then we have at least one pack of each size y where 1≤y<x. So, our task is an "extension" of the task where you need to take a subset of 1,2,…,n of minimum size with sum equal to m and can be solved with the same greedy strategy. 

Let's just take packs greedily, starting from weight n down to weight 2. We'll take packs as many packs as possible. For a fixed weight k we can calculate the maximum number of packs we can take as min(s[k],m′k−1). 

If m edges can't be constructed, then we return −1. Otherwise, we return m+s where s is the total number of packs. 

Time Complexity: O(nlogn)Code1731F - Сумма функций 

Idea: nishkarsh and s_jaskaran_s 

Solution1731F - Function SumLet's try to write a brute force solution of this using combinatorics. Let's say that a[i]=t now we will try to see that in how many permutations this is contributing towards the answer. Using combinatorics, it can be calculated asF(t)=t⋅∑i=1n∑x=0i−1∑y=x+1n−i((i−1x)(t−1)x(K+1−t)i−1−x⋅(n−iy)(K−t)y⋅tn−i−y). 

Here x represents lsl(i) and y represents grr(i). 

LetP(u)=∑t=1uF(t)be a polynomial whose degree will be ≤n+2. And now our answer will be P(k). 

Now, we can evaluate this polynomial for smaller values (by brute force) and will use the technique of polynomial interpolation to find the answer. 

Code 

Codeforces Round #840 (Div. 2) and Enigma 2022 — Cybros LNMIIT Editorial 

By SoCloseButStillSoFar, 2 months ago, In EnglishWe hope you liked the problems! Unfortunately, problem C turned out to be harder than usual. Please read its editorial, we hope you'll find that the intended solution is not that hard. 

1763A - Absolute MaximizationIdea: DreadArceusPrepared by: DreadArceus 

Hint 1Hint 2Need more hints?SolutionIn the minimum element, we want to make every bit 0 when possible, it won't be possible to set a particular bit to 0 when that bit is set in all the elements of a. Therefore, the minimum value we can achieve after performing the operations is the bitwise AND of all the elements of a. 

In the maximum element, we want to make every bit 1 when possible, it won’t be possible to set a particular bit to 1 when that bit is not set in any of the elements of a. Therefore, the maximum value we can achieve after performing the operations is the bitwise OR of all the elements of a. 

Therefore the answer is (OR of the array — AND of the array). 

Time Complexity: O(n)1763B - IncinerateIdea: og_Prepared by: og_ 

Hint 1Hint 2Solution 1Sort the monsters in ascending order of their powers. 

Now we iterate through the monsters while maintaining the current attack power and the total damage dealt. 

Only the monsters with health greater than the total damage dealt are considered alive, and every time we encounter such a monster it will be the weakest one at the current time, thus we need to attack until the total damage dealt exceeds the current monster's health while lowering our attack power by its power each time. 

If we can kill all the monsters in this way, the answer is YES, otherwise it is NO. 

Time Complexity: O(nlogn)Sort by power solutionSolution 2Sort the monsters in ascending order of their health. 

Now we maintain a count of monsters alive after each attack. This could be achieved by applying upperbound() on h array for each attack. The total damage dealt could be stored and updated in a separate variable. 

To find the power of the weakest monster alive, we could just precompute the minimum power of monsters in a suffix array. In other words, 

pi=min(pi,pi+1).Time Complexity: O(nlogn)Sort by health solution1763C - Another Array ProblemIdea: .utk.Prepared by: .utk. 

Hint 1Hint 2SolutionLet’s first consider the case for n≥4. The key observation to make here is that we can make all the elements of a subarray al,...ar zero by applying the operation on range [l,r] twice. Then let’s assume the maximum element mx of the array is at an index m>r. We can apply the operation on the range [l,m] and turn all its elements into mx. 

Using the above information we can see that to achieve the final array with maximum sum we need to make all the elements in it equal to the maximum element in the array. Regardless of the given array this can be achieved by making the last two elements (n-1,n) zero. Then applying the operation on subarray [m,n] to make all its elements equal to mx. Then making the first two elements (1,2) zero and applying the operation on the whole array making all the elements equal to mx. Thus the maximum sum for the final array will always be n∗mx. (In case m=n−1 or n, we can operate on the left side first to reach the same solution). 

For n=2 the maximum final sum would be max(a1+a2,2∗(|a1−a2|)). 

For n=3, when the maximum element is present at index 1 or 3 we can make all the elements of the array into mx. When the maximum element is at index 2, we have the following options. 

Case 1: We can apply the operation on (1,2), then we can convert all the elements of the array into max(a3,|a2−a1|). 

Case 2: We can apply the operation on (2,3), then we can convert all the elements of the array into max(a1,|a2−a3|). 

Case 3: We can apply the operation on (1,3) making all the elements in the array |a1−a3|. This is redundant since a2>a1,a3 either case 1 or case 2 will give a larger sum as a2−min(a1,a3)>max(a1,a3)−min(a1,a3). 

Now considering case 1, if 3∗max(a3,|a2−a1|)≤a1+a2+a3 the maximum sum possible would be the current sum of the array (see sample 1 and 3). Therefore no operations are required. Similar case for case 2. 

So the maximum possible sum for n=3 will be max(3∗a1,3∗a3,3∗|a1−a2|,3∗|a3−a2|,a1+a2+a3). 

To avoid doing this casework for n=3, we can see that there are only 3 possible operations -> (1,2) , (2,3), (1,3). We will be required to perform operations (1,2) and (2,3) at most two times. So we can brute force all possible combinations of operations [(1,2),(1,2),(2,3),(2,3),(1,3)] to find the maximum sum. 

Brute force solutionCase work solution1763D - Valid Bitonic PermutationsIdea: warksPrepared by: warks 

Hint 1Hint 2Hint 3SolutionFor simplicity, if x>y, perform i′=n−j+1, j′=n−i+1, x′=y, and y′=x. Hereafter, the variables i, j, x, and y, will refer to these values. Now, i<j and x<y. 

For now, assume that y<n. We shall consider the case where y=n at a later stage.Let us consider solving the problem for fixed k. Valid values for k are [2,i−1], [i+1,j−1], [j+1,n−1].If we think about it, when x<y, k cannot lie in the range [2,i−1]. So, we can discard them as possible values for k. 

Let us consider the case where k belongs to [i+1,j−1].The permutation adheres to the following pattern: B1<..<Bi=x<..<Bk=n>..>Bj=y>..>Bn. 

Numbers to the left of i must lie in the range [1,x−1]. We choose i−1 elements from [1,x−1] and place them to the left of i. There are (x−1i−1) ways to do this. The remaining x−i elements from [1,x−1] lie to the right of j by default.Numbers to the right of j must lie in the range [1,x−1] or [x+1,y−1]. Since numbers in the range [1,x−1] have already been placed, therefore, we choose numbers in the range [x+1,y−1], and place them in the n−j−(x−i) remaining positions. There are (y−x−1n−j−(x−i)) ways to do this. The remaining elements in the range [x+1,y−1] lie between i and k by default.Numbers between k and j must lie in the range [y+1,n−1]. We choose j−k−1 elements from [y+1,n−1] and place them between k and j. There are (n−y−1j−k−1) ways to do this. Afterwards, the remaining elements in the range lie between i and k by default, and the permutation is full.Multiplying the ways for the above three actions, we get that the answer for a fixed k, when between i and j as:(x−1i−1)∗(y−x−1n−j−(x−i))∗(n−y−1j−k−1)Let us consider the case where k belongs to the range [j+1,n−1].The permutation adheres to the following pattern: B1<..<Bi=x<..<Bj=y<..<Bk=n>..>Bn. 

Similar to above, the numbers to the left of i must lie in the range [1,x−1]. We choose i−1 elements from [1,x−1], and place them to the left of i. The remaining x−i elements from [1,x−1] lie to the right of k by default.Numbers between i and j must lie in the range [x+1,y−1]. We choose j−i−1 elements from [x+1,y−1] and place them between i and j. There are (y−x−1j−i−1) ways to do this, and the remaining elements from [x+1,y−1] lie to the right of k by default.Numbers between j and k must lie in the range [y+1,n−1]. We choose k−j−1 elements from [y+1,n−1] and place them in these positions. Afterwards, the remaining elements in the range get placed to the right of k by default, and the permutation is full.Multiplying the ways for the above three actions, we get the answer for a fixed k, when between j+1, and n−1 as:(x−1i−1)∗(y−x−1j−i−1)∗(n−y−1k−j−1)The answer to the problem is the sum of individual answers for all iterated values of k. 

ans=(x−1i−1)∗(y−x−1n−j−(x−i))∗∑j−1k=i+1(n−y−1j−k−1) + (x−1i−1)∗(y−x−1j−i−1)∗∑n−1k=j+1(n−y−1k−j−1)Let us now consider the case where y=n.The permutation adheres to the following pattern: B1<..<Bi=x<..<Bj=Bk=n>..>Bn. 

Again, the numbers to the left of i must lie in the range [1,x−1]. We choose i−1 elements from [1,x−1] and place them to the left of i. The remaining x−i elements from [1,x−1] lie to the right of j (here, k) by default.Numbers between i and j must lie in the range [x+1,y−1]. We choose j−i−1 elements form [x+1,y−1] and place them between i and j. The remaining elements from [x+1,y−1] lie to the right of j (here, k) by default, and the permutation is full.Multiplying the ways for the above two actions, we get the answer for k=j (y=n) as:(x−1i−1)∗(y−x−1j−i−1)With O(nmax∗log(109+7−2)) precomputation for factorials and their modular inverses, each individual test can be solved as above in O(n). Therefore, the overall complexity of this approach is O(nmax∗log(109+7−2)+t∗n), but the constraints allowed for slower solutions as well. 

Bonus: Can you solve the problem when 1≤t,n≤105. 

Code1763E - Node PairsIdea: crimsonredPrepared by: ...nvm, DreadArceus, crimsonred 

Hint 1Hint 2SolutionFor two nodes u and v to be reachable from each other, they must lie in the same strongly connected component (SCC). Let's define f(i) as the minimum number of nodes required to construct an i-reachable graph. We can use dynamic programming and calculate f(i) as f(i)=min(f(i—s(s—1)2)+s) over all the valid SCC sizes s for which s(s—1)2≤i, i.e., over those s which have less pairs of the required type than i. Thus, f(p) gives us the minimum number of nodes required to create a p-reachable graph. 

In all p-reachable graphs with f(p) nodes, the upper bound on the number of unidirectional pairs of nodes is (f(p)2)−p, because we have exactly p pairs of nodes which are reachable from each other. It is possible to achieve this upper bound using the following construction: let s1,s2,…,sk be any sequence of SCC sizes which agrees with the dp values we calculated earlier. Let the first SCC contain the nodes [1,s1], the second one contain [s1+1,s1+s2], and so on. We add a directed edge from u to v if u<v. 

Time Complexity: O(pp–√)Code1763F - Edge QueriesIdea: ...nvm, DreadArceusPrepared by: ...nvm, DreadArceus 

Hint 1Hint 2Hint 3Hint 4SolutionFirst, let us see examples of graphs that are valid or invalid according to the statement. 

Valid Graph ExampleInvalid Graph ExampleThe queries ask us to count all non-bridge edges in any simple path from u to v. 

There are many ways to proceed with the solution. We will first go into a simple one that gives more insight into the problem. 

We can see our graph as a tree of BiConnected Components (BCCs). 

The edges of the tree are all bridges.Let’s define a few things before continuing further. 

The first node of a BCC that is visited in the DFS tree will represent that BCC.Let rep[u] be the representative of the BCC of node u.cnt[u] be the number of edges in the BCC of u.Root node of our tree of BCCs is root.lca(u,v) is the lowest common ancestor of u and v.With all that set, let us now look at the DFS tree. 

We can build an array dp to store the answer to query(root,u), for all u, and to answer queries, we can use LCA. 

In a typical LCA use case, query(u, v) would be dp[u]+dp[v]−2∗dp[lca(u,v)], But is that the case here? 

Let us bring attention to a few things. 

FirstSecondThirdIn conclusion, in this setup, we need to determine how the simple paths from u to v cross through the BCC of lca(u,v), then the queries will be answered. 

How to distinguish?Or make a better graph to deal with this… 

Codeforces Round #839 (Div. 3) Editorial 

By awoo, history, 2 months ago, In English1772A - A+B? 

Idea: BledDest 

Tutorial1772A - A+B?There are multiple ways to solve this problem. 

Most interpreted languages have some function that takes the string, evaluates it as code, and then returns the result. One of the examples is the eval function in Python. If the language you use supports something like that, you can read the input as a string and use it as the argument of such a function. 

Suppose you use a language where this is impossible. There are still many approaches to this problem. The most straightforward one is to take the first and the last characters of the input string, calculate their ASCII codes, and then subtract the ASCII code of the character 0 from them to get these digits as integers, not as characters. Then you can just add them up and print the result. 

Solution (BledDest)1772B - Matrix Rotation 

Idea: BledDest 

Tutorial1772B - Matrix RotationSure, you can just implement the rotation operation and check all 4 possible ways to rotate the matrix, but it's kinda boring. The model solution does the different thing. 

If a matrix is beautiful, then its minimum is in the upper left corner, and its maximum is in the lower right corner (and vice versa). If you rotate it, the element from the upper left corner goes to the upper right corner, and the element from the lower right corner goes to the lower left corner — so these elements are still in the opposite corners. No matter how many times we rotate a beautiful matrix, its minimum and maximum elements will be in the opposite corners — and the opposite is true as well; if you have a 2×2 matrix with minimum and maximum elements in opposite corners, it can be rotated in such a way that it becomes beautiful. 

So, all we need to check is that the minimum and the maximum elements are in the opposite corners. There are many ways to do it; in my opinion, the most elegant one is to read all four elements in an array of size 4; then the opposite corners of the matrix correspond either to positions 0 and 3, or to positions 1 and 2 in this array. So, we check that the sum of positions of minimum and maximum is exactly 3. 

Solution (BledDest)1772C - Different Differences 

Idea: BledDest 

Tutorial1772C - Different DifferencesWe can transform the problem as follows. Let di=ai+1−ai. We need to find an array [d1,d2,…,dk−1] so that the sum of elements in it is not greater than n−1, all elements are positive integers, and the number of different elements is the maximum possible. 

Suppose we need f different elements in d. What can be the minimum possible sum of elements in d? It's easy to see that d should have the following form: [2,3,4,…,f,1,1,1,…,1]. This array contains exactly f different elements, these different elements are as small as possible (so their sum is as small as possible), and all duplicates are 1's. So, if the sum of this array is not greater than n−1, then it is possible to have the number of different elements in d equal to f. 

The rest is simple. We can iterate on f, find the maximum possible f, construct the difference array, and then use it to construct the array a itself. 

Solution (BledDest)1772D - Absolute Sorting 

Idea: BledDest 

Tutorial1772D - Absolute SortingWhat does it actually mean for an array a1,a2,…,an to be sorted? That means a1≤a2 and a2≤a3 and so on. 

For each pair of adajacent elements, let's deduce which values x put them in the correct order. Any value of x that puts all pairs in the correct order will be the answer. 

Consider any ai and ai+1 and solve the inequality |ai−x|≤|ai+1−x|. If ai=ai+1, then any value of x works. Let ai be smaller than ai+1. 

If x is smaller than or equal to ai, then the inequality becomes ai−x≤ai+1−x⇔ai≤ai+1. Thus, they don't change their order, and any x≤ai works. 

If x is greater than or equal to ai+1, then the inequality becomes x−ai≤x−ai+1⇔ai≥ai+1. Thus, they always change their order, and none of x≥ai work. 

If x is between ai and ai+1, then the inequality becomes x−ai≤ai+1−x⇔2x≤ai+ai+1⇔x≤ai+ai+12. Thus, they only remain in the same order for any integer x such that ai≤x≤⌊ai+ai+12⌋. 

In union, that tells us that all values of x that work for such a pair are x≤⌊ai+ai+12⌋. 

The similar analysis can be applied to ai>ai+1, which results in the required x being x≥⌈ai+ai+12⌉ for such pairs. 

Finally, how to find out if some value of x passes all conditions? Among all conditions of form x≤vali, in order for some x to work, it should be less than or equal to even the smallest of them. Similarly, among all conditions of form x≥vali, in order for some x to work, it should be greater than or equal to even the largest of them. 

Thus, take the minimum over the pairs of one type. Take the maximum over the pairs of another type. If two resulting values are contradictory, then there is no answer. Otherwise, any value inside the resulting range of x works. 

Overall complexity: O(n) per testcase. 

Solution (BledDest)1772E - Permutation Game 

Idea: BledDest 

Tutorial1772E - Permutation GameNote that it makes no sense to use the first type of operation if it does not lead to an instant win, because the opponent can return the previous state of the array with their next move. 

So the winner is the one who has time to color "their" elements in blue first. Let's denote a as the number of elements that only the first player needs to color, b as the number of elements only the second player needs to color, c — both players needs to color. 

To win, the first player needs to have time to paint a+c elements, and they have no more than b moves to do it, because otherwise the second player can prevent the win of the first player. So the winning condition for the first player is a+c≤b. Similarly, for the second player, with the only difference that they have 1 move less (because they go second), which means the condition is b+c<a. If none of these conditions are met, then neither player has a winning strategy, which means they will both reduce the game to a draw. 

Solution (Neon)1772F - Copy of a Copy of a Copy 

Idea: BledDest 

Tutorial1772F - Copy of a Copy of a CopyNotice the following: once you apply the recolor operation to some cell, you can never recolor it again. That happens because you can't recolor its neighbors too as each of them has at least one neighbor of the same color — this cell itself. 

In particular, that implies that applying a recolor operation always decreases the possible number of operations that can be made currently. It doesn't always decrease them by 1: from 1 to 5 operations can become unavailable, but it always decreases. 

That gives us an order of copies. Just sort them in the decreasing order of the number of recolor operations that can be made currently. If the numbers are the same, the copies must be equal, so their order doesn't matter. 

The only thing remains is to apply the operations. Turns out, their order doesn't matter at all. Consider all different cells for a pair of adjacent pictures. It's never possible that there are two different cells that are adjacent to each other. Thus, no operation can interfere with another one. Just print all positions of different cells in any order you want and make a copy. 

Overall complexity: O(nmk+klogk). 

Solution (awoo)1772G - Gaining Rating 

Idea: BledDest 

Tutorial1772G - Gaining RatingAfter parsing the statement, you can understand that Monocarp plays cyclically: in one cycle, he chooses some order of opponents and play with them in that order. Then repeats again and again, until he gains desired rating at some moment. 

So, firstly, let's prove that (in one cycle) it's optimal to play against opponents in increasing order of their skills. Suppose you play with opponents in some order ord and there is a position where a[ordi]>a[ordi+1], if you swap ordi and ordi+1 you won't lose anything and may even gain extra wins. It means that the total gain after playing one cycle in increasing order in greater or equal than playing in any other order. 

In other words, we can sort array a and play against them cyclically in that order. Monocarp's list of games will look like several full cycles and some prefix. The problem is that there can be many cycles, and we need to skip them in a fast way. 

How one cycle looks? Monocarp starts with some x wins first p games and then loses all other games (m games where m=n−p). The maximum rating he gains is x+p and the resulting rating after all games is x+p−m. 

We can already find several conditions of leaving a cycle: if x+p≥y then Monocarp gets what he wants and stops; otherwise, if x+p−m≤x (or p−m≤0) he will never gain the desired rating, since in the next cycle the number of wins p′≤p, since his starting rating x+p−m≤x. 

Otherwise, if x+p<y and p−m>0, he will start one more cycle with rating x′=x+p−m and will gain the desired rating y, eventually. So, how to find the number of games p he will win for a starting rating x? 

Let's calculate two values for a given sorted skill array a: for each i let's calculate ti — the minimum starting rating Monocarp need to win opponent i (and all opponent before) and bi — the rating he'll get after winning the i-th opponent. 

We can calculate these values in one iteration (we'll use 0-indexation): t0=a0, b0=a0+1; then for each i>0 if bi−1≥ai then ti=ti−1 and bi=bi−1+1, otherwise ti=ai−i and bi=ai+1. 

Now, knowing values ti it's easy to find the number of wins p for a starting rating x: p is equal to minimum j such that tj>x (don't forget, 0-indexation). Or the first position in array t with value strictly greater than x. We can search it with standard upper_bound function, since array t is sorted. 

Okay, we found the number of wins p for the current x. Let's just calculate how many cycles k Monocarp will make with exactly p wins. There are only two conditions that should be met in order to break this cycle: either Monocarp reaches rating y — it can be written as inequality x+k(p−m)+p≥y, or the number of wins increases (starting rating becomes greater or equal than tp), i.e. x+k(p−m)≥tp. 

From the first inequality, we get minimum k1=⌈y−x−pp−m⌉ and from the second one — k2=⌈tp−xp−m⌉. As a result, we can claim that Monocarp will repeat the current cycle exactly k=min(k1,k2) times and either finish in the next turn or the number of wins will change. 

So, we can skip these k equal cycles: we can increase answer by kn and current rating by k(p−m). Since we skip equal cycles, then at each step we either finish (with success or −1), or the number of wins p increases. Since p is bounded by n, we will make no more than n skips, and total complexity is O(nlogn) because of initial sorting and calls of upper_bound. 

Solution (adedalic) 

Codeforces Round #838 (Div. 2) Editorial 

By satyam343, 2 months ago, In EnglishThank you for participation! I hope you liked atleast one problem from the set (: 

We tried hard to have an interesting problemset. 

It is sad to see people disliking the round only because some problems were hard. Please read the intended solutions to know why we decided to put the problems(especially D) at current positions. 

1762A - Divide and Conquer 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionWe are assuming initial sum is odd. Suppose f(x)(1≤x≤106) gives the minimum number of operations needed to change parity of x. 

Iterate from i=1 to n and calculate f(ai) for each i. 

Answer is minimum among all the calculated values. 

Time complexity is O(n⋅log(Amax)). 

Code1762B - Make Array Good 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionSuppose f(x) gives the smallest power of 2 which is greater than x. 

Iterate from i=1 to n and change ai to f(ai) by adding f(ai)−ai to i-th element. 

Time complexity is O(n⋅log(Amax)). 

Code1762C - Binary Strings are Fun 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionNow we know how to solve for whole string s. 

We can similarly solve for all prefixes. 

To find f(s[1,i]), we need to find the longest suffix of s[1,i] containing same character. 

We can easily calculate this all prefixes while moving from i=1 to n. 

Time complexity is O(n). 

Code1762D - GCD Queries 

Idea:amurto Prepared by:errorgorn 

Hint 1Hint 2Hint 3SolutionSo suppose we have three distinct indices i, j and k. 

Let us assume l=query(i,k) and r=query(j,k)Now we have only three possibilities. 

l=r In this case, pk cannot be 0. Why? pi and pj are distinct, and we have gcd(0,x)≠gcd(0,y) if x≠yl>r In this case, pj cannot be 0. Why? Note gcd(0,pk)=pk and gcd(m,pk) can be atmost pk for any non negative integer. If l>r, this means r cannot be pk. Thus pr≠0 for surel<r In this case, pi cannot be 0. Why? Refer to the above argument.This we can eliminate one index on using 2 queries. We will perform this operation n−2 times. Refer to attached code for details. 

Time complexity is O(n). 

Code1762E - Tree Sum 

Idea:satyam343 Improved by:TheScrasse 

Hint 1Hint 2Hint 3SolutionTime for one more interesting claim. The weight of edge e is (−1)l if there are l nodes on one side and n−l nodes on other side of e, irrespective of the structure of tree. 

We can prove this claim by induction, similar to what we did in hint 3. 

To find answer we will look at contribution of each edge. 

Here's detailed explanation on how to dot it. 

In total, we have nn−2⋅(n−1) edges. 

Suppose for some edge(say e), we have l nodes(including node 1) on left side and r nodes(including node n) on right side. 

Among nn−2⋅(n−1) edges, how many possibilities do we have for e? 

It is (n−2l−1)⋅l⋅r⋅ll−2⋅rr−2. Why? First we select l−1 nodes(as node 1 is fixed to be on left side) to be on left side, we get (n−2l−1) for this. 

Now we have l nodes on left side and r nodes on right side. Edge e will connect one among l nodes on left and one among r nodes on right. So edge e will exist between l⋅r pairs. We know that number of distinct trees having x nodes is xx−2. 

Now on selecting one node from left and one from right, we have fixed the root of subtree on left side, and have also fixed the root of subtree on right side. So, number of distinct subtrees on left side is ll−2, and number of distinct subtrees on right side is rr−2. 

Thus, on mutliplying all(since they are independent), we get (nl)⋅l⋅r⋅ll−2⋅rr−2 possibilities for e. 

Now this edge lies on the path from 1 to n as both lie on opposite sides of this node. 

So this edge contributes (−1)l⋅(n−2l−1)⋅l⋅r⋅ll−2⋅rr−2 to answer. 

Hence d(1,n)=∑n−1l=1(−1)l⋅(n−2l−1)⋅l⋅r⋅ll−2⋅rr−2 where l+r=n. Note that we assumed that we are always going from left subtree to right subtree while calculating contribution. As we have tried all possibilties for l, all cases get covered. We used left and right subtrees just for our own convention. 

Time complexity is O(n⋅log(n)). 

Code1762F - Good Pairs 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionHow to prove the claim in hint 3? 

Suppose we have a good pair (l,r) such that al≠ar. Now using exchange arguments we can claim that there always exists a sequence(say s) starting at index l and ending at index rsuch that difference between adjacent elements of a is atmost kstrictly increasing if al<arstrictly decreasing if al>arThus (l,r) will be counted in F(a,k) if al<ar and (l,r) will be counted in F(rev(a),k) if al>ar. 

Time complexity is O(n⋅log(n)). 

Code1762G - Unequal Adjacent Elements 

Idea:satyam343 

Hint 1Hint 2Hint 3SolutionLet us continue from where we left off. 

So our motivation is to break the original array into multiple beautiful subarrays and the elements in those subarrays, as mentioned before. Now for condition 1 to be satisfied, we should not have two adjacent subarrays such that the elements at the end positions of both subarrays(after rearranging the elements) are the same. 

Here is one construction using which we can achieve our goal. 

Suppose l denotes the leftmost point of our concerned subarray. 

If al≠al+1, we move forward, as subarray a[l,l] is good. 

Otherwise, we keep moving towards the right till index r(here, r should be the smallest possible) such that the subarray a[l,r] is beautiful and al≠ar+1. So it is easy to notice the following observations about the subarray a[l,r]length of this subarray is odd 

al occurs exactly ⌈r−l+12⌉ times in this subarray 

Now we can rearrange the elements of this subarray a[l,r]. 

Do note that the subarray a[1,r] satisfies both the conditions stated in the statement. 

So our task is to make the subarray a[r+1,n] good now. 

We can now update l=r+1 and continue searching for the corresponding r and so on. 

Now it might be the case that we did not get a valid r for the last search. 

From here, I assume we did not get valid r for the last search. We could print the obtained permutation if we got it, as a would satisfy both conditions. 

Assume that we had started at pos=l and couldn't find r. 

Subarray a[1,pos−1] is already good. 

To fix this issue, we will do a similar search that we did before. 

We start from the back(from index n) and move towards left till index m such that 

m<posa[m,n] is beautifulapos occurs exactly ⌈n−m+12⌉ times in this subarrayapos≠am−1Now we arrange elements of this subarray in the same fashion that we did before. 

Are we done? 

No. First, we must prove that we will always get some m. 

Let us have function f(a,l,r,x), which denotes the score of the subarray a[l,r] for the element x. f(a,l,r,x)=freqx−(r−l+1−freqx), where freqx denotes the frequency of element x in the subarray a[l,r] 

It is easy to note that f(a,pos,n,apos)>1 

(Hint — Prove that f(a,pos,r,apos)≠0 for pos≤r≤n. Why?(If it does then a[pos,r−1] would be beautiful )) 

Now we start from the back and move towards the right to find m with n as our right endpoint of the concerned subarray. 

Note that f(a,1,n,apos)≤1 (Why? apos would have occurred at most ⌈n2⌉ times in a) 

So while moving from pos to 1 we will indeed find a m such that f(a,m,n,apos)=1, and am−1≠apos (assuming a0=−1) 

Are we done? 

Not still :p. We can observe that condition 1 is satisfied, but sometimes condition 2 would not be. For example, simulate the above approach on the array a=[1,1,2,3,3]. 

How to fix this issue? It's pretty easy to fix this issue. 

HintYou can refer to the attached code for implementation details. 

Code 

Codeforces Round #837 (Div. 2) Editorial 

By 4qqqq, history, 2 months ago, In EnglishWe apologize for the delay in editorial of the tasks. 

A. Hossam and Combinatorics 

Idea: _HossamYehia_ 

Tutorial1771A - Hossam and CombinatoricsFirstly, let's find max1≤p,q≤n|ap−aq|=max(a)−min(a)if it's equal to zero, then any pair is valid, so answer if n⋅(n−1)Otherwise, let's calculate count_min and count_max. Answer is 2⋅count_min⋅count_maxSolution(_HossamYehia_)B. Hossam and Friends 

Idea: _HossamYehia_ 

Tutorial1771B - Hossam and FriendsJust ai<bi in non-friends pairs. Let's calculate ri= minimum non-friend for all people. So, we can't start subsegment in ai and finish it righter ri. 

Let's process people from right to left and calculate the rightmost positions there subsegment can end. Initially, R=n−1. Then we go to ai just do R=min(R,ri) and add R−i+1 to answer. 

Solution(_HossamYehia_)C. Hossam and Trainees 

Idea: _HossamYehia_ 

Tutorial1771C - Hossam and TraineesIf exists x≥2 such that ai divides x and aj divides x then exists prime number p such that ai and aj divides p. We can choose p= any prime divisor of x. 

So, let's factorize all numbers and check, if two of them divides one prime number. We can use default factorization, and it will be O(n⋅A−−√). It's too long, so just calculate prime numbers ≤A−−√ and check if ai divides this numbers. It will be O(n⋅A√logA) - fast enouth. 

Solution(_HossamYehia_)D. Hossam and (sub-)palindromic tree 

Idea: 4qqqq 

Tutorial1771D - Hossam and (sub-)palindromic treeLet's use dynamic programming method. Let dpv,u as length of the longest maximal sub-palindrome on the path between vertexes v and u. Then the answer to the problem is max1≤v,u≤ndpv,u. 

Define gov,u (v≠u) vertex x such that it is on way between v and u and distance between v and x is 1. If v=u, then we put gov,u equal to v. 

So, there are three cases: 

The answer for (v,u) equals to the answer for (gov,u,u);The answer for (v,u) equals to the answer for (v,gou,v);If sv=su, then the answer for (v,u) equals to the answer for (gov,u,gou,v)+2. In this case we took best sub-palindrome strictly inside the path v,u and added to it two same symbols in v and u.Formally , the transitions in dynamics will look like this: 

dpv,u:=max(dpv,gou,v,dpgov,u,u,dpgov,u,gou,v+2⋅(sv=su)).Dynamic's base:dpv,v:=1,dpv,w:=1+(sv=sw),for v,w, such that distance between them equals to one. 

In order to calculate the values in dp, you need to iterate through pairs of vertices in ascending order of the distance between the vertices in the pair (note that this can be done by counting sort). 

The question remains: how to calculate the array go? Let's iterate all vertexes and let the current vertex is v. Let v be the root of the tree. Consider all sons of this vertex. Let current son is x. Then for all u from subtree of x the value of gov,u will be number of x. 

Thus, time and memory complexity of this solution is O(n2). 

Solution(4qqqq)E. Hossam and a Letter 

Idea: _HossamYehia_ 

Tutorial1771E - Hossam and a LetterLet's preprocess the following data for each cell. 

1. first medium cell above current cell. 2. first medium cell below current cell. 3. first bad cell above current cell. 4. first bad cell below current cell. 

Then we will try to solve the problem for each row (i), and 2 columns (j, k). 

Now we have a horizontal line in row (i), and we can calculate the length of vertical line by the following. 

There is two cases: 

In case of the horizontal line contains one letter 'm'. 

For each column (j, k): get first cell above it the don't contain ('#' or 'm') and first cell below it the don't contain ('#' or 'm'). 

In case of the horizontal line doesn't contain any letter 'm'. 

We will try to get the 4 cells as it contains letter 'm', but in this case we will 4 trials. 

for each cell from the 4 cells, we allow to have only one letter 'm' in that line. 

After getting above cells and below cells for each line. the starting cell will be the maximum between the two above cells, and the ending cell will be the minimum between the two below cells. 

Then we need to check that starting cell is above the current row (i) to avoid making letter n instead of H 

And check that ending cell is below the current row (i) to avoid making letter u instead of H. 

Since n, m has the same maximum limit 400. 

Thus, time complexity of this solution is O(n3). 

Solution(_HossamYehia_)F. Hossam and Range Minimum Query 

Idea: 4qqqq 

Tutorial1771F - Hossam and Range Minimum QueryNote that we were asked to solve the problem in online mode. If this were not the case, then the Mo Algorithm could be used. 

How to solve this task in online mode? Consider two ways. 

The first way is as follows. Let's build a persistent bitwise trie T on a given array, where the i-th version of the trie will store numbers x such that x occurs on the subsegment a[1…i] an odd number of times. 

This can be done as follows. Let T0 be an empty trie, and Ti will be obtained as follows: first we assign Ti=Ti−1; then, if ai occurs in Ti−1, then we will erase the number ai from Ti, otherwise we will insert it there. 

Suppose we need to get answer on the query [l,r]. Note that if x is included in Tr, but is not included in Tl−1 (or is included in Tl−1, but is not included in Tr), then this means that the number x on the segment a[l…r] occurs an odd number of times. Otherwise, the number x occurs an even number of times (recall that 0 is an even number). Thus, we need to find a minimum number x such that it occurs either in Tl−1 or in Tr, but not in both at once. If there is no such number, then you need to output 0. 

Let's go down Tl−1 and Tr in parallel on the same prefix of the number. If Tl−1 and Tr are equal, then the same numbers are contained there, and then the answer is 0. Next, we will assume that the answer is not 0. The left subtree of the vertex is the son to whom the transition along the edge of 0 is going, and the right subtree is the vertex to which the transition along the edge of 1 is going. Let us now stand at the vertices v and u, respectively. If the left subtrees of v and u are equal, it means that the same numbers are contained there, so there is no point in going there, so we go along the right edge. Otherwise, the left subtree of v contains at least one number that is not in the left subtree of u (or vice versa), so we will go down the left edge. The number in which we ended up will be the answer. 

Note that in order to compare two subtrees for equality, you need to use the hashing technique of root trees. Then we can compare the two subtree for O(1). 

Thus, we get the asymptotics O((n+q)logmax(a)). If we compress the numbers of the sequence a in advance, then we can get the asymptotics of O((n+q)logn). 

Let's consider the second way. Let's compress the numbers in the sequence a in advance. Let prefij=0 if the prefix i contains the number aj an even number of times, and prefij=1 if the prefix i contains the number aj an odd number of times. 

Then, in order to get an answer to the query [l…r], we need to take the "bitwise exclusive OR" arrays prefl−1 and prefr and find in it the minimum j such that prefij=1. The number j will be the answer. 

Obviously, now this solution need much time and memory. 

In order to optimize the amount of memory consumed, we will use bitsets. However, even in this case, we consume memory of the order of o(h2/64), which is still a lot. So let's not remember about all prefi, but only some. For example, let's get some constant k and remeber only about pref0,prefk,pref2k,\dataprefpk. 

Then, when we need to answer the next query [l…r], we will find the right block on which we store almost all the numbers we are looking for, and then we will insert/erase for O(k) missing numbers. 

If you select k∼n−−√, then this solution will fit in memory. However, if you use std::bitset<> in C++, then most likely this solution will still receive the verdict Time Limit. Therefore, to solve this problem, you need to write your own fast bitset. 

The asymptotics of such a solution would be O(n(n+q)/64). However, due to a well-chosen k and a self-written bitset, the constant in this solution will be very small and under given constraints, such a solution can work even faster than the first one. 

Solution(4qqqq, trie)Solution(Aleks5d, bitset) 

Codeforces Round #836 (Div. 2) Editorial 

By ScarletS, 3 months ago, In EnglishThank you for participating in our contest! We hope you enjoyed it. Implementations will be added soon (when Codeforces lets authors submit solutions!). 

Please let us know what you thought of the problems by voting! 

1758A - SSeeeeiinngg DDoouubbllee 

HintSolution1758A - SSeeeeiinngg DDoouubblleeOutput s+reverse(s). 

It works, since each character in s occurs exactly twice (once in s, once in reverse(s)), and the result is a palindrome. 

Implementation (C++)Implementation (Java)Implementation (Python)Feedback1758B - XOR = Average 

HintSolution1758B - XOR = AverageLet us consider the cases when n is odd and when its even. 

n is odd: We can see that printing 1,…,1n times will lead to an average of 1 and an XOR of 1 (since 1⊕1=0). Similarly, you could print any integer n times to pass this case.n is even: We use a slight modification of the solution for odd n here. Instead of printing the same number n times, we print 1,3,2,…,2n−2 times. Both the XOR and the average of 1 and 3 are 2. Therefore the average of the total sequence remains 2, and the XOR of the whole sequence is also 2.Note that there are other possible solutions, but the simplest one is described here. 

Implementation (C++)Implementation (Java)Implementation (Python)Video EditorialFeedback1758C - Almost All Multiples 

HintSolution1758C - Almost All MultiplesWe start by giving the answer for n=12, k=2:[2,4,3,12,5,6,7,8,9,10,11,1]and for n=12, k=3:[3,2,6,4,5,12,7,8,9,10,11,1].As you can see, the array is almost the identity permutation, with certain elements rotated to the left. In particular, these are the elements that you get when you find the longest sequence ai such that x∣a1∣a2∣⋯∣n (recall a∣b means a divides b). For example, 3∣6∣12 and 2∣4∣12. To find this longest sequence, you need to prime factorize nx. The complexity is O(nlogn). 

The main idea is intuitive, but the proof is rather long. We include it below. 

The idea is to look at cycles in the permutation. Consider any cycle of length greater than 1, say c1,c2,…,ck (that is, pc1=c2, pc2=c3,…,pck=c1). We claim that for at least one element ci of the cycle, pci is not a multiple of ci. 

In fact, we'll show a more general claim: for one element of the cycle pci<ci, which implies that pci cannot be a multiple of ci. Indeed, let's sum pci−ci over all elements of the cycle. This sum is 0, because each element appears once before the − sign and once afterwards. Since none of these equal 0, it follows that at least one of these terms is negative (and at least one is positive). If pci−ci<0, then pci<ci, as desired. 

So in each cycle, we must have at least one element breaking the key claim in the problem. But this claim holds for all 1≤i≤n−1, so the only cycle we can have goes through pn! Indeed, since pn=1 and p1=x, the cycle goes n→1→x→⋯→n. For all arrows except the first one, we a∣b to write a→b, because only pn can break the condition. Since we want the permutation to be lexicographically minimal, we want the longest such chain. 

So we should find the longest sequence of numbers from x to n, such that each number divides the previous. If there are multiple such sequences, we need to pick the one that puts smaller numbers earlier, since we want smaller elements earlier on in the sequence. To do this, we can just find the prime factorization of nx (it is the longest, since the primes cannot be broken up into smaller factors), sort it, and cycle it. 

Implementation (C++)Implementation (Java)Implementation (Python)Video EditorialFeedback1758D - Range = √Sum 

HintSolution1758D - Range = √SumLet us consider the cases when n is odd and when its even. 

n is odd: First, we can start with the n consecutive distinct numbers centered at n. The minimum-maximum difference is n−1, and the sum is n2. If we add 2 to each number, the minimum-maximum difference remains the same, and the sum increases to n2+2n.Now, we can decrease the minimum by 1 and the increase the maximum by 1. The sum remains at n2+2n, while the difference increases to n+1. To make the sum equal (n+1)2=n2+2n+1, we can increase the 2nd last number by 1, which we can do since we previously increased the maximum by 1. 

As an example, this sequence is followed for n=5: 

[3, 4, 5, 6, 7] (centered at 5)[5, 6, 7, 8, 9] (increase by 2)[4, 6, 7, 8, 10] (shift min/max)[4, 6, 7, 9, 10] (shift 2nd last)n is even: We can let [a1,…,an]=[n/2,n/2+1,…,n−1,n+1,…,3n/2]. The difference between the minimum and maximum is n, and the sum of the numbers equals n2, so this is valid.Other solutions exist, only one is described here. 

Implementation (C++)Implementation (Java)Implementation (Python)Video EditorialFeedback1758E - Tick, Tock 

HintSolution1758E - Tick, TockNotice that a relationship between two clocks with assigned values on the grid on different rows but the same column, that is, gx,z and gy,z, can be represented as gy,z≡gx,z+d(modh), where 0≤d<h. Now, for every 1≤i≤m, gy,i≡gx,i+d(modh). Using these relationships, we can create a weighted directed graph using our rows as nodes. 

Obviously, no solutions exist if there are discrepancies in the graph (modh), no solution exists. Now, for each connected component, if there is an assigned value in one of the rows it contains, we can determine all of the other values for that column in the connected component. We can merge different connected components i,j by choosing a common difference di,j for these components. This needs to be done (connected components - 1) times, and there are h different ways to choose a common difference when combining different components, resulting in hconnected components−1 different ways to combine all components into one connected component. 

This leaves us with columns that are fully empty, i.e., they consist only of unassigned clocks. As all rows are in one connected component at this point, assigning a clock in one empty column results in all other clocks in that column becoming assigned values too. There are hempty columns different ways to assign clocks to these empty columns. 

Thus, overall, our solution is hconnected components+empty columns−1. 

Implementation (C++)Implementation (Java)Implementation (Python)Feedback1758F - Decent Division 

HintSolution1758F - Decent DivisionAfter each update, we want to maintain the invariant that each interval is balanced, and additionally that there is a gap containing at least one zero in between each pair of consecutive intervals. Since every 1 must be contained in an interval, this is equivalent to having non-empty gaps between consecutive intervals after an update. 

There are several cases we need to handle. 

Case 1: Bit ai is changed from 0 to 1.Case 1a: Bit ai is contained in an interval after the previous updateIf we are inside an interval, then we want to grow the interval that contains it by 2 zeros to maintain balance. If the interval containing ai is [l,r], then we can expand it to [l,r+1]. Since there is at least one 0 after each interval, ar+1=0, so this contains one of the two zeroes we need. 

If there is another interval r+2∈[l′,r′], then increasing the right bound again by 1 would overlap with this interval. In this case, We know that ar′+1=0 as well, so we can merge both intervals together into [l,r′+1] to get a total of two new zeros. [l′,r′] was also previously balanced, so the interval is still balanced. In this case, we removed two intervals and added one interval, so a total of three operations were used. 

If there is no intervals where r+2∈[l′,r′], then ar+2=0, so we can simply expand the current interval once more to [l,r+2]. One interval was removed and one interval was added, so a total of two operations were used. 

Case 1b: Bit ai is not contained in an interval.If there exists an interval where i+1∈[i+1,r], then we can expand it to [k,r+1]. This interval is directly after ai, so expanding it by one to the left will include an extra 1. ar+1=0 since it is part of the gap between two intervals, so including it balances ai. One interval was removed and one interval was added, so a total of two operations were used. 

If there is no interval where i+1∈[i+1,r], then ai+1=0. Therefore, we can simply add [i,i+1], which is balanced. One interval was added, so a total of one operation was used. 

In both cases, after adding a new interval to the set, we can merge with any adjacent intervals to the left or right. This will maintain the invariant that there is a gap between consecutive ranges as mentioned earlier. We merge at most once to the left and one to the right. Since the maximum number of operations done earlier is 3, the maximum number of operations in total is 5 in this case. 

Case 2: Bit ai is changed from 1 to 0.Suppose that i∈[l,r]. In this case, we want to somehow split the interval into two balanced portions. Now, suppose we compute the prefix sums of the balance, where 0 corresponds to −1 and 1 corresponds to +1. If x is the first location where the prefix sum equals −2, then we claim that we can split the interval into [l,x−2] and [x+1,r]. 

To prove this, note that the balance of the empty prefix is 0, so before the prefix sum equals −2 for the first time, it must have gone ...,0,−1,−2. To have two decreases in a row, we must have ax−1=ax=0. In the interval [l,x−2], the final balance prefix sum is 0, so the first interval is balanced. Since we changed a 1 to a 1 and removed two 0s, the first interval being balanced implies that the second interval is balanced as well. In addition, since the original interval satisfied the separation invariant, and the new intervals are separated by two 0s, the separation invariant is still satisfied. 

To compute the first time when the balance prefix sum equals -2, we can use binary search on the interval using a lazy segment tree. The segment tree represents a global balance prefix sum, and we can range query the minimum balance on an interval. We can binary search for the lowest index on the interval where the minimum prefix sum is less than -2. 

In this case, we removed one interval and added two new intervals, for a total of three operations. 

In both cases, we use at most 5 operations in a single step, so we in total use at most 5n operations, which fits in our bound. In practice, this upper bound is quite loose. 

Because of the binary search on the lazy segment tree, the time complexity for this solution is O(nlog2n). Note that this can be optimized to O(nlogn) by optimizing the binary search, but this was not required. 

Implementation (C++)Implementation (Python)Feedback 

Codeforces Round #835 (Div. 4) Editorial 

By flamestorm, 3 months ago, In EnglishWe hope you enjoyed the contest! Sorry for the late editorial. 

1760A - Medium Number 

Idea: flamestorm 

Tutorial1760A - Medium NumberHere are two ways to implement what's given in the problem: 

Take input as an array [a1,a2,a3], and sort it. Output the middle element.Write two if-statements. The first: if (a>b and a<c) or (a<b and a>c), output a. Else, if (b>a and b<c) or (b<a and b>c), output b. Else, output c.Solution1760B - Atilla's Favorite Problem 

Idea: SlavicG 

Tutorial1760B - Atilla's Favorite ProblemTo solve the problem we need to find the character with the highest alphabetical order in our string, since Atilla will need at least that alphabet size and won't need more. To do this iterate through the string and find the character with the highest alphabetical order. Output the maximum alphabetical order found. The solution can be done in O(n).Solution1760C - Advantage 

Idea: Errichto 

Tutorial1760C - AdvantageMake a copy of the array s: call it t. Sort t in non-decreasing order, so that t1 is the maximum strength and t2 — the second maximum strength. 

Then for everyone but the best person, they should compare with the best person who has strength t1. So for all i such that si≠t1, we should output si−t1. Otherwise, output si−t2 — the second highest strength, which is the next best person. 

Solution1760D - Challenging Valleys 

Idea: mesanu 

Tutorial1760D - Challenging ValleysOne possible solution is to represent a range of equal element as a single element with that value. Construct this array b and loop through it and check how many element bi satisfy the conditions i=0 or bi−1<bi and i=n−1 or bi>bi+1. If exactly one index satisfies these conditions, print "YES" and othewise "NO". 

Complexity: O(n)Solution1760E - Binary Inversions 

Idea: SlavicG 

Tutorial1760E - Binary InversionsLet's find out how to count the number of binary inversions, without flips. This is the number of 1s that appear before a 0. To do this, iterate through the array and keep a running total k of the number of 1s seen so far. When we see a 0, increase the total inversion count by k, since this 0 makes k inversions: one for each of the 1s before it. 

Now let's see how to maximize the inversions. Consider the flip 0→1. We claim that it is best to always flip the earliest 0 in the array. It's never optimal to flip a later 0, since we have strictly fewer 0s after it to form inversions. Similarly, we should flip the latest 1 in the array. 

Now recalculate the answer for these two choices for flipping, and pick the maximum. The complexity is O(n). 

Solution1760F - Quests 

Idea: flamestorm 

Tutorial1760F - QuestsLet's fix k and find the maximum number of coins we can get. Here we can do a greedy solution: at every step, we should always take the most rewarding quest. (Intuitively, it makes sense, since doing more rewarding quests earlier allows us to do them again later.) If no quests are available, we do nothing. 

To implement this, sort the quests in decreasing order, and 0-index them. On day i we should do quest imodk, provided that this value is less than n. This is because after every k days, we cycle back to the first quest. Thus we solved the problem for a fixed k in O(d) with O(nlogn) precomputation to sort the array. 

Now to solve the problem, we can binary search on the answer, since if some k works, then all smaller k work. The minimum value of k is 0, and the maximum value is n (for larger k, we won't be able to do the same quest multiple times anyways, so it's useless to consider them). 

If we find that k always goes towards the smaller end of our binary search and k=0 still fails, we output Impossible. If we find that k always goes towards the larger end of our binary search and k=n still fails, we output Infinity. Otherwise, just output k. 

The overall time complexity is O(nlogn+dlogn). 

Remark. It is not hard to improve the solution to O(nlogn). Originally, I proposed the problem this way, but we ended up removing this part of the problem because the implementation of this solution was tricky enough. 

Solution1760G - SlavicG's Favorite Problem 

Idea: SlavicG 

Tutorial1760G - SlavicG's Favorite ProblemLet's ignore the teleporting, and decide how to find the answer. Note that we don't need to ever go over an edge more than once, since going over an edge twice cancels out (since a XOR a=0 for all a). In other words, the only possible value of x equals the XOR of the edges on the unique path from a to b. We can find it through a BFS from a, continuing to keep track of XORs as we move to each adjacent node, and XORing it by the weight of the corresponding edge as we travel across it. 

Now let's include the teleport. It means that we travel from a→c, then teleport to d, and go from d→b, for some nodes c and d. Also, we cannot pass b on the path from a→c. 

Again, note that the value of x is fixed on each of the paths from a→c and d→b, since there is a unique path between them. Let x1 be the XOR of the first path and x2 be the XOR of the second. Then we need x1 XOR x2=0⟹x1=x2. So we need to find if there are two nodes c, d such that the XORs from a and b to those nodes are the same. To do this, we can do our BFS from before, but instead run one BFS from a and another from b, and check if any two values are the same. 

Make sure not to include nodes past b while we look for c on our BFS from a. 

The time complexity is O(nlogn). 

Solution 

Codeforces Round #834 (Div. 3) Editorial 

By Vladosiya, history, 3 months ago, translation, In English1759A - Yes-Yes? 

Idea: MikeMirzayanov 

Tutorial1759A - Yes-Yes?Note that it is enough to consider the string full=YesYes...Yes, where Yes is written 18 times, since 18⋅3=54, and our substring s has size |s|≤50. 

Then we just use the built-in function find to find out if our string s is a substring of the string full. 

Solution1759B - Lost Permutation 

Idea: MikeMirzayanov 

Tutorial1759B - Lost PermutationLet us add to s the sum of the elements of the array b and try to find a suitable permutation. To do this, greedily add elements 1,2,…,cnt until their sum is less than s. And at the end we will check that the sum has matched. 

Also check that the maximal element from b: max(b)≤cnt, and that the total elements in b: n≤cnt. 

Solution1759C - Thermostat 

Idea: Vladosiya 

Tutorial1759C - ThermostatFirst let's consider the cases when the answer exists: 

If a=b, then the thermostat is already set up and the answer is 0.else if |a−b|≥x, then it is enough to reconfigure the thermostat in 1 operation.else if exist such temperature c, that |a−c|≥x and |b−c|≥x, then you can configure the thermostat in 2 operations. If such c exists between l and r, we can chose one of bounds: a→l→b or a→r→b.we need to make 3 operations if times if we cannot reconfigure through one of the boundaries as above, but we can through both: a→l→r→b or a→r→l→bIf we can't get the temperature b in one of these ways, the answer is −1. 

Solution1759D - Make It Round 

Idea: MikeMirzayanov 

Tutorial1759D - Make It RoundThe answer is n⋅k. 

First, count two numbers: cnt2,cnt5 which denote the degree of occurrence of 2 and 5 in the number n respectively, that is n=2cnt2⋅5cnt5⋅d. Where d is not divisible by either 2 or 5. Now while cnt2≠cnt5 we will increase the corresponding value. For example, if cnt2<cnt5, then as long as cnt2≠cnt5 and at that k⋅2≤m we will increase cnt2 by 1 and multiply k by 2 times. 

That way we can get the most round number possible by spending the least possible k. 

Now we either have cnt2=cnt5, or k⋅5>m or k⋅2>m. Then in the first case, we will multiply the number k by 10 as long as we can. That is, until k⋅10≤m. 

Now in either case we have: k⋅10>m. Then ⌊mk⌋=x<10. Then we multiply k by x times and get our desired answer. 

In the last step, we can no longer get a rounder number, but just find the maximal possible number. 

Solution1759E - The Humanoid 

Idea: Gornak40 

Tutorial1759E - The HumanoidLet's make two obvious remarks: 

If we can absorb two astronauts with power x≤y, then we can always first absorb an astronaut with power x, and then an astronaut with power y;If we can absorb some astronaut, it is effective for us to do it right now.Let's sort the astronauts powers in increasing order. 

Now let's lock the sequence of serums we use. There are only three of them: blue serum can be the first, second or third. 

Let's absorb the astronauts in increasing order of their powers, and if we can't, then use the next serum in a locked sequence or stop. 

This solution works for O(n). 

Solution1759F - All Possible Digits 

Idea: DmitriyOwlet 

Tutorial1759F - All Possible DigitsIf all digits from 0 to p−1 are initially present in the number, then the answer is 0. 

Each time we will increase the number by 1. If the last digit is less than p−1, then only it will change. Otherwise, all digits equal to p−1 at the end will become equal to 0, and the previous one will increase by 1 (or a new digit equal to 1 will be added if all digits were equal to p−1). 

For a p−1 operation, the last digit will run through all possible values. However, we can get all the numbers earlier. We will solve the problem using binary search, sorting through the number of operations. 

We can have 2 options: whether 0 was at the end or not. Depending on this, one or two subsegments of the segment [0,p−1] — a subsegment in the middle or a prefix and a suffix remained uncovered by the last digit of the number. They need to be completely covered with numbers that were already in positions, except for the last one — these are the original numbers and, in case there was 0 at the end, the number into which the transfer was made. There are at most n+1 of them. 

Solution1759G - Restore the Permutation 

Idea: MikeMirzayanov 

Tutorial1759G - Restore the PermutationFirst, let's check the b array for correctness, that is, that it has no repeating elements. 

Then let's look at the following ideas: 

each number bi must be paired with another permutation element pj, with pj<bi by the definition of array b. Then, since we want a lexicographically minimal permutation, it is always more advantageous to put element pj before bi.for the permutation to be lexicographically minimal, the smallest possible numbers must be placed at the beginning. Consequently, the largest numbers must be placed at the end.Let's proceed as follows: 

Let's select the set of unused numbers that are not included in the b array.For an element bn2, find the maximum number k of the set unused such that bn2>k and put that number in front of the element bn2.moving from the end of the array to its beginning, each element bi will be matched with such an element. If at some point k can not be matched — array b is not composed correctly, and the answer to the query — "NO".Otherwise, print "YES" and the resulting permutation p.Solution 

Codeforces Round #833 (Div. 2) Editorial 

By Gheal, history, 4 months ago, In EnglishA — The Ultimate SquareAuthor: Gheal 

HintsSolutionIf n is odd, let k=n+12 be the width of the last block. It is possible to create a square of side length k using every block as follows: 

Line 1 contains a 1×k block;Line 2 contains a 1×1 block and a 1×(k−1) block;Line 3 contains a 1×2 block and a 1×(k−2) block;…Line i contains a 1×(i−1) block and a 1×(k−i+1) block;…Line k contains a 1×(k−1) block and a 1×1 block.Since the area of this square is k2, and the n+1-th block has a width of k tiles, the total area of the first n+1 blocks is equal to k2+k<(k+1)2. Therefore, the answer for n+1 is also k. 

In conclusion, the answer for each testcase is ⌊n+12⌋. 

Time complexity per testcase: O(1). 

Code (C++)Rate ProblemB — Balanced SubstringsAuthor: Gheal 

HintsSolutionIn a diverse string, there are at most 10 distinct characters: '0', '1', …, '9'. Therefore, each of these characters can appear at most 10 times in a diverse string. 

With all this in mind, the maximum possible length of a diverse string is 102=100. To solve this problem, we only need to check whether each substring of length l≤100 is diverse. 

Time complexity per testcase: O(n⋅102)Code(C++)Rate problemC — Zero Sum PrefixesIdea: Gheal, Solution: IgorI 

HintsSolutionLet's consider the prefix sum array s=[a1,a1+a2,…,a1+a2+…+an]. 

For every index i such that ai=0, if we change the value of ai to x, then every element from the suffix [si,si+1,…,sn] will be increased by x. Therefore, if ai1=ai2=…=aik=0, we'll partition array s into multiple subarrays: 

[s1,s2,…,si1−1];[si1,si1+1,…,si2−1];[si2,si2+1,…,si3−1];…[sik,sik+1,…,sn];Since none of the elements from the first subarray can be changed, it will contribute with the number of occurences of 0 in [s1,s2,…,si1−1] towards the final answer. 

For each of the other subarrays [sl,sl+1,…,sr], let x be the most frequent element in the subarray, appearing fr[x] times. Since al=0, we can change the value of al to −x. In this case, every x in this subarray will become equal to 0, and our current subarray will contribute with fr[x] towards the final answer. 

Time complexity per testcase: O(NlogN)Code(C++)Rate problemD — ConstructORAuthor: Gheal 

HintsSolutionLet k=lsb(d), where lsb(d) represents the least significant bit of d. 

Since a|x and b|x are multiples of d, the last k bits of a and b (and also x) must be equal to 0. 

Otherwise, there are no solutions and we can print −1. 

To simplify the construction process, we will try to find some x such that a|x=b|x=x. Since we already know that the last k bits of a, b and x are 0, we will consider that the other 30−k of the 30 least significant bits of x are equal to 1: 

x(2)=p 1 1 1 … 1 0 0 … 0This gives the following general formula for x: 

x=2k⋅(p⋅230−k+(230−k−1))Now, we'll try to find some p for which x is a multiple of d=2k⋅d′: 

x=2k⋅(p⋅230−k+(230−k−1)≡0mod2k⋅d′⇔⇔(p⋅230−k+(230−k−1)≡0modd′⇔⇔(p+1)⋅230−k≡1modd′⇔⇔p+1≡2k−30modd′⇔⇔p+1≡(2−1)30−kmodd′⇔⇔p+1≡(d′+12)30−kmodd′⇒⇒p=((d′+12)30−k+d′−1)modd′Time complexity per testcase: O(logd)Note that if a|b is already a multiple of d, we can consider x=a|b. 

Code(C++)Rate problemE — Yet Another Array Counting ProblemAuthor: Gheal 

HintsSolutionLet f(i,j) be the position of the leftmost maximum in the interval (i;j), 1≤i≤j≤n. 

Let's consider an interval (l;r) such that f(l,r)=m. For the sake of simplicity, let's assume that l<m<r. 

Let p=f(l,m−1) and p2=f(m+1,r). Since am is the leftmost maximum in (l;r), p<m and p2>m, the following conditions must hold for array b: 

bm>bpbm≥bp2Let's consider a binary tree where the children of node u=f(l,r) are nodes p=f(l,u−1) and p2=f(u+1,r), for every 1≤u≤n. 

Note that if u=l, f(l,l−1) is not defined, and, as such, node u will have no left child. Similarly, if u=r, then node u will have no right child. 

Let dp[u][x] be equal to the number of ways to assign values to every element bv from the subtree rooted in u, if bu=x. 

If u has a left child and x=1, then dp[u][x]=0;Otherwise, if u has two children, then dp[u][x]=(∑x−1i=1dp[p][i])⋅(∑xi=1dp[p2][i]);If u only has a left child, then dp[u][x]=∑x−1i=1dp[p][i];If u only has a right child, then dp[u][x]=∑xi=1dp[p2][i];If u has no children, then dp[u][x]=1.To optimise the transitions, we'll also need to compute sum[u][x]=∑xi=1dp[u][x] alongside our normal dp. 

Intended time complexity per testcase: O(n⋅m+n⋅log(n))Additional implementation detailsCode(C++)Rate problemF — Circular Xor ReversalIdea: Gheal, Solution: IgorI 

HintsSolutionIf m=dist(i,j)=((j+n−i)modn), m>0 and bk=a(i+k)modn, let f(i,j) be a sequence of operations that performs: 

b0=b0⊕bm−1;b1=b1⊕bm−2;b2=b2⊕bm−3;…b⌊m−12⌋=b⌊m−12⌋⊕b⌊m+22⌋If n is even, we can reverse array a by performing f(0,n−1), f(n2,n2−1) and f(0,n−1), in this order. 

Otherwise, if n is odd, we can perform f(0,n−1), f(n+12,n−32) and f(0,n−1), in this order. 

One possible way to construct f(i,j) is as follows: 

Perform an operation on every i from m−1 to 0:⇒b=[(0..m),(1..m),(2..m)…,(i..m),…,bm]Perform an operation on every i from 1 to m−1:⇒b=[(0..m),b1,b2,…,bi,…,bm]Perform an operation on every i from m−2 to 1:⇒b=[(0..m),(1..m−1),(2..m−1),…,(i..m−1),…,bm−1,bm]Perform an operation on every i from 2 to m−2:⇒b=[(0..m),(1..m−1),b2,b3,…,bi,…,bm−1,bm]…⇒b=[(0..m),(1..m−1),(2..m−2),…,(i..m−i),(⌊m−12⌋..⌊m+22⌋),b⌊m+12⌋,…,bj,bm−1]The last step is to perform an operation on every i from 0 to ⌊m−22⌋:⇒b=[a0⊕am,a1⊕am−1,…,ai⊕am−i,…,b⌊m−12⌋⊕b⌊m+22⌋,b⌊m+12⌋,…,bj,…,bm]Here, (l..r) denotes bl⊕bl+1⊕…⊕br. 

The number of operations needed for f(i,j) is equal to m+(m−1)+…+1+(m2)=m⋅(m+1)2+m2=m2+2⋅m2, therefore the total number of operations needed to reverse the array is 32⋅(m2+2⋅m). Since m≤n−1, 32⋅(m2+2⋅m)≤32⋅(3992+2⋅399)<250000. 

Time complexity per testcase: O(N2)Code(C++)Rate problemIf there is anything wrong or unclear in this editorial, feel free to ping me in the comments. 

Codeforces Round #832 (Div. 2) Editorial 

By rivalq, history, 4 months ago, In EnglishI hope you all liked the round. Please share your feedback in the comments section. 

1747A — Two GroupsHintTutorialLet S denotes sum of element of array a. 

Claim: Answer is |S|. 

Proof: Let sum of all positive elements is Spos and sum of all negative elements Sneg. Put all positive numbers in first group and negative numbers in second group. We get ||Spos|−|Sneg||=|S|. 

Let's prove that we can not do better than that. Let S1 denotes sum of elements of first group and S2 denotes sum of elements of second group. We have |S1|−|S2|≤|S1+S2|=|S|. Hence |S| is the upperbound for the answer. 

Solution1747B — BAN BANHint 1Hint 2Hint 3TutorialNo subsequences of string BAN would also mean no substrings of BAN in original string. Let minimum number of operations to have no substrings of BAN be x, it would be also be the lower bound for having no subsequences of string BAN. 

Claim: x=⌈n2⌉. 

Proof: Swap i-th B from start with i-th N from end for 1≤i≤⌈n2⌉. We can see that, no substrings of BAN exists after performing ⌈n2⌉ operations. Since we can only destroy atmost 2 substrings in one operations, ⌈n2⌉ is minimum possible. 

Now if you see clearly, after performing above operations, there does not exist any subsequence of string BAN in original string. Hence ⌈n2⌉ is also the answer for the original problem. 

Solution1747C — Swap GameHint 1Hint 2TutorialCase 1: a1>min(a) 

Alice can force the Bob to always decrease the minimum element by always choosing minimum element of a in her turn. Where as Bob can not do much, all other elements he would swap with would be greater than or equal to min(a). Even if there exists multiple minimums in a, In first move Alice would decrease from a1, hence in this case Alice would always win. 

Case 2: a1=min(a) 

In this case optimal startegy for Bob would be to always chhose minimum element of the array, which is a1. Alice would always be swapping the element greater than a1 in her turn, hence in the case Bob would always win 

Solution1747D — Yet another ProblemHint 1Hint 2Hint 3TutorialFirst forget queries, solve for single array a. 

Let's make some observations. 

Xor of array does not change after each operation 

Look at the set of prefix XORs while doing operations. Its size always decreases or remains same after each operation. Infact we can further reduce it to parities. Let S0, S1 be sets of prefix XOR's of parities 0 and 1 respectively. After each operation new sets S′0, S′1 will be subsets of S0 and S1 respectively. 

So necessary conditions for answer to exist is that xor of array should be 0 and S1 should contains 0. 

Now comes to minimum operations. 

Claim: If above conditions are satisfied, its always possible to make all elements 0 in less than or equal to 2 operations 

Proof: Let length of array be n. 

Case 1: n is odd 

Just apply the operation on whole array. 

Case 2: n is even 

There will exists some odd size prefix j such that xor of its elements is 0. Apply operation on [1,j] and [j+1,n]. It can happen that j=1 or j=n−1, in that case we only need one operation, because other remaining element would already be equal to 0. 

To solve for queries, you just need to check for odd prefix, which can be done using some data structure like std::map or std::set in C++. Do not forget to check the case when all elements are already 0. 

Solution1747E — List GenerationHint 1Hint 2TutorialGiven problem is equivalent to: 

You are currently at cell (0,0). From any cell (x,y) you can jump to cell (x′,y′) such that x≤x′≤n , y≤y′≤m and (x,y)≠(x′,y′). Find sum of number of visited cells over all paths starting from (0,0) and ending at (n,m). Denote the required value by f(n,m). 

Directly thinking in 2 dimensions is difficult, lets first solve for case when n=0 or m=0. WLOG, assuming m=0. We can solve this case using some binomials. 

f(n,0)=2n−1⋅n+32, n>0. 

Now, we can divide all possible paths from (0,0) to (n,m) into several classes of one dimensional paths. 

These classes are defined by what I call breakpoints. When we passes the breakpoint we turns right. Hence we can group paths by fixing the number of breakpoints. 

WLOG, Assuming n≥m. For k breakpoints there are (nk)⋅(mk) ways to select for 0≤k≤m. For a path with k breakpoints, n+m−k points are optional, that is there will exist 2n+m−k paths with k breakpoints. It is not difficult to see that sum of number of visited cells over paths with k breakpoints turned out to be f(n+m−k,0)+2n+m−k−1⋅k. Hence we can write f(n,m)=∑k=0m(nk)⋅(mk)⋅(f(n+m−k,0)+2n+m−k−1⋅k) 

Time complexity of the solution would be O(min(n,m)) 

Solution 

Codeforces Round #832 (Div. 2) Editorial 

By rivalq, history, 4 months ago, In EnglishI hope you all liked the round. Please share your feedback in the comments section. 

1747A — Two GroupsHintTutorialLet S denotes sum of element of array a. 

Claim: Answer is |S|. 

Proof: Let sum of all positive elements is Spos and sum of all negative elements Sneg. Put all positive numbers in first group and negative numbers in second group. We get ||Spos|−|Sneg||=|S|. 

Let's prove that we can not do better than that. Let S1 denotes sum of elements of first group and S2 denotes sum of elements of second group. We have |S1|−|S2|≤|S1+S2|=|S|. Hence |S| is the upperbound for the answer. 

Solution1747B — BAN BANHint 1Hint 2Hint 3TutorialNo subsequences of string BAN would also mean no substrings of BAN in original string. Let minimum number of operations to have no substrings of BAN be x, it would be also be the lower bound for having no subsequences of string BAN. 

Claim: x=⌈n2⌉. 

Proof: Swap i-th B from start with i-th N from end for 1≤i≤⌈n2⌉. We can see that, no substrings of BAN exists after performing ⌈n2⌉ operations. Since we can only destroy atmost 2 substrings in one operations, ⌈n2⌉ is minimum possible. 

Now if you see clearly, after performing above operations, there does not exist any subsequence of string BAN in original string. Hence ⌈n2⌉ is also the answer for the original problem. 

Solution1747C — Swap GameHint 1Hint 2TutorialCase 1: a1>min(a) 

Alice can force the Bob to always decrease the minimum element by always choosing minimum element of a in her turn. Where as Bob can not do much, all other elements he would swap with would be greater than or equal to min(a). Even if there exists multiple minimums in a, In first move Alice would decrease from a1, hence in this case Alice would always win. 

Case 2: a1=min(a) 

In this case optimal startegy for Bob would be to always chhose minimum element of the array, which is a1. Alice would always be swapping the element greater than a1 in her turn, hence in the case Bob would always win 

Solution1747D — Yet another ProblemHint 1Hint 2Hint 3TutorialFirst forget queries, solve for single array a. 

Let's make some observations. 

Xor of array does not change after each operation 

Look at the set of prefix XORs while doing operations. Its size always decreases or remains same after each operation. Infact we can further reduce it to parities. Let S0, S1 be sets of prefix XOR's of parities 0 and 1 respectively. After each operation new sets S′0, S′1 will be subsets of S0 and S1 respectively. 

So necessary conditions for answer to exist is that xor of array should be 0 and S1 should contains 0. 

Now comes to minimum operations. 

Claim: If above conditions are satisfied, its always possible to make all elements 0 in less than or equal to 2 operations 

Proof: Let length of array be n. 

Case 1: n is odd 

Just apply the operation on whole array. 

Case 2: n is even 

There will exists some odd size prefix j such that xor of its elements is 0. Apply operation on [1,j] and [j+1,n]. It can happen that j=1 or j=n−1, in that case we only need one operation, because other remaining element would already be equal to 0. 

To solve for queries, you just need to check for odd prefix, which can be done using some data structure like std::map or std::set in C++. Do not forget to check the case when all elements are already 0. 

Solution1747E — List GenerationHint 1Hint 2TutorialGiven problem is equivalent to: 

You are currently at cell (0,0). From any cell (x,y) you can jump to cell (x′,y′) such that x≤x′≤n , y≤y′≤m and (x,y)≠(x′,y′). Find sum of number of visited cells over all paths starting from (0,0) and ending at (n,m). Denote the required value by f(n,m). 

Directly thinking in 2 dimensions is difficult, lets first solve for case when n=0 or m=0. WLOG, assuming m=0. We can solve this case using some binomials. 

f(n,0)=2n−1⋅n+32, n>0. 

Now, we can divide all possible paths from (0,0) to (n,m) into several classes of one dimensional paths. 

These classes are defined by what I call breakpoints. When we passes the breakpoint we turns right. Hence we can group paths by fixing the number of breakpoints. 

WLOG, Assuming n≥m. For k breakpoints there are (nk)⋅(mk) ways to select for 0≤k≤m. For a path with k breakpoints, n+m−k points are optional, that is there will exist 2n+m−k paths with k breakpoints. It is not difficult to see that sum of number of visited cells over paths with k breakpoints turned out to be f(n+m−k,0)+2n+m−k−1⋅k. Hence we can write f(n,m)=∑k=0m(nk)⋅(mk)⋅(f(n+m−k,0)+2n+m−k−1⋅k) 

Time complexity of the solution would be O(min(n,m)) 

Solution 

Codeforces Round #830 (Div. 2) Editorial 

By 74TrAkToR, history, 4 months ago, translation, In EnglishThanks for the participation! 

1732A - BestieLet's make an important observation: gcd(n−1,n)=1 for any value of n. Moreover, choosing i=n−1 and i=n are the cheapest operations. From this we can conclude that the answer is ≤3. 

Let g be the gcd of all numbers in the array. Then we have the following cases: 

If g=1, then the operation can be omitted and the answer is 0,Otherwise, let's try the cheapest operation i=n. If gcd(g,n)=1, then the answer is 1.Otherwise, let's try the next cheapest operation, ie i=n−1. If gcd(g,n−1)=1, then the answer is 2.Otherwise, the answer is 3, since gcd(g,n−1,n)=1.1732B - UguLet's mentally imagine the following array of length n−1: ai=0 if si=si+1, and 1 otherwise. Note that if we apply the operation to the index i, then all the values ​​of the array a do not change, except for ai−1. Let's look at this in more detail: 

For i≤j, note that the jth and (j+1)th elements invert their value, so aj does not change.For j<i−1, note that the j-th and (j+1)-th elements do not change their value, so aj does not change.For j=i−1, note that the jth element does not change its value, but the (j+1)th element does, so aj will change its value.If we look at the array a for a sorted binary string, we can see that this array does not contain more than one unit (you either have a string consisting of only zeros or only ones, or it looks like this — 0000…01…11111 ). 

Let s be the number of ones in the original array a. We have now shown that the answer is ≥max(s−1,0). In fact, if the string starts with 0, then the answer is max(s−1,0), otherwise it is s. 

Let's prove that if the string starts with 0, then we can get the answer max(s−1,0) (the case with 1 will be similar). Let's show a constructive proof using a small example s=0001110010: 

Choose i=3, then s=0000001101,Choose i=7, then s=0000000010,Choose i=9, then s=0000000001.1732C1 - Sheikh (Easy version)Note that f(l,r)≤f(l,r+1). To prove this fact, let's see how the sum and xor change when the element x is added. The sum will increase by x, but xor cannot increase by more than x. 

Then it was possible to use two pointers or binary search to solve the problem. If you solve the problem in the second way, then you iterate over the right boundary of the answer and look for the optimal left boundary for it by binary search. You will need O(1) to find the sum on the segment and xor on the segment. To do this, you can use prefix sums and prefix xor. 

1732C2 - Sheikh (Hard Version)Note that f(l,r)≤f(l,r+1). To prove this fact, let's see how the sum and xor change when the element x is added. The sum will increase by x, but xor cannot increase by more than x. From this we obtain that the maximum value of f is reached on the entire subsegment. 

Next, let's see in which case xor changes exactly by x, because if it changes by a smaller value, then f(l,r) will be strictly less than f(l,r+1). The value of xor will change exactly by x if all 1 bits of x were zeros in the current xor. In fact, this means that if we consider the first logA+1 non-zero element, then at least one of the bits will occur twice, and thus the value of the function will become smaller. 

Let's put all these facts together: we can remove at most logA+1=30+1=31 non-zero element from the beginning and end of the subsegment. Then let's just iterate over how many non-zero elements we remove on the prefix and suffix (their positions can be found using binary search) and using prefix sums and xor-s, calculate the value on this subsegment. 

1732D1 - Balance (Easy version)Let's look at a stupid solution and try to improve it. 

In a stupid solution, we can simply add to the set, and when answering a query, iterate over the numbers 0,k,2k,3k,… and so on until we find the answer. This solution will take a long time if the answer is c⋅k, where c is large. 

We will improve the solution. If a request comes to us for the first time for a given k, then we calculate the answer for it greedily and remember it. In the future, we will no longer check with 0 whether there is a number in the set, but with the previous answer. 

Let's count for each value x how many times we can check for its presence in the set. First, we do this for k such that x is divisible by k. Secondly, the set must already contain elements 0,k,2k,…,x−k, that is, xk numbers. Note that if k is not one of the largest divisors of x, then xk becomes greater than q. Therefore, this solution will work quite quickly. 

1732D2 - Balance (Hard version)Let's look at a stupid solution and try to improve it. 

In a stupid solution, we can simply add and remove elements from the set, and when answering a query, iterate over the numbers 0,k,2k,3k,… and so on until we find the answer. This solution will take a long time if the answer is c⋅k, where c is large. 

We will improve the solution, first consider the solution of the problem without the removal operation. If a request comes to us for the first time for a given k, then we calculate the answer for it greedily and remember it. In the future, we will no longer check with 0 whether there is a number in the set, but with the previous answer. 

Now consider a variant of the problem with the delete operation. Let's set for a fixed k to store all the numbers that we have removed and they are ≤ than the maximum answer found for this k. Then let's see what happens during the search for an answer operation. If set for a given k is not empty, then the answer will be the minimum element from the set, otherwise we will try to improve the current maximum answer for this k (that is, if it was equal to c⋅k, then we will check c⋅k,(c+1)⋅k,…). 

It remains to figure out how we can recalculate these set in the case of an add/remove operation. Let's actually just remember for each value in which set it participates and we will update all of them. 

Let's calculate the running time. Let's understand how many sets a given value x can participate in. First, it lies in sets where x is divisible by k. Second, if x is in the set for the number k, then at least xk numbers have already been added. That is, if x lies in t sets and among these k there are the largest divisors of x, then we should already have added approximately ∑ki=1txki, where ki is the i-th largest divisor of x. Since we have q queries in total, the given value x may not lie in a large number of sets. 

1732E - LocationTasks of this kind, as a rule, are solved using data structures, and this one is no exception. Since the constraints in the problem are not large enough, it is logical to think in the direction of root optimizations. 

Let's divide the array into blocks of length k, we will have about nk such blocks. For each block, we want to maintain a response, i.e. a minimum value of lcm(ai,bi)gcd(ai,bi). 

Let's see what happens with the first type of operation. If the block partially intersects with the segment of the request, then it is possible to go through this block for O(k) and recalculate the answer. There are no more than two such blocks, so in total we will spend O(k) on this (we neglect the running time of gcd). If the block lies entirely in the segment of the request (and there can be nk such blocks), then you need to somehow recalculate the response more quickly. 

To do this, let's precalculate the following value for each block: answerx — what will be the answer in the block if we assign the value x to all numbers. Let's learn how to calculate the answer for a fixed x first. To do this, let's iterate over all divisors d of the number x — in fact, by enumeration of this divisor, we will try to fix gcd. Then note that since we want the value to minimize the value, we need to find the minimum value of bi that is divisible by d. And then we make answerx=min(bid) over all such d. Let's note that gcd(bi,x) may not actually be equal to d, but we know for sure that gcd(bi,x)≥d, and since we want to minimize the value , then we do not do worse. 

Already now we can calculate the answer for AlogA inside the block, where A is the maximum value. But you can do even better! 

Let's note that answerx=min(answerxp⋅p) where p is a prime divisor of x, and don't forget the case when d=x . This follows from the fact that all divisors of the number x are contained among the divisors of numbers of the form xp. 

Let's calculate the running time and find the optimal k. We need to find all its divisors for each number in order to quickly find out the minimum number that is divisible by the given one inside the block — we do this in O(nA−−√). Inside each block, our precalculation now works for O(AloglogA), that is, in total for all blocks O(nk⋅AloglogA). We answer the request for O(k⋅gcd+nk). Hence we get that it is advantageous to take k approximately n−−√ (we have all quantities of the same order, so we use n). 

Codeforces Round #829 Editorial 

By Ormlis, history, 4 months ago, translation, In EnglishThanks for the participation! 

1754A - Technical Support was authored by KAN and prepared by DishonoredRighteous 

1754B - Kevin and Permutation was authored and prepared by KLPP 

1753A1 - Make Nonzero Sum (easy version) and 1753A2 - Make Nonzero Sum (hard version) were authored and prepared by Artyom123 

1753B - Factorial Divisibility was authored and prepared by sevlll777 

1753C - Wish I Knew How to Sort was authored and prepared by TheOneYouWant 

1753D - The Beach was authored by Tikhon228 and prepared by Ormlis 

1753E - N Machines was authored and prepared by Tikhon228 

1753F - Minecraft Series was authored and prepared by teraqqq 

1754A - Technical SupportLet's process each character of the string from left to right and store the number of unanswered questions cnt. Initially this value equals to zero. Consider the i-th character of the string. If it equals to "Q", increase cnt by one. If it equals to "A", decrease cnt by one. If cnt has become negative, it means that some of the questions was answered several times. In this case let's assign zero to cnt. 

If cnt will be equal to zero after processing all string, then all questions were answered, and the answer is "Yes". Otherwise, the answer is "No". 

Time complexity: O(n) for each test case. 

1754B - Kevin and PermutationLet's prove that the minimum difference of consecutive elements is not greater than ⌊n2⌋. To do it, let's prove that larger value is not achievable. Consider element of a permutation with value ⌊n2⌋+1. It will have at least one adjacent element in the constructed permutation. And the maximum absolute difference of this element with the adjacent elements is at most ⌊n2⌋. 

Now we will construct the permutation with the minimum absolute difference of consecutive elements equals to ⌊n2⌋. Assign x=⌊n2+1⌋. Now we can construct such permutation: x,1,x+1,2,x+2,…. It's easy to see that the minimum absolute difference of consecutive elements equals to x−1. 

1753A1 - Make Nonzero Sum (easy version)If the sum of all elements of the array is odd, the partitions does not exist because the partition does not affect the parity of the sum. Otherwise the answer exists. 

Let's build such construction. As the sum of all elements is even, n is even too. Consider pairs of elements with indices (1,2), (3,4), ..., (n−1,n). Consider the pair (2i−1,2i). If a2i−1=a2i, add the segment [2i−1,2i] to the answer. In this case the alternating sum of elements of this segment will be equal to a2i−1−a2i=0. Otherwise we will add two segments to the answer: [2i−1,2i−1] and [2i,2i]. The sum of the first segment is a2i−1, and the sum of the second segment is a2i. The sum of two sums will be equal to zero. So the sum of all alternating sums will be equal to zero. 

1753A2 - Make Nonzero Sum (hard version)If the sum of all numbers in the array is odd, then splitting is impossible, because splitting does not affect the evenness of the sum. Otherwise, we will build the answer constructively. Suppose we have considered some kind of array prefix. Let's keep going until we get exactly 2 non-zero numbers. 

We want to make these two non-zero numbers add up to 0. Then if on the last segment the sum is already equal to 0, then just take it as an answer. Otherwise, consider a few cases: 

If the length of the segment is even, then we simply separate the last number (it will be non-zero) into a separate segment. Then its sign will change and in total these two numbers will give 0.The same can be done if the length of the segment is odd, but its first element is equal to 0. Separate this 0 and repeat the algorithm above.If the length of the segment is odd and the first element is not equal to 0, then we separate it. Then the value of the first element will not change, and the last will change to the opposite, and then their sum will be equal to 0.1753B - Factorial DivisibilityLet's create an array [cnt1,cnt2,…,cntx] where cnti equals to number of elements equals to i in the initial array. 

Note that a1! +a2! + … + an! equals to sum of k!⋅cntk over all k from 1 to x−1, cntx does not affect anything because x! divides x! itself. We have to check if this sum is divisible by x!. 

Suppose there exists some k<x such that cntk≥k+1. In this case we can make two transformations: cntk−=(k+1);cntk+1+=1 and the sum of k!⋅cntk will not change because (k+1)⋅k!=(k+1)!. 

Let's perform this operation until it is possible for all numbers from 1 to x−1. After all operations the sum of k!⋅cntk will not change and for each k<x the inequality cntk≤k will be satisfied because if cntk≥k+1 we could perform an operation with this element. 

Let's see what is the maximum value of sum of k⋅cntk over all k from 1 to x−1 after all operations. We know that cntk≤k for all k, so the maximum value of the sum is the sum of k⋅k! over all k. 

Note that k⋅k!=((k+1)−1)⋅k!=(k+1)⋅k!−k!=(k+1)!−k!. 

It means that the sum of such values over all k from 1 to x−1 equals to (2!−1!)+(3!−2!)+…+(x!−(x−1)!). Each factorial from 2 to x−1 will be added and subtracted from the sum. So the result is x!−1. 

So the only one case when this sum is divisible by x! is when the sum equals to 0. It means that cntk equals to zero for all k from 1 to x−1 after performing all operations. 

Time complexity: O(n+x). 

1753C - Wish I Knew How to SortLet the number of zeros in the array be g. Let dp[k] be the expected number of swaps needed when there are k zeros in the first g positions. Then, we know that dp[g]=0, and we can write down the recurrence equations for dp[k] by considering the case where some element equals to one from the first g positions and some element equals to zero from the last (n−g) positions are swapped. 

This is the only case where the dp value will change. Thus, our recurrence is as follows. 

Let p=2⋅(g−k)⋅(g−k)n⋅(n−1). Then dp[k]=1+dp[k]⋅(1−p)+dp[k+1]⋅p. 

The answer is dp[o], where o is the initial number of zeros in the first g positions. 

1753D - The BeachLet's paint our field in a chess coloring. 

Now let's consider our operations not as the movement of sunbeds, but as the movement of free cells. Then, a free cell adjacent to the long side of the sunbed can move to a cell of the sunbed that is not adjacent to this one, for p units of discomfort. A free cell adjacent to the short side of the sunbed can move to a cell of the sunbed that is not adjacent to this one, for q units of discomfort. Note that in this cases, the free cell does not change its color (in chess coloring). 

Since each sunbed should occupy one black and one white cell, then some two free cells of different colors should move to neighboring ones using operations. 

It can be shown that in the optimal answer we use no more than one operation with each sunbed. 

Then, for each position, looking at the adjacent sunbeds, we will determine where the free cell can move if it turns out to be in this position. Let's construct a weighted oriented graph on the cells of the field. Edge (x1,y1)→(x2,y2) of weight w (equal to p or q) will mean that there is a sunbed such that by moving it with an operation that brings w discomfort, we will free the cell (x2,y2) and block the cell (x1,y1). 

Note that the graphs on the black and white cells are not connected. Let's run Dijkstra's algorithm from all free cells at once. Then, for each cell dx,y - the minimum distance in this graph from a free cell is equal to the minimum amount of discomfort that must be used to free this cell. 

The answer to the problem is the minimum for all pairs (x1,y1), (x2,y2) neighboring cells, dx1,y1+dx2,y2. Or −1 if there is no pair of adjacent cells, both of which are reachable from the free ones. 

Asymptotics of the solution: O(nm⋅log(nm))1753E - N MachinesLet C bi the maximum value of the resulting product before any movements. The problem statement says that it is guaranteed that C≤2⋅109. 

Observation 0 — after each movements the value of the resulting product is not greater than C24.Observation 1 — each machine of kind (∗,ai) should be moved to the end of the sequence, and each machine of kind (+,ai) — to the beginning of the sequence, and the order of movements does not make sense.Observation 2 — there are at most log2C non-trivial machines of kind (∗,ai) (such machines that ai≠1). We will need some more strong observation for machines of kind (∗,ai), but this will be useful too.Observation 3 — if there are two machines (∗,ai), (∗,aj), where i<j and ai>=aj, then in optimal answer machine j may be moved if and only if machine i is moved too. It is true because we could increase the answer otherwise, by moving machine i instead of machine j.The last two observations says that there are not many subsets of machines of kind (∗,ai) (that satisfies the property from observation 3). Let's say that there are F(C) such subsets, in the end of the editorial we will estimate this value. 

Let's pick out subsegments of machines of kind (+,ai) between machines of kind (∗,ai), sort them and count prefix sums. There will be not more than log2C+1 such segments. In the optimal answer some maximums will be moved from each of the segments. 

Let's fix some subset of machines of kind (∗,ai), that will be moved to the end, and count the current value of the output product. Consider some element (+,aj) in the array. Let the product of machines (∗,ai) to the left of it be lmul, and to the right of it — to be rmul. Now if we move this element to the beginning of the array, the value of the resulting product will increase by lmul−1lmul⋅rmul⋅aj. Let's call this profitj. Now we have to find the sum of some numbers of maximum values profitj. 

Let's use binary search to find some "critical" value profit: such value that all elements profitj≥profit will be moved to the beginning. profitj of each element is not greater than C2/4. Inside binary search we have to iterate over all segments of elements (+,ai) and find the number of elements with profitj≥profit inside this segment using binary search. We have to check if we can to move the selected amount of elements to the beginning of the array to understand how to move borders of the external binary search. 

After we find the critical value profit, let's iterate over all segments (+,ai) and add the sum of elements that are profitj≥profit to the answer. Separately let's consider elements with profitj = profit−1. We could move some of them to the beginning too. Let's update the answer with this value. 

Time complexity: O(F(C)log32(C)+n⋅log2(n)). It should be noted that this estimate is actually higher than in fact. 

Let's estimate the value F(C) now: 

Consider some sequence b1,b2,…,bk, such that b1⋅b2⋅ … ⋅bk≤C and 2≤biSort it by ascending, b1≤b2≤⋯≤bk — the product of elements will not change and the number of "interesting" subsets will not become smaller.Replace all the smallest elements of the sequence with 2, the second minimums with 3 and so on. If there are smaller number of elements equals to x than elements equals to y and x<y, let's swap their numbers. Now the number of interesting subsets is not changed, b1⋅b2⋅ … ⋅bk is not increased. The sequence looks like 2,2,…,3,…,4,… now.The number of interesting subsets in the new sequence equals to (cnt2+1)⋅(cnt3+1)⋅…, where cntx is the number of elements if sequence equals to x.(Let's run the code that will brute-force over all sequences of such kind and see that the number of interesting subsets is 4608, which is achieved on sequence 2,2,2,3,3,4,4,5,6,7,8,9,10,11)Let's continue estimating this value "fairly": the elements of the sequence do not exceed 12 because 13!>C. Let's replace each number with a prime number corresponding to it by order: p2=2,p3=3,p4=5,p5=7,p6=11,... and replace all elements x with px. The product of elements will increate in at most maxx((pxx)logx(C)) times, so the product will not exceed maxx(Clogx(px)). It is easy to check that the maximum is achieved in x=6, so the product is not greater than Clog611 ≤3⋅1012.The number of interesting subsets of our sequence does not exceed the number of divisors of received numbers that can be estimated as (3⋅1012)(1/3) ≤150001753F - Minecraft SeriesLet's formalize the problem condition. It is required to calculate the number of squares s in the table for which we have inequality A+B≥T, where A is a MEX of positive integers in the sqare and B is a MEX of absolute values of all negative integers in the square. Then we denote cost of a square as A+B. Note that when the square is expanded, its value cannot decrease. 

Let's fix the diagonal that contains the upper left and lower right sides of the square. Now, with a fixed lower right cell, we want to maintain the upper left cell of the square that is maximally removed from it so that its cost does not exceed T−1. Note that this upper-left boundary can only shift in the direction of moving the right lower one, which means we can use the two pointers technique. 

We will also need to maintain a set of numbers that are contained in a square. To do this, we will process each cell separately, which are added and removed from our square. Note that for each cell there are no more than min{N,M} diagonals on which it is possible to construct a square containing this cell, and also note that due to the structure of our solution for each such diagonal, our cell will be added to the set no more than 1 time. Thus, the total number of additions of cells to our set does not exceed MN⋅min{N,M}, and accordingly the total number of additions of numbers to the set does not exceed K⋅min{N,M}. 

We will also need to find out the MEX of all positive integers in the square, as well as the MEX of absolute values of negative integers in the square. Here we need to make another observation about our algorithm. The number of MEX queries will not exceed 2MN. That is, you can use the square roots technique to adding and removing integers in O(1) time, and find out the MEX values in O(K−−√) time. 

To summarize, our algorithm will work in asymptotic time: 

O((NM+K)⋅min{N,M}+NMK−−√)As the author of the problem, I want to apologize for the very low TL in this problem. Due to the specificity of the task, it was difficult to cut off the wrong solutions. The solution described above, if implemented correctly, fits into TL with a time reserve at least 1 second. But if suddenly you didn't write it efficiently enough and you have TL, then you can try using the following tips: 

Sort the numbers in each cell. This will help to better in the cache. It does benefit buffering provided by a cache.It is more accurate to implement your algorithm without making unnecessary MEX queries.Use bit magic and implement the MEX search in O(ω+K/ω) time where w=64 is machine word size. Such a solution may have a better time-constant and it is better to be vectorized 

Codeforces Round #828 (Div. 3) Editorial 

By 74TrAkToR, history, 4 months ago, In RussianСпасибо за участие! 

1744A - Number Replacement придумал MikeMirzayanov, подготовил 74TrAkToR 

1744B - Even-Odd Increments придумал и подготовил 74TrAkToR 

1744C - Traffic Light придумали MikeMirzayanov и 74TrAkToR, подготовил 74TrAkToR 

1744D - Divisibility by 2^n придумал и подготовил 74TrAkToR 

1744E2 - Divisible Numbers (hard version) придумал и подготовил 74TrAkToR 

1744F - MEX vs MED придумал и подготовил 74TrAkToR 

1744A - Number ReplacementLet's note that if ai=aj, then si must be equal to sj, since we must change the same value to the same letter. If we check this for all pairs of i and j and find no such contradictions, then the answer is "YES", otherwise "NO". 

We got the solution for O(n2) for one test case. 

1744B - Even-Odd IncrementsLet sum — the initial sum in the array, cnt0 — the number of even numbers, cnt1 — the number of odd numbers. 

Let's see how these values ​​change with each action. In fact, we can consider four main options: 

Add an even number x to all even numbers. Then sum will increase by x⋅cnt0, and the number of even and odd numbers will remain the same.Add an odd number x to all even numbers. Then sum will increase by x⋅cnt0, the number of even numbers will become 0, all numbers will become odd, so cnt1=n.Add an even number x to all odd numbers. Then sum will increase by x⋅cnt1, and the number of even and odd numbers will remain the same.Add an odd number x to all odd numbers. Then sum will increase by x⋅cnt1, the number of odd numbers will become 0, all numbers will become even, so cnt0=n.1744C - Traffic LightLet's note that for each second of color c in the traffic light, we need to find the rightmost green time, and then find the largest distance between color c and the nearest green. Also, let's not forget that traffic light states are cyclical. 

To get rid of cyclicity, you can write the string s twice and for each cell of color c from the first half, find the nearest green color (thus we solved the problem with cyclicity). And now we can just follow this line from right to left and maintain the index of the last occurrence of green. If we encounter color c, then we try to update our answer ans=max(ans,last−i), where ans is our answer, last is the nearest time that green was on color, i — current time. 

1744D - Divisibility by 2^nLet's notice that if we multiply the numbers a1⋅a2⋅…⋅an, then the power of two of the product is equal to the sum of the powers of two in each of the numbers. 

Let's calculate the initial sum of the powers of twos in the product. This can be done as follows: let's take the element ai and divide it by 2 as long as we can, while remembering to increase our counter by the number of occurrences of a power of two. 

Now let's move on to operations and note that choosing the index i will increase the degree of occurrence of two by a fixed number (that is, it does not matter when to apply this operation). Choosing an index i will increment the counter by a number x such that i is divisible by 2x but not by 2x+1 — you can find this x, again , by dividing by 2 while we can. 

Since we want to minimize the number of operations used, at each moment of time we will try to use an index that increases the counter by the largest number. To do this, it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest. 

We get the solution in O(nlogn+nlogA). 

1744E2 - Divisible Numbers (hard version)Let's look at the slow solution first, which will lead us to the full one. Let's iterate over the number x from a+1 to c. 

Given a number x, we want to find a y from b+1 to d such that x⋅y is divisible by a⋅b. Since x⋅y must be divisible by a⋅b, the following conclusion can be drawn: y must be divisible by a⋅bgcd(a⋅b,x). Let's denote this number as s. Now our task is to check if there is a multiple of s between b+1 and d. The problem can be solved in many ways, you can simply consider the largest multiple of s that does not exceed d — it is equal to ⌊ds⌋⋅s We compare this number with b+1, and if it matches, then we have found a suitable pair. 

Now let's note that we do not need to iterate over all the values ​​of x, because from the number x we are only interested in gcd(x,a⋅b) — and this is one of the divisors of a⋅b! 

Even though the product a⋅b can be large, we can still consider all divisors of this number, since a and b themselves are up to 109. Let's find the divisors of a and b separately, then notice that any divisor of a⋅b — is a′⋅b′, where a′ — is some divisor a, and b′ — is some divisor b. 

Let's calculate the running time. We need to factorize the numbers a and b into prime factors, this can be done in O(a−−√). Next, you need to iterate over pairs of divisors a and b. Recall the estimate for the number of divisors of a number (https://oeis.org/A066150): the number x up to 109 has no more than 1344 divisors. Therefore, we can sort through the pairs for 13442. We learned how to find the optimal y for O(1). We get that for each test case we have learned to solve the problem in O(a−−√+(13442)). 

1744F - MEX vs MEDLet's learn how to count the number of subsegments where mex>mid for a fixed value of mex. 

Let's understand on which subsegments mex has such a value. We understand that the numbers 0,1,…,mex−1 should be in this subsegment, the number mex — should not, and then — does not matter . Let ℓ — be the index of the left-most occurrence of the numbers 0,1,…,mex−1, and r — the right-most occurrence. Also, let pos "be the index of the number mex. If ℓ<pos<r, then there is no subsegment with the given mex, otherwise let's think about how many numbers can be in a subsegment. 

It is stated that if the length of a segment is ≤2⋅mex, then mex>mid on it, otherwise it is not true. Indeed, if the length of a segment is ≤2⋅mex, then simply by the definition of the median, it will be among the first mex numbers. On the other hand, if the length of the segment becomes longer, then according to the same definition of the median, it will no longer be among the first mex numbers, which are equal to 0,1,…,mex−1. 

It turns out that we need to count the number of subsegments of length ≤2⋅mex that contain the subsegment ℓ…r inside themselves, but not pos. This, of course, can be done with large formulas and the like, but one more useful fact can be noticed! 

If we iterate over mex in ascending order, and at the same time maintain ℓ and r, then let's see what happens with a fixed mex and a position of pos (for convenience, let's assume that pos<ℓ, since the second case is similar). In fact, you can simply iterate over the left border of our segment from pos+1 to ℓ, and then use a simpler formula to calculate the number of good subsegments with such fixed values. 

Why can this left boundary be iterated for each mex if pos<ℓ (correspondingly, if it were pos>r, then we would iterate over the right boundary) ? Let's remember that after this step, ℓ becomes equal to pos. That is, if we iterate over an element, then we move the corresponding border. And we can only move it O(n) times. 

Codeforces Round #827 (Div. 4) Editorial 

By flamestorm, 5 months ago, In EnglishThanks for participating! 

1742A - Sum 

Idea: flamestorm 

Tutorial1742A - SumYou only need to write an if statement and check if any of these are true: a+b=c, b+c=a, c+a=b. 

Solution1742B - Increasing 

Idea: mesanu 

Tutorial1742B - IncreasingIf there are two elements with the same value, then the answer is NO, because neither of these values is less than the other. 

Otherwise, the answer is YES, since we can just sort the array. 

The time complexity is O(nlogn) or O(n) depending on the implementation. 

Solution1742C - Stripes 

Idea: flamestorm 

Tutorial1742C - StripesNote that if a stripe is painted last, then the entire stripe appears in the final picture (because no other stripe is covering it). 

Since rows are only painted red and columns are only painted blue, we can just check if any row contains 8 Rs. If there is such a row, then red was painted last; otherwise, blue was painted last. 

BonusSolution1742D - Coprime 

Idea: badlad, SlavicG 

Tutorial1742D - CoprimeNote that the array has at most 1000 distinct elements, since ai≤1000. For each value, store the largest index it is in. Then we can brute force all pairs of values, and find the coprime pair with largest sum of indices. 

The time complexity is O(a2ilogai+n) per testcase. 

Solution1742E - Scuza 

Idea: mesanu 

Tutorial1742E - ScuzaLet's compute the prefix sums of the array a: let bi=a1+⋯+ai. Rephrasing the problem: for each question containing an integer k, we need to find the largest ai such that a1,…,ai are all at most k, and then output bi. In other words, max(a1,…,ai)≤k. 

Let's make the prefix maximums of the array: let mi=max(a1,…,ai). Then we need to find the largest i such that mi≤k, which is doable using binary search, since the array m is non-decreasing. Once we find the index i, we simply need to output bi. 

The time complexity is O(nlogn) per testcase. 

Solution1742F - Smaller 

Idea: SlavicG 

Tutorial1742F - SmallerFirst of all, let's think about how we should rearrange the two strings in such a way that a<b (if that is ever possible). It's always optimal to arrange a's characters increasingly in lexicographic order and b's characters decreasingly. 

Since initially both a and b contain a character "a", the first time b receives any other letter than "a" the answer will always be "YES", because that character will always be lexicographically larger than a's first character which should be "a". 

In the other case, we know that b doesn't have any other characters than "a", so we can compare the string a with multiple "a" characters and we know that a will be smaller if and only if it's only formed of "a"s and has a smaller size than b. 

Solution1742G - Orray 

Idea: SlavicG 

Tutorial1742G - OrrayNote that in this context maxval denotes 109. 

We can make the observation that only the first log2(maxval) elements matter, since after placing them optimally we can be sure all bits that could be set in the prefix OR would have already been set. So, we can brute force the optimal choice log2(maxval) times (we choose to add an element if it provides the largest new prefix OR value among all unused elements) and then just add the rest of the unused elements. 

Solution 

Codeforces Round #826 (Div. 3) Editorial 

By Vladosiya, history, 5 months ago, translation, In English1741A - Compare T-Shirt Sizes 

Idea: MikeMirzayanov 

Tutorial1741A - Compare T-Shirt SizesLet sa, sb are the last characters of lines a and b respectively. And |a|,|b| are the sizes of these strings. 

sa≠sb: then the answer depends only on sa and sb and is uniquely defined as the inverse of sa to sb ("<" if sa>sb, ">" if sa<sb, since the characters S, M, L are in reverse order in the alphabet).sa=sb:|a|=|b|. Then the answer is "=". This also covers the case sa=sb=M;sa=sb=S. Then the larger the size of the string, the smaller the size of the t-shirt. That is, the answer is "<" if |a|>|b| and ">" if |a|<|b|;sa=sb=L. Then the larger the size of the string, the smaller the size of the t-shirt. That is, the answer is "<" if |a|<|b| and ">" if |a|>|b|;Solution1741B - Funny Permutation 

Idea: MikeMirzayanov 

Tutorial1741B - Funny PermutationWe cannot make a funny permutation only when n=3, because one of the neighboring elements of 3 must be equal to 2. Any permutation made in this way will not satisfy the conditions: 

The permutation [3,2,1] will have a fixed point p2=2.The permutation [1,3,2] will have a fixed point p1=1.The permutation [2,3,1] will not have a neighbor equal to p3+1=1+1=2 for p3=1.For the remaining values of n, make the following observations: 

For n=2, the only funny permutation is [2,1].When n≥4, permutations of the form [3,…,n,2,1] will always be funny because all elements pi will have a neighbor equal to pi−1 or pi+1, and the permutation will have no fixed points (pn−1=2, pn=1, and for 3≤i≤n−2 will always be true pi=i+2).Solution1741C - Minimize the Thickness 

Idea: MikeMirzayanov 

Tutorial1741C - Minimize the ThicknessLet's iterate over the length of the first segment of the split. Having fixed it, we actually fixed the sum that needs to be collected on all other segments. Since each element must belong to exactly one segment, we can build other segments greedily. If we have found a solution, we will remember the length of the longest segment in it and try to update the answer. We have n possible lengths of the first segment, for each of which we greedily built the answer for n. Thus, the asymptotics of the solution will be O(n2). 

Solution1741D - Masha and a Beautiful Tree 

Idea: Gornak40 

Tutorial1741D - Masha and a Beautiful TreeLet some vertex be responsible for a segment of leaves [l..r]. Then her left son is responsible for the segment [l..l+r−12], and the right for the segment [l+r+12..r]. Note that if we do not apply the operation to this vertex, then it will not be possible to move some element from the right son's segment to the left son's segment. It remains to understand when we need to apply the operation to the vertex. Let the maximum on the segment [l..r] be max, the minimum on the same segment is min. Then if min lies in the right son, and max in the left, then we should obviously apply the operation, for the reason described above. In the case when min lies in the left son, and max in the right, the application of the operation will definitely not allow you to get a solution. Let's continue to act in a similar way recursively from the children of the current vertex. At the end, we should check whether we have received a sorted permutation. The above solution works for O(nm), since there are n levels in the tree and at each level, vertexes are responsible for m sheets in total. You can optimize this solution to O(m) if you pre-calculate the maximum and minimum for each vertex. 

Solution1741E - Sending a Sequence Over the Network 

Idea: MikeMirzayanov 

Tutorial1741E - Sending a Sequence Over the NetworkLet's introduce the dynamics. dp[i]=true if on the prefix i the answer is Yes. 

Then in this sequence b the numbers corresponding to the sizes of the segments from the partition a into subsegments will be called interesting. 

A number at position i in the sequence b, if it is interesting, is either to the right or to the left of the segment. 

If it is to the left of the segment, it can only be interesting if dp[i−1]=true. Then dp[i+b[i]]=true.If it is on the right side of the segment, then if dp[i−b[i]−1]=true, then dp[i]=true.The answer for the whole sequence is Yes if dp[n]=true. 

Solution1741F - Multi-Colored Segments 

Idea: MikeMirzayanov, DmitriyOwlet 

Tutorial1741F - Multi-Colored SegmentsLet's go through the segments 2 times: in non-decreasing coordinates of the left end, and then — in non-increasing coordinates of the right end. To walk a second time, just multiply the coordinates of the left and right borders by −1, and then swap them and walk from left to right. 

Going through the segments in non-decreasing coordinates of the left end, you need to find for each segment a segment that starts not to the right of the current one and ends as far to the right as possible. If the coordinate of its right end is not less than the coordinate of the left end of the current segment, then it intersects with it, otherwise the distance between them is equal to the distance between the coordinate of the left end of the current segment and the maximum coordinate of the right end of the segment starting to the left of ours. 

Note that it is enough for us to store no more than 2 segments: for each color we will store the maximum right coordinate of the segment of this color, which has already been considered. If we store the 2 colors with the largest right coordinates, then one of them is definitely not equal to the current one. When considering a segment, we add it to the list, and if the size of the list becomes 3, then we leave 2 of optimal elements. 

Solution1741G - Kirill and Company 

Idea: Vladosiya 

Tutorial1741G - Kirill and CompanyTo begin with, let's learn how to find possible sets of friends for the vertex, whom he can give a ride, in the form of masks. Let's use a breadth first search, every time we find the shortest path to the vertex u with the previous vertex v, we will add the masks of the vertex v to the masks of the vertex u, updating them with friends living in u. 

Now, according to the resulting sets, you need to get the best combination of them. We will find it using the knapsack problem, we will use masks as weights, and the total weight will be the bitwise OR of the selected set. 

Solution 

Codeforces Round #825 (Div. 2) Editorial 

By satyam343, 5 months ago, In EnglishThank you for participation! We apologize for problem D that turned out to be harder than expected. Still, we hope that you liked most of the problems. 

In case you found C2 tedious to implement or found many cases to deal with, I would recommend you to have a look at the intended solution. I think it is interesting and easy to implement. 

1736A - Make A Equal to B 

SolutionIt is easy to observe that the second operation needs to be performed at most once. Now, we just need to check 2 cases, one in which the re-arrangement operation is used, and one in which it is not. 

If the re-arrangement operation is to be used, then we just need to make the counts of 0s and 1s in a equal to that of b. Without loss of generality assume a contains x more 0s than b, then the cost in this case will just be x+1 (extra one for re-arrangement cost). 

If the re-arrangement operation is not to be used, then we just need to make each element of a equal to the corresponding element of b. 

Finally, our answer is the smaller cost of these 2 cases. 

Time complexity is O(n). 

Code1736B - Playing with GCD 

SolutionTake a0=an+1=1. 

Now take bi=lcm(ai−1,ai) for 1≤i≤n+1. If b gives us a after performing the gcd operations, then the answer is YES, otherwise the answer is NO. (When answer is NO, we would get a case like gcd(bi,bi+1)=k⋅ai(where k>1 for some i). 

Suppose c is some valid array which gives us a. So, ci should be divisible by bi. This means gcd(ci,ci+1)≥gcd(bi,bi+1). 

So, if gcd(bi,bi+1)>ai for any i, we should also have gcd(ci,ci+1)>ai. This implies that c is not valid if b is not valid. 

Time complexity is O(n⋅log(bmax)). 

Code1736C1 - Good Subarrays (Easy Version) 

SolutionSuppose l[i] represents the leftmost point such that subarray a[l[i],i] is good. 

Notice that the array l is non-decreasing. 

So suppose dp[i] denotes the length of longest good subarray which ends at index i. 

Take dp[0]=0. 

Now dp[i]=min(dp[i−1]+1,a[i]). 

Suppose a[i]≥dp[i−1]+1. Now we claim that dp[i]=dp[i−1]+1. We know a[i−dp[i−1],i−1] is \t{good}. Now if we look at array b=a[i−dp[i−1],i], bi≥i for 1≤i≤dp[i−1]. For b to be good, last element of b(which is a[i]) should be greater than or equal dp[i−1]+1(which is consistent with our supposition). So b is good. 

We can similarly cover the case when a[i]<dp[i−1]+1. 

So our answer is ∑ni=1dp[i]. Time complexity is O(n). 

Code1736C2 - Good Subarrays (Hard Version) 

SolutionLet us continue the idea of C1. 

Suppose track[i] denotes ∑nj=idp[j] if dp[i]=a[i]. 

We can precalculate array track. 

Now suppose ap is changed to x and adp[i] denotes the length of longest good subarray which ends at index i in the updated array. 

It is easy to see that adp[i]=dp[i] for 1≤i<p. Now let q be the smallest index greater than p such that adp[q]=a[q](It might be the case that there does not exist any such q which can be handled similarly). So we have 3 ranges to deal with — (1,p−1), (p,q−1) and (q,n). 

Now ∑p−1i=1adp[i] = ∑p−1i=1dp[i](which can be stored as prefix sum). 

Also ∑ni=qadp[i] = track[q]. 

Now we only left with range (p,q−1). An interesting observation is adp[i]=adp[i−1]+1 for p<i<q. 

This approach can be implemented neatly in many ways(one way is answer each query offline). 

Time complexity is O(n⋅log(n)). 

Code(Offline queries)Code(Online queries)1736D - Equal Binary Subsequences 

SolutionIt is easy to see that a necessary condition for a solution to exist is that the number of 1 in s should be even. It turns out that this condition is sufficient too. 

Here is one valid construction: 

We make n pairs of the form (s[2i−1],s[2i]) for (1≤i≤n). 

Assume we have x pairs in which both elements are different and n−x pairs in which both elements are same. 

\textbf{Claim} — x should be even. 

\textbf{Proof} — Assume that among the n−x pairs in which both elements are same, we have y pairs in which both elements are 1. So number of 1 in s is x+2⋅y. We know that number of 1 in s is even, so for x+2⋅y to be even, x should also be even. 

Now we will select x indices; exactly one index from each of the x pairs in which both elements are distinct. Take the index of 0 from ith pair if i is odd, else take the index of 1. Thus our selected characters = 0,1,0,1,…,0,1Now on cyclically shifting the selected characters clockwise once, we can see that elements at selected indices got flipped. 

Since, elements in those x pairs were distinct initially, and we flipped exactly one character from each of those x pairs, both elements of those x pairs are same now. 

Hence, in updated s, s[2i−1]=s[2i]. 

So, for s1, we can select characters of all odd indices. 

Finally we'll have s1=s2. Time complexity is O(n). 

Code1736E - Swap and Take 

SolutionAs the constraints suggest, we should use dp to solve this problem. 

Let's write the original indices of the array that are added during this process — p1,p2,…,pn. None of added numbers are zeroed in an optimal answer. It gives that p1≤p2≤…≤pn and the answer is equal to the sum of a[pk] (1≤k≤n). 

To get the optimal answer we'll use dp[t][last][m] = maximum score on t-th turn if pt=last and we have performed m swapping moves (the first dimension can be omitted). Note that m≤i. It can be updated by considering the next index but it will take O(n4). The most straightforward way to improve it to O(n3) is to use prefix maximums. 

Here are some details. 

We have only two cases: 

pt=pt−1 — In this case, our transition is just dp[t][last][m]=dp[t−1][last][m−1]+a[last]pt>pt−1 — Let us make some observations. First of all, pt≥t. So number of swaps to bring pt to index t is fixed. It is pt−t. So dp[t][last][m]=maxlast−1j=1(dp[t−1][j][m−(pt−t)])+a[last]. Note that we can find maxlast−1j=1(dp[t−1][j][m−(pt−t)]) in O(1). Hint — use prefix maximum. 

Time complexity is O(n3). 

Code 

Codeforces Round #824 — editorial 

By Akulyat, 5 months ago, In English1735A - Working Week 

Hint1Answer to Hint1SolutionLet's consider that l1, l2, and l3 are sorted working segments. 

If l1 is not equal to 1 then we can decrease l1 by 1 and increase l3 by 1. So we'll increase the answer. 

We've got that l1=1 and we have to work just with l2 and l3. 

Now, our problem can be rewritten as:l2+l3=n−4, maximize min(l2−1,l3−l2). 

And as we know that l3=n−4−l2, just:maximize min(l2−1,n−4−2⋅l2). 

If we increase both values under the minimum scope by one, solutions don't change:maximize min(l2,(n−3)−2⋅l2). 

If we choose l2=⌊n−33⌋, then min(l2,(n−3)−2⋅l2)=⌊n−33⌋.If the answer is greater, then l2>n−33 and (n−3)−2⋅l2>n−33, and it means that 2⋅(l2)+((n−3)−2⋅l2)>n−3 but 2⋅(l2)+((n−3)−2⋅l2)=n−3. 

The only thing is left to do is to calculate final answer. And it is ⌊n−33⌋−1 or just ⌊n3⌋−2. 

It was a mathematician way of solving. As it's pretty obvious that l2 is approximately n3, you could check l2=n3±5 and choose the best among them. 

Code1735B - Tea with Tangerines 

Hint1Hint2SolutionLet's start with a simple solution. 

Let's choose the minimum piece from a and assume that it will remain the minimum until the end.As the array is sorted, let's define the minimum piece as a1.It means that in the end, all pieces must be smaller or equal to 2⋅a1−1. 

The lower bound of the answer for this solution is ∑i=1n⌈ai2⋅a1−1⌉. 

Let's show that this is achievable.For each piece, while its size greater than 2⋅a1−1, let's cut off a piece of size 2⋅a1−1.The only problem is that we could get a piece smaller than a1 in the end.But it means that before the last cut we had a piece in the range [2⋅a1,3⋅a1−2]. All pieces in this range can be easily cut into pieces of the right size in one move. 

The only left question is why the minimum piece in the end should have size a1. Actually, it shouldn't, but it gives the best answer anyway.As was described above, the lower bound of the solution with the minimal piece of size x in the end is ∑i=1n⌈ai2⋅x−1⌉.Having a minimal piece with a smaller size, we can't get anything better, because the lower bound will be equal or greater for all x<a1. 

Code1735C - Phase Shift 

Hint1Answer to Hint1Hint2Hint3Answer to Hint3SolutionFirst of all, the encryption process is reversible. If we obtained t from s using the circle c, we can obtain s from t using the same cycle c, but reversed.So, let's think in terms of encryption of t. 

Lexicographical order itself is a greedy thing. So, we can create a greedy algorithm. 

Let's go from left to right and generate the result letter by letter. We have to choose the best possible option at each step. Let's describe the options we have. 

If the current letter was used earlier, we already know the replacement we need to choose.Otherwise, we would like to choose the minimum possible option. We need to maintain some structure to know what is acceptable.Let's keep the circle that is already generated(it's a graph). For each letter we have one incoming edge and one outgoing edge in the end. Let's keep them for every letter: arrays in[26], out[26].When we want to generate an outgoing edge at some step(let's define the letter on this step as x), we have to choose the minimum letter that doesn't have an incoming edge yet. With one exception: if creating the edge using this rule creates a circle of size less than 26. It would mean that we wouldn't have a full circle in the end. It's easy to see that there is no more than one such letter, as this letter is just the end of a chain starting in x.To check that a small circle wasn't generated, we can go along an outgoing edge 26 times, starting at x. If we end up in x or there was no edge at some step then everything is ok, we can create this edge. 

Complexity is O(26⋅26+n), that is, O(n). 

Code1735D - Meta-set 

Hint1Answer to Hint1SolutionFor every two cards, there is always a single card that forms a set with them.[1] That means that two sets can share at most one card. 

Let's prove that there are no more than 2 sets in a meta-set.Let's define 5 cards as c1,c2,c3,c4,c5. Let's guess that (c1,c2,c3) is a set.All other sets can have at most one card among (c1,c2,c3) (according to [1]), so they must include c4 and c5. So we have at most one other set, otherwise they would have two same cards, which is prohibited according to [1]. 

So, every meta-set looks like 2 sets with one common card. Let's call this card a central card. 

Now there is just a simple combinatorics. For each card, we want to know the number of sets that include it. If this number is s, then we should add s(s−1)2 to the answer — it is the number of meta-sets with this card as a central card. 

To get the number of sets for each card, we can iterate over all pairs of cards (i,j), generate the complement to the set, and add 1 to that card in a map/hashmap. 

Complexity is O(kn2log(n)) or O(kn2). 

Code1735E - House Planning 

Hint1Answer to Hint1Hint2Hint3SolutionLet's assume that considered point p1 was to the left of considered point p2.Let's assume that we know the distance l between considered points p1 and p2. Let's show how to solve this problem in linear time(almost linear). 

As long as there is a value greater than l, let's get the largest among them(let's call it x). Let's assume that this value is from d1.It's easy to see that this point is to the right of the considered point p2 (because the largest distances is to the point p1). It means that we can match distance x from d1 to the distance x−l from d2. 

When there is no value greater than l, all other houses are located between considered points. We can match them by sorting. 

That is the O(nlog(n)) solution. 

Let's limit possible options of l with O(n) options.If we know that some house has distances x and y to considered options, then there are 2 options of l: x+y and |x−y|.Let's consider 2⋅n options d1[1]+d2[i], |d1[1]−d2[i]|. 

Complexity is O(n2log(n)). 

Code1735F - Pebbles and Beads 

Hint1Hint2Hint3SolutionLet's draw currencies on 2D plane. Having x pebbles and y beads is described as point (x,y).Let's assume that we can throw out any amount of money at any moment. In this case, an area of possible points can be described as a convex polygon in the upper-right quarter. Initially it is the rectangle [(0,0),(0,b),(a,b),(a,0)].At any moment, this polygon can be described as a list of segments starting at point (0,y0) and finishing at point (xk,0). In the rectangle described above, there are 2 segments.Let's keep those segments sorted by angle. 

When a new day comes, each point can be shifted by the vector c⋅(pi,−qi) ∀c∈[−1,1] if the new point has non-negative coordinates.If we forget about new points to be non-negative, how new segments look like?We just have to add new segment (2⋅pi,−2⋅qi) and shift a prefix of old segments by (−pi,qi) and remaining suffix of segments by (pi,−qi).Then the only thing left to do is to cut segments to keep our polygon non-negative.Sounds great, but sounds like O(n2). 

Do we need to maintain segments explicitly?No!Let's just keep the set of their lengths and angles. Knowledge of extreme points (0,y0) and (xk,0) is enough.So we need to: 

Insert a new segment to the set. (You need just length and angle).Shift extreme points (0,y0) and (xk,0) by (−pi,qi) and (pi,−qi) correspondingly.Delete or cut the last and first segments while they are out of the non-negative area.Complexity O(nlog(n)). 

There is another simple O(n2log(n)) approach:We can keep the area as a polygon. At each step, create two copies shifted by corresponding vectors. Build a convex hull of them. Cut this convex hull to be in the non-negative area.It won't fit. Mentioned just for fun. 

Code 

Codeforces Round #823 — editorial 

By Brovko, 5 months ago, In English1730A - PlanetsTo solve the problem, it was enough to count the number of planets with the same orbits cnti and sum up the answers for the orbits separately. For one orbit, it is advantageous either to use the second machine once and get the cost c, or to use only the first one and get the cost equal to cnti. 

Jury solution: 173498496 

1730B - Meeting on the LineThere are many solutions to this problem, here are 2 of them. 

1) Let people be able to meet in time T, then they could meet in time T+ε, where ε>0. So we can find T by binary search. It remains to learn how to check whether people can meet for a specific time T. To do this, for the i-th person, find a segment of positions that he can get to in time T: if T<ti then this segment is empty, otherwise it is [xi−(T−ti),xi+(T−ti)]. Then people will be able to meet only if these segments intersect, that is, the minimum of the right borders is greater than or equal to the maximum of the left borders. In order to find the answer by the minimum T, you need to intersect these segments in the same way (should get a point, but due to accuracy, most likely, a segment of a very small length will turn out) and take any point of this intersection. Asymptotics is O(nlogn). 

2) If all ti were equal to 0, then this would be a classical problem, the solution of which would be to find the average of the minimum and maximum coordinates of people. We can reduce our problem to this one if we replace the person (xi, ti) with two people: (xi−ti, 0) and (xi+ti, 0). Proof. Let the meeting be at the point y. Let xi≤y. Then this person will need ti+y−xi of time to get to her, and the two we want to replace him with — y−xi+ti and y−xi−ti. it is easy to see that the first value is equal to the initial value, and the second is not greater than the initial value, then the maximum of these two values is equal to the initial value. The proof is similar for the case y≤xi. Then for any meeting point, the time in the original problem and after the replacement does not differ, which means that such a replacement will not change the answer and it can be done. Asymptotics is O(n). 

binary search: 173497901 

classic: 173497940 

1730C - Minimum NotationWe leave all suffix minimums by the digits mni (digits less than or equal to the minimum among the digits to the right of them), remove the rest and replace them with min(d+1,9) (using the described operations) and add to lexicographically minimum order on the right (due to the appropriate order of operations, this is possible). The suffix minimums mni should be left, because no matter what digit we leave after mni, it will be no less than mni, and therefore will not improve the answer. The rest must be removed at the end with operations, since there is a number to the right less than this one, i.e. if you remove everything before it (put mni at the current position), the answer will become less than if you leave another digit at this position. 

Jury solution: 173498569 

1730D - Prefixes and SuffixesIf you reflect the second string and see what happens, it is easy to see that the elements at the same positions in both strings after any action remain at the same positions relative to each other. Let's combine them into unsorted pairs and treat these pairs as single objects. Now we need to compose a palindrome from these objects. This is always possible with the help of these actions, if there is a palindrome consisting of these objects (pay attention to odd palindromes, there must be a pair of the form (a, a) in the center). 

Proof of possibility: 

Let's make an array of pairs, in one action we expand some prefix of this array and the elements in the pairs of this prefix are swapped. Let's prove that we can change the order of the pairs in the array as we like. We will build from the end. Let all the pairs after position i already stand as we want, and now the pair that we want to place in position i at position j≤i. Let's do the following: 

1. k=j — will move the pair from position j to the beginning. 

2∗. k=1 — swap elements within a pair if needed (so pairs are considered unsorted). 

3. k=i — move the pair from the beginning to position i. 

(* the 2 action is optional if you don't want to change the order of the elements in the pair) 

With this construction, we can get any permutation of these pairs and a palindrome, if it is possible. If you divide the final palindrome into two strings and expand the second one back, you get the first string. 

Example: 

From the test suite from the condition: 

s1=bbcaa, s2=cbaab, expanded s2=baabc. 

Couples: 

(b,b), (b,a), (c,a), (a,b), mathtt(a,c). 

Pairs unordered: 

(b,b), (a,b)⋅2, (a,c)⋅2. 

Pairs in a palindrome: 

(a,b), (a,c), (b,b), (a,c), (a,b). 

Real couples: 

(a,b), (a,c), (b,b), (c,a), (b,a). 

Strings: s1=aabcb expanded s2=bcbaa, s2=aabcb. 

!!! The pair (b,b) !!! 

Jury solution: 173498668 

1730E - Maximums and MinimumsLet's introduce some new variables: lgei - the position of the nearest left greater or equal than ai(−1 if there is none). rgi - position of the nearest right greater than ai(n if there is none). lli - position of the nearest left lower than ai(−1 if there is none). rli - position of the nearest right lower than ai(n if there is none). All this can be calculated, for example, using a stack in O(n) or using binary search and sparse table in O(nlogn)Let's iterate over the position i of the leftmost maximum of the good segment. Then the i-th element will be the maximum on the segment [l, r] if lgei<l≤i and i≤r<rgi (1). For the segment to pass the test, the minimum must be a divisor of the maximum. Let's iterate over this divisor d and find the number of segments where the maximum is ai and the minimum is d. Consider positions of occurrence of d j1 and j2 — the nearest left and right to i(they can be found using two pointers). Let's find the number of segments satisfying the condition (1), in which the element j1 is a minimum. To do this, similar conditions must be added to (1): lli<l≤j1 and j1≤r<rgi. Intersecting these conditions, we obtain independent segments of admissible values of the left and right boundaries of the desired segment. Multiplying their lengths, we get the number of required segments. Similarly, the number of segments satisfying (1), in which j2 is the minimum, is found, but in order not to count 2 times one segment, one more condition must be added: j1<l. The sum of these quantities over all i and divisors of ai will give the answer to the problem. 

To enumerate divisors, it is better to precompute the divisors of all numbers in O(AlogA), where A is the constraint on ai. So the whole solution runs in O(AlogA+nD), where D is the maximum number of divisors. 

Jury solution: 1734980091730F - Almost SortedLet's build a permutation q from left to right. If the current prefix contains the number i, let's call the element pi used, otherwise — unused. Consider the smallest unused element mn=pj. All elements greater than mn+k must also be unused, and all elements less than mn must be used. Then the current state can be described by the number mn and the mask, i-th bit of which indicates whether the element with the value mn+i is used. 

Let's solve the problem by dynamic programming: dp[mn][mask] is the minimum number of inversions. We can continue building a permutation by adding the number i such that mn≤pi≤mn+k and pi hasn't been used yet. New inversions can be divided into two types: those formed with indices of elements less than mn (they can be counted using Fenwick tree) and those formed with indices of elements not less than mn (but their number is not more than k). 

The time complexity is O(n⋅2k⋅k⋅(k+logn)). 

Jury solution: 173498327 

Codeforces Round #822 (Div.2) Editorial 

By arvindf232, 5 months ago, In EnglishThank you for your participation! 

1734A — Select Three SticksWe first sort the array a in non-decreasing order. 

Denote the indices of the elements that we choose from a to be x, y, and z, where 1≤x<y<z≤n, and the final value (after performing the operations) of the concerned elements to be v. 

The minimum required number of operations is then |ax−v|+|ay−v|+|az−v|. It is well-known that such expression attains its minimum value when v is the median of ax, ay, and az. Since the array a has already been sorted, it is best to assign v to be ay. 

Our expression then becomes |ax−ay|+|ay−ay|+|az−ay|=(ay−ax)+0+(az−ay)=az−ax. We would like to minimize the value of az, which implies z should be as small as possible since a is sorted. It is clear that taking z=y+1 would minimize the value of the expression. Similarly, we can show that we can take x=y−1 to minimize the value of the expression. 

Therefore, the only possible values of the triplets (x,y,z) are of the form (t,t+1,t+2) for positive integers 1≤t≤n−2, and we can iterate through all such triplets and find the best one. 

The time complexity is Θ(nlogn) per case due to sorting. 

Code in C++1734B — Bright, Nice, BrilliantNote that the brightnesses of the rooms on the i-th floor is at most i. This is because in room (i,1), only i rooms, namely, (1,1), (2,1), …, (i,1) can reach to (i,1) through some number of staircases. 

It is also possible to find a configuration of torches in the pyramid such that the brightnesses of the rooms on the i-th floor is exactly i, i.e. it attains the upper bound. 

The configuration is as follows: Room (i,j) contains a torch if and only if it is the leftmost room (i=1) or the rightmost room (i=j) on the i-th floor. 

This is valid because for all rooms (i,j), it can be reached from (1,1), (2,1), (3,1), …, (i−j+1,1) and (2,2), (3,3), …, (j,j). In other words, room (i,j) has brightness (i−j+1)+j−1=i, so the pyramid is nice. 

Code in C++1734C — Removing Smallest MultiplesOne operation should be used to remove every element not belonging to T. 

Let v be an element not belonging to T. Suppose a x-cost operation removes value v, then v must be divisible by x. Furthermore, the multiples x,2x,⋯(k−1)x must have been already removed from S, where we write v=kx. 

Since removed elements stay removed, the above is only possible if all of x,2x,⋯(k−1)x does not belong to T. 

For each v, let f(v) be the smallest integer x satisfying the above condition. As we can always remove v using a v-cost operation, f(v)≤v and in particular f(v) exists. 

The total cost must be at least ∑i∉Tf(i). We claim that this cost can be achieved. 

To do so, we should remove the required elements in ascending order. When removing v, we assume all w∉T with w<v have already been removed. At this state, an f(v)-cost operation would be able to remove v. 

It remains to find the values f(v). To do so efficiently, we can perform the above process in a bottom-up manner similar to the Sieve of Eratosthenes. Please refer to the code below for implementation details. The overall complexity is n(1+12 +13 +⋯+1n )=Θ(nlogn). 

Code in C++1734D — Slime EscapeLet's call a group of slime good if their total health is at least 0, or if defeating this group allows you to reach the exits. 

We partition the slimes into good groups in a two-pointer like manner. To form the groups to the right, start from position k, then find the smallest position r such that slimes from k+1 through r form a good group. We do the same starting from r+1 again. Repeat this process until slimes to the right are partitioned into groups, which can be done by maintaining the sum of health. We partition the left slimes into groups in a similar way. 

We can observe that in an optimal strategy, we may assume the player absorbs group-by-group. 

ProofFor any good group, since the total health is positive, there is no drawback to absorbing a good group. In other words, whenever it is possible to absorb a good group, we will absorb it. 

For each group G, we calculate the ``requirement'' of the group — the lowest health we can begin with, such that we can absorb the group while maintaining non-negative health at all times. The requirement of a group of slime with health a1,a2⋯an can be expressed as 

−minnk=0(∑ki=1ai)Finally, we can simply simulate the process. We repeatedly attempt to absorb good groups to the left or to the right. We keep track of the current health, initially equal to ak. Whenever we consider whether to absorb a group or not, we absorb it if and only if the current health is at least as high as its requirement. Otherwise, we ignore it for now and attempt to do so for the group on the other side. If it is possible to reach a state where either all left groups or all right groups are absorbed, then we can win the game. If at some point, it is not possible to absorb the left group nor the right group, then we lose. 

The overall complexity is Θ(n). 

It is also possible to use a range max/min segment tree form the groups instead of using two-pointers, in which case its complexity would be Θ(nlogn). 

Code in C++1734E — Rectangular CongruencesWe say a matrix to be good if it satisfies the congruence condition (the second condition). 

When we have a good matrix, we can add any value c to a whole row while maintaining the congruence relation. The same is true for adding the same value to a whole column. 

Suppose we have any good matrix A, then by adding bi−ai,i to the i-th row for each of i=1,2,⋯,n, we obtain a good matrix that has the desired values on the diagonal. 

In fact, there are a lot of possible constructions. We present a few of them here: 

ai,j=i×j(modn)ai,j=(i+j)2(modn). This needs special handling when n=2. 

ai,j=(i+j)(i+j+1)2 (modn). 

The coolest part is that all quadratic polynomials in the form ai2+bij+cj2+di+ej+f are valid for all integers a,b,c,d,e,f and b≢0(modn)As a bonus, we prove that the general quadratic polynomial gives a good construction. 

ProofHere are some extra observations that may enable one to find a good matrix more quickly. 

Some extra observationsCode in C++1734F — Zeros and OnesObserve that the i-th character is `1' if and only if i has an odd number of set bits in its binary representation. Both solutions make use of this fact. 

The constraints allows solutions of up to Θ(qlog3n). Yet, both of the model solution runs in Θ(logn). 

1. Digit DP solutionThe question can be reformulated as follows: How many integers x between 0 and m−1 inclusive have the property that the total number of set bits of x and x+n is an odd number? 

This can be solved with digit DP. We process the bit position from ⌈log(max)⌉ down to 0. We maintain three states: 

ans, a boolean value; 

trailzeros, an integer between 0 and ⌈log(max)⌉ inclusive; and 

under, a boolean value. 

We can thus conclude the following: the number of trailing zeros is all we need to decide the answer. 

After processing each bit k, we should have the following: the number of integers x between 0 and ⌊m2k ⌋ inclusive which have the following property: 

the total number of set bits of x and x+⌊n2k ⌋ is equal to ansmod2; 

the number of trailing `1's of x+⌊n2k ⌋ is equal to trailzeros; 

the boolean value [x<⌊m2k ⌋] (where [] is the Iverson bracket). 

Now onto the transitions. Suppose we are adding the (k−1)-th digit, and let d be the new digit of x, and z be the (k−1)-th digit of n. 

If z+d=0, then (ans,trailzeros) after digit k will be transited to (ans,0) after digit k−1; 

if z+d=1, then (ans,trailzeros) after digit k will be transited to ((ans+z+d)mod2,trailzeros+1) after digit k−1; 

if z+d=2, then (ans,trailzeros) after digit k will be transited to ((ans+z+trail+1)mod2,0) after digit k−1The final answer is the total number of values for which ans=1 and under=1. 

The above solution runs in Θ(log2(max)) per query. There is a simple way to optimize this to Θ(log(max)): note that we only need to keep parity of trailzero. 

There are many other digit DP approaches that give similar time complexity. The constraints should allow most of them pass. 

Code in Kotlin2. Recursive Solution, by darkkcyanDefine the function f(x):= the parity of bit one in the number x. 

We have thus reworded the statement into evaluating the follow expression: 

T=∑k−1i=0[f(i)≠f(i+n)]The formula can be further transformed as: 

T=∑k−1i=0f(i⊕(i+n))since [f(a)≠f(b)]=f(a⊕b) holds true for all non-negative integers a and b. 

Imagine we construct a grid and assign the value at row r and column c to be f(r⊕c). Then, T is sum of a diagonal of length k which starts at either (0,n) or (n,0). Without loss of generality, we use (0,n) in this editorial. 

The grid can be constructed similarly to the way we construct the string S. We start with a 1-by-1 matrix M0=[ 0 ]. 

Then, the matrix Mi of size 2i×2i can be constructed as follows: 

Mi=[ Mi−1	 ¯Mi−1 ¯Mi−1 	Mi−1 ]where ¯Mi−1 is the matrix Mi−1 but with flipped bits. 

Here is another way of constructing the grid: let Ci be an infinite chess board with alternating colors, similar to a regular chess board, but with each of the cells being size 2i×2i. For example, C0, C1 and C2 in an 8-by-8 grid is as follows: 

IllustrationWe claim that our grid is the xor of all chess board Ci. The proof is easy: Ci is constructed by xor-ing the i-th bit of the the row and column number. 

We are therefore motivated to proceed in the following way: if we drop the least significant bit (by making it to be 0), we are still solving a very similar problem to the original problem, because dropping the first bit is similar to removing C0. And when we shift Ci to Ci−1, it is a recursion of the same problem! 

Going back to the problem, where we are computing sum of a diagonal of length k. If k is odd, we can make it odd by adding the last element to the result and decreasing k by one. Now, k is even, and we can utilize the recurrence as follows: 

remove C0. 

scale the board down by 2 (including n and k). By doing so, Ci becomes Ci−1. 

solve the new problem. 

scale the board up again and add C0 back. 

from the result of the scaled down problem, some how calculate the result of the original problem 

The result of the scaled down problem is the number of 2-by-2 cells with value 1. From the number of 2-by-2 cells with value 1, we compute the number of cells with value 0 as well. It is not hard to observe that it crosses the 2-by-2 cells at all places. The only thing that matters is the parity of n. 

If n is even, then the diagonal crosses the diagonal of the 2-by-2 cells. In the scaled-down version, the diagonal is still a single diagonal starting at (0,n2 ); otherwise, 

if n is odd, it crosses the corner of the 2-by-2 cells. In the scaled-down version, the diagonal is actually 2 neighboring diagonals starting at (0,n−12 ) and (0,n+12 ). 

Also, the 2-by-2 cells with values 0 and 1 respectively will also have the form: 

IllustrationFrom here we have everything we need to compute the result of the original problem. 

Overall, the number of states we have to visit is Θ(logk). 

Code in Python 

Codeforces Round #821 (Div. 2) Editorial 

By tlsdydaud1, 2 years ago, In EnglishProblem A is developed by mejiamejia. 

1733A - Consecutive SumHintsSolutionFor each index i (k+1≤i≤n), there is exactly one element among a1 to ak, which can swap with ai. If ai is greater than that element, swap them. This process perform the operation at most n−k times. After performing operations, select a1 to ak. This is the maximum score we can get. 

Solution CodeChallenge1733B - Rule of LeagueHintsSolutionAccording to hints, min(x,y)=0 and max(x,y)>0 and (n−1)modmax(x,y)=0 holds in order to generate a valid result. If so, player 1 and player 2 would play first. Let's consider player 2 wins. Then player 2 should win max(x,y) games, and loses to player max(x,y)+2. Likewise, player max(x,y)+2 wins max(x,y) games and loses to player 2⋅max(x,y)+2. Construct the remaining result in the same way. 

Solution CodeChallenge1733C - Parity Shuffle SortingHintsSolutionIf n=1, do nothing. 

Otherwise, select indices 1 and n to make a1 equal to an first. After that, for each element ai (2≤i<n), select indices 1 and i if a1+ai is odd, and select indices i and n otherwise. This process requires n−1 operations and make all elements equal, which is also non-decreasing. 

Solution CodeChallenge1733D1 - Zero-One (Easy Version)HintsSolutionConsider another binary string c, in which ci=ai⊕bi (1≤i≤n). So doing an operation means selecting two indices of c and flipping them. Also, let's define d is the number of 1 in c. Because the parity of d never changes, the answer is −1 if d is odd. 

If d is even, classify the cases: 

[1] If d=2 and two 1-s are adjacent, the answer is min(x,2y). Because n≥5 holds, we can always replace one x-cost operation with two y-cost operations. 

[2] If d=2 and two 1-s are not adjacent, the answer is y. 

[3] If d≠2, select i-th 1 and (i+d2)-th 1 each (1≤i≤d2). This costs d2×y, and we showed the cost cannot be reduced more in hint 3. 

Solution Code1733D2 - Zero-One (Hard Version)HintsSolution(Continued from D1 editorial) 

If x<y, greedy approach used in D1 doesn't work. Let's use DP. Define z0[i][j] as the minimal cost when there is j 1s in first i elements of c and ci=0, and z1[i][j] as the minimal cost when there is j 1s in first i elements of c and ci=1. Initially all table values are ∞. 

First, check c1. If c1=0, set z0[1][0] to 0. Otherwise, set z1[1][1] to 0. 

Then, check the following elements from c2 to cn in turn. 

[4] If ci=0, 

z0[i][j]=min(z0[i−1][j],z1[i−1][j]),z1[i][j]=⎧⎩⎨min(z0[i−1][j]+y,z1[i−1][j]+x),min(z0[i−1][j]+y,z1[i−1][j]+x,z0[i−1][j−2]+x,z1[i−1][j−2]+y),if j≤1,if j>1,[5] If ci=1, 

z0[i][j]=⎧⎩⎨min(z0[i−1][j+1]+y,z1[i−1][j+1]+x),min(z0[i−1][j+1]+y,z1[i−1][j+1]+x,z0[i−1][j−1]+x,z1[i−1][j−1]+y),min(z0[i][j],z0[i−1][j−1]+x,z1[i−1][j−1]+y),if j=0,if 0<j<i,if j=i,z1[i][j]={∞,min(z0[i−1][j−1],z1[i−1][j−1]),if j=0,if j>0,for 0≤j≤i. The answer is z[n][0]. 

Solution CodeChallenge1733E - ConveyorHintsSolutionIn the conveyor, cells with same (i+j) value consists a diagonal (i is row number, j is column number). Let's call them (i+j)-th diagonal. So there are 239 diagonals, from 0-th to 238-th. 

So, we can find every slime ball move to the next diagonal for every second. It means no two slime ball merge forever. 

Given t, x, y, cell (x,y) belongs to (x+y)-th diagonal. If t<x+y, the answer is NO because there is no slime ball in (x+y)-th diagonal yet. If t≥x+y, (x+y)-th diagonal contains one slime ball, and the ball is placed on cell (0,0) after (t−x−y) seconds from the start. So (t−x−y) slime balls passed this diagonal before. 

Now, find out which cell contains slime ball among the diagonal. To do this, we use following method: simulate with (t−x−y) slime balls to check how many slime reach each cell of the diagonal, and repeat this with (t−x−y+1) slime balls. Exactly one cell will show different result, and this cell is where (t−x−y+1)-th slime ball passes through. If this cell is equal to (x,y), the answer is YES. Otherwise the answer is NO. 

Simulation with x slime balls processes as follows: 

Place x slime balls on cell (0,0).Move slime balls to next diagonal. For each cell, if the cell contains k slime balls, ⌈k2⌉ moves to right and ⌊k2⌋ moves to down.Repeat the second step. If slime balls reached aimed diagonal, stop and find the result.Solution CodeChallenge 

Codeforces Round #820 (Div. 3) Editorial 

By Vladosiya, history, 5 months ago, translation, In English1729A - Two Elevators 

Idea: Vladosiya 

Tutorial1729A - Two ElevatorsYou had to to calculate the time that each elevator would need and compare them. Let the time required by the first elevator be d1=|a−1|, and the time required by the second one be d2=|b−c|+|c−1|. Then the answer is 1 if d1<d2, 2 if d1>d2 and 3 if d1=d2Solution1729B - Decode String 

Idea: MikeMirzayanov 

Tutorial1729B - Decode StringThe idea is as follows: we will go from the end of the string t and get the original string s. 

Note that if the current digit is 0, then a letter with a two-digit number has been encoded. Then we take a substring of length three from the end, discard 0 and get the number of the original letter. 

Otherwise, the current number ≠0, then a letter with a one-digit number was encoded. We easily reconstruct the original letter. 

Next, discard the already processed characters and repeat the process until the encoded string is complete. 

Solution1729C - Jumping on Tiles 

Idea: MikeMirzayanov, Aris 

Tutorial1729C - Jumping on TilesIt's worth knowing that ways like ('a' -> 'e') and ('a' -> 'c' -> 'e') have the same cost. That is, first you need to understand the letter on the first tile and the last one (conditionally, the letters first and last). 

Then you just need to find all such tiles on which the letters are between the letters first and last inclusive. 

We go through each letter from first to last and for each letter we visit every tile that has a given letter (but we must not forget to start exactly at tile 1 and end at tile n). 

Solution1729D - Friends and the Restaurant 

Idea: MikeMirzayanov, Aris, myav 

Tutorial1729D - Friends and the RestaurantFirst, we sort the friends in descending order of yi−xi. Now for each friend we know the amount of money he lacks, or vice versa, which he has in excess. 

In order to maximize the number of days, it is most advantageous for friends to break into pairs. It is the number of groups that matters, not the number of people in the group, so adding a third person to the pair won't improve the answer in any way. 

Let's solve the problem using two pointers: for the richest friend, find the first friend from the end such that the sum of their values y exceeds the sum of their values x. Then repeat this for all subsequent friends until the pointers meet. 

If no pair could be formed, or none of the friends has a value x greater than y, then the answer is -1. 

Otherwise, print the number of pairs formed. 

Solution1729E - Guess the Cycle Size 

Idea: Gornak40, MikeMirzayanov 

Tutorial1729E - Guess the Cycle SizeThe implication was that the solution works correctly with some high probability. So we tried to give such constraints so that the solution probability is very high. 

The idea: we will output queries of the form (1,n) and (n,1), gradually increasing n from 2. If we get an answer to query −1 the first time, then the size of the graph is exactly n−1. 

Otherwise, let the answer to the first query be x and the answer to the second query be y. 

With probability 12,x≠y. In this case, we can output the answer: x+y, since there are a total of two different paths from vertex 1 to n and we recognized them. Accordingly the total length of paths will be the size of the cyclic graph. 

But with probability 12,x=y. In this case we must continue the algorithm. At most we can make 25 of such attempts. 

Let's calculate the probability of finding the correct graph size: p=1−(12)25. That is, we "lucky" on one test with probability p≈0.99999997. But we should have "lucky" on 50 tests. We get: P=p50≈0.99999851. 

Solution1729F - Kirei and the Linear Function 

Idea: Gornak40 

Tutorial1729F - Kirei and the Linear FunctionNote that the remainder of dividing a number by 9 is equal to the remainder of dividing its sum of digits by 9. This is easy to check, because the number a of n digits is representable as a polynomial a0+a1⋅10+a2⋅100+⋯+an−1⋅10n−1+an⋅10n, and 10k gives a remainder of 1 when divided by 9 for any k. 

Let's count an array of prefix sums of digits for the string s. 

Now, knowing w, we can pre-calculate for each remainder modulo 9 all possible L. 

Also, for each query, we can easily find the remainder of dividing v(l,r) by 9 using all the same prefix sums. 

Let's iterate over the remainder of the number a when dividing by 9. Knowing it, we can easily find the remainder of the number b when divided by 9, as k−a⋅v(l,r) modulo 9. 

Now, using each pair of remainers (a,b), let's try to update the answer: 

a=b, then the minimum index from the pre-calculated array will act as L1, and the next largest will act as L2 (if such exist);a≠b, then the minimum indexes from the pre-calculated array will act as L1 and L2.This solution works for 9⋅(n+m) or for O(n+m). 

Solution1729G - Cut Substrings 

Idea: DmitriyOwlet, MikeMirzayanov 

Tutorial1729G - Cut SubstringsFirst, find all occurrences of t in s as substrings. This can be done using the prefix function. 

To find the minimum number of times we need to cut substrings, consider all indexes of occurrences. Having considered the index of the occurrence, we cut out the rightmost occurrence that intersects with it. After that, we find the leftmost occurrence that does not intersect with the cut one. If it doesn't, we end the loop. 

The number of optimal sequences of moves will be calculated using dynamic programming. 

For each occurrence, we can count how many ways we can cut out all occurrences of t in the suffix s starting with this occurrence in the minimum number of moves. Considering the occurrence, we find the leftmost occurrence that does not intersect with it, and then iterate over the occurrences with which we can remove it. 

Solution 

Codeforces Round #820 (Div. 3) Editorial 

By Vladosiya, history, 5 months ago, translation, In English1729A - Two Elevators 

Idea: Vladosiya 

Tutorial1729A - Two ElevatorsYou had to to calculate the time that each elevator would need and compare them. Let the time required by the first elevator be d1=|a−1|, and the time required by the second one be d2=|b−c|+|c−1|. Then the answer is 1 if d1<d2, 2 if d1>d2 and 3 if d1=d2Solution1729B - Decode String 

Idea: MikeMirzayanov 

Tutorial1729B - Decode StringThe idea is as follows: we will go from the end of the string t and get the original string s. 

Note that if the current digit is 0, then a letter with a two-digit number has been encoded. Then we take a substring of length three from the end, discard 0 and get the number of the original letter. 

Otherwise, the current number ≠0, then a letter with a one-digit number was encoded. We easily reconstruct the original letter. 

Next, discard the already processed characters and repeat the process until the encoded string is complete. 

Solution1729C - Jumping on Tiles 

Idea: MikeMirzayanov, Aris 

Tutorial1729C - Jumping on TilesIt's worth knowing that ways like ('a' -> 'e') and ('a' -> 'c' -> 'e') have the same cost. That is, first you need to understand the letter on the first tile and the last one (conditionally, the letters first and last). 

Then you just need to find all such tiles on which the letters are between the letters first and last inclusive. 

We go through each letter from first to last and for each letter we visit every tile that has a given letter (but we must not forget to start exactly at tile 1 and end at tile n). 

Solution1729D - Friends and the Restaurant 

Idea: MikeMirzayanov, Aris, myav 

Tutorial1729D - Friends and the RestaurantFirst, we sort the friends in descending order of yi−xi. Now for each friend we know the amount of money he lacks, or vice versa, which he has in excess. 

In order to maximize the number of days, it is most advantageous for friends to break into pairs. It is the number of groups that matters, not the number of people in the group, so adding a third person to the pair won't improve the answer in any way. 

Let's solve the problem using two pointers: for the richest friend, find the first friend from the end such that the sum of their values y exceeds the sum of their values x. Then repeat this for all subsequent friends until the pointers meet. 

If no pair could be formed, or none of the friends has a value x greater than y, then the answer is -1. 

Otherwise, print the number of pairs formed. 

Solution1729E - Guess the Cycle Size 

Idea: Gornak40, MikeMirzayanov 

Tutorial1729E - Guess the Cycle SizeThe implication was that the solution works correctly with some high probability. So we tried to give such constraints so that the solution probability is very high. 

The idea: we will output queries of the form (1,n) and (n,1), gradually increasing n from 2. If we get an answer to query −1 the first time, then the size of the graph is exactly n−1. 

Otherwise, let the answer to the first query be x and the answer to the second query be y. 

With probability 12,x≠y. In this case, we can output the answer: x+y, since there are a total of two different paths from vertex 1 to n and we recognized them. Accordingly the total length of paths will be the size of the cyclic graph. 

But with probability 12,x=y. In this case we must continue the algorithm. At most we can make 25 of such attempts. 

Let's calculate the probability of finding the correct graph size: p=1−(12)25. That is, we "lucky" on one test with probability p≈0.99999997. But we should have "lucky" on 50 tests. We get: P=p50≈0.99999851. 

Solution1729F - Kirei and the Linear Function 

Idea: Gornak40 

Tutorial1729F - Kirei and the Linear FunctionNote that the remainder of dividing a number by 9 is equal to the remainder of dividing its sum of digits by 9. This is easy to check, because the number a of n digits is representable as a polynomial a0+a1⋅10+a2⋅100+⋯+an−1⋅10n−1+an⋅10n, and 10k gives a remainder of 1 when divided by 9 for any k. 

Let's count an array of prefix sums of digits for the string s. 

Now, knowing w, we can pre-calculate for each remainder modulo 9 all possible L. 

Also, for each query, we can easily find the remainder of dividing v(l,r) by 9 using all the same prefix sums. 

Let's iterate over the remainder of the number a when dividing by 9. Knowing it, we can easily find the remainder of the number b when divided by 9, as k−a⋅v(l,r) modulo 9. 

Now, using each pair of remainers (a,b), let's try to update the answer: 

a=b, then the minimum index from the pre-calculated array will act as L1, and the next largest will act as L2 (if such exist);a≠b, then the minimum indexes from the pre-calculated array will act as L1 and L2.This solution works for 9⋅(n+m) or for O(n+m). 

Solution1729G - Cut Substrings 

Idea: DmitriyOwlet, MikeMirzayanov 

Tutorial1729G - Cut SubstringsFirst, find all occurrences of t in s as substrings. This can be done using the prefix function. 

To find the minimum number of times we need to cut substrings, consider all indexes of occurrences. Having considered the index of the occurrence, we cut out the rightmost occurrence that intersects with it. After that, we find the leftmost occurrence that does not intersect with the cut one. If it doesn't, we end the loop. 

The number of optimal sequences of moves will be calculated using dynamic programming. 

For each occurrence, we can count how many ways we can cut out all occurrences of t in the suffix s starting with this occurrence in the minimum number of moves. Considering the occurrence, we find the leftmost occurrence that does not intersect with it, and then iterate over the occurrences with which we can remove it. 

Solution 

Codeforces Round #818 (Div. 2) Editorial. 

By FairyWinx, history, 6 months ago, translation, In EnglishProblem A. Idea by Igorbunov 

Hint 1SolutionNotice that only the following pairs of numbers are possible: (x,x), (x,2⋅x), and (x,3⋅x). 

Proof:The number of the pairs of the first kind is n, of the second kind is 2⋅⌊n2⌋, and of the third kind is 2⋅⌊n3⌋ (the factor 2 in the latter two formulae arises from the fact that pairs are ordered). Therefore, the answer to the problem is n+2⋅(⌊n2⌋+⌊n3⌋). 

Problem B. Idea by FairyWinx 

Hint 1Hint 2Hint 3Hint 4SolutionNotice that the answer to the problem is at least n2k, because you can split the square into so many non-intersecting rectangles of dimensions 1×k. So let's try to paint exactly so many cells and see if maybe it's always possible. 

For simplicity, let's first solve the problem without necessarily painting (r,c). In this case, we're looking for something like a chess coloring, which is a diagonal coloring. 

Let's number the diagonals from the "lowest" to the "highest". Notice that every 1×k and k×1 subrectangle intersects exactly k consecutive diagonals, so we can paint every k-th diagonal to obtain the required answer: every such subrectangle will contain exactly one painted cell. 

To add the (r,c) requirement back, notice that (r,c) lies on the diagonal number r+c. (Because if you trace any path from (0,0) to (r,c) with non-decreasing coordinates, going one cell upwards or rightwards increases exactly one of the coordinates by one, and also increases the number of the diagonal by one). Therefore, all we need to do is paint the cells whose coordinates satisfy (x+y)%k=(r+c)%kProblem C. Idea by FairyWinx 

Hint 1Hint 2Hint 3SolutionFirstly, we obviously require ai≤bi to hold for all i. With that out of our way, let's consider non-trivial cases. Also let an+1=a1,bn+1=b1 cyclically. 

For each i, we require that either ai=bi or bi≤bi+1+1 holds. That's because if we increment ai at least once, we had ai=bi−1 and ai+1≤bi+1 before the last increment of ai, and from here it's just a matter of simple algebraic transformations. 

Now let's prove these two conditions are enough. Let i be the index of the minimal element of a such that ai<bi (i.e. the smallest element that's not ready yet). Notice that in this case we can, in fact, assign ai:=ai+1, because ai≤bi≤bi+1+1 holds, and now we're one step closer to the required array. It's easy to continue this proof by induction. 

Problem D. Idea by FairyWinx 

Hint 1Hint 2SolutionThe problem can be reformulated as follows. We've got a complete binary tree with 2n leaves. There's a marked edge from each intermediate node to one of its children. The winner is the leaf reachable from the root via marked edges. Changes modify the outgoing marked edge of a node. 

Now it should be fairly obvious that there's no reason to change more than one node per level, because only one node matters per level--the one on the path from the root to the answer node. So, the winner only depends on the subset of levels we perform changes on, and vice versa: different subsets always yield different winners. 

Sponsors can change exactly i nodes in (ni) ways. Summing this over i, we get ∑min(n,k)i=0(ni). Call this number m. m is the number of winners the sponsors choose between--let's call them candidates for brevity. It's easy to see that m is the answer to the problem, because a) sponsors can guarantee the winner is at least m, as, independent of the list of candidate winners "provided" by Madoka, at least one of them must be at least m, and b) Madoka can guarantee the winner is at most m by firstly marking edges arbitrarily, then computing the list of candidate nodes, and only then fill them with numbers from 1 to m (and the other nodes arbitrarily). 

Problem E. Idea by FairyWinx 

Hint 1Hint 2Hint 3SolutionLet's bruteforce c, then we have gcd(a,b)=gcd(a,a+b)=gcd(a,n−c). This means that gcd(a,b) divides n−c, so let's just go through all divisors of n−c. For every factor d, the count of pairs (a,b) satisfying a+b=n−c and gcd(a,b)=d is ϕ(n−cd), because we need d to divide a and be coprime with n−cd, so that the gcd is equal to d. 

Therefore, the answer to the problem is ∑lcm(c,d)∗ϕn−cd, where 1≤c≤n−2 and d is a factor of n−c. 

Problem F. Idea by TeaTime, tutorial by imachug 

Editorialist's note: I didn't submit the solution myself, but I proved it theoretically, aggregated solutions of problemsetters as well as participants, so I'm fairly sure it's correct, but you might want to treat it with more suspicion. 

Hint 1Hint 2Hint 3SolutionLet's reformulate the problem in terms of graphs. We are given an undirected graph and we are asked to determine edge directions, subject to fixed indegree minus outdegree (hereinafter balance) values for some vertices. 

It is tempting to think of this as a flow problem: edges indicate pipes with capacity of 1, vertices are producers or consumers of flow, and vertices with fixed differencies produce or consume an exact amount of flow. Except that's not quite an equivalent problem: a maxflow algorithm will find a flow, i.e. an orientation of edges, but it might just ignore some edges if it feels like it. 

We need to overcome this somehow by introducing incentive to use all edges. To do this, forget about the "edges are edges, vertices are vertices" idea for a while. Create an imaginary source and add a pipe with capacity 1 to every edge of the original graph. Technically, this is interpreting edges of the original graph as vertices of the flow graph. Non-technically, I like to interpret this like magically spawning flow into the middle of the edge. 

Now, the flow appearing in the edge has to actually go somewhere if we want the maxflow algorithm to treat it like a treasure it wants to increase. Let's just add two pipes: from the edge to vertex ui and from the edge to vertex vi, because where else would it go? (technically, any capacity works, but let's use 1 for simplicity) This has a nice side effect of determining the orientation of the edge: if the flow from the edge goes into ui, it's as if it was oriented from vi to ui, and vice versa. 

A small problem is that this changes the semantics of the edge orientation somewhat. In the original problem, ui→vi incremented vi and decremented ui. In the new formulation, only vi is incremented, so we need to transform the requirements av on balances into requirements bv on indegrees: bv=av+degv2 (and we need to check that the numerator is even and non-negative, otherwise the answer is NO). 

How do we enforce the indegree requirements? For all vertices with sv=1, add a pipe from the vertex v to an imaginary sink with capacity bv. We expect all these pipes to be satiated. 

What about vertices with sv=0? Unfortunately, we can't just add a pipe from the vertex v to an imaginary sink with capacity ∞, because if you have an edge with sv=0 and su=1, the maxflow algorithm doesn't have any incentive to let the flow go to u instead of v, so the pipe from u to the sink might not get satiated and we might erroneously report a negative answer. 

How do we require certain pipes to be satiated? We could theoretically use a push-relabel algorithm, but in this case we can use something much simpler. The sum of capacities of all pipes from the imaginary source is m. We expect them all to be satiated, so this is the total flow we're expecting. The sum of capacities of all pipes to the imaginary sink we want to satiate is ∑vbv. Therefore, there's a surplus of flow of exactly Δ=m−∑vbv (if it's negative, the answer is NO). So: create an intermediate vertex, add a pipe of capacity ∞ from each vertex with sv=0 to this intermediate vertex, and a pipe from this intermediate vertex to the imaginary sink with capacity Δ. This will stop the algorithm from relying too much on non-fixed vertices. 

Run a maxflow algorithm. Check that every pipe from the source to an edge and every pipe from a vertex to the sink is satiated, or, alternatively, the maxflow is exactly m. If this does not hold, the answer is NO. If this holds, the answer is YES and the edge orientation can be restored by checking which of the two pipes from an edge is satiated. 

Is this fast? That depends on the algorithm heavily. 

Firstly, you can use the Edmonds-Karp algorithm. It works in O(FM), where F is the maxflow and M is the number of pipes. The former is m and the latter is n+m, so we've got O((n+m)m), which is just fine. 

Secondly, you can use Dinic's algorithm, which is typically considered an improved version of Edmonds-Karp's, but is worse in some cases. It improves the number of rounds from F to O(N), where N is the number of vertices in the network, which doesn't help in this particular problem, sacrificing the complexity of a single phase, increasing it to O(NM), which is a disaster waiting to happen. 

Lots of people submitted Dinic's instead of Edmonds-Karp's. I don't know why, perhaps they just trained themselves to use Dinic's everywhere and didn't notice the unfunny joke here. 

Luckily for them, Dinic's algorithm still works. You might've heard it works in O(MN2/3) for unit-capacity networks, where M is the number of pipes and N is the number of vertices, which translates to O((n+m)n2/3) in our case, which would be good enough if the analysis held. 

Our network is not unitary, but it's easy to see how to make it into one. We use non-unit capacities in three cases: 

When we enforce the indegree, we add a pipe with capacity bv from the vertex to the sink. We can replace it with bv pipes of capacity 1. As ∑vbv≤m, this will not increase the number of pipes by more than m, so the complexity holds. Due to how Dinic's algorithm works, replacing a pipe with several pipes of the same total capacity does not slow the algorithm down. 

Similarly, the pipe from the intermediate vertex to the sink has capacity Δ≤m, so we could theoretically replace it with Δ unit pipes and the complexity would hold. 

Finally, when we handle vertices with sv=0, we add pipes from such vertices to the intermediate vertex with capacity ∞. However, for each such vertex, the maximum used capacity is actually the count k of edges incident with v, so the capacity of such pipes could be replaced with k. This would obviously have the same effect, and would not slow Dinic down: even if it tries to push more than k through the corresponding backedge, it will quickly rollback, which affects the time taken by a single phase (non-asymptotically), but not the count of phases. As the sum of k is O(m), we're fine again. 

Codeforces Round #817 (Div. 4) Editorial 

By flamestorm, 6 months ago, In EnglishThanks for participating! 

1722A - Spell Check 

Idea: mesanu, MikeMirzayanov 

Tutorial1722A - Spell CheckCheck if the string has length 5 and if it has the characters T,i,m,u,r. The complexity is O(n). 

You can also sort the string, and check if it is Timur when sorted (which is Timru). 

Solution1722B - Colourblindness 

Idea: flamestorm 

Tutorial1722B - ColourblindnessHere are two solutions. 

Solution 1. Iterate through the string character by character. If si=R, then ti=R; otherwise, if si=G or B, then ti=G or B. If the statement is false for any i, the answer is NO. Otherwise it is YES. 

Solution 2. Replace all B with G, since they are the same anyway. Then just check if the two strings are equal. 

In either case the complexity is O(n) per testcase. 

Solution1722C - Word Game 

Idea: flamestorm 

Tutorial1722C - Word GameYou need to implement what is written in the statement. To quickly check if a word is written by another guy, you should store some map<string, int> or Python dictionary, and increment every time you see a new string in the input. Then, you should iterate through each guy, find the number of times their word appears, and update their score. 

The complexity is O(nlogn) per testcase. 

Solution1722D - Line 

Idea: flamestorm 

Tutorial1722D - LineFor each person, let's calculate how much the value will change if they turn around. For example, in the line LRRLL, if the i-th person turns around, then the value of the line will change by +4, −2, 0, −2, −4, respectively. (For instance, if the second person turns around, they see 3 people before and 1 person after, so the value of the line changes by −2 if they turn around.) 

Now note that if a person turns around, it doesn't affect anyone else's value. So the solution is a greedy one: let's sort the array of values in increasing order. Afterwards, we should go from the left to the right, and see if the value will increase if this person turns around; if it does, we should add it to the current total and continue. 

The time complexity of this solution is O(nlogn) per testcase. 

Solution1722E - Counting Rectangles 

Idea: mesanu 

Tutorial1722E - Counting RectanglesConsider the 2D array with a[x][y]=0 for all x,y. Increase a[h][w] by h×w if there is an h×w rectangle in the input. 

Now for each query, we need to find the sum of all a[x][y] in a rectangle with lower-left corner at a[hs+1][ws+1] and upper-right corner at a[hb−1][wb−1]. This is the standard problem that can be solved with 2D prefix sums. 

The time complexity is O(n+q+max(hb)max(wb)) per testcase. 

You can read about 2D prefix sums if you haven't heard of them before. 

Solution1722F - L-shapes 

Idea: MikeMirzayanov 

Tutorial1722F - L-shapesThe problem is mainly a tricky implementation problem. Let's denote the elbow of an L-shape as the square in the middle (the one that is side-adjacent to two other squares). Every elbow is part of exactly one L-shape, and every L-shape has exactly one elbow. 

Iterate through the grid and count the number of side-adjacent neighbors they have. If there is a cell with more than 2, or if there is a cell with exactly two neighbors on opposite sides, then the answer is NO. Otherwise, if there are exactly 2 neighbors, this cell is an elbow. Mark all three cells of this L-shape with a unique number (say, mark the first one you find with 1, the second with 2, and so on.) If you ever remark a cell that already has a number, then two elbows are adjacent, and you can output NO. 

After all elbows are marked, check if all shaded cells have a number. If some don't, then they are not part of an L-shape, so you can output NO. 

Finally, we should check that L-shapes don't share edge or corner. Just check, for each number, if it is only diagonally adjacent to other numbers equal to it or unshaded cells. If it is diagonally adjacent to other unequal numbers, then the answer is NO, because two L-shapes share an edge or corner then. 

Otherwise the answer is YES. 

There are many other solutions, all of which are various ways to check the conditions. The complexity is O(mn) per testcase. 

Solution1722G - Even-Odd XOR 

Idea: mesanu 

Tutorial1722G - Even-Odd XORThere are a lot of solutions to this problem. Here I will describe one of them. 

First, we observe that having the XOR of even indexed numbers and odd indexed numbers equal is equivalent to having the XOR of all the elements equal to 0. Let's note with a the XOR of all odd indexed numbers and b the xor of all even indexed numbers. Notice that the XOR of all the array equals 0 if and only if a = b. 

So how do we generate such an array with XOR of all elements 0? Our first instinct might be to arbitrarily generate the first n−1 numbers, then set the last element as the XOR of the first n−1, ensuring that the total XOR is 0. However, we might have problems with the condition that all elements must be distinct. Let's arbitrarily set the first n−2 so that they don't have the highest bit(230) set, and then the n−1-th number can be just 230. The last number can be the XOR of the first n−2 XOR the n−1-th number; you will be sure that the last number has not occurred in the first n−2 elements because they don't have the highest bit set while the last number must have the highest bit set. But how do we know that the n−1-th number and the n-th number will not be equal? This occurs only if the total XOR of the first n−2 numbers equals 0. To fix this, we can just choose a different arbitrary number in one of the n−2 spots. 

For example, my solution checks if the XOR of the numbers 0,1,2...,n−4,n−3 is 0. If it is not 0, great! We can use the simple solution without any changes. However, if the XOR is 0 I use the numbers 1,2,3,....,n−3,n−2 in their place. These two sequences have different XORs, so it ensures that one of them always works. 

Alternate Tutorial SketchSolution 

Codeforces Round #816 (Div. 2) editorial 

By ilyakrasnovv, 8 months ago, translation, In EnglishHello, Сodeforces! 

We are very grateful for Your participation in our round. 

Thanks to Qwerty1232 for the help with this editorial. 

1715A - Crossmarket 

Advice #0Hint #1Hint #2Hint #3Solution1715A - CrossmarketFor convenience let's define going upward as decreasing x coordinate, downward — increasing x, left — decreasing y, right — increasing y. 

One of the optimal solutions is the following: 

Megan goes upward to Stanley, she spends (n−1) units of energy for that. Then she goes right to her final destination by spending (m−1) more units of energy.Stanley now has a choice: he obviously has to teleport from his starting position either all the way down, or right. He chooses what will save him the most energy, so he teleports along the greater wall of the shop for the 1 unit of power.Then Stanley has to finish his route: he walks along the smaller side and spends min(n,m)−1 more energy.If at least one of the dimensions is not 1, then the answer is (n−1)+(m−1)+1+(min(n,m)−1)=min(n,m)+n+m−2. In case where (n,m)=(1,1) answer is 0. 

Normal proofProof, director's cut (or how you should not do)С++ code: 169161824Python code: 169161508Kotlin code: 1691616741715B - Beautiful Array 

Hint #1Hint #2Hint #3Solution1715B - Beautiful ArrayTo start with, the sum of the numbers in the array s cannot be less, than k⋅b (where k is the number by which we divide, and b is beauty (s≥k⋅b)) 

It is important, that s≤k⋅b+(k−1)⋅n. Let's assume that is not true. Consider the sum of divisible parts of numbers in the array: it obviously does not exceed k⋅b, thus the sum of remainders is at least (k−1)⋅n+1, which means, that at least one of the numbers' remainders is k, which is impossible by definition of the remainder. 

That way we got the criteria for the existence of the answer: k⋅b≤s≤k⋅b+(k−1)⋅n. 

If there does exist an answer, then we can use the following algorithm: 

Assign k⋅b to any of the n cells of the array.Iterate over all the cells (including the cell from the previous item) and add min(s−sum,k−1) to the current cell, where sum is the current sum of the elements.С++ code: 169162178Python code: 1691619681715C - Monoblock 

Hint #1Hint #2Hint #3Solution1715C - MonoblockLet us introduce another definition for the beauty — beauty of the array a is a number of such positions (indexes) i<n, that ai≠ai+1, plus 1. Let's call "joints" places where two adjacent different numbers exist in the array. 

Now consider the problem from the angle of these joints: if f(joint) is equal to the number of segments, that overlap this joint, then the sum of beauty over all subsegments is equal to the sum of f(joint) over all joints. To get a clearer understanding, consider the following example: [1,7,7,9,9,9]=[1]+[7,7]+[9,9,9] ("+" is basically a joint). There are 5 segments, which contain first joint ([1:2],[1:3],[1:4],[1:5],[1:6]), and there are 9 such for the second joint ([1:4],[1:5],[1,6],[2:4],[2:5],[2:6],[3:4],[3:5],[3:6]), 14 in total. After adding the number of subsegments, we get the answer: 6⋅72=21,21+14=35. 

From this the solution is derived, apart from change requests: iterate over the array, find "joints", comparing adjacent numbers, if ai is different from ai+1, that we must add i⋅(n−i) to the answer, that is how many possible beginnings of subsegments from the left multiplied by the number of possible ends from the right. 

How we should apply changes? In fact, it's worth just checking if there are any neighboring joints for the position of the changing number, subtracting the number of subsegments, that overlap these joints, and then doing similar operations after setting a new value for the number. 

For a better understanding and more details, we suggest you look over the authors' solutions. 

С++ сode: 1691623001715D - 2+ doors 

Hint #1Hint #2Hint #3Solution1715D - 2+ doorsThe first observation is that we can solve the task separately bit by bit, because of 

bitwise or operation is "bit-independent": bits of one particular power don't affect other bitsto gen a lexicographically minimal solution, we can combine solutions for each bit separatelyThis makes it possible for us to create a solution for a boolean array, and then run it 30 times for all numbers and statements, considering only i-th bit in each run. 

For ease of understanding let's speak in a language of graphs: we have an undirected graph with n vertices, on each vertex, there is either 0 or 1, and on each edge, there is a bitwise or of numbers, that are written on vertices connected by that edge. We have to recover the numbers on the vertices after they were somehow lost, knowing, that numbers on the vertices create a lexicographically minimal sequence possible. 

Initially, let's write 1 on each of the vertices. Then walk through them and consider incidental edges. If any of the edges contain 0, we must also write 0 on our current vertex and the neighbor by that edge. After zeroing all the required vertices, let's try to make our sequence lexicographically minimal. Walk through the vertices again and try to write 0 on each: to check if everything is ok, iterate over the incidental edges again. If any of them contains 1 and connects us with a vertex with 0, then we cannot make our vertex 0. 

Such solution works in O(log(max(ai))⋅(n+m)) time. 

For a better understanding and more details, we suggest you look over the authors' solutions. 

С++ сode: 1691623931715E - Long Way Home 

Hint 1Hint 2Hint 3Solution1715E - Long Way HomeLet's assume we know the shortest distances from the first vertex to each, if we have added no more than k edges (air travels). Let's learn to recalculate the answer for (k+1) edges. 

First, let's update the answer for all the paths ending in an air travel. Then we can run Dijkstra to take into account all the paths ending with a usual edge. 

In order to add an air travel, we need to update the distance to v, with all the paths ending with an air travel to v. To do so, we can use Convex Hull Trick, since the recalculation formula has the following form (dold — array of distances for k edges, dnew — array of distances if k+1 the flight goes exactly to the i-th vertex): 

dnew[v]=minu dold[u]+(u−v)2After that, we need to run Dijkstra to update the distances with all the paths not ending with an air travel. 

The resulting asymptotics is O(k(mlogn+n))С++ сode: 1691625081715F - Crop Squares 

Advice #0Hint #1Hint #2Hint #3Solution1715F - Crop SquaresIn fact, two queries are enough. The first query is to find out the area of intersection of the polygon with 2n+2 vertices at the points with coordinates (0,m+1),(0,0),(1,m),(1,0),…,(n−1,m),(n−1,0),(n,m),(n,m+1) with a filled square. Such a polygon is periodic over x axis with period 1, hence the x-coordinate of the lower left corner of the filled square does not affect the intersection area. Denote the intersection area — s, then the y-coordinate of the lower left corner of the square is calculated by the formula y=ms−12. 

An example of such a polygon for the field 5×4 and a filled square with the lower left corner at the point (3.5,2.5): 

With the second query, we find out the area of intersection of a similar polygon with 2m+2 vertices at points with coordinates (n+1,m),(0,m),(n,m−1),(0,m−1),…,(n,1),(0,1),(n,0),(n+1,0) with a filled square. Such a polygon is periodic over y axis with period 1, hence the y-coordinate of the lower left corner of the filled square does not affect the intersection area. Denote the intersection area — s, then the x-coordinate of the lower left corner of the square is calculated by the formula x=ns−12. 

An example of such a polygon for the field 5×4 and a filled square with the lower left corner at the point (3.5,2.5): 

С++ сode: 169162576 

Codeforces Round #815 (Div. 2) Editorial 

By TeaTime, 6 months ago, In EnglishA — Burenka Plays with FractionsAuthors: glebustim 

SolutionNote that we always can make fractions equal in two operations: Multiply first fraction's enumerator by bc, the first fraction is equal to abcb=ac, Multiply second fraction's enumerator by ad, the second fraction is equal to acdd=ac. 

That means that the answer does not exceed 2. 

If fractions are equal from input, the answer is 0. Otherwise, it can't be 0. 

Now we have to check if the answer is 1. Let's assume that for making fractions equal in 1 operation we have to multiply first fraction's enumerator by x. Then axb=cd must be true. From this we can see that x=bcad. x must be integer, so bc must be divisible by ad. If we assume that we multiplied first fraction's denumerator by x, we can do the same calculations and see that ad must be divisible by bc. So, for checking if the answer is 1 we need to check if one of ad and bc is divisible by another one. If we multiply second fraction's enumerator or denumerator by x we will get the same conditions for answer being equla to 1. 

If the answer is not 0 or 1, it's 2. 

Complexity: O(1)Code(C++)B — Interesting SumSolutionObviously, answer does not exceed max1+max2−min1−min2, where max1,max2 are two maximum values in the array, and min1,min2 are two minimum values. Let's find a segment, such as this is true. For that we will look at all positions containing max1 or max2 (S1) and all positions containing min1 or min2 (S2). After that we choose a pair l∈S1, r∈S2, such as abs(r−l) is minimum possible. Complexity: O(nlogn)Code(C++)C — CornersAuthors: Allvik06 

SolutionLet's say that cnt1 is the number of ones in the table. 

Note that if there is a connected area of zeros in the table of size at least 2, then we can add one 0 to this area by replacing only one 1 in the table. That means that if we have such area we can fill the table with zeros in cnt1 operations (we can't make more opertions because we need to replace at least one 1 by operation). 

There can be no such area in the beginning, but after first operation it will appear. So, for finding the answer we just need to find an angle with minimal number of 1 in it, and which we can replace. 

Complexity: O(nm)Code(C++)D1 — Xor-Subsequence (easy version)Authors: kirill.kligunov 

SolutionLet's use dynamic programming to solve this task. dpi -- maximum length of good subsequence, that ends int i-th element of a, than naive solution is 

dpi=maxij=0aj⊕i<ai⊕jdpj+1Let's observe that aj⊕i changes i not more than by 200. 

This way we can relax dpi not from j=0, but j=i−512, because xor operation changes only last 8 bits, so for j′<i−512, definitely aj′⊕j>aj⊕j′. 

Additional idea: 

It not so hard to proove that we can try j from i−256 to i−1. 

Code(C++)D2 — Xor-Subsequence (hard version)Authors: kirill.kligunov 

SolutionLet's calculate answer for each prefix. Let's find answer if the last number in our subsequence is number with index i. 

Let there be such j that a[j]⊕i<a[i]⊕j. That means that there are k bits in numbers a[j]⊕i and a[i]⊕j which are the same, and after that a[j]⊕i has different k+1-th bit. Let's notice that if first k bits are the same in a[j]⊕i and a[i]⊕j, then these bits are the same in a[j]⊕j and a[i]⊕iLet's keep our answer in bit trie. We will add numbers a[j]⊕j for our prefix. To find dp value for index i, we will descend in our trie with pair of integers ai⊕i and i. Each time we descend with bit l(0 or 1), in the opposite subtree there might be numbers which we can use to recalculate our answer. If in that subtree exists indexс j, then k+1-th bit of a[j]⋅i to 0. Let's keep such dp for every subtree: maximum value of dp[j] for every j, such that j lies in the subtree (but we need to keep answer if k-th bit of j is 0, and if it's equals 1). We should try to improve our answer using j if we descend to the opposite subtree. Then we can easily find answer for current i. After that we only need to add our number in the trie and recalculate the dp. 

Complexity: O(n * logC) where C its max value 

Code(C++)E — Misha and PaintingsAuthors: Allvik06, pakhomovee 

SolutionIf k is greater than the number of different numbers in the matrix, then the answer is k minus the number of different elements. 

Otherwise the answer does not exceed 2. 

Let's proof that: choose the maximum square (let its side be equal to L), containing the top left corner of the matrix, such as recolouring it to some new colour makes the number of different colours in the table at least k. 

If the number of different colours after recolouring is greater than k, then choose a square with bottom right corner in (L+1,L+1), such as recolouring it makes the number of different colours at least k. If we got exactly k colours then we are done. Otherwise let's extend the square by one. We got k or k−1 different colours. This way, by choosing the correct colour of the square we can get exactly k colours. Otherwise we are done. 

It remains to learn how to check whether the answer is equal to 1. We will iterate over length of the side of the square of the answer. Now we need O(n2) to check whether the required square with such a side exists. To do this, we calculate for each square in the table with such a side length (there are n2 such squares), how many numbers this square completely covers (all appeareances of this numbers are in thsi square). To do this, let's iterate over the number c. Having considered its occurrences, it is easy to understand that the upper left corners of all squares with our side length, covering all cells with the number c, lie in some subrectangle of the table, so you can simply add 1 on this subrectangle using offline prefix sums. Having processed all the numbers in this way, we can count for each square how many numbers it covers completely, and therefore check whether it fits the requirements. 

Complexity: O(n3)Code(C++) 

Codeforces Round #814 (Div. 1, Div. 2) Editorial 

By SomethingNew, 6 months ago, In EnglishSorry for not very good samples, and late editorial. It was our first round, so it was wary stressful for us, But we hope you liked the problems despite this! 

1719A - Chip Game 

Hint 1Hint 2Hint 3TutorialNote that the game will end only when the chip is in the upper right corner (otherwise you can move it 1 square to the right or up). For all moves, the chip will move n−1 to the right and m−1 up, which means that the total length of all moves is n+m−2 (the length of the move is how much the chip moved per turn). Since the length of any move is odd, then after any move of Burenka, the sum of the lengths will be odd, and after any move of Tonya is even. So we can find out who made the last move in the game by looking at (n+m−2)mod2=(n+m)mod2. With (n+m)mod2=0, Tonya wins, otherwise Burenka. 

The complexity of the solution is O(1). 

1719B - Mathematical Circus 

Hint 1Hint 2Hint 3TutorialNote that from the number k we only need the remainder modulo 4, so we take k modulo and assume that 0≤k≤3. 

If k=0, then there is no answer, because the product of the numbers in each pair must be divisible by 4=22, that is, the product of all numbers from 1 to n must be divisible by 2n2⋅2=2n, but the degree of occurrence of 2 in this sum is ⌊n2⌋+⌊n4⌋, which is less than n. 

If k=1 or k=3, then we will make all pairs of the form (i,i+1), where i is odd. Then a+k will be even in each pair, since a and k are odd, and since b is also even, the product will be divisible by 4. Если k=2, then we will do the same splitting into pairs, but in all pairs where i+1 is not divisible by 4, we will swap the numbers (that is, we will make a=i+1 and b=i). Then in pairs where i+1mod4=0, b is divisible by 4 (therefore the product too), and in the rest a+k is divisible by 4 (since a and k have a remainder 2 modulo 4). 

The complexity of the solution is O(n). 

1719C - Fighting Tournament 

Hint 1Hint 2Hint 3TutorialNote that after the strongest athlete is at the beginning of the queue, only he will win. The strongest athlete will be at the beginning of the queue no more than after the n-th round. Let's simulate the first n rounds, if the j-th athlete won in the i-th round, then we will write down the i number for him. Now, to answer the query (i,k), it is enough to find the number of wins of the i athlete in rounds with numbers j≤k, and if k>n, and the strength of the i athlete is equal to n, then add to the answer another k−n. 

The complexity of the solution is O(n+qlog(n)). 

1718A2 - Burenka and Traditions (hard version) 

Hint 1Hint for A1 1Hint for A1 2Hint 2Hint 3TutorialThere is an answer where the time spent is minimal and the lengths of all the segments taken are 1 and 2. because of the segment l,r,x can be replaced to ⌈r−l+12⌉ of segments of length 2 and 1, or rather [l,l+1,x],[l+2,l+3,x],…,[r,r,x](or [r−1,r,x] if (l−r+1) even). 

Note that if al⊕al+1⊕…⊕ar=0 is executed for l,r, then we can fill the l,r subsections with zeros for r−l seconds with queries [l,l+1,al],[l+1,l+2,al⊕al+1],...[r−1,r,al⊕al+1⊕…⊕ar]. 

Note that if a segment of length 2 intersects with a segment of length 1, they can be changed to 2 segments of length 1. 

It follows from all this that the answer consists of segments of length 1 and cover with segments of length 2. Then it is easy to see that the answer is (n minus (the maximum number of disjoint sub-segments with a xor of 0)), because in every sub-segments with a xor of 0 we can spend 1 second less as I waited before. this amount can be calculated by dynamic programming or greedily. Our solution goes greedy with a set and if it finds two equal prefix xors(prefixl=prefixr means that al+1⊕al+2⊕…⊕ar=0), it clears the set. 168724728 

The complexity of the solution is O(nlog(n)). 

1718B - Fibonacci Strings 

Common hintThe way of mathematiciansThe way of programmersTutorialAt the beginning, let's check that the number n (the sum of all ci) is representable as the sum of some prefix of Fibonacci numbers, otherwise we will output the answer NO. 

Let's try to type the answer greedily, going from large Fibonacci numbers to smaller ones. For the next Fibonacci number, let's take the letter with the largest number of occurrences in the string from among those that are not equal to the previous letter taken (to avoid the appearance of two adjacent blocks from the same letter, which cannot be). If there are fewer occurrences of this letter than this number, then the answer is NO. Otherwise, we will put the letter on this Fibonacci number and subtract it from the number of occurrences of this letter.If we were able to dial all the Fibonacci numbers, then the answer is YES. 

Why does the greedy solution work? Suppose at this step you need to take Fi (I will say take a number from ct, this will mean taking Fi letters t from string), let's look at the maximum cx now, if it cannot be represented as the sum of Fibonacci numbers up to Fi among which there are no neighbors, then the answer is no. It can be proved that if cx>Fi+1, then it is impossible to represent cx. 

If there is exactly one number greater than or equal to Fi at the step, then there is only one option to take a number, so the greedy solution works. 

If there are two such numbers and they are equal, then the option to take a number is exactly one, up to the permutation of letters. the greedy solution works again. 

If there are cj≥Fi,cx≥Fi,j≠x, then we note that the larger of the numbers cj,cx will be greater than Fi, if we don't take it, then at the next step this number will be greater than Fi+1 (i will be 1 less), according to the above proven answer will not be, so, taking the larger of the numbers is always optimal. 

The complexity of the solution is O(klog(n)log(k)). 

1718C - Tonya and Burenka-179 

Hint 1Hint 2Hint 3Hint 4TutorialLet's note that the answer for k=x and k=gcd(x,n) is the same. 

Indeed, for the number k, we will visit numbers with indices s+ikmodn for i from 0 to n−1 inclusive, from this we can see that the index of the i-th number coincides with the index of i+ngcd(k,n), and if we look at two indexes, the difference between which is l and l<ngcd(k,n), then they are different, since k⋅lmodn≠0, therefore, the answer is (the sum of numbers with indices s+ikmodn for i from 0 to ngcd(k,n)−1) ⋅gcd(k,n). 

Now let's prove that the first gcd(k,n) numbers are the same for (s,x) and (s,gcd(x,n)), note that only those indices that have the same remainder as s when divided by gcd(x,n) are suitable, but there are only ngcd(k,n) of such indices, and we proved that we should have ngcd(k,n) of different indices, so they are all represented once, therefore the answer for k=x and k=gcd(x,n) is the same, because the sum consists of the same numbers. 

So, we need to consider only k being divisors of n, this is already passes tests if we write, for example, a segment tree, but we don't want to write a segment tree, so we go further, prove that for k1=x, the answer is less or equal than for k2=x⋅y if k1 and k2 are divisors of n, why is this so? 

Note that for the number k, the answer beats for gcd(k,n) groups of numbers, so that in each group there is exactly ngcd(k,n) and each number is in exactly one group, and for different s the answer will be (the sum in the group that s belongs to) ⋅gcd(k,n). 

Let's look at the answer for the optimal s for k1, let's call the set at which it is reached t, note that in k2 for different s there are m independent sets that are subsets of t. Let mi be the sum in the i-th set. Now note that we need to prove max(m1,m2,…,my)∗y≥m1+m2+…my this is true for any mi, easy to see. 

So you need to iterate the divisors which equals to np where p is prime, now it can be passed with a set. Hurray! 

For the divisor d, it is proposed to store answers for all pairs (s,d), where s≤nd and the maximum among them, they can be counted initially for O(nlogn) for one d, each request is changing one of the values, this can be done for O(logn). 

The complexity of the author's solution is O(6⋅nlog(n)), where 6 is the maximum number of different prime divisors of the number n. 

1718D - Permutation for Burenka 

Hint 1Hint 2Hint 3TutorialLet's build a tree recursively starting from the segment [1,n], at each step we will choose the root of the subtree v=argmax([pl,pl+1…,pr])+l−1, then recursively construct trees for subtrees [l,v−1],[v+1,r] if they are not empty, then create edges from the root to the roots of these subtrees. What we got is called a Cartesian tree by array. This Cartesian tree will be mentioned further in the analysis. 

It is easy to see that Cartesian trees by arrays coincide if and only if these arrays are similar. Then the necessary and sufficient condition for the array a to be similar to p is that for any pair u,v such that u is in the subtree v, av>au is satisfied, in other words av is the maximum among the numbers in the subtree of the vertex v. 

Let's call the position i initially empty if initially ai=0. 

Let's call an array a almost similar to p if for any pair u,v such that u is in the subtree v, av>au is executed, or both positions u, v are initially empty. 

Let's prove that if there is a way to fill in the gaps in a to get an array almost similar to p, then there is also a way to fill in the gaps to get a similar to p array a. 

Indeed, let's look at the a array almost similar to p. let's walk through the tree recursively starting from the root. At the step with the vertex v, we first start recursively from all the children of v, now it is true for them that the maxima of their subtrees are in them, let's look at the maximum child v, let it be u, then if av>au, then everything is fine, otherwise av<au note that v is initially an empty position, because for all initially non-empty positions it is true that they are maximums in their subtrees (this is easy to see in the definition), but v is not. Note that u is initially an empty position. Otherwise, we have never changed av and au, therefore, in the original array a almost similar to p, av>au contradiction was executed, it is contradiction. so v,u are initially empty, we can perform swap(av,au) and everything will be executed. 

After executing this algorithm, we changed only the initially empty elements and got a similar to p. Q.E.D. 

How to check the existence of an array almost similar to p? Let's call the number ri the minimum among all the numbers av such that i is in the subtree of v. Let's call the number li the maximum among all the numbers av such that v is in the subtree of i. it is easy to see that a is almost similar to p if and only if for all i, li<ai<ri is satisfied. 

That sounds incredibly good. So, all we need is to find a matching of the set S and number d and segments [li,ri] for i that are initially empty. Now it is easy to prove that the suitable d is a continuous segment (let's say the answer is yes for d1, we don't know the answer for d2, try looking at the alternating path from d1 to d2 in good matching for d1, it's easy to see that if there is such a path, then for d2 the answer is yes, otherwise, no. If you look at the structure of the matching of points with segments, you can see that an alternating path exists for a continuous segment of values d2). the boundaries can be found by binary search or by typing greedily twice. 

Final complexity is O(nlogn) or O(nlog2n)1718E - Impressionism 

Hint 1Hint 2Hint 3TutorialLet's have two permutations: p of length n and q of length m. Initially, both permutations are identical. For operation 1ij, we will execute swap(pi,pj), for operation 2ij we will execute swap(qi,qj). It is easy to see that after performing all operations in the position i,j will be api,qj. 

Now we need to find permutations of p,q so that api,qj=bi,j. 

Let's look at a bipartite graph where the first part is rows and the second is columns. Let if ai,j≠0, then from i there is an undirected edge in j of the color ai,j. if we construct the same graph for b, then we need to check for isomorphism two bipartite graphs, each edge of which has a color, and as we remember, by the condition of the vertex, 2 edges of the same color cannot be Incidence. Let's call them graph a and graph b. 

This problem is largely for implementation, therefore, starting from this moment, the actions that you can observe in the author's solution are described 168728958. 

Let n<m otherwise let's swap n and m in places. Let's try to match the elements of the array a to the elements of the array b. Let's go through the indices from 1 to n. Let's now choose which pair of b to choose for the i-th vertex of the first fraction of the graph a. If we have already found a pair earlier, skip the step, otherwise let's sort out the appropriate option for the pair among all the vertices of the first component b that do not yet have a pair, there are no more than n, after the vertices are matched, the edges are also uniquely matched (because there are no 2 edges of different colors), let's then run the substitution recursively for edges (if we have mapped the vertex v to the vertex u and from v there is an edge of color x in i, and from u there is an edge x in j, then it is easy to prove that in the answer i will be mapped to j), which means we will restore the entire component. Let the sum of the number of vertices and the number of edges in the component be k, then we will perform no more than n⋅k actions to restore the component. 

by permutations, getting a sequence of swaps is a matter of technique, I will not explain it, but this is a separate function in the author's solution you will understand. 

in total, our solution works for O(n(n⋅m+n+m)) or O(min(n,m)(n⋅m+n+m)), where n⋅m+n+m is the total number of vertices and edges in all components. 

feel free to ask any questions 

1718F - Burenka, an Array and Queries 

HintTutorialIn order to find the number of numbers from 1 to C that are mutually prime with x, we write out its prime divisors (various). Let these be prime numbers a1,a2,…,ak. Then you can find the answer for 2k using the inclusion-exclusion formula. 

Because ⌊ab⋅c⌋=⌊⌊ab⌋c⌋, a similar statement is made for k numbers (you can divide completely in any order). 

Let's split the primes up to 2×104 into 2 classes — small (≤42) and large (the rest). There are 13 small numbers, and 2249 large ones. Separately, we will write down pairs of large numbers that in the product give a number not exceeding 105. There will be 4904 such pairs. 

Let's match each set of small primes with a mask. Let's write dp[mask] — alternating sum over the mask submasks of numbers ⌊Ca1⋅a2⋅…⋅ak⌋, where a1,…,ak — prime numbers from the submask. Similarly, we define dp[mask][big] (in addition to the mask, there is a large prime big) and dp[mask][case] (in addition to the mask, there are a pair of primes from a pair of large primes case). Each dp can be counted for states×bits, where states — is the number of states in dp, and bits — is the mask size (number of bits). 

If we write out all the large primes on the segment for which mask — mask of small primes, the answer for this segment will be the sum of dp[mask]+∑dp[mask][bigi]+∑dp[mask][casei] (for big and case lying on the segment). Thus, the request can be answered in 7000 calls to dp. 

In order to find a set of prime numbers on a segment, you can use the MO algorithm. 

Final complexity is O(nn−−√+q×(π(m)+casesCount(C)))It is worth noting that (with a very strong desire) it is possible to further optimize the solution using avx, to speed up the calculation of the amount by submasks in dynamics by 16 times, to speed up the calculation of the amount of dp[mask][big] by 8 times, which will allow you to answer the request in ~5000 (instead of 7000) calls to dp, and the pre-calculation for 4⋅107 instead of 7⋅108 (in fact, the pre-calculation works much faster due to compiler optimizations). 

Please rate the problems, it will help us make the problems better next time! 

Problem Feedback 

Codeforces Round #813 (Div. 2) Editorial 

By Vladithur, history, 7 months ago, In EnglishThanks for participating in the round, we hope you liked the problems! 

Solve count predictions (official div. 2)1712A - Wonderful Permutation 

HintTutorial1712A - Wonderful PermutationFor any permutation p of length n, the final sum p1+p2+…+pk after some number of operations can't be less than 1+2+…+k. 

This means that we need to apply the operation at least once for every i such that 1≤i≤k and pi>k. Every time we apply it, we have to choose some index j such that k<j≤n and pj≤k. 

This is always possible since initially the number of suitable i is equal to the number of suitable j, and one operation decreases both the number of suitable i and the number of suitable j by one. 

It is easy to see that in the end, the set {p1,p2,…,pk} only contains the values {1,2,…,k}, which means that the sum is equal to 1+2+…+k, which is the smallest sum we can get. 

So the answer is the the number of i such that 1≤i≤k and pi>k. 

Complexity: O(n)Bonus: solve for every k from 1 to n for n≤105. 

1712B - Woeful Permutation 

HintsTutorial1712B - Woeful PermutationA well know fact is that gcd(a,b)⋅lcm(a,b)=a⋅b for any two positive integers a and b. Since gcd(x,x+1)=1 for all positive x, we get that lcm(x,x+1)=x⋅(x+1). 

All of this should hint that for even n, the optimal permutation looks like this: 2,1,4,3,…,n,n−1. Add for odd n, it looks like this: 1,3,2,5,4,…,n,n−1. 

Complexity: O(n)Turns out the formal proof is pretty hard. You are welcome to try and find something simpler. 

Define f(x,y) as x⋅y if x≠y, and x otherwise. It is easy to see that lcm(x,y)≤f(x,y). We will find the maximum possible value of f(1,p1)+…f(n,pn) and show that it is reached by our construction. 

Suppose we want to solve this problem: find the max possible value of 1⋅p1+…+n⋅pn, if for all i>1, pi≠i. This is equivalent to maximizing f(1,p1)+…f(n,pn), because if there is such an index i, it is always optimal to swap pi with pj for any 1≤j<i. 

Let's build a graph on this permutation with n vertices and add all edges i→pi. Except for maybe p1=1, all the other cycles have a length of at least 2. 

Let's look at one such cycle x1,x2,…,xk. The optimal value with no restrictions on the value of pi would be x21+x22+…+x2k, but right now we have x1⋅x2+x2⋅x3+…+xk⋅x1. Subtracting one from the other: 

x21+x22+…+x2k−(x1⋅x2+x2⋅x3+…+xk⋅x1)==x212−x1⋅x2+x222+x222−x2⋅x3+x232+…+x2k2−xk⋅x1+x212==(x1−x2)2+(x2−x3)2+…+(xk−x1)22≥≥|x1−x2|+|x2−x3|…+|xk−x1|2≥≥max(x1…xk)−min(x1…xk)So we need to minimize the sum of max(x1…xk)−min(x1…xk) over all cycles. 

If n is even, it is easy to see the minimum possible value of this is n2, and it doesn't matter what p1 equals to. 

For odd n we have to look at two cases: p1=1 and p1≠1. In the first case, the minimum possible sum is n−12, in the second case, it is n+12, which is worse that in the previous case. 

Returning to the original problem, our constructions also achieve this minimal difference from 12+22+…n even when we change f back into lcm, so they are optimal. 

Bonus: try to prove the solution without the editorial! 

1712C - Sort Zero 

HintsTutorial1712C - Sort ZeroAn array is sorted in non-decreasing order if and only if there is no index i such that ai>ai+1. This leads to a strategy: while there is at least one such index i, apply one operation with x=ai. 

Why is this optimal? Since our operation can only decrease values, and we must decrease ai so that ai>ai+1 is no longer true, this leaves us no choice but to use the operation with x=ai. 

You can simulate this strategy by maintaining a set of bad indices, since if an index i becomes bad, after you apply an operation with x=ai, it can never become bad again. So in total, there are at most 2⋅(n−1) operations with the set. 

Complexity: O(nlogn) or O(n), depending on which set you use. 

Note: you can solve the problem in O(n) by noticing that if an index i is bad, we need to apply the operation for all unique non-zero values in {a1…ai}. This is also quite a bit shorter to code. 

Bonus: solve for when ai can also be negative. 

1712D - Empty Graph 

HintsTutorial1712D - Empty GraphFirst of all, we will always use the operation to assign 109 to ai. 

1. Suppose u<v. Then d(u,v)=min(min(au…av),2⋅min(a1…an)). 

Proof: since the weight of an edge is always ≥min(a1…an), the best we can do with one edge is min(au…av). And the best we can possibly do with two edges is 2⋅min(a1…an), which turns out possible to achieve. 

Subproof: suppose imin is the index of one of the minimums in the array. If u≤imin≤v, then min(au…av) is optimal, so we don't need two edges in the first place. Else, either imin<u or imin>v. In the first case, we can notice that d(u,1)+d(1,v)=2⋅min(a1…an). In the second case, d(u,n)+d(n,v)=2⋅min(a1…an). 

2. The diameter of the graph is equal to max1≤i≤n−1d(i,i+1)=min(max1≤i≤n−1min(ai,ai+1),2⋅min(a1…an)). 

Proof: since the minimum of a subsegment can only decrease when it's length increases, it is optimal to look only at the distance between two adjacent vertices. 

Now we can either do binary search on the answer, or we can do a clever greedy. 

Binary search solution: 

Suppose the answer is ≥ans. First of all, we need to apply the operation for all ai<ans2. If there are not enough operations to do this, return false. Otherwise assign 109 to such ai. If there are no operations left, just calculate the diameter and see if it is ≥ans. 

If there is at least one operation left, there are two cases: k=1 and k≥2. If the first case, it is optimal to apply our operation near one of the maximums in the array to maximize min(ai,ai+1), so we need to return true if max(a1…an)≥ans. With k>1, it is optimal to apply the operation near an index which has been turned into 109, so we always return true. 

Make sure to binary search on ans from 1 to 109 inclusive. Doing it from 1 to 2⋅109 needs another case to work. 

Complexity: O(nlogA). 

Greedy solution: 

We can actually maintaining the diameter of the graph while supporting point update queries (set ai to some value). To do this, we can use any structure that can get max1≤i≤n−1min(ai,ai+1) (multiset, segment tree) and another structure to maintain the minimum in the array. 

Change the k−1 smallest values in the array into 109. For every i from 1 to n, change ai to 109, get the diameter, and then change ai back to it's original value. The answer is the max value over all the returned diameters. 

Proof: obviously works for k=1, so suppose k≥2. Since we changed at least one value, we will check if having two adjacent 109 is optimal, maximizing max1≤i≤n−1min(ai,ai+1). And we will also check if we need to change the k-th smallest value, in this case maximizing 2⋅min(a1…an). 

Complexity: O(nlogn)Note: it is also possible to solve without data structures by doing a bit more casework, but the solution is still O(nlogn) due to sorting. 

Bonus: solve for every k from 1 to n. 

1712E2 - LCM Sum (hard version) 

HintsTutorial1712E2 - LCM Sum (hard version)Let's count the number of bad triplets that don't satisfy the condition, i.e. lcm(i,j,k)<i+j+k. Then the answer for one test case is (r−l+1)⋅(r−l)⋅(r−l−1)6− the number of bad triplets. 

Since i<j<k, a triplet is bad only when lcm(i,j,k)=k or (lcm(i,j,k)=2⋅k and i+j>k). This means that both i and j must be a divisor of 2⋅k. 

For every segment [i;k] where i is a divisor of 2⋅k, let's count the number of j such that i<j<k. Let's call it the weight of the segment. Turns out that for the current constraints, for every k, we can iterate over all pairs of 1≤i<j<k, where i and j are divisors of 2⋅k, and check if the triplet is bad. If it is, then we increase the weight of the segment [i;k] by one. 

To get answers for the test cases, we just need to find the sum of the weights of the segments [i;k] that are inside [l;r]. This is a pretty standard problem, which can be solved in offline using a data structure that supports point add and range sum. 

It is possible to solve E1 without a data structure by iterating over the segments and checking for every one of them if it lies inside [l;r]. 

Complexity: O(nlog2n+tlogn+∑ni=1σ0(2⋅i)2) with a seg tree (∑ni=1σ0(2⋅i) is about nlogn and a seg tree update works in O(logn), so we get nlog2n). 

You can also use sqrt decomposition to get O(nlogn+tn−−√+∑ni=1σ0(2⋅i)2). 

Bonus: solve the problem in O((n+t)logn) or better. 

1712F - Triameter 

HintsTutorialTutorial is loading...Bonus: solve for n,q≤106. 

Don't forget to rate the problems! 

Problem FeedbackPS: Solution codes probably will be added later. 

UPD: explanations of the references: 

Click here 

Codeforces Round #812 (Div. 2) Editorial 

By DeMen100ns, history, 7 months ago, In EnglishBefore the round starts1713A - Traveling Salesman Problem 

Hint 1Hint 2Tutorial1713A - Traveling Salesman ProblemSuppose we only have boxes on the Ox+ axis, then the optimal strategy is going in the following way: (0,0),(xmax,0),(0,0). There is no way to do in less than 2⋅|xmax| moves. 

What if we have boxes on two axis? Let's assume it is Oy+, suppose we have a strategy to go in the following way: (0,0),(xmax,0),...,(0,ymax),(0,0). In this case it is optimal to fill the three dots with (0,0), which is just solving each axis independently. 

Therefore, the number of axis does not matters. For each axis that has at least one box, go from (0,0) to the farthest one, then come back to (0,0). 

Time complexity: O(n)SolutionFeedback1713B - Optimal Reduction 

Hint 1Hint 2Hint 3Tutorial1713B - Optimal ReductionLet's call M=max(a1,a2,…,an). 

The problem asks us to make all its elements become 0 in some operations. And for each operation, we subtract each elements in an subarray by 1. Thus, every largest elements of the array have to be decreased in at least M operations. And also because of that, min(f(p)) over all permutations p of a is never less than M. 

Every permutations p of a such that f(p)=M have the same construction. That is, they can be divided into 2 subarrays where the left subarray is sorted in non-decreasing order, and the right subarray is sorted in non-increasing order. In other words, the elements of the array should form a mountain. 

Why?So how to check whether f(a)=M or not? Well, we can define preLen equal to the length of the longest prefix which is sorted in non-decreasing order. Then define sufLen equal to the length of the longest suffix which is sorted in non-increasing order. If preLen+sufLen≥n, the answer is YES. 

Time complexity: O(n)SolutionFeedback1713C - Build Permutation 

Hint 1Hint 2Hint 3Hint 4Tutorial1713C - Build PermutationFirst, let's prove that the answer always exists. Let's call the smallest square number that is not smaller than k is h. Therefore h≤2⋅k, which means h−k≤k. Proof. 

So we can fill pi=h−i for (h−k≤i≤k). Using this method we can recursively reduce k to h−k−1, then all the way down to −1. 

We can prove that h−k≥0, as h≥k. 

Time complexity: O(n)SolutionFeedback1713D - Tournament Coundown 

Hint 1Hint 2Hint 3Tutorial1713D - Tournament CoundownThere is a way to erase 3 participants in every 2 queries. Since there are 2n−1 participants to be removed, the number of queries will be ⌈(2n−1)⋅23⌉=⌊2n+13⌋. Suppose there are only 4 participants. In the first query we will ask the judge to compare the 1st and the 3rd participants. There are three cases: 

The 1st participant wins more game than the 3rd one: the 2nd and 3rd cannot be the winner. 

The 3rd participant wins more game than the 1st one: the 1st and 4th cannot be the winner. 

The 1st and 3rd participants' numbers of winning games are equal: both the 1st and 3rd cannot be the winner. 

Ask the remaining two participants, find the winner between them. 

If there are more than 4 participants, we can continuously divide the number by 4 again and again, until there are at most 2 participants left. Now we can get the winner in one final query. 

SolutionFeedback1713E - Cross Swapping 

Hint 1Hint 2Hint 3Tutorial1713E - Cross SwappingLet's take a look at what the lexicographically smallest matrix is. Let's call (x,y) a cell that is in the intersection of row x and column y of the matrix, and the integer written on that cell is Ax,y. A cell (xp,yp) of this matrix is called more significant than the another cell (xq,yq) if and only if xp<xq, or xp=xq and yp<yq. The problem asks us to find the smallest matrix so the best suitable way to solve this problem is to traverse through the most to the least significant cell of the matrix, then determine if the current cell can be minimized or not. 

Suppose the current cell we are looking at is (x,y). If x=y then its position will not change after performing the operations. But if x≠y, there are exactly 2 operations that swap (x,y) with another cell, that is k=x and k=y. Both of these operations swap (x,y) with the same cell (y,x). So the only way we can minimize the value of (x,y) is to try swapping it with (y,x) (if x<y and Ax,y>Ay,x) in some way. 

As a result we have our constructive algorithm. Remind that for each operation k=i of the matrix (1≤i≤n), there are 2 states: it is being performed and not being performed. Suppose we have traversed to the cell (x,y). If x≥y, ignore it. If x<y then we try to make Ax,y=min(Ax,y,Ay,x) by deciding to swap or not to swap the cells. If Ax,y>Ay,x, try to swap (x,y) with (y,x) by making 2 operations k=x and k=y having different states. And if Ax,y<Ay,x then we should keep their positions unchanged by making 2 operations k=x and k=y having the same state. Note that if Ax,y=Ay,x, we do nothing. 

Let's implement this algorithm using a simple DSU where the ith node represents the operation k=i. We define the value par[u] in such a way that, suppose p is the root of the u node's component, par[u]=p if 2 operations k=u and k=p should have the same state, or par[u]=−p if 2 operations k=u and k=p should have different states. Define another function join(i,j) to union 2 nodes i and j to the same component. Note that u and −u are always in the same component and par[−u]=−par[u]. Thus, for the current cell (x,y), we want to swap it with (y,x) by calling join(x,−y), or keep its position unchanged by calling join(x,y). 

After constructing the graphs, the last thing to do is to determine which operations should be performed. One way to do so is for each root of the components of the DSU, we perform the operation which this root represents for. Then for other nodes just check par[i]>0 for the ith node and if it is true, the k=i operation should be performed. When we have the list of the operations that need to be performed, we can bruteforcely perform each operation from the list one by one and the final matrix will be the lexicographically smallest matrix. 

Time complexity: O(n2) 

SolutionFeedback1713F - Lost Array 

Hint 0Hint 1Hint 2Hint 3Tutorial1713F - Lost ArrayFirst, we can see that ai contribute ((n−i)+(j−1)j−1) times to bj,n, which can calculate similar to Pascal's Triangle. It's easy to see that the value that ai contribute to bj,n equal to ai when ((n−i)+(j−1)j−1) is odd, 0 otherwise. 

Let's solve the inverse problem: Given array a. Construct bj,n for all j. (1≤j≤n)By Lucas Theorem, ((n−i)+(j−1)j−1) is odd when (n−i) AND (j−1)=0→(n−i) is a submask of ∼(j−1) (with ∼a is inverse mask of a). 

Let define m=2k with smallest m satisfy m≥n. Set a′i=ai and b′j=b∼(j−1)=b(m−1)−(j−1) then b′ is the Zeta transform of a′. 

So we could apply Mobius transform in b′ to get a′. Since the operation is xor, mobius transform is as same as zeta transform. But unlike the inverse problem, there are some differences. We don't know the value of b′i for i in [0,m−n). 

Let c be the sum over supermasks array of b′ (with i is supermasks of j when i AND j=j), then set ck=0 for k in [m−n,m). After that, do another sum over supermasks on c to get original value of b′. Now we can find a′ from b′ and a from a′. 

Complexity: O(nlog2(n))SolutionFeedback 

Codeforces Round #811 (Div. 3) Editorial 

By Vladosiya, history, 7 months ago, In English1714A - Everyone Loves to Sleep 

Idea: Vladosiya 

Tutorial1714A - Everyone Loves to SleepTo begin with, let's learn how to determine how much time must pass before the i alarm to trigger. If the alarm time is later than the current one, then obviously 60∗(hi−H)+mi−M minutes should pass. Otherwise, this value will be negative and then it should pass 24∗60+60∗(hi−H)+mi−M since a full day must pass, not including the time from the alarm to the current time. We just need to find the minimum number of minutes among all the alarm clocks. 

Due to small constrains, the problem can also be solved by stimulating the sleep process: increase the answer by 1 and check whether any alarm will work after this time. 

Solution1714B - Remove Prefix 

Idea: MikeMirzayanov 

Tutorial1714B - Remove PrefixLet's turn the problem around: we'll look for the longest suffix that will make Polycarp happy, since it's the same thing. 

Let's create an array cnt, in which we will mark the numbers already encountered. Let's go along a from right to left and check if ai does not occur to the right (in this case it is marked in cnt), if it occurs to the right, then removing any prefix that does not include i, we get an array where ai occurs twice, so we have to delete prefix of length i. 

Solution1714C - Minimum Varied Number 

Idea: MikeMirzayanov 

Tutorial1714C - Minimum Varied NumberLet's use the greedy solution: we will go through the digits in decreasing order. If the sum of s we need to dial is greater than the current digit, we add the current digit to the end of the line with the answer. 

Note that in this way we will always get an answer consisting of the minimum possible number of digits, because we are going through the digits in descending order. 

Suppose that the resulting number is not optimal. Then some digit can be reduced, and some digit that comes after it can be increased, in order to save the sum (we can not increase the digit before it, as then we get a number greater than the current one). Two variants are possible. 

We want to increase the digit x to x+1, but then it becomes equal to the digit following it, or exceeds the value 9. Then we can't increment that digit.Otherwise, in the first step, we can get x+1 instead of x, but since we are going through the digits in decreasing order, we cannot get the value of x in that case. Contradiction.Solution1714D - Color with Occurrences 

Idea: MikeMirzayanov 

Tutorial1714D - Color with OccurrencesThe first step is to find the word that covers the maximum length prefix. If there is no such word, we cannot color the string. 

Then go through the positions inside the found prefix and find the next word, which is a tweak of t, has the maximal length, and ends not earlier than the previous found word, and not later than the text t. If there is no such word, it is impossible to color t. 

After the second word is found, similarly continue looking for the next ones. 

Solution1714E - Add Modulo 10 

Idea: DmitriyOwlet 

Tutorial1714E - Add Modulo 10Let's see which remainders modulo 10 change into which ones. 

If the array contains a number divisible by 10, then it cannot be changed. If there is a number that has a remainder of 5 modulo 10, then it can only be replaced once. 

Thus, if the array contains a number divisible by 5, then we apply this operation to all elements of the array once and check that all its elements are equal. 

The remaining odd balances (1,3,7,9) immediately turn into even ones. The even remainders (2,4,6,8) change in a cycle, while the array element increases by 20 in 4 operations. Thus, we will apply the operation to each element of the array until its remainder modulo 10 becomes, for example, 2, and then check that the array does not contain both remainders 2 and 12 modulo 20. 

Solution1714F - Build a Tree and That Is It 

Idea: MikeMirzayanov 

Tutorial1714F - Build a Tree and That Is ItIf the answer exists, you can hang the tree by some vertex such that the distances d12,d23 and d31 can be expressed through the sums of distances to vertices 1,2 and 3. Then from the system of equations we express the required values of distances to vertices 1,2,3 and construct a suitable tree. If the distance to a vertex is 0, then that vertex is the root. There cannot be two roots, nor can there be negative distances. 

If none of the vertices of 1,2,3 is the root, then make vertex 4 the root. 

Next we build the required tree: add the required number of unique vertices on the path from the root to vertices 1,2,3. Note also that if the sum of distances is greater than or equal to n, then we cannot build the tree either. 

The remaining vertices can be simply joined to the root. 

Solution1714G - Path Prefixes 

Idea: MikeMirzayanov 

Tutorial1714G - Path PrefixesNote that all bj are positive, which means that the amount on the prefix only increases. This allows us to use binary search to find the answer for the vertex. It remains only to learn how to quickly find the sum of bj on the path prefix. Let's run a depth-first search and store the prefix sums of the current path in stack: going to the vertex, add the sum to the end of the path and delete it when exiting. 

Solution 

Codeforces Round #810 Editorial 

By Rhodoks, history, 7 months ago, In EnglishSorry for the late editorial. May this editorial help you. If you have questions, feel free to ask. 

1711A - Совершенная перестановка 

hint1.solutionSince k+1 does not divide k, a permutation with weight equal to 1 is: [n,1,2,⋯,n−1]. 

code1711B - Вечеринка 

hint1.hint2.solutionLet's consider the case where m is odd only, since if m is even the answer is 0. 

Assume that you delete x vertices with even degrees and y vertices with odd degrees. 

If y≥1, then only deleting one vertex with an odd degree would lead to a not worse answer, so you do not need to consider it except for (x,y)=(0,1). 

If y=0, then the parity of the edges at the end is determined only by the number of edges whose both endpoints are deleted. In particular, there must be at least two adjacent vertices deleted with even degrees. So you do not need to consider it except for (x,y)=(2,0) and they are neighbours. 

Thus, an optimal solution either has (x,y)=(0,1) or (x,y)=(2,0) and the two vertices are adjacent. 

One can iterate over all possible solutions with such a structure and take the optimal one. 

Total time complexity: O(n+m). 

code1710A - Покраска рисунка 

hint1.hint2.solutionLet's first prove hint1 first. 

If there is a pair of toroidal neighbors with different colors. For example, colx,y=a and colx+1,y=b(a≠b). Then we will find colx−1,y=colx,y+1=colx,y−1=a,colx+2,y=colx+1,y+1=colx+1,y−1=b must hold. Then we find another two pairs of toroidal neighbors colx,y+1,colx+1,y+1 and colx,y−1,colx+1,y−1. Repeat such process, we will find the boundary should be like: 



Similar, the boundaries can be vertical lines, but horizontal lines and vertical lines can not exist in one picture. 

So the pattern should be row stripes all with at least 2 rows or column stripes all with at least 2 columns. 

Check if one can draw a beautiful picture with row stripes only or with column stripes only. We consider only the case of row stripes, the reasoning is analogous for column stripes. 

If it is possible, then ∑ai≥2m⌊aim⌋≥n must hold. 

If n is even, then such a condition is enough. 

If n is odd, there must be some ⌊aim⌋≥3. In this case, you can draw a beautiful picture using such algorithm: 

Sort ai from large to small. 

Draw 2 rows stripes of each color if possible. 

If the picture still has some rows empty, insert new rows into each stripe. 

Total time complexity: O(n). 

code1710B - Дождь 

hint1.hint2.hint3.solutionLet's call position j a key position if it is the center position of a rain. i.e. there exists i so that xi=j. 

You can calculate aj for all key positions j using the difference array. 

Let d1j=aj−aj−1, d2j=d1j−d1j−1, then the i-th day's rain will change it as follows: 

d2xi−pi+1←d2xi−pi+1+1d2xi+1←d2xi+1−2d2xi+pi+1←d2xi+pi+1+1This can be calculated efficiently using prefix sums. 

We say that a position j is valid if aj≤m. 

Now, consider an invalid position j; erasing the i-th day's rain will make it valid if and only if pi−|xi−j|≥aj−m. 

One can check that the region of (x,p) satisfying such an inequality is a quadrant rotated 45∘ anticlockwise and translated. And in particular, even the intersections of two such regions have the same structure and can be computed easily (to avoid using floating point numbers, one can multiply all xi,pi by 2). 

In the end, for each i, you only need to check whether point (xi,pi) belongs to such region. 

Total time complexity: O(nlogn). 

code1710C - XOR-треугольники 

hint1.hint2.solutionDefine cnti1i2i3 as: 

jth bit of cnti1i2i3 is 1 iif i1=aj,i2=bj,i3=cj 

e.g. a=(10)2,b=(11)2,c=(01)2 then cnt110=(10)2,cnt011=(01)2, other cnt is 0. 

a=cnt100+cnt101+cnt110+cnt111b=cnt010+cnt011+cnt110+cnt111c=cnt001+cnt011+cnt101+cnt111a⨁b=cnt010+cnt011+cnt100+cnt101a⨁c=cnt001+cnt011+cnt100+cnt110b⨁c=cnt001+cnt010+cnt101+cnt110a⨁b+a⨁c>b⨁c⟺cnt011+cnt100>0similar: 

cnt101+cnt010>0cnt110+cnt001>0then we use digit dp: dp[n][i][j] means when we consider first n bits, state of reaching the upper bound is i, state of conditions is j. 

Enumerate ajbjcj for j from |n|−1 to 0 and make transition. 

Time complexity is O(29|n|) where |n| is the length of input. 

code1710D - Восстановление дерева 

Thank dario2994, the key part of the proof is from him. 

hint1hint2hint3solutionLet's consider the interval in the order of its length (small to large) and add the edge one by one. 

Initially, the graph has no edge. There are n connected components each consisting of exactly one vertex. Note our algorithm will guarantee that at every moment every connected component's indices compose an interval. Let [Li,Ri] be the connected component vertex i in. 

If [x,y] is good and x and y are not in the same connected component, we can merge [Lx,Ry] into a larger connected component. 

Supposing [Lx,Ry] consist of k+2 connected components now, let's call them [l0,r0],[l1,r1],⋯,[lk+1,rk+1](x∈[l0,r0],y∈[lk+1,rk+1]), you can link edges like: 

⋯−l4−l2−x−y−l1−l3−⋯If [x,y] is good and x and y are in the same connected component, then we do nothing. 

Finally, you will get a valid tree. 

Total time complexity: O(n2). 

proofcode1710E - Два массива 

hint1.hint2.hint3.solutionKnowing the above facts, it is clear that we can apply binary search on the answer Z, which is less than a1+b1, or Alice can end the game immediately to get a1+b1. 

Let's color white all the cells with ar+bc≤Z, and black all the cells with ar+bc>Z. 

Then we shall add edges between cells in the same row or same column with different colors. These edges and cells form a bipartite graph. 

Consider the game on the bipartite graph. Initially, we are at cell (1,1). Alice moves first, then they take turns to move. Each player can only move the cell to another place with an edge connecting them, or the other player will end the game immediately. 

Each cell can be visited at most 1000 times, whoever cannot move loses. 

If Alice wins, then the answer is no greater than Z, otherwise, the answer is greater than Z. 

The version of this game where each vertex can be visited exactly once is known. If both players play optimally, the first player wins iff the starting vertex belongs to all possible maximum matchings. I'll explain why at the end of the editorial. 

It turns out that the condition is exactly the same even if each vertex can be visited at most 1000 times. Let us show why. 

First, calculate the maximum matching. Then we erase the starting vertex and calculate the maximum matching in the new graph. If two matchings have the same size, the vertex does not belong to all maximum matchings and vice versa. 

Now, we know that if we copy a cell 1000 times and copy the edges as well, this problem is exactly the same as the model mentioned above. If we consider the initial bipartite graph, it's easy to see that we only need to check whether (1,1) is in all maximum matchings of the initial graph, because the maximum matching remains unchanged in the other 999 parts. 

So, we have shifted the problem to see if the initial cell belongs to all matchings. 

According to [Kőnig's theorem in graph theory](https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)), the size of the maximum matching is equal to the size of the minimum vertex cover. And if you erase all vertices in the minimum vertex cover, you get an independent set, which is the maximum independent set. 

Using M to refer to the maximum matching, I to refer to the maximum independent set, V to refer to the set of vertices, we know that |M|+|I|=|V|So, if we erase one vertex and |M| remains unchanged, then |I| must be changed and vice versa. 

Now our issue is to calculate the maximum independent set in this graph, with or without the initial cell. 

Let us sort ai and bi (notice that reordering rows and columns do not change the game at all). Now the white cells form a "decreasing histogram". We can still find the starting cell (va,vb). 

First, let's compute the maximum independent set with the initial cell. 

Before that, consider the following constraints: 

It's obvious that one column has at most one color of its cells in the independent set(we shall call it I), so does a row. Let's call a column white if only white cells of it are in I, otherwise, we shall call it black. 

What is the maximum size of I, when we must have i white columns and j white rows? The answer is simple. We shall select the first i columns to be white and the first j rows to be white, the rest of the columns and rows to be black. Then the independent set consists of black cells on black rows and black columns, and white cells on white columns and white rows. It's easy to prove this greedy strategy is correct. 

Now we fix the number of white columns as i, and try to find a j that maximizes |I|. If we make an array da[i] satisfying ai+bda[i]≤Z and ai+bda[i]+1>Z, and a similar array db[j], we can easily calculate the change of |I| when we turn row j from black to white and vice versa, which is n−max(i,db[j])−min(i,db[j]), −min(i,db[j]) means remove the white part from I, +n−max(i,db[j]) means add the black part to I. For a fixed i, it's easy to see that the change increases with j. 

So you can maintain all positive changes of |I|, just decrease the j with i decreasing. Now you can calculate the maximum of |I| in O(n+m) time. 

It's easy to see that da[i] and db[i] are non-increasing, so they can be calculated in O(n+m) time. 

For the maximum independent set without the initial cell, you just need to remove it when it is in I. Since the cell is always black, it is quite easy. 

Using binary search on the answer, you can solve the whole problem in O((n+m)logA+nlogn+mlogm), where A is the maximum value of the arrays a and b. 

Let us conclude with the idea of the known game on bipartite graphs. 

\textbf{Lemma}: The first player can win if and only if all possible maximum matchings include the initial vertex H. 

Let's prove it when H satisfies the constraint. 

The first player can just choose any matching M and move to the vertex P matching with current vertex, then any unvisited neighbor of P still matches with other unvisited vertices. If P has a neighbor unmatched in a certain matching M, we find an augmenting path and a matching M′ that doesn't include H, which is in conflict with the constraint. So no matter how the second player chooses to move, the first player always has a vertex to go after that. 

Otherwise, we add a vertex P with the only edge (P,H), move the initial cell to P, swap the two players, then it turns into the situation above. 

code 

Codeforces Round #809 Editorial 

By BucketPotato, history, 7 months ago, In EnglishSome stats about the roundPre-contest predictionsWho did what?SolutionsProblem ASolution1706A - Another String Minimization ProblemLet's iterate through the elements of a. For convenience, we'll make ai=min(ai,m+1−ai). If the ai-th character of s is not currently A, then we should replace it. Otherwise, we replace the (m+1−ai)-th character. This is because if we have the choice between replacing two characters, replacing the one with the smaller index will result in a lexicographically smaller string. 

Alternatively, we can keep track of how many times either x or m+1−x appears in a for each 1≤x≤⌈m2⌉. 

If they appear 0 times, neither of these indices in s can become A.If they appear 1 time, it is optimal to set the x-th character to A, since this will produce a lexicographically smaller string.Otherwise, they appear at least 2 times, and it is possible to set both the x-th and (m+1−x)-th character to A.CodeProblem BSolution1706B - Making TowersWhen can two blocks of the same color form two consecutive elements of a tower? Formally, if we have two blocks of the same color at indices i and j such that i<j, how can we tell if it is possible to place them at (xi,yi) and (xi,yi+1) respectively? 

As it turns out, they can be placed like this if and only if i and j have different parities. 

First, if they have the same parity, it is impossible to place them this way. Note that xi+yi must have a different parity from xi+1+yi+1, since these sums must differ by exactly 1. So, if i and j have the same parity, then xi+yi must also have the same parity as xj+yj. But we want them to be vertically adjacent, which is not possible if their parities must be the same. So, it is impossible to make two blocks with indices of the same parity adjacent to each other. 

Next, there is a valid construction if you want to put blocks i and j together when they have different parities. Say that block i will go at position (xi,yi) and block j goes at position (xi,yi+1). If j=i+1, then we are done. Now, let's say that j=i+3. Then, we can place block i+1 at (xi+1,yi) and block j−1 at position (xi+1,yi+1). What if j=i+5? Then we can do the same as the previous case, and then put block i+2 at (xi+2,yi) and block j−2 at (xi+2,yi+1). Essentially, we are making the blocks between i and j into a horizontal line extending out for j−i−12 blocks then coming back in. 

If there are already blocks to the right of (xi,yi), then we can do the same construction but extending out to the left. Note that since we cannot move down, at least one of the right and left side must be open. 

There are two ways we can go from here: 

First, there is a DP solution. Let's imagine the naive O(n2) dp: We say that dp[i][c] is the maximum size of a tower with color c, such that the last block placed was at index i. The transitions look like this: dp[i][ci]= maxj<i,j≢i(mod2) (dp[j][ci]+1). We check all j<i such that j and i have different parities, then see if adding a block to this tower makes a better solution. To optimize it, we can notice that for the first DP dimension (index), only the parity of the index matters — for each color, we just need to keep track of the maximum dp[i][c] for even and odd i. 

We will iterate through all blocks ai, maintaining dp[p][c], which contains the maximum size of a tower with color c, where the last block included in the tower had an index with parity p (p=0 indicates an even index, p=1 indicates an odd index). If the current index is even, we set dp[0][ci]=max(dp[0][ci],dp[1][ci]+1). If it is odd, we set dp[1][ci]=max(dp[1][ci],dp[0][ci]+1). The solution runs in linear time. 

Alternatively, there's a greedy solution. After selecting a block, the next block selected must always have the opposite parity. Therefore, it makes sense to greedily select the first block of the same color with opposite parity, since it will never improve the answer if we select a later block. For each color, we start from the first block and iterate through, adding each block to the sequence if and only if it has a different parity from the last one. 

CodeProblem CSolution1706C - Qpwoeirut And The CityThe first observation to be made is that no two adjacent building can both be cool at the same time. This means that, for odd n, there must be n−12 cool buildings arranged in the following configuration... 

01010...01010(0 — normal (not cool) building, 1 — cool building)For even n, there must be n−22 cool buildings. This means that exactly one pair of adjacent buildings in the city is normal, meaning that the buildings must be arranged in one of the following configurations... 

01010...01010001010...01001001010...001010⋮010100...01010010010...01010001010...01010(0 — normal (not cool) building, 1 — cool building)For odd n, the solution is relatively simple. Just find the total floors necessary to make each of the alternating buildings (starting from the 2nd building) cool and that is the answer. 

For even n, the solution is more complex. First, find the number of floors necessary to get to the first of the configurations shown above. Then, loop through each of the subsequent configurations, each time using the previous configuration to get the number of floors necessary for the new configuration in O(1) time. This enables a solution in O(n) time. 

For example, in the 4th test case from the example in the problem statement, the possible configurations of cool buildings are... 

4 2 1 3 5 3 6 14 2 1 3 5 3 6 14 2 1 3 5 3 6 14 2 1 3 5 3 6 1(light — normal (not cool) building, bold — cool building)The number of floors necessary to reach each of these configurations are... 

1st configuration: (5 - 2) + (6 - 3) + (7 - 3) = 10.2nd configuration: 10 - (7 - 3) + (6 - 6) = 6.3rd configuration: 6 - (6 - 3) + (5 - 5) = 3.4th configuration: 3 - (5 - 2) + (4 - 1) = 3.The answer is the minimum of these values, which is 3. 

For even n, the floors necessary for every configuration can also be found in O(n) time using an alternating forward prefix sum array and an alternating backward prefix sum array. 

CodeProblem D1Solution1706D1 - Chopping Carrots (Easy Version)Let's iterate over integers v=0,1,…,a1. We'll construct an answer assuming that the minimum value of ⌊aipi ⌋ is at least v. 

For all 1≤i≤n, we set pi=min(k,⌊aiv ⌋): the maximum value pi such that 1≤pi≤k and v≤⌊aipi ⌋ (if v=0 we can just set pi=k)). 

Now, we find the value of max1≤i≤n (⌊aipi ⌋)−v. This gives the answer when the minimum value of ⌊aipi ⌋ is v. 

Finally, we compute this for all 0≤v≤a1. This gives a O(n⋅a1) time solution per test case. 

CodeProblem D2Solution1706D2 - Chopping Carrots (Hard Version)Solution 1 

Let's fix v, the minimum value of ⌊aipi ⌋. Then, for all 1≤i≤n, we find the maximum value pi such that pi≤k and ⌊aipi ⌋≥v. 

For some minimum value v, let's call the array described above P(v), and let's define M(v)= max1≤i≤n ⌊aiP(v)i ⌋. We can find the answer by taking the minimum of M(v)−v across all 0≤v≤a1, giving a O(n⋅ai) solution. 

To speed it up, let's consider how some element ai will affect the values of M(v). 

First, notice that ⌊aiq ⌋ (where 1≤q≤k) can take on at most O(min(k,√ai)) distinct values. Let's denote these values (in increasing order) s1,s2,s3,…,sx. Consider what happens when v≤s1. Then, M(v) must be at least s1. What about when s1<v≤s2? Then, M(v) must be at least s2. And so on, until sx−1<v≤sx, where M(v) must be at least sx. 

This way, we can get lower bounds on value of M(v). It is easy to see that the highest of these bounds is achievable. 

Let's iterate over array a. Let m[v] (here, m=m[0],m[1],m[2],…,m[a1] is an array of length a1+1) be the highest of lower bounds on M(v) we already found. Initially, m[v]=0 for all v. When we are dealing with ai we want to do the following: 

For all 0≤j≤x−1, we want to update m[y]=max(m[y],sj+1) for all sj+1≤y≤sj+1 (for convenience we define s0=−1).Since s0<s1<s2<…<sx, this can be done without any fancy data structures — instead of updating all these ranges directly, we can set m[sj+1]=max(m[sj+1],sj+1]), so that M(v) will be equal to max(m[0],m[1],…,m[v]). 

Then, once m is computed, we can sweep through to find all values of M(v) in with prefix maxes. 

Once we have m computed, we can find M(v)−v for all 0≤v≤a1 in linear time. This gives a O( ∑1≤i≤n min(k,√ai)+a1) solution per test case, with total O(n+maxa) memory across all tests. 

Solution 2 (AlperenT) 

Now, let's fix v as the maximum value of ⌊aipi ⌋. We now want to maximize the minimum value of ⌊aipi ⌋. 

Let's now consider all elements ai that satisfy 1≤ai≤v. For these elements, it will be optimal to set pi=1, since we want to maximize them. 

How about elements ai satisfying v+1≤ai≤2(v+1)−1? We need to have ⌊aipi ⌋≤v, so for these elements, we must have pi≥2. At the same time, we want to maximize them — so it will be optimal to set all these pi=2. 

Continuing this logic, for all integers u=1,2,…,k, we should check the elements ai satisfying (u−1)⋅(v+1)≤ai≤u⋅(v+1), and set all these pi=u. 

How can we determine the minimum value of ⌊aipi ⌋ from this? For a fixed u, the minimum ⌊aiu ⌋ will come from the minimum ai. So if we can determine the minimum ai such that (u−1)⋅(v+1)≤ai≤u⋅(v+1), and calculate these values across all u=1,2,…,k, then we will get the answer. 

To help us, let's precompute an array next1,next2,…,nextan. nextj will store the minimum value of ai such that ai≥j. Now, for a fixed u, we can check next(u−1)⋅v+1. If this value is less than or equal to u⋅v, it will be the minimum ai that we divide by u. 

Two important details: 

If there exists some ai≥(v+1)⋅k, then it is impossible to have the max element as v, and we should skip it.For some value v, we only need to check u such that (u−1)⋅v+1≤an.Using this second detail, the solution runs in O( an∑i=1 ani )=O(an⋅log(an)) time per test case. The memory usage is O(n+maxa) across all tests. 

CodeProblem ESolution1706E - Qpwoeirut and VerticesIf l=r, answer is 0. From now on we assume l<r. 

Say we have a function f(i) that tells us for some 2≤i≤n the answer for the query [i−1,i]. Then for some query [l,r], the answer will be k=max(f(l+1),f(l+2),…,f(r−1),f(r)). This is true because: 

Since all consecutive nodes are connected, the first k edges will be sufficient to connect all nodes l,l+1,…,r.Say that it is possible to connect these nodes using the first k′ edges (k′<k). We know that there is at least 1 index l+1≤i≤r such that f(i)=k. But if the answer for this query is k′, then it must be true that f(i)≤k′ (because we can reach vertex i−1 from vertex i using only the first k′ edges then). Then, we have f(i)≤k′<k=f(i), which is a contradiction.So if we precompute the values of f(i) for all 2≤i≤n, we can answer any query efficiently using a range max query structure (for example, a sparse table or segment tree). Here's how to find f(i): 

Weight the edges, so that the i-th edge has a weight i.Find the unique minimum spanning tree of this weighted graph.f(i) will be the maximum weight of an edge on the path from i−1 to i.This will always give the correct value for f(i) since edges not in the MST are useless. Let's imagine building the MST with Kruskal's: if we don't add the W-th edge, that means that the first W−1 edges are sufficient to connect uW and vW, and we can use those instead to get a better answer. 

On the resulting tree, the optimal way to connect any two nodes is to use the edges on the simple shortest path between them. Finding the max edge weight in a path on a tree can be done, for example, with binary lifting: for each node we store the maximum weight on the path to the root with length 1, 2, 4, 8, and so on. Then, we can find the max edge weight on the path from any two nodes to their LCA in O(log(n)). 

Instead of using binary lifting, we can also directly represent the MST in the DSU. After successfully merging two components rooted at u and v in the DSU, we add an edge (u,v) with the weight being the edge number from the input. f(i) will then be the maximum edge from i−1 to i in the newly constructed tree. We can just walk up the tree since the maximum depth is at most O(logn) assuming the DSU implementation uses small-to-large merging. 

This gives an O((m+q)log(n)) or O(mlog(n)+q) solution, depending on the implementation. 

Code 

Codeforces Round #809 Editorial 

By BucketPotato, history, 7 months ago, In EnglishSome stats about the roundPre-contest predictionsWho did what?SolutionsProblem ASolution1706A - Another String Minimization ProblemLet's iterate through the elements of a. For convenience, we'll make ai=min(ai,m+1−ai). If the ai-th character of s is not currently A, then we should replace it. Otherwise, we replace the (m+1−ai)-th character. This is because if we have the choice between replacing two characters, replacing the one with the smaller index will result in a lexicographically smaller string. 

Alternatively, we can keep track of how many times either x or m+1−x appears in a for each 1≤x≤⌈m2⌉. 

If they appear 0 times, neither of these indices in s can become A.If they appear 1 time, it is optimal to set the x-th character to A, since this will produce a lexicographically smaller string.Otherwise, they appear at least 2 times, and it is possible to set both the x-th and (m+1−x)-th character to A.CodeProblem BSolution1706B - Making TowersWhen can two blocks of the same color form two consecutive elements of a tower? Formally, if we have two blocks of the same color at indices i and j such that i<j, how can we tell if it is possible to place them at (xi,yi) and (xi,yi+1) respectively? 

As it turns out, they can be placed like this if and only if i and j have different parities. 

First, if they have the same parity, it is impossible to place them this way. Note that xi+yi must have a different parity from xi+1+yi+1, since these sums must differ by exactly 1. So, if i and j have the same parity, then xi+yi must also have the same parity as xj+yj. But we want them to be vertically adjacent, which is not possible if their parities must be the same. So, it is impossible to make two blocks with indices of the same parity adjacent to each other. 

Next, there is a valid construction if you want to put blocks i and j together when they have different parities. Say that block i will go at position (xi,yi) and block j goes at position (xi,yi+1). If j=i+1, then we are done. Now, let's say that j=i+3. Then, we can place block i+1 at (xi+1,yi) and block j−1 at position (xi+1,yi+1). What if j=i+5? Then we can do the same as the previous case, and then put block i+2 at (xi+2,yi) and block j−2 at (xi+2,yi+1). Essentially, we are making the blocks between i and j into a horizontal line extending out for j−i−12 blocks then coming back in. 

If there are already blocks to the right of (xi,yi), then we can do the same construction but extending out to the left. Note that since we cannot move down, at least one of the right and left side must be open. 

There are two ways we can go from here: 

First, there is a DP solution. Let's imagine the naive O(n2) dp: We say that dp[i][c] is the maximum size of a tower with color c, such that the last block placed was at index i. The transitions look like this: dp[i][ci]= maxj<i,j≢i(mod2) (dp[j][ci]+1). We check all j<i such that j and i have different parities, then see if adding a block to this tower makes a better solution. To optimize it, we can notice that for the first DP dimension (index), only the parity of the index matters — for each color, we just need to keep track of the maximum dp[i][c] for even and odd i. 

We will iterate through all blocks ai, maintaining dp[p][c], which contains the maximum size of a tower with color c, where the last block included in the tower had an index with parity p (p=0 indicates an even index, p=1 indicates an odd index). If the current index is even, we set dp[0][ci]=max(dp[0][ci],dp[1][ci]+1). If it is odd, we set dp[1][ci]=max(dp[1][ci],dp[0][ci]+1). The solution runs in linear time. 

Alternatively, there's a greedy solution. After selecting a block, the next block selected must always have the opposite parity. Therefore, it makes sense to greedily select the first block of the same color with opposite parity, since it will never improve the answer if we select a later block. For each color, we start from the first block and iterate through, adding each block to the sequence if and only if it has a different parity from the last one. 

CodeProblem CSolution1706C - Qpwoeirut And The CityThe first observation to be made is that no two adjacent building can both be cool at the same time. This means that, for odd n, there must be n−12 cool buildings arranged in the following configuration... 

01010...01010(0 — normal (not cool) building, 1 — cool building)For even n, there must be n−22 cool buildings. This means that exactly one pair of adjacent buildings in the city is normal, meaning that the buildings must be arranged in one of the following configurations... 

01010...01010001010...01001001010...001010⋮010100...01010010010...01010001010...01010(0 — normal (not cool) building, 1 — cool building)For odd n, the solution is relatively simple. Just find the total floors necessary to make each of the alternating buildings (starting from the 2nd building) cool and that is the answer. 

For even n, the solution is more complex. First, find the number of floors necessary to get to the first of the configurations shown above. Then, loop through each of the subsequent configurations, each time using the previous configuration to get the number of floors necessary for the new configuration in O(1) time. This enables a solution in O(n) time. 

For example, in the 4th test case from the example in the problem statement, the possible configurations of cool buildings are... 

4 2 1 3 5 3 6 14 2 1 3 5 3 6 14 2 1 3 5 3 6 14 2 1 3 5 3 6 1(light — normal (not cool) building, bold — cool building)The number of floors necessary to reach each of these configurations are... 

1st configuration: (5 - 2) + (6 - 3) + (7 - 3) = 10.2nd configuration: 10 - (7 - 3) + (6 - 6) = 6.3rd configuration: 6 - (6 - 3) + (5 - 5) = 3.4th configuration: 3 - (5 - 2) + (4 - 1) = 3.The answer is the minimum of these values, which is 3. 

For even n, the floors necessary for every configuration can also be found in O(n) time using an alternating forward prefix sum array and an alternating backward prefix sum array. 

CodeProblem D1Solution1706D1 - Chopping Carrots (Easy Version)Let's iterate over integers v=0,1,…,a1. We'll construct an answer assuming that the minimum value of ⌊aipi ⌋ is at least v. 

For all 1≤i≤n, we set pi=min(k,⌊aiv ⌋): the maximum value pi such that 1≤pi≤k and v≤⌊aipi ⌋ (if v=0 we can just set pi=k)). 

Now, we find the value of max1≤i≤n (⌊aipi ⌋)−v. This gives the answer when the minimum value of ⌊aipi ⌋ is v. 

Finally, we compute this for all 0≤v≤a1. This gives a O(n⋅a1) time solution per test case. 

CodeProblem D2Solution1706D2 - Chopping Carrots (Hard Version)Solution 1 

Let's fix v, the minimum value of ⌊aipi ⌋. Then, for all 1≤i≤n, we find the maximum value pi such that pi≤k and ⌊aipi ⌋≥v. 

For some minimum value v, let's call the array described above P(v), and let's define M(v)= max1≤i≤n ⌊aiP(v)i ⌋. We can find the answer by taking the minimum of M(v)−v across all 0≤v≤a1, giving a O(n⋅ai) solution. 

To speed it up, let's consider how some element ai will affect the values of M(v). 

First, notice that ⌊aiq ⌋ (where 1≤q≤k) can take on at most O(min(k,√ai)) distinct values. Let's denote these values (in increasing order) s1,s2,s3,…,sx. Consider what happens when v≤s1. Then, M(v) must be at least s1. What about when s1<v≤s2? Then, M(v) must be at least s2. And so on, until sx−1<v≤sx, where M(v) must be at least sx. 

This way, we can get lower bounds on value of M(v). It is easy to see that the highest of these bounds is achievable. 

Let's iterate over array a. Let m[v] (here, m=m[0],m[1],m[2],…,m[a1] is an array of length a1+1) be the highest of lower bounds on M(v) we already found. Initially, m[v]=0 for all v. When we are dealing with ai we want to do the following: 

For all 0≤j≤x−1, we want to update m[y]=max(m[y],sj+1) for all sj+1≤y≤sj+1 (for convenience we define s0=−1).Since s0<s1<s2<…<sx, this can be done without any fancy data structures — instead of updating all these ranges directly, we can set m[sj+1]=max(m[sj+1],sj+1]), so that M(v) will be equal to max(m[0],m[1],…,m[v]). 

Then, once m is computed, we can sweep through to find all values of M(v) in with prefix maxes. 

Once we have m computed, we can find M(v)−v for all 0≤v≤a1 in linear time. This gives a O( ∑1≤i≤n min(k,√ai)+a1) solution per test case, with total O(n+maxa) memory across all tests. 

Solution 2 (AlperenT) 

Now, let's fix v as the maximum value of ⌊aipi ⌋. We now want to maximize the minimum value of ⌊aipi ⌋. 

Let's now consider all elements ai that satisfy 1≤ai≤v. For these elements, it will be optimal to set pi=1, since we want to maximize them. 

How about elements ai satisfying v+1≤ai≤2(v+1)−1? We need to have ⌊aipi ⌋≤v, so for these elements, we must have pi≥2. At the same time, we want to maximize them — so it will be optimal to set all these pi=2. 

Continuing this logic, for all integers u=1,2,…,k, we should check the elements ai satisfying (u−1)⋅(v+1)≤ai≤u⋅(v+1), and set all these pi=u. 

How can we determine the minimum value of ⌊aipi ⌋ from this? For a fixed u, the minimum ⌊aiu ⌋ will come from the minimum ai. So if we can determine the minimum ai such that (u−1)⋅(v+1)≤ai≤u⋅(v+1), and calculate these values across all u=1,2,…,k, then we will get the answer. 

To help us, let's precompute an array next1,next2,…,nextan. nextj will store the minimum value of ai such that ai≥j. Now, for a fixed u, we can check next(u−1)⋅v+1. If this value is less than or equal to u⋅v, it will be the minimum ai that we divide by u. 

Two important details: 

If there exists some ai≥(v+1)⋅k, then it is impossible to have the max element as v, and we should skip it.For some value v, we only need to check u such that (u−1)⋅v+1≤an.Using this second detail, the solution runs in O( an∑i=1 ani )=O(an⋅log(an)) time per test case. The memory usage is O(n+maxa) across all tests. 

CodeProblem ESolution1706E - Qpwoeirut and VerticesIf l=r, answer is 0. From now on we assume l<r. 

Say we have a function f(i) that tells us for some 2≤i≤n the answer for the query [i−1,i]. Then for some query [l,r], the answer will be k=max(f(l+1),f(l+2),…,f(r−1),f(r)). This is true because: 

Since all consecutive nodes are connected, the first k edges will be sufficient to connect all nodes l,l+1,…,r.Say that it is possible to connect these nodes using the first k′ edges (k′<k). We know that there is at least 1 index l+1≤i≤r such that f(i)=k. But if the answer for this query is k′, then it must be true that f(i)≤k′ (because we can reach vertex i−1 from vertex i using only the first k′ edges then). Then, we have f(i)≤k′<k=f(i), which is a contradiction.So if we precompute the values of f(i) for all 2≤i≤n, we can answer any query efficiently using a range max query structure (for example, a sparse table or segment tree). Here's how to find f(i): 

Weight the edges, so that the i-th edge has a weight i.Find the unique minimum spanning tree of this weighted graph.f(i) will be the maximum weight of an edge on the path from i−1 to i.This will always give the correct value for f(i) since edges not in the MST are useless. Let's imagine building the MST with Kruskal's: if we don't add the W-th edge, that means that the first W−1 edges are sufficient to connect uW and vW, and we can use those instead to get a better answer. 

On the resulting tree, the optimal way to connect any two nodes is to use the edges on the simple shortest path between them. Finding the max edge weight in a path on a tree can be done, for example, with binary lifting: for each node we store the maximum weight on the path to the root with length 1, 2, 4, 8, and so on. Then, we can find the max edge weight on the path from any two nodes to their LCA in O(log(n)). 

Instead of using binary lifting, we can also directly represent the MST in the DSU. After successfully merging two components rooted at u and v in the DSU, we add an edge (u,v) with the weight being the edge number from the input. f(i) will then be the maximum edge from i−1 to i in the newly constructed tree. We can just walk up the tree since the maximum depth is at most O(logn) assuming the DSU implementation uses small-to-large merging. 

This gives an O((m+q)log(n)) or O(mlog(n)+q) solution, depending on the implementation. 

Code 

Codeforces Round #807 (Div 2.) Editorial 

By MarkBcc168, history, 7 months ago, In EnglishThanks for participating. We apologize for problem F that has appeared before. Still, we hope you all enjoy our round! 

1705A - Фотограф МаркAuthor: MarkBcc168 

Hint 1Hint 2TutorialWe have a very explicit description of whether the arrangement is possible. Sort the heights so that h1≤h2≤⋯≤h2n. Then, there exists such arrangement if and only if all the following conditions hold. 

hn+1−h1	≥xhn+2−h2	≥x⋮h2n−hn	≥x We present two proofs. 

Proof 1 (Direct Proof). Suppose that the arrangement is possible. We will show that for each i, we have hn+i−hi≥x. 

To do so, note that n+1 people who have height in [hi,hn+i]. It's impossible that these n+1 people got assigned to different columns (because there are n columns), so there exist two people that got assigned to the same column. 

However, because these two people have height in [hi,hn+i], the difference in heights between these two people is at most hn+i−hi. As the difference is at least x by the arrangement, we must have that hn+i−hi≥x. ◼Proof 2 (Exchange Argument). First, we look at two pairs. Suppose that the i-th person in the first and second row have heights a<b, while the j-th person in the first and second row have heights c<d. 

…	a	…	c	……	b	…	d	… Assume that b≥c, then we switch b,c. The arrangement still works since a−c≥a−b≥x and b−d≥c−d≥x.Similarly, a≥d yields a switch.Thus, we can keep exchanging until anyone in the first row is at least as tall as anyone in the second row. Thus, the first row must be hn+1,hn+2,…,h2n, while the second row must be h1,h2,…,hn in some order. 

Now, we look at the same picture again. Assume that a≥c but b≤d. then, we can switch b,d, and it still works because a−d≥c−d≥x and c−b≥c−d≥x. Thus, we can switch the second row until it matches the order of the first row. 

Therefore, we force the first row to be hn+1,hn+2,…,h2n, while the second row must be h1,h2,…,hn in that order. This implies the conclusion. ◼Time Complexity: O(nlogn) for sorting. 

Code1705B - Марк-уборщикAuthor: MarkBcc168 

HintTutorialDelete the leading zeroes in the array a (i.e., the first t numbers of a that are zero) so that now a1≠0. Let k be the number of 0's in a1,a2,…,an−1. The answer is 

(a1+a2+⋯+an−1)+k.To see why, let Mark keep filling the holes (rooms with dust level 0) first by subtracting the first nonzero index and changing the first zero index to 1. This takes k moves to fill all zeroes in a1,a2,…,an−1. Then, we can start moving, from left to right, all dust to the n-th room, taking a1+a2+⋯+an−1 moves. 

Finally, we argue that this is the minimum number of moves. To that end, we prove that each move decreases the answer by at most 1. We consider two cases. 

If a move has j=n, then it decreases a1+a2+⋯+an−1 by 1 but does not decrease k.If j≠n, then the move doesn't decrease a1+a2+⋯+an−1 and decreases k by at most 1.Thus, we are done. The time complexity is O(n). 

Code1705C - Марк и неоконченное эссеAuthor: MarkBcc168 

Hint 1Hint 2Hint 3TutorialThis is an implementation problem. What you need to do is after the i-th copying operation, we need to keep track of the beginning point ai and the ending point bi of the appended string. Moreover, we also keep track the subtraction distance ti=ai−li so that for k∈[ai,bi], the k-th letter is the same as the (k−ti)-th letter. Thus, we have recursed the position to the smaller position k−ti, so we keep doing that until we reach the initial string. 

Therefore, to solve this problem, we iterate from i=c,c−1,…,1. If k is in [ai,bi], subtract k by ti. After all operations, k should be at the inital string, and we output the k-th letter. 

The time complexity of this solution is O(cq). However, less efficient solutions of O((clogc)q) (using binary search each time) or O(c2q) (by going through all intervals in each iteration) pass as well. 

Code1705D - Марк и лампочкиAuthor: MarkBcc168 

Hint 1Hint 2Hint 3TutorialAs explained in the sample explanations, the operation cannot change the first or the last bit. Thus, if either s1≠t1 or sn≠tn, simply return -1. 

Now, the key idea is to consider a binary ¯s =(s1⊕s2)(s2⊕s3)…(sn−1⊕sn) of length n−1, where a⊕b denotes the XOR operation of bits a and b. Then, it's easy to verify that the operation acts on ¯s by just swapping two different bits. An example is shown below 

s	 ¯s 000101	00111↓	↓001101	01011↓	↓011101	10011↓	↓011001	10101↓	↓011011	10110↓	↓010011	11010 Thus, the operation is possible if and only if ¯s and ¯t has the same number of 1's. Moreover, if a1,a2,…,ak are the positions of 1's in ¯s and b1,b2,…,bk are the positions of 1's in ¯t . Then, the minimum number of moves is given by 

|a1−b1|+|a2−b2|+⋯+|ak−bk|,which can be evaluated in O(n). 

This is a well-known fact, but for completeness, here is the proof. Note that the operation is moving 1 to left or right by one position. Thus, to achieve that number of moves, simply move the first 1 from a1 to b1, move the second 1 from a2 to b2, …, and move the k-th 1 from ak to bk. For the lower bound, notice that the i-th 1 cannot move past the (i−1)-th or (i+1)-th 1. Thus, it takes at least |ai−bi| moves to move the i-th 1 from ai to bi. Summing gives the conclusion. 

Note that another way to think about this problem is to look at the block of 1's and 0's and notice that the number of blocks remains constant. This is more or less the same as the above solution. 

Code1705E - Марк и профессор КороAuthor: abc241 

Hint 1Hint 2Hint 3Hint 4TutorialThe key observation is the following. 

Claim: The answer is ⌊log2(2a1+2a2+⋯+2an)⌋.Proof: The upper bound is pretty clear, as the operation doesn't change the ∑2ai. Moreover, the sum must be at least 2ans, giving the result. 

For the construction, let Mark keep performing the operation until he cannot. At this point, all numbers must be distinct, and the ∑2ai is unchanged. Let the current numbers on the board be b1<b2<⋯<bk. Then, 

∑ni=12ai=2b1+2b2+⋯+2bk≤21+22+⋯+2bk<2bk+1.Thus, Mark can make the final number be bk=⌊log2(2a1+2a2+⋯+2an)⌋ as desired. ◼Finally, we need a data structure to maintain the ∑2ai and simulate base 2 addition. There are many ways to proceed, including the following: 

Using bitsets, partition the bits into many chunks of w bits (w between 50 and 64 is fine). This gives O(n2/w) complexity, but its low constant factor makes it enough to pass comfortably. 

Use lazy segment augmented with O(logn) binary search. For each bit added, find where the longest streak of 1's to the left of that bit ends, and update accordingly. Similarly, for each bit subtracted, find where the longest streak of 0's to the left of that bit ends, and update accordingly. The total complexity is O(nlogn). 

Code (Bitsets, by errorgorn)Code (Lazy Segment)1705F - Марк и онлайн-экзаменAuthor: MarkBcc168 

Unfortunately, a harder version of this problem has appeared in a Chinese contest here and here. You can look at their solution here. We thank many contestants who pointed it out. 

Hint 0Hint 1Hint 2Hint 3Hint 4TutorialThere are many possible approaches, including using randomized algorithms. However, I will present the solution that takes about 2n3 queries deterministically. 

We pre-query TTT...T and TFTF...TF. Then, for i=1,2,…,⌊n3 ⌋, we take the difference when both the (2i−1)-th and the 2i-th question in TTT...T is changed to F. 

If the difference is +2, then both answers must be F.If the difference is −2, then both answers must be T.Else, the answers must be TF or FT in some order.Now, here is the key idea: if the last case happens, then we can figure out if it's TF or FT as well as the answer to one more question in one query. To do so, compare the previous TFTF...TF with a new query that has 3 differences: 

TFTF…TF…T…TFTFTF…FT…F…TF (Note: we assume that the third question corresponds to T in the query. If it's F, just change to T and proceed analogously.) 

There are four possible scenarios. 

If the answers are TF and T, then the difference is −3.If the answers are TF and F, then the difference is −1.If the answers are FT and T, then the difference is +1.If the answers are FT and F, then the difference is +3.Therefore, we can distinguish these four scenarios in one go. 

Finally, if the first two cases happen, we can easily figure out the answer to one more question in one query (say, by changing that question to F and compare with the TT...T query). Either way, we can deduce the answer to 3 questions in 2 queries, leading to a solution with 2n3 queries. 

Note that this solution can be easily improved to 3n5 on average by randomly shuffling the questions. 

Code 

Codeforces Round #806 (Div. 4) Editorial 

By flamestorm, 8 months ago, In EnglishThanks for participating! 

1703A - YES or YES? 

Idea: flamestorm 

Tutorial1703A - YES or YES?You should implement what is written in the statement. Here are three ways to do it: 

Check that the first character is Y or y, check that the second character is E or e, and check the third character is S or s.Make an array storing all acceptable strings (there are only 8), and loop and see if any of the strings match the input.Use some built-in function like tolower() in C++ to make the string all lowercase, and check if s is equal to yes.The complexity is O(1) per test case.Solution1703B - ICPC Balloons 

Idea: flamestorm 

Tutorial1703B - ICPC BalloonsLet's keep an array a of booleans, ai denoting whether or not some team has solved the ith problem already. Now we can iterate through the string from left to right and keep a running total tot. If ai is true (the i-th problem has already been solved), increase tot by 1; otherwise, increase tot by 2 and set ai to true. 

The time complexity is O(n). 

Bonus: the answer is always n+number of distinct characters in s. Can you see why? 

Solution1703C - Cypher 

Idea: mesanu 

Tutorial1703C - CypherWe will perform each move in reverse from the final sequence of the cypher. 

down move: it increases the i-th digit by 1. After applying the up move on 9, it becomes 0.up move (denoted by D): it decreases the i-th digit by 1. After applying the down move on 0, it becomes 9.Now we just need to implement the two types of moves. The time complexity is O(n+∑ai) per test case.Solution1703D - Double Strings 

Idea: MikeMirzayanov 

Tutorial1703D - Double StringsUse some data structure that allows you to answer queries of the form: "does the string t appear in the array s1,…,sn?" For example, in C++ you can use a map<string, bool>, while in Python you can use a dictionary dict. 

Afterwards, for each string s, brute force all strings x and y such that s=x+y. There are at most 7 such strings, because s has length at most 8. Then check if both x and y appear in the array using your data structure. 

The time complexity is O(ℓnlogn) per test case, where ℓ is the maximum length of an input string. 

Solution1703E - Mirror Grid 

Idea: mesanu 

Tutorial1703E - Mirror GridLet's rotate the grid by 0∘, 90∘, 180∘, and 270∘, and mark all cells that map to each other under these rotations. For example, for 4×4 and 5×5 grids, mirror grid must have the following patterns, the same letters denoting equal values: 

acbabddccddbabcaadcbabefedcfgfcdefebabcdaIn general, we can rotate the grid by 0∘, 90∘, 180∘, and 270∘ and see which cells need to have equal values by seeing the positions which each cell maps to. 

Now to solve the problem, we consider each equal value (each of the letters a, b, c, ... in the above figures) independently, and consider the minimum number of moves to make them all 0 or all 1. The answer is the total across all values. See the implementation for better understanding. 

The time complexity is O(n2) per testcase. 

Solution1703F - Yet Another Problem About Pairs Satisfying an Inequality 

Idea: flamestorm 

Tutorial1703F - Yet Another Problem About Pairs Satisfying an InequalityCall a pair good if it satisfies the condition. Let's split the inequality into three parts: ai<i, i<aj, aj<j. 

Note that if ai≥i for any i, then it can't be an element of a good pair, because it fails the first and third conditions. So we can throw out all elements of the array satisfying ai≥i. 

For the remaining elements, the first and third inequalities are already satisfied, so we only have to count the number of pairs (i,j) with i<aj. Let's iterate j through the array from the left to the right, and make a list storing all i that appear before j. Then for each j, count the number of i less than aj by binary searching on the number of elements in the list less than aj. Afterwards, add j to the end of the list. 

Since we iterate from left to right, the list will always remain sorted (we insert the indices of elements, which are increasing from left to right), so the binary search will always work. 

The time complexity is O(nlogn). 

Solution1703G - Good Key, Bad Key 

Idea: mesanu 

Tutorial1703G - Good Key, Bad KeyWe will prove it is always optimal to use good keys for a prefix then only use bad keys. Consider we have used a bad key then a good key, by doing this we obtain ⌊ai2⌋+⌊ai+12⌋−k coins. If we switch and use a good key first, the a bad key then we obtain ai+⌊ai+12⌋−k, this number is clearly bigger so we will never encounter a bad key before a good key in an optimal solution, thus we will use a prefix of good keys then move on to using bad keys. 

For every possible prefix of good keys we will calculate the coins we get at the end. We do this by maintaining a variable with the prefix sum where we use the good keys and then calculate what we will get from the chests where we use bad keys. Notice that because we halve all the chests when we use a bad key we only need to verify the next log2(109)≈30 chests, all chests after it will go to 0 coins. 

Final complexity: O(nlogai). 

Solution 

Codeforces Round #805 (Div. 3) Editorial 

By Vladosiya, history, 8 months ago, translation, In English1702A - Round Down the Price 

Idea: MikeMirzayanov 

Tutorial1702A - Round Down the PriceNote that the number m and the nearest round number not exceeding m have the same size (consist of the same number of digits in the record). Denote the size of m by len. Then we can construct the nearest round number. It will consist of one and len−1 zeros. 

Solution1702B - Polycarp Writes a String from Memory 

Idea: MikeMirzayanov 

Tutorial1702B - Polycarp Writes a String from MemoryLet us simulate the process. We store a set v consisting of letters that Polycarp memorizes on one day. Gradually dial the set s. If the size of v exceeds 3, we add 1 to the day counter ans and clear v. 

Solution1702C - Train and Queries 

Idea: MikeMirzayanov 

Tutorial1702C - Train and QueriesTo solve the problem, we will use the dictionary. Each station will be matched with a pair of integers — the indices of its first and last entries in the route. Then we will sequentially process queries. If at least one of the stations aj or bj is missing in the dictionary — the answer is NO. Otherwise, check: 

If the index of the first entry of station aj in the route is strictly less than the index of the last entry of station bj in the route — the answer is YES.Otherwise, the answer is NO.Solution1702D - Not a Cheap String 

Idea: MikeMirzayanov 

Tutorial1702D - Not a Cheap StringThe main idea is that it is always better to remove the most expensive symbol. To do this quickly, we will count all the symbols and remove them from the most expensive to the cheapest, counting how many times we have removed each. During the output, we will skip the characters the number of times that we deleted. 

Solution1702E - Split Into Two Sets 

Idea: MikeMirzayanov 

Tutorial1702E - Split Into Two SetsPolycarp has n dominoes, on each domino there are 2 numbers — it turns out, there will be 2n numbers in total. 

We need to divide 2n numbers (each number from 1 to n) into two sets so that all numbers in each set are different — each set will consist of n numbers. It turns out that all numbers from 1 to n must occur exactly 2 times, no more and no less. 

Let's imagine it all as a bipartite graph, where there are vertices from 1 to n, and dominoes are edges. Since each number occurs exactly 2 times, then we have a lot of cycles. In which the edges of each number must be included in different sets, in other words, the cycles must be of even length. 

This can be checked in O(n) by a simple enumeration. 

Solution1702F - Equate Multisets 

Idea: MikeMirzayanov 

Tutorial1702F - Equate MultisetsWe divide each number from the multiset a by 2 as long as it is divisible without a remainder. Because if we can get a new number from the multiset a, we can also increase it to the original number by multiplication by 2. 

Now notice that it does not make sense to use the first operation (multiplication by 2), because we get an even number, and only odd numbers remain in the multiset a. 

Then we take the largest number from b and if it is in a, we remove this number from both multisets. Otherwise, we use the second operation, if the number is greater than 1. If it is equal to 1, then it is impossible to equalize the multisets a and b. 

Solution1702G1 - Passable Paths (easy version) 

Idea: MikeMirzayanov 

Tutorial1702G1 - Passable Paths (easy version)If the answer is YES, then we can choose a subset of the tree vertices forming a simple path and containing all the vertices of our set. Let's choose the minimum possible path, its ends — vertices from the set. The constraints allow us to answer the query in O(n), hang the tree by one of the ends and check if it is true that there is only one selected vertex that does not have any selected ones in the subtree, if there is one such vertex, then it is — the second end. To make it easier to search for one of the ends, we will hang the tree by any vertex before the queries, calculate their depths and take the deepest of the set. 

Solution1702G2 - Passable Paths (hard version) 

Idea: MikeMirzayanov 

Tutorial1702G2 - Passable Paths (hard version)Recall that the path in the rooted tree — ascends from one end to the least common ancestor (lca) of the ends and descends to the other end (possibly by 0). Then our set is divided into two simple ways. 

To check this, you only need to count lca. 

We will first calculate the depths, as for solving an easy version of the problem. We will go along the vertices according to the non-growth of the depths, if lca of the deepest vertex and the current one is equal to the current one, then it is the ancestor of the deepest one, we will mark it. Next, we will find the deepest unmarked vertex and do the same, if there is no such vertex, then the whole path goes down and the answer is YES. 

If there are unmarked vertices, then there are vertices outside of those two ascents and the answer is NO. Now we need to check that the two ascents do not intersect or intersect only at the lca of ends, for this we just make sure that lca is not deeper than the shallowest vertex of the set. 

Solution 

Codeforces Round #804 (Div. 2) Editorial Reupload 

By Gheal, history, 4 months ago, In EnglishThe original blog was deleted yesterday by one of the other authors. We are very sorry about this. 

A — The Third Three Number ProblemAuthors: antontrygubO_o, Gheal 

HintsSolutionFirst and foremost, it can be proven that (a⊕b)+(b⊕c)+(a⊕c) is always even, for all possible non-negative values of a, b and c. 

ProofTherefore, if n is even, one possible solution is a=0, b=0 and c=n2. In this case, (a⊕b)+(b⊕c)+(a⊕c)=0+n2+n2=n. Otherwise, there are no solutions. 

Time complexity per testcase: O(1). 

Code (C++)Rate ProblemPost ScriptumB — Almost Ternary MatrixAuthor: Gheal 

SolutionThe general construction consists of a 2×2 checkerboard with a 1-thick border. Here is the intended solution for n=6 and m=8: 



Time complexity per testcase: O(nm). 

Code (C++)Rate ProblemC — The Third ProblemAuthor: Gheal 

HintsSolutionLet p[x] be the position of x in permutation a. 

Since MEX([ap[0]])=1, the only possible position of 0 in permutation b is exactly p[0]. 

Without loss of generality, we will assume that p[0]<p[1]. For every interval [l,r] (l≤p[0]<p[1]≤r), MEX([bl,…,br]) must be at least 2. For every other interval, MEX([bl,…,br]) cannot exceed 2. The only position for 1 which satisfies both of these constraints is exactly p[1]. 

Let's consider the current interval [l,r] as being [p[0],p[1]]. 

If p[2]∈[l,r], we can say that, for every interval [x,y] (x≤l<r≤y), MEX([bx,…,by]) must be at least 3. Similarly, for every other interval, MEX([bx,…,by]) cannot exceed 3. Both of these constraints are only met if 2 occurs in permutation b on some position p∈[l,r]. Since only 2 positions are currently occupied in [l,r], the total number of similar permutations will be multiplied by (r−l+1)−2. 

Otherwise, 2 can be placed in permutation b only on p[2]. Additionally, the current interval will be "extended" to include p[2], resuting in either [p[2],r] or [l,p[2]]. 

After processing 0,1,…,k−2 and k−1, the algorithm for processing k is very similar to the one presented earlier. If p[k]∈[l,r], the answer gets multiplied by (r−l+1)−k. Otherwise, the current interval is extended to include p[k]. 

Time complexity per testcase: O(n)Code (C++)Rate ProblemD — Almost Triple DeletionsAuthors: Gheal 

HintsSolutionLemma: An array a1,a2,…,an can be fully deleted via a sequence of operations if and only if it satisfies both of the following constraints: 

n is even 

The maximum frequency of any element in the array is at most n2. 

ProofSince the maximum frequency of a value for every subarray [al,al+1,…,ar] can be computed in O(n2), it is possible to precompute all subarrays which can be deleted via a sequence of operations. 

Let dp[i] be the maximum length of a final array consisting of ai and some subsequence from the first i−1 elements. Initially, dp[i] is set to 1 if the prefix [a1,a2,…,ai−1] can be fully deleted. Otherwise, dp[i]=0. 

For every pair of indices i and j (1≤j<i≤n,ai=aj), if we can fully delete the subarray [aj+1,aj+2,…ai−1], then we can append ai to any final array ending in aj. Naturally, dp[i] will be strictly greater than dp[j]. This gives us the following recurrence: 

dp[i]=maxi−1j=1(dp[j]>0 and ai=aj and [aj+1,aj+2,…,ai−1] is deletable)⋅(dp[j]+1)If we define a final array as a subsequence of equal elements from the array a, to which an+1 is forcefully appended, then the final answer can be written as dp[n+1]−1. Note that, when computing dp[n+1], aj should not be compared to an+1. 

Total time complexity per testcase: O(n2). 

Code (C++)Rate ProblemE — Three Days GraceAuthor: tibinyte 

SolutionWe can see that in the final multiset, each number Ai from the initial multiset will be assigned to a subset of values x1,x2,....,xk such that their product is Ai. Every such multiset can be created. Also let vmax be the maximum value in the initial multiset. 

Consider iterating through the minimum value. To get the best maximum value that has this minimum we fixed, one can use dynamic programming dp[i][j]=the best possible maximum if we had number i and the minimum value in the product is j, j is a divisor of i. This dp can be calculated in O(vmax⋅log2(vmax)) for all values. We can also process all updates when incrementing the minimum and keeping the result with a total effort of O(vmax⋅log2(vmax)). Thus we have a total time complexity of O(vmax⋅log2(vmax)). However, this ( we hope ) won't pass. 

Here is a way more elegant solution ( thanks to valeriu ): 

To get things straight, we observe that when we decompose a number, we just actually write it as a product of numbers. We still consider fixing the minimum value used in our multiset, call it L. We will further consider that we iterate L from the greatest possible value (i.e. vmax) to 1, and as such, we try at each iteration to calculate the minimum possible value which will appear in any decomposition as the maximum value in said decomposition. 

We shall now retain for each element the minimal maximum value in a decomposition where the minimum of that decomposition is L, let's say for element i, this value will be stored in dp[i]. Naturally, after calculating this value for every number, we now try to tweak the calculated values as to match the fact that, after this iteration concluded, we will decrease L. For further simplicity, we denote L′=L−1. 

So, we changed the minimum value allowed. What changes now? Well, it is easy to see that any element that is not divisible by L′ won't be affected by this modification, as much as it is impossible to include L′ in any decomposition of said number. So it remains to modify the multiples of L′. Let's take a such number, M. How can we modify dp[M]? Well, we can include L′ in the decomposition as many times as we want, and then when we decide to stop including it, we remain with a number which needs to be further decomposed. The attributed maximum of this value should already be calculated, so we can consider it as a new candidate for the update of dp[M]. This idea could be implemented simpler by going through multiples of L′, and for an element, updating dp[i] with dp[i/L′] (by taking the minimum of either) 

We now need for each iteration to keep track of the attributed maximums of each element that actually appears in our initial list. This can be done by keeping a frequency of all these elements, and after all updates, taking the (already known) maximum of the previous iteration and decreasing it until we find another element that actually appears in our set (this can be verified by simply checking the frequency). This is correct, as much as all the values gradually decrease as L decreases, so their maximum would have to decrease as well. 

Final time complexity: O(vmax∗log(vmax))Code (C++)Rate Problem 

Codeforces Round #803 (Div. 2) Editorial 

By flamestorm, 8 months ago, In EnglishThank you for participating in our contest! We hope you enjoyed it. 

1698A - XOR Mixup 

HintSolution1698A - XOR MixupAny element of the array works. Let's use ⊕ for XOR. 

Suppose that the original array is [a1,…,an−1]. Then x=a1⊕⋯⊕an−1. 

Let's show that a1 is the XOR of all other elements of the array; that is, a1=a2⊕⋯⊕an−1⊕x. Substituting x=a1⊕⋯⊕an−1, we havea1=a2⊕⋯⊕an−1⊕a2⊕⋯⊕an−1.There are two occurences of a2,…,an on the right-hand side and only one occurrence of a1. Since y⊕y=0 for all y, the a2,…,an−1 all cancel out, leaving only a1. 

More formally, we can write the following.a1=?a2⊕⋯⊕an−1⊕x=a2⊕⋯⊕an−1⊕(a1⊕⋯⊕an−1)=a2⊕⋯⊕an−1⊕(a1⊕a2⊕⋯⊕an−1)=(a2⊕⋯⊕an−1)⊕a1⊕(a2⊕⋯⊕an−1)=a1⊕(a2⊕⋯⊕an−1)⊕(a2⊕⋯⊕an−1)=a1.The same proof follows for any ai. Hence you can output any element of the array. 

The time complexity is O(n). 

Implementation (C++)Implementation (Python)1698B - Rising Sand 

HintSolution1698B - Rising SandNote that two piles in a row can't be too tall, since a pile that is too tall has strictly more sand than its neighbours. 

If k=1 then we can make every other pile too tall, excluding the ends of the array. For example, if a=[1,2,3,4,5,6], we can make piles 2 and 4 too tall by performing some large number of operations on them (say, by making it into [1,10100,3,10100,5,6].) The answer is ⌊n−12⌋. 

If k≥2, then note that for any pile, if we perform the operation on it then we perform on one of its neighbours as well. Therefore, if the pile is not too tall initially, then it will never become too tall as a result of these operations, since both a pile and at least one of its neighbours will gain sand. So in this case, doing operations never improves the answer, and so the answer is the number of too tall piles initially. 

The time complexity is O(n). 

Implementation (C++)Implementation (Python)1698C - 3SUM Closure 

HintSolution1698C - 3SUM ClosureLet's consider some array which is 3SUM-closed. 

If the array has at least three positive elements, consider the largest three x, y, and z. Notice that x+y+z is strictly larger than x, y, and z, which means that x+y+z is not an element of the array (since x, y, z were the largest elements). Therefore the array has ≤2 positive elements. 

Similarly, if the array has at least three negative elements, consider the smallest three x, y, and z. Notice that x+y+z is strictly smaller than x, y, and z, which means that x+y+z is not an element of the array (since x, y, z were the smallest elements). Therefore the array has ≤2 negative elements. 

Finally, note that there is no point in having more than 2 zeroes in the array, since any additional zeroes won't change the sums that can be formed. So if there are more than 2 zeroes, we can remove them until there are exactly 2. 

It follows that the resulting array has at most 2+2+2=6 elements. This is small, so we can brute force the condition in the problem in O(64) or O(63) time. 

The time complexity is O(n+64) or O(n+63), depending on the implementation. 

Implementation (C++)1698D - Fixed Point Guessing 

HintSolution1698D - Fixed Point GuessingNote that ⌈log2104⌉=14, which is less than the number of queries. If we can answer a question of the form "given a subarray, does it contain the fixed point?", then we can binary search on this subarray until we find the fixed point. 

Given a subarray [al,…,ar], let's count the number of ai such that l≤ai≤r. We claim that if this count is odd, then the subarray contains the fixed point; otherwise, it does not. 

First, let's show that each swapped pair either increases the count by 0 or by 2. Suppose that x↔y are swapped (that is, ax=y and ay=x). If ax is in the range from l to r, then l≤y≤r (since ax=y), so ay is also in the range from l to r. Similarly, if ax is not in the range, then neither is ay. So this pair either increases the count by 0 or 2. 

Contrarily, the fixed point increases the count by 0 if it is not in the range and 1 if it is. So we can simply look at the parity of the number of elements satisfying the condition, and run our binary search. 

The time complexity is O(n). 

Implementation (C++)Implementation (Python)1698E - PermutationForces II 

Hint 1Hint 2Hint 3Solution1698E - PermutationForces IISuppose that we know the elements of b. We claim that the minimum strength needed is maxni=1ai−bi. Let's prove it. 

Proof. For simplicity let's sort the elements of b from 1 to n, and rearrange the corresponding elements of a in the same way. In other words, we only need to turn this new array a into the identity [1,2,…,n]. 

First note that on the i-th operation, we need to move the number i to the correct position. This is because of the format of the operations; in any future operation, i will not be in the given range, so it is required to move i in the current operation. 

Let's look at the number 1. If a1=1, then we don't need any strength. Otherwise, we need ai−1 strength to swap 1 and ai. Afterwards, we can essentially ignore 1 for the rest of the operations, since there is no need to move it again. 

In general, there are two cases for when we need to move i to its correct place: 

ai≥i. In this case, we'll never move ai until the i-th operation, where we swap i and ai. We need a strength of ai−i for that. This is necessary.ai<i. In this case, we will swap ai in an earlier operation (since ai<i, so we must swap it to its correct place in the ai-th operation). If we again end up with some smaller number, we will need to swap that before i, and so on.Suppose that after some time, the current element ai in the i-th position is at least i. Then this element must have been swapped with some other element smaller than i (since we only perform swaps with elements smaller than i before the i-th operation). In particular, this element originally started somewhere to the left of i, say at position j<i. Then in the strength calculation, we counted ai−j, which is more than ai−i, i.e. more than we actually need to swap i and ai. This is sufficient. 

Hence we only need to check the inequality s≥ai−bi for all i. Now we proceed to the counting part. 

Rewrite this as ai−s≤bi. Suppose that k values of bi are missing. Call them [m1,…,mk] in increasing order. Then note that if some element of m satisfies this inequality, all larger elements of m will. In other words, for each ai whose corresponding element of b is missing, some suffix of [m1,…,mk] will work. We can simply binary search to find this suffix for each ai. Let li denote the length of this suffix. 

Afterwards, we need to count the number of ways to assign each missing element to an ai. Process the elements greedily, from the ai with the fewest choices to the one with the most (that is, the largest ai to the smallest). The first ai has li choices, the second li−1 (one element of m was already taken), the third li−2, and so on. We can compute this product straightforwardly. 

The time complexity is O(nlogn). 

Implementation (C++)1698F - Equal Reversal 

HintSolution1698F - Equal ReversalConsider the following invariants of the array: 

a1 and an don't change as a result of the operations.The set of unordered pairs of adjacent elements doesn't change as a result of the operations. In other words, if you build a graph G whose vertices are labelled 1 to n, and make an edge connecting ai and ai+1 for all 1≤i<n, the graph does not change after operations. This is because the operation can be seen as reversing the order we traverse a cycle in G, which doesn't change the undirected graph.It turns out that these conditions are necessary and sufficient to determine if a can be turned into b. Let's prove it by fixing the elements of a one at a time.The first element of a already has to match. Suppose the second element does not match; that is, a1=b1 but a2≠b2. Then there has to be some other copy of b1 later in a next to the element in a equal to b2, by the graph condition mentioned above. If the copy of b1 appears after the element equal to b2, we can reverse the subarray whose endpoints are the two copies of b1. Otherwise, it can be shown that there must exist some subarray with equal endpoints that contains b1 followed by b2, so we can reverse it. 

This takes 2n operations, but it requires O(n2) time to construct. So the overall complexity is O(n3). 

Implementation (C++)1698G - Long Binary String 

HintSolution1698G - Long Binary StringIgnore leading zeroes of s. We can add them back at the end. 

Let's view the string as a polynomial P(x) in GF(2). Then in an operation we can multiply P(x) by any monomial xk for some k, so after some number of operations we can multiply P(x) by some other polynomial Q(x). 

At the end, we have a string with two flipped bits. We can in fact make the first character equal to 1 by finding the smallest k such that P(x)Q(x)=xk+1. Such a k exists, because the constant term of P is 1 and Q is arbitrary. Rewrite this as xk≡1(modP(x)). Now it's clear that the answer is a divisor of the order of x in P(x). 

We can use polynomial factoring algorithms or baby-step-giant-step and meet in the middle. The time complexity is O(2|s|/2|s|2) or O(2|s|/2|s|). 

Implementation (C++) 

Codeforces Round #802 Editorial 

By ch_egor, 8 months ago, translation, In EnglishThanks for the participation! 

1700A - Optimal Path was authored and prepared by 74TrAkToR 

1700B - Palindromic Numbers was authored by fedoseev.timofey and prepared by _overrated_ 

1700C - Helping the Nature was authored and prepared by Igorbunov 

1700D - River Locks was authored and prepared by Ziware 

1700E - Serega the Pirate was authored by fedoseev.timofey and prepared by talant 

1700F - Puzzle was authored and prepared by Olerinskiy 

1700A - Optimal PathLet's notice that the optimal path looks like the following: (1,1)→(1,2)→…→(1,m)→(2,m)→…→(n,m). The proof is relatively easy — all paths from (1,1) to (n,m) consist of n+m−1 cells and in the optimal path we have minimized all numbers in the path. The cost of such path is equal to 1+2+…+m+2⋅m+…+n⋅m=∑i=1m−1i+m⋅∑i=1ni. This sum can be found in O(n+m) by just summarizing all numbers, or it can be found in O(1) if you remember that ∑i=1n=n⋅(n+1)2. 

1700B - Palindromic NumbersLet X be the number in input. Consider two cases: first digit of X is 9 and not 9. 

If the first digit of input number is not 9, we can simply output 9999...999 (n digits) - X. 

If the first digit is 9, we can output 111...1111 (n+1 digits) - X. It is easy to show that this number will be exactly n-digit. 

To simplify implementation, we can first find 9999...999 - X by subtracting all digits of X from 9, and than if this number is not n-digit, add 111...1111 - 9999...999 = 11111...1112 to it. 

Overall complexity will be O(n). 

1700C - Helping the NatureConsider the difference array di=ai+1−ai. Note that for di>0 it is necessary to make di subtractions on the suffix. For di<0, you need to make −di subtractions on the prefix. Let's add them to the answer. Let's calculate the final array using prefix and suffix sums for O(n). Note that it will consist of the same numbers. Add |x| to the answer, where x is the resulting number. 

1700D - River LocksTo begin with, we note that it makes sense to open only some pipe prefix, because we need to fill all the locks, and more left pipes affect the total volume of the baths, which is obviously beneficial. Let's enumerate how many pipes we will open, namely which prefix of pipes we will open and calculate dpi - how long it will take to fill the first i locks if the first i pipes are open. Let's introduce an auxiliary array prefi - the sum of the capacities of the gateways on the prefix i. Then dpi=max(dpi−1, ⌈prefi/i⌉). Let's see why this is so. We need all gateways on prefix i−1 to be filled, and also that the i-th gateway be filled. Note that if the i-th gateway does not have time to fill up in the time dpi−1, then it will fill up in the time ⌈prefi/i⌉ (filling will occur at the time prefi/i, but since in the condition we are asked about integer times, we can round up and not use real arithmetic), it turns out when the required amount of water is poured into all the locks in total from all pipes. Now knowing dpi for all i open we can similarly calculate when all n gateways are full. For i this will be max(dpi, ⌈prefn/i⌉). It is also obvious that when an additional pipe is opened, the time will not increase, therefore we can do a bin search by time and find out the answer for the desired request. If the request t is less than the minimum filling time for the locks (when all pipes are open), then you need to print −1. Total running time O(n+qlog(n)). 

1700E - Serega the PirateWe need to find a simple criteria of a solvable puzzle. It can be shown that for every cell, except cell with value 1, it should have a neighbour with a smaller value. Indeed, if the puzzle is solvable, a cell going before the first occurence of our cell always has the smaller value. Conversely, if each cell has a smaller neighbor, one can list cells one at a time, and there will always be a path to the next cell along already visited cells with lower numbers. 

Let's call a cell bad, if it's value is not 1 and it doesn't have a neighbour with a smaller value. Consider any bad cell. Let's notice, that the pair that we swap should contain either the bad cell itself, or its neighbour, otherwise that bad cell will stay bad. That way we have 5nm pairs of candidates, for each of which we'll run a check if the resulting puzzle is solvable. 

Now we'll learn how to quickly understand, if the puzzle became solvable after a swap. For this we'll keep the amount of bad cells. After the swap, the state can be changed only for these cells and their neighbours. Let's recalc the amount of bad cells and check if it's zero. 

The resulting complexity is O(nm)1700F - PuzzleWe are asked to find a minimum cost perfect matching between 1's in the matrices, where the cost between (x1,y1) and (x2,y2) is |x1−x2|+|y1−y2|. Notice that the answer exists only if the number of 1's is equal in both matrices. Consider that this is the case. 

Notice that every 1 either stays in its original row or changes it in a single operation. For simplicity let's assume that all operations of that kind are performed in the beginning. Let's denote Δi,j as the difference between the j-th prefix sum in i-th row of the matrices. If the final row for each 1 is fixed, then the answer is equal to S+∑ni=1(|Δ1,i|+|Δ2,i|), where S in the number of 1's that changed its row. 

Now let's look at what happens when we change the row of a 1. For simplicity let's assume that it was in a cell (1,j). Then after the swap we have to increment S by 1, decrement all Δ1,j,…Δ1,n by 1, and increment all Δ2,j,…Δ2,n by 1. 

Now let's solve the following problem: we are given Δ1,i and Δ2,i and in one operation we can increment some suffix by 1 and decrement the same suffix in the other array by 1. The goal is to minimize S+∑ni=1(|Δ1,i|+|Δ2,i|). 

Notice that the following greedy algorithm works: iterate through columns from left to right and while Δ1,i and Δ2,i have different signs, decrement the suffix of one that's greater and increment suffix of one that's lower. 

Now let's prove that this algorithm minimizes the target sum. For this consider some optimal sequence of operations. It doesn't matter in which order operations are performed, so let's assume they are performed from left to right, and are accumulated in a single element for the same suffix. If the sequences differ, denote i as the first such position. Note that before that all Δ1,i and Δ2,i are the same in both our answer and the optimal one. Suppose that in the optimal answer we incremented i-th suffix of Δ1 by k and decremented i-th suffix of Δ2 by k. Then the target sum will increase by |k|+|Δ1,i+k|+|Δ1,i−k|. 

Consider the following cases: 

Δ1,i≥0 and Δ2,i≥0 or Δ1,i≤0 and Δ2,i≤0. By triangle inequality |Δ1,i+k|+|Δ2,i−k|≥|Δ1,i+Δ2,i|=|Δ1,i|+|Δ2,i|, which means that those k operations could be performed on the i+1-st suffix and that wouldn't increase the answer.Δ1,i<0 and Δ2,i>0. Here if k<0, |Δ1,i+k|+|Δ2,i−k|=2|k|+|Δ1,i|+|Δ2,i|, which means that those k operations could be performed on the i+1-st suffix and that wouldn't increase the answer. Now if k≥0. We can assume that k≤min(−Δ1,i,Δ2,i), otherwise we will perform an operation on values with the same sign, which we already shown can be done later on. Then |k|+|Δ1,i+k|+|Δ2,i−k|=k+(−k−Δ1,i)+(Δ2,i−k)=−k−Δ1,i+Δ2,i. Greedy algorithm suggests doing exactly t=min(−Δ1,i,Δ2,i) operations. Note that if we perform t operations on suffix i and t−k operations on suffix i+1, we will add (−t−Δ1,i+Δ2,i)+(t−k)=−k−Δ1,i+Δ2,i to the answer and get the same state as the optimal answer. This means that we can do t operations and not increase the answer.Δ1,i>0 and Δ2,i<0. This case can be analyzed in the same way.What we showed here is that we can always extend the matching prefix with the optimal answer, which means that the greedy algorithm produces the same answer.Let's come back to the original problem. Described greedy algorithm finds a lower bound on the answer. Let's show that it is always possible to achieve it when the operations are allowed only for moving 1's between rows and the number of 1s in each row at the end should be the same. For this note that we can "perform" operations on 1's from the second matrix, if we reverse their order and append to the end of the sequence for the first matrix. Now note that if on some prefix i Δ1,i and Δ2,i have the same sign, but on prefix i+1 the signs differ, there has to be at least a single 1 in column i+1, and we can perform the operation suggested by the greedy algorithm. Finally, if the answer exists it is true that Δ1,n+Δ2,n=0, and if Δ1,n and Δ2,n have the same sign at the end this means that they are both 0, which means that the constructed answer is correct. 

This solution works in O(n) time. 

Editorial for Codeforces Round #801 (Div. 2) and EPIC Institute of Technology Round 

By jdurie, history, 8 months ago, In English1695A - Subrectangle GuessNote that for any rectangle size, we can always choose an h by w rectangle that contains the maximum element in the grid (which is unique). So in order for Michael to ensure that he can win, he needs to make h and w big enough such that every h by w rectangle contains the maximum element in the grid. 

Let (i,j) be the position of the maximum (1−indexed). The furthest point in the grid from it has to be one of the four corners, and hxw has to be big enough to include that furthest point and (i,j). So just try all four corners and take the biggest rectangle that gives you. This reduces to max(i,n−i+1)⋅max(j,m−j+1) (because the dimensions are independent). 

So the answer is max(i,n−i+1)⋅max(j,m−j+1). 

Complexity: O(nm)Solution1695B - Circle GameNote that since all piles are initially nonempty, the game will not end for the first n turns, because on each of those turns, a player will be removing from a nonempty pile. If n is odd, Mike can remove all of the stones from the first pile. Then, on the n+1th turn (the first turn where the game can end), Joe will be forced to remove from the first pile, which is empty. So Mike can always win if n is odd. 

If n is even, then Mike will only ever remove from the odd piles, and Joe will only ever remove from the even piles. So each player has n/2 piles, and neither can remove from the other's piles. Therefore, it is optimal for each player to remove the minimal possible number of stones at each step, so that they stay in the game for as long as possible. 

So on each turn, a player removes exactly one stone, and the first pile to become empty will be the pile with the minimal number of stones. If there are multiple minimal piles, it will be the leftmost such pile. So if this pile is on an odd position, Mike will lose (and therefore Joe will win), and otherwise Joe will lose (and Mike will win). 

Complexity: O(n)Solution1695C - Zero PathNote that if n+m is even, then the sum of any path from the top left to bottom right will be odd, and therefore nonzero. So in this case, there is no solution. 

Otherwise, every path from top left to bottom right will have even sum. For each position (i,j) in the grid, we define maxij to be the maximum possible sum of a path starting at the top left and ending at (i,j). Similarly, minij is defined to be the minimum possible sum starting at the top left and ending at (i,j). These values can be computed using an O(nm) DP, wheremaxij=aij+max(max(i−1)j,maxi(j−1))minij=aij+min(min(i−1)j,mini(j−1))If 0<minnm or maxnm<0, there is no path adding up to zero. Otherwise, 0 lies in the range [minnm,maxnm], and we can show that there is a valid solution path. 

Proof: Let p1 be a path from (1,1) to (n,m) adding up to minnm, and p2 be another such path adding up to maxnm. Each of these paths consists of n−1 down moves and m−1 right moves, so it can be represented as a string of "R" and "D" of length n+m−2. We can move p1 to p2 by a sequence of operations where we swap two adjacent (and different) characters. Visually, what we are doing is replacing one square on the path with a square diagonally adjacent to it. The below picture shows one possible operation on a path. 

Note that in each step, the sum of values on the path changes by either −2,0, or 2. So after performing this sequence of operations taking p1 to p2, we have moved the path with sum minnm to a path with sum maxnm, changing the sum by −2,0, or 2 at each step. Therefore, because both minnm and maxnm are even, and minnm≤0≤maxnm, at some point in this sequence of operations, the sum of the path must be zero. 

Complexity: O(nm)Solution1695D1 - Tree Queries (Easy Version)If n=1, then no queries are needed, because there is only one vertex. Otherwise, we need at least one query. 

If we fix a node u, and force it to be a query, we can root the tree at u and do a greedy DFS to compute the answer. Note that because we guarantee that the root is a query, when we are computing the answer for any node v in this DFS, we can assume that either v or some vertex not in the subtree of v has already been queried. 

We define ans[v] to be the minimal number of queries to distinguish all vertices in the subtree of v, given that v or some vertex not in the subtree of v has been queried. Note that for each child c of v, we need to be able to distinguish all vertices in the subtree of c, so we have ans[v]≥∑cans[c]. Additionally, there can be at most one child c of v with no queries in its subtree, otherwise all of these children will be indistinguishable by the queries. If there are x>1 such children of v, we can query the first x−1 of them, which will be enough to differentiate all vertices in these x subtrees. So, using this definition of x, our final formula is 

ans[v]=∑cans[c]+max(0,x−1)For each possible root, we do a DFS to recursively compute these answers. The answer is the minimum ans[root]+1, where the +1 is to account for the fact that we are querying the root. 

Complexity: O(n^2) 

Solution1695D2 - Tree Queries (Hard Version)In the previous solution, we forced the root to be a query, because we needed to ensure that for every node v, either v was queried, or there was a query outside the subtree of v. Notice that if the root has degree ≥3, regardless of whether we query the root, this property still holds. The way we compute values in the DFS ensures that at least degree[root]−1≥2 subtrees of the root will have at least one query. Therefore, for each other vertex, some vertex outside its subtree must have a query. 

So the solution is the same as D1, except we root the tree at any vertex of degree ≥3, and don't query the root itself. If there are no vertices of degree ≥3, then the tree is a path, and querying either of the endpoints is sufficient, so the answer is 1. 

Complexity: O(n)Solution1695E - Ambiguous DominoesWe represent the set of dominoes as a graph on 2n vertices, where the vertices are the values 1 to 2n, and the ith domino represents an edge between xi and yi. Note that this graph can contain self-loops and duplicate edges. 

If any of the connected components of the graph contain only one edge, then that means that there is a domino such that its xi and yi values don't appear in any other dominoes. Therefore, this domino must be in the same location in both grids, so there is no solution. 

Otherwise, iterate over all connected components with >0 edges, which must therefore contain ≥2 edges. For a component with k edges, we will run a DFS that will generate a valid 2 by k grid for the k dominoes in this component. 

As we go through this DFS, we keep track of which vertices and which edges we've already seen. When we DFS from a vertex u we haven't seen, mark it as seen, and iterate over all edges adjacent to u that we haven't seen. Mark each one as seen, and then traverse it to the other vertex v, marking u as its parent. Once we backtrack to u, continue to the next unseen edge. Once all unseen edges are traversed, traverse back to the parent of u. 

When we visit a vertex u we have already seen, just traverse the edge back to its parent. 

Throughout this process, maintain a list of all vertices we've seen in order, including any duplicates. Because we traverse every edge exactly twice (once in each direction) in this DFS, this list will be of size 2k+1, and every two adjacent vertices in the list are connected by an edge. Each edge will be represented in two positions in this list. 

We can additionally prove that within this list, each edge appears in one even position and one odd position. 

Proof: Let uv be an edge that we initially traverse from u to v. If v has already been traversed by this point in the DFS, we immediately traverse back to u, so the two positions of uv are adjacent in the list, and thus on different parity positions. 

If not, consider the final sequence of edges traversed, but removing any edges that are immediately traversed backwards. Note that since we are only removing pairs of adjacent edges, the parities of positions of edges in the list are unchanged. Now, the sequence of edges is just a DFS traversal of a tree. So because the graph is now a tree, and thus bipartite, any path from v to itself must be of even length. Therefore, the sequence of moves looks like (...,uv, [an even number of edges], vu,...) and therefore the two occurrences of uv must be on different parities. 

Now, to generate the 2 by k grid that works for this component, we note that the list of size 2k+1 can be seen as a cyclic list of size 2k, because the first and last element of the list must be equal. So we pop the last element of the list off, and insert the remaining vertices of the list into a 2 by k grid in clockwise order. Now, the edges form a cycle of length 2k, and because each edge appears on one odd and one even position, each domino will appear exactly once in both of the below orientations. Each of these orientations takes the dominoes going around the cycle in order. 

To get the solution for the whole problem, simply concatenate the 2 by k grids for each component into a 2 by n grid. 

The below example demonstrates the whole process. The blue edges are the edges to previously-seen vertices, and the red edges are the edges to previously-unseen vertices. 

Complexity: O(n)Solution 



