Codeforces Round #100: problem analysisBy natalia, 11 years ago, translation, In EnglishProblem A. New Year Table

The plates must touch the edge of the table, so their centers must lie on the circle with radius R - r (see the figure).

In case the plates have the largest radius possible for the given table, their centers are situated in the vertices of the regular polygon (n-gon) inscribed in this circle. The problem is to find the length of the side of the inscribed regular n-gon and to compare it with 2r. The formula for the length of the side is a = 2(R - r)sin (π / n), it can be easily deduced. For that you should consider the right triangle (the green one in the figure).

In implementation, be careful with a case when the equality r = (R - r)sin(π / n) (*) holds. Because of the computational error the right-hand side can get larger than the left-hand one. This can result in answer "NO" instead of "YES". Comparison in such cases should be performed with a small ε: a + ε < b instead of a < b ,a < b + ε instead of a ≤ b.A constant ε should be chosen in such a way, that it is smaller than any possible difference between precise values of a and b, if they are distinct. In particular, for computations by the formula (*), taking into account the constraints of the problem, this difference may be approximately 7· 10 - 7. So ε   = 10 - 7 is sufficient, but ε  = 10 - 6 is not. 

Once again, I focus your attention on the fact that the choice of ε  depends on specific formulas used for computations and comparisons. Different solutions can be accepted or not with the same ε. Problem B. New Year Cards

This problem was just a problem on implementation. Note that a number of a send card is uniquely determined by a number of a friend and a set of cards Alexander already has at the moment. Consider the sample form the statement. 	 1	2 	3 	4  {1}	 -	1 	1 	1  {1, 2}	2	1 	1 	1  {3, 1, 2}	3 	3 	1 	3  {3, 1, 2, 4}	3	3 	1 	3 The first column of the table contains sets of cards that Alexander gets after having received a next card each time. Numbers in the sets are written in order of Alexander's preferences. Each i-th of the next four columns contains numbers of cards that the i-th friend will get from the corresponding sets. Our goal is to choose for each friend the most preferred card in his column.

Note that to determine by the current Alexander's set and the number of the friend a number of a card received by this friend, it is not necessary to know the whole Alexander's set. The two most preferable cards are sufficient. So for each time moment find the two most preferable cards for Alexander. Using them, determine which of them will be send to each friend (find the numbers in the columns). Then choose the element with the maximum priority in each column. We get the O(n2) solution.  Problem C. New Year Snowmen

Solution 1. Suppose that the answer is k. If there are more than k equal among the given numbers, it's clear that we can't use them all (we can't use equal snowballs in the same snowman). So we leave k snowballs of them, and discard the rest. Then, sort the radii in the non-decreasing order. After that every two snowballs with numbers i and k + i are different. Make snowmen of snowballs with numbers (1, k + 1, 2k + 1), (2, k + 2, 2k + 2), (3, k + 3, 2k + 3) and so on. If the total number of snowballs is not less than 3k, we always manage to make k snowmen. Now we can for the fixed k answer to the question, if k snowmen can be made, so k can be chosen by binary search. 

Solution 2. Count quantities of snowballs of each size, choose greedily the three largest quantities, take a snowball from each of them, make snowman and continue the process, while it's possible. Why is it correct? Let k be the answer for the problem. If there are quantities larger than k, we will count them as k, because other snowballs in them will not be used in any way. We prove the correctness of the algorithm usingProposition: if every quantity is  ≤ k and the total quantity of snowballs is  ≥ 3k, then it's possible to perform a step of the algorithm. 

Proposition is valid because by Pigeonhole principle there are no less than three non-zero quantities. If there are 3 (or more) quantities equal k, then k steps of the algorithm can be performed. If there is one or two such quantities, by the first step we certainly decrease them and come to a similar situation with k - 1. If there are no quantities equal k, after the first step we obtain quantities  ≤ k - 1, and their total sum is  ≥ 3(k - 1). Thus, we always can perform k steps and get the answer k.

From the point of view of implementation, in the second solution it is easy to calculate quantities for each size of snowballs (using sorting and scaling). Use set to work with these quantities. The time for the both solutions is .Problem D. New Year Contest

Solution 1 (greedy). Optimal order to solve problems is an increasing (non-decreasing) order by their difficulties. Problems solved before the New Year must be submitted at 0:00, ones solved after the New Year must be submitted just after finishing their solutions.

Let us prove the optimality of this solution by the descent method. General scheme of reasoning is the following. Suppose you have the optimal order which is not the increasing order by problems' dificulties. Show that it is possible to come (to descend) from it to another variant, that is not less optimal. As a result you come to the sorted variant by such steps.

So suppose that there is a pair of problems in the optimal solution such that their difficulties are going in decreasing order. Then there are consecutive problems with this property. Suppose they both are solved before the New Year. Then the swap of them doesn't influence the penalty (it doesn't decrease). If the both problems are solved after the New Year, then their contribution to the total penalty is (T + ai) + (T + ai + aj), where T is a time of the beginning of solution for the first problem, ai is a time for the solution for the first problem, aj < ai is a time for the solution for the second problem. After the swap of these problems we get the penalty (T + aj) + (T + aj + ai), that is less than (T + ai) + (T + ai + aj). It remains to consider cases when one of the consecutive problems that are in the "wrong" order "intersects the New Year". These cases can be treated similarly.

In case when Gennady hasn't time to solve all problems, you should choose the maximal possible number of the easiest problems. Indeed, it doesn't make sense to solve a more difficult problem instead of an easy one: change of a larger ai to a smaller one doesn't spoil an answer. Rigorous proof can be obtained by the same descent method.

Solution 2 (dynamic). First of all, as in the previous solution, choose the maximal number of the easiest problems that Gennady has time to solve. Discard the remaining tasks. Try every problem as one being solved in the moment of the New Year (0:00). Remaining problems (except it) must be divided into two sets. One is for solving before the New Year, and another is for solving after the New Year. Problems in the second set must be solved in increasing order of their difficulties (it is a well-known fact for everybody participating in contests by ACM rules). In the first set an order of solving is immaterial. Sort the given numbers in increasing order, and count the dynamics d[i][j][k] that is the smallest possible penalty, if there are the first i problems solved, j from them are solved after the New Year, and the last problem after the New Year was solved at the moment k. Note that the triple (i, j, k) uniquely determines the number of problems solved before the New Year and the total time needed for their solutions. After calculating the dynamics, recollect the problem being solved exactly at 0:00 (it was not taken into account in the dynamics). Try moments of time before the New Year when its solutions starts, and count remaining problems using the dynamics we already has.Problem E. New Year Garland

First, let us solve the subtask for one layer. It consists in finding the number of ways to compose a garland of lengths s with lamps of exactly k colors such that no two consecutive lamps have the same color. Variants different only by an order of colors are considered to be the same (we always can multiply by k! if we need). The solution of the subtasks is required only for k ≤ s ≤ 5000, so can be done by O(s2)-dynamics:  a[s][k] = a[s-1][k-1] + a[s-1][k] * (k -1).They would be Stirling numbers of the second kind, if there was not a restriction about different colors of consecutive lamps.  

Then, calculate the dynamics d[i][j] that is a number of ways to compose a garland for the first i layers according to the rules, such that the i-th layer contains exactly j different colors. There will be about L positions (the total length of the garland), because every layer can't contain more colors than its length: j ≤ li (!). All d[i][j] can be calculated in O(L) operations, because sets of colors with different cardinalities are always different (!!). Indeed, put d[i][j] = Amj * a[l[i]][j] * (sum of all d[i-1][k]), and then subtract variants with equal sets on the i-th and (i-1)-th layers. Coefficients Amj = m(m - 1)... (m - j + 1) can be pre-calculated because they are required only for j ≤ 5000.

Thus, the author's solutions works in O(L + s2) (L ≤ 107, s ≤ 5000), and it doesn't use division (only addition and multiplication modulo p).Problem F. New Year Snowflake

Start with the check of a candidate symmetry center (xc, yc). Consider all points symmetrical to (xi, yi) with this center. They are of form (2xc - xi, 2yc - yi). It is necessary to check that they all except may be k of them are in the set {(xi, yi)}. It can be done in  by binary search (if the set was previously sorted). But there is more effective way of check in O(n). Note that if initially the points (xi, yi) were sorted, say, by x-coordinate in increasing order and in case of equal x by y, then the points of the form (2xc -  xi, 2yc - yi) will be sorted in the reverse order. The order doesn't depend on the center (xc, yc). So we can check the points (2xc -  xi, 2yc - yi) in the order of sorting moving a pointer in the sorted array (xi, yi).

It follows from the previous reasoning, that if a set has a symmetry center, then the first point (in the order of sorting) forms a pair with n'th, the second one with (n-1)-th and so on. Since up to k points have not a pair, try the first (k+1) points from the beginning and (k+1) from the end of the array. For every pair of these points find the midpoint and check it in O(n). Asymptotics of the solution is  O(nk2). In conclusion, a couple of words about the difficulty order in the problemset must be said. Difficulty of a problem is subjective. Especially if we need to compare a problem with idea and nearly without implementation and implementation without idea. As a result, different participants form different preference lists (russian). I can't deny that the order chosen during preparation of the contest appeared to be inadequate with the number of solutions for the problems, and it surely can be not liked by someone personally. Nevertheless, I want to say a couple of words in its support. Namely, about principles we have used to choose it. 

Score for a problem is, first of all, its "price". Ability to solve problems with idea, IMHO, must have higher price then ability to solve implementation problems. Because everybody can learn to solve implementation with level like problem B. But idea with sorting in problm D, as I saw, was not invented by several strong and experienced participants. About the order of the problems, I can say that nobody makes you to solve them exactly in this order. It is not bad, if you fast get an idea for C or D, solve them before B, and get more scores. Many contestants acted this way. Moreover, the current standing is available that can help you to choose right problems to solve. 

Codeforces Beta Round #99: editorialBy Endagorion, 11 years ago, translation, In English139A - Petr and BookIf the total number of pages doesn't exceed the number of pages for Monday, the answer is Monday. Otherwise we can substract the Monday number from total and go on to Tuesday. If Tuesday isn't enough, we subtract and continue to Wednesday, and so on. We are sure that no more than N weeks will pass, as at least one page is read every week. Complexity - O(N).

139B - WallpaperUnluckily, the translated statement was quite tough even tougher to understand than the original statement.

Say we fixed the roll type and the room. The only possible way to cut the roll is to cut it into vertical stripes with length equal to room's height (though it was said we can cut it any way we want, there were some conditions to fulfill, namely there could be no joints other than vertical). So we find the total width of stripes we can cut our roll into as the (length of the roll / height of the room) (rounded down) * (width of the roll). If the roll length is smaller than room height, we obviously can not use this type of rolls (though the statement said there must exist at least one type we can use). The number of rolls is (perimeter of the wall rooms) / (total stripes width) (rounded up).

Then we just try all types for every room and sum the minimal costs. Complexity - O(MN).139C - Literature Lesson138A - Literature LessonThe hardest part is to check whether two lines rhyme or not.

We have to check the suffixes starting in K-th vowels from the ends for equality. Notice that if a line has less then K vowels, it can NOT be part of any rhyme (even with the identical string).

To check this we can use two pointers running from two ends simultaneously, or use some built-in functions for taking substrings (like s.substr(...) in C++).

Now, let us take three boolean variables: aabb, abab and abba. Each one says if every quatrain we have seen before satisfies the corresponding type of rhyme. To support them, for each new quatrain we must check for rhyming every pair of lines it and change variables if needed.

If at the end of the poem all variables are set to TRUE, then the type is aaaa. If all of them are FALSE's, then the answer is NO. Otherwise exactly on of them is TRUE, and answer is clear. 

Complexity - O(S), where S is the sum of all lines' sizes.

139D - Digits Permutations138B - Digits PermutationsIt turned out to be surprisingly hard, possibly because of lots of cases to think of.

How to determine the number of zeros at the end of the sum of two numbers? First we skip all the positions from the end where both numbers have zeros. If on the next position the sum of digits is not 10, that's it. If it is, we go on while the sum of digits is 9.

Now we take two transitions of digits in N. Let's fix the number of common zeros at the end of both transitions. If, moreover, we fix the digits that sum up to 10 at the next positions, we can find the maximal number of zeros to get with the remaining digits as min(a0, b9) + ... + min(a9, b0), where a0, ..., a9 are the quantities of every remaining digit in the first transition after taking out the last zeroes and the digit for the 10-sum, and b0, ..., b9 are the same numbers for second transition (initially these quantities are equal to quantities of digits in N).

So, if we store a0, ..., a9 and b0, ..., b9, and then run through the numbers of common zeros at the end and the 10-sum digits, we determine the maximal zeros number (and configuration giving that answer) in O(10 * 10 * N) = O(N) time. Getting the transitions now is easy - we build them from right to left according to the saved answer.

The most common mistake was to think that maximal number of zeros at the end gives the maximal answer. It was disproved by 4-th pretest - 1099. As we can see, the optimal configuration is 1901 + 1099, giving three zeros, which cannot be achieved by placing both zeros at the ends.

139E - Mushroom Gnomes - 2138C - Mushroom Gnomes - 2First of all - the answer is the sum for all mushrooms of the probabilities of not being destroyed multiplied by that mushroom's power. That is a simple property of random variables' means.

So we come to the equivalent statement: we still have mushrooms, but now instead of trees we have a family of segments with probabilities arranged to them. Every segment "exists" with this probability, otherwise it doesn't, and all these events are independent. We want to count the sum of probabilities (with weights) for each mushroom not to lie in any "existing" segment. (Note that we can reformulate the statement this way because any segments containing any fixed point are truly independent: they can't belong to the same tree. Thus the probability to survive for any point in this statement is equal to the probability for this point in the original statement).

Now, how do we count this? There are several ways:

1) "Scanning line". If we go from left to right, we can meet three kinds of events: "the segment i started", "the segment i finished", "the mushroom j found". We can easily support the probability of current point being covered by "existing" segment if we multiply it by segment's probability when we find its beginning and divide by it if we find its end. If we find a mushroom by the way, we can add the known probability to answer (multiplied by its power). To perform the above trick we just sort the array of events by x-coordinate and iterate over it.

This solution is good in theory, but in practice it has a flaw: if the number of segments is large, after multiplying lots of real numbers less then 1 we can exceed the negative explonent of the real type used, and thus get a 0 in a variable instead of desired value. And after any number of divisions it still would be 0, so we couldn't get any sane answer anymore.

This trouble can be resolved in several ways (without changing the solution much):

a) We can have no more than 101 distinct values of probabilities for segments. So, if we store an array for quantities of segments containing current point and having a corresponding probability, we just add and substract 1's from array's elements. When we find a mushroom we find the product of degrees with exponents stored in array, spending ~100 operations.

b) We can store a set of segments containing current point. Every operation with set works in O(log N) time, and iterating over the whole set works in O(N) time. So, upon meeting mushroom we iterate over set and multiply the probabilities for all segments in it.The next thing that helps us is that we can drop the answer for current mushroom if it's too small. If we don't store the segments with probability 1, the most number of segments which probabilities' product more than 1e-8 is about 2000 (since 0.99 ^ 2000 < 1e-8). So we can count everything in time.

c) If we use logs of probabilities instead of themselves, we have to add and substract them instead of multiplying and dividing. This way we won't encounter any precision troubles.

2) Segment tree.

Let's sort the mushrooms by their coordinates. Let's also assume we have some set of segments and already counted the desired probabilities. And now we want to add a new segment to the set. What will change? The probabilities of mushrooms lying in this segment (and thus forming a segment in the array) will multiply by segment's probability.Now it's clear we can use multiplication segment tree (or simple addition segment tree if we use logs again) to perform the queries for all segments and then sum up the elements in the end.

About the strange score and pretest: we discovered the trouble with precision quite late, and realized that it makes the problem way harder ('cause it's hard to predict during writing and submission phases). What's worse, it won't show itself on the small tests. So we decided to "show up" the test and let the contestants solve this additional problem, for additional score. (However, not all solutions from above list do actually deal with this problem. Unfortunately, we didn't came up with them beforehand.)138D - World of DarkraftNotice that the game can be separated into two independent: for only even and only odd coordinate sum cells. The player chooses the game he would like to make a move in. Thus, if we find a Grundy function for each of this games we can find the whole game result.

Now let's observe only even cells, for instance. We can prove that every diagonally connected piece formed during the game is constructed as the intersection of the field rectangle with some diagonally oriented semi-planes, with exactly one semi-plane for every orientation. Let's enumerate every possible edges of semi-planes, which obviously are some diagonals of the grid. Now we have an enumeration of all possible pieces - by four diagonals being "edges" of this piece.

Now we want to count the Grundy function for some piece. To do this we iterate over all cells in this piece and find XORs of all Grundy functions of pieces formed by making a move in each cell, then find a minimal exclused non-negative number of this set (see the page on the Sprague-Grundy theorem above). All these pieces are smaller than current, so we can use the DP to count the functions. To easily iterate over cells in the piece we can iterate over numbers of two diagonals the cell lies on (going right-and-upwards and right-and-downwards), as we have exactly the bounds on their numbers as the parameters of the piece. For each case of diagonals we also have to check if the piece is inside the field.

So we have counted the Grundy functions for even- and odd-numbered cells separately. If they are equal, the answer is "LOSE", otherwise it's a "WIN" (see the theorem again).

Complexity - O((n + m)4 (number of pieces) mn (number of pieces inside one piece and counting MEX)).138E - Hellish ConstraintsThe most interesting problem. =)

Let's start with the case when we have only one constriction - "c l r". For a string s let's count an array A with a length equal to s's. A[i] = 1 if the suffix of s starting at position i satisfies the condition, and A[i] = 0 otherwise.

So, we have s and already counted A. What happens if we write another symbol c' at the of s? Let s' = s + c', A' = A(s').

If c' ≠ c, than the part of A' corresponding to everything beside the last symbol does not change. The last element is 1 or 0 depending on the condition (it's easy to count).

If c' = c, some elements of A might change. Let's denote the i-th occurence of c in s' counting from the end as pi(c) (symbols and occurences are enumerated from 1). If there are less then i occurences, pi(c) = 0.

It's easy to see that elements from A'[pl + 1(c) + 1..pl(c)] are incremented by 1, and elements from A'[pr + 2(c) + 1..pr + 1(c)] are decremented by 1. It's also clear that as we add the symbols these invervals won't intersect for l and r separately (that is, every A[i] will be incremented and decremented not more than one time each).

Now we can have more then one constriction. We count B[i] as the number of constrictions the suffix starting at i-th position satisfies. Clearly, B[i] is the sum of A[i]'s for all constrictions. Also, we support the variable C - number of i-s that satisfy L ≤ B[i] ≤ R.

Similarly, we add symbols one after another and change B[i]. To do that, we must consider all the constrictions concerning new symbols and change the numbers in the intervals mentioned above. Changing the numbers is just iterating over symbols in the mentioned intervals and incrementing/decrementing B[i]'s (this procedure also lets us to support C effectively). As the intervals for each constriction do not intersect, we will not change any B[i] more than twice for each constriction, so the number of operations concerning any constriction is O(n), giving total number of operations O(nk). To get the answer, we just sum up C's states after adding every symbol (as every substring will be a suffix of some prefix exactly one time).

To find borders of every interval used (in which the B[i]'s are changed) we can enumerate all occurences of every symbols and count the borders easily, knowing how many times every symbol occured. The other way to do that is to keep two pointers for each constriction, showing where last intervals ended. On the next occurence we move these pointers to next occurences of corresponding symbol (however, we need to handle the case when not enough symbols have occured to changed B).

Codeforces Beta Round #98 (Div. 2): EditorialBy Edvard, 11 years ago, translation, In EnglishA. Postcards and photos

We will move from the left of string to the right. When we passed the whole string, or in the hands of us have 5 pieces, or current object is different from what we hold in our hands, we remove all the items in the pantry. The answer to the problem is the number of visits to the pantry.

The complexity is O(n).

B. Permutation

We can count the number of integers from 1 to n, which occur in sequence at least once. Then the answer is n minus that number.

The complexity is O(n).

C. History

Denote a[i], b[i] - ends of the i-th event. Let's sort pairs (a[i], b[i]) by a[i] and iterate over all pairs. Denote rg the maximal b[i] from already processed. If current b[i] < rg than we must increment answer by one. If b[i] > rg than we must assign rg by b[i].

The complexity is O(n logn).

D. Palindromes

Let's preprocess array cnt[i][j] - the minimal number of changes tha we must do to make substring from position i to j palindrom. We can easy calc cnt[i][j] with complexity O(n^3). Now we can calculate dynamic programming z[i][j] - minimal number of changes that we can do to split prefix of length i into j palindromes. In begining we must assign z[i][j] = infinity for all (i, j) and assign z[0][0] = 0. If we want to make updates from state (i, j) we must fix the length of j-th palindrom - len. We can update z[i + len][j + 1] by value z[i][j] + cnt[i][i + len - 1]. Answer to the problem is the min(z[n][i]), where n is the length of string and i from range [1, k].

The complexity is O(n^3).

E. Last Chance

Let's replace all vowels by -1 and all consonants by +2. Obviously substring from position i to j is good if sum in the substring [i, j] is nonnegative. Denote this sum by sum[i][j]. Obviously sum[i][j] = p[j + 1] - p[i], where p[i] is the sum of first i elements. Now for all i we want to find maximal j such that j >= i and sum[i][j] >= 0. For this let's sort the array of (p[i], i) and build segment tree on this array by i. Let's iterate over all p[i] in nondescending order. Obsiously for fixed i we have that j = max(index[i]), where index[i] is the index of i-th partial sum in nondescending order and i from range [x, n], where x is the position of the first partial sum with value p[i] in sorted array. Than we must update position i by value of negative infinity and update answer by j - i.

The complexity is O(n logn).

Codeforces Beta Round #97: editorialBy KADR, 11 years ago, translation, In EnglishHere is the editorial of Codeforces Beta Round #97. If you have any questions or suggestions --- feel free to post them in the comments.

136A - Presents (A Div 2)

In this problem one had to read a permutation and output the inverse permutation to it. It can be found with the following algorithm. When reading the i-th number, which is equal to a one can store i into the a-th element of the resulting array. The only thing left is to output this array.

The complexity is O(N).136B - Ternary Logic (B Div 2)

It is easy to see that the answer is always unique. Let's consider an operation which is opposite to tor. From each ternary digit of c we will subtract a corresponding digit of a and take a result modulo 3. We'll obtain a number b which has the following property: a tor b = c.

The complexity is O(logC + logA).136C - Replacement (C Div 2)135A - Replacement (A Div 1)

If the largest number in our array is equal to 1 then let's replace it with 2, otherwise let's replace it with 1. After that let's sort the array and output it. It is easy to see that the array obtained in that way is the one we are looking for.

The complexity is O(NlogN).136D - Rectangle and Square (D Div 2)135B - Rectangle and Square (B Div 1)

Let's iterate over all partitions of our set of 8 points into two sets of 4 points. We want to check whether the first set forms a square and the second set forms a rectangle.

To check if 4 points lay at the vertexes of a rectangle one can iterate over all permutations of the last 3 points. Then one need to ensure that every two consecutive sides intersect at a 90 degrees angle. That can be done using the fact that the scalar product of two vectors is equal to 0 iff they intersect at a 90 degrees angle.

To check if 4 points lay at the vertexes of a square one can check whether they lay at the vertexes of a rectangle and ensure that two consecutive sides have equal length. 

136E - Zero-One (E Div 2)135C - Zero-One (C Div 1)

First, let's solve the problem when there are no spoiled cards. Let a be the number of ones and b be the number of zeroes. It is easy to see that if a < b then the outcome is 00, because the first player can always remove ones until they are over, which will happen before the end of the game regardless of the second player's moves. Similarly, if a > b + 1 then the outcome is 11.

If a = b or a = b + 1 then the outcome is either 01 or 10. That's because the first player will always remove ones, because otherwise the outcome will be 00 which is worse than any other outcome for him. Similarly, the second player will always remove zeroes. One may notice that the first player can always remove the first card to the left with 1 written on it, because it won't make the outcome worse for him. Similarly, the second player can always remove the first card to the left with 0 written on it. That means that the last card won't be removed by anyone. Thus is the last card is 1 then the outcome is 01, otherwise it is 10.

We've learned how to solve the problem is there are no '?' signs. Now, suppose that the number of ones is a, the number of zeroes is b and the number of question signs is c. To check if the outcome 00 is possible, one can simply replace all question signs with zeroes and use the previous result, i.e. check if a < b + c. Similarly, the outcome 11 is possible is a + c > b + 1.

Let's show how to check if the outcome 01 is possible. If the last character of the string is 0, then the string is not possible. If the last character is ? then we can replace it with 1, i.e. decrease c by 1 and increase a by 1. Suppose we want to replace x question signs with one and c - x question signs with zero. Then the following equality must hold: x + a = b + c - x + (a + b + c) mod 2. Thus, x = (b + c - a + (a + b + c) mod 2) / 2. If the resulting value of x is non-negative and is not greater than c, then the outcome 01 is possible, otherwise it is not possible.

We can check if the outcome 10 is possible in the similar way.

The complexity is O(N).

135D - Cycle (D Div 1)

One can notice that the only possible variant of a cool cycle which doesn't have zeroes inside it is a 2x2 square of ones. This case should be checked separately. From this point we'll assume that the cool cycle we are looking for contains at least one '0' inside it.

Let's take any zero from the table. If it is adjacent to another zero by a side or a corner then it can't lay inside a cool cycle which doesn't have any other zeroes inside it. Thus, this zero can lay inside a cool cycle only together with all zeroes adjacent to it. Generalizing this fact one can show that the zero can lay inside a cool cycle only together with all zeroes reachable from it. We'll assume that one zero is reachable from another zero if they can be connected with a path which consists only of zeroes and in which every two consecutive cells share either a side or a corner.

Let's find all the connected components of zeroes. Two zeroes are connected if they share either a side or a corner. If the component of zeroes has a cell adjacent to a border of the table, then it can't lay inside any cool cycle and thus it should be ignored. After that for each connected component of zeroes let's find all cells with 1, adjacent to it. By the statement all those cells should be connected. Also, each cell from this set should share a common side with exactly two other cells from the set. Note that if the set of  cells with '1' satisfy those restrictions, then it forms a cycle which doesn't contain any other cells with '1' inside it.

The above algorithm has the complexity O(NM), if implemented carefully.

135E - Weak Subsequence (E Div 1)

Let cool substring be the substring which is also a weak subsequence.

The main observation is that the longest cool substring in any string is either its prefix or its suffix. Moreover, if, for example, it is a prefix then it can be found in the following way. Let's start moving from the end of the string towards the beginning and memorize all characters met on our way. We'll stop after some character appear in the second time. The prefix with the end in the position where we stopped is the one we are looking for.

Let's count the number of strings in which the longest cool substring is a suffix. First, we will iterate over the number of characters at the beginning of the string lying before the second appearance of some character. Let this number be t. Obviously, t is not greater than k, because all characters in the prefix of length t are distinct. We need to consider the following two cases:

1. If t ≤ w - 1. The first t characters of a resulting string are distinct, then there is a character which was present among the first t characters. After it there are w - 1 more characters. One should also consider that the last t characters are distinct, otherwise prefix of length greater than w will be also a weak subsequence. Thus, the corresponding summand is equal to .2. If t > w - 1.  The first t characters of a resulting string are distinct, then there is a character which was present among the first t characters. The last t characters should be distinct, but at this time the suffix of t characters overlaps with the prefix of t characters. The corresponding summand is equal to .

After adding up everything for all t from 1 to k we will obtain the number of strings in which the longest cool substring is a suffix of length w.

Similarly, we can find the number of strings in which the longest cool substring is a prefix. The only difference is that we should make sure that the first t + 1 characters of those strings are distinct in order to avoid a double-counting of the strings in which the first and the last t characters are distinct. Considering this the formulas are:

1. If t + 1 ≤ w - 1, then the summand is equal to .

2. If t + 1 > w - 1, then the summand is equal to .

The only thing left is to add up everything for all t from 1 to k - 1.

To calculate the above formula quickly one need to precompute factorials for all numbers from 1 to k and they inverse modulo 109+7.

The complexity is either O(K) or O(K· log(MOD)), depending on the way of computing inverse values to the factorials.

As a bonus for those who made it to the end of the editorial, I'll describe a simple linear time algorithm of finding inverse values for all integers between 1 and N modulo prime number P (P > N). I think it will be useful for those who didn't hear about this trick.

Let's consider an obvious equality (% means a remainder of division) and perform a few simple operations with it. 





Thus, in order to compute i - 1 we only need to know (P%i) - 1, which is less than i. That means we can compute inverse values successively for all integers between 1 and N in O(N) time.

Codeforces Beta Round #96: editorialBy Nickolas, 11 years ago, translation, In EnglishA. HQ9+The problem described HQ9+ programming language and asked whether the given program will print anything. Given the extraordinary simplicity of the language, it was enough to check whether the program contains at least one of the characters H, Q and 9.

B. UnaryA lovely language Brainfuck has dialects for literally every occasion; I guess one could write a whole round about it (not Unknown Language Round, of course, it's too well-known for it), but this time I used it in one problem only.

The solution is quite simple: all you have to do is to follow the described procedure of transforming code from Brainfuck to Unary. If your language has built-in long arithmetics, the solution is straightforward: replace characters of each type with corresponding binary codes, convert the resulting string into a long integer and take it modulo 1000003.

Having no long arithmetics is not a big deal either. The program can be created step by step, adding one character at a time from left to right. On each step the length of the program is multiplied by 16 (the binary code added has length of 4 bits), then the code of the current character is added and the result is taken modulo 1000003, so that the result never gets really large.

C. Turing TapeThis was another implementation problem, inspired by another great language INTERCAL. Technically it was a bit more complicated than the previous one, due to the usage of byte reversal and having to implement not the described procedure but its inverse. For i-th character of input data reverse it and store in rev[i]; then i-th number of the output can be calculated as (rev[i - 1] - rev[i] + 256)%256 (for i = 0 rev[i - 1] = 0).

D. PietAs you've already noticed, Piet differs from most other esoteric programming languages in the way it interprets the image — the problem offered a very simplified version of it, and still it was quite cruel.

The first step of the solution is finding colored blocks. Given that they are rectangular, this can be done without BFS; once you've found a colored pixel which is not part of any block you've seen before, you just find the maximal contiguous sequence of pixels of the same color in the same line that starts with this pixel, and assume that it's horizontal dimension of its block.

..............X----->.....|XXXXXX.....vXXXXXX...............I found it convenient to index the blocks and store their colors and dimensions at this point, so that this doesn't need to be re-done later. After this I calculated "state transition function" — a function which for each state of instruction pointer defined the next state. The IP has at most 50x50x4x2 states, and they can be indexed with 8*(index of current block) + 2*(direction pointer) + (block chooser). Thus, the transition function can be described with a one-dimensional array (index is current state of IP, and value is the next one), and the simulation of interpretation steps becomes just updating the current state of IP, which is easier than repeating the full procedure described in the statement on each step.

It was also possible to note that at some point there will be a loop in the states of the IP, since the maximal possible number of distinct states is less than the number of steps to be done. But exploiting this wasn't necessary.

E. Logo TurtleThis was the only problem of the round which featured a non-esoteric language. The solution is dynamic programming, and it could be used in several ways. My solution was to store two three-dimensional arrays: the leftmost and the rightmost position of a turtle after it used I commands from the list, made J changes in these commands and is now facing direction K. The initial condition is that left=right=0 when I = J = 0 and the turtle faces right (the initial direction can be chosen arbitrarily). The rule of moving between states is: if currently executed command is T (either it is the current command of the list and no change is done, or it is a result of a change), the coordinate stays the same and the direction changes; otherwise the direction stays the same and the coordinate changes accordingly to the direction.

It's convenient to do at most one change for each command; in this case after all the arrays are calculated, one has to take the maximal absolute value among all distances which use all commands from the list, all facing directions of the turtle and all quantities of changes which have the same parity as the required quantity (any command can be changed an even number of times without affecting the result).

Div1 D. Constants in the language of ShakespeareTwo last problems of the round were inspired by Shakespeare programming language. The original idea was to make them one problem — "How to print the given sequence using as few adjectives as possible?". But later we came to our senses and split this monster of a problem in two.

The evident greedy solution (break the binary notation into contiguous groups of 1s, if the size of the group is 1, write it as a single power, otherwise write it as a difference of two powers) is wrong. You can see this from test 4 "10110111": the greedy solution will return 5 ( + 27 + 26 - 24 + 23 - 20), while it's possible to find a notation of size 4 ( + 28 - 26 - 24 - 21).

The correct solution is based on the following idea. Let us have a fragment of binary notation which contains bits for powers of 3 between N and M (N < M), inclusive, which has K 0s and L 1s. It can be written as a sum of powers which correspond to positions of 1s, using L powers. Alternatively, it can be written as 2M + 1 - 2N - ..., where ... are powers which correspond to positions of 0s, using 2 + K powers. It's evident that using second method makes sense only if the fragment starts and ends with 1s (otherwise it can be used for shorter fragment without the leading/trailing 0s, and save at least one power on this) and contains no 00 sequence inside (otherwise you can break the fragment into two in place of these 00 and write these fragments separately with the same or better result).

After you've noted this, you can solve the problem using DP: for each position in binary notation store the sign "write it as sum of powers or as difference of powers", and in second case store the length of the fragment which is written using difference (storing the length of the fragment which is written using sums only is unnecessary, since this can be done for individual bits with the same result as for longer fragments.

Some ideas for Round #95 (Div 2)By reiracofage, 11 years ago, In EnglishHi, these are just some ideas of what I did to solve the problems in #95 (div 2). They're just what I did, better solutions may exist and will be very welcome!Also, sorry if I wrote something wrong, English isn't my first language.Also, (a b) is a choose b (a!/(b!(a-b)!)).

Problem A

Just do what the statement asks you to. Check if all letters are uppercase, except for the first one, that you don't need to check. If so, change the case of the entire string. If not, do nothing. Please notice that an one-letter string must have its case changed.

It can be easly done in O(n), where n is the lenght of the string.

Problem B

First, let count(i) be the numbers of occurrences of the number i in the input,    for -10 <= i <= 10. Remember that there may be negative numbers in the input, so one can use an offset to store these values (use an 21-sized array C and store count(i) in C[i+10]). Except for 0, possible matching are pairs (i,-i), for 1 <= i <= 10. It's easy to see that there will be exactly count(i)*count(-i) valid matching for each i, so just sum them all.

Since 0 "is opposite to itself", but "a client can't form a couple withhim/herself", the number of valid pairs (0,0) will be (count(0) 2). Just sumthis value to the previous computed sum and print.Use 64 bits-types to do the math.

Problem C

Since the constraints are small, let's just iterate through all possible numbers b of boys in the group and count how many ways we can form the group with b boys.

First, consider only the values where b >= 4. Given b, it's clear that the number of girls in the group must be g = t - b. If g < 1, don't consider this case. Given the values of b and g, there are (n b)*(m g) ways to form the group, since we can combine the boys independently the girls. Just sum (n b)*(m g) for each pair (b,g). Again, use 64 bits-types to do the math.

One could precompute all the values of (i j) using the Pascal triangle, but one could also compute it with the traditional formula, if its implementation takes care of possible overflow (30! doesn't fit in 64-bit integer type).

Problem D

A graph-related problem. The statement makes you sure that the given graph is connected and contains one (and exactly one) cycle. What you have to do is to compute the distance, in number of edges, from all vertexes to the cycle (print 0 for the vertex that are in the cycle. We will call these vertexes 'in-cycle').

First, let's find the cycle and find the vertexes whose answer is 0. The cycle can be found with a regular Depth-First-Search (DFS), storing the fathers of the vertexes. Notice that, during the search, there will be exactly one back edge, say (vi, vj). When this edge is found, iterate from vi to vj (using the father array) and label the vertexes as 'in-cycle'.

After that, let's compute the answers for the other vertexes. One could "compact" the graph by merging all the 'in-cycle' vertexes into a single vertex. Then, just do another search starting by this vertex and compute the distances, knowing that the distance of a vertex vi is the distance of father[vi] plus one.

Also, it's also possible to do as many searchs as the number of 'in-cycle' vertexes if you don't consider others 'in-cycle' vertexes during the search. The running time would still be O(n + m), that, in this problem, is O(n + n) = O(n).

Problem E

Let's first consider that the queens can only attack the other pieces standing in the same line - the case with the columns and both diagonals will be analogous.

Let line[i] be an array that will store all the queens that are in the i-th line on the chessboard. Since it's indexed by the line number, it's only necessary to store the column number of the pieces. So, for example, if we have queens at positions (4,6), (4,8) and (6,5), we will have line[4] = {6,8} and line[6] = {5}.

To check if the queen at position (i,j) is attacking someone in its line, you must check if there is some number greater than j and/or less than j in line[i]. To do that, presort line[i] and binary search j in it. Notice that j will always be successful found by the search. Notice also that there will be some number greater than j iff the found element is not the last one of line[i]. The same applies for the other case: check if j is not the first element of line[i]. If j is not the first nor the last element, the queen is attacking 2 pieces in its line. If j is the only element, the queen is attacking no one, and it's attacking 1 piece otherwise.

Do the same thing (compute all column[i], sort them and, for each queen, binary search) to the column, to the "/" diagonal, and to the "\" diagonal. Remember that a piece at position (i,j) is at the diagonals i+j and i-j. Like in problem B, use an offset to handle the negative numbers in the last case. Store the line number in the column[i] array. There's no different in witch index (line or column) to use in the diagonals arrays (but, of course, use the same chosen index for everyone).

It seems that the sorting part of the algorithm will run in O(n*n*logn) time, since we have O(n) lines, columns and diagonals. However, the sum of the sizes of all these arrays will be m, the numbers of queens. So the running time will be actually near O(m*logm). Binary searching for every queen will take less than O(m*logm), too.

UPD: nab said in the comments that an easier solution can be correctly done in O(m) time. Thank you!

Problem F

The main idea is to, for each pair of lines i1 and i2, count the ways you can form the rectangle using a sweep line-like algorithm. The idea is similar to the somewhat classic idea used for the problem that is, given an array of numbers, count how many contiguous sub arrays exists witch sum is equal or greater to some given k.

Let's first of all identify all the points where a star can be found, in its "starting" position and "finish" position. These are the S and F position shown below.

  1S1F  1

For each pair of lines i1 and i2 (i2 > i1) we will keep two indices (or pointers) j1 and j2 for the columns, with j2 > j1. During the algorithm, we will always analyze the rectangle formed by lines i1,i2 and columns j1,j2. Let's start with j1 = 0 and j2 = 2 (there won't be any star in the rectangle  i1,i2,0,(0 or 1) simply because a star won't fit in it). Let's then count the number of stars found in this rectangle. It will be equal to countfinish(i1+1,i2-1,j2), where countfinish(I1,I2,J) is the number of "finish"positions in the column J between the lines I1 and I2. If this number is equal or greater than k, this rectangle and all the rectangles (i1,i2,j1,j) for j >= j2 will be valid, so you need to sum m-j2 to the answer. Then, increment j1 and recalculate the numbers of stars in the rectangle. It will be equal to the previous number minus countstart(i1+1,i2-1,j1-1), (the definition of countstart() is analogous) since it's the number of starts that are "lost" when we move from j1-1 to j1. Check again if the new number is greater or equal than k and repeat the process until the number is less than k. Notice that j1 will always be less than j2, since a star needs 3 columns to exists.

Then, increment j2 and, without changing the value of j1, repeat the process. Notice that this part of the algorithm will take O(m)*T time (where T is the time needed to calculate countstart and countfinish), since both j2 and j1 will "walk" in the columns only one time.

A trick can be made to make T = O(1). For each column j, precompute an array countstart[j], where countstart[j][i] = countstart[j][i-1] + (1 if (i,j) is a "starting" position, 0 otherwise). To compute countstart(I1,I2,J), just use the formula countstart[J][I2] - countstart[J][I1-1], that gives the value in constant time. Do the same with countfinish.

Precomputing countstart and countfinish takes, for each column, O(n) time, so all the precomputing can be done in O(n*m) time. Since we use an O(m)*O(1) = O(m) time for O(n2) pairs of lines, the total time used for the algorithm is O(n*m) + O(n2*m) = O(n2*m). A bit high for n=m=500, but the time limit for this problem was higher than the usual too (5 seconds instead of 2).

Codeforces Beta Round #94 EditorialBy gen, 11 years ago, In RussianDivII A. ПеченькиСамый лёгкий способ решить задачу — сперва посчитать всю сумму чисел, и затем посчитать количество чётных разностей между этой суммой и каждым числом. Однако маленькое наблюдение позволит написать решение немного эффективней: помимо суммы (sum) посчитаем также, сколько среди данных чисел есть чётных (even) и нечётных (odd). Тогда, если сумма нечётна, то ответ — odd, иначе — even. Время O(n), память O(1).

DivII B. Шнурки и шестиклассникиМаленькие ограничения позволяют нам написать решение «в лоб». Будем хранить данный граф в матрице смежности, и симулировать происходящее. Также будем хранить степень каждой вершины отдельно, чтобы быстро находить детей, которые связаны только одним шнурком. Тогда при каждой итерации удаляем все вершины со степенью 1 и все грани, которые соединяются с этими вершинами; продолжаем до тех пор, пока не останется таких вершин. Ответом будет количество произведённых итераций. Время O(n3), память O(n2).

DivII C / DivI A. СтатуиПроизведём симуляцию падения статуй. При каждой итерации будем сдвигать все статуи на одну клетку вниз. Перед каждым ходом (итерацией) будем получать список всех полей, куда Маша может пойти (до того, как статуи передвинутся на одну клетку вниз), используя список тех полей, куда она могла придти с прошлого хода (единственное, из полей с прошлого хода можно использовать только те, в которые после конца прошлого хода не переместилась статуя). Логично, что через 8 любых ходов на доске не останется ни одной статуи. Поэтому, если список  доступных Маше полей после 8-ого хода не пуст, то она может добраться до Ани, потому что дальше её ходы ничто не ограничивает. Время O(9· 83) = O(1), память O(82) = O(1).

DivII D / DivI B. СтрокаВначале ликвидируем случай невозможности — такой строки нет, если k больше, чем количество подстрок, т.е. , где n — длина строки.

Теперь заметим, что для каждой буквы мы можем быстро оценить, сколько подстрок начинаются именно с этой буквы. Действительно, если буква стоит на позиции i (нумеруя с 1), то количеством подстрок, начинающихся с позиции i, является n - i + 1. Тогда количество строк, которые начинаются с конкретной буквы, будет сумма всех таких значений для позиций, в которых стоит эта буква.

Далее, используя найденную информацию, не сложно выяснить, с какой буквы будет начинаться нужная подстрока (потому что в слове при лексикографическом сравнении буквы слева важнее, чем буквы справа). Теперь заметим, что тоже самое рассуждение мы можем применить и для следующей буквы нужного слова, только теперь нужно проверить только такие буквы, которые следуют после первой буквы слова. Таким образом, мы повторяем итерации и для 3-ей, 4-ой, ... букв до тех пор, пока не найдём нужную строку. Чтобы не искать каждый раз нужные позиции, будем хранить их отдельно; при каждой итерации сдвигать их на одну позицию направо и исполнять алгоритм только для них, а после нахождения i-того символа убирать те позиции, буквы в которых не равны с найденным символом. Время благодаря k ≤ 105 не квадратичное (самому ещё не получилось доказать), память O(n).

Также задачу можно было решить с помощью хэшей или суффиксного массива.

DivII E / DivI C. Игра с прямоугольникамиРассмотрим все левые и правые границы всех k внутренних прямоугольников, вместе их 2k. Присвоим им произвольные 2k координат между левой и правой стороной данного прямоугольника, это можно сделать  способами. То же самое сделаем и с верхними и нижними границами, это можно сделать  способами. Заметим, что каждая пара таких размещений однозначно определяет одно искомое расположение, и все такие расположения можно определить одной парой размещений. Поэтому ответом является . Так как n и m не больше 1000, то коэффициенты можно посчитать с помощью треугольника Паскаля (не забывая вычислять по данному модулю). Время O(max(n, m)2), память O(max(n, m)2).

DivI D. ЧислаУ меня эта задача ассоциировалась с атомами и молекулами. :) Представим, что каждое из чисел имеет две связи, где связь соединяется с другой по заданным правилам. Тогда решение существует тогда и только тогда, когда все связи соединены, и из каждого элемента по связям можно дойти до любого другого элемента; также решения не существует, если присутствуют числа x, x + 2, но x + 1 не присутствует.

Пусть у нас есть числа a, a + 1, ..., b, тогда количество связей у них 2|a|, 2|a + 1|, ..., 2|b|, где |x| — количество чисел x. Ясно, что 2|a| связей от 2|a + 1| «съедают» элементы a. У a + 1 свободными остаются p = 2|a + 1| - 2|a| связей. Аналогично, эти p связей соединяются с a + 2 элементами и т.д. В конце концов, если у b - 1 свободными остаются q связей, то должно быть q = 2|b|, чтобы завершить цепочку. Остаётся только проверить все эти соотношения (учитывая то, что цепочку нельзя завершить раньше, чем не истрачены все связи — то есть, вычисляемый p не может быть 0). Время  (т.к. данные числа нужно отсортировать), память O(n). Для простоты вычислений можно ещё заметить, что 2|a| можно заменить на |a|, из-за этого ничего не изменится.

DivI E. День рожденияСм. хороший разбор здесь.

Editorial for Codeforces Beta Round #93By Ripatti, 11 years ago, translation, In Englishdiv2 A. In this problem you should find length of polyline, multiply it by k / 50 and output that you will recieve. Length of polyline is sum of lengths of its segments. You can calculate length of every segment using Pythagorean theorem: .

div2 B. Idea of this problem was offered by RAD. It was the last problem in the problemset and I had no any easy idea:) I thank him for it.

Here you should calculate an array cnt[100]. i-th element of it stores number of sticks whose lengths equal i. Now you should calculate number of pairs of sticks of equal lengths. This number is , where [x] is floor of x. For every frame you need 2 if such pairs and you can choose it in any order. Therefore the answer will be z = [k / 2].

div2 С. div1 A. At the first you should consider cases when t0 = t1, t0 = t2 and t1 = t2. Answers will be (x1, 0), (0, x2) and (x1, x2). The last 2 of them didn't present in the pretests.

Next, for all 1 ≤ y1 ≤ x1 you should find minimal y2, for that t(y1, y2) ≥ t0. You can do it using one of three ways: binary search, two pointers or just calculation by formula [y1(t0 - t1) / (t2 - t0)], where [x] is rounding up of x. You should iterate over all cases and choose one optimal of them.

The last tricky case consists in the fact that for all 1 ≤ y1 ≤ x1 и 1 ≤ y2 ≤ x2 t(y1, y2) < t0. For example, you can see following test

100 110 2 2 109 (it is the 6th pretest).

In this case you should output (0, x2).

All calculations should be done in 64-bit integers (8th pretest checks overflow of 32-bit integers) or very carefully in the real numbers.

div2 D. div1 B. 

Let us calculate a prefix-function for all prefices of string. Prefix-function p[i] is maximal length of prefix that also is suffix of substring [1...i]. More about prefix function you can see in a description of Knuth-Morris-Pratt algorithm (KMP).

The first of possible answers is prefix of length p[n]. If p[n] = 0, there is no solution. For checking the first possible answer you should iterate over p[i]. If at least one of them equal to p[n] (but not n-th, of course) - you found the answer. The second possible answer is prefix of length p[p[n]]. If p[p[n]] = 0, you also have no solution. Otherwise you can be sure that the answer already found. This substring is a prefix and a suffix of our string. Also it is suffix of prefix with length p[n] that places inside of all string. This solution works in O(n).

Also this problem can be solved using hashing. You can find hash of every substring in O(1) and compare substrings by comparing thier hashes. Well, let's check for every prefix that it is a suffix of our string and store thier lengths into some array in the increasing order. Then, using binary search over the array, you can find maximal length of prefix that lie inside of string. Check of every prefix you can do in O(n). So, you have some  solution.

In point of fact, the array of prefix lengths in the previous solution is list { p[n], p[p[n]], ... }, that written if reversed order. From the first solution you know that the answer is prefix of length either p[n], or p[p[n]] (if it exists, of course). Therefore some naive solution without binary search can fits in the limits if you will stupidly check all prefices in the order of decrease thier lengths:) This solution works in O(n).

Also this problem can be solved using z-function.

div2 E. div1 C. You can see that every command i, j you should do no more than once. Also order of commands doesn't matter. Actually, sequence of command you can represent as boolean matrix A with size n × n, where aij = 1 mean that you do the command i, j, and aij = 0 mean that you don't do it.

Let us describe one way to construct the matrix.

Let the starting image is boolean matrix G. A boolean matrix B of size n × n stores intermediate image that you will recieve during process of doing commands.

For the upper half of matrix G without main diagonal you should move line by line from the up to the down. For every line you should move from the right to the left. You can see that for every positions all nonconsidered positions do not affect the current position. So, if you see that values for position  i, j in the matrices G and B are different, you should do command i, j: set in the matrix A aij = 1, and change segments (i, i) - (i, j) and (j, j) - (i, j) in the matrix B.

For the lower half of the matrix G without main diagonal you should do it absolutely symmetric. At the end you should iterate over main diagonal. Here it should be clear.

Well, for matrix G you always can build matrix A and do it by exactly one way. It mean that this way requires minimum number of commands. So, you can get answer for problem by following way: you can build the matrix A from the matrix G and output number of ones in the matrix A.

There is only one problem that you should solve. Algorithm that you can see above works in O(n3), that doesn't fit into time limits. Let's speed up it to O(n2). Consider in the matrix B the upper half without main diagonal. During doing commands all columns of cells that placed below current position will have same values. Values above current position are not matter for us. Therefore instead of the matrix B you can use only one array that stores values of columns. It allows you do every command in O(1) instead of O(n). This optimization gives a solution that works in O(n2).

div1 D. Let us represent a number in the Fibonacci code. You can imagine Fibonacci coding by following way: i-th bit of number corresponds to the i-th Fibonacci number. For example, 16=13+3 will be written as 100100. You can represent into this code any positive integer, for that no two neighbouring 1-bit will be present. It is possible to do it by only one way (let's define this way as canonical). In the problem you should calculate a number of ways to represent some number into Fibonacci code in that two ones can be placed in the neighbour positions.

You can easily get the canonical representation if you generate several of Fibonacci numbers (about 90) and after that try to substract all of them in the decreasing order.

You should store positions of 1-bits of canonical representation into an array s in the increasing order. You can decompose any of them into two ones. It looks like that:

1000000001 // starting number;0110000001 // there we decompose0101100001 // the first "one"0101011001 // using all0101010111 // possible ways

After some number of such operations you will meet next 1-bit (or the end of number). This 1-bit also can be decomposed, but it can be "shifted" by only one bit.

Let us dp1[i] is number of ways to represent a number that consists of i last 1-bits of our number in the case that the first of 1-bits are NOT decomposed. Also let us dp2[i] is number of ways to represent a number that consists of i last 1-bits of our number in the case that the first of 1-bits are decomposed.

You can easily recaclulate this dp following way

dp1[0] = 1, dp2[0] = 0dp1[i] = dp1[i - 1] + dp2[i - 1]dp2[i] = dp1[i - 1] * [(s[i] - s[i - 1] - 1) / 2] + dp2[i - 1] * [(s[i] - s[i - 1]) / 2]where [x] is rounding down.

Answer will be dp1[k] + dp2[k], where k is total number of 1-bits in the canonical representation. So, we have  solution for one test.

div1 E. Consider all partitions of 7 × 8 board into dominoes. There is only 12988816 of them (you can get this number using some simple bruteforce algorithm)

Also, consider all "paintings" of 7 × 8 board (i.e. number of cells of every color) and find number of patritions into set of pills of 10 types for every of them. In the worst case you will get 43044 partitions (this number you can get using another bruteforce algo).

In the first part of solution you should iterate over all partitions of board into dominoes and find all sets of pills that you will get. You will have no more than 43044 of them.

In the second part of solution you should try to distribute all available pills for every of sets that you recieved in the first part. You should distribute them in such way that maximal number of colors match.

You should build a graph that composed from 4 parts - source, the first part of 10 nodes, the second part of 10 nodes and sink. There are edges between all pairs of nodes from neighbour parts. From source to the first part you should set capacities of edges equal to numbers of available pills of every type. From the second part to sink you should set capacities of edges equal to numbers of pills in the current partition. From the first part to the second part you should use infty capacities and set costs equal to number of MISmatched colors in the types of pills (it is some numbers in range from 0 to 2). At the end, you should find maximal flow of minimal cost (MCMF) if this graph and save a flow that gets minimal cost.

In the third part of solution you should restore answer from optimal flow.

In the second part of solution you can replace MCMF by usual maxflow. You can see that at the beginning MCMF will fill edges of cost 0. So, you can fill them by hand. After that you can drop all edges of cost 0 and 2 and just find maxflow.

Complexity of solution is difficult, but it is clear that this solution fits into limits. The first jury solution in C++ that was written carelessly works in 1 sec. Some more clever solutions works in 0.4 sec, but you can write something more faster.

Codeforces Beta Round #92 - AnalysisBy aropan, 11 years ago, translation, In EnglishDiv-2. 124A - The number of positionsLet's iterate through the each item and check whether it is appropriate to the conditions a ≤ i - 1 and n - i ≤ b (for i from 1 to n). The first condition can be converted into a + 1 ≤ i, and the condition n - i ≤ b in n - b ≤ i, then the general condition can be written max(a + 1, n - b) ≤ i and then our answer can be calculated by the formula n - max(a + 1, n - b) + 1.The author's solution

Div-2. 124B - PermutationsLet's try all possible ways to rearrange digits in the numbers and check the difference between maximum and minimum number.The author's solution

Div-1. 123A - Prime PermutationDiv-2. 124C - Prime PermutationAll positions except the first and those whose number is a prime greater |s| / 2 have to have the same symbol. Remaining positions can have any symbol. Consider positions that should be the same for p = 2 is 2,4,6,8 ... Now let's take a position with the number x ≤ |s| / 2, this position should have the same character as the position of 2 as the symbol x must be equal to the character at position 2 * x, which is equal to the character at position 2. Now consider the position whose number is more than |s| / 2. If this position is not a prime then there is a prime number p to divide the number at our positions and p ≤ |s| / 2. So character at position p is equal the character at position 2 and so a symbol at our position is also consistent to the character at position 2. The remaining positions are not combined with any other positions so it does not matter which symbol is situated here.Let's find the symbol which occurs the most and try to place the symbol on the position in which the characters have to be equal. If this symbol for all positions is not enough then the answer will be "NO", otherwise arrange the remaining characters by any way at other positions.The author's solution

Div-1. 123B - SquaresDiv-2. 124D - SquaresLet's turn the field on 45o transforming cells coordinates (x, y) in (x + y, x - y). Then the cell (x, y) will be bad if one of the conditions occurs x ≡ 0 (mod 2a) or y ≡ 0 (mod 2b). So good cells will be divided into sectors by vertical and horizontal lines. For each sector, it is possible to determine the coordinates of a pair of numbers, the first number that will rise during the transition to the next right sector, and the second pair number will increase during the transition to the next upper sector. From the sector with coordinates (x, y) can go to any nearby on the side of the sector, visiting at least one bad cell, ie in (x - 1, y), (x + 1, y), (x, y - 1) and (x, y + 1). Since the numbers 2a and 2b have the same parity, then from the sector (x, y) can also go to the sector on the diagonal, and visiting a bad cell, ie in (x - 1, y + 1), (x + 1, y - 1), (x - 1, y - 1) and (x + 1, y + 1). Then it turns out that the minimum number of bad cells, which should be visited on the way out of from the sector (x1, y1) to sector of (x2, y2) equals max(|x1 - x2|, |y1 - y2|).Let's transform the coordinates of the initial and final cells as described rule above. Then find sectors which contain our cells and calculate answer with formula above.The author's solution

Div-1. 123C - BracketsDiv-2. 124E - BracketsLet's reduce the problem to a one-dimensional matrix. Consider a monotonous path (1, 1), (1, 2), ..., (1, m - 1), (1, m), (2, m), ..., (n - 1, m), (n, m) which has correct bracket sequence. Now, in this way a cell (1, m) can be replaced on (2, m - 1) and still be a monotonous way and will form the correct sequence of the bracket. So in the cells of (1, m) and (2, m - 1) is one type of bracket. Proceeding further (eg to replace (1, m - 1) on (2, m - 2) or (2, m) on (3, m - 1)) can be seen that in cells (i, j) and (i - 1, j + 1) is one type of bracket. Then we get not two-dimensional array n × m, a one-dimensional size n + m - 1. For each position can be determined what her highest priority, ie for cell i (1 ≤ i ≤ n + m - 1), the priority will be equal to the minimum value of px, y where 1 ≤ x ≤ n, 1 ≤ y ≤ m and x + y - 1 = i.Let's iterate through the positions, starting with the highest priority. Let's put in this position the bracket "(" and consider how many ways can complete the remaining brackets to get the correct bracket sequence. If the number of ways of not less than k, then leave in this position "(", or reduce the k on the number of ways and put in this positions bracket ")". And so let's iterate through all items. In order to calculate the number of ways each time dynamics is calculated on two parameters fi, j, where i is the number of processed positions, and j is the number of opened brackets. If the position of i + 1 bracket is not defined yet then you can go to fi + 1, j + 1 or fi + 1, j - 1, if defined then only fi + 1, j + 1 or only fi + 1, j - 1, depending on opening or closing bracket respectively.The author's solution

Div-1. 123D - StringSort all suffixes of the string (denoted by an array of strings ci). Then the answer to the problem is the amount of 1 ≤ i ≤ j ≤ |s| and 1 ≤ k, that the prefixes of length k in all ci..j are equal. Options when i = j, and 1 ≤ k ≤ |ci| can calculate at once, it is the number of substrings in the string, ie |s| * (|s| + 1) / 2. Now let's count the LCP (longest common prefix) for adjacent suffixes, ie ai = LCP(ci, ci + 1) for 1 ≤ i < |s|. Then let's count the number of 1 ≤ i ≤ j < |s| and 1 ≤ k, that k ≤ min(ai..j). This task is to count the number of rectangles if there is a limit to the height of each column, ie ai the maximum height of the rectangle in the column i. Solve by a stack or list.The author's solution

Div-1. 123E - MazeConsider what is the expected value for a given entrance and exit vertexes. It is clear that there will be only one path from the entrance to the exit, which in any case will be passed. Also, you can still go in the wrong direction. Consider the case when the chosen vertex from which there is k false paths and one right (it is always). Then before going in the right direction it can be 2k equiprobable way around false paths. Every false way occurs the 2k - 1 ways and to increase the number of moves in 2 ×  < amount of vertexes in false subtree >  ie expectation of a false path to increase by 2 ×  < amount of vertexes in false subtree >  × 2k - 1 / 2k =  < amount of vertexes in false subtree > . Then expectation in vertex is equal to sum of  < amount of vertexes in false subtrees >  + 1 (a move in the right direction) + expectation of the vertex if to go the right direction. The result is that the expected value equal to the number of edges reachable from the entrance, without passing through the exit.Let's run dfs and consider of the vertex as exit vertex. Then, if in some subtree defined entrance, the expected value equal to the size of the subtree. Calculate how much of each subtree is the number of entrance and calculate the number of moves, if the exit is in the current vertex. It is necessary not to forget to count cases where the current vertex is an exit and entrance is higher in the tree traversal.The author's solution

Codeforces Beta Round #91 - AnalysisBy witua, 11 years ago, translation, In English1. Lucky Div (Div2 A)

In this problem you just need to loop through the integers i from 1 to n determine, is i lucky, if yes, then try, if n mod i = 0, then answer is "YES". If there are no such i, answer is "NO".

2. Lucky Substring (Div2 B)

Notice, that answer is either one digit or -1. So, if there are no 4 and 7 digits, then answer is -1. Else, if there is more or equel number of digits 4, then answer is 4, else answer is 7.

3. Lucky Sum (Div1 A + Div2 C)

Let generate all lucky number between 1 and 1010. Consider all segment [1;L0], [L0 + 1;L1], [L1 + 1;L2] ... Then the result equals to product of intersection of segments [1;L0] and [1;n] by L0 plus size of intersection of [L0 + 1;L1] and  [1;n] multiplied by L1 and so on.

4. Lucky Operation (Div1 B + Div2 D)

Notice, that if there exits such i that i mod 2 = 0 and di = 4 and di + 1 = 7 and di - 1 = 4 then after that operation there will be a loop. So, let we simple do all operation from left ro right, and, when we will win our loop, just return a rusult (which variates by k mod 2 (k is one that leaves after operation from left side).

5. Lucky Permuation (Div1 C + Div2 E)

If n ≤ 14 let find out, is k more than n! or not? If yes, then return -1. Then, notice, that since k ≤ 109, then at most 13 elements from right (suffix) will change. So, element from left of this part (prefix) will not change (then we can just find a number of lucky numbers on than range). To find result for the rest of the permutation (suffix) we need to find k-th permutation of number from 1 to t (t is maximun integer, such that t! ≤ k). After we find that permutation, we can just loop through that permutation and count result.

6. Lucky Segments (Div1 D)

Lei calculate arrays L and R. Let for all lucky i, L[i] = number of operation needed to move every segment, which's right end is to left from i to i. R[i] = number of operation needed to move every segment which left end is to right to i. How to calculate such array? Just use a sorting. Let arrange array A of pairs of integers, first - number, second equals to 0, if that number end of some segment, 1 if that number is lucky. Then, iterate from left to right, counting number of segment end we counted and si, si = si - 1 + (Ai - Ai - 1) * ci. The same way you can use to R. Now, to find the answer we must find (using method of two pointers of binary search) pair of indexes x and y, such that  i ≤ j, Lj + Ri ≤ k, Luckyj - Luckyi + 1 ≤  min_size_of_input_segment. Also, is this problem you should arrange function Mul(a, b), which return min(a * b, INF). Since simple multiplication overflows, then you can use multipling modulo 264 or double or min-long-arithmetic.

7. Lucky Array (Div1 E)

In this problem you can use many different algorithms, here is one of them. Obviously, number of different lucky number is 30, because Ai always is  ≤ 10000. Let Di - difference between minimum lucky number which is greater than or equal to Ai and Ai. Now, we need to have 5 (but you can use less number) of operation on D: Subtract(l, r, d) - subtract number d from all Ai (l ≤ i ≤ r), Minimum(l, r) - minumum number of all Di (l ≤ i ≤ r), Count(l, r) - how many times that minimum occared in that interval, Left(l, r) = leftmost occarence of that minimum, Set(i, d) - assign d to Di (Di = d). Now, we can do our operations. If our operation is "count", then we need to find minimum number d (d =  Minimum(l, r)), if it is equal to 0, then answer is Count(l, r, 0), otherwise, answer is 0. If out operation is "add", then we need to Subtract(l, r, d), but now some Di might be less than 0. So, while, Minimum(l, r)  ≤ 0, let j = Left(l, r), assign Dj new value (use Set(j, Dj')), which can be calculated with complaxity O(1).

Complexity of this algorithm is O(m * log(n) + n * log(n) * C), where C is equal to 30.

Codeforces Beta Round #90 (editorial)

By Serega, 11 years ago, translation, In EnglishProblem A. Epic Game.

Author's solution: http://pastebin.com/zRiQwy6u

It's enough just to model the described game to solve this problem. You can search a greatest common divisor in any reasonable way.

Problem B. Before Exam.

Author's solution: http://pastebin.com/kBjCwiiD

Let's consider solution of the task for maximum level of profience (for minimum level solution is similar). It's clear that maximum level can be reached either in a card that has fallen one somebody's lot already or in a card about that we know nothing. In the first case we can just calculate levels of profiency for all cards from input and choose maximal level. The second case is more tricky. Let's sort all the theorems that weren't mentioned in cards from input in order of non-increasing of profiency's level. It's obvious that sought-for card consists of first  theorems in sorted list. This case is possible if the number of different cards mentioned in input is stictly less than k. For example, in the test

3 21 2 3212

we can't consider a card containing third theorem because both examination cards are already known.

Problem C. Education Reform

Author's solution: http://pastebin.com/eZhJYGpC

This problem can be solved by dynamic programming. Let's sort all subjects in order of complexity's non-increasing. Let d <  / span > [ < spanstyle = "" > i <  / span > ][ < spanstyle = "" > j <  / span > ][ < spanstyle = "" > z <  / span > ] is the greatest summary number of exercises, that can be given, if timetable contains exactly z subjects from among of first i subjects (in order of sort), involves ith subject and number of exercises in ith subject is equal to ai + j. Recurrent correlations are based on search of subject that will occupy ( < spanstyle = "" > z <  / span >  - 1)th day in timetable.

For restoration of answer you should save source numbers of subjects.

Asymptotic complexity is O(m2·n·max(bi - ai)).

Problem D. String Transformation

Author's solution: http://pastebin.com/puGK1WYh

If lengths of input strings aren't equal, we can at once output "-1 -1" and complete execution of a program. Otherwise let number n is equal to the length of input strings.

Let's iterate through the number i. We should find (in O(1)) the such smallest number j, that substing b[0... n - i - 1] can be represented as a[i + 1... j - 1] + r(a[j... n - 1]). In order to do that, let's calculate the prefix function (p[i]) for string s1 = r(a) + ' 0' + b and z-function (z[i]) for string s2 = b + ' 0' + a. It's clear that for fixed i value of j is equal to n - p[2n - i - 1], and substrings a[i + 1... j - 1], b[0... j - i] must coincide at that (1). The last condition can be easily verified through using of calculated z-function. You can also trivial prove the next statement: if the property (1) is not satisfied by fixed i for the chosen j, then it will not meet for bigger j.

Asymptotic complexity is O(n).

Разбор задач. Codeforces beta round #89.By Alexander, 11 years ago, translation, In EnglishEditorial.

Task A.

First problem only is realization. In need read input string, delete all uppercase and lowercase vowels letter and print answer.

 

Task B.

Second problem is realization too. Good solution to calc count space in beginning of string. In handkerchief pattern there is 2 * n + 1 rows. In rows form 0 to N number of space is 2 * n – i. In rown number from N + 1 to 2 * N number of space is (I - N) * 2.

 

Task C.

In this task it need to find a minimal sum that to find a beautiful number of car. So, there are only 10 available digits. Let us try the minimum cost to have one of those digits repeat at least K times and the lexicographically minimum string that has such cost. Then we pick the best result among all digits. Therefore, we divide the task into subtasks and solve it for each digit separately. To spend the least amount of money and make the maximum number of substitutions for each digit it need replace all the numbers are different from her first modulo 1, then modulo 2, then modulo 3 and etc to increase the module, in this and only this if typed in the sum will be minimal. Of course, if produced the right number of substitutions of K, then the algorithm should stop. However, to get the lexicographically smallest string with K digit C, then the replacement should be performed as follows. Suppose that this step of the algorithm need to change all the numbers that are different from the numbers with modulo I, first time it need replace all digits C + I for digit C from begin to end of string. Second time it need replace all digits C – I for C for end to begin of string, because in need to lexicographically minimum one.After choosing the best answer will be 10 rows. Thus, the asymptotic complexity of the algorithm is 10 * 10 * n.

 

Task D.

The problem is solved lazy dynamics. Let z[n1] [n2] [2] - a number of ways to place troops in a legion of Caesar. Indicate the following parameters, n1 – is a number of footmen, n2 – is a number of horseman, the third parameter indicates what troops put Caesar in the beginning of the line. If Caesar wants to put the footmen, the state dynamics of the z [n1] [n2] [0] go to the state

z [n1] [n2 - i] [0], where 0 <= I <= min (k2, n2) . If Caesar wants to put the riders, the state dynamics of the z [n1] [n2] [1] go to the state z [n1] [n2 - i] [1], where 0 <= I <= min (k2, n2) .

 

 

Task E.

We are given an undirected connected graph, it is necessary to orient its arc so as to obtain a strongly connected directed graph. There is theorem (on a theoretical basis for a written task) that a graph admits an orientation to a strongly connected digraph if and only if every edge is part of what a cycle.

To test this, simply run the bfs to the depth of any vertex and orient the edges in the direction of the bfs. The result of this procedure is an orientation of the graph. To make sure that in the original graph has no bridges, it need to take the orientation of the resulting graph, change the direction of arcs in it, and check that there remains a strong connection. This may be check by dfs too.

Codeforces Beta Round #88 (Editorial)By Gerald, 11 years ago, translation, In EnglishProblem A.Consider three cases.s = f, ans = t.s < f, we must find the smallest non-negative k such, that t ≤ (s - 1) + 2(m - 1)k. ans = s - 1 + 2(m - 1)k + (f - s).s > f, similarly, we must find the smallest non-negative k such, that t ≤ 2(m - 1) - (s - 1) + 2(m - 1)k. ans = 2(m - 1) - (s - 1) + 2(m - 1)k + (s - f).We can find k in any reasonable manner, for example, by using formulas of integer division.

Problem B.Suppose, that the first player made a move x ≤ a, then consider the remainder rem = x· 109%mod. Obviously, if (mod - rem)%mod ≤ b, then the second player can win. Thus, we must iterate through all relevant values of x (we don't need iterate through more than mod values) and check whether the second player to win. If there exist a losing move for second player, then won the first, else second. Since we iterate through all relevant moves of the first player, then we can easily determine his winning move (if such move exist).

Problem С.Approval. If the tournament has at least one cycle, then there exist a cycle of length three.

A constructive proof. Find any cycle in the tournament by using any standard algorithm, such as depth-first search. If there is no cycle, then output -1, else choose any three consecutive vertices of the cycle v1 v2 v3 (Av1, v2 = Av2, v3 = 1). Since given graph is a tournament, then there is an edge (v3, v1), or there is an edge (v1, v3). The first of these two cases, we find immediately the cycle of length three of the vertices v1 v2 v3,  the second, we can reduce the length of the loop (erase vertex v2). 

We can reduce the length of the cycle until we find a cycle of length three.

Problem D.Imagine a recursion tree our transformation F. This tree is binary. We write on the edges leading into the left subtree, zero, and on the edges, leading to the right, one. Now consider the path of some number a (hereafter, we assume that we substracted one from all numbers in the array over which we make the conversion). This path start in the root of the tree and end in some leaf, and numbers written on the edges of the path is exactly bit representation of a in order from least significant bit to the most significant bit.

Construct the recursive function which solve our problem, similar to how we carry out a query to the segment tree. Here is the prototype of this function.

solve(idx, tl, tr, l, r, u, v)

This function returns the answer to the query (l, r, u, v), if we consider only subtree with positions [tl, tr], while on the path from the root to the subtree is written bit representation of idx. If l ≤ tl ≤ tr ≤ r, then we calculate answer by formulae, else we divide our segment of positions and return sum of answers from left and right part.

As described above, the answer to the whole subtree is a formula. Here you need to use the fact that all the numbers in the subtree have the form k· 2depth + idx, where depth - depth of subtree. We must find k such, that u ≤ k· 2depth + idx ≤ v and then calculate the sum of  appropriate numbers.   

Asymptotics of this solution O(m· log(n)· (formulae - for - whole - subtree)). We can calculate formulae for whole subtree in O(logn).

Problem E.In this problem, suggested a solution using heavy light decomposition. Graph, given in problem statement, is a cycle, on which are suspended trees. For each tree construct the data structure (heavy light + segment tree), which can perform change on the path from some vertex to any parent, and to maintain the amount of ones. The same structure we use for the cycle. 

Suppose, that we have no cycle, i.e. there is just a bunch of trees (forest). Then the amount of switched-on edges uniquely determines the number of connected components (each switched-on edge decrease the amount of components by one). 

Suppose, that we have only the cycle. Then, similarly, the amount of switched-on edges uniquely determines the number of connected components.

We will maintain the amount of switched-on edges in the cycle and in the all trees. So, the answer to the problem Compscicle + Compstrees - CntCicle, where Compscicle - the amount of connected components in cycle, Compstrees - the amount of connected components in all trees, CntCicle - the amount of vertexes in cycle.

(Google).

Codeforces Beta #87 EditorialBy dolphinigle, 12 years ago, In EnglishTime Capsule Remarks (planted before the contest)

Due to popular demand, today's problem statements are made to be as short as possible without too many (but existing!) embellishment. All of them are thinking-based problems (i.e., implementation is the easier of the two) - so I'm generally happy with the problems :). I hope nobody found them to be too easy :S

As you may have noticed, we decided not to give devastatingly weak pretests. I guess it's just really evil to give weak pretests for my first match.

And so, the editorial begins...

Remarks

I'm sorry - but I don't have access to my usual graphic editing tool and so, the graphics are fairly limited :) (Example: Lawnmower's pictures must be the ugliest lawnmower I have ever seen! (Is it even a lawnmower?) Not to mention I don't look like the actor at all...)

D2-A: Tram

If we know the number of people inside the tram at all possible time, then the answer is the maximum of such. We observe that the number of people inside the tram changes only at tram stops. The conclusion is that the answer will be the maximum of the number of people inside the tram directly before arriving at a particular stop and directly after leaving a particular stop (the more observant readers can notice that using only one of these is sufficient).

It's sufficiently easy to calculate the number of people inside the tram directly before and after leaving a tram stop.

D2-B: N Little Pigs

No... not maximum matching ;)

So, an equivalent less-evil rewording of the problem would be: "Return the number of wolves that are adjacent to at least one pig".

To see this, since each pig has at most one wolf adjacent to it (the constraints impose that) we don't need to worry at a single pig may get eaten by two different wolves. Hence, each wolf can eat any of the pig adjacent to it.

Remarks

It's more interesting to reverse this problem isn't it:

Each pig will be adjacent to at most one wolf

becomes

Each wolf will be adjacent to at most one pig

Can you solve this one? (Of course, not using network flow mind you ;) - that's overkill)

D2-C / D1-A Party

We let an employee without a manager called as root. There's an edge from a manager to an employee that he/she manages.

First notice that the graph is a collection of directed trees. Hence, we can assign a depth label to each node - denoting the number of nodes on the simple path from the root to it. The answer is then the maximum depth a node has.

Why?

First, the answer is bounded below by this number because any pair of employees in this path cannot be in the same group. Second, since the graph is a tree, each node in the graph has a unique depth label assigned to it. Simply put all nodes with the same depth in the same group. It's fairly easy to see that no one will be the superior of another within a group, for otherwise their depths will not be equal.

Remark

You might notice that there exist an O(N) implementation of the above algorithm, yet the constraint is 2000. Well, this problem was swapped with the D1-B because the previous D1-A was thought to be harder than expected. And so, in the process, we also decrease the constraint for N from 200,000 to 2,000. I hope you like it :)

D2-D / D1-B: Lawnmower

First, let's observe a particular strategy that turns out to be optimal at the end of our discussion.

Suppose we're on a row, facing right. This strategy say that we need to move to the right as long as there is a weed to the right of us either on this row or on the row directly below us.

The idea is that we need to mow that weed, hence, we need to move there. If it's in the same row as us, it's fairly obvious we have to mow that before going down. If it's at the row directly below us, since we can't move to the right in the row below us (since we'll be facing left there) we need to move there before going down.

The strategy then says that if we no longer need to move right, we go down, and face left. Repeat this until all weeds are mowed (replacing left and right in the discussion above) - and we have our strategy.

This strategy is optimal. Proof is using induction - but it's not particularly interesting, so the idea is given instead.

Suppose we're on a row, facing right, again. If there exist a weed to the right in this row or below us, then any solution will necessarily move right as far as our strategy goes (for the reason we discussed above). Some solution however choose to go further right despite having no weed in this row or the row directly below us. This solution is not optimal if we need to go left directly after going down, for we can just simply go down instead of going right-down-left. On the other case, if we don't need to go left directly after going down, then it means that we go down twice-in-a-row! Hence, instead of moving right in this row, we go down twice, then move right there. And then the induction can continue and the proof can follow.

Remarks

I guess the actor should be Toastman instead :).

Anyway, so sorry to disappoint you, but we decided to add some pretty strong pretest to this problem, despite the fact that many solutions will probably forget to take care of two consecutive empty rows. But still, the pretest we gave only consist of one column, so feel free to hack the stragglers :) (not that this suggestion matters after the contest but still...)

D2-E / D1-C Plumber

To solve this problem, let's imagine that the left and top sides of the grid also determines whether the pipe adjacent to that side has an end connecting it to the side or not. There are 2^(N+M) ways to pick them. We claim that if we fix them (i.e., pick one of the possible 2^(N+M) ways, then the entire grid's pipes are fixed).

To see this, notice that each pipe segment will have either one vertical end (it either have end on the top or end on the bottom) and one horizontal end (left or right). We can pick any 4 combinations of them. Suppose we pick a row, and determine whether the leftmost pipe should have an end to the left of it, or not. Suppose it doesn't have an opening to the left. It means that the leftmost pipe should have an opening to the right, the next pipe should have an opening to the left, the next pipe to the right, and so on. Continuing this way, we have fixed the horizontal ends for an entire row - and only that. Hence, if we pick one of the possible 2^(N+M) ways to pick the ends, then the horizontal ends of each row and vertical ends of each column is fixed. Since there is exactly one pipe segment that has a particular configuration of ends, there is exactly one possible completed grid for each of the 2^(N+M) ways to pick the ends.

Hence, the solution works by first checking if a solution exists. Any pre-assigned pipe simply sets whether or not its corresponding row and column has an end at the left and top side. We need to check that no two pipes sets this value contradictorily. If any of them are contradictory, then we return the answer as 0. Otherwise, we return 2^(number of rows without preassigned cell + number of columns without preassigned cell).

D1-D Unambiguous Arithmetic Expression

This problem is solved using Dynamic Programming. The somewhat straightforward dynamic programming is to represent the state as {start_pos, end_pos}, which represents the number of unambiguous arithmetic expression on the substring of the input starting at start_pos and ending at end_pos. This however has a complexity of O(N^3) and is not suitable for our problem.

The solution uses the state {pos, braces}. This state is somewhat tricky to explain. This means that we have read the first pos characters in the input. We're expected to read a single unambiguous arithmetic expression, close it with some number of brackets that we don't care (to be explained below), and then, if braces is zero, that's it. Otherwise, we're then expected to read a binary operator (either + - * or /), then open a bracket, then move the state to {pos + some_value, braces-1}. That is, braces keeps track on the number of second operands of binary expression that we need to make.

For an example how this works, let's try to solve a particular test case:

"++0*+1"

Let's denote with quotes the part of the input that we haven't processed. We're going to create the unambiguous arithmetic expression by scanning it left to right and making some choices.

There are three choices:

1) Create a unary expression. In the example above,

"++0*+1" -> +("+0*+1"

We don't really care about where the closing bracket is yet.

2) Create a binary expression. In the example above,

+("+0*+1" -> +(("+0*+1"

How does this tells that we will need to create a binary expression? The second open bracket does not have any operator preceeding it. The only thing that can makes this a proper prefix of an unambiguous arithmetic expression is that if this bracket belongs to the first operand of a binary expression.

For our example, we suppose we read another unary expression

+(("+0*+1" -> +((+("0*+1"

3a) Read an integer. In our example above,

+((+("0*+1" -> +((+(0))*("+1"

There are two questions. a) how do we know the number of closing brackets we have to make? This is actually easy - for every open bracket we have, if it's for a unary expression, we simply close and repeat. Otherwise it's a closing bracket for possibly the first operand to a binary expression, so we close it, and we read a binary operator (* in the example above), and try to read the second operand of the binary expression.

Finally:

+((+(0))*("+1" -> +((+(0))*(+("1"

3b) We try to read an integer again and we have no open brackets that belongs to the first operand of a binary expression, and we have ourself a possible answer.

+((+(0))*(+("1" -> +((+(0))*(+(1)))

So, in the state {pos, braces}, pos determines the starting location of the remaining unprocessed input. braces indicates the number of open brackets that belongs to a binary expression. So, in the examples above:

1)

"++0*+1" -> +("+0*+1" is represented by

{0, 0} -> {1, 0}

More specifically, for unary expressions, {pos, braces} -> {pos+1, braces}

2)

+("+0*+1" -> +(("+0*+1" is represented by

{1, 0} -> {1, 1}

More specifically, for binary expressions, {pos, braces} -> {pos, braces+1}

3a)

+((+("0*+1" -> +((+(0))*("+1"

{2, 1} -> {4, 0}

More specifically, {pos, braces} -> {pos + length_of_integer + 1, braces-1}

3b)

+((+(0))*(+("1" -> +((+(0))*(+(1))){5, 0} -> Done

More specifically, {pos, braces} -> done if braces is zero and the remaining input forms a single integer.

Remarks

My favorite problem of this match (because it's hard-to-think and easy-to-code) ;). This turns out to be the hardest problem of the match.

During the match, three coders (shik, ivan.popelyshev, and watashi) submitted solutions which I think works in N^2. Petr submitted a solution that (I think) uses Catalan number, while Egor submitted a solution which uses polynomial to quickly count each of the dp values (see his comment in the Editorial). tourist submitted a solution which uses a highly-optimized inner loop with no branching and expensive operations (only a single multiplication) - he cleverly avoid branching in his code.

D1-E Races

We process the roads one by one. Associated with each road is the races whose UBi is that road (i.e., races that 'ends' at that road). We will discuss the Dynamic Programming solution first, then improve it with a data structure into the optimal solution.

Let's say we're going to process a road. Our state is this : DP[X] is the maximum possible profit such that the last X roads before this road are fixed and the X+1-th road before this road is NOT fixed. We are going to compute the value of DP for the next iteration, let's call this FUTURE. FUTURE[0] is obtained if we don't fix this road, FUTURE[0] = maximum amongst the value of DP. Otherwise, if we decide to fix this road, then for each of DP[X], FUTURE[X+1] >?= DP[X] - cost to fix the road + all races' profit that ends at this road and whose starting point is not before X roads from current road (i.e., all the races that is contained and ends at this road). This should work in N^2 + N * M. It can be improved to N^2 + M

The data structure approach is slightly different. We will use a segment tree that allows finding a maximum value in a subset and modifying the values of a range, all of which should work in either O(1) or O(log N). The segment tree will consist of N+1 leaves. However, not all the leaves are active at the start of the algorithm. At the start, only one leaf is active and it corresponds to the initial value of DP[0]. Next, we can compute the maximum value amongst all active leaves in O(log N). Then, we create a new active leaf that corresponds to FUTURE[0]. This will be located in the same tree however, the values represented by the leaves will be shifted one to the right - this is done implicitly (for example, we use the last node as DP[0] for the first iteration, but treat it as DP[1] for the next, and so on). These shifted values will correspond to FUTURE[X], since we notice that FUTURE[X] = DP[X-1] - cost to fix the road + races that this series contains and ends at this current road (i.e., it's value directly depends on the leaf BEFORE it was shifted). Next, we decrement the value of all these new leaves (except FUTURE[0]) by the cost to fix the road (in O(log N)). Finally, for each race that ends at this road, we increment the value of the leaves that contains this race. This will be continuous, i.e., FUTURE[X] for X in [race_len, INFINITY]. This can also be done in O(log N). Since a race ends at at most one road, the total complexity this will contribute is M log N.

The answer will then simply the maximum value amongst all members of the tree.

Remarks

This is one of the problems I submitted to this year's IOI but didn't got accepted - I sort of agree that this doesn't suit IOI very well. IOI likes a non-numeric output :) #goparrots!

Codeforces Beta Round #86 EditorialBy Kenny_HORROR, 11 years ago, translation, In EnglishDiv 2. Problem А. CiferaTo solve this task, let's describe what is needed more formally. We should answer whether is number l some positive degree of number k or no. To answer this question we can proceed in 2 ways:1) Using 64 bit data type, we can find minimal degree h of number k, such that kh ≥ l. If kh = l, then the answer is YES, and number of articles is equal to h - 1. Otherwise, the answer is NO.2) We will divide l by k, until k divides l and l ≠ 1. If l = 1, then the answer - YES and number of articles is equal to numberOfDivisions - 1, and the answer is NO otherwise.

Div 2. Problem B. PFAST Inc.We can reformulate the statement more formally.In this case, we have a undirected graph, and we have to find some maximal clique in it. If we have a look to constraint n ≤ 16, then there can be noticed that we can iterate over all possbile subsets of vertices and find the answer. To do this, one can use bit masks and iterate from 0 to 216, checking current subgraph for being a clique. Also, it's necessary not to forget about sorting the names while printing the answer.

Div 1. Problem A. Grammar LessonsThis task is an example of task that requires accurate realization. After reading the statement one can understand that we have to check whether the text from input represents exactly one correct sentence or no. If yes, therefore the text can be either a single word from our language or a following structure:{zero or non-zero count of adjectives} -> {a single noun} -> {zero or non-zero count of verbs}, and moreover, all these words should have equal gender.So, to check these facts, one can do the following:We count number of words. If this number is equal to 1, we check this word for being a valid word from our language. Otherwise, we can get gender of the first word, and iterate through the rest of the words validating existing of only one noun and order of these words. Also, while iterating we check the gender of each word for being equal to the gender of the first word.

Div 1. Problem B. Petr# Let's find all occurrences of begin and end. Then we'll map the whole string to number 0. After this we will simply add one symbol per iteration to already seen sub-strings and map new strings to some non-negative integers. One can notice that we will never reach a situation when more then 2000 different strings exist, so we can map them easily. Now, as per we know all the ends and beginnings of strings and different string of equal length are mapped to different numbers ( and equal strings are mapped equally), we can simply count the number of necessary sub-strings of certain length. So, we have time complexity O(N2LogN), since we are making N iterations and each is done in O(NLogN) time. 

Div. 1. Problem C. Double HappinessIn this task one have to find quantity of prime numbers that can be reproduced as sum of two perfect squares. Obviously, that 4k + 3 prime numbers are not suitable as sum of two perfect squares can not be equal to 3 (of course, modulo 4). So, we can prove or use the well-known fact ( also known as Fermat theorem), that every odd 4k + 1 prime number is a sum of two perfect squares. Also, we have not to forget about 2, as 2 = 12 + 12. Now, how can we get this task accepted? Simply using the sieve will exceed memory limit, but we can use block sieve, that works in the same time (), but uses  of memory. Also, we can use precalc for intervals of length equal to 100000. Also, Romka used the fact, that using bitset compress memory up to 8 times, and it will enough to suite the ML. Also, it would be nice to count only odd numbers while buliding the sieve.

Div. 1. Problem D. MuseumLet's consider a pair (i, j) as a state - this means that now Petya is in room i, and Vasya is in room j. Therefore, their meeting is state (i, i) for some i. So, it's quite easy to build transition matrix - this means that for each state (i, j) we will know probability of reaching state (x, y) in one step, where 1 ≤ i, j, x, y ≤ n. Also, from meeting state we can reach only the same state.Let's try to solve such a problem - what is the probability of meeting in the first room? We build system of linear algebraic equations:, where a(i, j), (x, y) —  probability of transition from state (i,j) to state (x,y). One can notice that p(1, 1) = 1, and p(i, i) = 0 when i ≠ 1, and the answer will be p(a, b).This system can be easily solved using Gauss method. Similarly we can solve such a problem for every room (considering that we will meet in certain room), but we have complexity O(n7), that will not pass time limit. But, after some observations, we now see that each time we are solving system Ax = b (and the only thing that is changing  —  is vector b). So, we can solve matrix equation Ax = b, where b is a matrix with dimensions n2 * n, and the answer will be in the row that corresponds to state (a, b) . With this approach we have time complexity O(n6), that will pass time limit.

Div. 1. Problem E. SleepingLet's consider function F(x) (where x is some moment of time)  —  amount of moments from 0..00:00..00 up to x (and x doesn't switch to next moment ) when n k or more digits will be changed . The answer will be F(h2: m2) - F(h1: m1), also it's necessary not to forget that if h2: m2 < h1: m1, then F(h2: m2) will be enlarged by a day.Now we will learn how to calculate F(x). To start with, let's count amount of such numbers when hour will remain the same. As hour is not changing, then k or more digits have to be changed in minutes, but in this case we need our number of minutes to be of the following form:a..a99...9, where a means any digit,and at the end we have k - 1 nines. So k digits are changing every moment that is divisible by 10k - 1.So, the total amount of such moments (without changing an hour) is , wherehx и mx are numbers of hour and minute in time moment x, and [] is integer part.Now let's deal with such moments when hour is changing. If this happens, then minute turns from m - 1 to 0, and we have y different digits, where y is amount of non-zero digits of number m - 1. Therefore we have to count for hours ( in similar way) amount of moments, when k - y or more digits will be changed. k - y digits are changing every moment that is divisible by 10max(0, k - y - 1), this means that total amount of such moments is . And the final value of F is .

Codeforces Beta Round #85: Editorial

By Seyaua, 11 years ago, translation, In English

Here you can find solutions to the problems from the past round. Editorial for Problem D (Div 1) was prepared by sdya. 

Division 2, problem A

In this problem one could transform all letters in both strings to lower case and then compare the strings lexicographically.

Division 2, problem B

One can notice that if we want to divide a square into two equal parts, then the cutting line should pass through the center of our square. Thus, if the marked cell contains the center of the square, then we can’t make a cut, otherwise we can. Here is the code which solves the problem:

scanf("%d%d%d", &n, &x, &y);

n /= 2;

if ((x == n || x == n + 1) && (y == n || y == n + 1)) printf("NO\n"); else printf("YES\n");

Division 2, problem C (Division 1, problem A)

It is easy to see that in order to maximize the sum of squares, one should make all numbers except the first one equal to 1 and maximize the first number. Keeping this in mind we only need to check whether the given value of y is large enough to satisfy a restriction that all n numbers are positive. If y is not to small, then all we need is to ensure that x ≤ 1 + 1 + … + (y - (n - 1))2

Division 2, Problem D (Divison 1, problem B)

Let’s create an array used[], j-th element of which will be the index of the last number from the input, which is divisible by j. Then for each query we’ll iterate over all divisors of xi and for each k, which divides xi we’ll check whether it is “unique”. After that we’ll update used[k].

Division 2, Problem E (Division 1, problem C)

This problem has many different approaches. One of them uses the fact that the overall number of possible inputs is small and it is possible to compute the answer manually for all of them. One could also write a brute-force with a few optimizations, which works even without a precalc.

However, the major part of all solutions involved dynamic programming with bitmasks. The solution below was described by Zlobober.

Instead of counting the maximal number of free cells, we’ll count the minimal number of occupied cells. We’ll assume that the number of rows is not greater than 6 (otherwise we can rotate the board).

Let D[k][pmask][mask] be the minimal number of occupied cells in the first k columns with the restrictions that the k-th column is described by pmask (ones correspond to occupied cells and zeroes correspond to free cells) and k+1-st column is described by mask. To make a transition from D[k-1][*][*] we can iterate over all possible masks for the k-1-st column, check whether we can distribute spiders in kth column knowing the masks for k+1-st and k-1-st columns and find the minimal value of D[k-1][*][pmask] for all such masks.

 

The overall complexity is O(n*23m), n > m.

 

Division 1, Problem D

One can notice that if m = 1 then the answer is kn, because all colorings are possible.Now we’ll assume that m > 1. Let’s look on the first column of the board (i.e. the vertical cut will be made right next to the first column). Suppose there are x distinct colors in this column. Then in the rest of the board there are also x colors. If we move the vertical line by one unit to the right, the number of different colors to the left of it will not decrease and the number of colors to the right of it won’t increase. It means that the number of different colors in both parts of the board will be also x. We can repeat this process until the line reaches the rightmost column, which means that the number of distinct colors in it is also x. It is easy to see that we can only use colors which belong to the intersection of sets of colors in the leftmost and rightmost columns in the rest of the board.

Let’s iterate over all values of x and y, where x is the number of colors in the leftmost column and y is the number of elements in intersection of sets of colors in the rightmost and leftmost columns. It is easy to see that x is limited by the number of rows in the board and y can’t be greater than x. Let’s find the answer for all such pairs of x and y and at the end we’ll add them up together.

 

Suppose x and y are fixed. We first need to choose (2x - y) colors from the given k colors, which we will use, which means that the answer for will be multiplied by C(k, 2x — y). After that we’ll choose (x-y) unique colors which will be used in the first column, which means that the answer will be also multiplied by C(2x-y, x-y). Then we’ll choose x-y colors for the rightmost column and multiply the answer by C(x, x-y). Now all we need to know is how many ways of coloring n cells into x colors are there. We’ll use a dynamic programming approach to solve this sub-problem.

 

Let d[i][j] be the number of ways to color a rectangle of unit width and length i into colors, numerated from 1 to j with the following restriction: if a < b then the first appearence of color a in the rectangle will be before the first appearence of color b.Then we can calculate this function using the following recurrence:

d[i][j] = j * d[i — 1][j] + d[i — 1][j — 1].

After we finish calculating d[i][j], we need to multiply the answer by d[n][x]2 (to color the first and the last columns). Now we need to notice that we can reorder all colors in the first and the last columns in arbitrary way, which means that the answer should be multiplied by (x!)2. Finally, we need to multiply the answer by yn(m-2), which correspond to coloring the rest of our board.

 

Here is the code, which solves the problem for the given values of x and y:

long long ans=0;

     

for (int y=0; y<=n; y++){

      long long cur=powmod(y,n*(m-2));

      for (int x=y; x<=n; x++)

      if (2*x-y<=k)

      {

            long long tek=cnk[2*x-y];

            tek*=cnn[2*x-y][x-y], tek%=mod;

            tek*=cnn[x][x-y], tek%=mod;

            tek*=d[n][x], tek%=mod;

            tek*=d[n][x], tek%=mod;

            tek*=f[x], tek%=mod;

            tek*=f[x], tek%=mod;

            tek*=cur;

            ans+=tek;

            ans%=mod;

      }

}

cout<<ans<<endl;

Some contestants had problems with time limit, because of calculation of C(N,K). One can notice that we won’t need more than 2000 colors, which reduces the time significantly. Author’s solution worked less than 200ms with the time-limit of 5s.

Division 1, Problem E

Let the length of the maximal path be S. First, we’ll estimate the value of S without specifying the longest path itself.

Let’s color our board into a chess-coloring. Obviously, each two neighboring cells in the path will have different color. Keeping this in mind we can make some estimation on the value of S. For example, if there are 4 white cells and 5 black cells on the board and we know that both starting and ending cells are white, than the length of the path can’t be greater than 7, because white and black cells must alternate in the path. We can write a simple function which calculates the maximal value of S using only the fact described above. Here, n and m are the dimensions of the board, (sx, sy) is the starting cell and (fx, fy) is the ending cell.

int fnd_ans(int n,int m,int sx,int sy,int fx,int fy){

      int col1=((sx+sy+1)%2); //color of the start cell

      int col2=((fx+fy+1)%2); //color of the finish cell

 

      int cntb=(n*m+1)/2; //the number of black cells

      int cntw=(n*m)/2; //the number of white cells

 

      if (col1==1&&col2==1)

            return cntb*2-1;

      if (col1==1&&col2==0)

            return cntw*2;

      if (col1==0&&col2==1)

            return cntw*2;

      if (col1==0&&col2==0)

            return 2*cntw-1;

}

It appears that for the constraints mentioned in the statement, this theoretical bound for S is always achievable. All we need is to find the path of the length S. Author solution divides the board into 5 pieces and solves the problem for each piece separately.

 

Let’s divide the board into 5 parts as it was shown on the first picture. We’ll assume that the relative location of the starting and ending cells is the same as on the picture. In each part we’ll try to build a longest path which completely belongs to it. For the first part we’ll try to build a path from the upper-right corner to the upper-left corner. Similar rules will hold for all other parts (see the picture above for further clarification). Paths can be different for different boards, but they will have similar structure. One can notice that there are only two types of paths (with respect to rotations of the board): the one which starts at the upper-left corner and ends at the bottom-right corner and the one which starts at the upper-left corner and ends at the upper-right corner. Now we can write down an algorithm:

1) Divide the board into 5 parts.2) Find the longest path in each of the parts.3) Check if the total length is equal to S.4) If the above is false, then rotate or reflect the board and continue to the step 1.

In order to find the longest path in a particular part, one can either consequently move through all rows of the part or through all its columns.

This solution gives correct answers for all 4 ≤ n, m ≤ 20. All possible cases of parity of each part are feasible within those constraints, which means that the solution will work for all boards, including ones with n > 20 or m > 20. The overall complexity of described algorithm is O(N*M).

Codeforces Beta Round #84 - AnalysisBy witua, 12 years ago, translation, In English1. Lucky Number (Div2 A)

In this problem you just need to find a number of lucky digits in n and output YES if it number is equal to 4 or 7, NO otherwise.

2. Lucky String (Div2 B)

To solve this problem you need to notice that result is a prefix of string abcdabcdabcd...abcd and output first n characters of this string.

3. Lucky Sum of Digits (Div1 A, Div2 C)

Let result number contains a digits 4 and b digits 7. Obviously, that a * 4 + b * 7 = n. Loop through all values of b. If we know b, we can calculate a, . Among all pairs (a;b) we need to choose one with a + b minimum. Among all that pairs we need to choose one with b minimum. Output will be an integer 444...444777...777, here number of digits 4 equal to a, number of digits 7 equal to b.

4. Lucky Probability (Div1 B, Div2 D)

Let L[i] - i-th lucky number, starting from 1 (L[0] = 0, L[1] = 4, L[2] = 7...). At first choose first k lucky number, then second k numbers and so on. For each of that group lets find answer, result will be a sum of each of this probabilities. Let index of current first number if i, last - j (j = i + k - 1). Then we need to find intersection of intervals [pl;pr] and (L[i - 1];L[i]], and also [vl;vr] and [L[j];L[j + 1]), product of that values will be a number of ways in which p < v, similarly for p > v. Sum of all that values for each group will be a total number of ways, then result = total number of ways / ((pr - pl + 1) * (vr - vl + 1)).

5. Lucky Tree (Div1 C, Div2 E)

Solve this problem using dynamic programming. Consider that root of a tree is vertex with number 1. Let F(x) - number of vertex in subtree of vertex x for which there is a path containing lucky edge. We will calculate F(x) using recursion. If x is a leaf, than F(x) = 0. Else, if there is an edge from x that leads to y and this edge is lucky, then to F(x) we need to add C(y), otherwise we add F(y), here C(y) - number of vertex in subtree of y, including y. But, to solve this problem we need to know also F'(x) - number of vertex which are not in subtree of x and there exits a path from x to that vertex that contains lucky edge. For a root of tree, F'(x) equals to 0. We should go recursive from root, and if we are in vertex x now, we suppose that F'(x) is already calculated. If from x we can directly go to y and that edge is lucky, then F'(y) = C(0) - C(y), otherwise F'(y) = F'(x) + F(x) - F(y).

After that, result equals to .

6. Lucky Sorting (Div1 D)

At first, if our array is already sorted, just return 0. Otherwise, if there is no lucky number in A, then output  - 1. Otherwise, let B is sorted A (array from input). Now, for all numbers in A we know a final position in B. Let k is an index of minimal lucky number in A. If we want to place integer from position i to j, we need A[j] to be lucky number. If is not so, we just Swap(A[j], A[k]), then A[j] contains lucky number. After that we can Swap(A[i], A[j]) and number A[i] is on position j. So, to place one number to it's position in B, we need at most two operations and total number that replacements will be not more than n, so answer'll contain at most 2n operations.

7. Lucky Interval (Div1 E)

That is only onw variation of solution, there are diffrent other, which uses same thinking.

With constraints for a and b to 107 problem can be solved using KMP algorithm: consider a string F(1)F(2)F(3)F(4)...F(3 * 107). We need to find first occurrence after index a of string F(a)F(a + 1)F(a + 2)...F(a + l - 1). Complexity of that algorithm is O(a + l), obviously, that fails on time and memory. Lets try to optimize this algorithm using some facts from "Lucky numbers theory".

Split all number interval on block with sizes 100: [0;99], [100;199] and so on. Introduce a concept "class of block". Class number of a block equals to F(i / 100), where i - any number from that block. There are 8 different block classes. There are at most 6 consecutive blocks with same class. All that can be seen using brute force.

Note #1: if l ≥ 1000, then .

Proof: consider a string F(100 * k)F(100 * k + 1)...F(100 * k + 99). Number of different that strings is equal to number of different classes. For example, for first class that string looks like this:

0000100100000010010000001001000000100100111121121100001001000000100100111121121100001001000000100100

for second:

1111211211111121121111112112111111211211222232232211112112111111211211222232232211112112111111211211

and so on. According to the structure of that strings, different block (by classes) can't intersect (there'll be no match). Hence, any sequence of of consecutive blocks which contain at least two blocks of different classes will match only with the same sequence, so shift will be multiple of 100. Since there is no more than 6 consecutive blocks with the same classes, if l ≥ 1000 then, obviously, this interval will contain at least two blocks with different classes.

So, problem with l ≥ 1000 can be solved using KMP with complexity O((a + l) / C), where C equals 100, let function that do that is named Solve(l, r).

Now we need to solve problem for l < 1000. At first, let a' is minimal number that F(a') = F(a), F(a' + 1) = F(a + 1), ..., F(a' + l - 1) = F(a + l - 1), a' / 100 = a / 100, that can be done using brute force. Then result is the minimum of next numbers:

- r = Solve(a', a' + l - 1);- Minimum r', for which r - r' <  = 1000, r' > a, F(r') = F(a), F(r' + 1) = F(a + 1), ..., F(r' + l - 1) = F(a + l - 1).- Minimum a'' for which a'' > a, a'' - a ≤ 1000 and F(a'') = F(a), F(a'' + 1) = F(a + 1), ..., F(a'' + l - 1) = F(a + l - 1).

That solves the problem of some non-100-multiple shifts, but that may be a doubt. Consider input interval is in just one block with class C. Then, probably, it is better to go to block with class C + 1, for example (397;1) → (400;1). Actually, second point solves that problem, because if block with class C + 1 is before C (and only in that case we will choose C + 1), then next block after current have class C + 1. To proof this we can use this note (which can be proofed using brute forces):

Note #2: if there is two consecutive block, then absolute difference between they classes is not more then 1.

Hence, if after block C (in which input interval is) goes block with class C - 1, then we will go to block C before C + 1, otherwise we will choose it (C or C + 1).

Thus, problems solves by accurate analysis all moments. Complexity of solution is O((A + L) / 100), my solution works 1.5 sec. and use 250 mega bytes of memory.

There are also solution which decompose of blocks with sizes depentding on l, that one work faster.

Editorial: Codeforces Beta Round #83By Atef, 12 years ago, In EnglishPalindromic TimesWriter: Atef

In this problem it was required to find next palindrome on a digital clock. Since the lowest unit of time used 1 minute, and there are only 24 * 60 minutes in a day, one could simply go through each minute starting from the time given in the input plus 1 minute, until finding a palindrome. If no palindrome is found till the end of the day 23: 59, the output should then be 00: 00.DatatypesWriter: Atef

Let us call a pair of datatypes (a, b), where a < b, BAD if and only if there exists a number x where x fits in a bits but x * x does not fit in b bits. The following observation helps in finding a solution to the problem. The best candidate for the number x is the largest number fitting in a bits, which is x = 2a - 1. So for each ai it is enough to check that the smallest aj > ai has enough bits to contain x * x = (2a - 1) * (2a - 1), which has at most 2 * a bits. Sorting the numbers first was needed to traverse the list of datatypes once and ensuring the condition above.Dorm Water SupplyWriter: Atef

The problem describes a graph of houses as nodes and one-way pipes as edges. The problem states that the graph will contain 1 or more chains of nodes. The required is to find the start and end of every chain (consisting of more than 1 node, which caused many hacks). The other requirement was to find the weakest edge in each of the chains. This can be done by traversing (using Depth-First Search (DFS) for example) the graph from each un-visited node with no incoming edges. These nodes are the start of a chain. By keeping track of the minimum diameter so far, whenever the DFS reaches a node with no outgoing edges, it means that this node is the end of the current chain. After storing, in a list or vector, the tuples (start, end, minimum diameter), we sort these tuples by start index and print.

Basketball TeamWriter: Atef

This problem is asking for the probability. Consider two sets of teams: the set of teams where Herr Wafa is the only student from his major and the set where at least one other student from Herr Wafa's major is present. These two sets don't intersect, so once we can compute the number of teams in the first set, A, and the number of teams in the second set, B, the answer would be B / (A + B).

The number of teams in the first set is A = . We subtract one as Herr Wafa is guaranteed the spot, and the other (n - 1) spots are to be taken by the remaining  students.

Now let's count the number of teams having exactly k students from Herr Wafa's major apart from him. This number would be . Much like for the first set, (n - (k + 1)) students from the other majors should he selected, and none of them should be from Herr Wafa's major. The total number of teams where at least one other student is from Herr Wafa's major is therefore .

The statements above describe the mathematical solution. It can be implemented in various ways.

Crime ManagementWriter: Atef

At the first glance the upper limit for n being 1018 looks huge. But in fact, combined with the fact, that the answer should be output modulo 12345, it's should not scare you but rather hint that the problem has a DP approach.

Like all DP problems the way to approach it is to split the problem into sub-problems and figure out what extra information should be carried between the sub-problems in order to combine them into the solution to the whole problem.

Say, n is 11 and we solved the problem for the first 10 crimes. Clearly, just the number of ways to commit the first 10 crimes is not enough to solve the full problem with n = 11. The extra information to be carried along with the number of ways to commit n crimes and be innocent is the following: the number of ways to commit the first n crimes and have remaining multiplicities d1, d2, ...d26 respectively. The fact that the product of the multiplicities does not exceed 123 makes this a solvable task, as the set of all possible remainders contains not more elements than the product of multiplicities.

To illustrate the idea from the first paragraph consider the first example case. It has two constraints, A with multiplicity 1 and B with multiplicity 2. The remainder of the number of crimes of type A is always zero, and committing crimes of type A may not yield any punishment. The remainder of the number of crimes of type B is zero or one. Therefore, while solving the sub-problems for the first n2 <  = n crimes, it's enough to keep track of only two numbers: "number of ways to commit n2 crimes and be completely innocent" and "number of ways to commit n2 crimes and have committed one 'extra' crime of type B".

The key step to solve the problem now is to notice that each transition from the solution for the first k crimes to the solution for the first (k + 1) crimes can be seen as multiplying the vector of the current state by the transition matrix. Once all possible transitions are converted to the matrix form, the problem can be solved by raising the matrix into n-th power. Raising the matrix into large power can be done efficiently using matrix exponentiation: on some steps instead of computing Ai + 1 = Ai· A0 one can compute A2i = Ai· Ai.

The last trick of this problem is to deal with multiple allowed multiplicities. If they were not allowed, the remainders per each crime type could have been kept with the modulo being equal to the multiplicity for this crime type. Moreover, if no crime type is listed more than once, the only valid final state is the state where the remainders are zero across all the crime types.

With multiple allowed multiplicities, for each crime type the remainder modulo the product of the multiplicities of crimes for this type should be kept. (Strictly speaking, LCM is enough, but the constraints allow to use the plain product instead). Then, at the stage of printing the output, instead of treating the counter for the state with zero remainders as the only contributor to the output, one would have to iterate through all possible states and verify if each set of remainders conducts a valid final state.

ArrangementWriter: Atef

The problem asks for finding the lexicographically n-th permutation satisfying the input constraints.

The trick which confused many contestants, as well as a few authors and testers, is that instead of having the restrictions formulated in a way position[a[i]] < position[b[i]] the restrictions were element at position[a[i]] < element at position[b[i]].

As in most problems where one has to output lexicographically n-th answer, the idea which can result in the solution which is passing the systests is to learn how to compute the number of solutions satisfying certain constraints.

We will speak about how to compute the number of solutions in a bit, but first let's understand how having such function would lead to a solution. The very first observation is: if the total number of possible solutions is less than y - 2000, then the answer is "The times have changed". Once we have ensured that the solution exists it can be found using some of search.

A simple approach would be the following: fix the first element of the resulting permutation to be 1 and count the number of possible solutions. If we do have enough to reach year y, then the first element must be 1, because there exists enough permutations with the first element being 1 to cover the years up to y, and any permutation where the first element is not 1 comes after any permutation where the first element is 1 in lexicographical order.

And if fixing the first element to be 1 is not giving enough permutations, then we should decrease the "desired" year by the number of solutions with 1 being fixed as the first element and start looking for the solutions with 2 as the first element. The intuition is that there are not enough solutions with 1 being the first element, but once we acknowledge that and start looking for the other solutions --- with 2 as the first element, we are speaking not about arrangements for years 2001 and onwards but about the years 2001 + number of solutions with first element being one and onwards. Therefore instead of looking for the permutation with index y - 2001 with the first element being 1 we are looking for the permutation with the lower index, y - 2001 - number of solutions with first element being one, with the first element being 2 or higher.

This process should be continued until all the elements are identified. Once the first index is fixed the known prefix would become a two-numbers prefix, and it will grow until all the permutation is constructed.

Now to complete the solution we need to be able to compute the number of permutations which satisfy two restrictions: the input constraints and the added "permutation has prefix P" constraint. This problem can be solved using DP.

For a given prefix P of length m, (n-m) other elements should be placed.

Assume first that we are going to be iterating over all possible permutations with the given prefix using the brute force, but, instead of trying each possible value for the element at the next empty position i, we would be trying each possible position for the next not-yet-placed element i. This approach would work, but in O((n - m)!) time, which is obviously unfeasible. We need to find some way to reduce the state space and make it run faster.

The key observation is the following: the state of the partially solved problem can be completely described by the bitmask of the currently occupied positions. This statement is nontrivial, as, from the first glance, it seems that apart from the unused positions mask, the information about the order, in which the already-placed elements are placed, is important. However it's not. Recall that all the constraints have the form of "element at position ai is less than the element at position bi". Provided the elements are placed in increasing order, in order to satisfy each constraint it's enough to confirm that, if the element to be placed is being put into position i, there is no such constraint in the input, that the element at position i should be less than the element at position j, while the element at position j has already been placed.

This approach results in the DP with 2n - m states. Note that the next element to be placed can always be determined by the number of bits set in the mask and the prefix elements.

The implementation of the above algorithm requires nontrivial coding, as the elements, belonging to the prefix, have to be treated differently compared to the elements which were placed by the DP. This is because the DP is enforcing that the elements are always added in the increasing order, which does not have to be the case for the elements conducting the prefix.

DartsWriter: Dima

Before doing the coding let's do some math. The answer to this problem can be computed as the total area of all input rectangles / the area of the union of all input rectangles.

One of the easy ways to understand it is the following. First notice that if all the rectangles are the same, the answer is always the number of rectangles. Now forget that the input figures are rectangles, assume any shape is  allowed, and then try to construct the example case given the union area s and the resulting expected score e. Notice that you can start with any shape constructed of non-intersecting figures with the total area s, and then add more figures on top of these, such that the contour of the union is the same as the contour of the first original figure of area s. Specifically, you'd need to add some figures of the total sum of t = s· (e - 1), but the number doesn't matter here. The key is that the placement of these added figures doesn't change the result, and therefore the answer will always depend only on the total area of the input figures and the area of their union.

Now back to the rectangles. Computing the sum of the ares of the rectangles is easy. The hard part is to compute the area of their union in better than O(n3). Note that the union may have multiple disjoins components, it does not have to be convex, it may have holes and, in short, does not have to be easy to describe.

One of the relatively-easy-to-implement solutions is the following. We will be computing the are of the union of the rectangles using the trapezoid method. Note that for the trapezoid method the order, in which the segments of the figure are provided, doesn't matter. Therefore, in order to use the trapezoid method, we "only" need to find all non-vertical directed segments which are the part of the contour of the union.

Let me elaborate a bit more on the previous paragraph. We don't need vertical segments, because their contribution to the resulting area is zero in the trapezoid method of computing the area. The direction of the segment is the important part though. It's not enough to know that the segment (x1, x2) - (y1, y2) belongs to the contour of the union. It's important to know whether the area of the union if the part of the plane above it or below it.

Imagine the test case where the union of all the rectangles is a big rectangle with a hole inside it. In this case we need to know that the segments, describing the outer part of the union, should contribute to the area with the "plus" sign, while the segments describing the inner hole should be considered with the "minus" sign.

Specifically, for the trapezoid method, the sign of x2 - x1 would be describing the direction of this segment: for example, if x1 < x2 than the segment is "positive" and if x1 < x2 it's "negative". 

To find all such segments let's consider all distinct  non-vertical lines. There are at most 4n such lines in the input. Each segment of the final contour of the union should lay on one of those lines, so it's enough to focus on the lines only, consider them independently from each other (but make sure to process each distinct line only once!) and for each line construct a set of the positive and negative segments.

Let's formulate the rules under which a part of the line would be a positive or negative segment. They turn out to be very simple:

1) If some segment (x1, y1) - (x2, y2) is part of the border of one of the input rectangles, then it's a "positive" segment if this input rectangle lays below this segment and a "negative" segment if this rectangle lays above this segment.2) If some segment (x1, y1) - (x2, y2) belongs to the intersection of the borders of two different input rectangles, with one being a "positive" one and one being a "negative" one, then this segment does not belong to the contour.3) If some segment (x1, y1) - (x2, y2) is being covered by another rectangle, then it does not belong to the contour. "Covered" means laying completely inside some other rectangle, the border cases are covered above.

The easy way of constructing all the segments could look as the following pseudo-code:

for each distinct non-vertical line  create the array of markers. the marker holds the x coordinate and one of four events: { start union area below, end union area below, start union area above, end union area above }.  iterate through all the input rectangles    if this rectangle has one segment laying on the line under consideration       add two markers: one for start and one for end. whether the markers are above or below is determined by the position of this rectangle with respect to this line    else if this rectangle intersects this line      find the intersection points and add four markers: { start area below } and { start area above } for the left intersection point and { end area below } and { end area above } for the right intersection point  sort the array of markers by the x coordinate of the events  traverse the array of markers. if some segment (x1..x2) is being reported as having the union area only above it or only below it, it becomes the negative or positive segment of the union respectively.

At this point one could run some sort of DFS to merge the segments into the connected loops, but this is actually unnecessary to compute the area using the trapezoid method. Just summing up (x2 - x1)· (y1 + y2) / 2 for all the segments does the trick, and it would automatically ensure that the outer contours are taken with the positive sign and the inner contours are taken with the negative sign.

The solution described above runs in O(n2· logn) : for each of O(n) lines we have at most O(n) intersections, which should be sorted in O(n· logn) inside the loop over all the lines.

Solutions for Codeforces Beta Round #82 (Div. 2)By Ripatti, 12 years ago, translation, In EnglishA. (link) Solution of this problem is written in the fourth paragraph of the statements. You should carefully read and implement it. Only one difficult part is how to to determine which card has higher rank. You can for every card iterate over array [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] and determine numbers of ranks in this array. Finally, just compare them.

B. (link) You can create array for all laptops where true for outdated laptop and false otherwise. Value of every cell of this array you can determine by iterating over all laptops and comparing all their parameters. At the end you should itarate over all laptops once again and choose cheapest one that is not outdated.

C. (link) Let create array dp by size n x m. dp[i][j] means maximum number of tugriks that the baker can earn if he used i grams of dough and cook buns with stuffings of types 1..j.

Initially dp[i][0] is 0 for all i.

You can easily calculate this dp:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } for every k from 0 to a[j]/b[j], for which i-c[j]*k>=0

The answer will be max{ dp[k][m] + ((n-k)/c0)*d0 } for every k from 0 to n.

Of course, all divisions in editorial of this problem are integer.

Solution works in O(nma), where a is maximum a_i.

D. (link) Solution is simulation of all insrtuctions from all of local sights. But naive solution doesn't fit into time limit. You should speed up this solution and do every instruction in O(1).

You can use one of following things.

1. For every position and every direction you can precalculate nearest position of sea. Now before than you do an instruction you should check that nearest position of sea further than position whereto you move after doing the instruction.

2. Let sea cells have 1 and all other ones have 0. For every cell (i,j) you can calculate sum of all cells in the rectangle with angles in (1,1) and (i,j). It can be done by the operations like:sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthwhere smth is 0 or 1 according to type of according cell (i,j). Now you can determine sum of numbers for all rectangles of the map. Before you do instruction you should chech that sum of rectangle on which you will go has sum 0.

Solution has complexity O(nm + kz), where z is number of local sights (this number no more than 26).

E. (link) Author's solution is three ternary search for every demension that are nested within each other.

It works because the function is convex. Maximum of convex functions also convex function. Author not very well imagine convex function in 3 dimrnsions, therefore you can read following proof that algorithm is correct:

Let consider some straight line. Function of distance between points on this line and planet position will be convex (you can imagine it). If you get maximum of such functions it will be convex function too. Let's call this function f1.

Now let's consider flat plane and choose one straight line in it. Set for every point of this line a minumum of function f1 of line that passes through this point and is perpendicular to choosen line. Let's call function on this choosen line f2.

f2 is convex. It can be easily proved by contrary. If f2 is not convex, we can find at least two local minimums. Let's choose two neighbour of them. We can find this two minimums on the plane and drawn through them new line. f1 on this line will be not convex (you also can imagine it). Сontradiction.

Now let's consider all space. Choose one line in it and define function f3 on it. Values of f3 will be minimums of functions f2 of planes that passes through the line and is perpendicular to it. f3 also is convex. Proof of it is analogically to that is written in the previous paragraph. []

Now you can see that minimum can ge found by three ternary search over functions fi. You can add to these functions returning of value in which they reach a minimum.

Also there are solutions that uses idea of Gradient descent or Hill climbing. Author was unable to write this solution (not enough precision), but some participants got AC with such solutions.

There is exact solution O(n^4) (more exactly O(C_n^4)). This solution uses Helly's theorem and Jung's theorem that follows from the first one:http://en.wikipedia.org/wiki/Helly's_theoremIn this solution you should itarate over all pairs, triples and fours of points and for every of them build minimal ball that cover them. Answer is center of ball with maximum radius.

Also you can google something like thathttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlThere are code and article, but the author of contest is not particularly delved into them))

Codeforces Beta Round #80 - unofficial editorialBy AlexanderBolshakov, 12 years ago, translation, In EnglishA-div2:First, we need to calculate n - 10 (because the queen of spades costs 10 points). If the difference stands in the [1;9] segment or is equal to 11, then the answer will be 4, because there are 4 cards for each cost. If the difference is 10, then the answer will be 15, i.e. 4 tens, 4 jacks, 3 queens (the queen of spades has been extracted from the pack) and 4 kings. And it's obvious that in all other cases the answer will be 0.

B-div2/A-div1:We need to use the following recurrence relation: count[i] = count[i - 1] + 1 + (answers[i] - 1) * i, and remember that count[1] = answers[1]. The answers[i] array contains the count of answers for the i-th question, count[i] - count of clicks that you need to answer the i-th question.Explanation of the formula:To answer the first question, we need to brute-force all of the answers to it. To answer the i-th question, we need to answer the (i-1)-th question and then brute-force the answers to the i-th. For the first try, we need only 1 click, for all other - i clicks (because we start answering from the very beginning).

C-div2/B-div1:We need to check the graph for connectivity and count loops in it using DFS. If the graph is connective and has only one loop - it is Cthulhu, if not - it isn't Cthulhu (C.O.).

D-div2/C-div1:Основная часть данной задачи - найти закономерность заполнения ячеек патронами. Найдем эту закономерность по индукции. Если патрон один - его можно поместить куда угодно, но т.к. нам нужна лексикографически минимальная строка, поместим его в самую правую ячейку. Теперь разберем случай с большим количеством патронов. Когда у нас один патрон находится в крайней правой ячейке, ячейки с той же четностью оказываются для нас проигрышными, а остальные - соответственно, выигрышными. Т.о. по идее, мы должны заполнять заведомо проигрышные ячейки справа налево, а после их заполнения заполнять справа налево и выигрышные ячейки. Но... это верно лишь для четного количества ячеек. Для нечетного количества ячеек второй патрон выгоднее посылать в предпоследнюю ячейку (т.к. количество выигрышных ячеек все равно не изменится, но зато при лексикографическом сравнении такая строка будет меньше). Далее заполняем аналогично с четным количеством ячеек.

E-div2/D-div1:Считываем все запросы и сортируем их по b. Далее используем ДП для всех запросов с b < 500 (для запоминания ответов нам хватит одномерного массива размера n), а остальные вычисляем наивным алгоритмом. За объяснение того, зачем следует выполнять сортировку, спасибо Александру Миланину (Milanin).

E-div1:Эту задачу я пока не решил :).

Codeforces Beta Round 79, editoralBy Sammarize, 12 years ago, translation, In English1. Clothes (A Div-2)In this problem constraints are allow to look throw all triples of clothes. For every triple one can check if all elements of tripe areturn out to match with others, and anong those triples find one whith minimal cost.

2. Sum of digits (B Div-2)Initial number consist of no more then 100000 digits. Therefore after first transform resulting number will be no more then 900000, and then it will constist of no more then 6 digits. Thus after next transform number will be no more then 54 and so it will be two-digit or one-digit. Sum of digits of a two-digit number no more, then 18, and sum of digit of such number no more, then 9.Thus Gerald can't do nore, then 4 transforms. First transform one can implement one simple pass throw symbols of given string. Following operations take very little time.

3. Homework (C Div-2, A Div-1)Lets count up the number of entries to string of every letter. Let Gerald choose x letter and lose them. Obvious thet if he lose x rarest letters then overall number of losed letter do not increase, and then if he can lose some x lettes, he can lose x rarest ones. Thus it's easy to determine if Gerald can loses x letters. And now to calculate the answer one only need to find the minimal such x, so Gerald can lose x letters.

4. Buses (D Div-2, B Div-1)For every slop from 0 to n lets calculate kx - number of ways come to them. Consider the i-th bus. Number of ways come to stop ti applied i-th bus is uqual to number of way to embus to i-th bus.One can embus to i-th bus on the stops si, si + 1, ..., ti - 1. Thus number of ways come to stop ti in the i bus is equal to sum ksi + ksi + 1 + ... + kti - 1. Finally, lets note that overall number of way to come to stop ti is the sum of numbers of ways to come to stop ti on every bus.It's remained two problems. First problem: 0 ≤ n ≤ 109. Therefore all kx not climb in memory limit. But we need to know only non-zero kx. For instance, one can gripe coordinates: create list of all occured stops (and also stops 0 and n), sort this list, delete the repeated stops and replace all numbers of stops they indexes in this list. After this operations all number of stops not exceed 200001, and all kx are climb to the memory.Second problem: if we will use loop "for" for counting sum ksi + ksi + 1 + ... + kti - 1, asymptotic of time of working will be O(m^2). There is an easy way to solve this problem: one can create and update array sum[], such that sum[i] = k[0] + k[1] + ... + k[i - 1], by another words, sum[0] = 0, sum[i + 1] = sum[i] + k[i].Then munber of ways to come to stop ti using bus i is equal to sum[ti] - sum[si].So time complexity is O(m \cdot log(m)), memory complexity is O(m).

5. Vectors (E Div-2, C Div-1)

Lets formulate the problem in complex number.Consider complex numbers a = xA + iyA, b = xB + iyB and c = xC + iyC. One can do operation A → A + C and A → iA.If we apply this transform some times in some order to A, we will get number A· ik + aC + biC - cC - idC for some non-negative integers k, a, b, c, d or, in another words, A· ik + aC + biC for k = 0, 1, 2, 3 and some integers a, b. Since k can be equal only 0, 1, 2 or 3, sufficiently to get to know is one can to represent B - A, B - iA, B + A or B + iA in the form of aC + biC.Then, how to determine, is one can to represent some complex number D in the such form? One can represent equation D = aC + biC in the form of linear real equation system:a· xC - b· yC = xDa· yC + b· xC = yDTo solve this system - is standart tehnical problem.

6. Castle (D Div-1)

Remunerate vertexes in such a way, that start Gerald vertex have got number 0.Consider that vertex 0 is the root of tree, and lets consider its children. Let Gerald first go to vertex x. Then he must to travel throw hole subtree, otherwise he will not visit all vertex in subtree. Then he come back to 0 and go to some next its child.Lets try to calculate looked for value for hole tree when we know all subtree values. If we can to do it, we can solve problem using dynamyc programming on the tree.Lets vertex 0 have n children. Lets i-th subtree have ki offspring (inclusive i-th child of 0). Let the hole tree consist of N vertexes.Lets Ti is the doubled sum of lenght all edges in i-th subtree, inclusive edge between 0 and its i-th child. It is the time to travel throw hole i-th subtree, starting in 0 and returning to 0.Finally, lets ti is answer to problem on i-th subtree. At once we add to this time length of edge between 0 and its i-th child.Lets Gerald travel throw all subtrees in order 1, 2, ..., n. What is average time of finding the treasure?Treasure can be in first subtree with probability . Then average time of finding the treasure will be t1.Treasure can be in second subtree with probability . Then average time of finding the treasure will be T1 + t2.And so on. Thus, average time of finding the treasure will be

Can we decrease this time? Lets swap i and i + 1 subtrees. Then item ki + 1Ti disappear from sum and appear item kiTi + 1. Sum will chenge to kiTi + 1 - ki + 1Ti. Sum will decrease, if kiTi + 1 - ki + 1Ti < 0, in ather words .Therefore, one can't decrease average time, if subtrees are sorted by increasing value .So, we must to sorted trees in this order and traveling from them in this order.

7. Candies and Stones. (E Div-1)

Essence of problem is that there is a board n × m in cell of wich placed numbers. And one must go from cell (0, 0) to cell (n - 1, m - 1), doing moves to one cell up and right (that is, increasing by 1 on of coordinates), maximizing sum o number on the cell in the path.Gerald's problems is determine m + n - 1 cells of optimal path. Lets start with search one, middle cell. Lets . What cell of board can be k-th in path? It is cell, sum of coordinate of wich is equal to k, thus, it is diagonal of doard. And then we can calculate, what maximum sum Gerald can collect, came to every cell in the diagonal, by dynamic programming in lower triangle. And the same way, we can calculate, what maximum sum Gerald can collect, came to cell (n-1,m-1), starting from every cell in the diagonal. Sumed up this to values, we calculate, what maximum sum Gerald can collect, came to from cell (0, 0) to cell (n - 1, m - 1), travel throw every cell in the diagonal. And now we will find cell (x, y), in wich maximum is reached. It is k-th cell of the path. We used time O((n + m)2) and memory O(n + m).Then we make recursive call on subproblems. In other word, will find optimal path from cell (0, 0) to cell (x, y) and from cell (x, y) to cell (n, m).It is evident, this solution take memory O(n+m). Why it tkae time O((n+m)^2)?Lets n + m is r.Once we are find middle cell of path of length k. Twice we are find middle cell of path of length . Four times we are find middle cell of path of length . And so on. Therefore, time of program working will be . Thus, this solution take time O((n + m)2).

Editorial for Codeforces Beta Round #78By goryinyich, 12 years ago, In EnglishHi there!

Here is editorial for the round #78.Russian editorial will be published a bit later - I supposed that there are more people who can understand English (or who can do English -> Russian web page translation) than vice versa.

Again, I'm very sorry for the situation with problem B (div. 1) / D (div. 2). Also, I'm sorry that I underestimated difficulty of the problems. At least, I hope the problems appeared interesting for many contestants.

Problem A (div. 2) - Help Far Away KingdomHere the problem was to round a number up according to the usual mathematical rules with the exception that if the last digit of integer part is equal to 9, you should output "GOTO Vasilisa.". One may notice that to check whether number's fractional part is not less than 0.5 only one digit just after the decimal point should be analysed. If it is '5' or greater - add one to the last digit of the integer part, and the problem is solved. Probably, the simplest way to deal with the input data was using of the string variables.

Problem B (div. 2) - Help Chef GerasimThe problem was to accurately check what is required in the problem statement. First of all, check whether all volumes in the input are equal. In this case output "Exemplary pages.". Otherwise find two cups with largest and smallest volumes. Suppose their numbers are a and b, and their volumes are v[a] and v[b]. Now suppose that before pouring their volumes were equal to V. Then they contained 2V units of juice before (and after) pouring. So, you need to check whether (v[a] + v[b]) is divisible by 2. If this is not so - output "Unrecoverable confihuration.". Otherwise assign to the cups presumable old volume v[a] = v[b] = (v[a] + v[b])/2. Now if only one pouring have been made, volumes of juice in all cups should be equal, and you print corresponding message "... ml. from ... to ...". If volumes are not equal, print "Unrecoverable configuration" instead.

Problem A (div. 1) / C (div. 2) - Help Victoria the WiseIn this problem you were required to find the number of sufficiently different colorings of a cube faces with predefined six colors. The most trivial solution is to introduce some ordering of the cube faces (say, 0 - front, 1 - back, 2 - up, 3 - down, 4 - left, 5 - right), then consider 720 = 6! arrangements of colors over these 6 faces. Each arrangement is some permutation of characters from the input. For each arrangement we find all its 24 rotations - and get 24 strings. Lexicographically smallest string will be representative of this coloring. The answer is the number of different representatives.

Problem B (div. 1) / D (div. 2) - Help KingUnfortunately, initial author's solution for this problem appeared wrong. However, the optimality of the below algo was proved by Knuth and Yao in 1976. Limitation for n in the problem now changed to 10000.The process of tossing a coin and making decisions regarding which alternative to choose may be naturally described as drawing some (possibly infinite) binary tree. Each toss "draws" two new branches from every free node of the tree (initially the tree consists of one free node). Whenever the number of free nodes becomes >= n, you turn n free nodes into leaves (onle leaf for each alternative), and proceed with the other free nodes in a similar way. For example, for n == 3 we get the following infitite tree:            o         /      \      o          o   /     \      /     \1        2  3        o                     /      \                   ...      ...Now we should evaluate expected length of a random path in this infinite tree now. One may notice that the tree is recursive: since the number of free nodes at every level is strictly less than n, the situation will repeat after maximum of n steps. Once one notices this, it is not so hard to derive formulas for the answer. Since numbers in the answer could be of the order 2^n, one needs to write "long arithmetics", or use Java.BigInteger.

Problem C (div. 1) / E (div. 2) - Help Greg the DwarfFor this problem I assumed numerical solution. But there are several cases to consider. Below without loss of generality we assume a <= b.1. l <= a <= b. In this case the answer is restricted by the length of the coffin, so the answer is l and it is clear that the coffin l x l can be brought through the corridor (a, b) - let's denote corridor's sizes in this way.2. a < l <= b. In this case the answer is a, and it is clear that no larger number can be an answer. Indeed, otherwise the coffin (w > a) x (l > a) is impossible to drag through the corridor (a, b).3. a <= b < l. This is the most general case, where we should rotate the coffin inside the corridor where it has a kink. To maximise the width of the coffin, we want to move it in such a way that one corner of the coffin touches one outer wall of the corridor (suppose bottommost on the picture), and another corner adjacent to the same long side of the coffin touches another outer wall of the corridor (leftmost on the picture). Let's introduce coordinate system in such a way that bottommost wall be OX axis, and leftmost wall - OY axis. Suppose that during the "rotation" process one corner of the coffin is at the point (x,0) (0 <= x <= l), then another corner should be at the point (0,sqrt(l*l-x*x)). And the answer we search for is min {distance from the segment (x,0) - (0,sqrt(l*l-x*x)) to the point (a,b) }, where you take min{} over all 0 <= x <= l. Let this distance at point x be f(x). Since f(x*) is minimal in some point x* and increases everywere to the left and to the right from x*, one may use ternary search to find its minimum.Exact solution for this problem is also possible: you can reduce the problem to minimizing the dot product of the vectors (a-x,b) and (-x,sqrt(l*l-x*x)) over x. But this leads to the neccessity to find the roots of the fourth-degree polynomial, which is not the best idea during the contest.

Problem D (div. 1) - Help MonksThis problem was about famous puzzle "Hanoi towers", but diameters of some discs might be equal. How to solve that? A good thing to do is to write BFS solution to check optimality of your ideas for small inputs (by the way, BSF works quickly for almost all towers that have up to 10 discs) and then try to create an algo which solves the puzzle in an optimal way.Let C (x1, x2, ..., xn) be a solution (under "solution" here we mean optimal number of moves - the moves itself is easy to get with one recursive procedure; also "solution" is the number of moves to move group of discs from one peg to any other (and not some particular) ) to the puzzle when we have a puzzle with x1 equal largest discs, x2 equal second largest discs and so on. And let U (x1, x2, ..., xn) be a solution to the puzzle when you are allowed not to save the order of the discs (you should still follow the restriction of the initial puzzle not to put larger discs onto the smaller ones, but at the end discs of the same diameter may be in any order).Then one of the optimal solutions to the problem is the following:C (x1, x2, ..., xn) = U (x1, x2, ..., xn) if x1 = 1 (*)C (x1, x2, ..., xn) = 2*x1 - 1 if n = 1 (**)C (x1, x2, ..., xn) = U (x2, ..., xn) + x1 + U (x2, ..., xn) + x1 + C (x2, ..., xn). (***)U (x1, x2, ..., xn) = U (x2, ..., xn) + x1 + U (x2, ..., xn) (****)Why so? One can notice that U() is "almost" solution for our problem: it "flips" order of the bottommost group of equal discs, the order of the rest of the discs remains the same! (try to understand why)That's why (*) is correct.The (**) is quite obvious.The (***) does the following: move (x2, ..., xn) from peg 1 to peg 2 without saving the order. Then move x1 equal discs from peg 1 to peg 3, then move (x2, ..., xn) from peg 2 to peg 1 without saving the order (but it occurs that after we apply U() to the same group of discs twice, the order restored!), then move x1 equal discs from peg 3 to peg 2, and then use C() to move (x2, ..., xn) from peg 1 to peg 2 (here we use C() since we should preserve the order). So, (***) is correct.And (****) is quite straightforward expression for U(): move all discs but the largest group with the same algo, then move largest discs (that's why if x1 > 1, the group of discs "flips"), and then move all discs but the largest group onto the same peg with x1.

Problem E (div. 1) - Help Shrek and DonkeyThis problem was about optimally playing this simple-at-first-glance game. The key thing to recognize in the statement was that it is not always optimal to name card which you don't have. Sometimes it is optimal to confuse the opponent by naming card which you have on hand. In this case... yes, he may think that the card you named is card on the table and lose during the next turn. Now the problem is to understand when to use the strategy of reduction of opponent's cards, when to bluff in the abovementioned sense and when to try to determine which card is on the table. But instead of "when" the right question is "how frequently" since we have nothing else but usual constant-sum matrix game, and optimal strategy is the mixture of these three. Let's construct a matrix first. Player 1 has three pure strategies: "playing" (when he plays the game and really tries to determine opponent's cards and card on the table), "guessing" (when he guesses which card is lying on the table) and "bluffing" (when he tries to confuse his opponent to force him to lose by naming card in his own hand). In turn, if the first player used "bluffing" strategy, or during the "playing" strategy named card on the table, his opponent has two strategies: "check" (i.e. to believe the first player that he doesn't own the card he named and guess it as the card on the table) and "move on" (i.e. to decide that it was a "bluffing" strategy and the game should be continued, but with notice that the first player has named card on hands). Let's denote P(m,n) probability to win the game when the first player has m cards and the second player has n cards. Then P(m,n) is the value of the matrix game with the following matrix (rows - strategies of the first player, two numbers in the rows - probabilities to win when the second player uses strategies "check" and "move on" correspondingly:

                                "check"                                    "move on""playing"        n/(n+1)*(1-P(n-1,m))        1/(n+1) + n/(n+1)*(1-P(n-1,m))"guessing"                 1/(n+1)                                     1/(n+1)"bluffing"                       1                                       1-P(n,m-1)

How to get these numbers in the matrix? Consider the first row: "playing" strategy of the first player, "check" strategy of the second. First just names one of the n+1 cards. With probability 1/(n+1) he names card on the table, seconds checks it and wins (so, probability to with for the first is 0), with probability n/(n+1) the first names one of the cards on hands of the second player, so the game continues, second wins with prob. P(n-1,m) in this case. Then the overall probability for the first to win with such combination of pure strategies is n/(n+1)*(1-P(n-1,m)). In the same manner we fill other cells of the matrix. Finally we solve the game (this can be done straightforwardly, or with one formula if one notices that the "guessing" strategy is suboptimal everywhere when m>=1 and n>=1 and that the game doesn't have saddle points) and get answer to the problem - P(m,n).And the last thing to note: when m==0 it is clear that during his move the second wins, so the first should guess, and P(0,n) = 1/(n+1). When n==0 P(m,0)==1 sinse we just do one rightguessing.

Codeforces Beta Round #77 - AnalysisBy witua, 12 years ago, translation, In EnglishDiv.2 – A Football

In this problem you must find longest substring consisting of equal characters and compare it with 7.

Div.2 – B Lucky Numbers - 2

If the length of input number |N| is odd, then, obviously, resulting number will have length |N|+1 and will be like this: 4444…7777, at first (|N|+1)/2 digits 4, then the same number of 7’s. If the number has even length, then, probably, resulting number will have size |N|, or |N|+2. So, length of the resulting number will have not more than 10 digits. So, we can recursive generate lucky numbers with size <= 10, take the smallest super lucky number which is greater than or equal to N.

Div.1 – A, Div. 2 – C – Hockey

Let B[i] = true, if character in position i is in some substring of W which is in dictionary. For each B[i] = true, do next:

·         If S[i] = letter and letter = ‘a’, then S[i] = ‘b’,

·         If S[i] = letter and letter != ‘a’ then S[i] = ‘a’;

·         If S[i] != letter, then S[i] = letter.

Div.1  - B. – Lucky Number

Read Div.2 – B

Notice, that answer will looks like this: to some position result will be equal with input string (that part must be lucky), next digit well be greater, the rest of digits are not important. That guarantees us that result will be greater than or equal to N. As rightest this position will be as number will be lesser. Some of the positions may not be ok to us. Let chosen position is i. Left part must be lucky. If S[i] < ‘4’, we can assign S[i] = ‘4’, then fill minimally right part. If S[i] < ‘7’, we can assign ‘7’ to it, like in prevision case. Call position i ok, if absolute different between number of ‘4’ and ‘7’ in part from 0 to i, inclusive is not more than n-i-1. If we chose some rightmost position, which is ok, now we must fill right part. How to do it? If we can assign to some position (we will fill them from left to right) ‘4’ and this position is still ok, then we place ‘4’,  else we assign ‘7’. If there is no ok positions at all, resulting number will looks like this: 4444…7777, when number of digits 4 = number of digits 7 = (|N|+2)/2.

Div.1 - C, Div.2 - D – Volleyball

At first in this simple problem you need to find shortest path between all pair of junctions. That can’t be done using O(N^3) algorithms, so you must use Dijkstra algorithm to find this in O(N*N*logN) time. Next part of this problem is to create new matrix, G[i][j] = C[i], if D[i][j] <= R[i], else G[i][j] = INF. Here D[i][j] – length of shortest path between I and j. So, result is shortest path between X and Y using matrix G. That can be done using simple Dijkstra algorithm.

Div.1 – D, Div.2 – E. Horse Races

Traditionally I remain that answer is Result(0..R) – Result(0..L-1).

Let we have array DP[x][y][z] – number of x-digits number if last lucky digit was on position y, bool z (0 or 1) – was the pair of lucky digits with less than or equal distance then K (call it lucky pair)? Now, let S – string which represent number N. Let F(x, y, z) – result for substring of first x digits, y – position of last lucky digit, z – (0 or 1) – was the lucky pair before? Try to assign some digits on position x. If this digit is less than S[i], then add to result for F(x, y, z) DP[n-x-1][yy][zz] (yy – updated position of last lucky digit, zz – updated bool for lucky pairs). If this digit is equal to S[i], add F(x+1, yy, zz). DP can be calculated simply. Let from state (x, y, z) we place some digit d on position x. Then, we can go to state (x+1, yy, zz). Again, yy and zz – updated parameters.

Complexity – O(T * |N}).

Div.1 – E – Lucky Country.

Let A[i] - sorted array of sizes of different connection components, C[i] – number of connection components of size A[i]. Sum for all C[i]*A[i] is equal to N. Size of A will be O(sqrt(N)).

Solution #4 (by RAD)

Coming soon…

Solution #7

Let all C[i] = (2^k)-1, i. e. C[i] = 1 + 2 + 4 + 8 + … + 2^(k-1). Obviously, that if chose some subset of this powers we can get any number from 0 to C[i], inclusive. So, the problem now is next: For each A[i] is log(C[i]) things (cost of this thing is size of subset that create it), each can be used at most once. This is standard “Knapsack” problem (read this). Complexity of this algorithm is O(N * S), when S is the sum for all log(C[i]). If C[i] is not power of 2, then we must find maximal k, which (2^k)-1 <= C[i] and add C[i]-((2^k)-1) to set.

Sorry for my poor English! If you do not understand something – write in comments, please.

Codeforces Beta Round 76 - AnalysisBy dalex, 12 years ago, translation, In EnglishAt first I tell about the contest at all.

My problems in the contest were A-div2,  B-div2,  C-div2/A-div1,  E-div2/C-div1,  D-div1. I wanted to make only div.2 round, but then we decided to give you seven problems at both divisions. MikeMirzayanov prepared the problem about milk pouring and anonymous gave E-div1 problem. Also RAD gave some advices to complicate problems Azembler and Flags a bit.And now let's start analysis.

Problem A (div.2) - Restoring Password

Password was very easy to restore. You should just iterate over groups of 10 characters in the first string and over all codes. Then, if some number's code is equal to the group - print that number.

Here's the example: http://pastebin.com/hMV0NcjN



Problem B (div.2) - Friends

Let's construct the graph where vertices correspond to the people and edges correspond to the relationships. Then paint each edge in this way: edge will be red if the men connected by it are friends and black otherwise. Now let's think what is "three pairwise acquainted people" and "three pairwise unacquainted people". We see that they are cycles of only red and only black vertices correspondingly, and the length of these cycles is 3.

Now we know the solution: write 3 "for" cycles, one cycle for one vertex, and check if the edges between these vertices are only red or only black.

Here's the solution: http://pastebin.com/gswaxGmM

Another way to solve it is to notice the answer is FAIL if and only if graph has exactly 5 edges and they all together form a cycle with a length 5. It's very funny solution, I think. Here's the code: http://pastebin.com/09T0ixrJ



Problem A (div.1) / C (div.2) - Frames

The problem is easy, but there were many tricky cases - and contestants show it successful :) I added almost all these cases to the pretests because I didn't want to arrange Beta Round 60.

So let's solve the problem. At first notice that the answer is not greater than 3 because we always can do three selections (maybe, some of them are empty): with first selection we select end of the first row, with second one - begin of the last row, and with last one - all remaining folders (they form the rectangle).The best way is to find all cases with answer 1 and 2. Try to do it.

If the answer is 1, we can select all folders from a to b with one selection. There must be nothing hard to detect these cases:

first and last folders are in the same row (21 5 7 9);first folder is in the first column, and the last folder - in the last column (21 5 1 15), сase m = 1 is included here;first folder is in the first column, and the last folder is n (21 5 6 21). Case when we must select all folders is included here. I was very surprised when I saw that many contestants forgot about it.And these are the cases with answer 2:

first and last folders are in the adjacent rows (21 5 8 14);first folder is in the first column (21 5 6 13);last folder is in the last column (21 5 4 15);last folder is n (21 5 4 21);and another tricky case: if the column where first folder is located is just at right from the column where the last column is located (21 5 3 12).If no one of these conditions is true, answer is 3.

Here's the solution: http://pastebin.com/8QRytzzF

Problem B (div.1) / D (div.2) - End of Exams

Greedy algorithm solves this problem. We should consecutively try to pour milk from each bottle into each available cup and in maximal possible amount.

Also we always need to know, how much milk is in each bottle and each cup, for each cup - bottles from which we have poured milk, and for each bottle - cups into which we have poured milk.

Writing it is not hard. But where is one special moment - if we compare real numbers, we must use EPS, or we can get WA on test 12 (50 1000 49). Some programs write NO on this test while answer is YES, because of wrong comparing of real numbers.

It must be said that answer can be calculated in integers: just set the volume of milk in each bottle mn. And only when we will print the answer, we divide each volume by mn and multiply by w. All three jury solutions didn't think up this :)

Here's the solution: http://pastebin.com/HG5Nrxne (be careful, it's not as beautiful as previous ones)

Problem C (div.1) / E (div.2) - Azembler

I don't know why so few coders have solved it. Small limitations for n and big time limit - 5 seconds - hint that it's backtracking. Also, no need to be a soothsayer to understand that maximal answer is about 5.

Solving it is clear. You should keep all current registers at the vector and call some function that goes over all current registers and calculate new values, then calls itself recursively. In that process we can also save the program itself.

To avoid TLE you should not make recursive calls if the deep of recursion is larger than current answer, should not go to the states where you get a number larger than n or less than current biggest number. And if you reach exactly n, you should update answer and copy the program to the safe place.

There are some hacks to speed up this approach: for example, iterate over numbers in descending order (it works faster), but 5 seconds is such TLE that you can solve it any way. Or you can launch backtracking for the specific answer (increasing it) while the program won't be found (I don't know how this method is named in English). Also, some contestants have solved it using BFS.

Here are two solutions: standard backtracking (http://pastebin.com/Z6ZF36st) and backtracking for the specific answer (http://pastebin.com/viiYF9CB).

Problem D (div.1) - Flags

I think my solution is not optimal, it's too long. Many solutions submitted during the contest are shorter. But I tell you about my solution.

At first I solve the problem for the number of stripes equals N (or L = R).

Let  is the number of flags with exactly N stripes where symmetrical flags are not identical. Try to get the answer using this designation.

At first sight it seems that answer is . But it's not true for the palindromes. For example, for non-palindromes WBWB and BWBW we should count only one of them, but for the palindromes, such as WBW, it leads to mistake, because each palindrome is symmetrical to itself.So for the flags with even number of stripes formula  is correct, because there are not palindromes among them. And if N is odd, the correct formula is , where  is the number of palindromes with N stripes. Each palindrome is definited by its first  stripes, and we can write that .

Now we can give an answer if we know how to calculate number of flags where symmetrical flags are not equal. Notice that if we know two last stripes of the flag, we can definitely say if we can add another stripe to its end.

Let's use dynamic programming. As a state we can take a vector  with a length 8 where each its component keeps a number of flags with N stripes and definite two last colors (exactly 8 options). And  is total number of flags with N stripes.

As start state we can take vector  which consists of ones (because there are 8 flags with a length 2, one flag for one possible combination of two colors). And how to calculate ?

It turns out that there is some matrix A that . Its elements can be found even using pen and paper: for example, let's we have a combination of two last stripes WB. Then it's possible to add white or yellow stripe to the end, and the last stripes will be BW and BY correspondingly. It means that we can write 1 to the matrix where the row are BW or BY and the column is WB.

We're about the finish. It's obvious that . Power of matrix can be calculated with a logarithmic time - that's because our problem is solved. And don't forget if N = 1 then answer is 4 and there's no need to do these calculations.

But it was only problem where L = R. Let's find a solution for the segment .

I know two ways to do it. First way is to add a new component to the vector and new row and column to the matrix. This new component should keep the total number on the segment  (if L = 1, we can write "if" somewhere at the beginning of the program). And the matrix A should be changed a bit: try to do it by yourself.

I like the second way. As we did it earlier, we will find a number of flags where symmetrical ones are different, but on the segment . It is equal to . Let's learn how to calculate the sum E + A + ... + AN quickly.

Let b is such maximal power of 2 that 2b - 1 ≤ N. We can write .

And apply some math magic to the first part of the previous formula: . And the expression in the brackets at the second part of that formula is... I think you've already understood it :)

We forgot about the palindromes, but it's very easy to calculate their number. Let's suppose that L and R are odd (if they are even, we can add one to L and substract one from R). Then .

That's all. Don't forget to apply "mod" operation after each operation and examine border cases carefully. And here's the solution: http://pastebin.com/wHu1tPgd (yes, "matrix" and "vector" type definitions are strange - I've totally forgotten how to write in Pascal)

Problem E (div.1) - LostbornThis problem can be solved using inclusion-exclusion principle. If  is the answer, then the following formula works: . But if you write only this recursive function, you get TLE. Many contestants got TLE and were hacked because they didn't run maximal test on their computers.

And the others who sensed that something was wrong memorized the answers for small n and all ai. For example, you can see solution by rng_58 who won the contest, or this solution: http://pastebin.com/4kcfJdAi.

anonymous, the author of this problem, wrote his thoughts about it there: http://codeforces.ru/blog/entry/2216 (but now there's only russian version). His solution works even if n = 1015 and it can be viewed here: http://codeforces.ru/problemset/status/93/E?order=BY_CONSUMED_TIME_ASC. It seems that any solution submitted during the contest would get TLE if n = 1015.

Sorry for my English :)

Solutions for Codeforces Beta Round #74By Ripatti, 12 years ago, translation, In EnglishA div2. In this problem you can simulate the process. You can consider all minutes and in dependence by a color of a current cablecar decrease size of corresponding group of students G by min(|G|, 2), where |G| is size of the group. After that you should determine the first minute t in that all three groups of students will be empty. So t + 30 is an answer. This solution works in O(r + g + b).

Also there is O(1) solution. It is following formula: ans = max(3[(R + 1) / 2] + 27, 3[(G + 1) / 2] + 28, 3[(B + 1) / 2] + 29) where [x] is rounding down.

B div2. It this problem you should write exactly that is written in statement. For every letter you should see a row and a column of the letter. If equal letter was found, current letter sould not be output. You can combine scanning rows and columns and output an answer, for example, this way:

FOR(a,1,n) FOR(b,1,m){    bool should_out=true;    FOR(c,1,n) if (c!=a) if (T[a][b]==T[c][b]) should_out=false;    FOR(c,1,m) if (c!=b) if (T[a][b]==T[a][c]) should_out=false;    if (should_out) printf("%c", T[a][b]);}

This solution works in O(mn(n + m)).

Also here an O(nm)-solution exitsts. In every row and column you can calculate a number of every letter of an alphabet. After that check for output can be done in O(1). You just should check that numbers of entries of considered letter into corresponding row and column equal exactly 1.

C div2 и A div1. Determine a form of all arrangements of diamonds that set of all sums of pairs adjacent cells is invariably. If you remove from the first cell exactly c diamonds, you should add exactly c diamonds into the second cell, remove c diamonds from the third cell and so on. In other words, all valid arrangements can be produced by adding c diamonds into every even cell and removing c diamonds from every odd cell, where c is some integer. c lies in range from  to  because otherwise number of diamonds in some cell will be less than zero. There is no more valid arrangements.

Now consider a number of all diamonds in cells as a function of c. If n is even, the sum always is constant. So there is impossible of theft diamonds and answer is 0. For odd n for every c there is c extra diamonds. So, Joe can theft no more than  diamonds.

It is easy for undarstanding that for increasing (or decreasing) c by some constant x Joe should do x(n + 1) / 2 moves, but he cannot done it by lass count of moves. In one minute Joe can change c no more than on [m / ((n + 1) / 2)]. Common number of diamonds thet Joe can theft for all time is k[m / ((n + 1) / 2)], but you should take into account a limits for changing of c.

At the end common solution is following:  If n is even, answer is 0, otherwise answer is .

Be careful fith overflow of 32bit integers. Here you should use an 64bit integers.

D div2 и B div1. Here you can build some miltigraph in which nodes are widgets and edges are relationship of pack()-method. This graph is acyclic. Next, you should do topological sort of nodes. Sizes of widgets should be calculated in the obtained order. At the last, you should sort all nodes by thier names and output an answer.

About implementation.

Parsing of instructions is very easy if you swap charachers '.', ',', '(', ')' by spaces. Now you can just split instructions into strings using spaces as separators.

Multigraph can be saved into matrix. Cell M[i][j] contains integer number that means number of edges from node i to node j. Topological sort can be done by any stupid method. For example, you can choose k times node that has no outgoing edges to unselected nodes, where k is numder of nodes. Every check can be done in O(k2).

You should recalculate sizes of widgets using 64-bit integets (a tip was is statement). In a test like

100Widget w(100,100)HBox boxbox.pack(w)box.set_border(100)HBox aa.pack(box)a.pack(box)HBox bb.pack(a)b.pack(a)HBox cc.pack(b)c.pack(b)...

width of widgets grows exponentially. In jurys' tests maximum length of a side of widgets was 103079215104000. You can get that length by packing 4 widgets everu time instead of 2 widgets.

E div2 и C div1. This problem can be solved by simulation. You can just iterate over all chips and for every of them calculate number of points. But srupid simulate can give O(k3) time solution, where k is total number of chips. It doesn't fit into time limits. For example, try test like

1 5000RRRR...[2500 times]LLLL...[2500 times]

You can simulate process in  time by using some data structures like std::set, but it doesn't fit into limits too.

Similating in O(k2) time is given by following data structure.

For every chip you can save links to chips that is placed up, doun, left and right from the considered chip. Net of links can be built in O(nm). Now, when you simulate process, you can remove chips this way:

Chip->L->R = Chip->RChip->R->L = Chip->LChip->U->D = Chip->DChip->D->U = Chip->U

So, jump from some chip to the next chip in a move can be done in O(1). Now you can simulate every move in O(k).

Remove operation is reversible because every removed chip stores links to all of its neighbours. Therefore you can save links to all removed chips in current move and after restore net of links using following operetions for all removed chips in reversed order

Chip->L->R = ChipChip->R->L = ChipChip->U->D = ChipChip->D->U = Chip

Also you can just build net of links anew for every move.

D div1. Initially lets pump all mines on radius of Death Star and squeeze Death Star into point. Now you should determine an intersection of a ray with obtained figures.

Mine's body with radius r is pumped into ball with radius r + R. Every mine's spike is pumped into union of two balls with radius R and cylinder. One of these balls lies inside of pumped mine's body, therefore you can don't consider it. Let length of spike is r0. Then cylinder will have heigth r0 and radius R. A distance between center of one base of the cylinder and edge of another one equals . Following unequation proves that this distance always less than radius of pumped mine's body and cylinder lies inside of the pumped mine's body:



So, you can don't consider the cylinders too. For every spike you should store only ball of radius R with center in a peak of the spike.

Now we have set of balls, we are needed to determine a time in that some point collides with every of those balls. Lets write an equation:

|A + vt - O| = R,

where A is start position of point, v is vector of its velocity, O is center of ball, R is its radius. Lets rewrite equation in scalar variables:

(Ax + vxt - Ox)2 + (Ay + vyt - Oy)2 + (Az + vzt - Oz)2 = R2.

When you expand brackets, you receive some quadratic equation from variable t:

At2 + Bt + C = 0.

You should solve it and choose minimal root (minimal root is time of the first collision of point with the ball, maximal one is time of the second collision). Check than root more than 0.

Now you should determine all times and choose minimum of them. If there are no collisions, answer is -1.

All checking should be done in integer 64bit numbers for absolutely precision.

E div1. Solomon can just create some segments of ice cubes and cut its. Consider a segment with rightmost begin. You can assume that it ends in position of the last demon (you always can cut end of a segment that ends on last demon and add it to current segment). For cutting the last segment you should build "ice bridge" to it. When you are building this bridge, you should create and cut all others segments.

Now iterate over all start positions of the last segment. For every of them you should decrease powers of demons that is covered by this segment and calculate minimal number of moves for destroy all demons (do not forgen about the last segment!).

You can see that for every fallen ice cube you need exactly 3 operations --- go left, create cube, go right. For cutting a segment you need exactly 2 operations --- create cube and destroy one. Therefore all demons should be covered by minimal number of segments that no cube falls on an empty position. It can be done by greedy algorithm.

Total number of operations for every start position of the last segment can be calculated in O(n). Total number of checks is O(n), so we have an O(n2) solution.

After all, answer can be built very easy.

Codeforces Beta Round #72 (Разбор задач: Игрушечные армии, Две последовательности)By NALP, 12 years ago, In RussianЗадача А (Div-2). Игрушечные армииУтверждение первое: пусть пусть первым ходом было убито x солдат, а вторым y, тогда третьим ходом количество убитых будет равно min(n - x, n - y) = n - max(x, y). Значит, общее количество убитых будет равно x + y + n - max(x, y) = n + min(x, y), и именно эту величину нам нужно максимизировать. Рассмотрим ограничения на эти переменные: 0 ≤ x ≤ n, 0 ≤ y ≤ n - x. Значит, нам нужно найти максимум функции f(x, y) = n + min(x, y) в этой области. Понятно, что если мы скажем, что y = n - x (то есть для y примем крайнее положение), то ответ не уменьшится, а значит, можем свести нашу функцию к f(x) = n + min(x, n - x) на отрезке [0, n]. Очевидно, максимум этой функции равен 3· n / 2 в точке x = n / 2.Ответ: 3· n / 2.

Задача E (Div-1). Две последовательностиДля начала, попробуем нашу задачу решить, не задумываясь об асимптотике. Рассмотрим динамическое программирование, где состояние - это пара (i, j) (а значение - это минимальная суммарная длина двух последовательностей), которое означает, что первая последовательность у нас заканчивается строкой i, а вторая - строкой j. Переходы тогда выглядят следующим образом: мы должны взять элемент с номером v = max(i, j) + 1 и добавить в одну из последовательностей, таким образом перейти в новые состояния (i, v) и (v, j), пересчитав нужным образом значение.

Выпишем более формально, но теперь использовав динамическое программирование "назад", считая, что i > j:



Теперь придумаем окончательное решение. В силу постановки нашей задачи, можно задачу свести к другой динамике - D(i, s), где состояние означает, что одна из последовательностей заканчивается на строку номер i, а вторая - на саму строку s, причем, заметим, что под строкой s будем подразумевать не только строки из входных данных, но и все их суффиксы длиной от 0 до l. Вспомним, что строки у нас бинарные длиной не более 20 символов, а это значит, что строки можно закодировать двоичными числами, в этом случае строка кодируется парой - длиной и самим числом (это строка, если ее интерпретировать как двоичную запись; эта тонкость нужна, т.к. в строках, возможно, присутствуют лидирующие нули, в этом случае разные строки будут переводится в одно и то же число), причем, общее количество пар будет не более 221.

Будем итерироваться по i и поддерживать наш массив со значениями динамики (одномерный, размером 2l). При переходе, нам нужно обновить его в соответствии с формулами выше: по первой нам нужно ко всем элементам массива прибавить величину f(i - 1, i) - это можно сделать, поддерживая дополнительную переменную balance и прибавлять к ней (таким образом, реальное значение элемента i будет равно balance + d[i], хотя в самом массиве значение хранится будет d[i]). А второе обновление еще проще, мы должны перебрать какой длины у нас будет наложение строки на последовательность, взять соотвествующее значение в массиве, и по всем таким перебираемым величинам взять минимум и записать его в соответствующее место в массиве.

Реализовать этот алгоритм можно за асимптотику O(n * l) с требуемой памятью O(n + 2l).

Codeforces Beta Round #71 EditorialBy ir5, 12 years ago, In EnglishStatisticsProblem	#Submission	#Passed Pretest	#Passed Finaltest	Average ScoreA	858	767	660	433.36B	749	655	600	813.28C	467	352	229	1093.07D	28	14	4	1315.00E	2	2	1	1620.00

A. Bus Game (writer: rng_58)Brute force simulation works in this problem. In Ciel's turn, if she has at least 2 100-yen coins and at least 2 10-yen coins, pay those coins. Otherwise, if she has at least 1 100-yen coins and at least 12 10-yen coins, pay those coins. Otherwise, if she has at least 22 10-yen coins, pay those coins. Otherwise, she loses. In Hanako's turn, do similar simulation in reverse order. The complexity of this solution is O(x + y).

B. Colorful Field (writer: ir5)A solution that uses an array of N × M will absolutely get (Time|Memory)LimitExceeded, so we cannot simulate it naively.Both the number of queries and the number of waste cells K are not more than 1,000, so it is enough to answer each queries in O(K) runtime.Let (a, b) be a query cell. Whether (a, b) is waste or not is determined by simple iteration.So let's consider about the case (a, b) is not waste. Let I be the number of cells including waste ones that will be sweeped before (a, b), and J be the number of waste cells that will be sweeped before (a, b). Then, the answer is classified by the value of (I - J) mod 3 (for example, if the value = 0, the answer = "Carrots", and so on).By simple calculation, I = (a - 1)M + (b - 1), and J is calculated by O(K) iteration.

Overall, this problem can be solved in O(KT) runtime, where T is the number of queries.

C. Beaver (writer: ir5)We can regard a substring that is equal to one of boring strings as an interval. The number of such intervals are at most |s|· n, and the required time to determine whether each of them is a boring string is |bi|, so all intervals can be calculated in O(|s|· n· |bi|) runtime, by naive way. (Yes, no special string algorithm is required here.)The original problem can be rewritten as follows: you are given at most 106 intervals on [0, 105], determine the longest interval that does not contain any given interval.

To solve this rewritten problem, define right[i] be the leftest position of an interval whose left-endpoint is equal to i. If there is no interval whose left-endpoint is i, define right[i] is ∞.

Now we will calculate the optimal interval whose left-endpoint is i, in the order of i = |s|, |s| - 1, |s| - 2, ... 0. When i = |s|, corresponding right-endpoint is only |s|. Let's think the case when corresponding right-endpoint to i + 1 is j. If right[i] > j, then corresponding right-point to i remains j. Otherwise, that right-point is updated to right[i] - 1.This iteration will be done in O(|s|).

Overall, O(|s|· n· |bi|) runtime.

D. Password (writer: rng_58)Define an array b0, b1, ..., bn as follows: If the states of i-th panel and (i + 1)-th panel are same, bi = 0. If the states of i-th panel and (i + 1)-th panel are different, bi = 1. (The states of 0-th panel and (n + 1)-th panel are considered to be OFF.) If Ciel flips panels between x-th and (x + a - 1)-th, inclusive, the values of bx and bx + a are changed and other elements of b aren't changed. We can rewrite the problem:



<Problem D'>You are given an 0-1 array b0, b1, ..., bn. At most 20 (=2k) of them are 1. In each move, you can change the values of bx and bx + a, where a is an element of the given array and 0 ≤ x ≤ n - a. Determine the minimal number of moves required to change all elements in b to 0.

The order of moves is not important. If there is an index x s.t. bx = 1, you must change bx at least once, so you can assume that the next move is performed on x. Assume that when you change the values of bx and bx + a, at least one of them is 1.

<Problem D''>Let V be the graph with (n + 1) vertices. Vertices are numbered 0 to n. There is an edge between vertex v1 and vertex v2 if and only if |v1 - v2| is an element of array a. Initially at most 20 vertices contain tokens. In each move, you can move a token along an edge. When two tokens meet, they disappear. Determine the minimal number of moves required to erase all tokens.

First, calculate the distances between all pair of tokens by doing bfs 2k times. Next, do DP with bitmasks: Let dp[S] (where S is a set of tokens) be the minimal number of moves required to erase all tokens. If S is empty, dp[S] = 0. If S = {s0, s1, ..., sm - 1} is nonempty, dp[S] = min{dp[S\{s0, si}] + dist(s0, si)} where 1 ≤ i ≤ m - 1.

The complexity of this solution is O(knl + k· 22k).

E. Security System (writer: ir5)Lemma. The sensors we should consider are only four sensors at the corner.proof: Let's think about sensors at a fixed row v. As the definition, when Ciel entered to (x, y), a sensor at (u, v) decreases its count by |x - u| + |y - v|. Let this value be fx, y(u). If we fix Ciel's path, the total decrease of each sensor is expressed as the summation of fx, y(u), where x, y is one of the path. Because fx, y(u) is a convex function about variable u and the fact that "the summation of convex functions is also a convex function", we can ignore sensors at center points: i.e. a < u < a + c - 1.The same thing holds true for vertical direction, so it is enough to consider only four sensors at corner: (a, b), (a + c - 1, b), (a, b + c - 1), (a + c - 1, b + c - 1). ■

Because we need the lexicographically first solution, we want to use 'R' rather than 'U' in each step. Thus, it is enough if we can determine whether a feasible path exists with constraints that Ciel is at (x, y) and the rest counts of four corners are T1, T2, T3, T4.

Lemma. Optimal step is following (except sensors region):

proof: A following figure shows that if a blue path is good a brown path is also good. (Here, the blue path means arbitrary one, and the brown path means optimal one.) ■

The problem is sensors region.  In sensors region, it is possible to assume that the optimal path always passes a right-top sensor.While Ciel moves in sensors region to right-top sensor, the total decrease of both left-bottom and right-top sensor is constant. So we should think about only two sensors: left-top and right-bottom.In addition, let the total decrease of left-top and right-bottom be D1 and D2. Then following holds: D1 + D2 = const.

The smallest value for D1 is the total decrease when Ciel moves upward then moves rightward, and the smallest value for D2 is in the same way (moves rightward  →  upward).So we can calculate the minimal value and the maximal value of D1. And actually, D1 can be an arbitrary value between them with interval of 2. A following picture shows it.

Complexity at a simulation part is O(1). Overall, the complexity is O(N).

Solutions for Codeforces Beta Round #70 (Div. 2)By Ripatti, 12 years ago, translation, In EnglishA. You should count a number of vowels for every of three phrases. Next, you should compare this numbers with numbers 5, 7 and 5. If all is matched, answer is YES, otherwise answer is NO.

Author of problem is Ripatti.

B. At first, you can [n / 7] times output string "ROYGBIV" ([] is a rounding down). After than you can output "", "G", "GB", "YGB", "YGBI", "OYGBI" or "OYGBIV" according to remainder of division n by 7. A resulting string will satisfy problem's requirements.

You can also build answer in other way.

Author of problem is Ripatti.

C. If n is even, Marsel wins - he just symmetrically repeats moves of Timur.

Now consider a case of odd n. If Timur cannot move - he is losing automatically. If he can do a move, he always can split one log into few parts that this parts cannot be splitted again. It can be done if we have find minimal t that k ≤ t < m and t|m. Next we split log into parts with length t. Thereafter Timur symmetrically repeats moves of Marsel and wins.

For checking that Timur could move or not, you can iterate over all divisors of m. If there is exists some divisor t that k ≤ t < m, Timar can do a move. Chech of all divisors can be done in  time.

Author of problem is Lepetrandr.

D. It should be solved like a classical problem "count the  number of square cells 1x1 lying inside the circle". Firstly, lets find the highest hexagon that lies inside the circle. Then we move to the right and up from this hexagon, and then go down until we find hexagon lying inside the circle. Repeat this process until you reach the rightmost part of the circle.

Thus we can count number of hexagons in each column, answer is sum of this numbers. Total number of operations is O(n).

Few words about implementation. Coordinates of every considered point looks like . That's why distance between this points and (0,0) should be calculated using integers only. For example, criteria "point  lies inside circle of radius R" looks like x2 + 3y2 ≤ 4R2.

Also you can solve this problem in . For every column of hexagons you can find number of hexagons inside circle by using binary search.

Author of problem is Ripatti.

E. Firstly, let's calculate the following value:dp[t][x0][y0][x][y] == true iff scientist from block (x0,y0) can reach block (x,y) in time t, considering toxic coolant.

Secondly, let's consider a graph consisting of 4 parts:1 - source (one vertex)2 - first fraction (nxn vertices)3 - second fraction (nxn vertices)4 - sink (one vertex)Each vertex of each fraction is for one block. Build edge from source to each vertex of the first fraction with capability as number of scientists in corresponding block. Build edge from each vertex of the second fraction to sink with capability as number of rescue capsules in corresponding block. Build edge from vertex (x0,y0) of the first fraction  to vertex (x,y) of the second fraction iff dp[T][x0][y0][x][y]==true for at least one T. Capability of this edges is infinity.

As one can see, value of maxflow in this graph is answer for the problem.

Complexity of this solution is O(tn4 + kn6), where k is maximum possible number of scientists in each block(in this problem k = 9).

Author of problem is Ripatti.

Codeforces Beta Round #69 tutorialBy Alex_KPR, 12 years ago, translation, In EnglishPanoramix's Prediction (problem A, div-2). The problem's author is Alex_KPR

  

In the very beginning of statement you may find some words about what is prime number and what is next prime number. Main point of problem is to check is m next prime after n or not.

Problem statement guarantees that n is prime number. We need to check only two cases:

1. Number m is prime, and

2. There is no any prime number between n and m

Really, if there is prime number k between n and m then m cannot be next prime after n. Restrictions in this problem are really small and there is a way to solve it:

for(int i=n+1;i<=m;i++){    if (prime(i))    {        if (i==m) return "YES"; else return "NO";    }}return "NO";

where prime(i) is any correct way to check is number i is prime.

Another simple solution of this problem is to conside the fact that restrictions are no more than 50. It is possible to find all pairs n and m by hands and write solution formed by series of cases like this:

if (n==2 && m==3) return "YES";else if (n==3 && m==5) return "YES";else ...else if (n==43 && m==47) return "YES";else return "NO";

This solution gets "accepted" too.

  

Complexity may be various because of diffenent realizations and is in range from O(1) to O(n + m).

If you are interested in why your solution gets "wrong answer" the test "2 5" maybe helps you.

 

 

Depression (problem B, div-2). The problem's author is Marishka

  

The first I pay your attention is while we are moving first arrow the second one is stay motionless. In fact this means that we can solve next two problems independently:

1. Find the angle to turn the minute hand, and

2. Find the angle to turn the hours hand

Next, you may find in statement phrase: "Cogsworth's hour and minute mustache hands move evenly and continuously". It means that after every little increasing of time Δt both hands will move for some little angles.

Number of minutes is always integer because of format HH:MM so every new minute will add 360 / 60 = 6 angles to minute hand. For angle of hours hand influence number of hours and number of minutes. Every new hour will add 360 / 12 = 30 angles to rotate and every new minute will add (360 / 12) / 60 = 0.5 angles.

Thus, we should cut number of hours and number of minutes from HH:MM entry and use formulaes described above for finding the answer.

Look at the time before midday and after noon carefully, analog watch has no difference between them and answers for 08:15 and 20:15 should be equal.

  

Complexity is O(1).

If you are interested in why your solution gets "wrong answer" the tests "20:15" and "00:00" maybe helps you.

 

 

Heroes (problem C, div-2 and problem A, div-1). The problem's author is Alex_KPR

  

It is possble to solve this problem by full search because there are only k = 7 heroes and three team. Let's find all dividings - move every hero in every team and drop away incorrect dividings when al least one team is empty.

In each correct dividing we should find value of experience between two heroes who will receive the maximum and minimum number of experience points and value of total amount of liking in teams.

Now we should choose the best way and write it.

 Complexity is O(3k· k2).

 

 

Falling Anvils (problem D, div-2 and problem B, div-1). The problem's author is dagon

  

In this problem you were to determine the probability if the equation  has at least one real root, assuming that values p and q are independent and equiprobable.

It's equivalent to the condition of non-negativity of the discriminant D = p - 4q. To solve this problem you might draw a rectangle on the (p,q)-plane with the vertices in points (0,  - b), (a,  - b), (a, b) и (0, b) and line p = 4q. Every point of the rectangle corresponds to possible value of p and q and the line divides the plane into two parts where the equation has real solutions and where it hasn't. Then because of equiprobability and independence of choosing p and q the answer is the area of the intersection of the rectangle and p ≥ 4q set divided by the area of the rectangle in case of it's nonsingularity (a, b ≠ 0).

If single number among a and b is equal to zero, the rectangle degenerates to the segment and the sough-for probability is equal to ratio of length of intersection of the segment and p ≥ 4q set and the lenght of the whole segment. In case a = b = 0 the answer is evident and equal to 1.

 

Complexity is O(t).

If you are interested in why your solution gets "wrong answer" the mini-tests "0 1", "1 0" and "0 0" maybe helps you.

 

 

Beavermuncher-0xFF (problem E, div-2 and problem C, div-1). The problem's author is Marishka

  

Let's assume that in vertix v it is possible to find pair of values  < xi, yi >  for every child vi where xi is maximal amount of beavers which can eat beavermuncher if it comes to vertix vi and return back, and yi is amount of beavers which will still alive in vertix vi after beavermuncher's ride.

Let's sort all children vi by value of xi. We should visit vi in sorted order from highest value of xi to lowest while there is possible to return back to root. If after ride to all children vertix v contains of some non-eaten beavers we must continue eating by following way. Let's find some value of yj which is greater than zero. We should move to vertix vj and after that move back to v. This operation must be executed as many times as possible. Of course, the process shouldn't be emulated, we may repeat this way with vertix vj for min(b, yj) times, where b is amount of beavers in vertix v which are remaining.

So we find a pair  < x, y >  for vertix v by knowing values  < xi, yi >  for every child vi, where x is amount of eaten beavers and y is b - number of remaining beavers.

Answer is a value of x for staring vertix s.

 

Complexity is O(n· logn).

If you are interested in why your solution gets "wrong answer" the tests with n = 1 maybe helps you.

 

 

Domino Carpet (problem D, div-1). The problem's author is Alex_KPR

  

Look at squares of Domino Carpet. They are can be only in one of this three states:

1. Here can be any domino chip

2. Here can be only horizontal domino chip

3. Here can be only vertical domino chip

No matter what is in squares, only their states are important.

Look at the any pair of columns j and j + 1 where in some row located horizontally chip of domino. We may cut this pair of jointed columns n × 2 from carpet and don't be afraid about cutting some another chips. So, this pair of columns may be completed independently from another columns.

If n is even number it is possible to complete some columns of single width, not only pair of columns. There is only way to do this - we should put all dominoes vertically.

This formula is describing all situations above: dj = (dj - 2· qj - 2) + (dj - 1· pj - 1), where j is an amount of completed columns, pj is an amount of all possible ways to complete only j-th column (it can be only 0 or 1) and qj is an amount of all possible ways to complete j-th and j + 1-th columns.

Obviously, this formula is incorrect. If some pair of jointed columns we will complete by only vertical dominoes then this way will be counted twice. Let's use the fact that it is unique situation when this formula is incorrect and improve it:

So, dj = (dj - 2· qj - 2) + (dj - 1· pj - 1) - (dj - 2· pj - 2· pj - 1). In dm is answer to the problem.

The only trouble is we need to count pj and qj. pj is 1 when n is even and in j-th column there are no squares in state "here can be only horizontal domino chip". Otherwise pj is 0.

qj can be found by dynamic programming. For every row we should try to put one horizontally oriented domino chip or two vertically oriented and use information about states in observable squares of carpet.

 Complexity is O(n· m).

 

 

Martian Food (problem E, div-1). The problem's author is dagon

  

The problem can be solved using the inversion conversion.

Inversion is the conversion transfering a point with the polar coordinates (r, φ) to a point . It's stated that the inversion transfers straight lines or circles to straight lines or circles. Straight line can be image only of line or circle that includes home (center of the inversion).

Assume the plate a circle with center in (R, 0) and radius R and Honduras - circle with center in (r, 0) ans radius r. Then Guadeloupe and Bull Terriers are situated as on the first picture.



Picture 1. Original picture

Picture 2. After inversion conversion

After applying the inversion conversion the border of the plate transfers to the line  and the border of the honduras - to the line , Guadeloupe and Bull Terriers becomes circles between them, see the second picture. It's easy to find the k-th bull terrier on the picture after applying the conversion, the coordinates of it's center are . To find the radius of the bull terier draw a line through the home and the center of the image of the need honduras. It's possible to prove that the prototypes of this points are diametral points on the bull terrier. So the answer is the distance between them divided by two.

 

Complexity is O(t).

Solutions for Codeforces Beta Round #68By Ripatti, 12 years ago, translation, In EnglishA. You can do exactly what is written in a statement. Only one pitfall in this problem is that room leader may have number of points less than zero.

B. In this problem you may find optimal strategy for a stowaway. Next you may just simulate a game.

Optimal strategy for the stowaway is placing from a conrtoller as far as possible. In the moving minute the stowaway should go into wagon that farther to the controller. In the idle minute stowaway should go into wagon in which the controller enter as later as possible. It is always the first or the last wagon of train.

You may also wrote some dynamic programming solution or a solution fot classic game.

C. Define a trajectory as a line that center of a billiard ball is drawing while it is moving. At begin of moving, the ball chose one from no more than two trajectoties and is moving along of it. Let a number of trajectories is k. Define z as maximal number of billiard balls that can be placed into chessboard without hits (it is answer for problem).

Theorem. z = k.Proof. Every ball covers at least one trajectory. Two different balls cannot cover one trajectory because then they hit each other. Therefore, z ≤ k.Now try to arrange k balls that they don't hit each other. Every cell of perimeter of board belongs to exactly one trajectory. Every trajectory covers at least one from border cells. So, there is exists k cells on perimeter of board whick belongs to different trajectories. Into these cells we should put all billiard balls. End of proof.

This theoren gives constructive methode to find k.  We may just calculate number of connected component in graph like in a picture below. It can be done by BFS, DFS or disjoint set union in time O(n + m).

For example, on picture 4 components are present.

In this problem alse some solution by formula exists. z = gcd(n - 1, m - 1) + 1. You may wrote some stupid solution for observe it. But this formula is difficult for prove.

D. You may use some data structire that allows fast insert, search, remove of elements and find a minimum of all elements. There can be used, for example, std::set in C++ or analogicaly container in other languages. In this structure segments of empty hooks can be stored. Minimum element in structure should be a segment into which a current coat can be hanged.

In addition, for every arrived employee you may store place of his coat and segments of empty hooks in the left from this place and in the right from one.

With help of this structures you can in  emulate a work of cloakroom. Difficults begins with director's queries. We can fastly insert, delete and find sum in a segment.

Online solution. There can be written some balanced or decart tree.

Offline solution. At first, iterate over all queries "in idle" (we will nor answer for director's queries) and store coordinates of all hooks on which ever coat was hanged. Next, squeeze these coordinates and iterate over all queries again. Now we can answer for director's queries by using Fenwick or segment tree.

E. A following sequence of operations swaps two pieces in positions 0 and 1: D1 R1 D1 L1 D1 R1 D1 L1 D1 R1 D1 L1 D1. This sequence can be found on a paper by hands or by usung bidirectional BFS with limitation of allowable moves (it also can be found by ordinary BFS with very limited number of allowable moves). Analogically you can swap any two neighbouring pieces in 13 moves.

Then the solution is trivial and easily fits in the limit of 10000 moves.

Codeforces Beta Round #67 (Div. 2) EditorialBy ahmed_aly, 12 years ago, In EnglishProblem A:In this problem you need to do what is written in the statement. You can do it in the following 3 steps:1- Calculate C.2- Remove all zeros from A, B and C.3- Check if the new values form a correct equation.

C++ solution for problem A.

Problem B:This problem is a direct simulation to the rules written in the problem statement.You need to iterate over all actions and parse each one to know the type of the action, and the 2 names X and Y, and if your name is X or Y then update your priority factor with this person with the action corresponding value. And take care about some special names like "post", "wall", "commented" and "on".Then sort all names according to the sorting criteria mentioned in the statement.Just make sure to print all names which are mentioned in the input (excluding yourself), even if the priority factor with you is 0.

C++ solution for problem B.

Problem C:In this problem you will need to generate all common divisors between a and b before answering any query.The first step in this problem is to factorize a and b, you can use the trial division technique which runs in O(sqrt(N)), you can check getFactors function in my solutions.Then using a recursive function you can generate all divisors for a and b from their prime factors, you can check getDivisors function in my solutions.Then intersect the 2 sets of divisors for both to get all common divisors, you can do this in O(N+M) where N and M are the lengths of the 2 sets, and also you can do a trivial O(N*M) intersection algorithm, because the maximum number of divisors is not too big (it's 1344).Now for each query you need to find the largest common divisor which lies in the given range, you can do this by sorting all common divisors and do binary search for the largest one which lies in the given range. Also you can do this using linear search, because the total number of queries is not too big.

Also there is much shorter solution for this problem. Here is a hint for it, the GCD between a and b should be dividable by all common divisors of a and b.

C++ solution for problem C (with binary search).C++ solution for problem C (without binary search).Java solution for problem C (with binary search).

Problem D:This problem is my favorite one in this problem set. Maybe it will be easier to solve this problem if you know how to solve the standard one.But because we can't construct the big array, so we can't apply the standard solution for this problem.Let's see first how to solve the standard problem, the following code solves it for a given array arr with length len:

int mx = -(1 << 30);int sum = 0;for (int j = 0; j < len; j++) {    mx = max(mx, arr[i]); // we need this for the case where all elements in the array are negatives    sum += arr[i];    if (sum < 0)        sum = 0;    else        mx = max(mx, sum);}

Now let's solve the big array problem, the first step is to calculate 4 values for each small array:1- The total sum of it, let's call it tot.2- The maximum sum of 0 or more consecutive elements starting from the first element in the array, let's call it lft.3- The maximum sum of 0 or more consecutive elements ending at the last element in the array, let's call it rght.4- The maximum sum of 1 or more consecutive elements, let's call it gen.

The final result will be 1 of 2 cases:1- The consecutive elements with the maximum sum will start and end inside the same small array.2- The consecutive elements with the maximum sum will start and end inside different small arrays.

For the first case, we can simply pick the maximum gen for all small arrays which exist in the big array.For the second case, we can apply something similar to the standard solution, we will keep a variable called sum, and it's initialized to 0, this will be the maximum sum of 0 or more consecutive elements ending at the last element in the previous small array. Now for each small array, if the maximum possible sum will end in this small array, so it will be sum+lft and maximize over this value (make sure this will be for 1 or more elements). And we need to update sum to be the maximum of the following 3 values:1- sum+tot (we will include all elements of this small array to the old sum).2- rght (we will take the maximum sum ending at the last element in the current small array).3- 0 (we will not take any elements in sum).

The running time for this solution will be just for reading the input, in my solutions I have no iterations except for reading the input.

You can check my solutions for more clarification.

C++ solution for problem D.Java solution for problem D.

Problem E:The main idea for this problem is not hard, but maybe the hard part is implementing it.First we need to know if the straight line segment between the source and destination points intersect with the island or not. So we will intersect this line segment with all the polygon sides. If there are 2 segments intersect in more than 1 point we will consider as they don't intersect, because it's mentioned in the problem statement that you can move on the island's edge and it will be considered in the sea.Now we have a set of all distinct intersection points of the polygon and the straight line segment between the source and destination points. Because the polygon is convex, this set will contain at most 2 points. We have 3 different cases now:1- This set contains less than 2 points.2- This set contains 2 points and they are on the same polygon side.3- This set contains 2 points and they are not on the same polygon side.

In the first 2 cases the result will be simply the length of the straight line segment.In the 3rd case you can do the following:1- Move from the source point to the nearest point of the 2 intersection points.2- You have 3 options here:    a- Move inside the island to the other intersection point.    b- Move in clockwise direction on the island's edge to the other intersection point.    c- Move in anti-clockwise direction on the island's edge to the other intersection point.    First option will be considered moving inside the island, and the other 2 options will be considered moving in the sea.    You should pick the minimum one.3- Move from the 2nd intersection point to the destination point.

Another solution:You can construct a graph where the nodes are the source point, the destination point, the intersection points and the polygon corner points. Then add an edge between any 2 points which you can move between them with the corresponding cost. Then run any shortest path algorithm, Floyd Warshall for example.

You can check my solutions for more clarification.

C++ solution for problem E.C++ solution for problem E (with Floyd Warshall).

Codeforces Beta Round #66 editorial: Problems A, B, CBy I_Remember_Olya_ashmelev, 12 years ago, translation, In EnglishProblem A.

Let’s call the monster dimension sizes as x1, x2, x3.

1. O(min(k, x1 + x2 + x3)) solution

We can make at most (x1 – 1) + (x2 – 1) + (x3 – 1) cuttings, so we may assume that k <= x1 + x2 + x3 – 3. For each of the three dimensions we will store an integer ai – number of cuttings performed through the corresponding dimension. Let’s perform the following actions k times: consider all numbers ai which we may increase (ai <  xi - 1) , call these dimensions “uncompleted”. Select the minimum number aj among all uncompleted ai and perform a cut through the corresponding dimension (aj will be increased by 1 as the result). Now let’s consider the resulting set after k actions: {a1, a2, a3}. Using the described algorithm we grant that the maximum element of this set is as little as possible and the minimum element is as big as possible. Because the sum a1 + a2 + a3 = k is fixed, we get the maximum product (a1 + 1) * (a2 + 1) * (a3 + 1) which is the answer for the problem.

2. O(1) solution

Instead of simulation all the k actions we may quickly determine values of numbers ai after using the algorithm described above.

Let x – the smallest value among (xi – 1). When x * 3 >= k on each of the algorithm iterations all three dimensions will be uncompleted. It means that during the first (k / 3) * 3 steps each of numbers ai will be increased by (k / 3). Then 0, 1 or 2 numbers ai will be increased by 1 subject to value of k % 3. So, we have found values ai.

Otherwise (x * 3 < k) during the first x * 3 steps each of ai will be increased by x. After that we will have at most two uncompleted dimensions which can be processed a similar way (we should choose the minimum value x among the remaining uncompleted dimensions).

 

Problem B.

We may assume that we have exactly n awarded places but some of them give 0 points.

Let’s sort places by amount of points (bi) and racers by amount of currently gained points (ai). First let’s find the best place Vasya can reach. In the best case he will get b0 points (where b0 is the greatest number among bi). So, let the total Vasya’s point is v. Now we should to distribute other prize points to racers so that the number of racers better than Vasya will be minimal. For doing that we are to give maximum number of prizes so that corresponding racers will have less than v points. Note that if we can give k prizes keeping this property, than we can give k “cheapest” prizes too. The following statement is also true: if we can get a prize with t points to racer i and to racer j , ai > aj, then it is better to give this prize to racer i. Formally: if there exists a way to give k prizes where this prize will get racer j, than there exists a way to give k prizes where this prize will get racer i. It can be proven the following way. Consider a way to give k prizes where racer j got prize with t points, racer i – s points or didn’t get prize at all. In the first case we can swap prizes for racers i and j: ai > aj and ai + s < v (since racer i have got the prize), so aj + s < v, and ai + t < v i.e. this change is acceptable. In the second case we can just give the prize t to racer i instead of racer j. In the both cases we get a way to give k prizes where racer i receive prize t.

Now including this statement we may give prizes to racers using the following greedy algorithm. Let’s begin to give prizes starting from the cheapest one and check the racers starting from the best one (of course excluding Vasya and the best prize). For each prize i we will go through the racers until applicable racer (j) found: bi + aj < v. If no such racers remain we are unable to give more prizes without violating the rule (racers should have less than v points). In this case we should stop the algorithm and the answer is n – k where k is the number of prizes we have given. If we have found such racer j we can give him prize bi and go to the next prize. Complexity of this step is O(n).

Similarly we can find the worst place for Vasya. For doing that we should give him the cheapest prize (note it may have positive points though). After that we should distribute the prizes iterating over prizes from the largest to cheapest and check racers from the worst to the best one trying to make sum of racer’s points more than v.

Total complexity of the described algorithm is O(n * log(n)) because we have to sort prizes and racers.

 

Problem C.

It is easy to see that if we put some symbol c at position p of the string s it will not affect symbols at positions (p+2) and greater. So we have a standard DP problem. State of the dynamic is described by three parameters: p – the number of already processed symbols (or the index of currently processed symbol of the string), c – the previous symbol, t – the number of allowed symbol changes. To calculate the answer for a state we should choose the best value among all symbols for current position (when t > 0) or just go to the index (p + 1) with current symbol s[p]. Thus we get the followings formulas:

d[n][*][*] = 0

d[p][c][t] = d[p + 1][s[p]][t] + bonus[c][s[p]] when t = 0

d[p][c][t] = max(d[p + 1][c’][t – (c’ <> s[p])] + bonus[c][c’])

where n  is the length of string s.

Computation complexity of the algorithm is O(n * k * h^2), where h is the alphabet size (h = 26 for current problem).

Solutions for Codeforces Beta Round #65 (Div. 2)By Ripatti, 12 years ago, translation, In EnglishA. In this problem you can just do what is written in the statement. Let read all words. For each of them compute its length L, its the first and the last letter. If L > 10, output word without any changes, otherwise output the first letter, next L - 2 and finally the last letter.

B. At first, compute . It equals ⌊ mnk / 100⌋, where ⌊ x⌋ is rounding down. Next we fill first ⌊ z / k⌋ squares with a saturation k. (⌊ z / k⌋ + 1)-th square (if it exists) we fill in a saturation z - ⌊ z / k⌋ k. All other squares we leave with a saturation 0.

C. Define an good polygon as a regular polygon which has a knight in a good mood in every of its vertex. Side of polygon we will measure in arcs which is obtained by dividing border of round table with knights.

Freeze the length of the side. Let this length equals k. Observe that the regular polygon with such length of side exists only if k divides n. We have exactly k of such polygons. Every of them has exactly n / k vertices. Check every of the polygons for goodness by review all of its vertices.

If sum of vertices with knight in a good mood equals to n / k, this polygon is good. Checking of all polygons with some frozen length of side works in an O(n).

Now observe that n has  of divisors. Really, all divisors (may be except only one) we can divide into pairs (for i corresponds n / i, for i = n / i there is no pair). One of divisors in every pair less than . It means thah number of pairs no more than  and number of divisors no more than .

It gives solution - iterate over all divisors of n and for every of them check existence of good polygon with length side equals this divisor. Solution has an  time.

In reality for big n is has  divisors. So solution actually has O(n4 / 3)-complexity. For all numbers less than 105 maximal number of divisors is 128.

UPD. There was found an  solution by some participants. This solution uses following idea. If we have a good polygon with xy vertices, we also have a good polygon with x vertices. So we can check only prime divisors of n (except 2 - here we must check 4).

D. This problem can be divided into some subproblems. Author's solution means following ones:

1. Check validness of square 3 × 3. Square is valid if all cards in it has equal suit or different rank. You may not check equal suit because equal suits imply different ranks.

2. Find 2 valid noninetsect squares 3 × 3 or return thah there are no ones. You can check all pairs of squares for inetsection. If some pair has no intersections check them with solution of subproblem 1.

3. Build set of cards which can be replaced with jokers. Generate full deck without jokers and drop from it all cards which in rectangle n × m are present.

4. Find number of jokers and its positions in rectangle.

5. Main subproblem. At first, solve subproblems 3 and 4. Now replace jokers in rectangle with cards from deck from subproblem 3 by all possible ways. For every replace solve subproblem 2. Arter all of variants of replacement just output answer.

There are O(n2m2) solution with small constant.

E. At first, you can use some search engine for find periodic table in some printable form. Next use copy-paste (one or several times) and format it by deleting all excess. It is mechanical work for no more than 5 minutes. Also some parser may be written. Note than author's solution does not mean write 100 symbols by hand from a picture. Next build some functions which transform symbols into numbers and vice versa.

So, we have some set of numbers. We need summarize some from them and get some another set of numbers. We will use dymanic programming over subsets.

Compute the first dp dp1[mask]->sum. For each subset calculate sum of numbers of all atoms in this subset. It can be done in O(2nn).

Now compute the second dp dp2[mask]->length. The "length" is a length of some prefix of result sequence of atoms which can be obtained by subset mask. If length -1, it means that it is impossible to get any prefix from this subset.

The second dp we can calculate in O(3n). Iterate over all masks and if dp2[mask]!=-1, iterate all its subsets of remained atoms (invert mask and get all its submasks). If some subset has sum of numbers which equals number of (dp2[маска]+1)-th atom from result set, recalculate dp2[mask XOR submask]=dp2[mask]+1.

At end, if dp2[2n - 1]=k, there are solution.

There are O(3n + 2nn) solution.

In this problem some brutforce solutions are passed because it is difficult to pick up some counterexample.

UPD. SkorKNURE found a solution in O(2nn). This solution is some modification of the author's solution.

Instead of dp2 calculate dp dp2'[mask]->(i,j), where i is a length of prefix which mask covers and j is part of number of (i+1)-th atom which mask covers.

Iterate over all masks. For each mask iterate over all its 0-bits (they are atoms which cover nothing from the finish set). We try to cover with this 0-bit a remainder of number of the (i+1)-th atom from the finish set. Let atomic number of an atom for current 0-bit is p and this atom is q-th in the start set. If we cover with this atom only part of the remainder of number of the (i+1)-th atom, dp2'[mask XOR (1<<q)]=(i,j+p). If we cover with this atom the remainder fully (and exactly this remainder, no more!), dp2'[mask XOR (1<<q)]=(i+1,0).

Now dp1 is useless. If at end dp2'[2n - 1]=(k,0), solution exists (it is easy to restore it), otherwise there is no solution.

Analysis Codeforces Beta Round #63 (Div. 2)By map, 12 years ago, translation, In EnglishProblem A.

In this task all you had to do was to make sure that the sum of all Σxi is 0, the sum of all Σyi is 0 and that the sum of all Σzi - 0 .We have not written that condition evidently in order that participants will have a chance to break a solution.

 

Problem B.

In this problem, in fact, you should find a winner at every section. For each section, you must do a full search of all competitors to find a competitor with a minimum section time, which ran that section. Asymptotic of the solution is O(nm).

 

Problem C.

In this task, you had to update the collection of artifacts, which belong to Kostya’s friends, after each purchase . You had to set  a matrix c[i][j] - number of the j-th basic artifact that is required in order to collect the i-th component artifact. Further, one can make a matrix of composite artifacts, where a[i][j] is number of the j-th basic artifact of the i-th friend and a similar matrix b of composite artifacts, and  check whether i-th friend has any a composite artifact of O (MN) after each  i-th friend’s  purchase. Check whether one component of the artifact assembles for O (N): while checking whether the i-th friend is able to collect the j-th artifact you have to check, if there is such u, that c[j [u]> a[i][u], if so, the j-th artefact will not be collected, if not, then you have to increase the b[i][j] and update the values in a[i]).

So.the asymptotics of the processing of all purchases will be O (NQM). Then, we need  to make a list of artifacts for each person, keeping their quantity(a total of O (KN + KM), and sort it (a total of O (QlogQ)).

 

Problem D.

This game is over, because except for a finite number (2) of reflections about the line y = x,the coordinates are changed to non-negative integer (and at least one coordinate is changed to a positive number).

Algorithm for solving this problem  is DFS / BFS (states) where the state is a pair of coordinates, and two logical variables, which denote if the 1 (2) player had reflected a point about the line y = x.

Total number of states is obtained by S <= 4D^2 (pairs of coordinates) * 4 (Boolean variables).

Processing of one state takes O (N) actions (do not forget to try to reflect the point about the line y = x, if the player had not made it earlier in the game). Thereby, we have the overall asymptotic O (ND^2), which works on C + + in less than 200ms.

 

 

Problem E

To solve this problem you have to do a "move" subsegment and know :

 1. The set B of numbers, meeting once, with the function of extracting the maximum for O (logN)

2.The set of numbers appearing on this subsegments with keeping the number of times,that this number is found on this subsegments, with function of verifying how many times the number in this subsegments for O (logN).

 

While moving a segment from (a[i] .. a[i + k - 1]) for 1 item left (a[I + 1] .. a[I + k]) you have to:

1) Check whether a[i] with a[I + k]. If yes, then there is no need to modify the set, otherwise proceed to item 2 and 3.

2) Check how many times we have a[i] in the set A: if 2, then add a[i] to B, if 1, then remove it from  A and B. Do not forget to reduce the corresponding number of occurrences of a[i] in the current segment 1.

3) Check, how many times we have a[I + k] in the set A: if 0, then add a[i] in the B and A, if 1, then remove it from B. Do not forget to increase the corresponding number of occurrences of a[i] the current interval to 1.

 

After that, if the set is not empty, we should take peak from it.

 

So the asymptotics of this process will be O(NlogN).

 

As such data structures  set / map(for those who use C + +) and the Cartesian tree are suitable.

Codeforces Beta Round #61 (Div. 2): Editorial

By Seyaua, 12 years ago, translation, In English

Here you can find the editorial for the past round. You can ask questions in the comments below. Special thank you goes to sdya who prepared editorials for problems D and E, which I used here.

Problem AIn this problem you should answer to 4 questions:

1)       Can we use type byte to store N?

2)       Can we use type short to store N?

3)       Can we use type int to store N?

4)       Can we use type long to store N?

We should check these conditions in the given order. If all these conditions are wrong, the answer is BigInteger.

The simplest way to check these conditions is to store numbers as strings and write a function to compare such strings. In Java you can use type BigInteger.

Problem BTry to check all possibilities for creation artificial rain and calculate how many sections contain water. The maximal answer from all these possibilities is the answer for the problem. To calculate the answer for the given position we should check how many sections are to the left and to the right of the given section receive water. The complexity of this algorithm is O(N^2).

Problem CWill be published later. 

Problem DConsider N distinct prime numbers: p1, p2, …, pn.

Let A=p1*p2*…*pn. Then, easy to see, that the numbers A/p1, A/p2, …, A/pn can be considered as the answer.

The special case is when N=2. In this case there is no answer. We can see that this solution needs long arithmetic. If we choose first n prime numbers as p1, p2, …, pn then the maximal number in the answer for all N<=50 contains less than 100 digits.

 

Of course, there are other solutions. For example, if N=3 numbers 15, 10, 6 are the answer, and for N>3 numbers 15, 10, 6, 6*2, 6*3, …, 6*(N-2) are the answer.

Problem EFirst of all we divide our problem into 2 parts: consider stations from which we can start if we are moving in the clockwise direction and stations from which we can start if we are moving in the counterclockwise direction.

Obviously, if we know the solution of one of these problems, we know the solution of another problem.

So, we may assume that stations are located in the counterclockwise order and we are moving in the counterclockwise direction.

Consider the following differences:

D1=a1-b1,

D2=(a1+a2)-(b1+b2),

D3=(a1+a2+a3)-(b1+b2+b3),

…

Dn=(a1+a2+…+an)-(b1+b2+…+bn);

Obviously if one of Di’s is less than a zero, then we cannot drive one round along the road. Let D = min(Di) – we will use it later.

Obviously, if D<0 then the first station cannot be the start station.

Now, we can check with complexity O(n) whether the first station can be used as the starting point. Next, we want to show how we can check this for the second station with complexity O(1).To show this, consider:

E1=D1-(a1-b1),

E2=D2-(a1-b1),

…

En=Dn-(a1-b1).

Next, substitute Di in these equalities. We get the following:

E1=(a1-b1)-(a1-b1)=0=(a2+a3+…+an+a1)-(b2+b3+…+bn+b1) – (a1+…+an=b1+…+bn=X)

E2=(a1+a2)-(b1+b2)-(a1-b1)=a2-b2

E3=(a1+a2+a3)-(b1+b2+b3)-(a1-b1)=(a2+a3)-(b2+b3)

…

En=(a1+a2+…+an)-(b1+b2+…+bn)-(a1-b1)=(a2+…+an)-(b2+…+bn)

But it’s easy to see that number E1 has the same meaning for the second station as number D1 for the first one. So, we just have to check min(Ei)>=0. But Ei=Di-(a1-b1), so we have to check min(Di-(a1-b1))>=0. Now, we can see that if min(Di)=Dk, then min(Di-(a1-b1))=Dk-(a1-b1). So, if we know Dk, that we can check whether the second station can be the starting point with complexity O(1). Similarly, we can check this for the third, the fourth, …, the nth stations.

Now we should check the same things but assuming that the car is moving in the clockwise direction.

Codeforces Beta Round #60: tutorialBy natalia, 12 years ago, translation, In EnglishProblem A

Fist, consider the case when all the numbers are non-zero. You can take a*c*e grams of sand, turn them into b*c*e grams of lead, and them turn into b*d*e grams of gold, and them turn into b*d*f grams of sand. If b*d*f > a*c*e, you can infinitely increase the amount of sand and consequently the amount of gold. Otherwise, if b*d*f <= a*c*e, it is impossible to get infinitely large amount of gold. The same is true when the fraction  (a*c*e)/(b*d*f) has zero numerator only or zero denuminator only. Otherwise there is 0/0, and  you have to check cases specially.

I explain, why I make this problem to be problem A.

1. Solution of the problem requires very little knowledge of programming (only "if"), so it was feasible for all participants.2. Tricky cases really exist, but I hoped that "stronger competitors will ... help newcomers to catch all bugs by their hacks". And so it happened.

Maybe I was wrong: this problem is too complex for A.

A large number of hacks for this problem is a quite foreseen circumstance. I haven't include the special class of tests into the pretests intendently, to make hacking more interesting. In fairness I should note that Artem Rakhov was against this idea. Beause of this task the problem surfaced that Gassa writes about here in Russian: pretests cover some incomplete set of cases and it is not clear in advance what the event "solution passed pretests" means. I think it should be discussed, and strong principles of pretests development should be stated.

Problem B

The problem has greedy solution. Change a digit in the first date to make it as small as possible. At each of the next steps try all one-digit exchanges in the current date and choose one that makes the date not less than the previous one and as small as possible at the same time. If the last year won't exceed 2011 - the answer is found. Otherwise there is no solution.

How to prove that? Consider any correct answer. Clearly, if the first date in it is different from the smallest possible number that can be obtained from the first of given years, your can put the smallest number instead of it. The second date can be exchanged by the smallest possible number not exceeding the first number, etc.Ar a result you obtain a greedy solution that is built by the algorithm described above. If the greedy solution doesn't exist, solution doesn't esist too.

The problem also has a dynamic solution.

Problem C

Check for each segment in the polyline if Harry can catch the snitch in it. Note that since vp ≥ vs, if Harry can catch the snitch at some moment of time, he can catch it at any later moment. He can just follow snitch along its trajectory. So use binary search in each segment.

About problems with EPS that participants got. The problems may be caused by1) some EPS in the condition: while (leftTime + EPS < rightTime) <do binary search>. The task was to output with a fixed accurancy not only the time, but also the point coordinates. If the difference between the time and the right one is less than EPS, the difference between coordinates may be significantly larger. In such cases you should compare not arguments of a function, but values of the function with EPS. Or the way that I usually follow and that once was not liked by the teacher of numerical methods - to implement some fixed number of iterations of the binary search (say, 60).  2) EPS in comparison of time moments inside the binary search like this:if (currentTime + addTime > distance / potterSpeed - EPS)                                                rightTime = currentTime;                                        else                                                leftTime = currentTime;Here it is better to remove EPS at all. Or to put EPS significantly smaller than the required accurancy for printing the point.

(Code fragments are from Egor's solution.)

Thus, there was no crime with severe limitations. Probably for such problems extreme accurancy tests should be in pretests? It is about principles of pretests making again. 

UPD. The problem has an analytical solution too. Consider the i-th segment. Let (xi, yi, zi) and (xi + 1, yi + 1, zi + 1) be its ends, and let ti be the time required for the snitch to reach the beginning of the segment. Then at the moment t the snitch will be at the point (x, y, z), x = xi + (xi + 1 - xi)(t - ti) / Ti, y = yi + (yi + 1 - yi)(t - ti) / Ti, z = zi + (zi + 1 - zi)(t - ti) / Ti, Ti is a time necessary for snitch to overcome the segment. To catch the snitch at the point (x, y, z), Harry have to overcome the distance that squared is equal to (x - Px)2 + (y - Py)2 + (z - Pz)2 for the time t. It is possible if (x - Px)2 + (y - Py)2 + (z - Pz)2 ≤ (tvp)2. To find the minimal proper moment t, solve the corresponding quadratic equation.

Problem D

Let Si be a set of all possible assignments of the first i students to the houses, that is a set of tuples (a1, a2, a3, a4), where a1 is a number of students sent to Gryffindor, a2 - to Ravenclaw, etc. It's intuitively clear that these sets will not be large. So you can get Si - 1 from Si in a trivial way, and get finally Sn, and determine the answer from it. 

What is a rigorous proof of the algorithm? Let us have a set S = {(ai1, ai2, ai3, ai4)}i = 1, 2, ..., k. Represent its elements as aij = bj + xij, xij ≥ 0, where bj are maximal possible, i.e. there is i for each j such that xij = 0. Let the tuple (b1, b2, b3, b4) be called the base part of S, and the set {(xi1, xi2, xi3, xi4)}i = 1, 2, ..., k be called the variant part of S. 

Initially for S0 both base and variant parts are zeroes. Let us see how base and variant parts change when a current student is added. If a house is fixed for the student, only the base part changes. It increases by 1 at the position corresponding to the house. In particular, it follows that a set with every base part can be obtained (since the string given in the input can contain every combination of symbols G, H, R, S). If the current symbol in the string is '?', it can influence both base and variant parts.

For example, for the string '????' we have:S0 = {(0 + 0, 0 + 0, 0 + 0, 0 + 0)},S1 = {(0 + 1, 0 + 0, 0 + 0, 0 + 0), (0 + 0, 0 + 1, 0 + 0, 0 + 0), (0 + 0, 0 + 0, 0 + 1, 0 + 0), (0 + 0, 0 + 0, 0 + 0, 0 + 1)},S2 = {(0 + 1, 0 + 1, 0 + 0, 0 + 0), (0 + 1, 0 + 0, 0 + 1, 0 + 0), (0 + 1, 0 + 0, 0 + 0, 0 + 1), (0 + 0, 0 + 1, 0 + 1, 0 + 0), (0 + 0, 0 + 1, 0 + 0, 0 + 1), (0 + 0, 0 + 0, 0 + 1, 0 + 1)},S3 = {(0 + 1, 0 + 1, 0 + 1, 0 + 0), (0 + 1, 0 + 1, 0 + 0, 0 + 1), (0 + 1, 0 + 0, 0 + 1, 0 + 1), (0 + 0, 0 + 1, 0 + 1, 0 + 1)},S4 = {(1 + 0, 1 + 0, 1 + 0, 1 + 0)}.

Let us investigate the question of what species a variant part may have. It can be analyzed independently from a base one, taking into account that a base part can be any. Consider a directed graph with vertices corresponding to variant parts and with edges determined by the existence of at least one base part that let go from one variant part to another. We are interested only in vertices reachable from {(0, 0, 0, 0)}.

Proposition. For all the vertices reachable from zero the following properties hold(1) xij ≤ 2,(2) k ≤ 13.

Let us prove that all the vertices not having the properties (1) and (2) are unreachable from zero. Consider a variant part with the property (1). To get all edges going from it you have to try all possible base parts. Note that base parts, that consist of the numbers 0, 1, 2, 3 and contain at lest one 0, are enough. Indeed, base part influence which elements are minimal, and 1 will be added to them. A base part can be always normed to contain at least one 0. If a base part contains numbers greater than 3, then the corresponding positions will never be minimal (since 4+0 > 0+2) and they can be changed equivalently by 3 (3+0 > 0+2).

Unfortunately, my attempts to deal with cases by hand were unsuccessful, so I wrote the program that traverse the described graph. Starting from 0, it builds edges trying only "small" base parts described in the previous paragraph. As a result, the program obtains all the reachable variant parts (there is a little more than 1000 of them) and check (1) and (2) for them. In addition, the program helps to construct a test with k = 13.

The problem was supposed to be a problem on intuition. Participants have another solution passed. Their solution generate all permutations and distribute students greedily with respect to each permutation.This solution was a complete surprise for me. Unfortunately, it is wrong. Test 66 against it was added. Of course, submissions accepted during the round won't be rejudged. If such a solution be expected, most likely I wouldn't give such a task. In terms of intuition this solution is not better and not worse than mine. I hope you will not judge me strictly: it is a beautiful problem, and it was interesting to see how it would be solved. 

Problem E

Consider a graph with floors as vertices and staircases as edges. It is clear that Harry can visit the whole connected component in which he is currently located.

Every edge can be used to reach a new vertex for not more than two times. If a connected component contains n vertices and m edges, only n - 1 edges are used to reach a new vertex during its traversal. The remaining m - n + 1 edges are not used to reach a new vertex in their initial placement. So they will be used to reach a new vertex not more than once.

So using edges of only one connected component you can reach no more than n - m + 1 new vertices. Totally there are not more than   reachable vertices. If m < k - 1, it is impossible to visit all the vertices.  

We show that otherwise (m >= k - 1), if the degree of the vertex 0 is different from zero, it is possible to visit all the vertices. In other words, there is such a traversal that every edge can be moved.  Use depth-first search for the current component. If a current edge goes to an already visited vertex, move it to a new component and traverse it recursively. If a current edge goes to a new vertex, after you visit this vertex and go back, you also can move this edge to a new component. As a result each edge can be moved and used again, if you reach all the components. If a component contains at least one edge, you can go from it to the next one. First visit components with edges, and you will visit them all and by the inequality (m >= k - 1) there are enough edges to visit all the isolated vertices.  

If the degree of the vertex 1 is zero, you can not start a traversal before you move some edge to it. After that you can go by this edge and remove it with the vertex 1 from the graph, becase you can not use this edge once more. If the chose edge is a bridge, you get k connected components and m - 1 egdes. If it is not a bridge, you get k - 1 components and m - 1 edges. In the first case the inequality m >= k - 1 turns m >= k. In the second case -  m >= k - 1. So if not all the edges are bridges, you should not take a bridge. If they all are bridges, you should disconnect an edge from a vertex of degree >= 2 not to came back to the initial situation with the zero degree of the first vertex. If there is no such vertex, it is easy to check that there is no solution.

Codeforces Beta Round #58 tutorialBy Alex_KPR, 12 years ago, translation, In EnglishProblem A. A Student's Dream.

There was a lot of troubles because of incorrect statement. Now I hope statement is ok. Let's solve it. =)

If boy will goes to the left he will take her left hand with his right one and boy's left hand and girl's right hand will be unused. Situation is looks like the same if we swap them vice versa. So, we need to check two situations and choose the best one.

There is a simple way to check comfortableness, let's assume that boy has B fingers on active hand and girl has G fingers on active hand, so:

If B < G they will be happy only when B = G - 1, you may see a pattern GBGBGBG...GBGBG. In this pattern you can add no girl's finger for save the condition in statementIf B > G the worst but correct situation for them is a pattern BBGBBGBB...BBGBB. As you may see this way must be satisfy 2G + 2 >  = B conditionSimple situation is B = G, obviously answer is "yes"

Problem B. Tyndex.Brome.

Let's define p as total length of all potential addresses c. In this problem obvious solution has O(p· k) difficulty and it is getting a TLE verdict. Let's speed up it by next way: we will save all position of letters 'a', 'b', ..., 'z' in address entered by user s separately in increasing order. After this step we can find closest position of letter ci in s for logarithmic time by binary search. This solution has O(p · logk) difficulty that gives "accepted".

Look carefully for length of potential address (it can be more than 105). Answer can be too big and asks you for using integer 64-bit type.

Problem C. Inquisition.

All triangles are located strickly inside of square. It makes problem more simplify, because you don't need to check situations of touching sides.

Let's save all segments of every triangle and cross them in pairs. There are many points at every segment - the results of crossing. Look at the every subsegment which do not contain any points of crossing inside. There are two situations: this subsegment completely lie on the side of some triangle or this subsegment completely lie inside of some triangle.

We may check what is situation by this way: let's take a point at the middle of subsegment. If this point is strickly inside of some triangle then all subsegment is located inside and vice versa. We should calculate only subsegments located on the side of triangles and print their total length.

If you are using integer numbers you should be careful for some operations like vector multiplication because it may leave 32-bit type.

If you are using real numbers you should change you types for as large as possible for good precision (long long in c++, extended in pascal).

Problem D. Wormhouse.

In this problem you asks to find lexicographically next euler cycle or say that there is no way. Let's solve this problem backwards.

We should repeat way of Arnie. Now it needs to rollback every his step and add edges for empty graph (graph without edges). Let's assume we had rollback edge from some vertix x to vertix y. We need to check is there some vertix z that is connected to x by an edge and value of z is more than y? Besides edge (x; z) shouldn't be a bridge because our component needs to be connected. 

No solution answer if it's impossible to find such z at any step.

But if edge (x; z) satisfied to conditions upper is exists let's change it to move and after this step our problem is to find lexicographically smallest euler way. It is possible to find only in unbreaked component of graph so every next step must going along non-brigde edges in vertix with as low number as possible. Of course, we must destroy unachievable vertices and do not destroy initial vertix.

We can check is edge a bridge for O(E) time by depth first search. Total difficulty of algorithm represented above is O(N· E2).

Problem E. World Evil.

Author of this problem is Vasily Vadimov, NNSU. He wrote her own tutorial for you.

In this problem you were to find the maximal flow in network with a cyllinder structure. The dynamic solution with complexity O(mn2n) was considered.It's well known that the maximal flow is equal to value of the minimal cut. Also all the sources must belong to one part of the cut and all the drains --- to the other part. Then we look over all the vertices from the left to the right, from the top to the bottom and append to the one or the other part of the cut, recalculating the answer during the process. The trivial solution has complexity O(2mn) and doesn't fit the time limit.

But we can notice the number add to the answer after appending a new vertice to some part of the cut depends only on what parts of the cut the vertices in the current and the previous columns belong to. So we can calculate such a value using dynamic programming: what is the minimal cut can be obtained by adding i columns and the mask of belongings of vertices of the ith column to the parts of the cut is mask. Then we have 2n conversions because there are 2n different states of the i - 1th column. So we have the O(mn22n) solution.

But this solution also can be improved. We calculate the minimal cut, if i - 1 columns are added completely and j vertices from the ith column are added, and mask of belongings of vertices that have no neighbours on the right is mask. Then we append j-th vertice to one of the parts, recalculate the value of the cut and do the conversion. So we have mn2n conditions and O(1) conversions from the every condition and the solution's complexity is O(mn2n).

Also congratulations to the participants rng_58 and Ra16bit who solved this problem during the contest!

Thanks to boys from NNSU (Vladislav Epifanov, Alexey Shmelev) who helps us with alternating solutions and etc.

Sorry for poor english

Round 57-ABy A.K.Goharshady, 12 years ago, In EnglishProblem A:This was indeed the easiest problem. You just needed to XOR the given sequences.The only common mistake was removing initial 0s which led to "Wrong Answer"Common mistake in hacks which led to "Invalid Input" was forgetting that all lines in input ends with EOLN.

Round 57-BBy A.K.Goharshady, 12 years ago, In EnglishIn this problem signs can be ignored in both initial and answer strings, so first we remove signs from initial strings. Then we make a list of the six possible concatenations of the 3 initial strings and convert all of them to lowercase.For checking an answer string , we remove the signs , convert it to lowercase and check if it is just one of those 6 concatenations.

There were two really nice hack protocols , the first one is:-------__________;_____;;;;;---------_2ab___________;;;

Here all concatenations become empty.

The second one was putting 0 as number of students :D

Round 57-CBy A.K.Goharshady, 12 years ago, In EnglishThe code for converting decimal numbers to Roman was on Wikipedia , so I'm not going to explain it.Since we have the upper limit 1015 for all of our numbers , we can first convert them to decimal (and store the answer in a 64-bit integer) and then to the target base.For converting a number to decimal we first set the decimal variable to 0, then at each step we multiply it by the base and add the left-most digit's equivalent in base 10.We had some tricky test cases for this one which got many people :test #51:2 100many codes printed nothing for this one, this was also the most used hack for this problem

test #54:12 2000..00Aa sample of having initial zeros in input

test #55:17 170000000...000There were many people who just printed the input if bases were equal

there were two nice extremal hacks:2 R101110111000 and10 21000000000000000

Round 57-DBy A.K.Goharshady, 12 years ago, In EnglishThis one has two different linear-time solutions. Greedy and dynamic programming.

Greedy solution:You should stop at the city with maximum distance from the root (city number 1). So all roads are traversed twice except for the roads between the root and this city.

Dynamic Programming:For each city i we declare patrol[i] as the traverse needed for seeing i and all of it's children without having to come back to i (Children of a city are those cities adjacent to it which are farther from the root) and revpatrol[i] as the traverse needed to see all children of i and coming back to it. we can see that revpatrol[i] is sum of revpatrols of its children + sum of lengths of roads going from i to its children. patrol[i] can be found by replacing each of revpatrols with patrol and choosing their minimum.

Round 57-EBy A.K.Goharshady, 12 years ago, In EnglishThis one can be solved in O(nlgn) using a segment tree.First we convert all powers to numbers in range 0..n-1 to avoid working with segments as large as 109 in our segment tree. Then for each of the men we should find number of men who are placed before him and have more power let's call this gr[j]. When ever we reach a man with power x we add the segment [0,x-1] to our segment tree , so finding gr[j] can be done by querying power of j in our segment tree when it's updated by all j-1 preceding men.Now let's call number of men who are standing after j but are weaker than j as le[j]. These values can be found using the same method with a segment-tree or in O(n) time using direct arithmetic:le[j]=(power of j -1)-(i-1-gr[j])note that powers are in range 0..n-1 now.Now we can count all triplets i,j,k which have j as their second index. This is le[j]*gr[j]so the final answer is 

( \sum_{j=0}^{n-1} le[j]\times gr[j] )

Round 55 (DIV 2)By pratikmoona, 12 years ago, In EnglishHere I am sharing how I approached and solved the problems of the recently held Round 55 (DIV 2)

A. WordThis was an extremely simple problem. Simply count the number of upper case latin letters. If that is strictly greater than number of lower case letters convert the word to upper case other wise convert it to lower case. Complexity: O(wordlength)

B. Fortune TellingFor this problem all you need to do is store the smallest odd number of petals and also the sum of all the petals. It is quite obvious that only if the number of petals is odd the result would be "Loves". So if the sum is even print sum - smallest odd, otherwise print the sum.Complexity: O(n).

C. TitleThis was a very nice problem. My approach was to first flag all the letters which have already appeared. Notice, that we have to output the lexicographically smallest palindrome. So, start from the middle of the letter and iterate one side...If you get a '?' stop and check if the corresponding position on the other side also has a '?'. If yes, then fill both with the lexicographically biggest letter which hasn't appeared yet in the word and also flag that letter.Once you have exhausted all the letters and there are still '?' left then simply fill them with 'a'.

Now simply iterate over the word again and see if there are any question marks left, if yes copy the values in the corresponding block on the other side. At the same time check if at any time the two opposite values match or not. If they do throughout then it is a valid plaindrome which is also the lexicographically smallest palindrome.

Here is a slightly messy implementation of the same: http://codepad.org/Fr7NYqYTComplexity: O(wordlength + k)

D. Team ArrangementThis was in my opinion was the toughest problem. However once you get the logic, its pretty obvious. However, it was a slightly challenging implementation for me as the structure of the data to be stored was sort of complex.

The basic idea was simply that if we have to find the preference list of a number 'p' then two things might happen:Case 1: p is the most skilled in his team and thus he chose the team. In this case we know that all the members of the teams coming after p's team are less preferred than p's team mates. Let p's team mates be 'm' and 'n' such that m > n.

To get the lexicographically smallest preference list, we will divide all the programmers into two lists. The first list will contain all members (ai) from teams which were chosen before p's team such that ai < m. It will also contain m and n.

The second list will contain all the left over members.

The separation can be done in O(n) time. Now all we need to do is sort the first list, print it, sort the second list, print it!

Complexity: O(nlogn)... It can be reduced to O(n) also but the constant will be pretty high and will give almost the same result as O(nlogn).

Case 2: p is not the leader of the team. Then you just have to output all number except 'p' from 1 to 3 * n.

As for the last problem, I do not have a solution. I do not have much experienced with implementing graphs unfortunately.

Please point out any optimizations to the above or mistakes which I might have made in the above.

Codeforces Beta Round #54 (Div.2) - разбор A-DBy yeputons, 12 years ago, translation, In EnglishProblem A. Chat roomSolution is greedy algorithm. The first thing we do is find in our string the first letter 'h'. Then we find letter 'e' which is righter that found 'h'. If we find the whole word 'hello' in such way, obliviously, answer is YES.Now let's prove that if answer exists, we find it. Let see on position of the 'h' in right answer. If we move it to the first 'h' in our string, nothing changes. But now we can say that our greedy algorithm correctly Now let's do such with the second letter, and so on.We have greedy algorithm with work time O(n), where n - length of the input.

Problem B. CoinsThis problem also have greedy solution: we run down all number from 2 and greater and while denomination of the last added to answer coin is divisible by current number, we divide and increase answer.You can prove correctness, if you take a look at prime factorizations of coins' denominations. In each next denomination each prime have less or equal power than the current one (it's equivalent to 'a divide b'). Obliviously, if summary degree of primes decreases at least two (for example, we had numbera = x· y· z (where y, z > 1, and the current number is b = x), then we can add one more coin with demonitaion a > c = x· y > b. So, in the optimal answer sum of degrees decreasing at exactly one. Our greedy algorithm do exactly what it need.

Problem C. Trees.The first thing we notice - beautiful sequence is can be determined with any member. The next thing - at least one tree will remain the same height. Prove: let's fix height of the first tree, and correct heights of all other ones. Obliviously, they all remain positive.Solution with work time O(n2): we run down which tree we will fix, determine required height of the first tree and then relax answer.This solution can be optimized to linear solution: if we don't touch some tree, we know the first element of sequence. Let's count for each possible element amount of trees, which have required height. It can be done with linear loop and the 'increment' operation on array. After that we just find value of the first element, for which amount of 'good' trees is maximal and output n - x, where x is this amount.

Problem D. CalendarWe know, that all lines of calendar should have equal length, so we can find this length. It's just , where suml - summary length of all strings. Now let take a look at string, which will be the first one in our calendar. Obliviously, it's profitably to take string with maximal s + d (where s is our string and d - is character from input). Such string is unique otherwise we have two equal strings in input (as d is not contained in any string); Of cause, you should remember that if you fix the first string in a line, you fix length of the second one - it's required to have at least one such. Great, now we know the first string in our calendar. Now let's determine the second one. We know it's length, so we need just to take minimal string with such length.We know one line, let's do similary with the second line and so on.

Problem E. ExpressionUnder construction. The main idea is 3D dynamic with O(102) transition.

Round 51, ABy Rei, 12 years ago, translation, In EnglishProblem A.This problem is solved by simple emulation. After 2n jumps flea returns to initial position, because 1 + 2 + 3 + ... + 2n = n(2n + 1) is divisible by n. Moreover, after that, jumps would be the same as in the beginning, because 2n is divisible by n. So it is just enough to emulate first 2n jumps.In fact one may see that it is enough to emulate first n jumps and moreover answer is "YES" exactly when n is power of two. Last gives alternative solution. For example: printf("%s", n&(n-1) : "NO" ? "YES");

Round 51, BBy Rei, 12 years ago, translation, In EnglishProblem B.One just needs to calculate all possible answers and find the minimum. For example one may run on a set of numbers, for all pairs of numbers apply next operation to that pair and recursively run on a new set of numbers. When only one number remains, compare it to the already obtained minimum, and change that minimum if  it's needed.

Round 51, CBy Rei, 12 years ago, translation, In EnglishProblem C.Vladimir wins exactly when there is a pie with distance to the border not greater than 4. Indeed if there is such a pie, then Vladimir will move it to the border and then move it around the whole rim. Of course if there would be any chance to throw this pie from the board, Vladimir will use it. If he gets no such chance, then after mentioned moves all border is banned. But it means Vlad made at least 2n + 2m turns, when Vladimir only 2n + 2m - 1 as a maximum. A contradiction. Else, if there is no such pie, then during first 4 turns Vlad would ban sides adjacent to each corner of the board. After that, if some pie comes to the rim he would ban adjacent side (there is no more than one such side) ans so Vladimir will never get the pie.

So solution consists of only one distance check, but, as one may see, it is easy to make mistake.

Round 51, D

By yaro, 12 years ago, translation, In EnglishIn this problem one should answer the query: how many beautiful numbers are there in the interval from 1 to R.

Clearly, to check whether a number is divisible by all its digits, it is sufficient to know the remainder of a division by the lcm of all possible digits (call this lcm M), that is M = 8 * 9 * 5 * 7 = 2520. The standart dynamic solution is supposed to maintain such state parameters: the length of the number, "strictly less" flag, current remainder of a division by M and the mask of already taken digits.

The first note: we can maitnain the lcm of the digits already taken, not the mask. This will decrease the number of different values of the last parameter (from 256 to 4 * 3 * 2 * 2 = 48, where 4 is the number of different powers of 2 etc).

Then, it is a good idea to pre-count transitions to the new parameters. But we wanted and tried to set such a time limit restriction, so that this solution would not be enough to avoid TL.

The idea that will decrease the running time even more lies in number theory. If we add digits from the end of a number we may see that the remainder of a number after division by 5 depends only on the last digit. Therefore, we may maintain the flag "last digit = 5 or 0" and ban transitions to the digit 5 if the flag is set to "false". Such an idea reduces the number of states by 5 * 2 / 2 = 5. This solution is fast enough to pass in any language, though there are even more powerful optimizations (the trick mentioned above can be done with digit 2 also).

Round 51, EBy yaro, 12 years ago, translation, In EnglishLet us solve this problem for every point P independently. We will show how to do this in linear time, that is, O(N). It seems that the most easy way to do this is to count the number of triangles not containing P (call them good), and then subtract this value from the total number of triangles.

Consider triples of vertices A, B, C that form a triangle, such that: P doesn't lie in ABC; AB separates P and C in the polygon; P lies in the polygon to the right from AB (clockwise). Note, that every good triangle provides us one such triple and each triple forms a good triangle. Thus, we may consider such triples instead of good triangles.

Let's consider an arbitrary vertex of the polygon. We want it to become an A-vertex in some triple. Then we can obtain the set of vertices, suitable for B-vertex in a triple moving diagonals from A (clockwise) until we reach P. Then for the fixed A the number of triples is equal to the sum of the number of triples for this A and the fixed B, which is equal to the sum of some linear series (as all suitable C lie between A and B and their number is equal to the vertex-distance between A and B minus one).

The only thing left to do is to find the last B (last until P is reached) for each vertex of the polygon. And this is a simple exercise on the two pointers technique.

Codeforces Beta Round #50: Editorial for problem CBy e-maxx, 12 years ago, translation, In EnglishSolution for this problem consists of two stages. First stage - counting the numbers with 1 as their first digit in the [L;R] segment. Second stage - using this information (in fact, by given probabilities that i-th quantity will be good) solve the problem about K percents.

To solve the first sub-problem one can generate all segments of good numbers and look how many numbers from them lie in the [L;R] segment. Segments of good numbers are of form [1;1], [10;19], [100;199] and so on, that is, [10i;2· 10i - 1]. After noticing that, calculating their intersection with [L;R] segment is quite easy.

So, we've learnt how to calculate the probability p[i] that i-th quantity is correct: this probability p[i] equals to a fraction of the number of good numbers and R[i] - L[i] + 1.

Now we can go to the second stage of the solution: solving the problem with N quantities and K percents. Now we know the probabilities p[i] that this or that quantity is good, and want to find the probability that K percents of them will be good. This can be done using dynamic programming: let's D[i][j] - probability that among first i quantities exactly j will be good. The starting state is D[0][0] = 1, and calculation of other states can be done as following:

D[i][j] = p[i - 1]· D[i - 1][j - 1] + (1 - p[i - 1])· D[i - 1][j].

After that answer to the problem will be a sum of D[n][j] over all j such, that j / n ≥ k / 100.

Codeforces Beta Round #50: Разбор задачи DBy e-maxx, 12 years ago, translation, In EnglishI'll describe here an author's solution for this problem.

The solution is by a method of dynamic programming: the state is a pair (pos, pref), where pos - the position in the string built (it is between 0 and n), and pref - the current prefix of pattern P (i.e. this is a number between 0 and length(P)). The value pref will help us to control all occurences of pattern P: if pref = length(P) then it means that here is an ending of occurence of pattern P (the beginning of the occurence was at pos - length(P)).

The value D[pos][pref] of the dynamic is true, if the state is reachable. We start from the state (0, 0) and want to get to any state with pos = n.

How to make moves in the dynamic? We iterate over all possible characters C and try to add it to the current answer. That's why we get into a stage (pos + 1, newpref), where newpref is a new length of prefix of P. The problem constraints permitted to calculate this value newpref easily, i.e. just by searching for substrings of form P[length(P) - oldpref..length(P)] + C in the pattern P.

For example, if P = ab and pref = 1, then with the character C = a we will get into newpref = 1 (because we added character a to the string a, - we got string aa, but its longest suffix matching with the prefix of string P equals to a). If we took C = b then we would get into state newpref = 2. Any other character would move us into the state with newprefix = 0.

But in reality, of course, an algorithm for calculating prefix-function can be guessed here. Really, in fact, we answer the following query: "we had some prefix of pattern P and added character C by its end - so what will be the new prefix?". These queries are answered exactly by prefix-function algorithm. Moreover, we can pre-calculate answers to all of these queries in some table and get answers for them in O(1) from the table. This is called an automaton built over the prefix-function.

One way or another, if we've taught how to calculate newpref, then everything is quite simple: we know how to make movements in dynamics from one state to another. After getting the solution we'll have just to restore the answer-string itself.

The solution's asymptotics depends on the way we chose to calculate newpref. The fastest way is using the prefix-function automaton, and the asymptotics in this case is O(kn2). But, I remind, the problem's constraints allowed to choose some simpler way with worse asymptotics.

P.S. This problem was additionally interesting by the fact that one can invent many strange simple solutions, which are very difficult to prove (and most of them will have counter-examples, but very rare ones). Some of these tricky solutions passed all systests in the round. I have also created one relatively simple solution that looks rather unlike to be right, but we didn't manage to create counter-example even after several hours of stress :)

Codeforces Beta Round #50: Editorial for problem EBy e-maxx, 12 years ago, translation, In English



The most important step on the way to solve this problem - is to understand that it's enough to consider only such rotations of the polygon, that one of its sides lies on the side of the room.

Let's try to understand this fact. Suppose that the fact is wrong, and there exists such a position of vacuum cleaner, that neither of its sides lies on the side of the room. Denote as i and j the numbers of vertices that lie on the room sides. It's easy to understand that the polygon form between vertices i and j doesn't make any sense itself: for each rotation we can see that from the area of triangle OP[i]P[j] some constant area is subtracted, while the concrete value of this constant depends on the polygon form.

That's why we see that the polygon form doesn't influence on anything (if we have fixed numbers i and j), and we have just to minimize the area of right-angled triangle OP[i]P[j]. But, taking into account that its hypotenuse is a constant, it's easy to see that the minimum is reached in borderline cases: i.e. when one of the polygon sides lies on the room side.

So, we've proved the fact. Then we have to invent fast enough solution. We have already obtained an O(n2) solution: iterate over all sides of the polygon (i.e. iterating over all possible i), mentally push it to one side of the room, then find the threshold point j, then calculate answer for given i and j. Let's learn how to do these both things in O(1).

In order to do the first thing (finding j) we can use a method of moving pointer: if we iterate over i in the same order as in the input file, then we can just maintain the right value of j (i.e. when we move from i to i + 1 we have to increase j several times, while it is getting further and further).

In order to do the second thing (the area calculation) we have to do some precalculation. For example, we can find the mass center Q of the vacuum cleaner, and pre-calculate all partial sums S[i] - sums of all triangles QP[j - 1]P[j] for all j ≤ i. After this precalculation we can get the answer for every i and j in O(1) as a combination of difference of two values from S[] and two triangles' areas: QP[i]P[j] and OP[i]P[j].

Tutorial for problems of Codeforces Beta Round #49 (Div.2). All problems now.By yeputons, 12 years ago, translation, In EnglishLet's go.

A. Autocomplete

In this problem you should read the statement and solve in any way. One of the most simple solutions is read string and last visited pages, sort (even bubble source - 1003 isn't a lot, 3rd power because we need 100 operations to compare two strings), and rundown pages. When we find good string, we should write it and exit.If there are no such one, write source string. 'Goodness' of string is checking with one if (to check lengths and avoid RTE) and for.

C. Froggy (Little Frog)

IMHO it's the second difficulty problem. If you cannot see solution just after you saw the statement, you can write brute-force solution (rundown all permutation and check), run it for n=10 and see beautiful answer.Answer is 1 n 2 (n-1) 3 (n-2) 4 (n-3) ... Let's define two pointers - l and r. In the beginning, the first one will point to 1, and the second one - to n. On odd positions write down l (and increase it), on even - r (and decrease it). Do it while l <= r.Proof is rather easy: every jump is shorter than the previous one.

D. Physical education

This problem is also very easy. The first thing we should learn is moving element from position x to position y (y < x). Let's move x to position x - 1 with one oblivious swap. Then to position x -2. And so on.Now we want to make a1=b1. Find in b element, that equals a1 and move it to the first position. Similarly we can make a2=b2. So, we have n steps and at every step we do n - 1 swaps at the most. n<=300, so n(n-1)<=89700<106.

B. Blog photo

Due to bug in GCC I've lost 25 minutes solving this problem. In the end I've used MSVC++.But it was digression, now let's think.The first thing we need to do is fix one side (which are power of two). Because there are two sides and copy-paste is great place for bugs it'll be better to make one more for from 1 to 2 and on the 2nd step swap w and h. It decreases amount of code.Now we know that h=2x. We need to find such w, that 0.8 <= h/w <= 1.25. Solve inequalities for w: h/1.25 <= w <= h/0.8. Because w is integer, it can take any value from ceil(h/1.25) to floor(h/0.8) inclusive. We need to maximize square and h is fixed, so our target is maximize w. We need to let w=floor(h/0.8) and check that it fit borders. If so - relax the answer.It's O(log2 h) solution.Possible bugs are:You calculate square in 32-bit type or like this: int w = ..., h = ...; long long s = w * h; In this case compiler calculate w * h in 32-bit type first, and then convert it to long long. Solution is long long s = (long long)w * hfloor(0.9999999999)=0. The floor function does not correspond with inaccuracy of floating point types. It can be solved either with adding something eps to number before calling floor, or with additional check that difference between floor's result and source value is not greater than 1 - eps.p.s. The floor function is up to 8-9 times slower that conversion to int.

E. Dead ends

The first thing you should notice - - n <= 10. It means, that we have exponential solution and we can rundown some subsets.

Solution is dynamic programming d[m][subm] - number of ways to make connected tree from subgraph m (it's a bit mask) with dead ends subm (it's also a bit mask). Answer is sum of d[2n-1][x], where |x|=k (size of x as a subset is k).Recalculating isn't really hard. For empty subset and subset of two vertexes (either 0 or 1) answer is oblivious. Also you should know that there is no tree with exactly one dead end (it's easy to prove). Now for greater subsets: rundown i from subm - one of dead ends. Cut it off from tree along some edge to b (b shouldn't be a dead end, otherwise we got unconnected graph). Now we have tree with lower count of vertexes and either decreased 1 number of dead ends or with changed i to b (if b had exactly two neighbors). Answer for this tree we know already. In the end of summarizing we should divide answer by k - each tree has been taken as many times, as it has dead ends (k).

p.s. I'll be glad if you tell me my mistakes in English.

Разбор Educational Codeforces Round 47

By awoo, history, 5 years ago, translation, In English1009A - Game Shopping

Tutorial1009A - Game ShoppingLet's keep the variable pos which will represent the number of games Maxim buy. Initially pos=0. Assume that arrays a and c are 0-indexed. Then let's iterate over all i=0…n−1 and if pos<m and a[pos]≥c[i] make pos:=pos+1. So pos will be the answer after this cycle.

Solution (Vovuh)1009B - Minimum Ternary String

Tutorial1009B - Minimum Ternary StringLet's notice that described swaps allows us to place any '1' character to any position of the string s (relative order of '0' and '2' obviously cannot be changed). Let's remove all '1' characters from the string s (and keep their count in some variable). Now more profitable move is to place all the '{1}' characters right before the first '2' character of s (and if there is no '2' character in s, then place they after the end of the string).

Solution (Vovuh)1009C - Annoying Present

Tutorial1009C - Annoying PresentJudging by constraints, you can guess that the greedy approach is the right one.

Firstly, let's transition from maximizing the arithmetic mean to the sum, it's the same thing generally.

Secondly, notice that each x is being added to each element regardless of the chosen position.

Finally, take a look at a function f(d,i) — total sum obtained by applying change with d to position i and notice that it is non-strictly convex. Its maximum or minimum values can always be found in one of these positions: n2 (method of rounding doesn't matter), 1 and n.

Thus, the solution will look like this: for positive d you apply the change to position 1 and for non-positive d — to position ⌊n2⌋. The impact of the change can be calculated with the formula of the sum of arithmetic progression.

Also, you should either do all of your calculations in long double (10-byte type) or maintain sum in long long (you can estimate it with m⋅n2⋅MAXN≤1018, so it fits) and divide it by n in the end (then double will work).

Overall complexity: O(m).

Solution (PikMike)1009D - Relatively Prime Graph

Tutorial1009D - Relatively Prime GraphEven though n is up to 105, straightforward O(n2logn) solution will work. You iterate for i from 1 to n in the outer loop, from i+1 to n in the inner loop and check GCD each time. When m edges are found, you break from both loops.

Here is why this work fast enough. The total number of pairs (x,y) with 1≤x,y≤n,gcd(x,y)=1 is φ(1)+φ(2)+⋯+φ(n), where φ is Euler's totient function. We also want to substract a single pair (1,1). And this sum grows so fast that after about 600 iteratons φ(1)+φ(2)+⋯+φ(600) will be greater than 100000 for any n.

The only thing left is to check that m is big enough to build a connected graph (m≥n−1) and small enough to fit all possible edges for given n (the formula above).

Overall complexity: O(n2logn).

Solution (PikMike)1009E - Intercity Travelling

Tutorial1009E - Intercity TravellingLet's consider each kilometer of the journey separatedly and calculate the expected value of its difficulty (and then use linearity of expectation to obtain the answer).

The difficulty of each kilometer depends on the rest site right before it (or, if there were no rest sites, on the distance from Moscow to this kilometer). So when considering the difficulty of i-th kilometer (one-indexed), we may obtain a formula:

diffi=a12+a222+⋯+ai−12i−1+ai2i−1. The denominator of the last summand is 2i−1 because it represents the situation where the last rest was in Moscow, and its probability is exactly 12i−1.

We can actually rewrite this as follows: diff1=a1, diffi+1=diffi−ai2i+ai+12i, thus calculating all that we need in linear time.

Solution (BledDest)1009F - Dominant Indices

Tutorial1009F - Dominant IndicesIn this problem we can use small-to-large merging trick (also known as DSU on tree): when building a depth array for a vertex, we firstly build depth arrays recursively for its children, then pull them upwards and merge them with small-to-large technique. In different blogs on this technique it was mentioned that this will require O(nlogn) operations with structures we use to maintain depth arrays overall.

However, in this problem we may prove a better estimate: it will require O(n) operations. That's because the size of depth array (if considering only non-zero elements) for a vertex is equal to the height of its subtree, not to the number of vertices in it. To prove that the number of operations is O(n), one can use the intuitive fact that when we merge two depth arrays, all elements of the smaller array are "destroyed" in the process, so if the size of smaller array is k, then we require O(k) operations to "destroy" k elements.

The main problem is that we sometimes need to "pull" our depth arrays upwards, thus inserting a 1 to the beginning of the array. Standard arrays don't support this operation, so we need to either use something like std::map (and the complexity will be O(nlogn)), or keep the depth arrays in reversed order and handle them using std::vector (and then complexity will be O(n)).

Solution (BledDest)1009G - Allowed Letters

Tutorial1009G - Allowed LettersThe idea of solution is the following: we build the answer letter-by-letter; when choosing a character for some position, we try all possible characters and check that we can build the suffix after placing this character. But we need to somehow do this checking fast.

As in many previous Educational Rounds, in this round some participants' solutions were much easier to write and understand than our own model solution.

Authors' solution (uses network flows):

Let's build a flow network, where we have 6 vertices representing the characters of the string and 26 vertices representing the masks of characters. Add directed edges from the source to every node representing some character with capacity equal to the number of such characters in the original string; also add directed edges from every node representing some character to all vertices representing masks where this character is contained (with infinite capacity); and finally, add a directed edge from every "mask"-node to the sink with capacity equal to the number of positions where this mask of characters is allowed.

If we find maximum flow in this network, we can check that the answer exists, and if it exists, build some answer. Now let's try to build optimal answer by somehow rebuilding the flow in the network.

Suppose we are trying to place a character x to position containing mask m. To check whether we can do it, we have to try rebuilding the flow in such a way that the edge from vertex corresponding to x to vertex corresponding to m has non-zero flow. If it is already non-zero, then we are done; otherwise we may cancel a unit of flow going through an edge from source to x-vertex, then cancel a unit of flow going through an edge from m-vertex to sink, decrease the capacity of these two edges by 1 and check that there exists an augmenting path. If it exists, then returning the capacities back and adding one unit of flow through the path source→x→m→sink actually builds some answer where some character x is placed on some position with mask m, so we may place it there; otherwise it's impossible.

When we finally decided to place x on position m, we have to decrease the flow through source→x→m→sink and the capacities of edges source→x and m→sink.

All this algorithm runs in O(n⋅2A⋅A2), where A is the size of the alphabet.

Participants' solution (uses Hall's theorem):

Hall's theorem allows us to check that we may build the suffix of the answer much easier.

Each time we try to place some character, we need to iterate on all possible subsets of characters we still need to place and check that the number of positions that are suitable for at least one character in a subset is not less than the size of subset (just like in regular Hall's theorem). The key fact here is that if we have, for example, 3 characters a yet to place, then we don't need to check any subset containing exactly 1 or 2 characters a, since the number of "suitable" positions for this subset won't become larger if we add all remaining characters a to a subset. So the subsets we have to consider are limited by the masks of possible characters, and there will be only 64 of them.

Solution (Bleddest)

Разбор Educational Codeforces Round 46

By BledDest, 5 years ago, translation, In English1000A - Codehorses T-shirts

Editorial1000A - Codehorses T-shirtsAt first, let's remove all coinciding entries of both lists. The most convinient way is to use map/hashmap but it's not the only option. Now divide entries into categories by their length. You can notice that it takes exactly one second to remove an entry in each category (to make it equal to an entry of the opposing list). Thus the answer is n−(number of coinciding entries).

Overall complexity: O(nlogn) or O(n).

Solution1000B - Light It Up

Editorial1000B - Light It UpAt first, let's insert 0 and M in array a, so all possible positions for inserting will always belong to (ai,ai+1).

At second, let x be value to insert and ai<x<ai+1. It can be proven, that it's always optimal to move x to ai or to ai+1. So, for each (ai,ai+1) we need to check only x=ai+1 and x=ai+1−1. To check it fast enough, we need to know total time of lamp is lit for each prefix and precalculate for each i, total time of lamp is lit if starting from ai light is on / lights is off.

Result complexity is O(n).

Solution1000C - Covered Points Count

Editorial1000C - Covered Points CountThis problem with small coordinates can be solved using partial sums and some easy counting. Let's carry an array cnt, where cnti will be equal to the number of segments that cover the point with coordinate i. How to calculate cnt in O(n+maxX)?

For each segment (li,ri) let's add +1 to cntli and −1 to cntri+1. Now build on this array prefix sums and notice that cnti equals the number of segments that cover the point with coordinate i. Then ansi will be equal to ∑j=0maxXcntj=i. All the answers can be calculated in O(maxX) in total. So the total complexity of this solution is O(n+maxX).

But in our problem it is too slow to build an entire array cnt. So what should we do? It is obvious that if any coordinate j is not equals some li or some ri+1 then cnti=cnti−1. So we do not need carry all the positions explicitly. Let's carry all li and ri+1 in some logarithmic data structure or let's use the coordinate compression method.

The coordinate compression method allows us to transform the set of big sparse objects to the set of small compressed objects maintaining the relative order. In our problems let's make the following things: push all li and ri+1 in vector cval, sort this vector, keep only unique values and then use the position of elements in vector cval instead of original value (any position can be found in O(logn) by binary search or standard methods as lower_bound in C++).

So the first part of the solution works in O(nlogn). Answer can be calculated using almost the same approach as in solution to this problem with small coordinates. But now we know that between two adjacent elements cvali and cvali+1 there is exactly cvali+1−cvali points with answer equals to cnti. So if we will iterate over all pairs of the adjacent elements cvali and cvali+1 and add cvali+1−cvali to the anscnti, we will calculate all the answers in O(n).

So the total complexity of the solution is O(nlogn).

Solution1000D - Yet Another Problem On a Subsequence

Editorial1000D - Yet Another Problem On a SubsequenceThe problem is solved by the dynamic programming.

Let dpi be the answer for the prefix of the array starting at i (it contains the indices i,i+1,…,n).

If ai≤0, then dpi=0.

Otherwise, let's go over the position j, with which the next good array begins. Then we need to select ai positions among j−i−1 positions, which will be elements of the array. The number of ways to choose an unordered set of k items from n of different objects is calculated using the formula Ckn=n!K!(N−k)!. Thus, the dynamics is as follows:

dpi=∑j=i+ai+1n+1Caij−i−1⋅dpj.

The basis of dynamics is the value dpn+1=1.

Solution1000E - We Need More Bosses

Editorial1000E - We Need More BossesIt's quite obvious that we can place bosses only on the bridges of the given graph — if an edge is not a bridge, then removing it doesn't make the graph disconnected, so there still exists a path between any pair of vertices. And if we fix two vertices s and t, and then find some simple path between them, then we will place the bosses on all bridges belonging to this path (since the set of bridges would stay the same no matter which simple path between s and t we choose).

If we find bridges in the given graph and compress all 2-edge-connected components (two vertices belong to the same 2-edge-connected component iff there exists a path between these vertices such that there are no bridges on this path) into single vertices, we will obtain a special tree called bridge tree. Every edge of a bridge tree corresponds to a bridge in the original graph (and vice versa). Since we want to find the path with maximum possible number of bridges, we only need to find the diameter of the bridge tree, and this will be the answer to the problem.

Solution1000F - One Occurrence

Editorial1000F - One OccurrenceSuppose all queries have the same right border r. Then the answer for the query can be some integer i such that the last occurence of i on the prefix [1,r] of the array is inside the segment, but the second to last occurence is outside the segment (or even does not exist). More formally, let f(i) be the maximum index j such that j<i and aj=ai (or −1 if there is no such j); the answer to the query is some number ak such that l≤k≤r and f(k)<l (and k is the rightmost occurence of ak in the segment [1,r]). For a fixed right border r, we can build a segment tree which for every index x such that x is the rightmost occurence of ax on [1,r] stores the value of f(x); and if we query minimum on the segment [l,r] in such tree, we can try to find the answer. Let the position of minimum be m. If f(m)<l, then am can be the answer; otherwise there is no answer.

But this is too slow since we can't afford to build a segment tree for every possible value of r. There are two methods how to deal with this problem: you may sort all queries by their right borders and maintain the segment tree while shifting the right border (when going from r to r+1, we have to update the values in the positions f(r+1) and r+1), or we may use a persistent segment tree and get an online solution.

We tried to eliminate solutions using Mo's algorithm, but in fact it's possible to squeeze some implementations of it into TL. There are two optimizations that might help there. When dividing the elements into blocks, we may sort the first block in the ascending order of right borders, the second — in descending, the third — in ascending order again, and so on. And also it's possible to obtain a Mo-based solution with worst case complexity of O((n+q)n−−√) if we maintain the set of possible answers using sqrt decomposition on it.

Solution with persistent segment treeSolution with persistent segment tree (a bit unreadable but runs faster)Solution with standard segment treeMo-based solution1000G - Two-Paths

Editorial1000G - Two-PathsLet's solve this task in several steps.

Step 1. Calculate dpi for each vertex.

Let dpi be maximal profit of some 2-path starting at i and finishing at i. If vertex i is a root of the tree, then dpi equivalent to d′i, where d′i — maximal profit of 2-path (i,i), when we can go only in subtree of i. The d′i can be calculated with next approach: d′v=av+∑to∈Children(v)max(0,d′to−2⋅w(v,to)).

To calculate dpi we can use next technique. Let's manage next invariant: when processing vertex v all its neighbours (even parent) will hold d′i as if v its parent. Then dpv=av+∑to∈Neighbours(v)max(0,d′to−2⋅w(v,to)). After that, we can proceed with each child to of v, but before moving to it we must change value d′v since we must keep invariant true. To keep it true, it's enough to set d′v=dpv−max(0,d′to−2⋅w(v,to)). Also let's memorize value max(0,d′to−2⋅w(v,to)) as dto(v,to).

Step 2. Processing queries.

Let simple path (qu,qv) be qu→p1→p2→⋯→pk→qv. If qu=qv then answer is dpqu. Otherwise, each edge on this simple path must be used exactly once. But, while travelling from qu to qv using this simple path, at each vertex v we can go somewhere and return to v — the only condition is not use edges from simple path. And we can do it using precalculated values dpi and dto(v,to). So, if we want to find max profit of 2-path (v,v) with prohibited edges (v,to1), (v,to2), so we can use value dpv−dto(v,to1)−dto(v,to2).

Finally, to process queries, let's find l=lca(qu,qv), divide it on two queries (qu,l), (qv,l). Now we can handle all queries offline, travelling on tree in dfs order. Let's manage some data structure on current path from current vertex to the root (this DS can be based on array of depths). Then, when we come to vertex v, just add value dpv−dto(v,parent(v)) to DS in position depth(v) (and erase it before exit). Each query (v,l) becomes a query of sum to some subsegment in DS (don't forget carefully handle value in lca). And, before moving from v to to, you need subtract dto(v,to) from current value of v (here you can at once subtract weight of edge (v,to)). Don't forget to return each change in DS, when it needed.

As we can see, DS is just a BIT with sum on segment and change in position.

Result complexity is O((n+m)logn). Fast IO are welcome.

Solution

Codeforces Beta Round #44: tutorialBy Vasya.V, 12 years ago, translation, In English1) Because of small constraints, just iterate n from 1 to Tn and check for (int n = 1; n <= Tn; n++){    if (n * (n + 1) / 2 == Tn)    {        cout << "YES\n";        return;    }}cout << "NO\n";2) Let's consider a graph, where the letters A, B, C are the vertexes and if  x < y, then the edge y -  > x exists. After that let's perform topological sort. If a cycle was found during this operation, put "Impossible" and exit. Otherwise put the answer.

Another approach is acceptable because of small constaints (by Connector in russian comments).Just iterate over all of 3! permutaioins of the letters and check if they are sorted. If no such permutation, put "Impossible"

3) Let's iterate over all of  6! = 720 permutations. For every permutation let's try to put the first 3 words horizontally, the others - vertically:hor[0], ver[0] - left-uphor[2], ver[2] - right-downhor[1]: (len(ver[0]) - 1, 0)ver[1]: (0, len(hor[0]) - 1)Now let's define N = len(ver[1]), M = len(hor[1]).A Conditions for the solution existencelen(hor[0]) + len(hor[2]) == M + 1 // edges of "eight"len(ver[0]) + len(ver[2]) == N + 1  // edges of "eight"len(hor[0]) >= 3 && len(hor[2]) >= 3 && len(ver[0]) >= 3 && len(ver[2]) >= 3 // "eight" is nondegenerateThe letters at start/end of appropriate strings are matchThe letters on the intersection of hor[1], ver[1] are matchNow we have the right field of the size N x M, and update the answerNote In C++ if you use vector<vector<char> > or vector<string> as the field type, then you can simply use operator "<" for updating.

4) Let's consider not the most efficient, but AC algorithm, with  the complexity O(mCn5log(Cn5)).Let's consider the 1 answer of the system: <number, v>. The amount of the variants of the password is Cnv - not very large number in constaints of the problem, you can simply generate this variants. Declare this set of variants as current. Now, for the every answer let's generate a set of possible passwords, and let's declare the intersection of this set and current set as current. After m iterations we'll have some set. Then we'll erase elements from this set, which were in the answers of the system, and the answer of the problem will be the size of this set.

5) Let's consider an algorightm with complexity O((n + m)log(n + m)).Exclude from considiration every wall can't be achieved by canon:  x > v2 / gBecause of α < =π / 4:Function Xmax(α) is monotonousFunction Y(α, x), when x is fixed, is monotonousSuch observation allows to assign to each wall a section of the attack angle [α1, α2]. If this canon shoots with angle within this section, it hits the wall. These angles can be obtained by solving equation (it will be biquadratic), but because of monotonous we can use binary search.Sort walls by x. Now the initial problem has reduced to the problem: for every shoot it is need to obtain minimal index of the wall, when shoot angle is between attack angles for this wall. This problem can be solved by Segment Tree for Minimum with possibility to update on an interval. At first, fill tree with KInf. Next, for every wall let's perform update(α1, α2, index). Then let's iterate over requests. If getMin(α) == KInf, then missle do not hit any wall and hit the land, otherwise it hit the wall with index getMin(α).

Solutions to Codeforces Beta Round #42, A, B, C, D, E(Amortized Analysis)

By SummerSky, 6 years ago, In EnglishA. Football

This is one feasible solution. We can use the "map<string, int>" provided by C++ to record the number of goals for each team. Moreover, we should also store the name of the two teams, i.e., the two strings (note that it is likely to have only one string appearing in the input). Then, we just compare the number of goals for each team and output the answer.

B. Letter

We can use "getline(cin,s)" provided by C++ to deal with a string containing blank space as input. We first deal with the input s1 and use the "hash" idea to record the number of letters that have appeared. Note that the blank space should not be considered as the problem requires. Then, we deal with the input s2 and similarly adopt the "hash" idea to record the number of letters appearing in s2. Finally, for each letter that has appeared in s2, we check whether s1 has provided enough such a letter or not.

C. Lucky Tickets

For an integer, it is divisible by 3 if and only if the sum of its digits is divisible by 3. A simple proof is that we write the integer as

A=a0*10^0+a1*10^1+...an*10^n

=a1*(10^1-1)+a2*(10^2-1)+...an*(10^n-1)+(a0+a1+a2+...an)

It is obvious that a1*(10^1-1)+a2*(10^2-1)+...an*(10^n-1) is divisible by 3 and thus the conclusion is straightforward.

Therefore, we can count the number of tickets that are divisible by 3 as x, and the number of tickets divided by 3 resulting in a remainder 1 and 2 as y and z, respectively. The answer is x/2+min(y,z), where "/" is integer division.

D. Journey

One can first prove that if both n and m are odd integers, we can definitely not return back to (1,1) without using any teleporter. The proof is based on painting colors. We first paint (1,1) with black and the next cell that we move to with white. Then, for the following steps, we just paint the cells with black and white in an alternative manner. As we visit each cell exactly once except for (1,1), this means that if we successfully achieve this goal, the last cell we reach must be painted with white color, which is contradictory with the fact that we have painted (1,1) with black color. Furthermore, we can always construct a feasible route for the case where at least one of n and m is an even number, and thus the solution can be summarized as follows:

1) Both n and m are odd integers. We start from (1,1) and visit all the cells in the first row and then the second row and so on. At last, we will always reach the cell (n,m), and by building a teleporter at cell (n,m) we can return back to (1,1);

2) At least one of n and m is an even integer. Without loss of generality, assume that n is an even number. We start from (1,1) and move on to (1,m). Then, we visit all the cells in the second row except for (2,1), i.e., we will reach cell (2,2). Next, we go to (3,2) and move on until we reach (3,m). In a word, we just visit the cells row by row but leaving the first column unvisited. Finally, we will surely arrive at (n,2). By visiting the first column, we just return back to (1,1) without using any teleporter.

Note that there exist several special cases. One case is (n=1, m>2), or (m=1, n>2). For this case, we have to build a teleporter at cell (n,m) and then can return back to (1,1). Another case is (n=1,m=2), or (n=2,m=1), where no teleporter is necessary.

E. Race

As both n is not quite large, we can count the number of "lead" for every two cars, which contributes O(n^2) complexity. For the i-th car and j-th car, we adopt two pointers pi and pj to enumerate (or scan) their time segments independently. Moveover, we adopt a "flag" to denote which car is leading over another one. We first find out the shortest time segment T for the current pi and pj, and use it to compute the current distance of the two cars. Then, we compare which car is leading over another one and update the number of "lead" accordingly. Finally, we should decrease the two time segments with T, and if any of them is reduced to zero, we just add pi or pj by 1 so that we move on to check the next time segment. As these operations will change the original values of time segments, we should backup them before implementing such operations so that when we deal with another two cars, the time segments are not "zero". By some simple amortized analysis, the total complexity is O(n^2*k).

I think for this problem, the most difficult step is how to "scan" any two time segments in an efficient and correct manner.

Codeforces Beta Round #40 Mini-TutorialBy A.K.Goharshady, 12 years ago, In EnglishI wrote this post to help my friend , Iman Movahhedi , complete this one.Round #40 was my first contest here in Codeforces and I feel I fell in love with CF just after that.A-Translation: (C# code)Many languages have built-in reverse() function for strings. we can reverse one of the strings and check if it's equal to the other one , or we can check it manually. I prefer the second.B-Martian Dollar: (C# code)Since number of days is very small (2 × 103) we can just iterate over all possibilities of buy-day and sell-day. This will take θ (n2) time which is OK.C-Email Address: (C++ code)The first letter of the input string can not be part of an "at" or a "dot" so we start from the second character. Greedily put "." wherever you reached "dot" and put "@" the first time you reached "at". This will take θ(n) time , where n is the length of input.D-Pawn:For each cell of the table store k + 1 values. Where ith value is the maximum number of peas the pawn can take while he is at that cell and this number mod k + 1 is i.This makes a O(n2 × m × k) dynamic programming which fits perfectly in the time.E-3-cycles: (C++ code)The road map with most edges is a complete bipartite graph with equal number of vertices on each side. (Prove it by yourself :D ). We can make such a graph by putting the first  vertices on one side and the other  on the other side.For sure , number of edges is .

Codeforces Beta Round #37 (Tutorial)By vepifanov, 12 years ago, translation, In EnglishA. TowersThe total number of towers is equal to number of different numbers in this set. To get the maximum height of the tower, it was possible to calculate for each length the number of bars with this length, and from these numbers is to choose the maximum.

B. Computer GameConstraints in the problem allows us to solve it this way: we keep the current number of health from the boss, and current summary damage from used scrolls per second. At the next step, we choose which scrolls we can use in the current second. Of all these, we find the scroll, which causes the most damage, and apply it. If at some point we could not use any of the scrolls, and the current damage in one second does not exceed regeneration, we deduce that there are no answers. Otherwise, continue to iterate the algorithm until the number hit points will be nonnegative.

C. Old Berland LanguageOne of the easiest to understand solutions of this problem is as follows: sort the words in ascending order of length, while remembering their positions in the source list. We will consistently build our set, starting with the short strings: strings of length one can only be strings "0" and "1". If the number of words of length one in a set are more than two, hence there are no answers. Add the desired number of strings of length one to answer, and remove it from the current list. Then look at the string of length two: each of the remaining strings of length one can be extended in two ways (having added to each of these symbols 0 and 1). Add the desired number of strings of length two in our answer, and then increase the length of the remaining strings by one. Continue this process, until we get all words from the input set. You can see that if at some moment the number of allowable words exceeded the number of remaining, the extra words can be ignored and solution takes O (N * the maximum length of input set) time.

D. Lesson Timetable

This problem is solved by dynamic programming:

state of dynamics will be a pair of numbers - the number of current room and number of groups which have first lesson in the room with a number not exceeding the current and for which the second room is not defined yet. For each state check all possible number of groups for which the second lesson will be held in the current classroom. When you add an answer from the new state, it must be multiplied by the corresponding binomial coefficients (the number of ways to select groups which have the first lesson in next room - Xi + 1, and the number of ways to select groups which have the second lesson in the current classroom). 

E. Trial for Chief

First, we construct the following graph: each cell we associate a vertex of the same color as the cell itself. Between neighboring cells hold an edge of weight 0, if the cells share the same color and weight of 1, if different. Now, for each cell count the shortest distance from it to the most distant black cell (denoted by D). It is easy to see that we can construct a sequence of D + 1 repainting leads to the desired coloring:

The first step of color all the cells at a distance less than or equal to D in black colorAt the second step color all the cells at a distance less than or equal to D - 1 in whiteEtc.

Of all the cells, choose the one for which this distance is minimal, and this distance increased by one will be the answer to the problem.

Codeforces Beta Round #36By ir5, 12 years ago, In EnglishGeneral

It was normal codeforces contest except the IO: input.txt/output.txt. I didn't know the IO change before contest began and I got upset. I used an unaccustomed fstream library in the contest, but I should use freopen as below code. (if C++)

    freopen("input.txt", "r", stdin);    freopen("output.txt", "w", stdout);

A Extra-terrestrial IntelligenceSimple problem, calculate the interval length between first two '1's, then check if all interval lenghs are equal.I failed to read the statement "It’s guaranteed that the given record sequence contains at least three 1s" at the beginning, then I stopped for a little.

B FractalThis is also a simple problem, simple iteration is good because the input size is very small.But I stuck at compilation error of vector<string> substitution, then I lost about 10 mins. This upset me. My C++ compiler MinGW outputs compilation error at below code. I don't know what is wrong yet..

        vector<string> vs1(N,string(N,'^'));        vector<string> vs2(2*N,string(2*N,'^'));        vs1=vs2;

C BowlsDifficult geometry. Many branching are required and my submission failed in the contest.When a bowl A is put on a bowl B, the contact point with A,B will be one of below situations.

So when we simulate putting a bowl A, calculate the height of putting on bowl B foreach 0<=B<=A-1, then take maximum height as a bowl A position.To find the contact point, I first wrote binary search method instead because branching was laborious. But it was hacked quickly. (perhaps TLE or WA.)

Be aware that input size N is a bit large to run O(N^2) in 2000 msec limit, heavy calculation must be reduced.Line struct class as below was bad thing because method push_back will consume much time.

    struct Line : public vector<P> {        Line(const P &a, const P &b) { push_back(a); push_back(b); }    };

(I think the input size 3000 was a bad thing because the code which is only a little heavy may got TLE.In Codeforces, TLE may not detect at pretest that contains only easy tests, and we cannot test the worst case in judge server environment, so we can't check if the code will get TLE or not.If O(N^2) algorithm is simply required, N<=1000 would be good.. wouldn't it?)

D New Game with a Chess PieceI didn't read in the contest.This problem looks like Nim, though the rule removing stones is different from Nim. Actually, this problem is not so hard if we experiment with small input size like 1<=N,M<=50.The answer has a relatively comprehensible rule with N,M,K, so we can construct O(1) algorithm. The solution will be simply an enumeration of mathematical expression.I thought D is easier than C, though two problems are in different category.

E Two pathsI don't read yet.

Resultooxxx 1332pts 97th1885->1814

Bad result. I'm shocked at C because I solved many geometry problems before and had a little self-confidence with geometry.If a geometry problem is given next time again, I need to solve it.

Round 32By amit5148, 12 years ago, In EnglishProblem AIterate over all possible pairs of soldiers and count those having difference of their heights less than or equal to d.

Problem BReplace all occurrences of '--' with '2', '-.' with '1' and '.' with '0'.Initially, there was some problem with the test cases but was rectified soon.

Problem CI won't be discussing my approach to this problem as my solution was hacked :( and I haven't tried another approach yet.Earlier I thought that my code failed because I was using int for storing answer,but later found that its giving WA after changing it to long.

Problem DSimple approach was to start finding stars in order of their indexes.For this, first try for stars with smaller radius, then for top and finally for left.Following code may explain it further.

int radius, x, y;for(radius=1; k>0 && radius<=150;++radius) for(x=radius; k>0 && x < N-r;++x)  for(y=radius; k>0 && y < N-r;++y)   if(StarAt(x,y,radius))    k--;if(k==0) //display start at x,y,radiuselse //display -1

Problem EHaven't yet solved this problem too. Will be updating soon.

This was my second contest at Codeforces. I was able to solve more problems this time and enter div 1, so enjoyed it :)

Codeforces Round 28 - tutorialBy Fefer_Ivan, 12 years ago, In EnglishA. Bender ProblemSolution by PolichkaLet's look at the first nail. If it is occupied by the fold place, then Bender will put next fold place on the third nail, then on fifth and so on. Else, is the first nail occupied by end, than second, fourth, sixth and so on nail will be occupied by the fold places.Let's see, if we can complete our polyline with the first nail, occupied by rhe fold place. It means we should check, if we have an unused pod with length dist(nails[n], nails[1]) + dist(nails[1], nails[2]). Then check the third nail and so on.If we have completed the polyline, then we have an answer. Else repeat previous procedure, but starting from the second nail.

B. pSortSolution by PolichkaLet's consider a graph. Vertexes will correspond to place of the permutation. Places will be connected by an edge if and only if we can swap theirs values. Our problem has a solution when for every i, vertex p[i] can be reached from vertex i.

C. Bath QueueSolution by FeferThis problem is solved by dynamic programmingConsider the following dynamics: d[i][j][k].i --- number of not yet processed students,j --- number of not yet processed rooms,k --- maximum queue in the previous rooms.The value we need is in state d[n][m][0]. Let's conside some state (i, j, k) and search through all c from 0 to i. If c students will go to jth room, than a probability of such event consists of factors: Cci --- which students will go to jth room.(1 / j)c· ((j - 1) / j)i - c --- probability, that c students will go to jth room,and the rest of them will go to the rooms from first to j - 1th.Sum for all ñ from 0 to i values of(1 / j)c· ((j - 1) / j)i - c· Cci· d[i - c][j - 1][mx]. Do not forget to update maximum queue value and get the accepted.

D. Do not fear, DravDe is kindSolution by RADLet's split all trucks into different classes by the sum of li + ci + ri. Answer sequence consists of trucks from only one class, so let's solve problem for different classes independently.Let's loop through trucks from fixed class in the order, then follow in the motorcade and update values in dynamics z[k] - maximum profit we can get, if last truck has ri = k.Truck with number i can update two values:it can update value z[ri] with value z[ri + ci] + vi. It means this truck continued some motorcade, started from some previous truck.if li = 0 it can update value z[ri] with vi. It means this truck started motorcade. Answer will be in z[0]To restore the trucks included in the answer, we can keep with the maximal sum in z the index of last truck that updated this sum. Also we store the ancestor p for each truck that updated something in z. This ancestor is calculated when we consider i-th truck and doesn't change further: p[i] = -1 if truck i became beginning of the motorcade, otherwise p[i] = last truck that updated z[ri + ci]. We start restore of the answer from last truck updated z[0]. After that we restore everything using only p.

E. DravDe saves the worldSolution by GeraldProblem by RADLet's look at geometrical locus where DravDe can land. It can be eigher an angle or a line(half-line).1. Locus is an angle if and only if projection of vector v and vector u on Oxy plane is not collinear. This angle is easy to calculate. Angular vertex is DravDe starting point and one of half-lines is collinear with place speed vector projection. Second half-line is easy to calculate:Az + Vz· tv + Uz· tu = 0Ax + Vx· tv + Ux· tu = BxAy + Vy· tv + Uy· tu = Bywhere A - starting point, B - landing point. Consider tv equal to 1 and calculate tu from first equation. From second and third calculate point B. This point lies on the second half-line of the angle.2. If plane speed projection and wind speed projection is collinear, locus is half-line or line, depending on the difference between this two speeds.If the answer exist, than polygon and locus have at least onecommon point. And t1 and t2 is minimal on edge points. So now let's cross all segments with locus, calculate t1 and t2 for each intersection point and select minimal answer. Thank you for your participation. Good luck with upsolving and incoming contests. Luck - is very useful and it is good to have it.With best regards, Ivan.

Codeforces Beta #27 - TutorialBy Fefer_Ivan, 12 years ago, translation, In EnglishA. Next TestWe will create an array of boolean used[1..3001] ans fill it with "false" values. For each of n given number, we will assign corresponding used value to "true". After that, the index of first element of used with "false" value is the answer to the problem.

B. TournamentTo solve this problem first of all we should find such numbers A and B that occur in the input data not (n - 1) times, but (n - 2). We can notice, that winner-loser relation in this problem is transitive. This means that if X wins against Y and Y wins against Z, than X wins against Z. So to find out who is harsher A or B, let's look for such C, that the results of the match A with C and B with C are distinct. If such C exists, than the one, who wins against C should be printed first. If there is no such C, than both results of the match A versus B satisfy problem's statement.

C. Unordered SubsequenceFirst of all, we should notice, that if answer exists, it consist of 3 elements. Here is linear time solution.Let's path with for-loop through the given array and on each iteration let's store current minimul and maximun elements positions. When we are looking at some element, it is enough to check, whereas this element makes unordered subsequence along with min and max elements of the previous part of the array. It is not obvious, but not very difficult to prove. You should try it yourself.

D. Ring Road 2Consider all m given roads as segments on numeric axis. Road from town a to town b should correspond to segment [min(a, b), max(a, b)]. For each pair of segments there are three types of positions: both ends of one segment are inside of the other one, both ends of one segment are outside of the other one and only one end of one segment is inside of the other one. In the first two cases positions of corresponding roads(inside circle or outside) are independend. But in the third case this positions must be oppositeLet's build the graph. Vertexes will correspond to segments/roads and edge between vertexes i and j will mean that positions of this roads should be opposite. Now we have another problem: for given undirected graph, we must paint all vertexes in 2 colours such that for each edge, corresponding vertexes will have different colours. This problem can be solved using DFS algorithm. First, we will paint all vertexes in -1 colour. Let's begin for-loop through vertexes. If loop finds -1-vertex, assing colour 0 to the vertex and run DFS from it. DFS from vertex V should look through all neighbor vertex. If neighbor has colour -1, than assing to that neighbor colour, opposite to the colour of V and run DFS from it. If neighbor already has non-negative colour, we should check whereas this colour is opposite, because if it is not, answer is "Impossible". Such DFS will either build the correct answer or prove that it is impossible.

E. Number With The Given Amount Of Divisors Consider the number, that is our answer and factorize it. We will get such product p1a1· p2a2· ... · pkak. Product through each i ai + 1 will be the number of divisors. So, if we will take first 10 prime numbers, their product will have 1024 divisors. This means that we need only first 10 primes to build our answer.  Let's do it with dynamic programming: d[i][j] - the minimal number with i divisors that can be built with first j prime numbers. To calculate the answer for state (i, j) let's look over all powers of j-th prime number in the answer. If j-th prime number has power k in the answer, than d[i][j] = d[i / (k + 1)][j - 1] * prime[j]k. For each power of j-th prime we must select the power, that gives us minimal d[i][j].You should be extremely careful during the implementation, because all calculations are made on the edge of overflow.

  This is it for now. I hope, you will puzzle out all problems, upsolve them and after next contest will get to the division 1. All questions and remarks you can post in the comments.With best regards, Ivan

Educational Codeforces Round 26 Editorial

By awoo, history, 6 years ago, translation, In English837A - Text VolumeMaintain the amount of capital letters taken by going from left to right, make it zero when you meet space.

Overall complexity: O(n).

837B - Flag of BerlandThere are lots of ways to check correctness. For example, you can keep boolean array with already used colors, check stripes naively and mark the color used if the stripe has single color. If all the colors are used in the end then the answer is YES.

Overall complexity: O(n·m).

837C - Two SealsIf you can place two rectangles in some way (without rotations), then it's always possible to move one of them to the top left corner and stick the other either to the bottom of the first (and push it all the way to the left) or to the right of it (and push it all the way to the top).

Now let's try all possible reorderings and rotations for every pair of seals. If there is at least one correct reordering then update the answer.

Overall complexity: O(8·n2).

837D - Round SubsetLet's use dynamic programming to solve this task.

Obviously, the roundness of the number is determined by minimum of powers of 2 and 5 in the number. Let pw5i be the maximal power of 5 in the number and pw2i be the maximal power of 2.

Let dp[i][j][l] be the maximum amount of twos we can collect by checking first i numbers, taking j of them with total power of five equal to l. It is usually called "the knapsack problem".

There are two types of transitions. You can either take current element or skip it:

dp[i + 1][j + 1][l + pw5i] = max(dp[i + 1][j + 1][l + pw5i], dp[i][j][l] + pw2i)dp[i + 1][j][l] = max(dp[i + 1][j][l], dp[i][j][l])The answer will be maximum of min(i, dp[n][k][i]) for every i. Also keeping this many states can cause ML, the first dimension should be stored in two layers and recalced on the fly.

Overall complexity: .

837E - Vasya's FunctionOne important fact is that when we subtract gcd(x, y) from y, new gcd(x, y) will be divisible by old gcd(x, y). And, of course, x is always divisible by gcd(x, y).

Let's factorize x. Consider the moment when gcd(x, y) changes. If we denote old value of gcd(x, y) by g, the new value of gcd(x, y) will be divisible by some k·g, where k is a prime divisor of x. Let's check all prime divisors of x and for each of these divisors find the number of times we need to subtract g from y to get gcd(x, y) divisible by k·g; that is just  (don't forget that x also has to be divisible by k·g). Among all prime divisors of x pick one with the minimum required number of operations (let this number of operations be m), add m to answer, subtract m·g from y and repeat the process.

837F - Prefix SumsLet's delete all zeroes from the beginning of the array; they won't affect the answer. Also we will return an array of m elements when calculating prefix sums (sum of zero elements becomes a zero in the beginning of the array, and so has to be removed).

If the size of array is at least 10, then we will get k after calculating only a few prefix sums, so we can use simple iteration. So now we have to obtain the solution in case array has less than 10 elements.

If we remove zeroes from the beginning of each array, then p(A) = A·T, where T is a matrix m × m, Ti, j = 1 if i ≤ j, otherwise Ti, j = 0. Then we can use matrix exponentiation to check whether Ai contains a number which is equal to or greater than k, and we can use binary search to find the answer. To avoid overflows, each time we get a number greater than k, we can set it to k.

837G - Functions On The SegmentsLet's build a data structure that allows us to find sum of functions on some prefix. The answer to the query can be obviously obtained using two answers on prefixes.

We will use some persistent data structure that handles prefix sum queries — persistent segment tree, for example. We will actually use two different structures: let the sum of functions in some point x0 be x0·k + m; one structure will allow us to find k, and another one will allow us to find m.

Obviously, for prefix of length 0 both k and m are equal to 0. Then when we advance from prefix of length i to prefix of length i + 1, we do the following: in the structure that handles k we add ki in position xi, 1 + 1 and add ( - ki) in position xi, 2 + 1, so it is added only on segment [x1 + 1, x2]. The same approach can be used to find m: add yi, 1 in position 0, add mi - yi, 1 in position xi, 1 + 1 and add yi, 2 - mi in position xi, 2 + 1. And to get the value in point x0 on some prefix, we just make a prefix sum query to the corresponding structure.

Codeforces Beta Round #25 Solution AnalysisBy choice, 13 years ago, In EnglishProblem A - IQ TestWe can store two values, countodd and counteven, as the number of odd or even elements in the series. We can also store lastodd and lasteven as the index of the last odd/even item encountered. If only one odd number appears --- output lastodd; otherwise only one even number appears, so output lasteven.

Problem B - Telephone NumbersThere are many ways of separating the string into clusters of 2 or 3 characters. One easy way is to output 2 characters at a time, until you have only 2 or 3 characters remaining. Here is a possible C++ solution:

<code>for( i=0; i<n; i++ ){    putchar(buf[i]);    if( i%2 && i<n-(n%2)-2 ) putchar('-');}</code>

Problem C - Roads in BerlandIf you are familiar with the Floyd-Warshall algorithm, then this solution may be easier to see.

Initially, we are given a matrix D, where D[i][j] is the distance of shortest path between city i and city j. Suppose we build a new road between a and b with length shorter than D[a][b]. How do we update the rest of the graph accordingly?

Define a new matrix D', whose entries D'[i][j] are the minimum path distance between i and j while taking into account the new road ab. There are three possibilities for each i, j:D'[i][j] remains unchanged by the new road. In this case D'[i][j] = D[i][j]D'[i][j] is shorter if we use the new road ab. This means that the new path i, v1, v2, ..., vn, j must include the road a, b. If we connect the vertices i, a, b, j together in a path, then our new distance will be D[i][a] + length(ab) + D[b][j].Lastly, we may have to use the road ba. (Note that this may not be the same as road ab.) In this case, we have D'[i][j] = D[i][b] + length(ab) + D[a][j].Thus, for each new road that we build, we must update each path i, j within the graph. Then we must sum shortest distances between cities. Updating the matrix and summing the total distance are both O(N2), so about 3002 operations. Lastly, there are at most 300 roads, so in total there are about 3003 operations.

One thing to note is that the sum of all shortest distances between cities may be larger than an int; thus, we need to use a long when calculating the sum.

Problem D - Roads not only in BerlandBefore we start this problem, it is helpful to know about the union find data structure. The main idea is this: given some elements x1, x2, x3, ..., xn that are partitioned in some way, we want to be able to do the following:merge any two sets together quicklyfind the parent set of any xiThis is a general data structure that sometimes appears in programming competitions. There are a lot of ways to implement it; one good example is written by Bruce Merry (aka BMerry) here.

Back to the problem: Every day we are allowed to build exactly 1 road, and close exactly 1 road. Thus, we can break the problem into two parts:How do we connect the parts of the graph that are disconnected?How do we remove roads in a way that does not disconnect parts of the graph?Let build be the list all roads that need to be built, and let close be the list of nodes that need to be closed. We can show that in fact, these lists are of the same size. This is because the connected graph with n nodes is a tree if and only if it has n - 1 edges. Thus, if we remove more roads than than we build, then the graph is disconnected. Also, if we build more roads than we remove, then we have some unnecessary roads (the graph is no longer a tree).

Now consider the format of the input data:a1, b1a2, b2...an - 1, bn - 1We can show that edge (ai, bi) is unnecessary if and only if the nodes ai, bi have already been connected by edges (a1, b1), (a2, b2), ..., (ai - 1, bi - 1). In other words, if the vertices ai, bi are in the same connected component before we, add (ai, bi) then we do not need to add (ai, bi). We can use union-find to help us solve this problem:

<code>for( i from 1 to n-1 ){    if( find(ai)=find(bi) ) close.add(ai, bi);    else merge(ai, bi);}</code>

In other words, we treat each connected component as a set. Union find allows us to find the connected component for each node. If the two connected components are the same, then our new edge is unnecessary. If they are different, then we can merge them together (with union find). This allows us to find the edges that we can remove.

In order to find the edges that we need to add to the graph, we can also use union-find: whenever we find a component that is disconnected from component 1, then we just add an edge between them.

<code>for( i from 2 to n )    if( find(vi)!=find(v1) )    {        then merge(v1, vi);        build.add(v1, vi);    }</code>

We just need to store the lists of roads that are unnecessary, and the roads that need to be built.

Problem E - TestThe way I solved this problem is with a hash function. Hash functions can fail on certain cases, so in fact, my solution is not 'correct'. However, it passed all the test cases =P

Let the input strings be s0, s1, s2. We can build the shortest solution by permuting the strings and then trying to 'attach' them to each other. I.e., we need to find the longest overlapping segments at the end of string a and the beginning of string b. The obvious brute force solution won't run in time. However, we can use a hash function to help us calculate the result in O(n) time, where n is min(len(a), len(b)). The hash function that I used was the polynomial hash(x0, x1, ..., xn) = x0 + ax1 + a2x2 + ... + anxn. This polynomial is a good hash function in this problem because it has the following useful property:Given hash(xi, ..., xj), we can calculate the following values in O(1) time:hash(xi - 1, xi, ..., xj) = xi - 1 + a × hash(xi, ..., xj)hash(xi, ..., xj, xj + 1) = hash(xi, ..., xj) + aj + 1 - i × xj + 1In other words, if we know the hash for some subsequence, we can calculate the hash for the subsequence and the previous element, or the subsequence and the next element. Given two strings a, b, we can calculate the hash functions starting from the end of a and starting from the beginning of b. If they are equal for length n, then that means that (maybe) a and b overlap by n characters.

Thus, we can try every permutation of s0, s1, s2, and try appending the strings to each other. There is one last case: if si is a substring of sj for some i ≠ j, then we can just ignore si. We can use hash functions to check that one string is contained within another one.

Codeforces Beta Round #22 TutorialBy iakolzin, 13 years ago, translation, In EnglishContest discussion

Problem А. Second Order StatisticsSorting

In this problem one should find a minimal element from all elements, that are strictly greater, then the minimal one or report that it doesn't exist. Of course, there can be a lot of different solutions, but one of the simplest - to sort the given sequence and print the first element, that's not equal to the previous. If all elements are equal, then the required element doesn't exist.

Problem B. Bargaining TableSimulation, dynamic programming

In this problem one should find the maximal perimeter of a rectangle that contains no '1'. Define these rectangles "correct". To solve a problem you are to check each possible rectangle for correctness and calculate its perimeter. The easiest way to check all rectangles is using 6 nested cycles. Using 4 of them you fix the coordinates while other 2 will look for '1'. So the complexity is O((n*m)3). It seems slow, but those, who wrote such a solution, says that it hasn't any problems with TL.

One may interest in much faster solution. Using simple DP solution one can get a solution with an O((n*m)2) complexity. It's clear, that rectangle with coordinates (x1, y1, x2, y2) is correct if and only if rectangles (x1, y1, x2-1, y2) and (x1, y1, x2, y2-1) are correct, and board[x2][y2] = '0'. So each of rectangles can be checked in O(1) and totally there will be O((n*m)2) operations.

Problem C. System AdministratorSimulation

In this problem you are to construct a connected graph, which contains n vertexes and m edges, and if we delete vertex with number v, our graph stops being connected or to report that such a graph doesn't exist. Moreover, each pair of vertexes can have no more than one edge connecting them. Obviously, a connected graph doesn't exist if the number of edges is less than n-1. It's easy to notice, that the maximal possible number of edges reaches when there is a vertex connected to v and doesn't connected to any other vertex, those can form up to complete graph. So the maximal number of edges is (n-1)*(n-2)/2+1. If m is in that range then required graph always exists. Then you should place one vertex on the one side of v (let it be 1), and other vertexes - on the other side. First, you should connect all this vertexes to v and then connect them between each other (except 1).

Problem D. SegmentsScanning line

In this problem one should place minimal number of points on the line such that any given segment touches at least one of these points. Let's call the coordinate of ending of any segment as event. There will be events of two types: beginning of a segment and its ending. Let's sort this events by coordinates. In the case of equality of some events consider that the event of the beginning will be less than the event of ending. Look at our events from left to right: if there is a beginning event, then push the number of this segment to the special queue. Once we take an ending of some segment, place the point here and clear the special queue (because each of segment in this queue will touch this point).

Problem E. SchemeGraph theory

Given an oriented graph, find the minimal number of edges one should add to this graph to make it strongly connected. Looking at statement we can get the fact that each vertex has exactly one outcoming edge. It means that starting at some point we'll get stuck in some cycle. So each connected (not strongly) component is a set of simple paths, ending in some cycle or just a simple cycle. First consider vertexes, which has no incoming edges. When passing through some vertex we'll paint it until the current vertex will be already painted. Then we call the starting vertex as "beginning" and the finishing one as "ending" of a component.

After that consider other vertexes - they belong to cycles. Beginning and ending of a cycle - is any vertexes (possible coinciding) belonging to it. So we got a number of components which we have to connect. Let's connect them cyclically: the edge will pass from the ending of i-th component to the beginning of ((i+1)%k)-th, where k is the number of such components. The answer will be k. There is an exception: if we have only one component which is a simple cycle, the answer will be equal to 0.

So we'll consider each edge exactly once and the total complexity will be O(n).

Codeforces Beta Round #17 TutorialBy tourist, 13 years ago, translation, In EnglishContest discussion

Problem A. Noldbach problem

To solve this problem you were to find prime numbers in range [2..N]. The constraints were pretty small, so you could do that in any way - using the Sieve of Eratosthenes or simply looping over all possible divisors of a number.Take every pair of neighboring prime numbers and check if their sum increased by 1 is a prime number too. Count the number of these pairs, compare it to K and output the result.

Problem B. Hierarchy

Note that if employee, except one, has exactly one supervisor, then our hierarchy will be tree-like for sure.For each employee consider all applications in which he appears as a subordinate. If for more than one employee there are no such applications at all, it's obvious that  - 1 is the answer. In other case, for each employee find such an application with minimal cost and add these costs to get the answer.Alternatively, you could use Kruskal's algorithm finding a minimum spanning tree for a graph. But you should be careful so that you don't assign the second supervisor to some employee.And yes, the employees' qualifications weren't actually needed to solve this problem :)

Problem C. Balance

Consider the input string A of length n. Let's perform some operations from the problem statement on this string; suppose we obtained some string B. Let compression of string X be a string X' obtained from X by replacing all consecutive equal letters with one such letter. For example, if S = "aabcccbbaa", then its compression S' = "abcba".Now, consider compressions of strings A and B - A' and B'. It can be proven that if B can be obtained from some string A using some number of operations from the problem statement, then B' is a subsequence of A', and vice versa - if for any strings A and B of equal length B' is a subsequence of A', then string B can be obtained from string A using some number of operations.Intuitively you can understand it in this manner: suppose we use some letter a from position i of A in order to put letter a at positions j..k of B (again, using problem statement operations). Then we can't use letters at positions 1..i - 1 of string A in order to influence positions k + 1..n of string B in any way; also, we can't use letters at positions i + 1..n of string A in order to influence positions 1..j - 1 of string B.

Now we have some basis for our solution, which will use dynamic programming. We'll form string B letter by letter, considering the fact that B' should still be a subsequence of A' (that is, we'll search for B' in A' while forming B). For this matter we'll keep some position i in string A' denoting where we stopped searching B' in A' at the moment, and three variables kA, kB, kC, denoting the frequences of characters a, b, c respectively in string B. Here are the transitions of our DP:1) The next character of string B is a. Then we may go from the state (i, kA, kB, kC) to the state (nexti, 'a', kA + 1, kB, kC).2) The next character of string B is b. Then we may go from the state (i, kA, kB, kC) to the state (nexti, 'b', kA, kB + 1, kC).3) The next character of string B is c. Then we may go from the state (i, kA, kB, kC) to the state (nexti, 'c', kA, kB, kC + 1).Where nexti, x is equal to minimal j such that j ≥ i and A'j = x (that is, the nearest occurrence of character x in A', starting from position i). Clearly, if in some case nexti, x is undefined, then the corresponding transition is impossible.Having calculated f(i, kA, kB, kC), it's easy to find the answer:  for all triples kA, kB, kC for which the balance condition is fulfilled.

Such a solution exceeds time and memory limits. Note that if string B is going to be balanced, then kA, kB, kC ≤ (n + 2) / 3, so the number of states can be reduced up to 27 times. But it's also possible to decrease memory usage much storing matrix f by layers, where each layer is given by some value of kA (or kB or kC). It's possible since the value of kA is increased either by 0 or by 1 in each transition.

The overall complexity is O(N4) with a quite small constant.

Problem D. Notepad

The answer to the problem is bn - 1 * (b - 1) mod c. The main thing you should be able to do in this problem - count the value of  AB mod C for some long numbers A and B and a short number C. Simple exponentiation by squaring exceeds time limit since to converse of B to binary you need about O(|B|2) operations, where |B| is the number of digits in decimal representation of number B.The first thing to do is to transform A to A mod C. It isn't difficult to understand that this transformation doesn't change the answer.Let's represent C as C = p1k1p2k2...pmkm, where pi are different prime numbers.Calculate ti = AB mod piki for all i in the following way. There are two possible cases:1) A is not divisible by pi: then A and pi are coprime, and you can use Euler's theorem: AB' = AB (mod C), where B' = B mod φ(C) and φ(C) is Euler's totient function;2) A is divisible by pi: then if B ≥ ki then ti = AB mod piki = 0, and if B < ki then you can calculate ti in any way since B is very small.Since all piki are pairwise coprime you may use chinese remainder theorem to obtain the answer.

You can also use Euler's theorem directly. Note that if for some B1, B2 ≥ 29 you know that |B1 - B2| mod φ(C) = 0, then all ti for them will be the same (29 is the maximal possible value of ki). Using that you may reduce B so that it becomes relatively small and obtain the answer using exponentiation by squaring.

There is another solution used by many contestants. Represent B as B = d0 + 10d1 + 102d2 + ... + 10mdm, where 0 ≤ di ≤ 9 (in fact di is the i-th digit of B counting from the last). Since ax + y = ax· ay, you know that AB = Ad0· A10d1· ...· A10mdm. The values of ui = A10i can be obtained by successive exponentiation (that is, ui = ui - 110); if you have A10i, it's easy to get A10idi = uidi. The answer is the product above (modulo C, of course).

Problem E. Palisection

The first thing to do is to find all subpalindromes in the given string. For this you may use a beautiful algorithm described for example here. In short, this algorithm find the maximal length of a subpalindrome with its center either at position i of the string or between positions i and i + 1 for each possible placement of the center.For example, suppose that the maximal subpalindrome length with center at position i is 5; it means that there are three subpalindromes with center at i, with lengths 1 (i..i), 3 (i - 1..i + 1) and 5 (i - 2..i + 2). In general, all starting and finishing positions of subpalindromes with a fixed center lie on some interval of positions, which is pretty easy to find.Let's find for each position i the value of starti, which is equal to the number of subpalindromes starting at position i. All these values can be found in linear time. Let's create an auxiliary array ai. If after processing a position in the string some new pack of subpalindromes was found and they start at positions i..j, then increase the value of ai by 1, and decrease the value of aj + 1 by 1. Now . Proving this fact is left as an exercise to the reader :)In a similar way it's possible to calculate finishi, which is equal to the number of subpalindromes finishing at position i.Since it's easy to count the total number of subpalindromes, let's find the number of non-intersecting pairs of subpalindromes and subtract this number from the total number of pairs to obtain the answer. Note that if two subpalindromes don't intersect then one of them lies strictly to the left of the other one in the string. Then, the number of non-intersecting pairs of subpalindromes is equal to: This can be calculated in linear time if the value of  is recalculated by addition of finishi before moving from position i to position i + 1.The overall complexity of the algorithm is O(N).

Codeforces Beta Round #14 tutorialBy slycelote, 13 years ago, In EnglishA. LetterTo find the smallest rectangle containing the picture, iterate through the pairs (i,j) such that the j-th symbol in i-th line is '*'; find the minimum and maximum values of i and j from these pairs. The rectangle to output is [imin, imax] × [jmin, jmax].

B. Young PhotographerFirst we find the intersection of all segments. To do this, denote by m the rightmost of left ends of the segments and denote by M the leftmost of right ends of the segments. The intersection of the segments is [m,M] (or empty set if m>M). Now determine the nearest point from this segment. If x0 < m, it's m, and the answer is m - x0. If x0 > M, it's M, and the answer is x0 - M. If , it's x0, and the answer is 0. If m>M, then the answer is -1.

C. Four SegmentsThere must be many ways to solve this problem. The following one seems quite easy to code.First count the number of distinct points among segments' ends. If it's not equal to 4, the segments can't form a rectangle and we output "NO". Then calculate the minimum and maximum coordinates of the 4 points: xmin, xmax, ymin, ymax. If xmin = xmax or ymin = ymax, then even if the segments form a rectangle, it has zero area, so we also output "NO" in this case.Now if the segments indeed form a rectangle, we know the coordinates of its vertices — (xmin, ymin), (xmin, ymax), (xmax, ymin) and (xmax, ymax). We just check that every side of this rectangle appears in the input. If it is the case, we output "YES", otherwise we output "NO".

D. Two PathsTake any pair of non-intersecting paths. Since Flatland is connected, there must be a third path, connecting these two. Remove a road from the third path. Then Flatland is divided into two components — one containing the first path, and the other containing the second path. This observation suggests us the algorithm: iterate over the roads; for each road remove it, find the longest path in both connected components and multiply the lengths of these paths. The longest path in a tree can be found by depth first search from each leaf.

E. CamelsLet us call an index j such that yj - 1  >  yj  <  yj + 1 a cavity. Also, we'll call humps and cavities by the common word break. Then there must be exactly T = 2t - 1 breaks, and the first one must be a hump.Denote by fnth the number of ways in which a camel with t breaks, ending at the point (n,h), can be extended to the end (the vertical xN = N) so that the total number of breaks was equal to T. Note that:1. fNTh = 1, if h=1,2,3,4. (We have already finished the camel and it has T breaks)2. fNth = 0, if 0 ≤ t < T, h = 1, 2, 3, 4. (We have already finished the camel, but it has less than T breaks)3. fn, T + 1, h = 0, if 1 ≤ n ≤ N, h = 1, 2, 3, 4. (The camel has already more than T breaks). Now we find the recurrent formula for fnth. Suppose that t is even. Then the last break was a cavity, and we are moving up currently. We can continue moving up, then the number of breaks stays the same, and we move to one of the points (n + 1, h + 1), (n + 1, h + 2), ..., (n + 1, 4). Or we can move down, then the number of breaks increases by 1, and we move to one of the points (n + 1, h - 1), (n + 1, h - 2), ..., (n + 1, 1). This gives us the formula.

If t is odd, then the last break was a hump, and similar reasoning leads to the formula.

We can calculate fnth by dynamic programming. Consider now the point (2, h) on a camel. There are h-1 ways to get to this point (starting from points (1, 1), ..., (1, h - 1)), and f2, 0, h ways to extend the camel to the end. So the answer to the problem is .

Codeforces Beta Round #13 editorialBy KADR, 13 years ago, translation, In EnglishLet me introduce an editorial to Codeforces Beta Round #13. If you have any questions or propositions - feel free to post them in the comments.

Problem A.It is sufficient to iterate over all bases from 2 to A-2 and find the sum of digits in them. Then one should find the greatest common divisor of found sum and A-2 (which is equal to number of bases in which we found the sums). The numerator of the answer is equal to founded sum divided by this GCD and the denominator is equal to A-2 divided by this GCD.

The complexity is O(A).

Problem B.This problem appeared to be quite unpleasant to code, but all what one need to do is to check whether all three statements are true. It is recommended to perform all computations using integer arithmetics and to use scalar and vector product instead of computing cosines of angles or angles itself.

Problem C.Note, that there exists a non-decreasing sequence, which can be obtained from the given sequence using minimal number of moves and in which all elements are equal to some element from the initial sequence (i.e. which consists only from the numbers from the initial sequence).

Suppose {ai} is the initial sequence, {bi} is the same sequence, but in which all elements are distinct and they are sorted from smallest to greatest. Let f(i,j) be the minimal number of moves required to obtain the sequence in which the first i elements are non-decreasing and i-th element is at most bj. In that case the answer to the problem will be equals to f(n,k), where n is the length of {ai} and k is the length of {bi}. We will compute f(i,j) using the following recurrences:

f(1,1)=|a1-b1|f(1,j)=min{|a1-bj|,f(1,j-1)},  j>1f(i,1)=|ai-b1|+f(i-1,1),  i>1f(i,j)=min{f(i,j-1),f(i-1,j)+|ai-bj|},  i>1, j>1

The complexity is O(N2). To avoid memory limit one should note that to compute f(i,*) you only need to know f(i-1,*) and the part of i-th row which is already computed. 

Problem D.

We will solve the problem using the following algorithm:Fix some red point.Find the number of triangles with vertices in the red points which don't contain any blue points inside and which have the fixed red point as one of the vertices.Remove the fixed red point and go back to statement 1, if there remain any red point.The first and third statements are obvious, so the main part of the solution is statement 2.

Suppose the red point A is fixed (in the first statement). Also suppose we have all other points which are still not removed (blue and red together) sorted by angle around the point A. We will iterate over all red points B, which will be the second vertice of triangle. Now, we need to find the number of triangles with vertices in red points which have points A and B as two vertices and which don't contain any blue point inside.

To solve this problem we will iterate over all unremoved points C in the increasing order of angle ABC starting from the point after the point B (in the same order). To avoid double counting we will stop when the angle between vectors AB and AC become greater than 180 degrees or when we reach the point which was already considered. Then we will perform such actions:If C is red then we will check whether there are blue points inside triangle ABC and if not - we will increase the answer by 1. Note, that to perform this check we don't need to iterate over all blue points. It is sufficient to maintain such point D from the ones which we have already seen for which the angle ABD is the smallest possible. If D doesn't lies inside the triangle ABC, then there is no blue point which lies inside it.If C is blue, then we will compare the angle ABC with ABD and if ABC is smaller, we will replace old D with C.Note, that after choosing new B we consider that there is no point D and there will be no blue points inside triangles ABC until we reach the first blue point.

The complexity is O(N2(N+M)). 

Problem E.

Let's divide all row into blocks of length K=sqrt(N) of consecutive holes. If N is not a complete square, then we will take K=sqrt(N) rounded down. For each hole we will maintain not only it's power (let's call it power[i]), but also the number of the first hole which belongs to other block and which can be reached from the current one with sequence of jumps (let's call it next[i]). Also, for each hole we will maintain the number of jumps required to reach the hole next[i] from the current one (let's call it count[i]). We will consider that there is a fictious hole, which lies after the hole N and it belongs to it's own block.

To answer the query of the first type (when the ball is thrown) we will jump from the hole i to hole next[i] and so on, until we reach the fictious hole. Each time we will add count[i] to the answer. We will jump not more than N/K times.To maintain the query of the seqond type (when the power of hole i is changed) we will change power[i], next[i] and count[i]. Then for each hole which belongs to the same block as i and has smaller number than i we will update next[i] and power[i] in decreasing order of number of the hole. We will perform not more than K updates.

The complexity is O(Nsqrt(N)).

Codeforces Beta Round #9 tutorialBy slycelote, 13 years ago, In EnglishA. Die RollIf the maximum of Yakko's and Wakko's points is a, then Dot will win, if she has not less than a points. So the probability of her win is (6 - (a-1)) / 6. Since there are only 6 values for a, you can simply hardcode the answers.

B. Running StudentIt is simple to calculate the time ti that the Student will need, if he gets off the bus at the i-th stop: ti = bi + si, where bi = xi / vb is the time he will drive on the bus, and  is the time he will need to get from the i-th stop to the University. We need to choose indices with minimal possible ti, and among them - the index with minimal possible si, that is, with maximal bi, that is (since the coordinates of bus stops are already ordered) with maximal i.

Note that due to precision issues, you should be careful when you compare ti: the condition ti = tj should be written in the form |ti - tj| < ε for some small ε.

C. Hexadecimal's NumbersBrute force solution, when you try each number from 1 to n, will not fit into the time limit.Note, however, that all good numbers have at most 10 digits, and each of the digits is 0 or 1. That is, there are at most 210 binary strings to check. Each of these strings is a number from 1 to 210 - 1 in binary representation. So the algorithm is the following: for each number from 1 to 210 - 1 write its binary  representation, read it as if it was decimal representation and compare the result to n.

D. How many trees?Denote by tnh the number of binary search trees on n nodes with height equal to h. We will derive a recurrent formula for tnh. For the base case note that t00 = 1 (empty tree), and ti0 = t0i = 0 if i>0.

Now take any binary search tree on n nodes with height equal to h. Let m be the number written at its root, 1 ≤ m ≤ n. The left subtree is a binary search tree on m-1 nodes, and the right subtree is a binary search tree on n-m nodes. The maximal of their heights must be equal to h-1. Consider 2 subcases:1. The height of the left subtree is equal to h-1. There are tm - 1, h - 1 such trees. The right subtree can have any height from 0 to h-1, so there are  such trees. Since we can choose left and right subtrees independently, we have  variants in this case.2. The height of the left subtree is less than h-1. There are  such trees, and the right subtree must have height exactly h-1, which gives us totally  variants.So the recurrent formula is the following: .

All the values tnh can be calculated by dynamic programming. The answer, then, is .

E. Interesting graph and ApplesThe funny ring consists of n vertices and n edges. If there is another edge except for these n, then the vertices it connects belong to more than one cycle. So, an interesting graph is just a funny ring.A graph is a funny ring if and only if the following conditions hold:A1. The degree of each vertex equals 2.A2. The graph is connected. Now let's figure out when a graph is not yet a funny ring, but can be transformed into a funny ring by adding edges. There are obvious necessary conditions:B1. m < n.B2. There are no cycles.B3. The degree of each vertex is not more than 2. Let's add edges so that these conditions were preserved, and the sequence of edges was lexicographically minimal. So, we add an edge (i,j) such that:1. The degrees of i and j are less than 2. (Otherwise we would break B3).2. i and j belong to different connected components. (Otherwise we would break B2).3. The pair (i,j) is lexicographically minimal. Let's see what we have when we can't add edges anymore. Since there are no cycles, each connected component is a tree, and therefore has at least one vertex with degree less than 2. If there are two connected components, then they could be connected by an edge without breaking B1-B3. So the graph is connected, has no cycles, and the degree of each vertex is not more than 2. This means that the obtained graph is just a walk and we can connect its end points to obtain a funny ring.  To summarize, the algorithm is the following: 1. Check if A1-A2 hold. If yes, output "YES" and 0. 2. Check if B1-B3 hold. If no, output "NO". 3. Output "YES" and n-m. 4. Add edges as described. When the edge (i,j) is added, output "i j". 5. Find the only vertices i and j with degree less than 2 (they can be equal if n=1). Output "i j".

Codeforces Beta Round #8 Tutorial

By Nedy88, 11 years ago, In EnglishRecently, I started solving codeforces problems from the beginning. I just solved Codeforces Beta Round #8. I couldn't find any tutorial for the round so I decided to write tutorial for the last two problems. The others I solve long time ago in the real contest. Problem E took me quite some time and I couldn't find even a discussion about it, so here are my solutions.

D. 8D - Two FriendsThe main observation for this problem is the following: If Alan and/or Bob is at some point X and moves following some curve and travels distance d, then the point at which they finish can be ANY point on or inside the circle with center X and radius d. In other words: If you start at some point X and go to some point Y, you can do this on as long curve as we want(only not shorter then the distance(X, Y). Now, for convenience, lets say that T1 is the longest allowed path for Alan and T2 is the longest allowed path for Bob. These values are easily calculated:

T1 = distance(cinema, shop) + distance(shop, home) + t1T2 = distance(cinema, home) + t2Now, there are two cases. The first and trivial case is when distance(cinema, shop) + distance(shop, home) <= T2. In this case, it is OK for Bob to go to the shop with Alan. If they go to the shop together there is no need for them to ever split. So they go together all the way from the cinema to the shop and then from the shop to their home. In this case the solution is min(T1, T2) Why? (Hint: here the observation in the beginning is important).

The second case is when Bob cannot go to the shop with Alan. We'll solve this case with binary search on the distance that they could cover together before splitting. Let's assume that the go to some point P together covering some distance x. After they split Bob goes home in straight line and Alan first goes to the shop in straight line and then goes home again in straight line. This circumstance forces three condition for the point P.

Point P must be inside a circle with center 'cinema' and radius x. This follows directly from the main observation.x + distance(P, home) <= T2 — Bob must be able to go home in time. This condition means that P must be inside a circle with center home and radius max(0, T2 - x).x + distance(P, shop) + distance(shop, home) <= T1 — Alan must be able to go home in time. This condition means that P must be inside circle with center shop and radius max(0, T1 - x - distance(shop, home).Now we have three circles and if they intersect, then it's possible to choose point P in such a way that Alan and Bob will the together the first x meters of their journey.

Now, the problem is to check if three circles intersect. I come up with easy solution for this problem. I haven't proven it correct, but it seem to work. I don't know if there is some standard algorithm for this problem. My idea is the following. Let the 3 circles be C1, C2 and C3. If C1 and C2 intersect they do it in one or two point. Now we check is some of these points is inside C3. If there is such point, then the 3 circles intersect, but if there is no such point, it doesn't necessarily mean thath the 3 circles doesn't intersect. We should try all permutations of the 3 circles. That is we first check C1 and C2 and the intersected points with C3, then C1 and C3 and the intersected points with C2, and so on.

Here is my solution for reference: 1632676

E. 8E - BeadsThis is quite an interesting problem for me. We must find the k-th lexicographically smallest number from a subset of the numbers from 0 to 2^N(It is easier to increase K with one and consider the all zeroes and all ones case, too). The numbers which we want to count are those which are smaller or equal to their inverted number(flip zeroes and ones), their reversed number(read the bits of the number from right to left) and their reversed and inverted number.

Let's call a prefix the first half of the numbers, i.e. when only the first N/2 bits are set. Since N <= 50, there are at most 2 ^ 25 such numbers. Also we will only consider numbers with 0 at the first bit. If it is 1, then the inverse number will be smaller, so there are at most 2^24 prefixes. Now if we have some prefix, using dynamic programming we will see in how many ways can we finish it to a real number. The state of the dp is: (int pos, bool less, bool lessInv) and dp[pos][less][lessInv] is the number of ways to finish the number if we have to choose the pos-th bit now. less shows if so far we are less then or equal to the reversed number and lessInv shows if so far we are less then or equal to the inverted and reversed number. Using the dp we could easily find the k-th number.

There is one final note. The DP here is run for every possible prefix and the prefixes could be up to 2^24. Every time we clear the DP table before running it. This makes the solution slow even for the 5 seconds time limit. There is one more observation which makes the solution run in time. We iterate the prefixes in order, that is in each step newprefix = oldprefix + 1. In this case only the last few bits of the prefix are changed. The other part of the prefix remains the same and there is no need to clear the whole DP table, only the parts that changed due to changing the last few bits. This is left for exercise and my solution using this method is: 1644014

Round #6 - Tutorial (A,B,C,E)By A.K.Goharshady, 12 years ago, In EnglishThis post is written to help my friend , Iman , complete this one.Problem A: Triangle (code)For each of the possible combinations of three sticks , we can make a triangle if sum of the lengths of the smaller two is greater than the length of the third and we can make a segment in case of equality.

Problem B: President's office (code)For each cell of president's desk , we check all its neighbors and add their colors to a set. easy as pie!

Problem C: Alice,Bob and chocolate (code)This one can be solved easily by simulation. see the code.

Problem E: ExpositionI solved this one in O(nlgn) time using a segment-tree and keeping track of minimum and maximum element in each segment. Adding a number is O(lgn) because we need to update minimum and maximum for the log2n  segments containing that number. For each start point we query the tree to find the maximal endpoint. This is again O(lgn) and is done O(n) times so we have a total complexity of O(nlgn) fitting perfectly in the time limit. 

Codeforces Beta Round #5 - TutorialBy DmitryKlenov, 13 years ago, In EnglishAs there is no tutorial of Codeforces Beta Round #5 in English, I have decided to write this one. Possibly, some ideas will be similar to ones, expressed in Russian tutorial made by SkidanovAlex, but I hope everybody will find some useful in this problem analysis too.

Problems A and B.

Both are implementation problems. The only difficult, many participants faced with - to read data correctly. It is recommended to use gets(s) or getline(cin, s) in C++, readLine() method of BufferedReader class in Java.

Problem C.

First of all, for each closing bracket in our string let's define 2 values:d[j] = position of corresponding open bracket, or -1 if closing bracket doesn't belong to any regular bracket sequence. c[j] = position of earliest opening bracket, such that substring s(c[j], j) (both boundaries are inclusive) is a regular bracket sequence. Let's consider c[j] to be -1 if closing bracket doesn't belong to any regular bracket sequence.It can be seen, that c[j] defines the beginning position of the longest regular bracket sequence, which will end in position j. So, having c[j] answer for the problem can be easily calculated.

Both d[j] and c[j] can be found with following algorithm, which uses stack.Iterate through the characters of the string.If current character is opening bracket, put its position into the stack.If current character is closing bracket, there are 2 subcases:Stack is empty - this means that current closing bracket doesn't have corresponding open one. Hence, both d[j] and c[j] are equal to -1.Stack is not empty - we will have position of the corresponding open bracket on the top of the stack - let's put it to d[j] and remove this position from the stack. Now it is obvious, that c[j] is equal at least to d[j]. But probably, there is a better value for c[j]. To find this out, we just need to look at the position d[j] - 1. If there is a closing bracket at this position, and c[d[j] - 1] is not -1, than we have 2 regular bracket sequences s(c[d[j] - 1], d[j] - 1) and s(d[j], j), which can be concatenated into one larger regular bracket sequence. So we put c[j] to be c[d[j] - 1] for this case.

Problem D.

This problem can be solved by careful case handling. Let's construct O(1) solution for it.

First of all, let's define 2 functions:

dist(speed, time) - calculates the distance will be covered in specified time, if car's current speed is speed. This function will not take car's speed limit into account. Also it assumes, that car is always driven with maximum acceleration a. It is obvious that required distance is equal to .travelTime(distance, speed) - calculates the time, required to travel specified distance, if car have starting speed equal to speed. This function will also take care about car's speed limit.We will have the following quadratic equation for time t: . This equation will have exactly 2 different roots. Using Viete's formulas it can be concluded, that one root of the equation is non-positive and other is non-negative. Let's define the larger root of the equation as tAll. It will be the answer, if there is no car's speed limit. To take the limit into account let's find the time, required to gain car's max speed. tMax = (v - speed) / a. If tMax ≥  tAll, function should just returns tAll as a result. Otherwise result is tMax hours to achieve car's maximal speed plus (distance - dist(speed, tMax)) / v hours to cover remaining distance.

Having these functions, solution will be the following:

If v ≤ w, answer is travelTime(l, 0).Calculate tw = w / a -  time, required to gain speed w.Consider dw = dist(0, tw).If dw ≥ d, we will pass the point there sign is placed before we gain speed w. Answer for this case is travelTime(l, 0) as well.Otherwise, we will gain speed w before the sign. Let's consider segment of the road [dw, d]. We need to find out the best strategy to drive it. It is obvious, that we definitely should have speed w at the both ends of this segment. Also we know, that acceleration is equal to deceleration. Taking these facts into account we can see, that the speed in the optimal solution will be symmetrical with respect to the middle of the segment [dw, d]. Hence answer for this case will be tw + 2 *  travelTime(0.5 * (d - dw), w) + travelTime(l - d, w).

Problem E.

Let's reduce the problem from the circle to the straight line. Perform the following actions to do it:

Find the hill with the maximal height (if it is not unique, choose any).Rotate all the sequence in such a way that hill with maximal height goes first.For convenience, add one more hill with maximum height to the end of the sequence. (It will represent the first hill, which goes after the last in the circle order).Now we have almost the same problem on the straight line. One exception is that now first hill is doubled.

General idea of the solution:

Consider there is a pair of hills, such that these hills are visible from each other. Let's define hill with lower height (if heights are equal - with lower position) as responsible for adding this pair to the answer.

From this point of view, hill x will adds to the answer 3 kinds of hills as his pair:First hill to the left of the x, which is strictly higher than x. (Let's define its position as l[x])First hill to the right of the x, which is strictly higher than x. (Let's call this hill y and define it's position as r[x]).All hills that are as high as x and are located between x and y. (Let's define this count as c[x]).Arrays r[x] and c[x] can be calculated by the following piece of code:

c[n] = 0;for(int i = n - 1; i >= 0; --i) {    r[i] = i + 1;    while (r[i] < n && height[i] > height[r[i]]) r[i] = r[r[i]];    if (r[i] < n && height[i] == height[r[i]]) {        c[i] = c[r[i]] + 1;        r[i] = r[r[i]];    }}

I am not going to prove here, that it works for the O(N) time, but believe it does :)

Pay attention, that r[x] is undefined for hills with maximum height and this algorithm will find r[x] = n for such hills.

Array l[x] can be found in a similar way.

Having l[x], r[x] and c[x], it's not so difficult to calculate the answer. We should just notice, that:Each hill will add c[x] pairs to the answer.Each hill, lower than maximal, will also add 2 pairs (x, l[x]) and (x, r[x]) to the answer. The only corner case here is l[x] = 0 and r[x] = n, because (x, 0) and (x, n) is the same pair of hills in the original problem, where hills are circled.

Codeforces Beta Round #2 - Another TutorialBy ivan.popelyshev, 13 years ago, translation, In EnglishLets start from the end.

Problem С. Commentator problemLet R be the distance from point А to a circle with center О and radius r. From this point the circle is observed at the angle .So, the three stadiums are observed at the same angle if R1 / r1 = R2 / r2 = R3 / r3.Take two different points A, B. The set of points C that AC / BC = const is either a line (perpendicular bisector of AB) or a circle with center somewhere on the line AB. This circle is easy to find. It contains two points that lie on AB and satisfy AC / BC condition.

Let X1 be the set of points from which stadiums 1 and 2 are observed at the same angle. Let X2 be the set of points from which stadiums 2 and 3 are observed at the same angle. The answer belongs to both X1 and X2 . The centers of the three stadiums don't lie on one line, so the number of points in the intersection of  X1 and X2 will be finite.Check them all. The answer is the point that lies closer to any of the stadiums. The stadiums don't intersect, so that point will not lie inside any of them.How to get a big circle for X1 : put the centers of the stadiums in the points far away, for example in (0, 0) and (1000, 0). The ratio of the radii should be the closer possible to 1, for example . The center and the radius of the new circle will have the order 106 . The answer should be known with 10 - 5 precision. Roofly speaking, we need 11 digits, double precision will be enough.

Problem B. The least round wayLet us solve the problem in the case of positive matrix.Let the number in the end be N = 2k· 5m·(other primes). The number of zeroes at the end of N is equal to min(k, m). At the aid of dynamic programming find minimal value of k (let it be k1) and minimal value of m (let it be m1), and paths that lead to these values. In case of k1 < m1 choose the path corresponding to k1, else  m1.So min(k, m) is the upper bound for the answer. Let us prove that it is the lower bound too. If there exists a path leading to a number with number of zeroes less than min(k, m) then in the factorization of that number the power of two is k < k1 or the power of five is m < m1. We come to a contradiction.So we need to calculate the power of 2 and 5 in the factorization of each value in the matrix and use dynamic programming on each of the two matrices.

In the case of matrix containing zeroes, calculate separately the best path not containing zeroes and any path containing zeroes:

Replace all 0 by 10 and use the method described above. For paths containing zeroes the result will contain at least one zero at the end. If the method returned a number without zeroes at the end, the corresponding path is the answer, else any path containing zeroes is the answer.The complexity of the algorithm depends on the complexity of the dynamics, it is O(N· M).

Problem A. WinnerSimple problem, just code it.At the first pass calculate the sum of points for each player at game end. Let M be the maximum of these sums. At the second pass check every round. If current player X has not less than M points and his final score is equal to M then he is the winner.The following test illustrates that player could receive more than M points, then lose some and, finally, win.Input:Masha 12Masha -5Sasha 10Masha 3Output:Masha

Codeforces Beta Round #1 - TutorialBy removed1, 13 years ago, translation, In EnglishProblem A.

The constraint that edges of each flagstone much be parralel to edges of the square allows to analyze X and Y axes separately, that is, how many segments of length 'a' are needed to cover segment of length 'm' and 'n' -- and take product of these two quantities. Answer = ceil(m/a) * ceil(n/a), where ceil(x) is the least integer which is above or equal to x. Using integers only, it is usually written as ((m+a-1)/a)*((n+a-1)/a). Note that answer may be as large as 10^18, which does not fit in 32-bit integer.

Most difficulties, if any, contestants had with data types and operator priority, which are highly dependant on language used, so they are not covered here.

Problem B.

Let each letter representation of column number be associated with integer in radix-26, where 'A' = 0, 'B' = 1 ... 'Z'=25. Then, when converting letter representation to decimal representation, we take associated integer and add one plus quantity of valid all letter representations which are shorter than letter representation being converted. When converting from decimal representation to letter representation, we have to decide how many letters do we need. Easiest way to do this is to subtract one from number, then quantity of letter representation having length 1, then 2, then 3, and so on, until next subtraction would have produced negative result. At that point, the reduced number is the one which must be written using defined association with fixed number  of digits, with leading zeroes (i.e. 'A's) as needed.

Note that there is other ways to do the same which produce more compact code, but they are more error-prone as well.

Problem C.

The points can be vertices of regular N-polygon, if, and only if, for each pair, difference of their polar angles (as viewed from center of polygon) is a multiple of 2*pi/N. All points should lie on the circle with same center as the polygon. We can locate the center of polygon/circle [but we may avoid this, as a chord (like, say, (x1,y1)-(x2,y2)) is seen at twice greater angle from center, than it is seen from other point of a cricle (x3,y3)]. There are many ways to locate center of circle, the way I used is to build midpoint perpendiculares to segments (x1,y1)-(x2,y2) and (x2,y2)-(x3,y3) in form y = a*x + b and find their intersection. Formula y = a*x + b has drawback that it cannot be used if line is parallel to y, possible workaround is to rotate all points by random angle (using formulae x' = x*cos(a) - y*sin(a), y' = y*cos(a) + x*sin(a) ) until no segments are horizontal (and hence no perperdiculares are vertical).

After the coordinates of the center are known, we use fancy function atan2, which returns angle in right quadrant: a[i] = atan2(y[i]-ycenter, x[i]-xcenter)

Area of  regular polygon increases with increasing N, so it is possible just to iterate through all possible values on N in ascending order, and exit from cycle as first satisfying N is found.

Using sin(x) is makes it easy: sin(x) = 0 when x is mutiple of pi. So, for points to belong to regular, N-polygon,

sin( N * (a[i]-a[j]) /2 )=0

because of finite precision arithmetic, 

fabs( sin( N * (a[i]-a[j]) /2 ) ) < eps

