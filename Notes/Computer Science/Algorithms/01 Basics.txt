n!      15
2^n     40
n^3     10000
n^2     1000000
n log n 100000000
n       1000000000000
log n^  >1000000000000

Strategies

OEIS.
OEIS queries like "1,2,4,7,13 minimal" and "2 4 _ 316".
Google Sequence Number "OEIS 123456" perhaps with "C++" and contribute back.
Google critical numbers at all precisions.
WolframAlpha Tips Tricks Queries [e.g. "Factor 348237523562873562382342300000" Divisors Plain Text Wolfram Language Plain Text Output]
Naive implementations to produce OEIS queries or insights into structure.
Use -1 rather than LLONG_MAX.
Separate .txt file or .cpp file templates prior to rounds for task analyses.

Note that the target is to get from the precise input to the precise output. There are a number of settings where reordering queries can be helpful i.e. not naively simulating. Furthermore, if the target is to compute a number, one can consider producing some other numbers and error-correcting in a certain way as long as it produces the target output. Ensure to have compute perhaps to support 100000000000000000 operations. Carefully verify Output character by character or run an Andrew He "ecnerwala"-style scraper script to ensure perfection. Consider generating edge and worst case maximum sized test Input in one's head and|or .txt to run locally prior to submitting for e.g. the Hacker Cup to ensure no de facto Time Limit Exceeded verdict is obtained via the judge platform system. Add edge cases in to Input. Do not spam submissions for penalty effective -20 rating points per penalty [robust policy might be to tank 10 minutes between potential penalty submissions meditating upon machine-verifiably flawless composition] or post information in public mid round. Compose a script to automatically ping Google with tonnes of queries of popular relevant substrings of the task statement and sort the top ~1000 results for simple .txt viewing. One can view AtCoder Solutions Editorials in Japanese and English Translated after a round if English is not available and for Heuristic Contests. One can simply run and execute a program for 10 or even 1000 hours on a strong machine. Some platforms will only accept 1 rather than 2 as the correct output for the sum P+Q corresponding with P/Q of the rational representation for the fraction 1/1. Modifications of naive simulation can be made to work for producing an estimate to within 0.000001 or even sometimes 0.000000001 depending. Ensure to nail details such as epsilons sizes, Pigeonhole Principle argumentation bounds, 10^99 being a 100 digit number, off-by-1s, O[1] and sublinear optimisations, optimising critical important code chunks, P[Collision] sufficiently low, etc. To view minimum execution time submissions go to AtCoder "Results" "All Submissions" "Task" "Language" "Status" "Execution Time" or CodeForces "Problems" "Status" "Status Filter" "Problem" "Verdict" "Execution Time" or CSES "Hacking" "Maximum Time". Mock AtCoder Beginner Contests and Division 2 Rounds once near 初段 or in Division 1. One can Late Register for Divsion 1 [+ Division 2] rounds 5-10 minutes in after onsighting proofs of correctness and asymptotics and coding up skeleton[s] for task C [or D and E] e.g. for the free Top 500 ranking on >=ABC Division 1 [and >=ABCDE Division 2]. If relatively slow, one can instead strategise towards Late Registration Division 1 FAB outcomes to boost from 2280 to the 2400 target. Consider competing in exclusively Division 1 rounds. Review and learn from other top Competitive Programmers' submissions. Certainly, the submission and [potentially implicit] execution times mid-round can leak information about a terse fast solution or existence of an asymptotic algorithm for a solution. Confirm that algorithm asymptotics will not Exceed Time Limit prior to submitting and compose comments on superior algorithms in-round if possible noting spots where one can relatively easily drop log[n] runtime factors e.g. Read all test case Input prior to Outputting "NO" and returning. Never lock. Practise fast typing coding daily. Consider exclusively engaging in Late Registration Onsighted-Task E Educational rounds until hitting >= 2100 Master perhaps from an ABCDE Top 30. Especially if Python with LinkedIn trawling predicts that to be the Life Theoretically Optimal Strategy. If one opts to solve ECD and Late Register 70 minutes in to a round and then proceeds to Fail 1|5 from ABCDE then one can consider running edge cases and pseudorandom low-n case stress tests locally in order to debug in time. Potentially strategise Jumps to ~2090 then ~2250. The Life Theoretically Optimal strategy for CodeForces Master may be to simply practise on an alternate account until semi-reliably pinging in ABCDE or ABCDEF on Educational rounds and then doing that ~3 times from a primary to signal to firms off of ~16 total solves for the account. Looks suspicious, hacked, plausibly ghostwritten.

Train for Competition X with past Competition X tasks and review Notes and Tutorials from the web logs and comments of Competition X task composers prior to the round.

Take things to logical extremes, mathematical degeneracies, pathological Inputs, edge cases, low-n base cases, etc.

If one is suboptimally looking left and right between windows, transcribing logical literals, create another data structure and manually enter all data vectorised in one place. This also makes debugging significantly easier if one errs. Know how to run an auxiliary script in round to say generate a vector of vectors of integers of total size ~1000 in 100s and then copy and paste that vector of vectors of integers in to another primary submission program.

Come back to tasks on a daily basis, perhaps just for 10 minutes to re contemplate and record thoughts and links in that corresponding text file.

Read the Project Leonhard Euler forum. Never cheat or submit a string after it appears in the public timestamped written record. That appears and may be flagged as suspicious. It may lead to being permanently delisted. Furthermore, there exists little purpose to appearing on a public timestamped leaderboard after that point in time. Use an "unlisted" alternate account "Lazar0". If pursuing a bona fide "State Of The Art" [25 Out Of 25] award, post accepted codes on the forum immediately upon submission, especially if the answer string has appeared in public.

Think about codes, write helpful informative comments, come back and re write better codes, terse, legible, functional, maintainable. When dealing with equations, write them out in natural mathematics on paper or in .tex. This will make it easier to spot the structures and effectively deal with things, perhaps in comments, prior to composing less human legible codes.

Usually all task statement details, including titles, are relevant and might plausibly help one rule out or in various strategies for the task but naive and close examination of low-n cases is often revealing. If one composes an algorithm for a more general setting, consider if the numerics or task specifics give additional structure with which to produce a better algorithm. Can auxiliary memory help? If a naive O[1] auxiliary memory algorithm is too slow? Can one ad hoc an approximation based off of low-n cases? If asked for 1 example rather than the minimal exemplar, any family of solutions suffices. If generating an exemplar from a large precision \p PARI|GP call, one may copy and paste the code and output to the counterparty for their verification.

Do not expect that WolframAlpha will produce a closed form expression for a real number given 8 digits of precision. Query reasonable fractional denominators directly or run an approximation algorithm. Continuous to enumerable discrete isomorphisms. Reason quite precisely about rates of convergence and error terms functions. Perhaps obtain and learn how to write codes in the Wolfram Mathematica software [or https://www.wolfram.com/wolframscript/] As Soon As Possible. As well as implementations in PARI|GP [Paris Parisian Pari De Pascal Pascal's Wager Pascal's Arithmetic Great Programmable Calculator In Mid-Latency C], Boost C++, Sage polynomial factoring over GF[2] etc., other auxiliary libraries in < 3600000ms rather than 36000000ms. Execute C codes locally to avoid an internet outage killing a process 30000000ms in to a 36000000ms runtime execution and also print and save partial progress outputs if possible. One prefers to be using the Decimal auxiliary library to the Python programming language most of the time rather than PARI|GP except in latency-sensitive-critical live IBM Ponder This rounds etc.

One can come back to tasks post facto, and think about code, re factor code [Keep It Simply Simple], think more about the mathematics, algorithms, ideas, literature.

For a structure like a high pressure, timer running, Hacker Cup round, view all tasks, compose solutions, algorithms, comments, keywords, ideas, prior to composing code.

Memorise all of these and click through: https://en.wikipedia.org/wiki/List_of_algorithms

One can execute a Task B O[n] algorithm locally for a maximum Input limit of say n=200000 in 100ms and deduce that running this algorithm for a Task C version in O[n^2] might take ~10000s will Exceed Time Limit.

One can run a function call for loop on an Input of 10000000000 and run a semi-costly check and halt for task completion every loop index multiple of 1000000 or multiple of 10000000 or power of 2 or what have you for semi-optimised expected runtime cost. It is good practice to reduce runtimes from 1000 minutes to 100 minutes, 100 minutes to 10 minutes, 10 minutes to 1 minute, 1 minute to 6000ms, 6000ms to 600ms, 600ms to 60ms, 60ms to 6ms, 6ms to 600µs, 600µs to 60µs, 60µs to 6µs, 6µs to 600ns, 600ns to 60ns, 60ns to 6ns, 6ns to 600ps, etc. Ensure to analyse simpler tasks and Elite Codes quite carefully and closely, checking runtimes and also forming a strong habit of post-contest analyses. Simply onsight and compose notes on Project Leonhard Euler without coding up if semi-retired [filtration to Top 1 [Or Top 10] only] from that platform for work reasons.

It is Badly Mannered to ping the Jane Street Capital firm with the Wrong answer and then correct it to the Right answer 5 minutes later, especially if they institute a +90-day scoring penalty mechanism rendering 1st Solves as unofficial in the histoire books. "Stop acting[,] Lazy." - Kanye Omari West. "1 square, 2 squares, 4 squares "oops" not so good at maths haha might crash your internet and firm's PnL haha and I ain't even into that. 'Cause Somewhere In America, Lazyr Blazer is still working, haha, work Lazyr, work, work, work Lazyr, work." - Lazar Ilic [Allusion To Somewhere In America - Shawn Corey Carter]