Table of Contents


1 T h e W orlds o f D atabase S ystem s 1


1.1 The Evolution of Database Systems ............................................... 1


1.1.1 Early Database Management S y ste m s............................... 2


1.1.2 Relational Database S y ste m s............................................... 3


1.1.3 Smaller and Smaller S y ste m s............................................... 3


1.1.4 Bigger and Bigger S y s te m s ................................................... 4


1.1.5 Information In te g ra tio n ......................................................... 4


1.2 Overview of a Database Management S y s te m ................................ 5


1.2.1 Data-Definition Language Commands ................................ 5


1.2.2 Overview of Query Processing............................................... 5


1.2.3 Storage and Buffer M an ag em en t......................................... 7


1.2.4 Transaction Processing............................................................ 8


1.2.5 The Query Processor............................................................... 9


1.3 Outline of Database-System S tu d ie s ............................................... 10


1.4 References for Chapter 1 ..................................................................... 12


1 Relational Database Modeling 15


2 T he R elation al M od el o f D ata 17


2.1 An Overview of Data M o d e ls............................................................ 17


2.1.1 What is a Data M o d e l? ......................................................... 17


2.1.2 Important Data M o d els......................................................... 18


2.1.3 The Relational Model in B rief............................................... 18


2.1.4 The Semistructured Model in B rief...................................... 19


2.1.5 Other Data M odels.................................................................. 20


2.1.6 Comparison of Modeling Approaches................................... 21


2.2 Basics of the Relational Model .........................................................21


2.2.1 A ttributes.................................................................................. 22


2.2.2 Schem as..................................................................................... 22


2.2.3 T u p les........................................................................................ 22


2.2.4 Domains..................................................................................... 23


2.2.5 Equivalent Representations of a Relation ......................... 23


xiii


2.2.6 Relation In stan c e s................................................................. 24


2.2.7 Keys of Relations.................................................................... 25


2.2.8 An Example Database S ch em a ........................................... 26


2.2.9 Exercises for Section 2 .2 ........................................................ 28


2.3 Defining a Relation Schema in SQ L.................................................. 29


2.3.1 Relations in S Q L .................................................................... 29


2.3.2 Data T y p e s.............................................................................. 30


2.3.3 Simple Table Declarations..................................................... 31


2.3.4 Modifying Relation Schemas ............................................... 33


2.3.5 Default V a lu e s....................................................................... 34


2.3.6 Declaring K e y s ....................................................................... 34


2.3.7 Exercises for Section 2 .3 ........................................................ 36


2.4 An Algebraic Query Language ........................................................ 38


2.4.1 Why Do We Need a Special Query Language?...................38


2.4.2 What is an A lgebra?.............................................................. 38


2.4.3 Overview of Relational A lgebra........................................... 39


2.4.4 Set Operations on Relations.................................................. 39


2.4.5 Projection.................................................................................41


2.4.6 Selection .................................................................................42


2.4.7 Cartesian P r o d u c t................................................................. 43


2.4.8 Natural J o in s.......................................................................... 43


2.4.9 Theta-Joins..............................................................................45


2.4.10 Combining Operations to Form Q u e ries............................47


2.4.11 Naming and Renaming...........................................................49


2.4.12 Relationships Among O perations........................................ 50


2.4.13 A Linear Notation for Algebraic E x p ressio n s...................51


2.4.14 Exercises for Section 2 .4 ........................................................ 52


2.5 Constraints on R elations.................................................................... 58


2.5.1 Relational Algebra as a Constraint L anguage...................59


2.5.2 Referential Integrity C o n strain ts........................................ 59


2.5.3 Key Constraints .................................................................... 60


2.5.4 Additional Constraint E x am p les........................................ 61


2.5.5 Exercises for Section 2 .5 ........................................................ 62


2.6 Summary of Chapter 2 ....................................................................... 63


2.7 References for Chapter 2 .................................................................... 65


3 Design T heory for R elational D atabases 67


3.1 Functional Dependencies.................................................................... 67


3.1.1 Definition of Functional Dependency.................................. 68


3.1.2 Keys of Relations.................................................................... 70


3.1.3 Superkeys................................................................................. 71


3.1.4 Exercises for Section 3 .1 ........................................................ 71


3.2 Rules About Functional D ependencies........................................... 72


3.2.1 Reasoning About Functional D ependencies...................... 72


3.2.2 The Splitting/Combining R u l e ............................................ 73


xiv TABLE OF CONTENTS


TABLE OF CONTENTS xv


3.2.3 Trivial Functional Dependencies ......................................... 74


3.2.4 Computing the Closure of A ttributes................................... 75


3.2.5 Why the Closure Algorithm W orks...................................... 77


3.2.6 The Transitive R u l e ............................................................... 79


3.2.7 Closing Sets of Functional Dependencies............................ 80


3.2.8 Projecting Functional D ependencies...................................81


3.2.9 Exercises for Section 3 .2 .........................................................83


3.3 Design of Relational Database Schemas .........................................85


3.3.1 Anomalies..................................................................................86


3.3.2 Decomposing Relations .........................................................86


3.3.3 Boyce-Codd Normal F o rm ......................................................88


3.3.4 Decomposition into BCN F......................................................89


3.3.5 Exercises for Section 3 .3 .........................................................92


3.4 Decomposition: The Good, Bad, and U gly......................................93


3.4.1 Recovering Information from a Decomposition ................94


3.4.2 The Chase Test for Lossless J o i n .........................................96


3.4.3 Why the Chase W orks............................................................99


3.4.4 Dependency P reserv atio n ......................................................100


3.4.5 Exercises for Section 3 .4 .........................................................102


3.5 Third Normal Form ............................................................................102


3.5.1 Definition of Third Normal F o rm .........................................102


3.5.2 The Synthesis Algorithm for 3NF Schemas ......................103


3.5.3 Why the 3NF Synthesis Algorithm W o rk s......................... 104


3.5.4 Exercises for Section 3 .5 .........................................................105


3.6 Multivalued Dependencies..................................................................105


3.6.1 Attribute Independence and Its Consequent Redundancy 106


3.6.2 Definition of Multivalued D ependencies............................ 107


3.6.3 Reasoning About Multivalued Dependencies......................108


3.6.4 Fourth Normal F o rm ...............................................................110


3.6.5 Decomposition into Fourth Normal Form .........................I l l


3.6.6 Relationships Among Normal F o rm s...................................113


3.6.7 Exercises for Section 3 .6 .........................................................113


3.7 An Algorithm for Discovering MVD’s ............................................115


3.7.1 The Closure and the C h a s e .................................................. 115


3.7.2 Extending the Chase to MVD’s ............................................116


3.7.3 Why the Chase Works for MVD’s ......................................118


3.7.4 Projecting MVD’s .................................................................. 119


3.7.5 Exercises for Section 3 .7 .........................................................120


3.8 Summary of Chapter 3 ........................................................................ 121


3.9 References for Chapter 3 ..................................................................... 122


4 H igh-Level D atabase M odels 125


4.1 The Entity/Relationship M odel.........................................................126


4.1.1 Entity S e t s .............................................................................. 126


4.1.2 A ttributes..................................................................................126


4.1.3 R elationships........................................................................... 127


4.1.4 Entity-Relationship Diagram s............................................... 127


4.1.5 Instances of an E /R D iagram ............................................... 128


4.1.6 Multiplicity of Binary E /R R elationships......................... 129


4.1.7 Multiway R elationships........................................................ 130


4.1.8 Roles in R elationships............................................................131


4.1.9 Attributes on R elationships.................................................. 134


4.1.10 Converting Multiway Relationships to B in ary ...................134


4.1.11 Subclasses in the E /R M o d e l...............................................135


4.1.12 Exercises for Section 4 .1 ........................................................ 138


4.2 Design Principles..................................................................................140


4.2.1 Faithfulness.............................................................................. 140


4.2.2 Avoiding R edundancy............................................................141


4.2.3 Simplicity Counts ..................................................................142


4.2.4 Choosing the Right Relationships.........................................142


4.2.5 Picking the Right Kind of E lem ent......................................144


4.2.6 Exercises for Section 4 .2 ........................................................ 145


4.3 Constraints in the E /R M odel............................................................148


4.3.1 Keys in the E /R M o d e l........................................................ 148


4.3.2 Representing Keys in the E /R Model ............................... 149


4.3.3 Referential In te g rity .................................................. ■ ■ • • 150


4.3.4 Degree C onstraints..................................................................151


4.3.5 Exercises for Section 4 .3 ........................................................ 151


4.4 Weak Entity S e ts ..................................................................................152


4.4.1 Causes of Weak Entity S e ts .................................................. 152


4.4.2 Requirements for Weak Entity S ets......................................153


4.4.3 Weak Entity Set N otation..................................................... 155


4.4.4 Exercises for Section 4 .4 ........................................................ 156


4.5 From E /R Diagrams to Relational Designs......................................157


4.5.1 From Entity Sets to Relations...............................................157


4.5.2 From E /R Relationships to Relations ............................... 158


4.5.3 Combining R elations...............................................................160


4.5.4 Handling Weak Entity S e t s .................................................. 161


4.5.5 Exercises for Section 4 .5 .........................................................163


4.6 Converting Subclass Structures to R elations.................................. 165


4.6.1 E/R-Style C onversion............................................................166


4.6.2 An Object-Oriented A p p ro a c h ............................................167


4.6.3 Using Null Values to Combine R elations............................ 168


4.6.4 Comparison of A p p ro ach es.................................................. 169


4.6.5 Exercises for Section 4 .6 ........................................................ 171


4.7 Unified Modeling L anguage...............................................................171


xvi TABLE OF CONTENTS


4.7.1 UML C la sses........................................................................... 172


4.7.2 Keys for UML c la s s e s ............................................................173


4.7.3 Associations...............................................................................173


4.7.4 Self-Associations..................................................................... 175


4.7.5 Association Classes.................................................................. 175


4.7.6 Subclasses in U M L .................................................................. 176


4.7.7 Aggregations and Compositions............................................ 177


4.7.8 Exercises for Section 4 .7 .........................................................179


4.8 From UML Diagrams to R e la tio n s.................................................. 179


4.8.1 UML-to-Relations Basics ..................................................... 179


4.8.2 From UML Subclasses to R elations......................................180


4.8.3 From Aggregations and Compositions to Relations .... 181


4.8.4 The UML Analog of Weak Entity S e ts............................... 181


4.8.5 Exercises for Section 4 .8 .........................................................183


4.9 Object Definition L anguage...............................................................183


4.9.1 Class D eclarations..................................................................184


4.9.2 Attributes in O D L ..................................................................184


4.9.3 Relationships in O D L ............................................................185


4.9.4 Inverse Relationships...............................................................186


4.9.5 Multiplicity of Relationships ............................................... 186


4.9.6 Types in ODL ........................................................................ 188


4.9.7 Subclasses in O D L ..................................................................190


4.9.8 Declaring Keys in O D L .........................................................191


4.9.9 Exercises for Section 4 .9 .........................................................192


4.10 From ODL Designs to Relational D e sig n s......................................193


4.10.1 From ODL Classes to Relations............................................193


4.10.2 Complex Attributes in C la s s e s ............................................194


4.10.3 Representing Set-Valued Attributes ...................................195


4.10.4 Representing Other Type Constructors............................... 196


4.10.5 Representing ODL R elationships.........................................198


4.10.6 Exercises for Section 4 .1 0 ..................................................... 198


4.11 Summary of Chapter 4 ........................................................................ 200


4.12 References for Chapter 4 ..................................................................... 202


II Relational Database Programming 203


5 A lgebraic and Logical Q uery Languages 205


5.1 Relational Operations on B a g s .........................................................205


5.1.1 Why B a g s ? ...............................................................................206


5.1.2 Union, Intersection, and Difference of B a g s...................... 207


5.1.3 Projection of B a g s ..................................................................208


5.1.4 Selection on B ags..................................................................... 209


5.1.5 Product of Bags ..................................................................... 210


5.1.6 Joins of B a g s........................................................................... 210


TABLE OF CONTENTS xvii


TABLE OF CONTENTS


5.1.7 Exercises for Section 5 .1 ........................................................ 212


5.2 Extended Operators of Relational A lgebra......................................213


5.2.1 Duplicate E lim ination............................................................214


5.2.2 Aggregation O perators............................................................214


5.2.3 G ro u p in g ..................................................................................215


5.2.4 The Grouping O p e ra to r........................................................ 216


5.2.5 Extending the Projection O perator......................................217


5.2.6 The Sorting O p e ra to r............................................................219


5.2.7 Outerjoins................................................................................. 219


5.2.8 Exercises for Section 5 .2 ........................................................ 222


5.3 A Logic for Relations........................................................................... 222


5.3.1 Predicates and A to m s ............................................................223


5.3.2 Arithmetic A to m s ..................................................................223


5.3.3 Datalog Rules and Q u e rie s .................................................. 224


5.3.4 Meaning of Datalog R u les..................................................... 225


5.3.5 Extensional and Intensional Predicates............................... 228


5.3.6 Datalog Rules Applied to B a g s ............................................228


5.3.7 Exercises for Section 5 .3 ........................................................ 230


5.4 Relational Algebra and D atalog.........................................................230


5.4.1 Boolean Operations ...............................................................231


5.4.2 Projection................................................................................. 232


5.4.3 Selection ................................................................................. 232


5.4.4 P ro d u c t.................................................................................... 235


5.4.5 Jo in s...........................................................................................235


5.4.6 Simulating Multiple Operations with D atalo g ...................236


5.4.7 Comparison Between Datalog and Relational Algebra . . 238


5.4.8 Exercises for Section 5 .4 ........................................................ 238


5.5 Summary of Chapter 5 ........................................................................ 240


5.6 References for Chapter 5 .....................................................................241


T he D atabase Language SQL 243


6.1 Simple Queries in S Q L ........................................................................244


6.1.1 Projection in S Q L ..................................................................246


6.1.2 Selection in S Q L .....................................................................248


6.1.3 Comparison of S trin g s............................................................250


6.1.4 Pattern Matching in S Q L ..................................................... 250


6.1.5 Dates and T im e s.....................................................................251


6.1.6 Null Values and Comparisons Involving NULL...................252


6.1.7 The Truth-Value UNKNOWN..................................................... 253


6.1.8 Ordering the O u tp u t.................................. ............................255


6.1.9 Exercises for Section 6 .1 ........................................................ 256


6.2 Queries Involving More Than One R e la tio n ...................................258


6.2.1 Products and Joins in S Q L .................................................. 259


6.2.2 Disambiguating Attributes .................................................. 260


6.2.3 Tuple Variables........................................................................261


6.2.4 Interpreting Multirelation Q u e rie s ......................................262


6.2.5 Union, Intersection, and Difference of Q ueries...................265


6.2.6 Exercises for Section 6 .2 ........................................................ 267


6.3 Subqueries.............................................................................................. 268


6.3.1 Subqueries that Produce Scalar Values............................... 269


6.3.2 Conditions Involving R ela tio n s............................................270


6.3.3 Conditions Involving T uples.................................................. 271


6.3.4 Correlated Subqueries............................................................273


6.3.5 Subqueries in FROM C la u se s.................................................. 274


6.3.6 SQL Join Expressions............................................................275


6.3.7 Natural J o in s ........................................................................... 276


6.3.8 Outerjoins..................................................................................277


6.3.9 Exercises for Section 6 .3 ........................................................ 279


6.4 Full-Relation O perations.....................................................................281


6.4.1 Eliminating Duplicates............................................................281


6.4.2 Duplicates in Unions, Intersections, and Differences . . . 282


6.4.3 Grouping and Aggregation in S Q L ......................................283


6.4.4 Aggregation O perators............................................................284


6.4.5 G ro u p in g ..................................................................................285


6.4.6 Grouping, Aggregation, and Nulls ......................................287


6.4.7 HAVING C lauses........................................................................ 288


6.4.8 Exercises for Section 6 .4 ........................................................ 289


6.5 Database Modifications .....................................................................291


6.5.1 Insertion.....................................................................................291


6.5.2 D eletion.....................................................................................292


6.5.3 U p d ates.....................................................................................294


6.5.4 Exercises for Section 6 .5 ........................................................ 295


6.6 Transactions in S Q L ........................................................................... 296


6.6.1 Serializability........................................................................... 296


6.6.2 A tom icity..................................................................................298


6.6.3 Transactions ........................................................................... 299


6.6.4 Read-Only Transactions........................................................ 300


6.6.5 Dirty R ead s.............................................................................. 302


6.6.6 Other Isolation L ev els............................................................304


6.6.7 Exercises for Section 6 .6 ........................................................ 306


6.7 Summary of Chapter 6 ........................................................................ 307


6.8 References for Chapter 6 .....................................................................308


7 C on strain ts and Triggers 311


7.1 Keys and Foreign K eys........................................................................ 311


7.1.1 Declaring Foreign-Key C onstraints......................................312


7.1.2 Maintaining Referential In teg rity .........................................313


7.1.3 Deferred Checking of C onstraints.........................................315


7.1.4 Exercises for Section 7 .1 ........................................................ 318


7.2 Constraints on Attributes and Tuples...............................................319


TABLE OF CONTENTS xix


TABLE OF CONTENTS


7.2.1 Not-Null Constraints..............................................................319


7.2.2 Attribute-Based CHECK C onstraints..................................... 320


7.2.3 Tuple-Based CHECK C onstraints........................................... 321


7.2.4 Comparison of Tuple- and Attribute-Based Constraints . 323


7.2.5 Exercises for Section 7 .2 ........................................................323


7.3 Modification of C o n strain ts................................................. ... 325


7.3.1 Giving Names to C onstraints.............................................. 325


7.3.2 Altering Constraints on T a b le s........................................... 326


7.3.3 Exercises for Section 7 .3 ........................................................327


7.4 A ssertions.............................................................................................328


7.4.1 Creating Assertions ..............................................................328


7.4.2 Using A ssertions....................................................................329


7.4.3 Exercises for Section 7 .4 ........................................................330


7.5 T riggers................................................................................................332


7.5.1 Triggers in SQ L.......................................................................332


7.5.2 The Options for Trigger D esign........................................... 334


7.5.3 Exercises for Section 7 .5 ........................................................337


7.6 Summary of Chapter 7 .......................................................................339


7.7 References for Chapter 7 ....................................................................339


Views and Indexes 341


8.1 Virtual V iew s.......................................................................................341


8.1.1 Declaring Views .................................................................... 341


8.1.2 Querying Views.......................................................................343


8.1.3 Renaming A ttributes..............................................................343


8.1.4 Exercises for Section 8 .1 ........................................................344


8.2 Modifying V ie w s................................................................................ 344


8.2.1 View Removal ....................................................................... 345


8.2.2 Updatable V iew s.................................................................... 345


8.2.3 Instead-Of Triggers on V iew s.............................................. 347


8.2.4 Exercises for Section 8 .2 ........................................................349


8.3 Indexes in S Q L ................................................................................... 350


8.3.1 Motivation for Indexes...........................................................350


8.3.2 Declaring Indexes.................................................................... 351


8.3.3 Exercises for Section 8 .3 ........................................................352


8.4 Selection of Indexes .......................................................................... 352


8.4.1 A Simple Cost Model ...........................................................352


8.4.2 Some Useful Indexes..............................................................353


8.4.3 Calculating the Best Indexes to C reate...............................355


8.4.4 Automatic Selection of Indexes to C r e a te .........................357


8.4.5 Exercises for Section 8 .4 ........................................................359


8.5 Materialized V iew s............................................................................. 359


8.5.1 Maintaining a Materialized V ie w ........................................ 360


8.5.2 Periodic Maintenance of Materialized Views......................362


8.5.3 Rewriting Queries to Use Materialized V ie w s...................362


8.5.4 Automatic Creation of Materialized V iew s......................... 364


8.5.5 Exercises for Section 8 .5 .........................................................365


8.6 Summary of Chapter 8 .........................................................................366


8.7 References for Chapter 8 ..................................................................... 367


9 SQL in a Server E nvironm ent 369


9.1 The Three-Tier Architecture ............................................................369


9.1.1 The Web-Server T ie r............................................................... 370


9.1.2 The Application T ier............................................................... 371


9.1.3 The Database T i e r .................................................................. 372


9.2 The SQL Environm ent.........................................................................372


9.2.1 Environments............................................................................373


9.2.2 Schem as..................................................................................... 374


9.2.3 Catalogs..................................................................................... 375


9.2.4 Clients and Servers in the SQL E n v iro n m en t...................375


9.2.5 Connections...............................................................................376


9.2.6 Sessions..................................................................................... 377


9.2.7 M odules..................................................................................... 378


9.3 The SQL/Host-Language In terface...................................................378


9.3.1 The Impedance Mismatch Problem ......................................380


9.3.2 Connecting SQL to the Host Language................................380


9.3.3 The DECLARE Section............................................................... 381


9.3.4 Using Shared Variables .........................................................382


9.3.5 Single-Row Select S tatem ents............................................... 383


9.3.6 C u rs o rs ..................................................................................... 383


9.3.7 Modifications by C u rso r.........................................................386


9.3.8 Protecting Against Concurrent U p d a te s............................ 387


9.3.9 Dynamic SQ L ............................................................................388


9.3.10 Exercises for Section 9 .3 .........................................................390


9.4 Stored P ro c e d u re s...............................................................................391


9.4.1 Creating PSM Functions and Procedures ......................... 391


9.4.2 Some Simple Statement Forms in P S M ................................392


9.4.3 Branching S ta tem en ts............................................................394


9.4.4 Queries in P S M .........................................................................395


9.4.5 Loops in PSM .........................................................................396


9.4.6 For-Loops.................................................................................. 398


9.4.7 Exceptions in P S M .................................................................. 400


9.4.8 Using PSM Functions and P ro ced u res................................402


9.4.9 Exercises for Section 9 .4 .........................................................402


9.5 Using a Call-Level In terface............................................................... 404


9.5.1 Introduction to S Q L /C L I......................................................405


9.5.2 Processing S tatem ents............................................................ 407


9.5.3 Fetching Data From a Query R e s u lt...................................408


9.5.4 Passing Parameters to Q u e rie s ............................................ 410


9.5.5 Exercises for Section 9 .5 .........................................................412


TABLE OF CONTENTS xxi


9.6 J D B C .................................................................................................... 412


9.6.1 Introduction to J D B C ............................................................412


9.6.2 Creating Statements in JD B C...............................................413


9.6.3 Cursor Operations in JD B C ..................................................415


9.6.4 Parameter P assin g ........................................................ ... 416


9.6.5 Exercises for Section 9 .6 ........................................................ 416


9.7 P H P ....................................................................................................... 416


9.7.1 PHP B asics.............................................................................. 417


9.7.2 A rrays........................................................................................418


9.7.3 The PEAR DB L ib ra r y ........................................................ 419


9.7.4 Creating a Database Connection Using D B ......................419


9.7.5 Executing SQL S ta te m e n ts.................................................. 419


9.7.6 Cursor Operations in PHP .................................................. 420


9.7.7 Dynamic SQL in P H P ............................................................421


9.7.8 Exercises for Section 9 .7 .........................................................422


9.8 Summary of Chapter 9 ........................................................................ 422


9.9 References for Chapter 9 .....................................................................423


10 A dvanced Topics in R elational D atabases 425


10.1 Security and User Authorization in S Q L .........................................425


10.1.1 Privileges..................................................................................426


10.1.2 Creating Privileges..................................................................427


10.1.3 The Privilege-Checking Process............................................428


10.1.4 Granting Privileges..................................................................430


10.1.5 Grant Diagrams .....................................................................431


10.1.6 Revoking Privileges ...............................................................433


10.1.7 Exercises for Section 1 0 .1 ..................................................... 436


10.2 Recursion in S Q L ..................................................................................437


10.2.1 Defining Recursive Relations in S Q L ...................................437


10.2.2 Problematic Expressions in Recursive SQL ......................440


10.2.3 Exercises for Section 1 0 .2 ..................................................... 443


10.3 The Object-Relational M o d e l............................................................445


10.3.1 From Relations to Object-Relations .................................. 445


10.3.2 Nested R elatio n s.....................................................................446


10.3.3 References..................................................................................447


10.3.4 Object-Oriented Versus Object-Relational.........................449


10.3.5 Exercises for Section 1 0 .3 ..................................................... 450


10.4 User-Defined Types in S Q L ...............................................................451


10.4.1 Defining Types in SQ L ............................................................451


10.4.2 Method Declarations in UDT’s ............................................452


10.4.3 Method Definitions..................................................................453


10.4.4 Declaring Relations with a U D T .........................................454


10.4.5 References..................................................................................454


10.4.6 Creating Object ID’s for T ables............................................455


10.4.7 Exercises for Section 1 0 .4 ..................................................... 457


xxii TABLE OF CONTENTS


TABLE OF CONTENTS xxiii


10.5 Operations on Object-Relational D a t a ............................................ 457


10.5.1 Following References...............................................................457


10.5.2 Accessing Components of Tuples with a U D T ...................458


10.5.3 Generator and Mutator F u n c tio n s......................................460


10.5.4 Ordering Relationships on UDT’s .........................................461


10.5.5 Exercises for Section 1 0 .5 ......................................................463


10.6 On-Line Analytic Processing ............................................................464


10.6.1 OLAP and Data W arehouses............................................... 465


10.6.2 OLAP Applications ...............................................................465


10.6.3 A Multidimensional View of OLAP D a t a ......................... 466


10.6.4 Star Schem as........................................................................... 467


10.6.5 Slicing and D ic in g .................................................................. 469


10.6.6 Exercises for Section 1 0 .6 ..................................................... 472


10.7 Data C u b e s ........................................................................................... 473


10.7.1 The Cube O p e ra to r...............................................................473


10.7.2 The Cube Operator in S Q L .................................................. 475


10.7.3 Exercises for Section 1 0 .7 ......................................................477


10.8 Summary of Chapter 1 0 ..................................................................... 478


10.9 References for Chapter 1 0 .................................................................. 480


III Modeling and Programming for Semistructured


Data 481


11 T he S em istru ctu red -D ata M odel 483


11.1 Semistructured D a ta ............................................................................483


11.1.1 Motivation for the Semistructured-Data M o d e l................483


11.1.2 Semistructured Data R epresentation...................................484


11.1.3 Information Integration Via Semistructured D a ta .............486


11.1.4 Exercises for Section 1 1 .1 ......................................................487


11.2 X M L ........................................................................................................488


11.2.1 Semantic T a g s ........................................................................ 488


11.2.2 XML With and Without a Schem a......................................489


11.2.3 Well-Formed X M L .................................................................. 489


11.2.4 A ttributes..................................................................................490


11.2.5 Attributes That Connect Elem ents......................................491


11.2.6 Namespaces...............................................................................493


11.2.7 XML and D atabases...............................................................493


11.2.8 Exercises for Section 1 1 .2 ......................................................495


11.3 Document Type D efinitions...............................................................495


11.3.1 The Form of a D T D ...............................................................495


11.3.2 Using a D T D ........................................................................... 499


11.3.3 Attribute L i s t s ........................................................................ 499


11.3.4 Identifiers and References......................................................500


11.3.5 Exercises for Section 1 1 .3 ......................................................502


xxiv TABLE OF CONTENTS


11A XML S chem a.......................................................................................502


11.4.1 The Form of an XML Schema.............................................. 502


11.4.2 E le m e n ts................................................................................ 503


11.4.3 Complex T ypes....................................................................... 504


11.4.4 A ttributes................................................................................ 506


11.4.5 Restricted Simple T ypes........................................................507


11.4.6 Keys in XML S ch em a...........................................................509


11.4.7 Foreign Keys in XML Schema.............................................. 510


11.4.8 Exercises for Section 1 1 .4 .....................................................512


11.5 Summary of Chapter 1 1 ....................................................................514


11.6 References for Chapter 1 1 .................................................................515


12 P rogram m ing Languages for XML 517


12.1 X P a th ...................................................................................................517


12.1.1 The XPath Data M o d el........................................................518


12.1.2 Document N odes....................................................................519


12.1.3 Path Expressions....................................................................519


12.1.4 Relative Path Expressions.....................................................521


12.1.5 Attributes in Path Expressions........................................... 521


12.1.6 A xes..........................................................................................521


12.1.7 Context of Expressions...........................................................522


12.1.8 W ildcards................................................................................ 523


12.1.9 Conditions in Path Expressions........................................... 523


12.1.10Exercises for Section 1 2 .1 .....................................................526


12.2 X Q u e ry ................................................................................................528


12.2.1 XQuery B a sic s.......................................................................530


12.2.2 FLWR Expressions.................................................................530


12.2.3 Replacement of Variables by Their V alues.........................534


12.2.4 Joins in X Q u e ry ....................................................................536


12.2.5 XQuery Comparison O perators........................................... 537


12.2.6 Elimination of D uplicates.....................................................538


12.2.7 Quantification in X Q u ery .....................................................539


12.2.8 Aggregations.......................................................................... 540


12.2.9 Branching in XQuery Expressions ..................................... 540


12.2.10 Ordering the Result of a Q uery........................................... 541


12.2.11 Exercises for Section 1 2 .2 .....................................................543


12.3 Extensible Stylesheet Language....................................................... 544


12.3.1 XSLT B a s ic s ..........................................................................544


12.3.2 Tem plates................................................................................ 544


12.3.3 Obtaining Values From XML D a ta ..................................... 545


12.3.4 Recursive Use of Tem plates..................................................546


12.3.5 Iteration in XSLT .................................................................549


12.3.6 Conditionals in X S L T ...........................................................551


12.3.7 Exercises for Section 1 2 .3 .....................................................551


12.4 Summary of Chapter 1 2 ....................................................................553


TABLE OF CONTENTS xxv


12.5 References for Chapter 1 2 .................................................................. 554


IV Database System Implementation 555


13 Secondary S torage M anagem ent 557


13.1 The Memory Hierarchy ..................................................................... 557


13.1.1 The Memory H ie ra rc h y .........................................................557


13.1.2 Transfer of Data Between L e v e ls.........................................560


13.1.3 Volatile and Nonvolatile S to r a g e .........................................560


13.1.4 Virtual Memory ..................................................................... 560


13.1.5 Exercises for Section 1 3 .1 ......................................................561


13.2 D isks........................................................................................................562


13.2.1 Mechanics of D isk s.................................................................. 562


13.2.2 The Disk C o n tro lle r...............................................................564


13.2.3 Disk Access C haracteristics.................................................. 564


13.2.4 Exercises for Section 1 3 .2 ............................... ......................567


13.3 Accelerating Access to Secondary S to ra g e ......................................568


13.3.1 The I/O Model of Computation .........................................568


13.3.2 Organizing Data by Cylinders............................................... 569


13.3.3 Using Multiple D isks...............................................................570


13.3.4 Mirroring D isks........................................................................ 571


13.3.5 Disk Scheduling and the Elevator Algorithm ...................571


13.3.6 Prefetching and Large-Scale B uffering............................... 573


13.3.7 Exercises for Section 1 3 .3 ..................................................... 573


13.4 Disk F a ilu re s............................................... ........................................ 575


13.4.1 Intermittent F ailures...............................................................576


13.4.2 C hecksum s...............................................................................576


13.4.3 Stable S to r a g e ........................................................................ 577


13.4.4 Error-Handling Capabilities of Stable S torage...................578


13.4.5 Recovery from Disk Crashes.................................................. 578


13.4.6 Mirroring as a Redundancy Technique............................... 579


13.4.7 Parity B lo ck s............................................................................580


13.4.8 An Improvement: RAID 5 ......................................................583


13.4.9 Coping With Multiple Disk C ra s h e s ...................................584


13.4.10Exercises for Section 1 3 .4 ......................................................587


13.5 Arranging Data on D is k ..................................................................... 590


13.5.1 Fixed-Length R ec o rd s............................................................590


13.5.2 Packing Fixed-Length Records into Blocks......................... 592


13.5.3 Exercises for Section 1 3 .5 ..................................................... 593


13.6 Representing Block and Record A ddresses......................................593


13.6.1 Addresses in Client-Server System s......................................593


13.6.2 Logical and Structured Addresses.........................................595


13.6.3 Pointer Swizzling..................................................................... 596


13.6.4 Returning Blocks to D i s k ......................................................600


xxvi TABLE OF CONTENTS


13.6.5 Pinned Records and B lo ck s..................................................600


13.6.6 Exercises for Section 1 3 .6 .....................................................602


13.7 Variable-Length Data and R eco rd s..................................................603


13.7.1 Records With Variable-Length Fields ............................... 604


13.7.2 Records With Repeating F ield s............................................605


13.7.3 Variable-Format Records .....................................................607


13.7.4 Records That Do Not Fit in a B lo c k .................................. 608


13.7.5 BLOBs ....................................................................................608


13.7.6 Column S to r e s....................................................................... 609


13.7.7 Exercises for Section 1 3 .7 .....................................................610


13.8 Record Modifications...........................................................................612


13.8.1 Insertion....................................................................................612


13.8.2 D eletion....................................................................................614


13.8.3 Update ....................................................................................615


13.8.4 Exercises for Section 1 3 .8 .....................................................615


13.9 Summary of Chapter 1 3 .................................................................... 615


13.10References for Chapter 1 3 ................................................................. 617


14 Index S tru ctu res 619


14.1 Index-Structure B asics........................................................................620


14.1.1 Sequential F iles........................................................................621


14.1.2 Dense Indexes...........................................................................621


14.1.3 Sparse In d e x e s....................................................................... 622


14.1.4 Multiple Levels of In d e x ........................................................623


14.1.5 Secondary In d e x es................................................................. 624


14.1.6 Applications of Secondary In d e x es..................................... 625


14.1.7 Indirection in Secondary In d ex es........................................ 626


14.1.8 Document Retrieval and Inverted In d ex es.........................628


14.1.9 Exercises for Section 1 4 .1 .....................................................631


14.2 B -T re e s................................................................................................ 633


14.2.1 The Structure of B -trees........................................................634


14.2.2 Applications of B-trees...........................................................637


14.2.3 Lookup in B -T rees................................................................. 639


14.2.4 Range Q u e rie s ....................................................................... 639


14.2.5 Insertion Into B -T rees...........................................................640


14.2.6 Deletion From B-Trees...........................................................642


14.2.7 Efficiency of B -Trees.............................................................. 645


14.2.8 Exercises for Section 1 4 .2 .....................................................646


14.3 Hash Tables..........................................................................................648


14.3.1 Secondary-Storage Hash T ables........................................... 649


14.3.2 Insertion Into a Hash T a b le ..................................................649


14.3.3 Hash-Table D eletio n .............................................................. 650


14.3.4 Efficiency of Hash Table In d e x e s........................................ 651


14.3.5 Extensible Hash Tables ........................................................652


14.3.6 Insertion Into Extensible Hash T a b le s............................... 653


TABLE OF CONTENTS xxvii


14.3.7 Linear Hash Tables..................................................................655


14.3.8 Insertion Into Linear Hash Tables ......................................657


14.3.9 Exercises for Section 1 4 .3 ......................................................659


14.4 Multidimensional In d e x e s .................................................................. 661


14.4.1 Applications of Multidimensional In d e x e s......................... 661


14.4.2 Executing Range Queries Using Conventional Indexes . . 663


14.4.3 Executing Nearest-Neighbor Queries Using Conventional


In d e x e s .....................................................................................664


14.4.4 Overview of Multidimensional Index S tructures................664


14.5 Hash Structures for Multidimensional D a t a ...................................665


14.5.1 Grid F ile s ..................................................................................665


14.5.2 Lookup in a Grid F i l e ............................................................666


14.5.3 Insertion Into Grid F iles.........................................................667


14.5.4 Performance of Grid F ile s ..................................................... 669


14.5.5 Partitioned Hash F unctions.................................................. 671


14.5.6 Comparison of Grid Files and Partitioned Hashing .... 673


14.5.7 Exercises for Section 1 4 .5 ......................................................673


14.6 Tree Structures for Multidimensional D a ta ......................................675


14.6.1 Multiple-Key Indexes ............................................................675


14.6.2 Performance of Multiple-Key Indexes...................................676


14.6.3 kd-T rees.....................................................................................677


14.6.4 Operations on fed-Trees.........................................................679


14.6.5 Adapting fed-Trees to Secondary Storage............................ 681


14.6.6 Quad T re e s ...............................................................................681


14.6.7 R -T re e s.....................................................................................683


14.6.8 Operations on R -Trees............................................................684


14.6.9 Exercises for Section 1 4 .6 ......................................................686


14.7 Bitmap Indexes.....................................................................................688


14.7.1 Motivation for Bitmap In d e x e s............................................ 689


14.7.2 Compressed B itm aps...............................................................691


14.7.3 Operating on Run-Length-Encoded Bit-Vectors................693


14.7.4 Managing Bitmap Indexes......................................................693


14.7.5 Exercises for Section 1 4 .7 ......................................................695


14.8 Summary of Chapter 1 4 ..................................................................... 695


14.9 References for Chapter 1 4 .................................................................. 697


15 Q uery E xecution 701


15.1 Introduction to Physical-Query-Plan O p erato rs............................ 703


15.1.1 Scanning Tables ..................................................................... 703


15.1.2 Sorting While Scanning T a b le s............................................ 704


15.1.3 The Computation Model for Physical O p e ra to rs .............704


15.1.4 Parameters for Measuring Costs .........................................705


15.1.5 I/O Cost for Scan O p e ra to rs ............................................... 706


15.1.6 Iterators for Implementation of Physical Operators .... 707


15.2 One-Pass Algorithms........................................................................... 709


xxviii TABLE OF CONTENTS


15.2.1 One-Pass Algorithms for Tuple-at-a-Time Operations . . 711


15.2.2 One-Pass Algorithms for Unary, Full-Relation Operations 712


15.2.3 One-Pass Algorithms for Binary O perations......................715


15.2.4 Exercises for Section 1 5 .2 ..................................................... 718


15.3 Nested-Loop J o i n s .............................................................................. 718


15.3.1 Tuple-Based Nested-Loop J o i n ............................................719


15.3.2 An Iterator for Tuple-Based Nested-Loop Join ................719


15.3.3 Block-Based Nested-Loop Join A lgorithm ......................... 719


15.3.4 Analysis of Nested-Loop J o i n ...............................................721


15.3.5 Summary of Algorithms so F a r ............................................722


15.3.6 Exercises for Section 1 5 .3 ..................................................... 722


15.4 Two-Pass Algorithms Based on Sorting .........................................723


15.4.1 Two-Phase, Multiway Merge-Sort.........................................723


15.4.2 Duplicate Elimination Using S o rtin g .................................. 725


15.4.3 Grouping and Aggregation Using S o r tin g .........................726


15.4.4 A Sort-Based Union A lgorithm ............................................726


15.4.5 Sort-Based Intersection and Difference............................... 727


15.4.6 A Simple Sort-Based Join A lgorithm.................................. 728


15.4.7 Analysis of Simple Sort-Join ...............................................729


15.4.8 A More Efficient Sort-Based J o in .........................................729


15.4.9 Summary of Sort-Based A lg o rith m s.................................. 730


15.4.10Exercises for Section 1 5 .4 ..................................................... 730


15.5 Two-Pass Algorithms Based on H ash in g .........................................732


15.5.1 Partitioning Relations by H a sh in g ..................................... 732


15.5.2 A Hash-Based Algorithm for Duplicate Elimination . . . 732


15.5.3 Hash-Based Grouping and Aggregation ............................ 733


15.5.4 Hash-Based Union, Intersection, and Difference................734


15.5.5 The Hash-Join A lgorithm ..................................................... 734


15.5.6 Saving Some Disk I/O ’s ........................................................ 735


15.5.7 Summary of Hash-Based A lgorithm s.................................. 737


15.5.8 Exercises for Section 1 5 .5 .....................................................738


15.6 Index-Based A lgorithm s.....................................................................739


15.6.1 Clustering and Nonclustering Indexes ............................... 739


15.6.2 Index-Based S electio n........................................................... 740


15.6.3 Joining by Using an Index..................................................... 742


15.6.4 Joins Using a Sorted I n d e x ..................................................743


15.6.5 Exercises for Section 1 5 .6 ..................................................... 745


15.7 Buffer Management.............................................................................. 746


15.7.1 Buffer Management A rchitecture.........................................746


15.7.2 Buffer Management Strategies ............................................747


15.7.3 The Relationship Between Physical Operator Selection


and Buffer M anagem ent........................................................ 750


15.7.4 Exercises for Section 1 5 .7 ..................................................... 751


15.8 Algorithms Using More Than Two P a s s e s ......................................752


15.8.1 Multipass Sort-Based Algorithms.........................................752


TABLE OF CONTENTS xxix


15.8.2 Performance of Multipass, Sort-Based Algorithms .... 753


15.8.3 Multipass Hash-Based A lg o rith m s......................................754


15.8.4 Performance of Multipass Hash-Based Algorithms .... 754


15.8.5 Exercises for Section 1 5 .8 ..................................................... 755


15.9 Summary of Chapter 1 5 ..................................................................... 756


15.10References for Chapter 1 5 ..................................................................757


16 T h e Q uery C om piler 759


16.1 Parsing and Preprocessing..................................................................760


16.1.1 Syntax Analysis and Parse T re e s .........................................760


16.1.2 A Grammar for a Simple Subset of S Q L ............................ 761


16.1.3 The Preprocessor..................................................................... 764


16.1.4 Preprocessing Queries Involving V iew s............................... 765


16.1.5 Exercises for Section 1 6 .1 ..................................................... 767


16.2 Algebraic Laws for Improving Query Plans ...................................768


16.2.1 Commutative and Associative L a w s ...................................768


16.2.2 Laws Involving Selection.........................................................770


16.2.3 Pushing Selections..................................................................772


16.2.4 Laws Involving P rojection..................................................... 774


16.2.5 Laws About Joins and P r o d u c ts .........................................776


16.2.6 Laws Involving Duplicate E lim in atio n ............................... 777


16.2.7 Laws Involving Grouping and Aggregation......................... 777


16.2.8 Exercises for Section 16.2 ......................................................780


16.3 From Parse Trees to Logical Query P l a n s ......................................781


16.3.1 Conversion to Relational A lgebra.........................................782


16.3.2 Removing Subqueries From Conditions............................... 783


16.3.3 Improving the Logical Query P l a n ......................................788


16.3.4 Grouping Associative/Commutative O p e ra to rs................790


16.3.5 Exercises for Section 1 6 .3 ..................................................... 791


16.4 Estimating the Cost of O p eratio n s..................................................792


16.4.1 Estimating Sizes of Intermediate Relations ......................793


16.4.2 Estimating the Size of a Projection......................................794


16.4.3 Estimating the Size of a Selection.........................................794


16.4.4 Estimating the Size of a J o i n ............................................... 797


16.4.5 Natural Joins With Multiple Join A ttrib u te s...................799


16.4.6 Joins of Many R elations.........................................................800


16.4.7 Estimating Sizes for Other O perations............................... 801


16.4.8 Exercises for Section 1 6 .4 ..................................................... 802


16.5 Introduction to Cost-Based Plan Selection......................................803


16.5.1 Obtaining Estimates for Size Param eters............................ 804


16.5.2 Computation of S ta tistic s..................................................... 807


16.5.3 Heuristics for Reducing the Cost of Logical Query Plans . 808


16.5.4 Approaches to Enumerating Physical P la n s......................810


16.5.5 Exercises for Section 1 6 .5 ..................................................... 813


16.6 Choosing an Order for Jo in s...............................................................814


X X X TABLE OF CONTENTS


16.6.1 Significance of Left and Right Join A rg u m e n ts................815


16.6.2 Join T rees................................................................................. 815


16.6.3 Left-Deep Join T rees.............................................................. 816


16.6.4 Dynamic Programming to Select a Join Order and Grouping819


16.6.5 Dynamic Programming With More Detailed Cost Functions823


16.6.6 A Greedy Algorithm for Selecting a Join O rd e r................824


16.6.7 Exercises for Section 1 6 .6 ..................................................... 825


16.7 Completing the Physical-Query-Plan...............................................826


16.7.1 Choosing a Selection M e th o d ...............................................827


16.7.2 Choosing a Join M ethod........................................................ 829


16.7.3 Pipelining Versus M aterialization.........................................830


16.7.4 Pipelining Unary O p eratio n s...............................................830


16.7.5 Pipelining Binary O perations...............................................830


16.7.6 Notation for Physical Query P la n s ......................................834


16.7.7 Ordering of Physical O p e ratio n s.........................................837


16.7.8 Exercises for Section 1 6 .7 ..................................................... 838


16.8 Summary of Chapter 1 6 .....................................................................839


16.9 References for Chapter 1 6 ..................................................................841


17 C oping W ith System Failures 843


17.1 Issues and Models for Resilient O p eratio n ......................................843


17.1.1 Failure M odes...........................................................................844


17.1.2 More About T ransactions..................................................... 845


17.1.3 Correct Execution of T ransactions..................................... 846


17.1.4 The Primitive Operations of T ransactions.........................848


17.1.5 Exercises for Section 1 7 .1 ..................................................... 851


17.2 Undo Logging....................................................................................... 851


17.2.1 Log Records.............................................................................. 851


17.2.2 The Undo-Logging Rules ..................................................... 853


17.2.3 Recovery Using Undo Logging ............................................855


17.2.4 Checkpointing ........................................................................857


17.2.5 Nonquiescent Checkpointing..................................................858


17.2.6 Exercises for Section 1 7 .2 ..................................................... 862


17.3 Redo Logging....................................................................................... 863


17.3.1 The Redo-Logging R u l e ........................................................ 863


17.3.2 Recovery With Redo Logging...............................................864


17.3.3 Checkpointing a Redo Log..................................................... 866


17.3.4 Recovery With a Checkpointed Redo L o g .........................867


17.3.5 Exercises for Section 1 7 .3 ..................................................... 868


17.4 Undo/Redo L og g in g ...........................................................................869


17.4.1 The Undo/Redo R u les........................................................... 870


17.4.2 Recovery With Undo/Redo L o g g in g.................................. 870


17.4.3 Checkpointing an Undo/Redo L o g ......................................872


17.4.4 Exercises for Section 1 7 .4 ..................................................... 874


17.5 Protecting Against Media F a ilu re s..................................................875


TABLE OF CONTENTS xxxi


17.5.1 The Archive...............................................................................875


17.5.2 Nonquiescent A rchiving.........................................................875


17.5.3 Recovery Using an Archive and L o g ...................................878


17.5.4 Exercises for Section 1 7 .5 ......................................................879


17.6 Summary of Chapter 1 7 ..................................................................... 879


17.7 References for Chapter 1 7 .................................................................. 881


18 C oncurrency C ontrol 883


18.1 Serial and Serializable S ch ed u les......................................................884


18.1.1 S chedules..................................................................................884


18.1.2 Serial Schedules........................................................................ 885


18.1.3 Serializable S chedules............................................................886


18.1.4 The Effect of Transaction S em antics...................................887


18.1.5 A Notation for Transactions and S ch ed u les......................889


18.1.6 Exercises for Section 1 8 .1 ......................................................889


18.2 Conflict-Serializability........................................................................ 890


18.2.1 Conflicts.....................................................................................890


18.2.2 Precedence Graphs and a Test for Conflict-Serializability 892


18.2.3 Why the Precedence-Graph Test W o rk s............................ 894


18.2.4 Exercises for Section 1 8 .2 ......................................................895


18.3 Enforcing Serializability by Locks . ...................................................897


18.3.1 L o c k s ........................................................................................898


18.3.2 The Locking Scheduler............................................................900


18.3.3 Two-Phase Locking ...............................................................900


18.3.4 Why Two-Phase Locking W o r k s .........................................901


18.3.5 Exercises for Section 1 8 .3 ..................................................... 903


18.4 Locking Systems With Several Lock M o d e s ...................................905


18.4.1 Shared and Exclusive L ocks.................................................. 905


18.4.2 Compatibility Matrices .........................................................907


18.4.3 Upgrading L o ck s..................................................................... 908


18.4.4 Update Locks............................................................................909


18.4.5 Increment L o c k s ..................................................................... 911


18.4.6 Exercises for Section 1 8 .4 ......................................................913


18.5 An Architecture for a Locking Scheduler.........................................915


18.5.1 A Scheduler That Inserts Lock Actions ............................ 915


18.5.2 The Lock T able........................................................................ 918


18.5.3 Exercises for Section 1 8 .5 ......................................................921


18.6 Hierarchies of Database Elem ents......................................................921


18.6.1 Locks With Multiple G ranularity.........................................921


18.6.2 Warning L o c k s........................................................................ 922


18.6.3 Phantoms and Handling Insertions C o rre c tly ...................926


18.6.4 Exercises for Section 1 8 .6 ......................................................927


18.7 The Tree P ro to c o l...............................................................................927


18.7.1 Motivation for Tree-Based Locking......................................927


18.7.2 Rules for Access to Tree-Structured D a t a ......................... 928


xxxii TABLE OF CONTENTS


18.7.3 Why the Tree Protocol W orks...............................................929


18.7.4 Exercises for Section 1 8 .7 ..................................................... 932


18.8 Concurrency Control by Tim estam ps...............................................933


18.8.1 Timestamps..............................................................................934


18.8.2 Physically Unrealizable Behaviors ......................................934


18.8.3 Problems With Dirty D a t a .................................................. 935


18.8.4 The Rules for Timestamp-Based Scheduling......................937


18.8.5 Multiversion T im estam ps..................................................... 939


18.8.6 Timestamps Versus Locking..................................................941


18.8.7 Exercises for Section 1 8 .8 ..................................................... 942


18.9 Concurrency Control by Validation..................................................942


18.9.1 Architecture of a Validation-Based S cheduler...................942


18.9.2 The Validation Rules.............................................................. 943


18.9.3 Comparison of Three Concurrency-Control Mechanisms . 946


18.9.4 Exercises for Section 1 8 .9 ..................................................... 948


18.10Summary of Chapter 1 8 .....................................................................948


18.11 References for Chapter 1 8 ..................................................................950


19 M ore A bout T ransaction M anagem ent 953


19.1 Serializability and Recoverability..................................................... 953


19.1.1 The Dirty-Data Problem........................................................ 954


19.1.2 Cascading Rollback .............................................................. 955


19.1.3 Recoverable Schedules........................................................... 956


19.1.4 Schedules That Avoid Cascading Rollback.........................957


19.1.5 Managing Rollbacks Using Locking..................................... 957


19.1.6 Group C o m m it........................................................................959


19.1.7 Logical Logging........................................................................960


19.1.8 Recovery From Logical Logs..................................................963


19.1.9 Exercises for Section 1 9 .1 ..................................................... 965


19.2 D eadlocks..............................................................................................966


19.2.1 Deadlock Detection by Timeout .........................................967


19.2.2 The Waits-For G r a p h ........................................................... 967


19.2.3 Deadlock Prevention by Ordering E lem en ts......................970


19.2.4 Detecting Deadlocks by T im estam ps.................................. 970


19.2.5 Comparison of Deadlock-Management M ethods................972


19.2.6 Exercises for Section 1 9 .2 ..................................................... 974


19.3 Long-Duration Transactions.............................................................. 975


19.3.1 Problems of Long Transactions............................................976


19.3.2 Sagas ....................................................................................... 978


19.3.3 Compensating Transactions..................................................979


19.3.4 Why Compensating Transactions W o r k ............................ 980


19.3.5 Exercises for Section 1 9 .3 ..................................................... 981


19.4 Summary of Chapter 1 9 .....................................................................982


19.5 References for Chapter 1 9 ..................................................................983


TABLE OF CONTENTS xxxiii


20 P arallel and D istrib u ted D atabases 985


20.1 Parallel Algorithms on R e la tio n s......................................................985


20.1.1 Models of Parallelism ............................................................986


20.1.2 Tuple-at-a-Time Operations in Parallel............................... 989


20.1.3 Parallel Algorithms for Full-Relation O p e ratio n s.............989


20.1.4 Performance of Parallel Algorithms......................................990


20.1.5 Exercises for Section 20.1 ...................................................... 993


20.2 The Map-Reduce Parallelism Framework.........................................993


20.2.1 The Storage M odel.................................................................. 993


20.2.2 The Map F u n ctio n .................................................................. 994


20.2.3 The Reduce Function ............................................................995


20.2.4 Exercises for Section 20.2 ...................................................... 996


20.3 Distributed D atab ases........................................................................ 997


20.3.1 Distribution of D a t a ...............................................................997


20.3.2 Distributed Transactions.........................................................998


20.3.3 Data R eplication..................................................................... 999


20.3.4 Exercises for Section 20.3 ...................................................... 1000


20.4 Distributed Query Processing............................................................1000


20.4.1 The Distributed Join Problem ............................................1000


20.4.2 Semijoin R eductions...............................................................1001


20.4.3 Joins of Many R elations.........................................................1002


20.4.4 Acyclic H ypergraphs...............................................................1003


20.4.5 Full Reducers for Acyclic Hypergraphs................................1005


20.4.6 Why the Full-Reducer Algorithm W o rk s............................ 1006


20.4.7 Exercises for Section 20.4 ...................................................... 1007


20.5 Distributed C o m m it........................................................................... 1008


20.5.1 Supporting Distributed Atomicity ......................................1008


20.5.2 Two-Phase C o m m it...............................................................1009


20.5.3 Recovery of Distributed Transactions...................................1011


20.5.4 Exercises for Section 2 0 .5 ......................................................1013


20.6 Distributed L o c k in g ............................................................................1014


20.6.1 Centralized Lock S y stem s..................................................... 1015


20.6.2 A Cost Model for Distributed Locking Algorithms .... 1015


20.6.3 Locking Replicated E lem en ts............................................... 1016


20.6.4 Primary-Copy Locking............................................................1017


20.6.5 Global Locks From Local Locks............................................1017


20.6.6 Exercises for Section 2 0 .6 ......................................................1019


20.7 Peer-to-Peer Distributed Search.........................................................1020


20.7.1 Peer-to-Peer N etw orks............................................................1020


20.7.2 The Distributed-Hashing P ro b le m ......................................1021


20.7.3 Centralized Solutions for Distributed H ashing...................1022


20.7.4 Chord C ircles............................................................................1022


20.7.5 Links in Chord C ircles............................................................1024


20.7.6 Search Using Finger T a b le s.................................................. 1024


20.7.7 Adding New N odes.................................................................. 1027


xxxiv TABLE OF CONTENTS


20.7.8 When a Peer Leaves the N etw ork.........................................1030


20.7.9 When a Peer F a i l s ..................................................................1030


20.7.10Exercises for Section 20.7 ..................................................... 1031


20.8 Summary of Chapter 20 ..................................................................... 1031


20.9 References for Chapter 20 .................................................................. 1033


V Other Issues in Management of Massive Data 1035


21 Info rm atio n In teg ratio n 1037


21.1 Introduction to Information In te g ra tio n .........................................1037


21.1.1 Why Information Integration? ............................................ 1038


21.1.2 The Heterogeneity P ro b lem .................................................. 1040


21.2 Modes of Information Integration..................................................... 1041


21.2.1 Federated Database Systems ............................................... 1042


21.2.2 Data Warehouses..................................................................... 1043


21.2.3 M ediators..................................................................................1046


21.2.4 Exercises for Section 2 1 .2 ......................................................1048


21.3 Wrappers in Mediator-Based Systems ............................................1049


21.3.1 Templates for Query P attern s............................................... 1050


21.3.2 Wrapper G enerators...............................................................1051


21.3.3 F ilte rs ........................................................................................1052


21.3.4 Other Operations at the Wrapper ......................................1053


21.3.5 Exercises for Section 2 1 .3 ......................................................1054


21.4 Capability-Based O ptim ization.........................................................1056


21.4.1 The Problem of Limited Source Capabilities......................1056


21.4.2 A Notation for Describing Source Capabilities...................1057


21.4.3 Capability-Based Query-Plan Selection............................... 1058


21.4.4 Adding Cost-Based O ptim ization.........................................1060


21.4.5 Exercises for Section 2 1 .4 ......................................................1060


21.5 Optimizing Mediator Q u e rie s............................................................1061


21.5.1 Simplified Adornment N otation ............................................1061


21.5.2 Obtaining Answers for Subgoals .........................................1062


21.5.3 The Chain A lg o rith m ............................................................1063


21.5.4 Incorporating Union Views at the M ed iato r......................1067


21.5.5 Exercises for Section 2 1 .5 ..................................................... 1068


21.6 Local-as-View M ediators.....................................................................1069


21.6.1 Motivation for LAV M e d ia to rs............................................1069


21.6.2 Terminology for LAV Mediation .........................................1070


21.6.3 Expanding Solutions...............................................................1071


21.6.4 Containment of Conjunctive Q ueries...................................1073


21.6.5 Why the Containment-Mapping Test W orks...................... 1075


21.6.6 Finding Solutions to a Mediator Q uery............................... 1076


21.6.7 Why the LMSS Theorem H olds............................................1077


21.6.8 Exercises for Section 2 1 .6 ......................................................1078


TABLE OF CONTENTS X X X V


21.7 Entity Resolution..................................................................................1078


21.7.1 Deciding Whether Records Represent a Common Entity . 1079


21.7.2 Merging Similar Records.........................................................1081


21.7.3 Useful Properties of Similarity and Merge Functions . . .1082


21.7.4 The R-Swoosh Algorithm for ICAR Records......................1083


21.7.5 Why R-Swoosh W o rk s............................................................1086


21.7.6 Other Approaches to Entity R e so lu tio n ............................ 1086


21.7.7 Exercises for Section 2 1 .7 ..................................................... 1087


21.8 Summary of Chapter 2 1 ..................................................................... 1089


21.9 References for Chapter 2 1 ..................................................................1091


22 D a ta M ining 1093


22.1 Frequent-Itemset M ining..................................................................... 1093


22.1.1 The Market-Basket M odel......................................................1094


22.1.2 Basic D efinitions..................................................................... 1095


22.1.3 Association R ules..................................................................... 1097


22.1.4 The Computation Model for Frequent Ite m se ts................1098


22.1.5 Exercises for Section 22.1 ...................................................... 1099


22.2 Algorithms for Finding Frequent Ite m s e ts ......................................1100


22.2.1 The Distribution of Frequent Item sets................................1100


22.2.2 The Naive Algorithm for Finding Frequent Itemsets . . . 1101


22.2.3 The A-Priori A lgorithm .........................................................1102


22.2.4 Implementation of the A-Priori Algorithm......................... 1104


22.2.5 Making Better Use of Main M em ory...................................1105


22.2.6 When to Use the PCY Algorithm.........................................1106


22.2.7 The Multistage Algorithm ......................................................1107


22.2.8 Exercises for Section 2 2 .2 ............................................... ... . 1109


22.3 Finding Similar I t e m s ........................................................................ 1110


22.3.1 The Jaccard Measure of S im ilarity......................................1110


22.3.2 Applications of Jaccard S im ilarity ......................................1110


22.3.3 M inhashing...............................................................................1112


22.3.4 Minhashing and Jaccard Distance ......................................1113


22.3.5 Why Minhashing W o rk s.........................................................1113


22.3.6 Implementing M inhashing......................................................1114


22.3.7 Exercises for Section 2 2 .3 ......................................................1115


22.4 Locality-Sensitive H ashing.................................................................. 1116


22.4.1 Entity Resolution as an Example of LSH ......................... 1117


22.4.2 Locality-Sensitive Hashing of S ignatures............................ 1118


22.4.3 Combining Minhashing and Locality-Sensitive Hashing . . 1121


22.4.4 Exercises for Section 2 2 .4 ......................................................1122


22.5 Clustering of Large-Scale D a t a .........................................................1123


22.5.1 Applications of Clustering......................................................1123


22.5.2 Distance M easures.................................................................. 1125


22.5.3 Agglomerative C lu sterin g ......................................................1128


22.5.4 fc-Means A lgorithm s...............................................................1130


xxxvi TABLE OF CONTENTS


22.5.5 &-Means for Large-Scale D a ta ...............................................1132


22.5.6 Processing a Memory Load of P o in ts.................................. 1133


22.5.7 Exercises for Section 2 2 .5 .....................................................1136


22.6 Summary of Chapter 2 2 .................................................................... 1137


22.7 References for Chapter 2 2 ................................................................. 1139


23 D atabase System s and th e Internet 1141


23.1 The Architecture of a Search E n g in e...............................................1141


23.1.1 Components of a Search Engine............................................1142


23.1.2 Web Crawlers...........................................................................1143


23.1.3 Query Processing in Search E n g in e s.................................. 1146


23.1.4 Ranking P a g e s ........................................................................1146


23.2 PageRank for Identifying Important Pages..................................... 1147


23.2.1 The Intuition Behind PageRank ........................................ 1147


23.2.2 Recursive Formulation of PageRank — First T r y ............ 1148


23.2.3 Spider Traps and Dead E n d s ...............................................1150


23.2.4 PageRank Accounting for Spider Traps and Dead Ends . 1153


23.2.5 Exercises for Section 2 3 .2 .....................................................1154


23.3 Topic-Specific PageR ank.................................................................... 1156


23.3.1 Teleport S e t s ...........................................................................1156


23.3.2 Calculating A Topic-Specific P a g e R a n k ............................1158


23.3.3 Link Spam ..............................................................................1159


23.3.4 Topic-Specific PageRank and Link Spam ............................1160


23.3.5 Exercises for Section 2 3 .3 .....................................................1161


23.4 Data S tream s....................................................................................... 1161


23.4.1 Data-Stream-Management System s..................................... 1162


23.4.2 Stream A pplications.............................................................. 1163


23.4.3 A Data-Stream Data M odel..................................................1164


23.4.4 Converting Streams Into R elations..................................... 1165


23.4.5 Converting Relations Into S trea m s..................................... 1166


23.4.6 Exercises for Section 2 3 .4 .....................................................1168


23.5 Data Mining of S tre a m s.................................................................... 1169


23.5.1 Motivation ..............................................................................1169


23.5.2 Counting B its...........................................................................1171


23.5.3 Counting the Number of Distinct E lem en ts......................1175


23.5.4 Exercises for Section 2 3 .5 .....................................................1176


23.6 Summary of Chapter 2 3 .................................................................... 1177


23.7 References for Chapter 2 3 ................................................................. 1179


Index 1183