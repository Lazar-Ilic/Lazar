Acknowledgments xxv

"First, all glory and praise go to God, who through His Son makes all things possible, and gives us the gift of eternal life." See I am an atheist in a good mood so this sort of a thing just elicits a mild chuckle from me I mean kekkorino tier content. No grating, agitating, or sneering. I personally am more prone to being the type of dude dedicate every single work to my wifey once I find 1.

Introduction xxvii

Like all books in the Bible series...

Part I The Linux Command Line

OK I always thought that some like light weight Ubuntu Linux distribution worked fine for most folks who do not want to use Windows.

Chapter 1: Starting With Linux Shells 3



What Is Linux? 3



Looking Into The Linux Kernel 4



The GNU Utilities 12



The Linux Desktop Environment 14



Linux Distributions 20



Core Linux Distributions 21



Specialized Linux Distributions 22



The Linux LiveCD 23



Summary 24

This chapter discussed where the Linux system came from and how it works. The Linux kernel is the core of the system, controlling how memory, programs, and hardware all interact with each other. The GNU utilities are also an important piece in the Linux system. The Linux shell, which is the main focus of this book, is part of the GNU core utilities. The chapter also discussed the final piece of a Linux system, the Linux desktop environment. Things have changed over the years, and Linux now supports several graphical desktop environments. Next, the chapter talked about the various Linux distributions. A Linux distribution bundles the various parts of a Linux system into a simple package that you can easily install on your PC. The Linux distribution world consists of full-blown Linux distributions that include just about every application imaginable, as well as specialized Linux distributions that only include applications focused on a special function. The Linux LiveCD craze has created another group of Linux distributions that allow you to easily test drive Linux without even having to install it on your hard drive.

Chapter 2: Getting To The Shell 25



Terminal Emulation 25

Interesting. History.

Yeah of course one immediately begins to wonder about these Character Sets in the context of low latency High Frequency Trading systems machines reading input from an Execution Enginge and how to precisely structure the Operating System on such systems so as to minimise whatever latency maximise useful throughput especially with respect to say tickers and indicators and whatever precise details might come through.

Graphics Capabilities 27



The Keyboard 30



The Term Info Database 31



The Linux Console 35



The xterm Terminal 36



Command Line Parameters 37



The xterm Main Menu 38



The VT Options Menu 41



The VT Fonts Menu 43



The Konsole Terminal 45



Command Line Parameters 45



Sessions 45



The Menu Bar 48

Not gonna lie this part here seems totally useless to me at the current point in time but may one day be useful. Dunno how it is that we clock things and run tests at trading firms but I thought we could easily clock remotely on the relevant systems as needed.

The GNOME Terminal 52



The Command Line Parameters 52



Tabs 53



The Menu Bar 54



Summary 58



Chapter 3: Basic Bash Shell Commands 59

The default shell used in all Linux distributions is the GNU bash shell. This chapter describes the basic features available in the bash shell, and walks you through how to work with Linux files and directories using the basic commands provided by the bash shell. If you're already comfortable working with files and directories in the Linux environment, feel free to skip this chapter and continue with Chapter 4 to see more advanced commands.

Starting The Shell 59



The Shell Prompt 60



The Bash Manual 63



File System Navigation 64

Yeah yeah and I do this sometimes like when you need to execute a Command Line Git push and it is annoying.

The Linux File System 64



Traversing Directories 66



File And Directory Listing 69



Basic Listing 69



Modifying The Information Presented 71



The Complete Parameter List 72



Filtering Listing Output 74



File Handling 75



Creating Files 75



Copying Files 76



Linking Files 79



Renaming Files 80



Deleting Files 81



Directory Handling 82



Creating Directories 82

Seems like a useful thing to be doing and these little examples are so so so instructive, critical, and pedagogical. We need more examples! Longer book! More examples!

Deleting Directories 82

OK I think this is all potentially very useful.

Viewing File Contents 83

Right.

Viewing File Statistics 84

Right.

Viewing The File Type 84

Right.

Viewing The Whole File 85

Right maybe I copy and paste all of the segments and examples into an auxiliary file to review regularly and cold mem memorise.

Viewing Parts Of A File 89



Summary 90



Chapter 4: More Bash Shell Commands 91



Monitoring Programs 91



Peeking At The Processes 91

Right.

Real-Time Process Monitoring 98



Stopping Processes 101



Monitoring Disk Space 104



Mounting Media 104



Using The df Command 108



Using The du Command 109



Working With Data Files 110



Sorting Data 110

Right this is mildly interesting that the book really fails to explicate what precisely it was that was going on here I mean I see that the numeric sort is useful as well as obviously the random sort would come in very useful but it does not actually state the algorithm if it is an O[n] or O[n log n] sorting algorithm here... for Interviews it is always good to brush up on all sorting algorithms and Interviews sorting algorithms tasks.

Searching For Data 114



Compressing Data 116



Archiving Data 120

Right the old .tar and tar interesting. So I guess they used to like find some fossils archived stored in literal tar or something and this Linus Linux guy maybe thought that was like an apt name for this command or something?

Summary 121

This chapter discussed some of the more advanced bash commands used by Linux system administrators and programmers. The ps and top commands are vital in determining the status of the system, allowing you to see what applications are running and how many resources they are consuming.

In this day of removable media, another popular topic for system administrators is mounting storage devices. The mount command allows you to mount a physical storage device into the Linux virtual directory structure. To remove the device, use the umount command.

Finally, the chapter discussed various utilities used for handling data. The sort utility easily sorts large data files to help you organize data, and the grep utility allows you to quickly scan through large data files looking for specific information. There are a few different file compression utilities available in Linux, including bzip2, gzip, and zip. Each one allows you to compress large files to help save space on your filesystem. The Linux tar utility is a popular way to archive directory structures into a single file that can easily be ported to another system.

The next chapter discusses Linux environment variables. Environment variables allow you to access information about the system from your scripts, as well as provide a convenient way to store data within your scripts.

Chapter 5: Using Linux Environment Variables 123



What Are Environment Variables? 123



Global Environment Variables 124



Local Environment Variables 125



Setting Environment Variables 127



Setting Local Environment Variables 127



Setting Global Environment Variables 129



Removing Environment Variables 129



Default Shell Environment Variables 130



Setting The PATH Environment Variable 134



Locating System Environment Variables 135

OK

Login Shell 136

This right here is some extreme elite hacker type shit this some fucking Tron Legacy opening scenes sequence when he is about to get in.

Interactive Shell 139



Non-Interactive Shell 141



Variable Arrays 142



Using Command Aliases 143



Summary 144



Chapter 6: Understanding Linux File Permissions 147



Linux Security 147



The /etc/passwd File 148



The /etc/shadow File 150



Adding A New User 150



Removing A User 153



Modifying A User 154

This book is a fucking bloated auto bio novel about some dude named Linus and his dumb Operating System we apparently all use to execute Trades on.

Using Linux Groups 157



The /etc/group File 157



Creating New Groups 158



Modifying Groups 159



Decoding File Permissions 160



Using File Permission Symbols 160



Default File Permissions 161



Changing Security Settings 163

Oh fantastic baby.

Changing Permissions 163



Changing Ownership 165



Sharing Files 166



Summary 168

OK

Chapter 7: Working With Editors 171



The vim Editor 171

Ah I think like Evan Chen, et al. talk about this one maybe like Andrew He, Alexander Bourzutschky too... weird stuff.

The Basics Of vim 172

Yeah yeah yeah who cares we Microsoft Visual Studio Code gang.

Editing Data 174



Copy And Paste 174



Search And Substitute 175



The emacs Editor 176

Heard of this one maybe in The Social Network or something. Man dude some kids only a know about old technology through films like Steve Jobs need to see that stuff in real life some old clunky clunks. An Apple colourful plastic gizmo whizz machine think a back in the old days kids would be it was like a fucking shitty 480 monitour so nothing surreal in the slightest now 8k colour sensitive is truly very very very different user experience.

Using emacs On The Console 176



Using emacs In X Windows 181



The KDE Family Of Editors 183



The KWrite Editor 183



The Kate Editor 189



The GNOME Editor 191



Starting gedit 191



Basic gedit Features 192



Setting Preferences 193

Hmm very exceedingly interesting and fascinating topic to be sure. Colourless colours once in fashion soon to be re discovered.

Summary 197



Part II Shell Scripting Basics



Chapter 8: Basic Script Building 201



Using Multiple Commands 201



Creating A Script File 202



Displaying Messages 204



Using Variables 206



Environment Variables 206

Seems very seriously deeply important.

User Variables 207

Seems very seriously deeply important.

The Backtick 209



Redirecting Input And Output 210



Output Redirection 211



Input Redirection 211



Pipes 213



Performing Math 216



The expr Command 216



Using Brackets 218



A Floating-Point Solution 219



Exiting The Script 223



Checking The Exit Status 223



The Exit Command 225



Summary 226



Chapter 9: Using Structured Commands 229



Working With The If-Then Statement 229



The If-Then-Else Statement 232



Nesting Ifs 232



The Test Command 233



Numeric Comparisons 234



String Comparisons 236

OK

File Comparisons 241



Compound Condition Testing 249



Advanced If-Then Features 250



Using Double Parentheses 250



Using Double Brackets 251



The Case Command 252



Summary 253

Damn my shoulders today are just really extra special saucy juicy feeling like boulders today rock solid hot stones of straight fire striations blood flowing through my veins got a little map of my vascularity on my shoulders. And my Right leg veins are starting to pop much more too.

Chapter 10: More Structured Commands 255



The For Command 255



Reading Values In A List 256



Reading Complex Values In A List 257



Reading A List From A Variable 259



Reading Values From A Command 260



Changing The Field Separator 261

OK need to go back to those Parallel tasks from Dr. Calvin Lin's book after this book I think actually is what is best next up. Someone need to just throw up a 100 tasks set on a system platform some Green checks and a Leaderboard so I can go Rank 1 that and certified cerify my own comprehensive depths of comprehensions of the comprehension of Parallel Algorithms and C++/C praxes.

Reading A Directory Using Wildcards 262



The C-Style for Command 264



The C Language for Command 264



Using Multiple Variables 266



The while Command 266



Basic while Format 267



Using Multiple Test Commands 268



The until Command 269



Nesting Loops 271



Looping On File Data 273



Controlling The Loop 274



The break command275



The continue Command278



Processing the Output of a Loop281



Summary 282



Chapter 11: Handling User Input 285



Command Line Parameters 285



Reading parameters 285



Reading The Program Name 288



Testing Parameters 289



Special Parameter Variables 290



Counting Parameters 290



Grabbing All The Data 292



Being Shifty 293



Working With Options 295

Ah finally Options love me some Options bro Derivatives bro take the derivative and derive the fundamental approximation for the Black-Scholes bro update on the markets via the firm's codebase and apparatus and centaur style some options bro fully automated bro Options... market making.

Finding Your Options 295



Using The getopt Command 299



The More Advanced getopts 302



Standardizing Options 304



Getting User Input 305



Basic Reading 306



Timing Out 307



Silent Reading 308



Reading From A File 309



Summary 310



Chapter 12: Presenting Data 313



Understanding Input And Output 313

OK

Standard File Descriptors 314



Redirecting Errors 316



Redirecting Output In Scripts 318



Temporary Redirections 318



Permanent Redirections 319



Redirecting Input In Scripts 320



Creating Your Own Redirection 321



Creating Output File Descriptors 321

OK.

Redirecting File Descriptors 322



Creating Input File Descriptors 323



Creating A read/write File Descriptor 323



Closing File Descriptors 324



Listing Open File Descriptors 326



Suppressing Command Output 328



Using Temporary Files 328

So the thing is I am not totally sure like I am fairly confident that I do not understand why it is the case that trading firms insist on talking about Linux... so like what do I need to know? What is relevant?

With respect to this stuff here it is not quite clear in this book where precisely these memories lie and what their lookup time is or how to directly program nearly optimal allocations to various caches and Random Access Memories so... I dunno would need to know more system specifics to really get the point and picture here. Like understanding that like the stream is huge and in a live trading session on execution engines only so much big data output can be stored as well as live updating stuff in various memories.

Creating A Local Temporary File 329



Creating A Temporary File In /tmp 330

OK

Creating A Temporary Directory 331

OK

Logging Messages 332



Summary 333



Chapter 13: Script Control 335



Handling Signals 335



Linux Signals Revisited 335



Generating Signals 336



Trapping Signals 338



Trapping A Script Exit 339



Removing A Trap 340

OK.

Running Scripts In Background Mode 341



Running In The Background 341



Running Multiple Background Jobs 342



Exiting the terminal 343



Running Scripts Without A Console 343

OK.

Job Control 344



Viewing Jobs 345



Restarting Stopped Jobs 347



Being Nice 348

OK finally we talk about the kernel. And assigning Central Processing Unit time for each process running on the system.

OK the scheduling priority is apparently an integer value from -20 to 20 and by default all processes start with a priority of 0. OK so unclear how costly the nice operation command itself is. But OK see with a firm what precisely is going on when running our software or whatever.

The Nice Command 348

OK

The renice command 349

OKOK but like ensure to not be a total clown donkey donk here or somehow fail to be nearly optimal in obvious ways strictly dominating ways yadda tasks scheduling and so on and so on priority dependent dependancy graphs and so on. What we discover and how we update and re shift around the priorities.

Running Like Clockwork 349



Scheduling A Job Using The At Command 350



Using The Batch Command 352



Scheduling Regular Scripts 353

OK. Regular prescriptions coming right up.

Start At The Beginning 355



Starting Your Scripts At Boot 355

OK.

Starting With A New Shell 357

A+. I already of course knew about the .bashrc file.

Summary 358

The Linux system allows you to control your shell scripts by using signals. The bash shell accepts signals, and passes them on to any process running under the shell process. Linux signals allow you to easily kill a runaway process or temporarily pause a long-running process.

You can use the trap statement in your scripts to catch signals and perform commands. This feature provides a simple way to control whether a user can interrupt your script while it's running.

By default, when you run a script in a terminal session shell, the interactive shell is suspended until the script completes. You can cause a script or command to run in background mode by adding an ampersand sign (&) after the command name. When you run a script or command in background mode, the interactive shell returns, allowing you to continue entering more commands. Any background processes run using this method are still tied to the terminal session. If you exit the terminal session, the background processes also exit.

To prevent this from happening, use the nohup command. This command intercepts any signals intended for the command that would stop it, for example, when you exit the terminal session. This allows scripts to continue running in background mode even if you exit the terminal session.

When you move a process to background mode, you can still control what happens to it. The jobs command allows you to view processes started from the shell session. Once you know the job ID of a background process, you can use the kill command to send Linux signals to the process, or use the fg command to bring the process back to the foreground in the shell session. You can suspend a running foreground process by using the Ctrl-Z key combination, then place it back in background mode using the bg command.

The nice and renice commands allow you to change the priority level of a process. By giving a process a lower priority, you allow the CPU to allocate less time to it. This comes in handy when running long processes that can take lots of CPU time.

Besides controlling processes while they're running, you can also determine when a process starts on the system. Instead of running a script directly from the command line interface prompt, you can schedule the process to run at an alternative time. There are several different ways to accomplish this. The at and batch commands allow you to run a script once at a preset time. The cron program provides an interface that can run scripts at a regularly scheduled interval.

Finally, the Linux system provides script files for you to use for scheduling your scripts to run either at system boot time or whenever a user starts a new bash shell. The rc.local (or boot.local for openSuse) file allows you to list scripts that start each time the system boots. This allows system administrators to run special scripts for system maintenance at boot time. Similarly, the .bash profile and .bashrc files are located in every user's home directory to provide a location to place scripts and commands that run with a new shell. The .bash profile file runs scripts each time a user logs in to the system, and the .bashrc file runs scripts on each new shell instance.

In the next chapter, we'll look at how to write script functions. Script functions allow you to write code blocks once, then use them in multiple locations throughout your script.

Part III Advanced Shell Scripting

Oh good finally the advanced stuff.

Chapter 14: Creating Functions 363



Basic Script Functions 363



Creating A Function 364



Using Functions 364



Returning A Value 366



The Default Exit Status 367



Using The Return Command 368



Using Function Output 369

Fantastic fantastic fantastic fantastic elastic elastic elastic elastic ring ding dong ding ding dong ding ding a ding ding a ding a ding ding butterfly...

Using Variables In Functions 369

Put your hands up and get ya drinks up now put your hands up put your hands up boo doo doo doo doo.

Passing Parameters To A Function 370

Bro I can pass a para meter to a para meter make an "autistic" verbose 100 page tract rant verbose verbose Astral Anus X post appear on the topic of my upcoming News Feed application bro.

Handling Variables In A Function 372



Array Variables And Functions 375



Passing Arrays To Functions 375



Returning Arrays From Functions 376



Function Recursion 377



Creating A Library 379

Mmm fascinating I thought that those dudes at Library Genesis already did this... a library was it? Did Borges write that one must read through the entire library of every single sequence in order of length and then lexicographic order to truly know everything? Look I know the first 1000 digits of the Natural Numbers bro 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, ...

Fascinating stuff really libraries.

Using Functions On The Command Line 381

OK

Creating Functions On The Command Line 381



Defining Functions In The bashrc File 382



Summary 384



Chapter 15: Adding Color To Scripts 385



Creating Text Menus 385



Create The Menu Layout 386

OK

Create The Menu Functions 387



Add The Menu Logic 388



Putting It All Together 389



Using The Select Command 390



Adding Color 391



The ANSI Escape Codes 392



Displaying ANSI Escape Codes 393

OK

Using Colors In Scripts 395

OK

Doing Windows 397



The Dialog Package 397



The Dialog Options 404

Oh good more Options and more Dialogue Dialog this is what we need the Die A Log and the dialogical logical aspects of it. What will my computer tell me today? I like my machine.

Using The Dialog Command In A Script 407

OK

Getting Graphic 409

Oh good graphic ultra violence.

The KDE Environment 409



The GNOME Environment 412



Summary 417



Chapter 16: Introducing Sed And Gawk 419



Text Manipulation 419

OK

The Sed Editor 420

OK

The gawk program 423



The sed Editor Basics 430



More Substitution Options 430



Using Addresses 432



Deleting Lines 434

OK

Inserting And Appending Text 436



Changing Lines 438

OK

The Transform Command 439



Printing Revisited 440



Using Files With Sed 442

OK

Summary 445



Chapter 17: Regular Expressions 447

GAWK GAWK GAWK GAWK blicky blicky icky sticky esko he a tricky trippy. I tell a ninja don't blick ride...

What Are Regular Expressions? 447

OK this actually comes up a ton in interviews.

A Definition 447



Types Of Regular Expressions 448

OK this also comes up in interviews quite a lot really.

Defining BRE Patterns 449



Plain Text 449



Special Characters 451



Anchor Characters 452



The Dot Character 454



Character Classes 455



Negating Character Classes 457



Using Ranges 458



Special Character Classes 459



The Asterisk 460



Extended Regular Expressions 461



The Question Mark 461



The Plus Sign 462



Using Braces 463



The Pipe Symbol 464



Grouping Expressions 465



Regular Expressions In Action 466

OK

Counting Directory Files 466



Validating A Phone Number 467



Parsing An E-Mail Address 469



Summary 471

If you manipulate data files in shell scripts, you'll need to become familiar with regular expressions. Regular expressions are implemented in Linux utilities, programming languages, and applications using regular expression engines. There are a host of different regular expression engines available in the Linux world. The two most popular are the POSIX Basic Regular Expression (BRE) engine, and the POSIX Extended Regular Expression (ERE) engine. The sed editor conforms mainly to the BRE engine, while the gawk program utilizes most features found in the ERE engine.

A regular expression defines a pattern template that's used to filter text in a data stream. The pattern consists of a combination of standard text characters and special characters. The special characters are used by the regular expression engine to match a series of one or more characters, similarly to how wildcard characters work in other applications.

By combining characters and special characters, you can define a pattern to match most any type of data. You can then use the sed editor or gawk program to filter specific data from a larger data stream, or for validating data received from data entry applications.

The next chapter digs deeper into using the sed editor to perform advanced text manipulation. There are lots of advanced features available in the sed editor that make it useful for handling large data streams and filtering out just what you need.

Chapter 18: Advanced sed 473



Multiline Commands 473

OK

The Next Commands 474



The Multiline Delete Command 477

OK

The Multiline Print Command 479



The Hold Space 479



Negating A Command 481



Changing The Flow 484

OK

Branching 484

OK

Testing 486



Pattern Replacement 487

OK this is also important for interviews rounds.

The Ampersand 488

OK

Replacing Individual Words 488



Using sed In Scripts 489



Using Wrappers 489



Redirecting Sed Output 490

OK

Creating Sed Utilities 491



Double Spacing Lines 491



Double Spacing Files That May Have Blanks 492



Numbering Lines In A File 493

OK

Printing Last Lines 494



Deleting Lines 495

OK

Removing HTML Tags 497



Summary 499



Chapter 19: Advanced Gawk 501



Using Variables 501



Built-In Variables 502



User-Defined Variables 508



Working With Arrays 510

OK

Defining Array Variables 510



Iterating Through Array Variables 511

OK

Deleting Array Variables 511



Using Patterns 512



Regular Expressions 512



The Matching Operator 513

OK

Mathematical Expressions 514

OK

Structured Commands 514



The If Statement 514



The While Statement 516



The Do-While Statement 518



The For Statement 518



Formatted Printing 519

OK

Built-In Functions 522

OK

Mathematical Functions 522



String Functions 524



Time Functions 526



User-Defined Functions 527



Defining A Function 527

OK

Using Your Functions 528



Creating A Function Library 528



Summary 529

OK

Part IV Alternative Linux Shells



Chapter 20: The Ash Shell 533

OK

What Is The Ash Shell? 533



The Original Ash Shell 534

OK I might need to study the kernel too after doing those Parallel tasks.

The Original Ash Command Line Parameters 534



The Original Ash Built-In Commands 536



The Ash Shell Files 539



The Dash Shell 540



The Dash Command Line Parameters 540



The Dash Environment Variables 540



The Dash Built-In Commands 544



Scripting In Dash 549

OK

Creating Ash And Dash Scripts 549



Things That Won't Work 549

Oh no the things that will not work!

Summary 555



Chapter 21: The tcsh Shell 557

OK

What Is The tcsh Shell? 557



The tcsh Shell Components 558



The tcsh Command Line Parameters 558



The tcsh Files 560



The tcsh Login Files 560



Shell Startup Files 561

OK

The Logout Files 562

OK

The tcsh Environment Variables 563



Shell Variables 563



Environment Variables 569



Setting Variables In tcsh 572

OK

Using The Set Command 572



Using The setenv Command 573



The tcsh Built-In Commands 574



Scripting In tcsh 577



Working With Variables 578

OK

Array Variables 578



Handling Mathematical Operations 578

OK

Structured Commands 578



The If Statements 579



The foreach Statement 582



The While Statement 582



The Switch Command 583



Summary 584



Chapter 22: The Korn Shell 587



The Korn Shell History 587



The Parts Of The ksh93 Shell 588

OK

Command Line Parameters 588

OK

Default Files 590

OK

Environment Variables 590

OK

Built-In Commands 597

OK

Scripting In The ksh93 Shell 602



Mathematical Operations 602

OK

Structured Commands 605



Command Redirection 607



Discipline Functions 608

OK

Summary 609



Chapter 23: The zsh Shell 611



History Of The zsh Shell 611



Parts Of The zsh Shell 612



Shell Options 612



The zsh Shell Files 615



Environment Variables 619

OK

Built-In Commands 625



Scripting With zsh 631

OK

Mathematical Operations 631



Structured Commands 633

OK

Functions 634



Summary 636



Part V Advanced Topics



Chapter 24: Using A Database 639

OK

The MySQL Database 639



Installing MySQL 640



Completing The MySQL Configuration 642

OK

The MySQL Client Interface 644

OK

Creating MySQL Database Objects 649

OK

The PostgreSQL Database 651



Installing PostgreSQL 652



The PostgreSQL Command Interface 654

OK

Creating PostgreSQL Database Objects 657

OK

Working With Tables 659



Creating A Table 659

OK

Inserting And Deleting Data 661

OK

Querying Data 663



Using The Database In Your Scripts 664



Connecting To The Databases 664



Sending Commands To The Server 666



Formatting Data 670



Summary 671

This chapter discussed the ability to save, modify, and retrieve data from your shell scripts in databases. You can easily access both the MySQL and PostgreSQL database servers directly from your shell scripts.

After installing the MySQL and PostgreSQL servers, you can use their respective client programs to access the servers from the command line, or from shell scripts. The mysql client program provides the command line interface to the MySQL server. You can send SQL commands as well as customized MySQL commands to the server from your shell scripts, then retrieve the results.

The psql client program operates the same way for the PostgreSQL server. There are plenty of command line parameters you can use to help format your data in just the right way.

Both client programs allow you to send either a single command to the server, or use input redirection to send a batch of commands. The programs normally send the output data from the server to STDOUT, but you can redirect the output to a variable, and use that information in your shell script.

The next chapter examines the World Wide Web. Getting your shell scripts to interface with Web sites on the Internet is a tricky task, but once you master it the world is yours to retrieve data from.

Chapter 25: Using The Web 673



The Lynx Program 673

I did not realise that when Dorothy got to the University Of Kansas or whatever they found machines there... they have machines in Kansas?

Installing Lynx 674

Oh good we install the links and link it up lion style with the minx dragging on the floor so tell Peter or PETA.

The Lynx Command Line 675

Fascinating stuff with raw HTML.

The Lynx Configuration File 676



The Lynx Environment Variables 683

OK

Capturing Data From Lynx 684



The cURL Program 687



Installing cURL 687



The cURL Command Line 688



Exploring With Curl 688



Networking With zsh 694

OK

The TCP Module 694

OK

The Client/Server Paradigm 695



Client/Server Programming With zsh 695



Summary 699

This chapter walked you through the world of interfacing shell scripts to the Internet. One of the most popular tools for doing that is the Lynx program. Lynx is a command line program that can display Web site information in a terminal session using text-mode graphics. Besides that feature, Lynx also provides a way to retrieve just the raw data from a Web site, and display it to STDOUT. You can use Lynx to extract data from a Web site, then parse the data using standard Linux text-handling tools such as sed and gawk to find specific information.

The cURL program is another handy tool to have when interfacing with the Internet. The cURL program also allows you to dump data from a Web site, and it also provides a way to easily script file downloads from many different types of servers.

Finally, the chapter showed you how to use the TCP module of the zsh shell to write your own network programs. The zsh shell provides an easy way to communicate between shell scripts that are located on separate systems on the network, just as easily as reading and writing data to a file.

In the next chapter, we'll examine how to utilize e-mail in your shell scripts. Often when you use shell scripts to automate processes, it's nice to get a message indicating if the process failed or succeeded. By knowing how to work with the installed e-mail software on your system, you can easily send automated messages to anyone in the world.

Chapter 26: Using E-Mail 701



The Basics Of Linux E-Mail 701



E-Mail In Linux 701



The Mail Transfer Agent 702



The Mail Delivery Agent 703



The Mail User Agent 705



Setting Up Your Server 708

OK

sendmail 709



Postfix 711



Sending A Message With Mailx 717



The Mutt Program 720

OK

Installing Mutt 720

OK

The Mutt Command Line 721



Using Mutt 721



Summary 723



Chapter 27: Shell Scripts For Administrators 725



Monitoring System Statistics 725



Monitoring Disk Free Space 725



Catching Disk Hogs 728

OK

Watching CPU And Memory Usage 732

OK

Performing Backups 739



Archiving Data Files 740



Storing Backups off-site 744



Summary 746



Appendix A: Quick Guide To Bash Commands 749



Built-In Commands 749

OK seems useful.

Bash Commands 749

OK possibly very useful. This comes up in interviews sometimes.

Environment Variables 753

OK

Appendix B: Quick Guide To sed And gawk 759



The sed Editor 759



Starting The sed Editor 759



sed Commands 760



The gawk Program 764



The gawk Command Format 764



Using gawk 765



The gawk Variables 766



The gawk Program Features 768



Appendix C: Comparing Shells 771

OK

Variables 771

OK

Environment Variables 771



User-Defined Variables 772



Array Variables 772



Structured Commands 773



The if-then, while, And Until Statements 773



The for Statement 774



Mathematical Operations 775

OK seems legit.

Index 777

Legitimate book I guess... might reference it once in a while.
